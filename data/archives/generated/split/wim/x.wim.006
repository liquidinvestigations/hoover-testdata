TimerProcessing disableTimerProcessing1(g_App.Panels[0]);
  CPanel::CDisableTimerProcessing disableTimerProcessing2(g_App.Panels[1]);

  switch (commandID)
  {
    case kMenuCmdID_Toolbar_Add: g_App.AddToArchive(); break;
    case kMenuCmdID_Toolbar_Extract: g_App.ExtractArchives(); break;
    case kMenuCmdID_Toolbar_Test: g_App.TestArchives(); break;
  }
}

static void local_WM_CREATE(HWND hWnd)
{
printf("**local_WM_CREATE**\n");

      int xSizes[2] = { 0,0 };

      // g_App.CreateDragTarget();
      bool archiveIsOpened;
      bool encrypted;
      bool needOpenFile = false;
      if (!g_MainPath.IsEmpty() /* && g_OpenArchive */)
      {
        if (NFile::NFind::DoesFileExist(us2fs(g_MainPath)))
          needOpenFile = true;
      }
      HRESULT res = g_App.Create(hWnd, g_MainPath, g_ArcFormat, xSizes, archiveIsOpened, encrypted);

      if (res == E_ABORT)
      {
        return ; // -1;
      }
      if (needOpenFile && !archiveIsOpened || res != S_OK)
      {
        UString message = L"Error";
        if (res == S_FALSE || res == S_OK)
        {
          message = MyFormatNew(encrypted ?
            IDS_CANT_OPEN_ENCRYPTED_ARCHIVE :
            IDS_CANT_OPEN_ARCHIVE,
            g_MainPath);
        }
        else if (res != S_OK)
          message = HResultToMessage(res);
        ErrorMessage(message);
        return ; // -1;
      }
      // g_SplitterPos = 0;

      // ::DragAcceptFiles(hWnd, TRUE);
      // RegisterDragDrop(hWnd, g_App._dropTarget);
}

#ifdef _WIN32
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  int wmId, wmEvent;
  switch (message)
  {
    case WM_COMMAND:
      wmId    = LOWORD(wParam);
      wmEvent = HIWORD(wParam);
      if ((HWND) lParam != NULL && wmEvent != 0)
        break;
      if (wmId >= kMenuCmdID_Toolbar_Start && wmId < kMenuCmdID_Toolbar_End)
      {
        ExecuteCommand(wmId);
        return 0;
      }
      if (OnMenuCommand(hWnd, wmId))
        return 0;
      break;
    case WM_INITMENUPOPUP:
      OnMenuActivating(hWnd, HMENU(wParam), LOWORD(lParam));
      break;

    /*
    It doesn't help
    case WM_EXITMENULOOP:
      {
        OnMenuUnActivating(hWnd);
        break;
      }
    case WM_UNINITMENUPOPUP:
      OnMenuUnActivating(hWnd, HMENU(wParam), lParam);
      break;
    */

    case WM_CREATE:
    {
      g_HWND = hWnd;
      /*
      INITCOMMONCONTROLSEX icex;
      icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
      icex.dwICC  = ICC_BAR_CLASSES;
      InitCommonControlsEx(&icex);
      
      // Toolbar buttons used to create the first 4 buttons.
      TBBUTTON tbb [ ] =
      {
        // {0, 0, TBSTATE_ENABLED, BTNS_SEP, 0L, 0},
        // {VIEW_PARENTFOLDER, kParentFolderID, TBSTATE_ENABLED, BTNS_BUTTON, 0L, 0},
          // {0, 0, TBSTATE_ENABLED, BTNS_SEP, 0L, 0},
        {VIEW_NEWFOLDER, ID_FILE_CREATEFOLDER, TBSTATE_ENABLED, BTNS_BUTTON, 0L, 0},
      };
      
      int baseID = 100;
      NWindows::NControl::CToolBar aToolBar;
      aToolBar.Attach(::CreateToolbarEx (hWnd,
        WS_CHILD | WS_BORDER | WS_VISIBLE | TBSTYLE_TOOLTIPS, //  | TBSTYLE_FLAT
        baseID + 2, 11,
        (HINSTANCE)HINST_COMMCTRL, IDB_VIEW_SMALL_COLOR,
        (LPCTBBUTTON)&tbb, ARRAY_SIZE(tbb),
        0, 0, 100, 30, sizeof (TBBUTTON)));
      */
      // HCURSOR cursor = ::LoadCursor(0, IDC_SIZEWE);
      // ::SetCursor(cursor);

      if (g_PanelsInfoDefined)
        g_Splitter.SetPos(hWnd, g_SplitterPos);
      else
      {
        g_Splitter.SetRatio(hWnd, kSplitterRateMax / 2);
        g_SplitterPos = g_Splitter.GetPos();
      }

      RECT rect;
      ::GetClientRect(hWnd, &rect);
      int xSize = rect.right;
      int xSizes[2];
      xSizes[0] = g_Splitter.GetPos();
      xSizes[1] = xSize - kSplitterWidth - xSizes[0];
      if (xSizes[1] < 0)
        xSizes[1] = 0;

      g_App.CreateDragTarget();
      
      bool archiveIsOpened;
      bool encrypted;
      bool needOpenFile = false;

      UString fullPath = g_MainPath;
      if (!fullPath.IsEmpty() /* && g_OpenArchive */)
      {
        if (!NFile::NName::IsAbsolutePath(fullPath))
        {
          FString fullPathF;
          if (NFile::NName::GetFullPath(us2fs(fullPath), fullPathF))
            fullPath = fs2us(fullPathF);
        }
        if (NFile::NFind::DoesFileExist(us2fs(fullPath)))
          needOpenFile = true;
      }
      
      HRESULT res = g_App.Create(hWnd, fullPath, g_ArcFormat, xSizes, archiveIsOpened, encrypted);

      if (res == E_ABORT)
        return -1;
      
      if (needOpenFile && !archiveIsOpened || res != S_OK)
      {
        UString message = L"Error";
        if (res == S_FALSE || res == S_OK)
        {
          message = MyFormatNew(encrypted ?
                IDS_CANT_OPEN_ENCRYPTED_ARCHIVE :
                IDS_CANT_OPEN_ARCHIVE,
              fullPath);
        }
        else if (res != S_OK)
          message = HResultToMessage(res);
        ErrorMessage(message);
        return -1;
      }
      
      // g_SplitterPos = 0;

      // ::DragAcceptFiles(hWnd, TRUE);
      RegisterDragDrop(hWnd, g_App._dropTarget);

      break;
    }

    case WM_DESTROY:
    {
      // ::DragAcceptFiles(hWnd, FALSE);
      RevokeDragDrop(hWnd);
      g_App._dropTarget.Release();

      g_App.Save();
      g_App.Release();
      SaveWindowInfo(hWnd);
      PostQuitMessage(0);
      break;
    }
    /*
    case WM_MOVE:
    {
      break;
    }
    */
    case WM_LBUTTONDOWN:
      g_StartCaptureMousePos = LOWORD(lParam);
      g_StartCaptureSplitterPos = g_Splitter.GetPos();
      ::SetCapture(hWnd);
      break;
    
    case WM_LBUTTONUP:
    {
      ::ReleaseCapture();
      break;
    }
    
    case WM_MOUSEMOVE:
    {
      if ((wParam & MK_LBUTTON) != 0 && ::GetCapture() == hWnd)
      {
        g_Splitter.SetPos(hWnd, g_StartCaptureSplitterPos +
            (short)LOWORD(lParam) - g_StartCaptureMousePos);
        g_App.MoveSubWindows();
      }
      break;
    }

    case WM_SIZE:
    {
      if (g_CanChangeSplitter)
        g_Splitter.SetPosFromRatio(hWnd);
      else
      {
        g_Splitter.SetPos(hWnd, g_SplitterPos );
        g_CanChangeSplitter = true;
      }
      
      g_Maximized = (wParam == SIZE_MAXIMIZED) || (wParam == SIZE_MAXSHOW);

      g_App.MoveSubWindows();
      /*
      int xSize = LOWORD(lParam);
      int ySize = HIWORD(lParam);
      // int xSplitter = 2;
      int xWidth = g_SplitPos;
      // int xSplitPos = xWidth;
      g_Panel[0]._listView.MoveWindow(0, 0, xWidth, ySize);
      g_Panel[1]._listView.MoveWindow(xSize - xWidth, 0, xWidth, ySize);
      */
      return 0;
      break;
    }
    
    case WM_SETFOCUS:
      // g_App.SetFocus(g_App.LastFocusedPanel);
      g_App.SetFocusToLastItem();
      break;
    
    /*
    case WM_ACTIVATE:
    {
      int fActive = LOWORD(wParam);
      switch (fActive)
      {
        case WA_INACTIVE:
        {
          // g_FocusIndex = g_App.LastFocusedPanel;
          // g_App.LastFocusedPanel = g_App.GetFocusedPanelIndex();
          // return 0;
        }
      }
      break;
    }
    */
    
    /*
    case kLangWasChangedMessage:
      MyLoadMenu();
      return 0;
    */
      
    /*
    case WM_SETTINGCHANGE:
      break;
    */
    
    case WM_NOTIFY:
    {
      g_App.OnNotify((int)wParam, (LPNMHDR)lParam);
      break;
    }
    
    /*
    case WM_DROPFILES:
    {
      g_App.GetFocusedPanel().CompressDropFiles((HDROP)wParam);
      return 0 ;
    }
    */
  }
  #ifndef _UNICODE
  if (g_IsNT)
    return DefWindowProcW(hWnd, message, wParam, lParam);
  else
  #endif
    return DefWindowProc(hWnd, message, wParam, lParam);

}

static int Window_GetRealHeight(NWindows::CWindow &w)
{
  RECT rect;
  w.GetWindowRect(&rect);
  int res = RECT_SIZE_Y(rect);
  #ifndef UNDER_CE
  WINDOWPLACEMENT placement;
  if (w.GetPlacement(&placement))
    res += placement.rcNormalPosition.top;
  #endif
  return res;
}

void CApp::MoveSubWindows()
{
  HWND hWnd = _window;
  RECT rect;
  if (hWnd == 0)
    return;
  ::GetClientRect(hWnd, &rect);
  int xSize = rect.right;
  if (xSize == 0)
    return;
  int headerSize = 0;
  #ifdef UNDER_CE
  _commandBar.AutoSize();
  {
    _commandBar.Show(true); // maybe we need it for
    headerSize += _commandBar.Height();
  }
  #endif
  if (_toolBar)
  {
    _toolBar.AutoSize();
    #ifdef UNDER_CE
    int h2 = Window_GetRealHeight(_toolBar);
    _toolBar.Move(0, headerSize, xSize, h2);
    #endif
    headerSize += Window_GetRealHeight(_toolBar);
  }
  int ySize = MyMax((int)(rect.bottom - headerSize), 0);
  
  if (NumPanels > 1)
  {
    Panels[0].Move(0, headerSize, g_Splitter.GetPos(), ySize);
    int xWidth1 = g_Splitter.GetPos() + kSplitterWidth;
    Panels[1].Move(xWidth1, headerSize, xSize - xWidth1, ySize);
  }
  else
  {
    /*
    int otherPanel = 1 - LastFocusedPanel;
    if (PanelsCreated[otherPanel])
      Panels[otherPanel].Move(0, headerSize, 0, ySize);
    */
    Panels[LastFocusedPanel].Move(0, headerSize, xSize, ySize);
  }
}
#else
void main_WM_DESTROY()
{    
   // // ::DragAcceptFiles(hWnd, FALSE);
   // RevokeDragDrop(hWnd);
   // g_App._dropTarget.Release();

   g_App.Save();
   g_App.Release();
   // SaveWindowInfo(hWnd);
   // PostQuitMessage(0);
}
#endif


// for mac
void doMacOpenFile(	const UString & fileName	 ) 
{
	g_App.GetFocusedPanel().BindToPathAndRefresh(fileName);
}

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

#include "wx/mimetype.h"
#include "wx/artprov.h"
#include "wx/imaglist.h"

#undef _WIN32
 
#include "resource.h"

#include "PropertyNameRes.h"

#include "App.h"

#include "Windows/Window.h" // FIXME
#include "Windows/Control/DialogImpl.h"
#include "Windows/Control/ListView.h"
#include "Windows/Control/Window2.h"

#define static const
#include "../GUI/p7zip_32.xpm"
#undef static

extern HWND g_HWND;

#define BASE_ID_PANEL_1 (1000 + 100 * 0)
#define BASE_ID_PANEL_2 (1000 + 100 * 1)

////////////////////////////////////// Tool bar images
#include "res/AddPNG.h"
#include "res/Add2PNG.h"
#include "res/ExtractPNG.h"
#include "res/Extract2PNG.h"
#include "res/TestPNG.h"
#include "res/Test2PNG.h"
#include "res/CopyPNG.h"
#include "res/Copy2PNG.h"
#include "res/MovePNG.h"
#include "res/Move2PNG.h"
#include "res/DeletePNG.h"
#include "res/Delete2PNG.h"
#include "res/InfoPNG.h"
#include "res/Info2PNG.h"

#include "LangUtils.h"

#include <wx/mstream.h>
#define wxGetBitmapFromMemory(name) _wxGetBitmapFromMemory(name ## _png, sizeof(name ## _png))

static inline wxBitmap _wxGetBitmapFromMemory(const unsigned char *data, int length) {
	wxMemoryInputStream is(data, length);
	return wxBitmap(wxImage(is, wxBITMAP_TYPE_ANY, -1), -1);
}

///////////////////////////////////// SevenZipPanel.h /////////////////////

#include <wx/listctrl.h>

typedef wxListCtrl CExplorerListCtrl;

class MyFrame;
class myToolBar;

class SevenZipPanel : public wxPanel
{
	static int count;
	
	MyFrame *m_frame;
	
	CExplorerListCtrl *m_pListCtrlExplorer;
	NWindows::NControl::CWindow2 *_wList;
	

	wxBitmapButton *m_pBmpButtonParentFolder;
	wxComboBox *m_pComboBoxPath;
	wxStatusBar *m_pStatusBar;

	wxImageList imgList;

	int _panelIndex;

	// wxString m_currentDirectory;

	// int m_nbDirs;

	// wxString m_prompt;

public:
	SevenZipPanel(MyFrame *frame, wxWindow *parent,int id,int panelIndex);

	void registerWindow2(NWindows::NControl::CWindow2 *w)
	{
		_wList = w;
		_wList->OnMessage(WM_CREATE,0,0);
	}
		
	void OnAnyButton( wxCommandEvent &event );
	void OnSelected(wxListEvent& event);
	void OnDeselected(wxListEvent& event);
	void OnActivated(wxListEvent& event);
	void OnFocused(wxListEvent& event);
	void OnLeftDownBeginDrag(wxListEvent& event);
	void OnRightClick(wxListEvent& event);
	void OnColumnClick(wxListEvent& event);

	void OnLeftDown(wxMouseEvent &event );
	void OnRightDown(wxMouseEvent &event );
	
	void OnTextEnter(wxCommandEvent& event);
	
        void WriteText(const wxString& text) {
		printf("DEBUG : %ls",(const wchar_t *)text);
        }

	/* Don't work ...
	void OnCloseWindow(wxCloseEvent& WXUNUSED(event)) {
		_wList->OnDestroy();
	}
	*/

	void evt_destroy() {
		_wList->OnDestroy();
	}


private:
		DECLARE_EVENT_TABLE()
};



///////////////////////////////////// SevenZipPanel.h /////////////////////



class MyFrame: public wxFrame
{
public:
    // ctor
 MyFrame(void (*fct)(HWND),wxFrame *frame, const wxString& title, int x, int y, int w, int h);
    // virtual ~MyFrame();

	void registerWindow2(int baseID,NWindows::NControl::CWindow2 *w)
	{
		printf("MyFrame::registerWindow2(%d,%p)\n",baseID,w);
		switch (baseID)
		{
			case BASE_ID_PANEL_1: _panel1->registerWindow2(w); break;
			case BASE_ID_PANEL_2: _panel2->registerWindow2(w); break;
			default: printf("FIXME - MyFrame::registerWindow2\n");
		}
	}

	void PopulateToolbar(wxToolBar* toolBar);
	void RecreateToolbar();


protected:
	// callbacks
	void OnWorkerEvent(wxCommandEvent& event);
	void OnAnyMenu(wxCommandEvent& event)
	{
		extern bool OnMenuCommand(HWND hWnd, int id);
		extern void ExecuteCommand(UINT commandID);

		int wmId = event.GetId();

		if (wmId >= kMenuCmdID_Toolbar_Start && wmId < kMenuCmdID_Toolbar_End)
		{
			ExecuteCommand(wmId);
			return ; // 0;
		}
		OnMenuCommand(this, wmId);
	}
	void OnCloseWindow(wxCloseEvent& WXUNUSED(event))
	{
		if (_panel1) _panel1->evt_destroy();
		if (_panel2) _panel2->evt_destroy();

		extern void main_WM_DESTROY();
		main_WM_DESTROY();
		Destroy();
	}
private:
	SevenZipPanel * _panel1;
	SevenZipPanel * _panel2;
	myToolBar     * m_toolBar;
    DECLARE_EVENT_TABLE()
};

BEGIN_EVENT_TABLE(MyFrame, wxFrame)
	EVT_MENU(WORKER_EVENT, MyFrame::OnWorkerEvent)
	EVT_MENU(wxID_ANY, MyFrame::OnAnyMenu)
	EVT_CLOSE(MyFrame::OnCloseWindow)
END_EVENT_TABLE()


static bool TEST_create(HWND hWnd) // FIXME
{
extern HWND g_HWND;
	 CMyListView _listView;
	
	int _baseID = 1000;
	
	HWND w = NWindows::GetDlgItem(g_HWND, _baseID + 1);
	if (w == 0) 
	{
		printf("Can't find id=%d\n",_baseID + 1);
		return false;
	}
	printf("CPanel::OnCreate : _listView.Attach(%p)\n",w);
	_listView.Attach(w);
	
	_listView.SetRedraw(false);
	
	_listView.DeleteAllItems();
	
	_listView.DeleteColumn(1);
		
	_listView.InsertColumn(0, L"toto", 100);
	
//	_listView.SetItemCount(1);

	_listView.InsertItem(0, L"item 1");


	_listView.SetRedraw(true);	
	
	return true;
}

// My frame constructor
MyFrame::MyFrame(void (*wm_create)(HWND),wxFrame *frame, const wxString& title,
                 int x, int y, int w, int h)
       : wxFrame(frame, wxID_ANY, title, wxPoint(x, y), wxSize(w, h))
{
printf("===MyFrame::MyFrame===BEGIN===\n");

	m_toolBar = 0;

	this->SetIcon(wxICON(p7zip_32));
	
	g_HWND = this; // FIXME
	
	SetMinSize(wxSize(800,700));
	
	wxBoxSizer *topsizer = new wxBoxSizer( wxVERTICAL );

	_panel1 = new SevenZipPanel(this,this,BASE_ID_PANEL_1,0);  // FIXME panelIndex = 0
	_panel2 = 0;
	topsizer->Add(
		_panel1,
		1,            // make vertically stretchable
		wxEXPAND |    // make horizontally stretchable
		wxALL,        //   and make border all around
		0 );         // set border width to 10

	// Create the toolbar
	// FIXME RecreateToolbar();
printf("===MyFrame::MyFrame===WM_CREATE===\n");
	wm_create(this);
// FIXME	TEST_create(this);
	
	
       // Create the toolbar // FIXME
	RecreateToolbar();


printf("===MyFrame::MyFrame===SIZER===\n");

	SetSizer( topsizer );      // use the sizer for layout

	topsizer->SetSizeHints( this );   // set size hints to honour minimum size
printf("===MyFrame::MyFrame===END===\n");
}

void myCreateHandle(int n);
void MyFrame::OnWorkerEvent(wxCommandEvent& event)
{
	int n = event.GetInt();
// printf(" MyFrame::OnWorkerEvent(n=%d)\n",n);
	myCreateHandle(n);
}

wxWindow * g_window=0;
HWND myCreateAndShowMainWindow(LPCTSTR title,void (*fct)(HWND))
{
   MyFrame *frame = new MyFrame(fct,(wxFrame *)NULL, title, 40, 40, 800, 600);

   g_window = frame; 
  
   // Don't Show the frame !
   frame->Show(true); // FIXME

   // FIXME : SetTopWindow(g_HWND);

   return frame;
}


class myToolBar
{
	wxToolBar * m_toolbar;

	bool m_bShowText;

public:
	myToolBar(wxToolBar * toolbar,bool bShowText ) : m_toolbar(toolbar), m_bShowText(bShowText)  { }

	myToolBar* AddTool(int toolId, const wxString& label, const wxBitmap& bitmap1, const wxString& shortHelpString = _T(""), wxItemKind kind = wxITEM_NORMAL)
	{
		wxString text = wxEmptyString;
		if (m_bShowText) text = label;

		wxSize tb_size = m_toolbar->GetToolBitmapSize();
		int tb_witdh = tb_size.GetWidth();
		int tb_height = tb_size.GetHeight();

		if ((bitmap1.GetWidth() > tb_witdh) || ( bitmap1.GetHeight()> tb_height))
		{
			wxBitmap bmp(bitmap1.ConvertToImage().Scale(tb_witdh, tb_height));
			m_toolbar->AddTool(toolId,text,bmp,shortHelpString,kind);
		}
		else
		{
			m_toolbar->AddTool(toolId,text,bitmap1,shortHelpString,kind);
		}

		return this;
	}

	void SetToolBitmapSize(const wxSize& size)
	{
		m_toolbar->SetToolBitmapSize(size);
	}

	bool Realize()
	{
		return m_toolbar->Realize();
	}

	void AddSeparator() { m_toolbar->AddSeparator(); }
};

void MyFrame::PopulateToolbar(wxToolBar* p_toolBar)
{/*
 toolBar->AddTool(wxID_NEW, _T("New"),toolBarBitmaps[Tool_new], wxNullBitmap, wxITEM_NORMAL,
 _T("New file"), _T("This is help for new file tool"));
 */
   m_toolBar = new myToolBar(p_toolBar,true);

   const int kWidth  = 24;
   const int kHeight = 24;

	
   UString msg;

   // FIXME toolBar->SetToolBitmapSize(wxSize(24,24));
   m_toolBar->SetToolBitmapSize(wxSize(kWidth,kHeight));

    msg = LangString(IDS_ADD); //  kMenuCmdID_Toolbar_Add,     IDB_ADD,     IDB_ADD2,     IDS_ADD },
    if (msg == L"") msg = L"Add";
	m_toolBar->AddTool(kMenuCmdID_Toolbar_Add, (const wchar_t *)msg, wxGetBitmapFromMemory(ADD2));
	
    msg = LangString(IDS_EXTRACT); // { kMenuCmdID_Toolbar_Extract, IDB_EXTRACT, IDB_EXTRACT2, IDS_EXTRACT },
    if (msg == L"") msg = L"Extract";	
	m_toolBar->AddTool(kMenuCmdID_Toolbar_Extract,(const wchar_t *)msg, wxGetBitmapFromMemory(EXTRACT2));
	
    msg = LangString(IDS_TEST); // { kMenuCmdID_Toolbar_Test,    IDB_TEST,    IDB_TEST2,    IDS_TEST }
    if (msg == L"") msg = L"Test";	
   m_toolBar->AddTool(kMenuCmdID_Toolbar_Test,(const wchar_t *)msg, wxGetBitmapFromMemory(TEST2));
	
   m_toolBar->AddSeparator();

    msg = LangString(IDS_BUTTON_COPY); // { IDM_COPY_TO,    IDB_COPY,   IDB_COPY2,   IDS_BUTTON_COPY },
    if (msg == L"") msg = L"Copy";		
    m_toolBar->AddTool(IDS_BUTTON_COPY, (const wchar_t *)msg, wxGetBitmapFromMemory(COPY2));
	
    msg = LangString(IDS_BUTTON_MOVE); // { IDM_MOVE_TO,    IDB_MOVE,   IDB_MOVE2,   IDS_BUTTON_MOVE }
    if (msg == L"") msg = L"Move";		
    m_toolBar->AddTool(IDM_MOVE_TO, (const wchar_t *)msg, wxGetBitmapFromMemory(MOVE2));
	
    msg = LangString(IDS_BUTTON_DELETE); // { IDM_DELETE,     IDB_DELETE, IDB_DELETE2, IDS_BUTTON_DELETE } ,
    if (msg == L"") msg = L"Delete";	
    m_toolBar->AddTool(IDM_DELETE, (const wchar_t *)msg, wxGetBitmapFromMemory(DELETE2));
	
    msg = LangString(IDS_BUTTON_INFO); // { IDM_PROPERTIES, IDB_INFO,   IDB_INFO2,   IDS_BUTTON_INFO }
    if (msg == L"") msg = L"Info";	
    m_toolBar->AddTool(IDM_PROPERTIES, (const wchar_t *)msg, wxGetBitmapFromMemory(INFO2));

#if 0
	////////////////////////////////////////////////////////

	/* FIXME
	if (g_mimeDatabase)
	{
		toolBar.AddSeparator();

		TryMime(&toolBar, _T("txt"));
		TryMime(&toolBar, _T("rar"));
		TryMime(&toolBar, _T("7z"));
	}

	toolBar.AddSeparator();

	wxIcon i_plus = wxArtProvider::GetIcon(wxART_ADD_BOOKMARK    , wxART_TOOLBAR  , wxSize(kWidth,kHeight));
	m_toolBar->AddTool(wxID_ANY, wxT("Add Bookmark"), i_plus);

	wxIcon i_go_up_dir = wxArtProvider::GetIcon(wxART_GO_DIR_UP   , wxART_TOOLBAR  , wxSize(kWidth,kHeight));
	m_toolBar->AddTool(wxID_ANY, wxT("Go up dir"), i_go_up_dir);

	wxIcon i_folder = wxArtProvider::GetIcon(wxART_FOLDER   , wxART_TOOLBAR  , wxSize(kWidth,kHeight));
	m_toolBar->AddTool(wxID_ANY, wxT("Folder"), i_folder);

	wxIcon i_missing_image = wxArtProvider::GetIcon(wxART_MISSING_IMAGE   , wxART_TOOLBAR  , wxSize(kWidth,kHeight));
	m_toolBar->AddTool(wxID_ANY, wxT("missing image"), i_missing_image);
	*/

	///////////////////////////////////////////////////////

#endif
	m_toolBar->Realize();

	// toolBar->SetRows(!(toolBar->IsVertical()) ? m_rows : 10 / m_rows);
}
void MyFrame::RecreateToolbar()
{
	// delete and recreate the toolbar
	wxToolBar *toolBar = GetToolBar();
	// long style = toolBar ? toolBar->GetWindowStyle() : TOOLBAR_STYLE;

	SetToolBar(NULL);

	delete toolBar;
	/*
	style &= ~(wxTB_HORIZONTAL | wxTB_VERTICAL | wxTB_BOTTOM | wxTB_RIGHT | wxTB_HORZ_LAYOUT);
	switch( m_toolbarPosition )
	{
	case TOOLBAR_LEFT:style |= wxTB_LEFT; break;
	case TOOLBAR_TOP: style |= wxTB_TOP;break;
	case TOOLBAR_RIGHT:style |= wxTB_RIGHT;break;
	case TOOLBAR_BOTTOM:style |= wxTB_BOTTOM;break;
	}
	*/
	long style = wxTB_FLAT | wxTB_NODIVIDER | wxTB_TEXT; // TOOLBAR_STYLE | wxTB_TOP;
	/*
	if ( m_showTooltips ) style &= ~wxTB_NO_TOOLTIPS;
	else                  style |= wxTB_NO_TOOLTIPS;

	if ( style & wxTB_TEXT && !(style & wxTB_NOICONS) && m_horzText ) style |= wxTB_HORZ_LAYOUT;
	*/
	toolBar = CreateToolBar(style, wxID_ANY);

	PopulateToolbar(toolBar);
}

void registerWindow2(int baseID,NWindows::NControl::CWindow2 *w)
{
	MyFrame * f = (MyFrame *) g_HWND;
	f->registerWindow2(baseID,w);
	
}


/////////////////////////////////////////////////////////
#include "LangUtils.h"

static const UINT kOpenBookmarkMenuID = 730;  // FIXME / duplicate
static const UINT kSetBookmarkMenuID = 740;


void rc_MyLoadMenu(HWND hWnd)
{
	wxFrame *hwnd = (wxFrame *)hWnd;
	wxMenu *m;
	wxMenu *m_file = m = new wxMenu;
	{
		m->Append(IDM_OPEN, _T("&Open"));  // FIXME "&Open\tEnter" - don't use Enter to support combobox enter ...
		m->Append(IDM_OPEN_INSIDE,_T("Open &Inside\tCtrl+PgDn"));
		m->Append(IDM_OPEN_INSIDE_ONE,_T("Open Inside *"));
		m->Append(IDM_OPEN_INSIDE_PARSER,_T("Open Inside #"));
		m->Append(IDM_OPEN_OUTSIDE,_T("Open O&utside\tShift+Enter"));
		m->Append(IDM_FILE_VIEW,_T("&View\tF3"));
		m->Append(IDM_FILE_EDIT,_T("&Edit\tF4"));
		m->AppendSeparator();
		m->Append(IDM_RENAME,_T("Rena&me\tF2"));
		m->Append(IDM_COPY_TO,_T("&Copy To...\tF5"));
		m->Append(IDM_MOVE_TO,_T("&Move To...\tF6"));
		m->Append(IDM_DELETE,_T("&Delete\tDel"));
		m->AppendSeparator();
		m->Append(IDM_SPLIT,_T("&Split file..."));
		m->Append(IDM_COMBINE,_T("Com&bine files..."));
		m->AppendSeparator();
		m->Append(IDM_PROPERTIES,_T("P&roperties\tAlt+Enter"));
		m->Append(IDM_COMMENT,_T("Comme&nt\tCtrl+Z"));

		wxMenu * subMenuCRC = new wxMenu;
		subMenuCRC->Append(IDM_CRC32   ,_T("CRC-32"));
		subMenuCRC->Append(IDM_CRC64   ,_T("CRC-64"));
		subMenuCRC->Append(IDM_SHA1    ,_T("SHA-1"));
		subMenuCRC->Append(IDM_SHA256  ,_T("SHA-256"));
		subMenuCRC->Append(IDM_HASH_ALL,_T("*"));
		m->AppendSubMenu(subMenuCRC,_T("CRC"));

		m->Append(IDM_DIFF,_T("Di&ff"));
		m->AppendSeparator();
		m->Append(IDM_CREATE_FOLDER,_T("Create Folder\tF7"));
		m->Append(IDM_CREATE_FILE,_T("Create File\tCtrl+N"));
		m->AppendSeparator();
		m->Append(IDEXIT,_T("E&xit\tAlt+F4"));   
	}
	wxMenu *m_edit = m = new wxMenu;
	{
		// m->Append(IDM_EDIT_CUT, _T("Cu&t\tCtrl+X"))->Enable(true);              // GRAYED
		// m->Append(IDM_EDIT_COPY, _T("&Copy\tCtrl+C"))->Enable(true);            // GRAYED
		// m->Append(IDM_EDIT_PASTE, _T("&Paste\tCtrl+V"))->Enable(true);          // GRAYED
		// m->AppendSeparator();
		m->Append(IDM_SELECT_ALL, _T("Select &All\tShift+[Grey +]")); 
		m->Append(IDM_DESELECT_ALL, _T("Deselect All\tShift+[Grey -]")); 
		m->Append(IDM_INVERT_SELECTION, _T("&Invert Selection\tGrey *"));   
		m->Append(IDM_SELECT, _T("Select...\tGrey +"));           
		m->Append(IDM_DESELECT, _T("Deselect...\tGrey -"));        
// FIXME		m->Append(IDM_SELECT_BY_TYPE, _T("Select by Type\tAlt+[Grey+]")); 
// FIXME		m->Append(IDM_DESELECT_BY_TYPE, _T("Deselect by Type\tAlt+[Grey -]")); 
	}
	wxMenu *m_view = m = new wxMenu;
	{
/*
		m->AppendRadioItem(IDM_VIEW_LARGE_ICONS, _T("Lar&ge Icons\tCtrl+1"));        
		m->AppendRadioItem(IDM_VIEW_SMALL_ICONS, _T("S&mall Icons\tCtrl+2"));      
		m->AppendRadioItem(IDM_VIEW_LIST, _T("&List\tCtrl+3"));             
		m->AppendRadioItem(IDM_VIEW_DETAILS, _T("&Details\tCtrl+4"))->Check(true);  // CHECKED
		m->AppendSeparator();
		m->Append(IDM_VIEW_ARANGE_BY_NAME, _T("Name\tCtrl+F3"));               
		m->Append(IDM_VIEW_ARANGE_BY_TYPE, _T("Type\tCtrl+F4"));             
		m->Append(IDM_VIEW_ARANGE_BY_DATE, _T("Date\tCtrl+F5"));             
		m->Append(IDM_VIEW_ARANGE_BY_SIZE, _T("Size\tCtrl+F6"));               
		m->Append(IDM_VIEW_ARANGE_NO_SORT, _T("Unsorted\tCtrl+F7"));           
		m->AppendSeparator();
		m->AppendCheckItem(IDM_VIEW_FLAT_VIEW, _T("Flat View"));                   
		m->AppendCheckItem(IDM_VIEW_TWO_PANELS, _T("&2 Panels\tF9")); 

		{
			wxMenu* subMenu = new wxMenu;
			subMenu->AppendCheckItem(IDM_VIEW_ARCHIVE_TOOLBAR, _T("Archive Toolbar"));            
			subMenu->AppendCheckItem(IDM_VIEW_STANDARD_TOOLBAR, _T("Standard Toolbar"));            
			subMenu->AppendSeparator();
			subMenu->AppendCheckItem(IDM_VIEW_TOOLBARS_LARGE_BUTTONS, _T("Large Buttons"));               
			subMenu->AppendCheckItem(IDM_VIEW_TOOLBARS_SHOW_BUTTONS_TEXT, _T("Show Buttons Text"));           
			m->Append(12112, _T("Toolbars"), subMenu); // FIXME ID ?
		}
		m->AppendSeparator();
*/
		// NO "/" is used on Unix Path ... m->Append(IDM_OPEN_ROOT_FOLDER, _T("Open Root Folder\t" STRING_PATH_SEPARATOR));        
		m->Append(IDM_OPEN_ROOT_FOLDER, _T("Open Root Folder\t" "\\"));        

		m->Append(IDM_OPEN_PARENT_FOLDER, _T("Up One Level\tBackspace"));
		m->Append(IDM_FOLDERS_HISTORY, _T("Folders History...\tAlt+F12"));
		m->AppendSeparator();
		m->Append(IDM_VIEW_REFRESH, _T("&Refresh\tCtrl+R"));
	}
	wxMenu *m_favorites = m = new wxMenu;
	{
		{
			wxMenu* subMenu = new wxMenu;
			for (int i = 0; i < 10; i++)
			{
				UString s = LangString(IDS_BOOKMARK);
				s += L" ";
				wchar_t c = (wchar_t)(L'0' + i);
				s += c;
				s += L"\tAlt+Shift+";
				s += c;
				subMenu->Append( kSetBookmarkMenuID + i, wxString(s));
			}

			m->Append(12111, _T("&Add folder to Favorites as"), subMenu); // FIXME ID ?
		}
		m->AppendSeparator();
		for (int i = 0; i < 10; i++)
		{
      UString s = g_App.AppState.FastFolders.GetString(i);
      const int kMaxSize = 100;
      const int kFirstPartSize = kMaxSize / 2;
      if (s.Len() > kMaxSize)
      {
        s.Delete(kFirstPartSize, s.Len() - kMaxSize);
        s.Insert(kFirstPartSize, L" ... ");
      }
      if (s.IsEmpty())
        s = L'-';
      s += L"\tAlt+";
      s += (wchar_t)(L'0' + i);
			// menu.AppendItem(MF_STRING, kOpenBookmarkMenuID + i, s);
			m->Append( kOpenBookmarkMenuID + i, wxString(s));
		}
		
	}
	wxMenu *m_tools = m = new wxMenu;
	{
//		m->Append(IDM_OPTIONS, _T("&Options..."));
		m->Append(IDM_BENCHMARK, _T("&Benchmark"));
	}
	wxMenu *m_help = m = new wxMenu;
	{
		m->Append(IDM_HELP_CONTENTS, _T("&Contents...\tF1"));
		m->AppendSeparator();
		m->Append(IDM_ABOUT, _T("&About 7-Zip..."));
	}

	wxMenuBar *menuBar = new wxMenuBar;

	menuBar->Append(m_file, _T("&File"));
	menuBar->Append(m_edit, _T("&Edit"));
	menuBar->Append(m_view, _T("&View"));
	menuBar->Append(m_favorites, _T("F&avorites"));
	menuBar->Append(m_tools, _T("&Tools"));
	menuBar->Append(m_help, _T("&Help"));
	hwnd->SetMenuBar(menuBar);
}

//////////////////////////////////////////////////////////////////


static CStringTable g_stringTable[] =
{
  /* resource.rc */	  
  /***************/
  { IDS_BOOKMARK   ,L"Bookmark" },

  { IDS_OPTIONS    ,L"Options" },

  { IDS_N_SELECTED_ITEMS  ,L"{0} object(s) selected" },

  { IDS_FILE_EXIST  ,L"File {0} is already exist" },
  { IDS_WANT_UPDATE_MODIFIED_FILE  ,L"File '{0}' was modified.\nDo you want to update it in the archive?" },
  { IDS_CANNOT_UPDATE_FILE   ,L"Can not update file\n'{0}'" },
  { IDS_CANNOT_START_EDITOR  ,L"Cannot start editor." },
  { IDS_VIRUS                ,L"The file looks like a virus (the file name contains long spaces in name)." },
  { IDS_MESSAGE_UNSUPPORTED_OPERATION_FOR_LONG_PATH_FOLDER ,L"The operation cannot be called from a folder that has a long path." },
  { IDS_SELECT_ONE_FILE      ,L"You must select one file" },
  { IDS_SELECT_FILES         ,L"You must select one or more files" },
  { IDS_TOO_MANY_ITEMS       ,L"Too many items" },

  { IDS_COPY      ,L"Copy" },
  { IDS_MOVE      ,L"Move" },
  { IDS_COPY_TO   ,L"Copy to:" },
  { IDS_MOVE_TO   ,L"Move to:" },
  { IDS_COPYING   ,L"Copying..." },
  { IDS_MOVING    ,L"Moving..." },
  { IDS_RENAMING  ,L"Renaming..." },

  { IDS_OPERATION_IS_NOT_SUPPORTED  ,L"Operation is not supported." },
  { IDS_ERROR_RENAMING  ,L"Error Renaming File or Folder" },
  { IDS_CONFIRM_FILE_COPY   ,L"Confirm File Copy" },
  { IDS_WANT_TO_COPY_FILES  ,L"Are you sure you want to copy files to archive" },

  { IDS_CONFIRM_FILE_DELETE   ,L"Confirm File Delete" },
  { IDS_CONFIRM_FOLDER_DELETE ,L"Confirm Folder Delete" },
  { IDS_CONFIRM_ITEMS_DELETE  ,L"Confirm Multiple File Delete" },
  { IDS_WANT_TO_DELETE_FILE   ,L"Are you sure you want to delete '{0}'?" },
  { IDS_WANT_TO_DELETE_FOLDER ,L"Are you sure you want to delete the folder '{0}' and all its contents?" },
  { IDS_WANT_TO_DELETE_ITEMS  ,L"Are you sure you want to delete these {0} items?" },
  { IDS_DELETING              ,L"Deleting..." },
  { IDS_ERROR_DELETING        ,L"Error Deleting File or Folder" },
  { IDS_ERROR_LONG_PATH_TO_RECYCLE  ,L"The system cannot move a file with long path to the Recycle Bin" },
  
  { IDS_CREATE_FOLDER       ,L"Create Folder" },
  { IDS_CREATE_FILE         ,L"Create File" },
  { IDS_CREATE_FOLDER_NAME  ,L"Folder name:" },
  { IDS_CREATE_FILE_NAME    ,L"File Name:" },
  { IDS_CREATE_FOLDER_DEFAULT_NAME  ,L"New Folder" },
  { IDS_CREATE_FILE_DEFAULT_NAME    ,L"New File" },
  { IDS_CREATE_FOLDER_ERROR ,L"Error Creating Folder" },
  { IDS_CREATE_FILE_ERROR   ,L"Error Creating File" },

  { IDS_COMMENT      ,L"Comment" },
  { IDS_COMMENT2     ,L"&Comment:" },
  { IDS_SELECT       ,L"Select" },
  { IDS_DESELECT     ,L"Deselect" },
  { IDS_SELECT_MASK  ,L"Mask:" },

  { IDS_PROPERTIES   ,L"Properties" },
  { IDS_FOLDERS_HISTORY  ,L"Folders History" },

  { IDS_COMPUTER   ,L"Computer" },
  { IDS_NETWORK    ,L"Network" },
  { IDS_DOCUMENTS  ,L"Documents" },
  { IDS_SYSTEM     ,L"System" },

  { IDS_ADD            ,L"Add" },
  { IDS_EXTRACT        ,L"Extract" },
  { IDS_TEST           ,L"Test" },
  { IDS_BUTTON_COPY    ,L"Copy" },
  { IDS_BUTTON_MOVE    ,L"Move" },
  { IDS_BUTTON_DELETE  ,L"Delete" },
  { IDS_BUTTON_INFO    ,L"Info" },

  { IDS_SPLITTING            ,L"Splitting..." },
  { IDS_SPLIT_CONFIRM_TITLE  ,L"Confirm Splitting" },
  { IDS_SPLIT_CONFIRM_MESSAGE  ,L"Are you sure you want to split file into {0} volumes?" },
  { IDS_SPLIT_VOL_MUST_BE_SMALLER ,L"Volume size must be smaller than size of original file" },

  { IDS_COMBINE     ,L"Combine Files" },
  { IDS_COMBINE_TO  ,L"&Combine to:" },
  { IDS_COMBINING   ,L"Combining..." },
  { IDS_COMBINE_SELECT_ONE_FILE  ,L"Select only first part of split file" },
  { IDS_COMBINE_CANT_DETECT_SPLIT_FILE  ,L"Can not detect file as split file" },
  { IDS_COMBINE_CANT_FIND_MORE_THAN_ONE_PART  ,L"Can not find more than one part of split file" },



  /* PropertyName.rc */	  
  /*******************/
  { IDS_PROP_PATH         ,L"Path" },
  { IDS_PROP_NAME         ,L"Name" },
  { IDS_PROP_EXTENSION    ,L"Extension" },
  { IDS_PROP_IS_FOLDER    ,L"Folder" },
  { IDS_PROP_SIZE         ,L"Size" },
  { IDS_PROP_PACKED_SIZE  ,L"Packed Size" },
  { IDS_PROP_ATTRIBUTES   ,L"Attributes" },
  { IDS_PROP_CTIME        ,L"Created" },
  { IDS_PROP_ATIME        ,L"Accessed" },
  { IDS_PROP_MTIME        ,L"Modified" },
  { IDS_PROP_SOLID        ,L"Solid" },
  { IDS_PROP_C0MMENTED    ,L"Commented" },
  { IDS_PROP_ENCRYPTED    ,L"Encrypted" },
  { IDS_PROP_SPLIT_BEFORE ,L"Split Before" },
  { IDS_PROP_SPLIT_AFTER  ,L"Split After" },
  { IDS_PROP_DICTIONARY_SIZE ,L"Dictionary" },
  { IDS_PROP_CRC          ,L"CRC" },
  { IDS_PROP_FILE_TYPE    ,L"Type" },
  { IDS_PROP_ANTI         ,L"Anti" },
  { IDS_PROP_METHOD       ,L"Method" },
  { IDS_PROP_HOST_OS      ,L"Host OS" },
  { IDS_PROP_FILE_SYSTEM  ,L"File System" },
  { IDS_PROP_USER         ,L"User" },
  { IDS_PROP_GROUP        ,L"Group" },
  { IDS_PROP_BLOCK        ,L"Block" },
  { IDS_PROP_COMMENT      ,L"Comment" },
  { IDS_PROP_POSITION     ,L"Position" },
  { IDS_PROP_PREFIX       ,L"Path Prefix" },
  { IDS_PROP_FOLDERS      ,L"Folders" },
  { IDS_PROP_FILES        ,L"Files" },
  { IDS_PROP_VERSION      ,L"Version" },
  { IDS_PROP_VOLUME       ,L"Volume" },
  { IDS_PROP_IS_VOLUME    ,L"Multivolume" },
  { IDS_PROP_OFFSET       ,L"Offset" },
  { IDS_PROP_LINKS        ,L"Links" },
  { IDS_PROP_NUM_BLOCKS   ,L"Blocks" },
  { IDS_PROP_NUM_VOLUMES  ,L"Volumes" },

  { IDS_PROP_BIT64        ,L"64-bit" },
  { IDS_PROP_BIG_ENDIAN   ,L"Big-endian" },
  { IDS_PROP_CPU          ,L"CPU" },
  { IDS_PROP_PHY_SIZE     ,L"Physical Size" },
  { IDS_PROP_HEADERS_SIZE ,L"Headers Size" },
  { IDS_PROP_CHECKSUM     ,L"Checksum" },
  { IDS_PROP_CHARACTS     ,L"Characteristics" },
  { IDS_PROP_VA           ,L"Virtual Address" },
  { IDS_PROP_ID           ,L"ID" },
  { IDS_PROP_SHORT_NAME   ,L"Short Name" },
  { IDS_PROP_CREATOR_APP  ,L"Creator Application" },
  { IDS_PROP_SECTOR_SIZE  ,L"Sector Size" },
  { IDS_PROP_POSIX_ATTRIB ,L"Mode" },
  { IDS_PROP_SYM_LINK     ,L"Symbolic Link" },
  { IDS_PROP_ERROR        ,L"Error" },
  { IDS_PROP_TOTAL_SIZE   ,L"Total Size" },
  { IDS_PROP_FREE_SPACE   ,L"Free Space" },
  { IDS_PROP_CLUSTER_SIZE ,L"Cluster Size" },
  { IDS_PROP_VOLUME_NAME  ,L"Label" },
  { IDS_PROP_LOCAL_NAME   ,L"Local Name" },
  { IDS_PROP_PROVIDER     ,L"Provider" },
  { IDS_PROP_NT_SECURITY  ,L"NT Security" },
  { IDS_PROP_ALT_STREAM   ,L"Alternate Stream" },
  { IDS_PROP_AUX          ,L"Aux" },
  { IDS_PROP_DELETED      ,L"Deleted" },
  { IDS_PROP_IS_TREE      ,L"Is Tree" },
  { IDS_PROP_SHA1         ,L"SHA-1" },
  { IDS_PROP_SHA256       ,L"SHA-256" },
  { IDS_PROP_ERROR_TYPE   ,L"Error Type" },
  { IDS_PROP_NUM_ERRORS   ,L"Errors" },
  { IDS_PROP_ERROR_FLAGS  ,L"Errors" },
  { IDS_PROP_WARNING_FLAGS ,L"Warnings" },
  { IDS_PROP_WARNING      ,L"Warning" },
  { IDS_PROP_NUM_STREAMS  ,L"Streams" },
  { IDS_PROP_NUM_ALT_STREAMS ,L"Alternate Streams" },
  { IDS_PROP_ALT_STREAMS_SIZE ,L"Alternate Streams Size" },
  { IDS_PROP_VIRTUAL_SIZE ,L"Virtual Size" },
  { IDS_PROP_UNPACK_SIZE  ,L"Unpack Size" },
  { IDS_PROP_TOTAL_PHY_SIZE ,L"Total Physical Size" },
  { IDS_PROP_VOLUME_INDEX ,L"Volume Index" },
  { IDS_PROP_SUBTYPE      ,L"SubType" },
  { IDS_PROP_SHORT_COMMENT ,L"Short Comment" },
  { IDS_PROP_CODE_PAGE    ,L"Code Page" },
  { IDS_PROP_IS_NOT_ARC_TYPE  ,L"Is not archive type" },
  { IDS_PROP_PHY_SIZE_CANT_BE_DETECTED ,L"Physical Size can't be detected" },
  { IDS_PROP_ZEROS_TAIL_IS_ALLOWED ,L"Zeros Tail Is Allowed" },
  { IDS_PROP_TAIL_SIZE ,L"Tail Size" },
  { IDS_PROP_EMB_STUB_SIZE ,L"Embedded Stub Size" },
  { IDS_PROP_NT_REPARSE   ,L"Link" },
  { IDS_PROP_HARD_LINK    ,L"Hard Link" },
  { IDS_PROP_INODE        ,L"iNode" },
  { IDS_PROP_STREAM_ID    ,L"Stream ID" },
 
	{ 0 , 0 }
};

REGISTER_STRINGTABLE(g_stringTable)

/////////////////////////////////////////////////////

#include "res/ParentFolder.h"

	SevenZipPanel::SevenZipPanel(MyFrame *frame, wxWindow *parent,int id,int panelIndex) :
	       	wxPanel(parent,id) , m_frame(frame), _wList(0)
	{
		_panelIndex = panelIndex;

		int _baseID = id; // FIXME
		int _listID = _baseID + 1;
		int _comboBoxID = _baseID + 3;
		int _statusBarID = _comboBoxID + 1;
		int kParentFolderID = 100; // FIXME Panel.h


		///Sizer for adding the controls created by users
		wxBoxSizer* pMainSizer = new wxBoxSizer(wxVERTICAL);
		int sizes[] = {150, 250, 350, -1};
		wxArrayString pathArray;
		wxBoxSizer *pPathSizer = new wxBoxSizer(wxHORIZONTAL);
		m_pBmpButtonParentFolder = new wxBitmapButton(this, kParentFolderID, wxGetBitmapFromMemory(PARENT_FOLDER), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW);
		m_pComboBoxPath = new wxComboBox(this, _comboBoxID, wxEmptyString, wxDefaultPosition, wxSize(300,-1), pathArray, wxCB_DROPDOWN | wxCB_SORT );
		pPathSizer->Add(m_pBmpButtonParentFolder, 0, wxALL|wxEXPAND, 0);
		pPathSizer->Add(m_pComboBoxPath, 1, wxALL|wxEXPAND, 5);

		m_pListCtrlExplorer = new CExplorerListCtrl(this,_listID,wxDefaultPosition, wxSize(300,300),
			wxLC_REPORT | // wxLC_EDIT_LABELS |   FIXME
			wxSUNKEN_BORDER);

		printf("DEBUG : new CExplorerListCtrl(id=%d) => %p\n",_listID,m_pListCtrlExplorer);

		m_pStatusBar = new wxStatusBar(this, _statusBarID);
		m_pStatusBar->SetFieldsCount(4, sizes);
		pMainSizer->Add(pPathSizer, 0, wxALL|wxEXPAND, 0);
		pMainSizer->Add(m_pListCtrlExplorer, 1, wxALL|wxEXPAND, 0);
		pMainSizer->Add(m_pStatusBar, 0, wxALL|wxEXPAND, 0);
		SetSizer(pMainSizer);
		SetAutoLayout (true);
		SetMinSize(wxSize(800,400));
		Layout();

		
		// m_pListCtrlExplorer->SetDropTarget(new DnDFile(this));

	}

	void SevenZipPanel::OnAnyButton( wxCommandEvent &event )
	{
		count++;

		int id = event.GetId();

		wxString msg = wxString::Format(_T("P %d : button %d \n"), count,id);

		WriteText(msg);

		_wList->OnMessage(WM_COMMAND , id , 0);
	}

	void SevenZipPanel::OnSelected(wxListEvent& event)
	{
		const wxListItem & item = event.GetItem();
		count++;

		wxString msg = wxString::Format(_T("P %d : OnSelected %d \n"), count,event.GetId());

		WriteText(msg);

		NMLISTVIEW info;
		info.hdr.hwndFrom = m_pListCtrlExplorer;
		info.hdr.code     = LVN_ITEMCHANGED;
		info.uOldState    = 0;
		info.uNewState    = LVIS_SELECTED;
		info.lParam       = item.GetData(); // event.GetIndex(); // FIXME ? event.GetData();
		_wList->OnMessage(WM_NOTIFY , event.GetId() , (LPARAM)&info);
		/*
		if ( GetWindowStyle() & wxLC_REPORT )
		{
		wxListItem info;
		info.m_itemId = event.m_itemIndex;
		info.m_col = 1;
		info.m_mask = wxLIST_MASK_TEXT;
		if ( GetItem(info) )
		{
		wxLogMessage(wxT("Value of the 2nd field of the selected item: %s"),
		info.m_text.c_str());
		}
		else
		{
		wxFAIL_MSG(wxT("wxListCtrl::GetItem() failed"));
		}
		}
		*/
	}

	

	void SevenZipPanel::OnDeselected(wxListEvent& event)
	{
		const wxListItem & item = event.GetItem();
		count++;
		wxString msg = wxString::Format(_T("P %d : OnDeselected %d \n"), count,event.GetId());
		WriteText(msg);

		NMLISTVIEW info;
		info.hdr.hwndFrom = m_pListCtrlExplorer;
		info.hdr.code     = LVN_ITEMCHANGED;
		info.uOldState    = LVIS_SELECTED;
		info.uNewState    = 0;
		info.lParam       = item.GetData(); // event.GetIndex(); // FIXME ? event.GetData();
		_wList->OnMessage(WM_NOTIFY , event.GetId() , (LPARAM)&info);
	}

	void SevenZipPanel::OnColumnClick(wxListEvent& event)
	{
		count++;
		wxString msg = wxString::Format(_T("P %d : OnColumnClick %d col=%d\n"), count,event.GetId(),event.GetColumn());
		WriteText(msg);

		NMLISTVIEW info;
		info.hdr.hwndFrom = m_pListCtrlExplorer;
		info.hdr.code     = LVN_COLUMNCLICK;
		info.iSubItem     = event.GetColumn();
		_wList->OnMessage(WM_NOTIFY , event.GetId() , (LPARAM)&info);

	}


	void SevenZipPanel::OnActivated(wxListEvent& event)
	{
		count++;

		int ind = event.GetIndex();

		NMHDR info;
		info.hwndFrom = m_pListCtrlExplorer;
		info.code     = NM_DBLCLK;
		_wList->OnMessage(WM_NOTIFY , event.GetId() , (LPARAM)&info);

		/*
		if ((ind >= 0) && ( ind < m_nbDirs))
		{
			wxString msg = wxString::Format(_T("P %d : OnActivated %d : DIR = %d\n"), count,event.GetId(),ind);
			WriteText(msg);

			wxString name = m_pListCtrlExplorer->GetItemText(ind);

			wxFileName filename (m_currentDirectory,name);
			BinPath(filename.GetFullPath());

		}
		else
		*/
		{
			wxString msg = wxString::Format(_T("P %d : OnActivated %d : FILE = %d\n"), count,event.GetId(),ind);
			WriteText(msg);
		}
	}

	void SevenZipPanel::OnFocused(wxListEvent& event)
	{
		count++;

		wxString msg = wxString::Format(_T("P %d : OnFocused %d \n"), count,event.GetId());

		WriteText(msg);

		event.Skip();
	}

	void SevenZipPanel::OnLeftDownBeginDrag(wxListEvent& event)
	{
		count++;

		wxString msg = wxString::Format(_T("P %d : OnLeftDownBeginDrag %d \n"), count,event.GetId());
		WriteText(msg);

#if 0		
		if (   m_pListCtrlExplorer->GetSelectedItemCount() < 1) return ;

        // start drag operation
        wxFileDataObject filesData;


	long item = -1;
    for ( ;; )
    {
        item = m_pListCtrlExplorer->GetNextItem(item,
                                     wxLIST_NEXT_ALL,
                                     wxLIST_STATE_SELECTED);
        if ( item == -1 )
            break;

        // this item is selected - do whatever is needed with it
        // wxLogMessage("Item %ld is selected.", item);
		wxString file = m_currentDirectory + _T("/") + m_pListCtrlExplorer->GetItemText(item);

		filesData.AddFile(file);

    }

		msg = wxString::Format(_T("P %d : wxDropSource %d \n"), count,event.GetId());
		WriteText(msg);

        wxDropSource source(filesData, this,
                            wxDROP_ICON(dnd_copy),
                            wxDROP_ICON(dnd_move),
                            wxDROP_ICON(dnd_none));

        int flags = 0;
		/*
        if ( m_moveByDefault )
            flags |= wxDrag_DefaultMove;
        else if ( m_moveAllow )
            flags |= wxDrag_AllowMove;
			*/
		flags |= wxDrag_AllowMove;

		msg = wxString::Format(_T("P %d : DoDragDrop %d \n"), count,event.GetId());
		WriteText(msg);


        wxDragResult result = source.DoDragDrop(flags);


        const wxChar *pc;
        switch ( result )
        {
            case wxDragError:   pc = _T("Error!");    break;
            case wxDragNone:    pc = _T("Nothing");   break;
            case wxDragCopy:    pc = _T("Copied");    break;
            case wxDragMove:    pc = _T("Moved");     break;
            case wxDragCancel:  pc = _T("Cancelled"); break;
            default:            pc = _T("Huh?");      break;
        }

        WriteText(wxString(_T("    Drag result: ")) + pc);
#endif
	}

void SevenZipPanel::OnLeftDown(wxMouseEvent &WXUNUSED(event) )
{
	WriteText(_T("OnLeftDown"));
#if 0
    if ( !m_strText.empty() )
    {
        // start drag operation
        wxTextDataObject textData(m_strText);
        wxDropSource source(textData, this,
                            wxDROP_ICON(dnd_copy),
                            wxDROP_ICON(dnd_move),
                            wxDROP_ICON(dnd_none));

        int flags = 0;
        if ( m_moveByDefault )
            flags |= wxDrag_DefaultMove;
        else if ( m_moveAllow )
            flags |= wxDrag_AllowMove;

        wxDragResult result = source.DoDragDrop(flags);

#if wxUSE_STATUSBAR
        const wxChar *pc;
        switch ( result )
        {
            case wxDragError:   pc = _T("Error!");    break;
            case wxDragNone:    pc = _T("Nothing");   break;
            case wxDragCopy:    pc = _T("Copied");    break;
            case wxDragMove:    pc = _T("Moved");     break;
            case wxDragCancel:  pc = _T("Cancelled"); break;
            default:            pc = _T("Huh?");      break;
        }

        SetStatusText(wxString(_T("Drag result: ")) + pc);
#else
        wxUnusedVar(result);
#endif // wxUSE_STATUSBAR
    }
#endif // wxUSE_DRAG_AND_DROP
}

void SevenZipPanel::OnRightClick(wxListEvent& event)
{
	wxPoint point = event.GetPoint(); 

	WriteText(_T("OnRightClick"));
    wxMenu menu; // (_T("Dnd sample menu"));

    menu.Append(wxID_ANY, _T("&Test drag..."));
    menu.AppendSeparator();
    menu.Append(wxID_ANY, _T("item1"));
    menu.Append(wxID_ANY, _T("item2"));
    menu.Append(wxID_ANY, _T("item3"));
    menu.Append(wxID_ANY, _T("&About"));

    PopupMenu( &menu, point.x, point.y );
}

void SevenZipPanel::OnTextEnter(wxCommandEvent& event)
{	
	count++;

	NMCBEENDEDITW info;
	info.hdr.hwndFrom = m_pComboBoxPath;
	info.hdr.code     = CBEN_ENDEDITW;
	info.iWhy         = CBENF_RETURN;
	
	_wList->OnMessage(WM_NOTIFY , event.GetId() , (LPARAM)&info);
	
	{
		wxString msg = wxString::Format(_T("P %d : OnTextEnter %d\n"), count,event.GetId());
		WriteText(msg);
	}
}

int SevenZipPanel::count = 0;

BEGIN_EVENT_TABLE(SevenZipPanel, wxPanel)
// EVT_MENU(wxID_ANY, SevenZipPanel::OnAnyMenu)
// EVT_LISTBOX   (wxID_ANY,       MyPanel::OnListBox)
// EVT_LISTBOX_DCLICK(wxID_ANY,          MyPanel::OnAnyListBoxDoubleClick)
EVT_BUTTON    (wxID_ANY,      SevenZipPanel::OnAnyButton)

 // EVT_CLOSE(SevenZipPanel::OnCloseWindow)

/////////////////
EVT_LIST_ITEM_SELECTED(wxID_ANY,   SevenZipPanel::OnSelected)
EVT_LIST_ITEM_DESELECTED(wxID_ANY, SevenZipPanel::OnDeselected)
EVT_LIST_ITEM_ACTIVATED(wxID_ANY,  SevenZipPanel::OnActivated)
EVT_LIST_ITEM_FOCUSED(wxID_ANY,  SevenZipPanel::OnFocused)

EVT_LIST_BEGIN_DRAG(wxID_ANY, SevenZipPanel::OnLeftDownBeginDrag)
// FIXME - add for menu on item - EVT_LIST_ITEM_RIGHT_CLICK(wxID_ANY, SevenZipPanel::OnRightClick)

EVT_LIST_COL_CLICK(wxID_ANY, SevenZipPanel::OnColumnClick)


EVT_TEXT_ENTER(wxID_ANY, SevenZipPanel::OnTextEnter)  // FIXME - not called


END_EVENT_TABLE()



void appClose(void)
{
	g_window->Close(true);
}
// FSDrives.cpp

#include "StdAfx.h"

#include "../../../../C/Alloc.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/Defs.h"
#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/FileDir.h"
#include "../../../Windows/FileIO.h"
#include "../../../Windows/FileName.h"
// #include "../../../Windows/FileSystem.h"
#include "../../../Windows/PropVariant.h"

#include "../../PropID.h"

#include "FSDrives.h"
#include "FSFolder.h"
#include "LangUtils.h"
#include "SysIconUtils.h"

#include "resource.h"

using namespace NWindows;
using namespace NFile;
using namespace NFind;

static const CFSTR kVolPrefix   = FTEXT("\\\\.\\");
static const CFSTR kSuperPrefix = FTEXT("\\\\?\\");

FString CDriveInfo::GetDeviceFileIoName() const
{
  return kVolPrefix + Name;
}

struct CPhysTempBuffer
{
  void *buffer;
  CPhysTempBuffer(): buffer(0) {}
  ~CPhysTempBuffer() { MidFree(buffer); }
};

static HRESULT CopyFileSpec(CFSTR fromPath, CFSTR toPath, bool writeToDisk, UInt64 fileSize,
    UInt32 bufferSize, UInt64 progressStart, IProgress *progress)
{
  NIO::CInFile inFile;
  if (!inFile.Open(fromPath))
    return GetLastError();
  if (fileSize == (UInt64)(Int64)-1)
  {
    if (!inFile.GetLength(fileSize))
      ::GetLastError();
  }
  
  NIO::COutFile outFile;
  if (writeToDisk)
  {
    if (!outFile.Open(toPath, FILE_SHARE_WRITE, OPEN_EXISTING, 0))
      return GetLastError();
  }
  else
    if (!outFile.Create(toPath, true))
      return GetLastError();
  
  CPhysTempBuffer tempBuffer;
  tempBuffer.buffer = MidAlloc(bufferSize);
  if (!tempBuffer.buffer)
    return E_OUTOFMEMORY;
 
  for (UInt64 pos = 0; pos < fileSize;)
  {
    UInt64 progressCur = progressStart + pos;
    RINOK(progress->SetCompleted(&progressCur));
    UInt64 rem = fileSize - pos;
    UInt32 curSize = (UInt32)MyMin(rem, (UInt64)bufferSize);
    UInt32 processedSize;
    if (!inFile.Read(tempBuffer.buffer, curSize, processedSize))
      return GetLastError();
    if (processedSize == 0)
      break;
    curSize = processedSize;
    if (writeToDisk)
    {
      const UInt32 kMask = 0x1FF;
      curSize = (curSize + kMask) & ~kMask;
      if (curSize > bufferSize)
        return E_FAIL;
    }

    if (!outFile.Write(tempBuffer.buffer, curSize, processedSize))
      return GetLastError();
    if (curSize != processedSize)
      return E_FAIL;
    pos += curSize;
  }
  
  return S_OK;
}

static const Byte kProps[] =
{
  kpidName,
  // kpidOutName,
  kpidTotalSize,
  kpidFreeSpace,
  kpidType,
  kpidVolumeName,
  kpidFileSystem,
  kpidClusterSize
};

static const char * const kDriveTypes[] =
{
    "Unknown"
  , "No Root Dir"
  , "Removable"
  , "Fixed"
  , "Remote"
  , "CD-ROM"
  , "RAM disk"
};

STDMETHODIMP CFSDrives::LoadItems()
{
  _drives.Clear();
#ifdef _WIN32
  FStringVector driveStrings;
  MyGetLogicalDriveStrings(driveStrings);
  
  FOR_VECTOR (i, driveStrings)
  {
    CDriveInfo di;

    const FString &driveName = driveStrings[i];

    di.FullSystemName = driveName;
    if (!driveName.IsEmpty())
      di.Name.SetFrom(driveName, driveName.Len() - 1);
    di.ClusterSize = 0;
    di.DriveSize = 0;
    di.FreeSpace = 0;
    di.DriveType = NSystem::MyGetDriveType(driveName);
    bool needRead = true;

    if (di.DriveType == DRIVE_CDROM || di.DriveType == DRIVE_REMOVABLE)
    {
      /*
      DWORD dwSerialNumber;`
      if (!::GetVolumeInformation(di.FullSystemName,
          NULL, 0, &dwSerialNumber, NULL, NULL, NULL, 0))
      */
      {
        needRead = false;
      }
    }
    
    if (needRead)
    {
      DWORD volumeSerialNumber, maximumComponentLength, fileSystemFlags;
      NSystem::MyGetVolumeInformation(driveName,
          di.VolumeName,
          &volumeSerialNumber, &maximumComponentLength, &fileSystemFlags,
          di.FileSystemName);

      NSystem::MyGetDiskFreeSpace(driveName,
          di.ClusterSize, di.DriveSize, di.FreeSpace);
      di.KnownSizes = true;
      di.KnownSize = true;
    }
    
    _drives.Add(di);
  }

  if (_volumeMode)
  {
    // we must use IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS
    for (unsigned n = 0; n < 16; n++) // why 16 ?
    {
      FChar temp[16];
      ConvertUInt32ToString(n, temp);
      FString name = FTEXT("PhysicalDrive");
      name += temp;
      FString fullPath = kVolPrefix;
      fullPath += name;

      CFileInfo fi;
      if (!fi.Find(fullPath))
        continue;

      CDriveInfo di;
      di.Name = name;
      di.FullSystemName = fullPath;
      di.ClusterSize = 0;
      di.DriveSize = fi.Size;
      di.FreeSpace = 0;
      di.DriveType = 0;

      di.IsPhysicalDrive = true;
      di.KnownSize = true;
      
      _drives.Add(di);
    }
  }
#else
  CDriveInfo di;
	// Root
    di.FullSystemName = L"/";
	di.VolumeName = L"/";
	di.FileSystemName = L"img";	
    di.Name = L"/"; // di.FullSystemName.Left(di.FullSystemName.Length() - 1);
    di.ClusterSize = 0;
    di.DriveSize = 0;
    di.FreeSpace = 0;
    di.DriveType = 0; // FIXME NFile::NSystem::MyGetDriveType(driveName);
	di.KnownSizes = false;
	_drives.Add(di);
	
	// Home Directory
	const char * home = getenv("HOME");
	if (home) {
		UString ustr = GetUnicodeString(home);
		di.FullSystemName = ustr + L"/";
		di.VolumeName = ustr;
		di.FileSystemName = L"img";	
		di.Name = ustr;
		_drives.Add(di);
	}
#endif

  return S_OK;
}

STDMETHODIMP CFSDrives::GetNumberOfItems(UInt32 *numItems)
{
  *numItems = _drives.Size();
  return S_OK;
}

STDMETHODIMP CFSDrives::GetProperty(UInt32 itemIndex, PROPID propID, PROPVARIANT *value)
{
  if (itemIndex >= (UInt32)_drives.Size())
    return E_INVALIDARG;
  NCOM::CPropVariant prop;
  const CDriveInfo &di = _drives[itemIndex];
  switch (propID)
  {
    case kpidIsDir:  prop = !_volumeMode; break;
    case kpidName:  prop = di.Name; break;
    case kpidOutName:
      if (!di.Name.IsEmpty() && di.Name.Back() == ':')
      {
        FString s = di.Name;
        s.DeleteBack();
        AddExt(s, itemIndex);
        prop = s;
      }
      break;

    case kpidTotalSize:   if (di.KnownSize) prop = di.DriveSize; break;
    case kpidFreeSpace:   if (di.KnownSizes) prop = di.FreeSpace; break;
    case kpidClusterSize: if (di.KnownSizes) prop = di.ClusterSize; break;
    case kpidType:
      if (di.DriveType < ARRAY_SIZE(kDriveTypes))
        prop = kDriveTypes[di.DriveType];
      break;
    case kpidVolumeName:  prop = di.VolumeName; break;
    case kpidFileSystem:  prop = di.FileSystemName; break;
  }
  prop.Detach(value);
  return S_OK;
}

HRESULT CFSDrives::BindToFolderSpec(CFSTR name, IFolderFolder **resultFolder)
{
  *resultFolder = 0;
  if (_volumeMode)
    return S_OK;
  NFsFolder::CFSFolder *fsFolderSpec = new NFsFolder::CFSFolder;
  CMyComPtr<IFolderFolder> subFolder = fsFolderSpec;
  FString path;
  if (_superMode)
    path = kSuperPrefix;
  path += name;
  RINOK(fsFolderSpec->Init(path));
  *resultFolder = subFolder.Detach();
  return S_OK;
}

STDMETHODIMP CFSDrives::BindToFolder(UInt32 index, IFolderFolder **resultFolder)
{
  *resultFolder = 0;
  if (index >= (UInt32)_drives.Size())
    return E_INVALIDARG;
  const CDriveInfo &di = _drives[index];
  /*
  if (_volumeMode)
  {
    *resultFolder = 0;
    CPhysDriveFolder *folderSpec = new CPhysDriveFolder;
    CMyComPtr<IFolderFolder> subFolder = folderSpec;
    RINOK(folderSpec->Init(di.Name));
    *resultFolder = subFolder.Detach();
    return S_OK;
  }
  */
  return BindToFolderSpec(di.FullSystemName, resultFolder);
}

STDMETHODIMP CFSDrives::BindToFolder(const wchar_t *name, IFolderFolder **resultFolder)
{
  return BindToFolderSpec(us2fs(name), resultFolder);
}

STDMETHODIMP CFSDrives::BindToParentFolder(IFolderFolder **resultFolder)
{
  *resultFolder = 0;
  return S_OK;
}

IMP_IFolderFolder_Props(CFSDrives)

STDMETHODIMP CFSDrives::GetFolderProperty(PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NCOM::CPropVariant prop;
  switch (propID)
  {
    case kpidType: prop = "FSDrives"; break;
    case kpidPath:
      if (_volumeMode)
        prop = kVolPrefix;
      else if (_superMode)
        prop = kSuperPrefix;
      else
        prop = (UString)LangString(IDS_COMPUTER) + WCHAR_PATH_SEPARATOR;
      break;
  }
  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}


STDMETHODIMP CFSDrives::GetSystemIconIndex(UInt32 index, Int32 *iconIndex)
{
  *iconIndex = 0;
  const CDriveInfo &di = _drives[index];
  if (di.IsPhysicalDrive)
    return S_OK;
  int iconIndexTemp;
  if (GetRealIconIndex(di.FullSystemName, 0, iconIndexTemp) != 0)
  {
    *iconIndex = iconIndexTemp;
    return S_OK;
  }
  return GetLastError();
}

void CFSDrives::AddExt(FString &s, unsigned index) const
{
  s += FTEXT('.');
  const CDriveInfo &di = _drives[index];
  const char *ext;
#ifdef _WIN32
  if (di.DriveType == DRIVE_CDROM)
    ext = "iso";
  else if (di.FileSystemName.IsPrefixedBy_Ascii_NoCase("NTFS"))
    ext = "ntfs";
  else if (di.FileSystemName.IsPrefixedBy_Ascii_NoCase("FAT"))
    ext = "fat";
  else
#endif
    ext = "img";
  s.AddAscii(ext);
}

HRESULT CFSDrives::GetFileSize(unsigned index, UInt64 &fileSize) const
{
#ifdef _WIN32
  NIO::CInFile inFile;
  if (!inFile.Open(_drives[index].GetDeviceFileIoName()))
    return GetLastError();
  if (!inFile.SizeDefined)
    return E_FAIL;
  fileSize = inFile.Size;
#else
  fileSize = 0;
#endif
  return S_OK;
}

STDMETHODIMP CFSDrives::CopyTo(Int32 moveMode, const UInt32 *indices, UInt32 numItems,
    Int32 /* includeAltStreams */, Int32 /* replaceAltStreamColon */,
    const wchar_t *path, IFolderOperationsExtractCallback *callback)
{
  if (numItems == 0)
    return S_OK;
  
  if (moveMode)
    return E_NOTIMPL;

  if (!_volumeMode)
    return E_NOTIMPL;

  UInt64 totalSize = 0;
  UInt32 i;
  for (i = 0; i < numItems; i++)
  {
    const CDriveInfo &di = _drives[indices[i]];
    if (di.KnownSize)
      totalSize += di.DriveSize;
  }
  RINOK(callback->SetTotal(totalSize));
  RINOK(callback->SetNumFiles(numItems));
  
  FString destPath = us2fs(path);
  if (destPath.IsEmpty())
    return E_INVALIDARG;

  bool isAltDest = false; // FIXME NName::IsAltPathPrefix(destPath);
  bool isDirectPath = (!isAltDest && !IsPathSepar(destPath.Back()));
  
  if (isDirectPath)
  {
    if (numItems > 1)
      return E_INVALIDARG;
  }

  UInt64 completedSize = 0;
  RINOK(callback->SetCompleted(&completedSize));
  
  for (i = 0; i < numItems; i++)
  {
    unsigned index = indices[i];
    const CDriveInfo &di = _drives[index];
    FString destPath2 = destPath;

    if (!isDirectPath)
    {
      FString destName = di.Name;
      if (!destName.IsEmpty() && destName.Back() == ':')
      {
        destName.DeleteBack();
        AddExt(destName, index);
      }
      destPath2 += destName;
    }
    
    FString srcPath = di.GetDeviceFileIoName();

    UInt64 fileSize = 0;
    if (GetFileSize(index, fileSize) != S_OK)
    {
      return E_FAIL;
    }
    if (!di.KnownSize)
    {
      totalSize += fileSize;
      RINOK(callback->SetTotal(totalSize));
    }
    
    Int32 writeAskResult;
    CMyComBSTR destPathResult;
    RINOK(callback->AskWrite(fs2us(srcPath), BoolToInt(false), NULL, &fileSize,
        fs2us(destPath2), &destPathResult, &writeAskResult));

    if (!IntToBool(writeAskResult))
    {
      if (totalSize >= fileSize)
        totalSize -= fileSize;
      RINOK(callback->SetTotal(totalSize));
      continue;
    }
    
    RINOK(callback->SetCurrentFilePath(fs2us(srcPath)));
    
    static const UInt32 kBufferSize = (4 << 20);
    UInt32 bufferSize = /* FIXME (di.DriveType == DRIVE_REMOVABLE) ? (18 << 10) * 4 : */ kBufferSize;
    RINOK(CopyFileSpec(srcPath, us2fs(destPathResult), false, fileSize, bufferSize, completedSize, callback));
    completedSize += fileSize;
  }

  return S_OK;
}

STDMETHODIMP CFSDrives::CopyFrom(Int32 /* moveMode */, const wchar_t * /* fromFolderPath */,
    const wchar_t * const * /* itemsPaths */, UInt32 /* numItems */, IProgress * /* progress */)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFSDrives::CopyFromFile(UInt32 /* index */, const wchar_t * /* fullFilePath */, IProgress * /* progress */)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFSDrives::CreateFolder(const wchar_t * /* name */, IProgress * /* progress */)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFSDrives::CreateFile(const wchar_t * /* name */, IProgress * /* progress */)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFSDrives::Rename(UInt32 /* index */, const wchar_t * /* newName */, IProgress * /* progress */)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFSDrives::Delete(const UInt32 * /* indices */, UInt32 /* numItems */, IProgress * /* progress */)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFSDrives::SetProperty(UInt32 /* index */, PROPID /* propID */,
    const PROPVARIANT * /* value */, IProgress * /* progress */)
{
  return E_NOTIMPL;
}
// FSDrives.h

#ifndef __FS_DRIVES_H
#define __FS_DRIVES_H

#include "../../../Common/MyCom.h"
#include "../../../Common/MyString.h"

#include "IFolder.h"

struct CDriveInfo
{
  FString Name;
  FString FullSystemName;
  UInt64 DriveSize;
  UInt64 FreeSpace;
  UInt64 ClusterSize;
  // UString Type;
  UString VolumeName;
  UString FileSystemName;
  UINT DriveType;

  bool KnownSize;
  bool KnownSizes;
  bool IsPhysicalDrive;

  FString GetDeviceFileIoName() const;
  CDriveInfo(): KnownSize(false), KnownSizes(false), IsPhysicalDrive(false) {}
};

class CFSDrives:
  public IFolderFolder,
  public IFolderOperations,
  public IFolderGetSystemIconIndex,
  public CMyUnknownImp
{
  CObjectVector<CDriveInfo> _drives;
  bool _volumeMode;
  bool _superMode;

  HRESULT BindToFolderSpec(CFSTR name, IFolderFolder **resultFolder);
  void AddExt(FString &s, unsigned index) const;
  HRESULT GetFileSize(unsigned index, UInt64 &fileSize) const;
public:
  MY_UNKNOWN_IMP2(IFolderGetSystemIconIndex, IFolderOperations)

  INTERFACE_FolderFolder(;)
  INTERFACE_FolderOperations(;)

  STDMETHOD(GetSystemIconIndex)(UInt32 index, Int32 *iconIndex);

  void Init(bool volMode = false, bool superMode = false)
  {
    _volumeMode = volMode;
    _superMode = superMode;
  }
};

#endif
// FSFolder.cpp

#include "StdAfx.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/Defs.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/UTFConvert.h"

#include "../../../Windows/FileDir.h"
#include "../../../Windows/FileIO.h"
#include "../../../Windows/FileName.h"
#include "../../../Windows/PropVariant.h"

#include "../../PropID.h"

#include "FSDrives.h"
#include "FSFolder.h"

#if 0 // #ifndef UNDER_CE
#include "NetFolder.h"
#endif

#include "SysIconUtils.h"

#if _WIN32_WINNT < 0x0501
#ifdef _APISETFILE_
// Windows SDK 8.1 defines in fileapi.h the function GetCompressedFileSizeW only if _WIN32_WINNT >= 0x0501
// But real support version for that function is NT 3.1 (probably)
// So we must define GetCompressedFileSizeW
EXTERN_C_BEGIN
WINBASEAPI DWORD WINAPI GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh);
EXTERN_C_END
#endif
#endif

using namespace NWindows;
using namespace NFile;
using namespace NFind;
using namespace NDir;
using namespace NName;

#ifndef USE_UNICODE_FSTRING
int CompareFileNames_ForFolderList(const FChar *s1, const FChar *s2)
{
  return CompareFileNames_ForFolderList(fs2us(s1), fs2us(s2));
}
#endif

namespace NFsFolder {

static const Byte kProps[] =
{
  kpidName,
  kpidSize,
  kpidMTime,
  kpidCTime,
  kpidATime,
  kpidAttrib,
  kpidPackSize,
  #ifdef FS_SHOW_LINKS_INFO
  kpidINode,
  kpidLinks,
  #endif
  kpidComment,
  kpidNumSubDirs,
  kpidNumSubFiles,
  kpidPrefix
};

HRESULT CFSFolder::Init(const FString &path /* , IFolderFolder *parentFolder */)
{
  // _parentFolder = parentFolder;
  _path = path;

#ifdef _WIN32
  _findChangeNotification.FindFirst(_path, false,
        FILE_NOTIFY_CHANGE_FILE_NAME
      | FILE_NOTIFY_CHANGE_DIR_NAME
      | FILE_NOTIFY_CHANGE_ATTRIBUTES
      | FILE_NOTIFY_CHANGE_SIZE
      | FILE_NOTIFY_CHANGE_LAST_WRITE
      /*
      | FILE_NOTIFY_CHANGE_LAST_ACCESS
      | FILE_NOTIFY_CHANGE_CREATION
      | FILE_NOTIFY_CHANGE_SECURITY
      */
      );
  if (!_findChangeNotification.IsHandleAllocated())
  {
    DWORD lastError = GetLastError();
    CFindFile findFile;
    CFileInfo fi;
    if (!findFile.FindFirst(_path + FCHAR_ANY_MASK, fi))
      return lastError;
  }
#endif
  return S_OK;
}

HRESULT CFsFolderStat::Enumerate()
{
  if (Progress)
  {
    RINOK(Progress->SetCompleted(NULL));
  }
  Path.Add_PathSepar();
  unsigned len = Path.Len();
  Path += FCHAR_ANY_MASK;
  CEnumerator enumerator(Path);
  CFileInfo fi;
  while (enumerator.Next(fi))
  {
    if (fi.IsDir())
    {
      Path.DeleteFrom(len);
      Path += fi.Name;
      RINOK(Enumerate());
      NumFolders++;
    }
    else
    {
      NumFiles++;
      Size += fi.Size;
    }
  }
  return S_OK;
}

#if 0 // FIXME #ifndef UNDER_CE

bool MyGetCompressedFileSizeW(CFSTR path, UInt64 &size)
{
  DWORD highPart;
  DWORD lowPart = INVALID_FILE_SIZE;
  IF_USE_MAIN_PATH
  {
    lowPart = ::GetCompressedFileSizeW(fs2us(path), &highPart);
    if (lowPart != INVALID_FILE_SIZE || ::GetLastError() == NO_ERROR)
    {
      size = ((UInt64)highPart << 32) | lowPart;
      return true;
    }
  }
  #ifdef WIN_LONG_PATH
  if (USE_SUPER_PATH)
  {
    UString superPath;
    if (GetSuperPath(path, superPath, USE_MAIN_PATH))
    {
      lowPart = ::GetCompressedFileSizeW(superPath, &highPart);
      if (lowPart != INVALID_FILE_SIZE || ::GetLastError() == NO_ERROR)
      {
        size = ((UInt64)highPart << 32) | lowPart;
        return true;
      }
    }
  }
  #endif
  return false;
}

#endif

HRESULT CFSFolder::LoadSubItems(int dirItem, const FString &relPrefix)
{
  unsigned startIndex = Folders.Size();
  {
    CEnumerator enumerator(_path + relPrefix + FCHAR_ANY_MASK);
    CDirItem fi;
    fi.FolderStat_Defined = false;
    fi.NumFolders = 0;
    fi.NumFiles = 0;
    fi.Parent = dirItem;
    
    while (enumerator.Next(fi))
    {
      if (fi.IsDir())
      {
        fi.Size = 0;
        if (_flatMode)
          Folders.Add(relPrefix + fi.Name + FCHAR_PATH_SEPARATOR);
      }
      else
      {
        /*
        fi.PackSize_Defined = true;
        if (!MyGetCompressedFileSizeW(_path + relPrefix + fi.Name, fi.PackSize))
          fi.PackSize = fi.Size;
        */
      }
      
      #if 0 // FIXME #ifndef UNDER_CE

      fi.Reparse.Free();
      fi.PackSize_Defined = false;
    
      #ifdef FS_SHOW_LINKS_INFO
      fi.FileInfo_Defined = false;
      fi.FileInfo_WasRequested = false;
      fi.FileIndex = 0;
      fi.NumLinks = 0;
      #endif
      
      fi.PackSize = fi.Size;
      if (fi.HasReparsePoint())
      {
        fi.FileInfo_WasRequested = true;
        BY_HANDLE_FILE_INFORMATION info;
        NIO::GetReparseData(_path + relPrefix + fi.Name, fi.Reparse, &info);
        fi.NumLinks = info.nNumberOfLinks;
        fi.FileIndex = (((UInt64)info.nFileIndexHigh) << 32) + info.nFileIndexLow;
        fi.FileInfo_Defined = true;
      }

      #endif

      /* unsigned fileIndex = */ Files.Add(fi);

      #if defined(_WIN32) && !defined(UNDER_CE)
      /*
      if (_scanAltStreams)
      {
        CStreamEnumerator enumerator(_path + relPrefix + fi.Name);
        CStreamInfo si;
        for (;;)
        {
          bool found;
          if (!enumerator.Next(si, found))
          {
            // if (GetLastError() == ERROR_ACCESS_DENIED)
            //   break;
            // return E_FAIL;
            break;
          }
          if (!found)
            break;
          if (si.IsMainStream())
            continue;
          CAltStream ss;
          ss.Parent = fileIndex;
          ss.Name = si.GetReducedName();
          ss.Size = si.Size;
          ss.PackSize_Defined = false;
          ss.PackSize = si.Size;
          Streams.Add(ss);
        }
      }
      */
      #endif
    }
  }
  if (!_flatMode)
    return S_OK;

  unsigned endIndex = Folders.Size();
  for (unsigned i = startIndex; i < endIndex; i++)
    LoadSubItems(i, Folders[i]);
  return S_OK;
}

STDMETHODIMP CFSFolder::LoadItems()
{
  Int32 dummy;
  WasChanged(&dummy);
  Clear();
  RINOK(LoadSubItems(-1, FString()));
  _commentsAreLoaded = false;
  return S_OK;
}

static CFSTR kDescriptionFileName = FTEXT("descript.ion");

bool CFSFolder::LoadComments()
{
  _comments.Clear();
  _commentsAreLoaded = true;
  NIO::CInFile file;
  if (!file.Open(_path + kDescriptionFileName))
    return false;
  UInt64 len;
  if (!file.GetLength(len))
    return false;
  if (len >= (1 << 28))
    return false;
  AString s;
  char *p = s.GetBuf((unsigned)(size_t)len);
  UInt32 processedSize;
  file.Read(p, (UInt32)len, processedSize);
  s.ReleaseBuf_CalcLen((unsigned)(size_t)len);
  if (processedSize != len)
    return false;
  file.Close();
  UString unicodeString;
  if (!ConvertUTF8ToUnicode(s, unicodeString))
    return false;
  return _comments.ReadFromString(unicodeString);
}

bool CFSFolder::SaveComments()
{
  AString utf;
  {
    UString unicode;
    _comments.SaveToString(unicode);
    ConvertUnicodeToUTF8(unicode, utf);
  }
  if (!utf.IsAscii())
    utf.Insert(0, "\xEF\xBB\xBF" "\r\n");

  FString path = _path + kDescriptionFileName;
  // We must set same attrib. COutFile::CreateAlways can fail, if file has another attrib.
  DWORD attrib = FILE_ATTRIBUTE_NORMAL;
  {
    CFileInfo fi;
    if (fi.Find(path))
      attrib = fi.Attrib;
  }
  NIO::COutFile file;
  if (!file.CreateAlways(path, attrib))
    return false;
  UInt32 processed;
  file.Write(utf, utf.Len(), processed);
  _commentsAreLoaded = false;
  return true;
}

STDMETHODIMP CFSFolder::GetNumberOfItems(UInt32 *numItems)
{
  *numItems = Files.Size() /* + Streams.Size() */;
  return S_OK;
}

#ifdef USE_UNICODE_FSTRING

STDMETHODIMP CFSFolder::GetItemPrefix(UInt32 index, const wchar_t **name, unsigned *len)
{
  *name = 0;
  *len = 0;
  /*
  if (index >= Files.Size())
    index = Streams[index - Files.Size()].Parent;
  */
  CDirItem &fi = Files[index];
  if (fi.Parent >= 0)
  {
    const FString &fo = Folders[fi.Parent];
    USE_UNICODE_FSTRING
    *name = fo;
    *len = fo.Len();
  }
  return S_OK;
}

STDMETHODIMP CFSFolder::GetItemName(UInt32 index, const wchar_t **name, unsigned *len)
{
  *name = 0;
  *len = 0;
  if (index < Files.Size())
  {
    CDirItem &fi = Files[index];
    *name = fi.Name;
    *len = fi.Name.Len();
    return S_OK;
  }
  else
  {
    // const CAltStream &ss = Streams[index - Files.Size()];
    // *name = ss.Name;
    // *len = ss.Name.Len();
    //
    // change it;
  }
  return S_OK;
}

STDMETHODIMP_(UInt64) CFSFolder::GetItemSize(UInt32 index)
{
  /*
  if (index >= Files.Size())
    return Streams[index - Files.Size()].Size;
  */
  CDirItem &fi = Files[index];
  return fi.IsDir() ? 0 : fi.Size;
}

#endif

#ifdef FS_SHOW_LINKS_INFO
bool CFSFolder::ReadFileInfo(CDirItem &di)
{
  di.FileInfo_WasRequested = true;
  BY_HANDLE_FILE_INFORMATION info;
  if (!NIO::CFileBase::GetFileInformation(_path + GetRelPath(di), &info))
    return false;
  di.NumLinks = info.nNumberOfLinks;
  di.FileIndex = (((UInt64)info.nFileIndexHigh) << 32) + info.nFileIndexLow;
  di.FileInfo_Defined = true;
  return true;
}
#endif

STDMETHODIMP CFSFolder::GetProperty(UInt32 index, PROPID propID, PROPVARIANT *value)
{
  NCOM::CPropVariant prop;
  /*
  if (index >= (UInt32)Files.Size())
  {
    CAltStream &ss = Streams[index - Files.Size()];
    CDirItem &fi = Files[ss.Parent];
    switch (propID)
    {
      case kpidIsDir: prop = false; break;
      case kpidIsAltStream: prop = true; break;
      case kpidName: prop = fs2us(fi.Name) + ss.Name; break;
      case kpidSize: prop = ss.Size; break;
      case kpidPackSize:
        #ifdef UNDER_CE
        prop = ss.Size;
        #else
        if (!ss.PackSize_Defined)
        {
          ss.PackSize_Defined = true;
          if (!MyGetCompressedFileSizeW(_path + GetRelPath(fi) + us2fs(ss.Name), ss.PackSize))
            ss.PackSize = ss.Size;
        }
        prop = ss.PackSize;
        #endif
        break;
      case kpidComment: break;
      default: index = ss.Parent;
    }
    if (index >= (UInt32)Files.Size())
    {
      prop.Detach(value);
      return S_OK;
    }
  }
  */
  CDirItem &fi = Files[index];
  switch (propID)
  {
    case kpidIsDir: prop = fi.IsDir(); break;
    case kpidIsAltStream: prop = false; break;
    case kpidName: prop = fs2us(fi.Name); break;
    case kpidSize: if (!fi.IsDir() || fi.FolderStat_Defined) prop = fi.Size; break;
    case kpidPackSize:
      #if 1 // ifdef UNDER_CE
      prop = fi.Size;
      #else
      if (!fi.PackSize_Defined)
      {
        fi.PackSize_Defined = true;
        if (fi.IsDir () || !MyGetCompressedFileSizeW(_path + GetRelPath(fi), fi.PackSize))
          fi.PackSize = fi.Size;
      }
      prop = fi.PackSize;
      #endif
      break;

    #ifdef FS_SHOW_LINKS_INFO

    case kpidLinks:
      #ifdef UNDER_CE
      // prop = fi.NumLinks;
      #else
      if (!fi.FileInfo_WasRequested)
        ReadFileInfo(fi);
      if (fi.FileInfo_Defined)
        prop = fi.NumLinks;
      #endif
      break;
    
    case kpidINode:
      #ifdef UNDER_CE
      // prop = fi.FileIndex;
      #else
      if (!fi.FileInfo_WasRequested)
        ReadFileInfo(fi);
      if (fi.FileInfo_Defined)
        prop = fi.FileIndex;
      #endif
      break;
    
    #endif

    case kpidAttrib: prop = (UInt32)fi.Attrib; break;
    case kpidCTime: prop = fi.CTime; break;
    case kpidATime: prop = fi.ATime; break;
    case kpidMTime: prop = fi.MTime; break;
    case kpidComment:
    {
      if (!_commentsAreLoaded)
        LoadComments();
      UString comment;
      if (_comments.GetValue(fs2us(GetRelPath(fi)), comment))
      {
        int pos = comment.Find((wchar_t)4);
        if (pos >= 0)
          comment.DeleteFrom(pos);
        prop = comment;
      }
      break;
    }
    case kpidPrefix:
      if (fi.Parent >= 0)
        prop = Folders[fi.Parent];
      break;
    case kpidNumSubDirs: if (fi.IsDir() && fi.FolderStat_Defined) prop = fi.NumFolders; break;
    case kpidNumSubFiles: if (fi.IsDir() && fi.FolderStat_Defined) prop = fi.NumFiles; break;
  }
  prop.Detach(value);
  return S_OK;
}


// ---------- IArchiveGetRawProps ----------


STDMETHODIMP CFSFolder::GetNumRawProps(UInt32 *numProps)
{
  *numProps = 1;
  return S_OK;
}

STDMETHODIMP CFSFolder::GetRawPropInfo(UInt32 index, BSTR *name, PROPID *propID)
{
  index = index;
  *name = NULL;
  *propID = kpidNtReparse;
  return S_OK;
}

STDMETHODIMP CFSFolder::GetParent(UInt32 /* index */, UInt32 * /* parent */, UInt32 * /* parentType */)
{
  return E_FAIL;
}

STDMETHODIMP CFSFolder::GetRawProp(UInt32
  #ifndef UNDER_CE
  index
  #endif
  , PROPID
  #ifndef UNDER_CE
  propID
  #endif
  , const void **data, UInt32 *dataSize, UInt32 *propType)
{
  *data = NULL;
  *dataSize = 0;
  *propType = 0;
  
  #if 0 // #ifndef UNDER_CE
  if (propID == kpidNtReparse)
  {
    const CDirItem &fi = Files[index];
    const CByteBuffer &buf = fi.Reparse;
    if (buf.Size() == 0)
      return S_OK;
    *data = buf;
    *dataSize = (UInt32)buf.Size();
    *propType = NPropDataType::kRaw;
    return S_OK;
  }
  #endif
  
  return S_OK;
}


// returns Position of extension including '.'

static inline CFSTR GetExtensionPtr(const FString &name)
{
  int dotPos = name.ReverseFind_Dot();
  return name.Ptr((dotPos < 0) ? name.Len() : dotPos);
}

STDMETHODIMP_(Int32) CFSFolder::CompareItems(UInt32 index1, UInt32 index2, PROPID propID, Int32 /* propIsRaw */)
{
  /*
  const CAltStream *ss1 = NULL;
  const CAltStream *ss2 = NULL;
  if (index1 >= (UInt32)Files.Size()) { ss1 = &Streams[index1 - Files.Size()]; index1 = ss1->Parent; }
  if (index2 >= (UInt32)Files.Size()) { ss2 = &Streams[index2 - Files.Size()]; index2 = ss2->Parent; }
  */
  CDirItem &fi1 = Files[index1];
  CDirItem &fi2 = Files[index2];

  switch (propID)
  {
    case kpidName:
    {
      int comp = CompareFileNames_ForFolderList(fi1.Name, fi2.Name);
      /*
      if (comp != 0)
        return comp;
      if (!ss1)
        return ss2 ? -1 : 0;
      if (!ss2)
        return 1;
      return MyStringCompareNoCase(ss1->Name, ss2->Name);
      */
      return comp;
    }
    case kpidSize:
      return MyCompare(
          /* ss1 ? ss1->Size : */ fi1.Size,
          /* ss2 ? ss2->Size : */ fi2.Size);
    case kpidAttrib: return MyCompare(fi1.Attrib, fi2.Attrib);
    case kpidCTime: return CompareFileTime(&fi1.CTime, &fi2.CTime);
    case kpidATime: return CompareFileTime(&fi1.ATime, &fi2.ATime);
    case kpidMTime: return CompareFileTime(&fi1.MTime, &fi2.MTime);
    case kpidIsDir:
    {
      bool isDir1 = /* ss1 ? false : */ fi1.IsDir();
      bool isDir2 = /* ss2 ? false : */ fi2.IsDir();
      if (isDir1 == isDir2)
        return 0;
      return isDir1 ? -1 : 1;
    }
    case kpidPackSize:
    {
      #if 1 // #ifdef UNDER_CE
      return MyCompare(fi1.Size, fi2.Size);
      #else
      // PackSize can be undefined here
      return MyCompare(
          /* ss1 ? ss1->PackSize : */ fi1.PackSize,
          /* ss2 ? ss2->PackSize : */ fi2.PackSize);
      #endif
    }
    
    #ifdef FS_SHOW_LINKS_INFO
    case kpidINode:
    {
      #ifndef UNDER_CE
      if (!fi1.FileInfo_WasRequested) ReadFileInfo(fi1);
      if (!fi2.FileInfo_WasRequested) ReadFileInfo(fi2);
      return MyCompare(
          fi1.FileIndex,
          fi2.FileIndex);
      #endif
    }
    case kpidLinks:
    {
      #ifndef UNDER_CE
      if (!fi1.FileInfo_WasRequested) ReadFileInfo(fi1);
      if (!fi2.FileInfo_WasRequested) ReadFileInfo(fi2);
      return MyCompare(
          fi1.NumLinks,
          fi2.NumLinks);
      #endif
    }
    #endif

    case kpidComment:
    {
      // change it !
      UString comment1, comment2;
      _comments.GetValue(fs2us(GetRelPath(fi1)), comment1);
      _comments.GetValue(fs2us(GetRelPath(fi2)), comment2);
      return MyStringCompareNoCase(comment1, comment2);
    }
    case kpidPrefix:
      if (fi1.Parent < 0) return (fi2.Parent < 0) ? 0 : -1;
      if (fi2.Parent < 0) return 1;
      return CompareFileNames_ForFolderList(
          Folders[fi1.Parent],
          Folders[fi2.Parent]);
    case kpidExtension:
      return CompareFileNames_ForFolderList(
          GetExtensionPtr(fi1.Name),
          GetExtensionPtr(fi2.Name));
  }
  
  return 0;
}

HRESULT CFSFolder::BindToFolderSpec(CFSTR name, IFolderFolder **resultFolder)
{
  *resultFolder = 0;
  CFSFolder *folderSpec = new CFSFolder;
  CMyComPtr<IFolderFolder> subFolder = folderSpec;
  RINOK(folderSpec->Init(_path + name + FCHAR_PATH_SEPARATOR));
  *resultFolder = subFolder.Detach();
  return S_OK;
}

/*
void CFSFolder::GetPrefix(const CDirItem &item, FString &prefix) const
{
  if (item.Parent >= 0)
    prefix = Folders[item.Parent];
  else
    prefix.Empty();
}
*/

/*
void CFSFolder::GetPrefix(const CDirItem &item, FString &prefix) const
{
  int parent = item.Parent;

  unsigned len = 0;

  while (parent >= 0)
  {
    const CDirItem &cur = Files[parent];
    len += cur.Name.Len() + 1;
    parent = cur.Parent;
  }

  wchar_t *p = prefix.GetBuf_SetEnd(len) + len;
  parent = item.Parent;

  while (parent >= 0)
  {
    const CDirItem &cur = Files[parent];
    *(--p) = FCHAR_PATH_SEPARATOR;
    p -= cur.Name.Len();
    wmemcpy(p, cur.Name, cur.Name.Len());
    parent = cur.Parent;
  }
}
*/

FString CFSFolder::GetRelPath(const CDirItem &item) const
{
  if (item.Parent < 0)
    return item.Name;
  return Folders[item.Parent] + item.Name;
}

STDMETHODIMP CFSFolder::BindToFolder(UInt32 index, IFolderFolder **resultFolder)
{
  *resultFolder = 0;
  const CDirItem &fi = Files[index];
  if (!fi.IsDir())
    return E_INVALIDARG;
  return BindToFolderSpec(GetRelPath(fi), resultFolder);
}

STDMETHODIMP CFSFolder::BindToFolder(const wchar_t *name, IFolderFolder **resultFolder)
{
  return BindToFolderSpec(us2fs(name), resultFolder);
}

static const CFSTR kSuperPrefix = FTEXT("\\\\?\\");

STDMETHODIMP CFSFolder::BindToParentFolder(IFolderFolder **resultFolder)
{
  *resultFolder = 0;
  /*
  if (_parentFolder)
  {
    CMyComPtr<IFolderFolder> parentFolder = _parentFolder;
    *resultFolder = parentFolder.Detach();
    return S_OK;
  }
  */
  if (_path.IsEmpty())
    return E_INVALIDARG;
  int pos = _path.ReverseFind_PathSepar();
  if (pos < 0 || pos != (int)_path.Len() - 1)
    return E_FAIL;
  FString parentPath = _path.Left(pos);
  pos = parentPath.ReverseFind_PathSepar();
  if (pos < 0)
  {
    #ifdef UNDER_CE
    *resultFolder = 0;
    #else
    CFSDrives *drivesFolderSpec = new CFSDrives;
    CMyComPtr<IFolderFolder> drivesFolder = drivesFolderSpec;
    drivesFolderSpec->Init();
    *resultFolder = drivesFolder.Detach();
    #endif
    return S_OK;
  }
  
  /*
  parentPath.DeleteFrom(pos + 1);
  
  if (parentPath == kSuperPrefix)
  {
    #ifdef UNDER_CE
    *resultFolder = 0;
    #else
    CFSDrives *drivesFolderSpec = new CFSDrives;
    CMyComPtr<IFolderFolder> drivesFolder = drivesFolderSpec;
    drivesFolderSpec->Init(false, true);
    *resultFolder = drivesFolder.Detach();
    #endif
    return S_OK;
  }

  FString parentPathReduced = parentPath.Left(pos);
  
  #ifndef UNDER_CE
  pos = parentPathReduced.ReverseFind_PathSepar();
  if (pos == 1)
  {
    if (!IS_PATH_SEPAR_CHAR(parentPath[0]))
      return E_FAIL;
    CNetFolder *netFolderSpec = new CNetFolder;
    CMyComPtr<IFolderFolder> netFolder = netFolderSpec;
    netFolderSpec->Init(fs2us(parentPath));
    *resultFolder = netFolder.Detach();
    return S_OK;
  }
  #endif
  
  CFSFolder *parentFolderSpec = new CFSFolder;
  CMyComPtr<IFolderFolder> parentFolder = parentFolderSpec;
  RINOK(parentFolderSpec->Init(parentPath, 0));
  *resultFolder = parentFolder.Detach();
  */
  return S_OK;
}

STDMETHODIMP CFSFolder::GetNumberOfProperties(UInt32 *numProperties)
{
  *numProperties = ARRAY_SIZE(kProps);
  if (!_flatMode)
    (*numProperties)--;
  return S_OK;
}

STDMETHODIMP CFSFolder::GetPropertyInfo IMP_IFolderFolder_GetProp(kProps)

STDMETHODIMP CFSFolder::GetFolderProperty(PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NWindows::NCOM::CPropVariant prop;
  switch (propID)
  {
    case kpidType: prop = "FSFolder"; break;
    case kpidPath: prop = fs2us(_path); break;
  }
  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}

STDMETHODIMP CFSFolder::WasChanged(Int32 *wasChanged)
{
  bool wasChangedMain = false;
#ifdef _WIN32
  for (;;)
  {
    if (!_findChangeNotification.IsHandleAllocated())
    {
      *wasChanged = BoolToInt(false);
      return S_OK;
    }

    DWORD waitResult = ::WaitForSingleObject(_findChangeNotification, 0);
    bool wasChangedLoc = (waitResult == WAIT_OBJECT_0);
    if (wasChangedLoc)
    {
      _findChangeNotification.FindNext();
      wasChangedMain = true;
    }
    else
      break;
  }
#endif
  *wasChanged = BoolToInt(wasChangedMain);
  return S_OK;
}
 
STDMETHODIMP CFSFolder::Clone(IFolderFolder **resultFolder)
{
  CFSFolder *fsFolderSpec = new CFSFolder;
  CMyComPtr<IFolderFolder> folderNew = fsFolderSpec;
  fsFolderSpec->Init(_path);
  *resultFolder = folderNew.Detach();
  return S_OK;
}

HRESULT CFSFolder::GetItemsFullSize(const UInt32 *indices, UInt32 numItems, CFsFolderStat &stat)
{
  for (UInt32 i = 0; i < numItems; i++)
  {
    UInt32 index = indices[i];
    /*
    if (index >= Files.Size())
    {
      size += Streams[index - Files.Size()].Size;
      // numFiles++;
      continue;
    }
    */
    const CDirItem &fi = Files[index];
    if (fi.IsDir())
    {
      stat.Path = _path;
      stat.Path += GetRelPath(fi);
      RINOK(stat.Enumerate());
      stat.NumFolders++;
    }
    else
    {
      stat.NumFiles++;
      stat.Size += fi.Size;
    }
  }
  return S_OK;
}

/*
HRESULT CFSFolder::GetItemFullSize(unsigned index, UInt64 &size, IProgress *progress)
{
  if (index >= Files.Size())
  {
    size = Streams[index - Files.Size()].Size;
    return S_OK;
  }
  const CDirItem &fi = Files[index];
  if (fi.IsDir())
  {
    UInt64 numFolders = 0, numFiles = 0;
    size = 0;
    return GetFolderSize(_path + GetRelPath(fi), numFolders, numFiles, size, progress);
  }
  size = fi.Size;
  return S_OK;
}

STDMETHODIMP CFSFolder::GetItemFullSize(UInt32 index, PROPVARIANT *value, IProgress *progress)
{
  NCOM::CPropVariant prop;
  UInt64 size = 0;
  HRESULT result = GetItemFullSize(index, size, progress);
  prop = size;
  prop.Detach(value);
  return result;
}
*/

STDMETHODIMP CFSFolder::CalcItemFullSize(UInt32 index, IProgress *progress)
{
  if (index >= (UInt32)Files.Size())
    return S_OK;
  CDirItem &fi = Files[index];
  if (!fi.IsDir())
    return S_OK;
  CFsFolderStat stat(_path + GetRelPath(fi), progress);
  RINOK(stat.Enumerate());
  fi.Size = stat.Size;
  fi.NumFolders = stat.NumFolders;
  fi.NumFiles = stat.NumFiles;
  fi.FolderStat_Defined = true;
  return S_OK;
}

void CFSFolder::GetAbsPath(const wchar_t *name, FString &absPath)
{
  absPath.Empty();
  if (!IsAbsolutePath(name))
    absPath += _path;
  absPath += us2fs(name);
}

STDMETHODIMP CFSFolder::CreateFolder(const wchar_t *name, IProgress * /* progress */)
{
  FString absPath;
  GetAbsPath(name, absPath);
  if (CreateDir(absPath))
    return S_OK;
  if (::GetLastError() == ERROR_ALREADY_EXISTS)
    return ::GetLastError();
  if (!CreateComplexDir(absPath))
    return ::GetLastError();
  return S_OK;
}

STDMETHODIMP CFSFolder::CreateFile(const wchar_t *name, IProgress * /* progress */)
{
  FString absPath;
  GetAbsPath(name, absPath);
  NIO::COutFile outFile;
  if (!outFile.Create(absPath, false))
    return ::GetLastError();
  return S_OK;
}

STDMETHODIMP CFSFolder::Rename(UInt32 index, const wchar_t *newName, IProgress * /* progress */)
{
  if (index >= (UInt32)Files.Size())
    return E_NOTIMPL;
  const CDirItem &fi = Files[index];
  // FString prefix;
  // GetPrefix(fi, prefix);
  FString fullPrefix = _path;
  if (fi.Parent >= 0)
    fullPrefix += Folders[fi.Parent];
  if (!MyMoveFile(fullPrefix + fi.Name, fullPrefix + us2fs(newName)))
    return GetLastError();
  return S_OK;
}

STDMETHODIMP CFSFolder::Delete(const UInt32 *indices, UInt32 numItems,IProgress *progress)
{
  RINOK(progress->SetTotal(numItems));
  // int prevDeletedFileIndex = -1;
  for (UInt32 i = 0; i < numItems; i++)
  {
    // Sleep(200);
    UInt32 index = indices[i];
    bool result = true;
    /*
    if (index >= (UInt32)Files.Size())
    {
      const CAltStream &ss = Streams[index - (UInt32)Files.Size()];
      if (prevDeletedFileIndex != ss.Parent)
      {
        const CDirItem &fi = Files[ss.Parent];
        result = DeleteFileAlways(_path + GetRelPath(fi) + us2fs(ss.Name));
      }
    }
    else
    */
    {
      const CDirItem &fi = Files[index];
      const FString fullPath = _path + GetRelPath(fi);
      // prevDeletedFileIndex = index;
      if (fi.IsDir())
        result = RemoveDirWithSubItems(fullPath);
      else
        result = DeleteFileAlways(fullPath);
    }
    if (!result)
      return GetLastError();
    UInt64 completed = i;
    RINOK(progress->SetCompleted(&completed));
  }
  return S_OK;
}

STDMETHODIMP CFSFolder::SetProperty(UInt32 index, PROPID propID,
    const PROPVARIANT *value, IProgress * /* progress */)
{
  if (index >= (UInt32)Files.Size())
    return E_INVALIDARG;
  CDirItem &fi = Files[index];
  if (fi.Parent >= 0)
    return E_NOTIMPL;
  switch (propID)
  {
    case kpidComment:
    {
      UString filename = fs2us(fi.Name);
      filename.Trim();
      if (value->vt == VT_EMPTY)
        _comments.DeletePair(filename);
      else if (value->vt == VT_BSTR)
      {
        CTextPair pair;
        pair.ID = filename;
        pair.ID.Trim();
        pair.Value.SetFromBstr(value->bstrVal);
        pair.Value.Trim();
        if (pair.Value.IsEmpty())
          _comments.DeletePair(filename);
        else
          _comments.AddPair(pair);
      }
      else
        return E_INVALIDARG;
      SaveComments();
      break;
    }
    default:
      return E_NOTIMPL;
  }
  return S_OK;
}

STDMETHODIMP CFSFolder::GetSystemIconIndex(UInt32 index, Int32 *iconIndex)
{
  if (index >= (UInt32)Files.Size())
    return E_INVALIDARG;
  const CDirItem &fi = Files[index];
  *iconIndex = 0;
  int iconIndexTemp;
  if (GetRealIconIndex(_path + GetRelPath(fi), fi.Attrib, iconIndexTemp) != 0)
  {
    *iconIndex = iconIndexTemp;
    return S_OK;
  }
  return GetLastError();
}

STDMETHODIMP CFSFolder::SetFlatMode(Int32 flatMode)
{
  _flatMode = IntToBool(flatMode);
  return S_OK;
}

/*
STDMETHODIMP CFSFolder::SetShowNtfsStreamsMode(Int32 showStreamsMode)
{
  _scanAltStreams = IntToBool(showStreamsMode);
  return S_OK;
}
*/

}
// FSFolder.h

#ifndef __FS_FOLDER_H
#define __FS_FOLDER_H

#include "../../../Common/MyCom.h"
#include "../../../Common/MyBuffer.h"

#include "../../../Windows/FileFind.h"

#include "../../Archive/IArchive.h"

#include "IFolder.h"
#include "TextPairs.h"

namespace NFsFolder {

class CFSFolder;

#ifdef _WIN32
#define FS_SHOW_LINKS_INFO
#endif

struct CDirItem: public NWindows::NFile::NFind::CFileInfo
{
  #ifndef UNDER_CE
  UInt64 PackSize;
  #endif

  #ifdef FS_SHOW_LINKS_INFO
  UInt64 FileIndex;
  UInt32 NumLinks;
  bool FileInfo_Defined;
  bool FileInfo_WasRequested;
  #endif

  #ifndef UNDER_CE
  bool PackSize_Defined;
  #endif

  bool FolderStat_Defined;

  #ifndef UNDER_CE
  CByteBuffer Reparse;
  #endif
  
  UInt64 NumFolders;
  UInt64 NumFiles;
  
  int Parent;
};

/*
struct CAltStream
{
  UInt64 Size;
  UInt64 PackSize;
  bool PackSize_Defined;
  int Parent;
  UString Name;
};
*/

struct CFsFolderStat
{
  UInt64 NumFolders;
  UInt64 NumFiles;
  UInt64 Size;
  IProgress *Progress;
  FString Path;

  CFsFolderStat(): NumFolders(0), NumFiles(0), Size(0), Progress(NULL) {}
  CFsFolderStat(const FString &path, IProgress *progress = NULL):
      NumFolders(0), NumFiles(0), Size(0), Progress(progress), Path(path) {}

  HRESULT Enumerate();
};

class CFSFolder:
  public IFolderFolder,
  public IArchiveGetRawProps,
  public IFolderCompare,
  #ifdef USE_UNICODE_FSTRING
  public IFolderGetItemName,
  #endif
  public IFolderWasChanged,
  public IFolderOperations,
  // public IFolderOperationsDeleteToRecycleBin,
  public IFolderCalcItemFullSize,
  public IFolderClone,
  public IFolderGetSystemIconIndex,
  public IFolderSetFlatMode,
  // public IFolderSetShowNtfsStreamsMode,
  public CMyUnknownImp
{
public:
  MY_QUERYINTERFACE_BEGIN2(IFolderFolder)
    MY_QUERYINTERFACE_ENTRY(IArchiveGetRawProps)
    MY_QUERYINTERFACE_ENTRY(IFolderCompare)
    #ifdef USE_UNICODE_FSTRING
    MY_QUERYINTERFACE_ENTRY(IFolderGetItemName)
    #endif
    MY_QUERYINTERFACE_ENTRY(IFolderWasChanged)
    // MY_QUERYINTERFACE_ENTRY(IFolderOperationsDeleteToRecycleBin)
    MY_QUERYINTERFACE_ENTRY(IFolderOperations)
    MY_QUERYINTERFACE_ENTRY(IFolderCalcItemFullSize)
    MY_QUERYINTERFACE_ENTRY(IFolderClone)
    MY_QUERYINTERFACE_ENTRY(IFolderGetSystemIconIndex)
    MY_QUERYINTERFACE_ENTRY(IFolderSetFlatMode)
    // MY_QUERYINTERFACE_ENTRY(IFolderSetShowNtfsStreamsMode)
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE


  INTERFACE_FolderFolder(;)
  INTERFACE_IArchiveGetRawProps(;)
  INTERFACE_FolderOperations(;)

  STDMETHOD_(Int32, CompareItems)(UInt32 index1, UInt32 index2, PROPID propID, Int32 propIsRaw);

  #ifdef USE_UNICODE_FSTRING
  INTERFACE_IFolderGetItemName(;)
  #endif
  STDMETHOD(WasChanged)(Int32 *wasChanged);
  STDMETHOD(Clone)(IFolderFolder **resultFolder);
  STDMETHOD(CalcItemFullSize)(UInt32 index, IProgress *progress);

  STDMETHOD(SetFlatMode)(Int32 flatMode);
  // STDMETHOD(SetShowNtfsStreamsMode)(Int32 showStreamsMode);

  STDMETHOD(GetSystemIconIndex)(UInt32 index, Int32 *iconIndex);

private:
  FString _path;
  
  CObjectVector<CDirItem> Files;
  FStringVector Folders;
  // CObjectVector<CAltStream> Streams;
  // CMyComPtr<IFolderFolder> _parentFolder;

  bool _commentsAreLoaded;
  CPairsStorage _comments;

  // bool _scanAltStreams;
  bool _flatMode;

  // FIXME NWindows::NFile::NFind::CFindChangeNotification _findChangeNotification;

  HRESULT GetItemsFullSize(const UInt32 *indices, UInt32 numItems, CFsFolderStat &stat);

  HRESULT GetItemFullSize(unsigned index, UInt64 &size, IProgress *progress);
  void GetAbsPath(const wchar_t *name, FString &absPath);
  HRESULT BindToFolderSpec(CFSTR name, IFolderFolder **resultFolder);

  bool LoadComments();
  bool SaveComments();
  HRESULT LoadSubItems(int dirItem, const FString &path);
  
  #ifdef FS_SHOW_LINKS_INFO
  bool ReadFileInfo(CDirItem &di);
  #endif

public:
  HRESULT Init(const FString &path /* , IFolderFolder *parentFolder */);
  #if !defined(_WIN32) || defined(UNDER_CE)
  HRESULT InitToRoot() { return Init(FSTRING_PATH_SEPARATOR /* , NULL */); }
  #endif

  CFSFolder() : _flatMode(false)
    // , _scanAltStreams(false)
  {}

  void GetFullPath(const CDirItem &item, FString &path) const
  {
    // FString prefix;
    // GetPrefix(item, prefix);
    path = _path;
    if (item.Parent >= 0)
      path += Folders[item.Parent];
    path += item.Name;
  }

  // void GetPrefix(const CDirItem &item, FString &prefix) const;

  FString GetRelPath(const CDirItem &item) const;

  void Clear()
  {
    Files.Clear();
    Folders.Clear();
    // Streams.Clear();
  }
};

struct CCopyStateIO
{
  IProgress *Progress;
  UInt64 TotalSize;
  UInt64 StartPos;
  UInt64 CurrentSize;
  bool DeleteSrcFile;

  int ErrorFileIndex;
  UString ErrorMessage;

  CCopyStateIO(): DeleteSrcFile(false), TotalSize(0), StartPos(0) {}

  HRESULT MyCopyFile(CFSTR inPath, CFSTR outPath);
};

HRESULT SendLastErrorMessage(IFolderOperationsExtractCallback *callback, const FString &fileName);

}

#endif
// FSFolderCopy.cpp

#include "StdAfx.h"

#include "../../../Common/MyWindows.h"

#ifdef _WIN32
#include <Winbase.h>
#endif

#include "../../../Common/Defs.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/Wildcard.h"

#include "../../../Windows/DLL.h"
#include "../../../Windows/ErrorMsg.h"
#include "../../../Windows/FileDir.h"
#include "../../../Windows/FileName.h"

#include "../../Common/FilePathAutoRename.h"

#include "FSFolder.h"

using namespace NWindows;
using namespace NFile;
using namespace NDir;
using namespace NName;
using namespace NFind;

#ifndef _UNICODE
extern bool g_IsNT;
#endif

namespace NFsFolder {

HRESULT CCopyStateIO::MyCopyFile(CFSTR inPath, CFSTR outPath)
{
  ErrorFileIndex = -1;
  ErrorMessage.Empty();
  CurrentSize = 0;

  {
    const size_t kBufSize = 1 << 16;
    CByteArr buf(kBufSize);
    
    NIO::CInFile inFile;
    NIO::COutFile outFile;
    
    if (!inFile.Open(inPath))
    {
      ErrorFileIndex = 0;
      return S_OK;
    }
    
    if (!outFile.Create(outPath, true))
    {
      ErrorFileIndex = 1;
      return S_OK;
    }
    
    for (;;)
    {
      UInt32 num;
      if (!inFile.Read(buf, kBufSize, num))
      {
        ErrorFileIndex = 0;
        return S_OK;
      }
      if (num == 0)
        break;
      
      UInt32 written = 0;
      if (!outFile.Write(buf, num, written))
      {
        ErrorFileIndex = 1;
        return S_OK;
      }
      if (written != num)
      {
        ErrorMessage = L"Write error";
        return S_OK;
      }
      CurrentSize += num;
      if (Progress)
      {
        UInt64 completed = StartPos + CurrentSize;
        RINOK(Progress->SetCompleted(&completed));
      }
    }
  }

  if (DeleteSrcFile)
  {
    if (!DeleteFileAlways(inPath))
    {
      ErrorFileIndex = 0;
      return S_OK;
    }
  }
  
  return S_OK;
}


/*
static bool IsItWindows2000orHigher()
{
  OSVERSIONINFO versionInfo;
  versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
  if (!::GetVersionEx(&versionInfo))
    return false;
  return (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
      (versionInfo.dwMajorVersion >= 5);
}
*/

struct CProgressInfo
{
  UInt64 TotalSize;
  UInt64 StartPos;
  UInt64 FileSize;
  IProgress *Progress;
  HRESULT ProgressResult;

  void Init() { ProgressResult = S_OK; }
};

#ifdef _WIN32

#ifndef PROGRESS_CONTINUE

#define PROGRESS_CONTINUE 0
#define PROGRESS_CANCEL 1

#define COPY_FILE_FAIL_IF_EXISTS 0x00000001

typedef
DWORD
(WINAPI* LPPROGRESS_ROUTINE)(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData
    );

#endif

static DWORD CALLBACK CopyProgressRoutine(
  LARGE_INTEGER TotalFileSize,          // file size
  LARGE_INTEGER TotalBytesTransferred,  // bytes transferred
  LARGE_INTEGER /* StreamSize */,             // bytes in stream
  LARGE_INTEGER /* StreamBytesTransferred */, // bytes transferred for stream
  DWORD /* dwStreamNumber */,                 // current stream
  DWORD /* dwCallbackReason */,               // callback reason
  HANDLE /* hSourceFile */,                   // handle to source file
  HANDLE /* hDestinationFile */,              // handle to destination file
  LPVOID lpData                         // from CopyFileEx
)
{
  TotalFileSize = TotalFileSize;
  // TotalBytesTransferred = TotalBytesTransferred;
  // StreamSize = StreamSize;
  // StreamBytesTransferred = StreamBytesTransferred;
  // dwStreamNumber = dwStreamNumber;
  // dwCallbackReason = dwCallbackReason;

  CProgressInfo &pi = *(CProgressInfo *)lpData;

  if ((UInt64)TotalFileSize.QuadPart > pi.FileSize)
  {
    pi.TotalSize += (UInt64)TotalFileSize.QuadPart - pi.FileSize;
    pi.FileSize = (UInt64)TotalFileSize.QuadPart;
    pi.ProgressResult = pi.Progress->SetTotal(pi.TotalSize);
  }
  UInt64 completed = pi.StartPos + TotalBytesTransferred.QuadPart;
  pi.ProgressResult = pi.Progress->SetCompleted(&completed);
  return (pi.ProgressResult == S_OK ? PROGRESS_CONTINUE : PROGRESS_CANCEL);
}

typedef BOOL (WINAPI * Func_CopyFileExA)(
    IN LPCSTR lpExistingFileName,
    IN LPCSTR lpNewFileName,
    IN LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    IN LPVOID lpData OPTIONAL,
    IN LPBOOL pbCancel OPTIONAL,
    IN DWORD dwCopyFlags
    );

typedef BOOL (WINAPI * Func_CopyFileExW)(
    IN LPCWSTR lpExistingFileName,
    IN LPCWSTR lpNewFileName,
    IN LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    IN LPVOID lpData OPTIONAL,
    IN LPBOOL pbCancel OPTIONAL,
    IN DWORD dwCopyFlags
    );

typedef BOOL (WINAPI * Func_MoveFileWithProgressW)(
    IN LPCWSTR lpExistingFileName,
    IN LPCWSTR lpNewFileName,
    IN LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    IN LPVOID lpData OPTIONAL,
    IN DWORD dwFlags
    );

struct CCopyState
{
  CProgressInfo ProgressInfo;
  IFolderOperationsExtractCallback *Callback;
  UInt64 TotalSize;
  bool MoveMode;
  bool UseReadWriteMode;

  Func_CopyFileExW my_CopyFileExW;
  #ifndef UNDER_CE
  Func_MoveFileWithProgressW my_MoveFileWithProgressW;
  #endif
  #ifndef _UNICODE
  Func_CopyFileExA my_CopyFileExA;
  #endif

  void Prepare();
  bool CopyFile_NT(const wchar_t *oldFile, const wchar_t *newFile);
  bool CopyFile_Sys(CFSTR oldFile, CFSTR newFile);
  bool MoveFile_Sys(CFSTR oldFile, CFSTR newFile);

  HRESULT CallProgress();

  bool IsCallbackProgressError() { return ProgressInfo.ProgressResult != S_OK; }
};
#else
struct CCopyState
{
  CProgressInfo ProgressInfo;
  IFolderOperationsExtractCallback *Callback;
  UInt64 TotalSize;
  bool MoveMode;
  bool UseReadWriteMode;
  HRESULT CallProgress();

  void Prepare();
  bool CopyFile_NT(const wchar_t *oldFile, const wchar_t *newFile);
  bool CopyFile_Sys(CFSTR oldFile, CFSTR newFile);
  bool MoveFile_Sys(CFSTR oldFile, CFSTR newFile);

  bool IsCallbackProgressError() { return ProgressInfo.ProgressResult != S_OK; }
};
#endif

HRESULT CCopyState::CallProgress()
{
  return ProgressInfo.Progress->SetCompleted(&ProgressInfo.StartPos);
}


void CCopyState::Prepare()
{
#ifdef _WIN32
  my_CopyFileExW = NULL;
  #ifndef UNDER_CE
  my_MoveFileWithProgressW = NULL;
  #endif
  #ifndef _UNICODE
  my_CopyFileExA = NULL;
  if (!g_IsNT)
  {
    my_CopyFileExA = (Func_CopyFileExA)::GetProcAddress(::GetModuleHandleA("kernel32.dll"), "CopyFileExA");
  }
  else
  #endif
  {
    HMODULE module = ::GetModuleHandleW(
      #ifdef UNDER_CE
        L"coredll.dll"
      #else
        L"kernel32.dll"
      #endif
        );
    my_CopyFileExW = (Func_CopyFileExW)My_GetProcAddress(module, "CopyFileExW");
    #ifndef UNDER_CE
    my_MoveFileWithProgressW = (Func_MoveFileWithProgressW)My_GetProcAddress(module, "MoveFileWithProgressW");
    #endif
  }
#endif
}

/* WinXP-64:
  CopyFileW(fromFile, toFile:altStream)
    OK                       - there are NO alt streams in fromFile
    ERROR_INVALID_PARAMETER  - there are    alt streams in fromFile
*/

bool CCopyState::CopyFile_NT(const wchar_t *oldFile, const wchar_t *newFile)
{
#ifdef _WIN32
  BOOL cancelFlag = FALSE;
  if (my_CopyFileExW)
    return BOOLToBool(my_CopyFileExW(oldFile, newFile, CopyProgressRoutine,
        &ProgressInfo, &cancelFlag, COPY_FILE_FAIL_IF_EXISTS));
  return BOOLToBool(::CopyFileW(oldFile, newFile, TRUE));
#else

  extern bool wxw_CopyFile(LPCWSTR existingFile, LPCWSTR newFile, bool overwrite);
  return wxw_CopyFile(oldFile, newFile, true);

#endif
}


bool CCopyState::CopyFile_Sys(CFSTR oldFile, CFSTR newFile)
{
#ifdef _WIN32
  #ifndef _UNICODE
  if (!g_IsNT)
  {
    if (my_CopyFileExA)
    {
      BOOL cancelFlag = FALSE;
      if (my_CopyFileExA(fs2fas(oldFile), fs2fas(newFile),
          CopyProgressRoutine, &ProgressInfo, &cancelFlag, COPY_FILE_FAIL_IF_EXISTS))
        return true;
      if (::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
        return false;
    }
    return BOOLToBool(::CopyFile(fs2fas(oldFile), fs2fas(newFile), TRUE));
  }
  else
  #endif
  {
    IF_USE_MAIN_PATH_2(oldFile, newFile)
    {
      if (CopyFile_NT(fs2us(oldFile), fs2us(newFile)))
        return true;
    }
    #ifdef WIN_LONG_PATH
    if (USE_SUPER_PATH_2)
    {
      if (IsCallbackProgressError())
        return false;
      UString superPathOld, superPathNew;
      if (!GetSuperPaths(oldFile, newFile, superPathOld, superPathNew, USE_MAIN_PATH_2))
        return false;
      if (CopyFile_NT(superPathOld, superPathNew))
        return true;
    }
    #endif
    return false;
  }
#else

  extern bool wxw_CopyFile(LPCWSTR existingFile, LPCWSTR newFile, bool overwrite);
  return wxw_CopyFile(oldFile, newFile, true);

#endif
}

bool CCopyState::MoveFile_Sys(CFSTR oldFile, CFSTR newFile)
{
  #if 0 // FIXME #ifndef UNDER_CE
  // if (IsItWindows2000orHigher())
  // {
    if (my_MoveFileWithProgressW)
    {
      IF_USE_MAIN_PATH_2(oldFile, newFile)
      {
        if (my_MoveFileWithProgressW(fs2us(oldFile), fs2us(newFile), CopyProgressRoutine,
            &ProgressInfo, MOVEFILE_COPY_ALLOWED))
          return true;
      }
      #ifdef WIN_LONG_PATH
      if ((!(USE_MAIN_PATH_2) || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED) && USE_SUPER_PATH_2)
      {
        if (IsCallbackProgressError())
          return false;
        UString superPathOld, superPathNew;
        if (!GetSuperPaths(oldFile, newFile, superPathOld, superPathNew, USE_MAIN_PATH_2))
          return false;
        if (my_MoveFileWithProgressW(superPathOld, superPathNew, CopyProgressRoutine,
            &ProgressInfo, MOVEFILE_COPY_ALLOWED))
          return true;
      }
      #endif
      if (::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
        return false;
    }
  // }
  // else
  #endif
    return MyMoveFile(oldFile, newFile);
}

static HRESULT SendMessageError(IFolderOperationsExtractCallback *callback,
    const wchar_t *message, const FString &fileName)
{
  UString s = message;
  s += L" : ";
  s += fs2us(fileName);
  return callback->ShowMessage(s);
}

static HRESULT SendMessageError(IFolderOperationsExtractCallback *callback,
    const char *message, const FString &fileName)
{
  return SendMessageError(callback, MultiByteToUnicodeString(message), fileName);
}

static DWORD Return_LastError_or_FAIL()
{
  DWORD errorCode = GetLastError();
  if (errorCode == 0)
    errorCode = (DWORD)E_FAIL;
  return errorCode;
}

static UString GetLastErrorMessage()
{
  return NError::MyFormatMessage(Return_LastError_or_FAIL());
}

HRESULT SendLastErrorMessage(IFolderOperationsExtractCallback *callback, const FString &fileName)
{
  return SendMessageError(callback, GetLastErrorMessage(), fileName);
}

static HRESULT CopyFile_Ask(
    CCopyState &state,
    const FString &srcPath,
    const CFileInfo &srcFileInfo,
    const FString &destPath)
{
  if (CompareFileNames(destPath, srcPath) == 0)
  {
    RINOK(SendMessageError(state.Callback,
        state.MoveMode ?
          "can not move file onto itself" :
          "can not copy file onto itself"
        , destPath));
    return E_ABORT;
  }

  Int32 writeAskResult;
  CMyComBSTR destPathResult;
  RINOK(state.Callback->AskWrite(
      fs2us(srcPath),
      BoolToInt(false),
      &srcFileInfo.MTime, &srcFileInfo.Size,
      fs2us(destPath),
      &destPathResult,
      &writeAskResult));
  
  if (IntToBool(writeAskResult))
  {
    FString destPathNew = us2fs((LPCOLESTR)destPathResult);
    RINOK(state.Callback->SetCurrentFilePath(fs2us(srcPath)));

    if (state.UseReadWriteMode)
    {
      NFsFolder::CCopyStateIO state2;
      state2.Progress = state.Callback;
      state2.DeleteSrcFile = state.MoveMode;
      state2.TotalSize = state.TotalSize;
      state2.StartPos = state.ProgressInfo.StartPos;
      RINOK(state2.MyCopyFile(srcPath, destPathNew));
      if (state2.ErrorFileIndex >= 0)
      {
        if (state2.ErrorMessage.IsEmpty())
          state2.ErrorMessage = GetLastErrorMessage();
        FString errorName;
        if (state2.ErrorFileIndex == 0)
          errorName = srcPath;
        else
          errorName = destPathNew;
        RINOK(SendMessageError(state.Callback, state2.ErrorMessage, errorName));
        return E_ABORT;
      }
      state.ProgressInfo.StartPos += state2.CurrentSize;
    }
    else
    {
      state.ProgressInfo.FileSize = srcFileInfo.Size;
      bool res;
      if (state.MoveMode)
        res = state.MoveFile_Sys(srcPath, destPathNew);
      else
        res = state.CopyFile_Sys(srcPath, destPathNew);
      RINOK(state.ProgressInfo.ProgressResult);
      if (!res)
      {
        // GetLastError() is ERROR_REQUEST_ABORTED in case of PROGRESS_CANCEL.
        RINOK(SendMessageError(state.Callback, GetLastErrorMessage(), destPathNew));
        return E_ABORT;
      }
      state.ProgressInfo.StartPos += state.ProgressInfo.FileSize;
    }
  }
  else
  {
    if (state.TotalSize >= srcFileInfo.Size)
    {
      state.TotalSize -= srcFileInfo.Size;
      RINOK(state.ProgressInfo.Progress->SetTotal(state.TotalSize));
    }
  }
  return state.CallProgress();
}

static FString CombinePath(const FString &folderPath, const FString &fileName)
{
  return folderPath + FCHAR_PATH_SEPARATOR + fileName;
}

static bool IsDestChild(const FString &src, const FString &dest)
{
  unsigned len = src.Len();
  if (dest.Len() < len)
    return false;
  if (dest.Len() != len && dest[len] != FCHAR_PATH_SEPARATOR)
    return false;
  return CompareFileNames(dest.Left(len), src) == 0;
}

static HRESULT CopyFolder(
    CCopyState &state,
    const FString &srcPath,   // without TAIL separator
    const FString &destPath)  // without TAIL separator
{
  RINOK(state.CallProgress());

  if (IsDestChild(srcPath, destPath))
  {
    RINOK(SendMessageError(state.Callback,
        state.MoveMode ?
          "can not copy folder onto itself" :
          "can not move folder onto itself"
        , destPath));
    return E_ABORT;
  }

  if (state.MoveMode)
  {
    if (state.MoveFile_Sys(srcPath, destPath))
      return S_OK;

    // MSDN: MoveFile() fails for dirs on different volumes.
  }

  if (!CreateComplexDir(destPath))
  {
    RINOK(SendMessageError(state.Callback, "can not create folder", destPath));
    return E_ABORT;
  }

  CEnumerator enumerator(CombinePath(srcPath, FSTRING_ANY_MASK));
  
  for (;;)
  {
    NFind::CFileInfo fi;
    bool found;
    if (!enumerator.Next(fi, found))
    {
      SendLastErrorMessage(state.Callback, srcPath);
      return S_OK;
    }
    if (!found)
      break;
    const FString srcPath2 = CombinePath(srcPath, fi.Name);
    const FString destPath2 = CombinePath(destPath, fi.Name);
    if (fi.IsDir())
    {
      RINOK(CopyFolder(state, srcPath2, destPath2))
    }
    else
    {
      RINOK(CopyFile_Ask(state, srcPath2, fi, destPath2));
    }
  }

  if (state.MoveMode)
  {
    if (!RemoveDir(srcPath))
    {
      RINOK(SendMessageError(state.Callback, "can not remove folder", srcPath));
      return E_ABORT;
    }
  }
  
  return S_OK;
}

STDMETHODIMP CFSFolder::CopyTo(Int32 moveMode, const UInt32 *indices, UInt32 numItems,
    Int32 /* includeAltStreams */, Int32 /* replaceAltStreamColon */,
    const wchar_t *path, IFolderOperationsExtractCallback *callback)
{
  if (numItems == 0)
    return S_OK;

  FString destPath = us2fs(path);
  if (destPath.IsEmpty())
    return E_INVALIDARG;

  bool isAltDest = false; // FIXME NName::IsAltPathPrefix(destPath);;
  bool isDirectPath = (!isAltDest && !IsPathSepar(destPath.Back()));

  if (isDirectPath)
  {
    if (numItems > 1)
      return E_INVALIDARG;
  }

  CFsFolderStat stat;
  stat.Progress = callback;
  RINOK(GetItemsFullSize(indices, numItems, stat));

  if (stat.NumFolders != 0 && isAltDest)
    return E_NOTIMPL;

  RINOK(callback->SetTotal(stat.Size));
  RINOK(callback->SetNumFiles(stat.NumFiles));

  UInt64 completedSize = 0;
  RINOK(callback->SetCompleted(&completedSize));

  CCopyState state;
  state.ProgressInfo.TotalSize = stat.Size;
  state.ProgressInfo.StartPos = 0;
  state.ProgressInfo.Progress = callback;
  state.ProgressInfo.Init();
  state.Callback = callback;
  state.MoveMode = IntToBool(moveMode);
  state.UseReadWriteMode = isAltDest;
  state.Prepare();

  for (UInt32 i = 0; i < numItems; i++)
  {
    UInt32 index = indices[i];
    if (index >= (UInt32)Files.Size())
      continue;
    const CDirItem &fi = Files[index];
    FString destPath2 = destPath;
    if (!isDirectPath)
      destPath2 += fi.Name;
    FString srcPath;
    GetFullPath(fi, srcPath);
  
    if (fi.IsDir())
    {
      RINOK(CopyFolder(state, srcPath, destPath2));
    }
    else
    {
      RINOK(CopyFile_Ask(state, srcPath, fi, destPath2));
    }
  }
  return S_OK;
}

STDMETHODIMP CFSFolder::CopyFrom(Int32 /* moveMode */, const wchar_t * /* fromFolderPath */,
    const wchar_t * const * /* itemsPaths */, UInt32 /* numItems */, IProgress * /* progress */)
{
  /*
  UInt64 numFolders, numFiles, totalSize;
  numFiles = numFolders = totalSize = 0;
  UInt32 i;
  for (i = 0; i < numItems; i++)
  {
    UString path = (UString)fromFolderPath + itemsPaths[i];

    CFileInfo fi;
    if (!FindFile(path, fi))
      return ::GetLastError();
    if (fi.IsDir())
    {
      UInt64 subFolders, subFiles, subSize;
      RINOK(GetFolderSize(CombinePath(path, fi.Name), subFolders, subFiles, subSize, progress));
      numFolders += subFolders;
      numFolders++;
      numFiles += subFiles;
      totalSize += subSize;
    }
    else
    {
      numFiles++;
      totalSize += fi.Size;
    }
  }
  RINOK(progress->SetTotal(totalSize));
  RINOK(callback->SetNumFiles(numFiles));
  for (i = 0; i < numItems; i++)
  {
    UString path = (UString)fromFolderPath + itemsPaths[i];
  }
  return S_OK;
  */
  return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::CopyFromFile(UInt32 /* index */, const wchar_t * /* fullFilePath */, IProgress * /* progress */)
{
  return E_NOTIMPL;
}

}
// FileFolderPluginOpen.cpp

#include "StdAfx.h"

#include "resource.h"

#include "../../../Windows/FileName.h"
#include "../../../Windows/Thread.h"

#include "../Agent/Agent.h"

#include "LangUtils.h"
#include "OpenCallback.h"
#include "PluginLoader.h"
#include "RegistryPlugins.h"

using namespace NWindows;

struct CThreadArchiveOpen
{
  UString Path;
  UString ArcFormat;
  CMyComPtr<IInStream> InStream;
  CMyComPtr<IFolderManager> FolderManager;
  CMyComPtr<IProgress> OpenCallback;
  COpenArchiveCallback *OpenCallbackSpec;

  CMyComPtr<IFolderFolder> Folder;
  HRESULT Result;

  void Process()
  {
    try
    {
      CProgressCloser closer(OpenCallbackSpec->ProgressDialog);
      Result = FolderManager->OpenFolderFile(InStream, Path, ArcFormat, &Folder, OpenCallback);
    }
    catch(...) { Result = E_FAIL; }
  }
  
  static THREAD_FUNC_DECL MyThreadFunction(void *param)
  {
    ((CThreadArchiveOpen *)param)->Process();
    return 0;
  }
};

/*
static int FindPlugin(const CObjectVector<CPluginInfo> &plugins, const UString &pluginName)
{
  for (int i = 0; i < plugins.Size(); i++)
    if (plugins[i].Name.CompareNoCase(pluginName) == 0)
      return i;
  return -1;
}
*/

static const FChar kExtensionDelimiter = FTEXT('.');

static void SplitNameToPureNameAndExtension(const FString &fullName,
    FString &pureName, FString &extensionDelimiter, FString &extension)
{
  int index = fullName.ReverseFind_Dot();
  if (index < 0)
  {
    pureName = fullName;
    extensionDelimiter.Empty();
    extension.Empty();
  }
  else
  {
    pureName.SetFrom(fullName, index);
    extensionDelimiter = FTEXT('.');
    extension = fullName.Ptr(index + 1);
  }
}

HRESULT OpenFileFolderPlugin(
    IInStream *inStream,
    const FString &path,
    const UString &arcFormat,
    HMODULE *module,
    IFolderFolder **resultFolder,
    HWND parentWindow,
    bool &encrypted, UString &password)
{
#ifdef _WIN32
  CObjectVector<CPluginInfo> plugins;
  ReadFileFolderPluginInfoList(plugins);
#endif

  FString extension, name, pureName, dot;

  int slashPos = path.ReverseFind_PathSepar();
  FString dirPrefix;
  FString fileName;
  if (slashPos >= 0)
  {
    dirPrefix.SetFrom(path, slashPos + 1);
    fileName = path.Ptr(slashPos + 1);
  }
  else
    fileName = path;

  SplitNameToPureNameAndExtension(fileName, pureName, dot, extension);

  /*
  if (!extension.IsEmpty())
  {
    CExtInfo extInfo;
    if (ReadInternalAssociation(extension, extInfo))
    {
      for (int i = extInfo.Plugins.Size() - 1; i >= 0; i--)
      {
        int pluginIndex = FindPlugin(plugins, extInfo.Plugins[i]);
        if (pluginIndex >= 0)
        {
          const CPluginInfo plugin = plugins[pluginIndex];
          plugins.Delete(pluginIndex);
          plugins.Insert(0, plugin);
        }
      }
    }
  }
  */

#ifdef _WIN32
  FOR_VECTOR (i, plugins)
  {
    const CPluginInfo &plugin = plugins[i];
    if (!plugin.ClassIDDefined)
      continue;
#endif
    CPluginLibrary library;

    CThreadArchiveOpen t;

#ifdef _WIN32
    if (plugin.FilePath.IsEmpty())
      t.FolderManager = new CArchiveFolderManager;
    else if (library.LoadAndCreateManager(plugin.FilePath, plugin.ClassID, &t.FolderManager) != S_OK)
      continue;
#else
      t.FolderManager = new CArchiveFolderManager;
#endif

    t.OpenCallbackSpec = new COpenArchiveCallback;
    t.OpenCallback = t.OpenCallbackSpec;
    t.OpenCallbackSpec->PasswordIsDefined = encrypted;
    t.OpenCallbackSpec->Password = password;
    t.OpenCallbackSpec->ParentWindow = parentWindow;

    if (inStream)
      t.OpenCallbackSpec->SetSubArchiveName(fs2us(fileName));
    else
      t.OpenCallbackSpec->LoadFileInfo(dirPrefix, fileName);

    t.InStream = inStream;
    t.Path = fs2us(path);
    t.ArcFormat = arcFormat;

    UString progressTitle = LangString(IDS_OPENNING);
    t.OpenCallbackSpec->ProgressDialog.MainWindow = parentWindow;
    t.OpenCallbackSpec->ProgressDialog.MainTitle = L"7-Zip"; // LangString(IDS_APP_TITLE);
    t.OpenCallbackSpec->ProgressDialog.MainAddTitle = progressTitle + L' ';
    // FIXME t.OpenCallbackSpec->ProgressDialog.WaitMode = true;

    {
      NWindows::CThread thread;
      RINOK(thread.Create(CThreadArchiveOpen::MyThreadFunction, &t));
      t.OpenCallbackSpec->StartProgressDialog(progressTitle, thread);
    }

    if (t.Result == E_ABORT)
      return t.Result;

    encrypted = t.OpenCallbackSpec->PasswordIsDefined;
    if (t.Result == S_OK)
    {
      // if (openCallbackSpec->PasswordWasAsked)
      {
        password = t.OpenCallbackSpec->Password;
      }
      *module = library.Detach();
      *resultFolder = t.Folder.Detach();
      return S_OK;
    }
    
    if (t.Result != S_FALSE)
      return t.Result;
#ifdef _WIN32
  }
#endif
  return S_FALSE;
}
// FileFolderPluginOpen.h

#ifndef __FILE_FOLDER_PLUGIN_OPEN_H
#define __FILE_FOLDER_PLUGIN_OPEN_H

HRESULT OpenFileFolderPlugin(IInStream *inStream, const FString &path, const UString &arcFormat,
    HMODULE *module, IFolderFolder **resultFolder, HWND parentWindow, bool &encrypted, UString &password);

#endif
// FormatUtils.cpp

#include "StdAfx.h"

#include "../../../Common/IntToString.h"

#include "FormatUtils.h"

#include "LangUtils.h"

UString NumberToString(UInt64 number)
{
  wchar_t numberString[32];
  ConvertUInt64ToString(number, numberString);
  return numberString;
}

UString MyFormatNew(const UString &format, const UString &argument)
{
  UString result = format;
  result.Replace(L"{0}", argument);
  return result;
}

UString MyFormatNew(UINT resourceID, const UString &argument)
{
  return MyFormatNew(LangString(resourceID), argument);
}
// FormatUtils.h

#ifndef __FORMAT_UTILS_H
#define __FORMAT_UTILS_H

#include "../../../Common/MyTypes.h"
#include "../../../Common/MyString.h"

UString NumberToString(UInt64 number);

UString MyFormatNew(const UString &format, const UString &argument);
UString MyFormatNew(UINT resourceID, const UString &argument);

#endif
// HelpUtils.h

#ifndef __HELP_UTILS_H
#define __HELP_UTILS_H

#include "../../../Common/MyString.h"

void ShowHelpWindow(HWND hwnd, LPCWSTR topicFile);

#endif
// IFolder.h

#ifndef __IFOLDER_H
#define __IFOLDER_H

#include "../../IProgress.h"
#include "../../IStream.h"

#define FOLDER_INTERFACE_SUB(i, b, x) DECL_INTERFACE_SUB(i, b, 8, x)
#define FOLDER_INTERFACE(i, x) FOLDER_INTERFACE_SUB(i, IUnknown, x)

namespace NPlugin
{
  enum
  {
    kName = 0,
    kType,
    kClassID,
    kOptionsClassID
  };
}

#define INTERFACE_FolderFolder(x) \
  STDMETHOD(LoadItems)() x; \
  STDMETHOD(GetNumberOfItems)(UInt32 *numItems) x; \
  STDMETHOD(GetProperty)(UInt32 itemIndex, PROPID propID, PROPVARIANT *value) x; \
  STDMETHOD(BindToFolder)(UInt32 index, IFolderFolder **resultFolder) x; \
  STDMETHOD(BindToFolder)(const wchar_t *name, IFolderFolder **resultFolder) x; \
  STDMETHOD(BindToParentFolder)(IFolderFolder **resultFolder) x; \
  STDMETHOD(GetNumberOfProperties)(UInt32 *numProperties) x; \
  STDMETHOD(GetPropertyInfo)(UInt32 index, BSTR *name, PROPID *propID, VARTYPE *varType) x; \
  STDMETHOD(GetFolderProperty)(PROPID propID, PROPVARIANT *value) x; \

FOLDER_INTERFACE(IFolderFolder, 0x00)
{
  INTERFACE_FolderFolder(PURE)
};

/*
  IFolderAltStreams::
    BindToAltStreams((UInt32)(Int32)-1, ... ) means alt streams of that folder
*/

#define INTERFACE_FolderAltStreams(x) \
  STDMETHOD(BindToAltStreams)(UInt32 index, IFolderFolder **resultFolder) x; \
  STDMETHOD(BindToAltStreams)(const wchar_t *name, IFolderFolder **resultFolder) x; \
  STDMETHOD(AreAltStreamsSupported)(UInt32 index, Int32 *isSupported) x; \

FOLDER_INTERFACE(IFolderAltStreams, 0x17)
{
  INTERFACE_FolderAltStreams(PURE)
};

FOLDER_INTERFACE(IFolderWasChanged, 0x04)
{
  STDMETHOD(WasChanged)(Int32 *wasChanged) PURE;
};

FOLDER_INTERFACE_SUB(IFolderOperationsExtractCallback, IProgress, 0x0B)
{
  // STDMETHOD(SetTotalFiles)(UInt64 total) PURE;
  // STDMETHOD(SetCompletedFiles)(const UInt64 *completedValue) PURE;
  STDMETHOD(AskWrite)(
      const wchar_t *srcPath,
      Int32 srcIsFolder,
      const FILETIME *srcTime,
      const UInt64 *srcSize,
      const wchar_t *destPathRequest,
      BSTR *destPathResult,
      Int32 *writeAnswer) PURE;
  STDMETHOD(ShowMessage)(const wchar_t *message) PURE;
  STDMETHOD(SetCurrentFilePath)(const wchar_t *filePath) PURE;
  STDMETHOD(SetNumFiles)(UInt64 numFiles) PURE;
};

#define INTERFACE_FolderOperations(x) \
  STDMETHOD(CreateFolder)(const wchar_t *name, IProgress *progress) x; \
  STDMETHOD(CreateFile)(const wchar_t *name, IProgress *progress) x; \
  STDMETHOD(Rename)(UInt32 index, const wchar_t *newName, IProgress *progress) x; \
  STDMETHOD(Delete)(const UInt32 *indices, UInt32 numItems, IProgress *progress) x; \
  STDMETHOD(CopyTo)(Int32 moveMode, const UInt32 *indices, UInt32 numItems, \
      Int32 includeAltStreams, Int32 replaceAltStreamCharsMode, \
      const wchar_t *path, IFolderOperationsExtractCallback *callback) x; \
  STDMETHOD(CopyFrom)(Int32 moveMode, const wchar_t *fromFolderPath, \
      const wchar_t * const *itemsPaths, UInt32 numItems, IProgress *progress) x; \
  STDMETHOD(SetProperty)(UInt32 index, PROPID propID, const PROPVARIANT *value, IProgress *progress) x; \
  STDMETHOD(CopyFromFile)(UInt32 index, const wchar_t *fullFilePath, IProgress *progress) x; \

FOLDER_INTERFACE(IFolderOperations, 0x13)
{
  INTERFACE_FolderOperations(PURE)
};

/*
FOLDER_INTERFACE2(IFolderOperationsDeleteToRecycleBin, 0x06, 0x03)
{
  STDMETHOD(DeleteToRecycleBin)(const UInt32 *indices, UInt32 numItems, IProgress *progress) PURE;
};
*/

FOLDER_INTERFACE(IFolderGetSystemIconIndex, 0x07)
{
  STDMETHOD(GetSystemIconIndex)(UInt32 index, Int32 *iconIndex) PURE;
};

FOLDER_INTERFACE(IFolderGetItemFullSize, 0x08)
{
  STDMETHOD(GetItemFullSize)(UInt32 index, PROPVARIANT *value, IProgress *progress) PURE;
};

FOLDER_INTERFACE(IFolderCalcItemFullSize, 0x14)
{
  STDMETHOD(CalcItemFullSize)(UInt32 index, IProgress *progress) PURE;
};

FOLDER_INTERFACE(IFolderClone, 0x09)
{
  STDMETHOD(Clone)(IFolderFolder **resultFolder) PURE;
};

FOLDER_INTERFACE(IFolderSetFlatMode, 0x0A)
{
  STDMETHOD(SetFlatMode)(Int32 flatMode) PURE;
};

/*
FOLDER_INTERFACE(IFolderSetShowNtfsStreamsMode, 0xFA)
{
  STDMETHOD(SetShowNtfsStreamsMode)(Int32 showStreamsMode) PURE;
};
*/

#define INTERFACE_FolderProperties(x) \
  STDMETHOD(GetNumberOfFolderProperties)(UInt32 *numProperties) x; \
  STDMETHOD(GetFolderPropertyInfo)(UInt32 index, BSTR *name, PROPID *propID, VARTYPE *varType) x; \

FOLDER_INTERFACE(IFolderProperties, 0x0E)
{
  INTERFACE_FolderProperties(PURE)
};

#define INTERFACE_IFolderArcProps(x) \
  STDMETHOD(GetArcNumLevels)(UInt32 *numLevels) x; \
  STDMETHOD(GetArcProp)(UInt32 level, PROPID propID, PROPVARIANT *value) x; \
  STDMETHOD(GetArcNumProps)(UInt32 level, UInt32 *numProps) x; \
  STDMETHOD(GetArcPropInfo)(UInt32 level, UInt32 index, BSTR *name, PROPID *propID, VARTYPE *varType) x; \
  STDMETHOD(GetArcProp2)(UInt32 level, PROPID propID, PROPVARIANT *value) x; \
  STDMETHOD(GetArcNumProps2)(UInt32 level, UInt32 *numProps) x; \
  STDMETHOD(GetArcPropInfo2)(UInt32 level, UInt32 index, BSTR *name, PROPID *propID, VARTYPE *varType) x; \

FOLDER_INTERFACE(IFolderArcProps, 0x10)
{
  INTERFACE_IFolderArcProps(PURE)
};

FOLDER_INTERFACE(IGetFolderArcProps, 0x11)
{
  STDMETHOD(GetFolderArcProps)(IFolderArcProps **object) PURE;
};

FOLDER_INTERFACE(IFolderCompare, 0x15)
{
  STDMETHOD_(Int32, CompareItems)(UInt32 index1, UInt32 index2, PROPID propID, Int32 propIsRaw) PURE;
};

#define INTERFACE_IFolderGetItemName(x) \
  STDMETHOD(GetItemName)(UInt32 index, const wchar_t **name, unsigned *len) x; \
  STDMETHOD(GetItemPrefix)(UInt32 index, const wchar_t **name, unsigned *len) x; \
  STDMETHOD_(UInt64, GetItemSize)(UInt32 index) x; \

FOLDER_INTERFACE(IFolderGetItemName, 0x16)
{
  INTERFACE_IFolderGetItemName(PURE)
};

#define FOLDER_MANAGER_INTERFACE(i, x)  DECL_INTERFACE(i, 9, x)

#define INTERFACE_IFolderManager(x) \
  STDMETHOD(OpenFolderFile)(IInStream *inStream, const wchar_t *filePath, const wchar_t *arcFormat, IFolderFolder **resultFolder, IProgress *progress) x; \
  STDMETHOD(GetExtensions)(BSTR *extensions) x; \
  STDMETHOD(GetIconPath)(const wchar_t *ext, BSTR *iconPath, Int32 *iconIndex) x; \
  
  // STDMETHOD(GetTypes)(BSTR *types) PURE;
  // STDMETHOD(CreateFolderFile)(const wchar_t *type, const wchar_t *filePath, IProgress *progress) PURE;
            
FOLDER_MANAGER_INTERFACE(IFolderManager, 0x05)
{
  INTERFACE_IFolderManager(PURE);
};

/*
#define IMP_IFolderFolder_GetProp(k) \
  (UInt32 index, BSTR *name, PROPID *propID, VARTYPE *varType) \
    { if (index >= ARRAY_SIZE(k)) return E_INVALIDARG; \
    const CMy_STATPROPSTG_2 &srcItem = k[index]; \
    *propID = srcItem.propid; *varType = srcItem.vt; *name = 0; return S_OK; } \

#define IMP_IFolderFolder_Props(c) \
  STDMETHODIMP c::GetNumberOfProperties(UInt32 *numProperties) \
    { *numProperties = ARRAY_SIZE(kProps); return S_OK; } \
  STDMETHODIMP c::GetPropertyInfo IMP_IFolderFolder_GetProp(kProps)
*/

#define IMP_IFolderFolder_GetProp(k) \
  (UInt32 index, BSTR *name, PROPID *propID, VARTYPE *varType) \
    { if (index >= ARRAY_SIZE(k)) return E_INVALIDARG; \
    *propID = k[index]; *varType = k7z_PROPID_To_VARTYPE[(unsigned)*propID]; *name = 0; return S_OK; } \

#define IMP_IFolderFolder_Props(c) \
  STDMETHODIMP c::GetNumberOfProperties(UInt32 *numProperties) \
    { *numProperties = ARRAY_SIZE(kProps); return S_OK; } \
  STDMETHODIMP c::GetPropertyInfo IMP_IFolderFolder_GetProp(kProps)


int CompareFileNames_ForFolderList(const wchar_t *s1, const wchar_t *s2);
// int CompareFileNames_ForFolderList(const FChar *s1, const FChar *s2);

#endif
// LangUtils.cpp

#include "StdAfx.h"

#include "../../../Common/Lang.h"

#include "../../../Windows/DLL.h"
#include "../../../Windows/Synchronization.h"
#include "../../../Windows/Window.h"

#include "LangUtils.h"
#include "RegistryUtils.h"

using namespace NWindows;

#ifndef _UNICODE
extern bool g_IsNT;
#endif

UString g_LangID;

static CLang g_Lang;
static bool g_Loaded = false;
static NSynchronization::CCriticalSection g_CriticalSection;

bool LangOpen(CLang &lang, CFSTR fileName)
{
  return lang.Open(fileName, L"7-Zip");
}

FString GetLangDirPrefix()
{
  return NDLL::GetModuleDirPrefix() + FTEXT("Lang") FSTRING_PATH_SEPARATOR;
}

void LoadLangOneTime()
{
  NSynchronization::CCriticalSectionLock lock(g_CriticalSection);
  if (g_Loaded)
    return;
  g_Loaded = true;
  ReloadLang();
}

void LangSetDlgItemText(HWND dialog, UInt32 controlID, UInt32 langID)
{
  const wchar_t *s = g_Lang.Get(langID);
  if (s)
  {
    CWindow window(GetDlgItem(dialog, controlID));
    window.SetText(s);
  }
}

static const CIDLangPair kLangPairs[] =
{
  { IDOK,     401 },
  { IDCANCEL, 402 },
  { IDYES,    406 },
  { IDNO,     407 },
  { IDHELP,   409 }
};


void LangSetDlgItems(HWND dialog, const UInt32 *ids, unsigned numItems)
{
  unsigned i;
  for (i = 0; i < ARRAY_SIZE(kLangPairs); i++)
  {
    const CIDLangPair &pair = kLangPairs[i];
    CWindow window(GetDlgItem(dialog, pair.ControlID));
    if (window)
    {
      const wchar_t *s = g_Lang.Get(pair.LangID);
      if (s)
        window.SetText(s);
    }
  }

  for (i = 0; i < numItems; i++)
  {
    UInt32 id = ids[i];
    LangSetDlgItemText(dialog, id, id);
  }
}

void LangSetDlgItems_Colon(HWND dialog, const UInt32 *ids, unsigned numItems)
{
  for (unsigned i = 0; i < numItems; i++)
  {
    UInt32 id = ids[i];
    const wchar_t *s = g_Lang.Get(id);
    if (s)
    {
      CWindow window(GetDlgItem(dialog, id));
      UString s2 = s;
      s2 += L':';
      window.SetText(s2);
    }
  }
}

void LangSetWindowText(HWND window, UInt32 langID)
{
  const wchar_t *s = g_Lang.Get(langID);
  if (s)
    MySetWindowText(window, s);
}

UString LangString(UInt32 langID)
{
  const wchar_t *s = g_Lang.Get(langID);
  if (s)
    return s;
  return MyLoadString(langID);
}

void AddLangString(UString &s, UInt32 langID)
{
  s += LangString(langID);
}

void LangString(UInt32 langID, UString &dest)
{
  const wchar_t *s = g_Lang.Get(langID);
  if (s)
  {
    dest = s;
    return;
  }
  MyLoadString(langID, dest);
}

void LangString_OnlyFromLangFile(UInt32 langID, UString &dest)
{
  dest.Empty();
  const wchar_t *s = g_Lang.Get(langID);
  if (s)
    dest = s;
}

static const char *kLangs =
  "ar.bg.ca.zh.-tw.-cn.cs.da.de.el.en.es.fi.fr.he.hu.is."
  "it.ja.ko.nl.no.=nb.=nn.pl.pt.-br.rm.ro.ru.sr.=hr.-spl.-spc.sk.sq.sv.th.tr."
  "ur.id.uk.be.sl.et.lv.lt.tg.fa.vi.hy.az.eu.hsb.mk."
  "st.ts.tn.ve.xh.zu.af.ka.fo.hi.mt.se.ga.yi.ms.kk."
  "ky.sw.tk.uz.tt.bn.pa.-in.gu.or.ta.te.kn.ml.as.mr.sa."
  "mn.=mn.=mng.bo.cy.kh.lo.my.gl.kok..sd.syr.si..iu.am.tzm."
  "ks.ne.fy.ps.tl.dv..ff.ha..yo.qu.st.ba.lb.kl."
  "ig.kr.om.ti.gn..la.so.ii..arn..moh..br.."
  "ug.mi.oc.co."
  // "gsw.sah.qut.rw.wo....prs...."
  // ".gd."
  ;

static void FindShortNames(UInt32 primeLang, UStringVector &names)
{
  UInt32 index = 0;
  for (const char *p = kLangs; *p != 0;)
  {
    const char *p2 = p;
    for (; *p2 != '.'; p2++);
    bool isSub = (p[0] == '-' || p[0] == '=');
    if (!isSub)
      index++;
    if (index >= primeLang)
    {
      if (index > primeLang)
        break;
      UString s;
      if (isSub)
      {
        if (p[0] == '-')
          s = names[0];
        else
          p++;
      }
      while (p != p2)
        s += (wchar_t)(Byte)*p++;
      names.Add(s);
    }
    p = p2 + 1;
  }
}

/*
#include "../../../Common/IntToString.h"

static struct CC1Lang
{
  CC1Lang()
  {
    for (int i = 1; i < 150; i++)
    {
      UString s;
      char ttt[32];
      ConvertUInt32ToHex(i, ttt);
      s.AddAscii(ttt);
      UStringVector names;
      FindShortNames(i, names);

      FOR_VECTOR (k, names)
      {
        s.Add_Space();
        s += names[k];
      }
      OutputDebugStringW(s);
    }
  }
} g_cc1;
*/

// typedef LANGID (WINAPI *GetUserDefaultUILanguageP)();

static void OpenDefaultLang()
{
  LANGID sysLang = GetSystemDefaultLangID(); // "Language for non-Unicode programs" in XP64
  LANGID userLang = GetUserDefaultLangID(); // "Standards and formats" language in XP64

  if (sysLang != userLang)
    return;
  LANGID langID = userLang;
  
  /*
  LANGID sysUILang; // english  in XP64
  LANGID userUILang; // english  in XP64

  GetUserDefaultUILanguageP fn = (GetUserDefaultUILanguageP)GetProcAddress(
      GetModuleHandle("kernel32"), "GetUserDefaultUILanguage");
  if (fn)
    userUILang = fn();
  fn = (GetUserDefaultUILanguageP)GetProcAddress(
      GetModuleHandle("kernel32"), "GetSystemDefaultUILanguage");
  if (fn)
    sysUILang = fn();
  */

  WORD primLang = (WORD)(PRIMARYLANGID(langID));
  WORD subLang = (WORD)(SUBLANGID(langID));
  {
    UStringVector names;
    FindShortNames(primLang, names);
    const FString dirPrefix = GetLangDirPrefix();
    for (unsigned i = 0; i < 2; i++)
    {
      unsigned index = (i == 0 ? subLang : 0);
      if (index < names.Size())
      {
        const UString &name = names[index];
        if (!name.IsEmpty())
        {
          if (LangOpen(g_Lang, dirPrefix + us2fs(name) + FTEXT(".txt")))
          {
            g_LangID = name;
            return;
          }
        }
      }
    }
  }
}

void ReloadLang()
{
  g_Lang.Clear();
  ReadRegLang(g_LangID);
  #ifndef _UNICODE
  if (g_IsNT)
  #endif
  {
    if (g_LangID.IsEmpty())
    {
      OpenDefaultLang();
      return;
    }
  }
  if (g_LangID.Len() > 1 || g_LangID[0] != L'-')
  {
    FString s = us2fs(g_LangID);
    if (s.Find(FCHAR_PATH_SEPARATOR) < 0)
    {
      if (s.Find(FTEXT('.')) < 0)
        s += FTEXT(".txt");
      s.Insert(0, GetLangDirPrefix());
    }
    LangOpen(g_Lang, s);
  }
}
// LangUtils.h

#ifndef __LANG_UTILS_H
#define __LANG_UTILS_H

#include "../../../Windows/ResourceString.h"

#ifdef LANG

extern UString g_LangID;

struct CIDLangPair
{
  UInt32 ControlID;
  UInt32 LangID;
};

void ReloadLang();
void LoadLangOneTime();
FString GetLangDirPrefix();

void LangSetDlgItemText(HWND dialog, UInt32 controlID, UInt32 langID);
void LangSetDlgItems(HWND dialog, const UInt32 *ids, unsigned numItems);
void LangSetDlgItems_Colon(HWND dialog, const UInt32 *ids, unsigned numItems);
void LangSetWindowText(HWND window, UInt32 langID);

UString LangString(UInt32 langID);
void AddLangString(UString &s, UInt32 langID);
void LangString(UInt32 langID, UString &dest);
void LangString_OnlyFromLangFile(UInt32 langID, UString &dest);
 
#else

inline UString LangString(UInt32 langID) { return NWindows::MyLoadString(langID); }
inline void LangString(UInt32 langID, UString &dest) { NWindows::MyLoadString(langID, dest); }
inline void AddLangString(UString &s, UInt32 langID) { s += NWindows::MyLoadString(langID); }

#endif

#endif
// ListViewDialog.cpp

#include "StdAfx.h"

#include "ListViewDialog.h"
#include "RegistryUtils.h"

#ifdef LANG
#include "LangUtils.h"
#endif

using namespace NWindows;

bool CListViewDialog::OnInit()
{
  #ifdef LANG
  LangSetDlgItems(*this, NULL, 0);
  #endif
  _listView.Attach(GetItem(IDL_LISTVIEW));

  // FIXME if (ReadSingleClick())
    // FIXME _listView.SetExtendedListViewStyle(LVS_EX_ONECLICKACTIVATE | LVS_EX_TRACKSELECT);

  SetText(Title);

  LVCOLUMN columnInfo;
  columnInfo.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
  columnInfo.fmt = LVCFMT_LEFT;
  columnInfo.iSubItem = 0;
  columnInfo.cx = 200;

  _listView.InsertColumn(0, &columnInfo);

  FOR_VECTOR (i, Strings)
    _listView.InsertItem(i, Strings[i]);

  if (Strings.Size() > 0)
    _listView.SetItemState_FocusedSelected(0);

  _listView.SetColumnWidthAuto(0);
  StringsWereChanged = false;

  NormalizeSize();
  return CModalDialog::OnInit();
}

bool CListViewDialog::OnSize(WPARAM /* wParam */, int xSize, int ySize)
{
#ifdef _WIN32
  int mx, my;
  GetMargins(8, mx, my);
  int bx1, bx2, by;
  GetItemSizes(IDCANCEL, bx1, by);
  GetItemSizes(IDOK, bx2, by);
  int y = ySize - my - by;
  int x = xSize - mx - bx1;

  /*
  RECT rect;
  GetClientRect(&rect);
  rect.top = y - my;
  InvalidateRect(&rect);
  */
  InvalidateRect(NULL);

  MoveItem(IDCANCEL, x, y, bx1, by);
  MoveItem(IDOK, x - mx - bx2, y, bx2, by);
  /*
  if (wParam == SIZE_MAXSHOW || wParam == SIZE_MAXIMIZED || wParam == SIZE_MAXHIDE)
    mx = 0;
  */
  _listView.Move(mx, my, xSize - mx * 2, y - my * 2);
#endif
  return false;
}

extern bool g_LVN_ITEMACTIVATE_Support;

bool CListViewDialog::OnNotify(UINT /* controlID */, LPNMHDR header)
{
#ifdef _WIN32
  if (header->hwndFrom != _listView)
    return false;
  switch (header->code)
  {
    case LVN_ITEMACTIVATE:
      if (g_LVN_ITEMACTIVATE_Support)
      {
        OnOK();
        return true;
      }
      break;
    case NM_DBLCLK:
    case NM_RETURN: // probabably it's unused
      if (!g_LVN_ITEMACTIVATE_Support)
      {
        OnOK();
        return true;
      }
      break;

    case LVN_KEYDOWN:
    {
      LPNMLVKEYDOWN keyDownInfo = LPNMLVKEYDOWN(header);
      switch (keyDownInfo->wVKey)
      {
        case VK_DELETE:
        {
          if (!DeleteIsAllowed)
            return false;
          for (;;)
          {
            int index = _listView.GetNextSelectedItem(-1);
            if (index < 0)
              break;
            StringsWereChanged = true;
            _listView.DeleteItem(index);
            Strings.Delete(index);
          }
          int focusedIndex = _listView.GetFocusedItem();
          if (focusedIndex >= 0)
            _listView.SetItemState_FocusedSelected(focusedIndex);
          _listView.SetColumnWidthAuto(0);
          return true;
        }
        case 'A':
        {
          if (IsKeyDown(VK_CONTROL))
          {
            _listView.SelectAll();
            return true;
          }
        }
      }
    }
  }
#endif
  return false;
}

void CListViewDialog::OnOK()
{
  FocusedItemIndex = _listView.GetFocusedItem();
  CModalDialog::OnOK();
}
// ListViewDialog.h

#ifndef __LISTVIEW_DIALOG_H
#define __LISTVIEW_DIALOG_H

#include "../../../Windows/Control/Dialog.h"
#include "../../../Windows/Control/ListView.h"

#include "ListViewDialogRes.h"

class CListViewDialog: public NWindows::NControl::CModalDialog
{
  NWindows::NControl::CListView _listView;
  virtual void OnOK();
  virtual bool OnInit();
  virtual bool OnSize(WPARAM wParam, int xSize, int ySize);
  virtual bool OnNotify(UINT controlID, LPNMHDR header);
public:
  UString Title;
  bool DeleteIsAllowed;
  bool StringsWereChanged;
  UStringVector Strings;
  int FocusedItemIndex;

  INT_PTR Create(HWND wndParent = 0) { return CModalDialog::Create(IDD_LISTVIEW, wndParent); }

  CListViewDialog(): DeleteIsAllowed(false) {}
};

#endif
#define IDD_LISTVIEW  99
#define IDL_LISTVIEW 100
// PasswordDialog.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif  

#include <wx/listctrl.h>

#undef _WIN32

#include "Windows/Control/DialogImpl.h"

#include "ListViewDialogRes.h"

class CListViewDialogImpl : public NWindows::NControl::CModalDialogImpl
{
  public:
   CListViewDialogImpl(NWindows::NControl::CModalDialog *dialog,wxWindow * parent,int id) :
	CModalDialogImpl(dialog,parent, id, wxT("ListView"), wxDefaultPosition, wxDefaultSize,
			   wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER | wxMAXIMIZE_BOX | wxMINIMIZE_BOX)

  {
	wxBoxSizer* topsizer = new wxBoxSizer(wxVERTICAL);

	wxListCtrl *list = new wxListCtrl(this, IDL_LISTVIEW, wxDefaultPosition, wxSize(645,195), wxLC_REPORT | wxLC_NO_HEADER);

	topsizer->Add(list, 1, wxALL|wxEXPAND, 5);

	topsizer->Add(CreateButtonSizer(wxOK|wxCANCEL), 0, wxALL|wxEXPAND, 5);

	this->OnInit();

	SetSizer(topsizer); // use the sizer for layout
	topsizer->SetSizeHints(this); // set size hints to honour minimum size
  }
private:
	// Any class wishing to process wxWindows events must use this macro
	DECLARE_EVENT_TABLE()
};

REGISTER_DIALOG(IDD_LISTVIEW,CListViewDialog,0)

BEGIN_EVENT_TABLE(CListViewDialogImpl, wxDialog)
	EVT_BUTTON(wxID_ANY,   CModalDialogImpl::OnAnyButton)
	EVT_CHECKBOX(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_MENU(WORKER_EVENT, CModalDialogImpl::OnWorkerEvent)
END_EVENT_TABLE()

// MessagesDialog.cpp
 
#include "StdAfx.h"

#include "../../../Common/IntToString.h"

#include "../../../Windows/ResourceString.h"

#include "MessagesDialog.h"

#include "LangUtils.h"

#include "ProgressDialog2Res.h"

using namespace NWindows;

void CMessagesDialog::AddMessageDirect(LPCWSTR message)
{
  int i = _messageList.GetItemCount();
  wchar_t sz[16];
  ConvertUInt32ToString((UInt32)i, sz);
  _messageList.InsertItem(i, sz);
  _messageList.SetSubItem(i, 1, message);
}

void CMessagesDialog::AddMessage(LPCWSTR message)
{
  UString s = message;
  while (!s.IsEmpty())
  {
    int pos = s.Find(L'\n');
    if (pos < 0)
      break;
    AddMessageDirect(s.Left(pos));
    s.DeleteFrontal(pos + 1);
  }
  AddMessageDirect(s);
}

bool CMessagesDialog::OnInit()
{
  #ifdef LANG
  LangSetWindowText(*this, IDD_MESSAGES);
  LangSetDlgItems(*this, NULL, 0);
  SetItemText(IDOK, LangString(IDS_CLOSE));
  #endif
  _messageList.Attach(GetItem(IDL_MESSAGE));
  _messageList.SetUnicodeFormat();

  _messageList.InsertColumn(0, L"", 30);
  _messageList.InsertColumn(1, LangString(IDS_MESSAGE), 600);

  FOR_VECTOR (i, *Messages)
    AddMessage((*Messages)[i]);

  _messageList.SetColumnWidthAuto(0);
  _messageList.SetColumnWidthAuto(1);
  NormalizeSize();
  return CModalDialog::OnInit();
}

bool CMessagesDialog::OnSize(WPARAM /* wParam */, int xSize, int ySize)
{
#ifdef _WIN32
  int mx, my;
  GetMargins(8, mx, my);
  int bx, by;
  GetItemSizes(IDOK, bx, by);
  int y = ySize - my - by;
  int x = xSize - mx - bx;

  InvalidateRect(NULL);

  MoveItem(IDOK, x, y, bx, by);
  _messageList.Move(mx, my, xSize - mx * 2, y - my * 2);
#endif
  return false;
}
// MessagesDialog.h

#ifndef __MESSAGES_DIALOG_H
#define __MESSAGES_DIALOG_H

#include "../../../Windows/Control/Dialog.h"
#include "../../../Windows/Control/ListView.h"

#include "MessagesDialogRes.h"

class CMessagesDialog: public NWindows::NControl::CModalDialog
{
  NWindows::NControl::CListView _messageList;
  
  void AddMessageDirect(LPCWSTR message);
  void AddMessage(LPCWSTR message);
  virtual bool OnInit();
  virtual bool OnSize(WPARAM wParam, int xSize, int ySize);
public:
  const UStringVector *Messages;
  
  INT_PTR Create(HWND parent = 0) { return CModalDialog::Create(IDD_MESSAGES, parent); }
};

#endif
#define IDD_MESSAGES  6602
#define IDS_MESSAGE   6603
#define IDL_MESSAGE    100
// MessagesDialog_rc.cpp
 
#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#include <wx/listctrl.h>

#undef _WIN32

#include "Windows/Control/DialogImpl.h"
#include "MessagesDialogRes.h"

/*
IDD_MESSAGES DIALOG 0, 0, xSize, ySize  MY_MODAL_DIALOG_STYLE
CAPTION "7-Zip: Diagnostic messages"
MY_FONT
BEGIN
  DEFPUSHBUTTON "&Close", IDOK, bXPos, bYPos, bXSize, bYSize
  CONTROL "List1",IDL_MESSAGE,"SysListView32",
          LVS_REPORT | LVS_SHOWSELALWAYS | LVS_NOSORTHEADER | WS_BORDER | WS_TABSTOP, 
          marg, marg, xSize2, ySize2 - bYSize - 6
END

STRINGTABLE
BEGIN
  IDS_MESSAGES_DIALOG_MESSAGE_COLUMN "Message"
END
*/

class CMessagesDialogImpl : public NWindows::NControl::CModalDialogImpl
{
  public:
   CMessagesDialogImpl(NWindows::NControl::CModalDialog *dialog,wxWindow * parent , int id) :
	CModalDialogImpl(dialog,parent, id, wxT("7-Zip: Diagnostic messages"), wxDefaultPosition, wxDefaultSize,
			   wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER | wxMAXIMIZE_BOX | wxMINIMIZE_BOX)
  {
	wxBoxSizer* topsizer = new wxBoxSizer(wxVERTICAL);


	wxListCtrl *list = new wxListCtrl(this, IDL_MESSAGE, wxDefaultPosition, wxSize(645,195), wxLC_REPORT );

#if 0
	list->InsertColumn(0, wxT("Col1"), wxLIST_FORMAT_LEFT);
	list->InsertColumn(1, wxT("Col2"), wxLIST_FORMAT_RIGHT);
	list->InsertItem(0, wxT("#1"));
	list->SetItem(0, 1, L"message 1");
	list->InsertItem(1, wxT("#2"));
	list->SetItem(1, 1, L"message 2");
#endif
	topsizer->Add(list ,  1, wxALL|wxEXPAND, 5);


	topsizer->Add(new wxButton(this, wxID_OK, _T("&Close")) ,  0, wxALL | wxALIGN_RIGHT, 5);

	this->OnInit();

	SetSizer(topsizer); // use the sizer for layout
	topsizer->SetSizeHints(this); // set size hints to honour minimum size
  }
private:
	// Any class wishing to process wxWindows events must use this macro
	DECLARE_EVENT_TABLE()
};

REGISTER_DIALOG(IDD_MESSAGES,CMessagesDialog,0)

BEGIN_EVENT_TABLE(CMessagesDialogImpl, wxDialog)
	EVT_BUTTON(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_MENU(WORKER_EVENT, CModalDialogImpl::OnWorkerEvent)
END_EVENT_TABLE()

// MyLoadMenu

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

#undef _WIN32

#include <wx/aboutdlg.h>

#include "../../../../C/CpuArch.h"
#include "PropertyNameRes.h"

typedef wxMenuBar * HMENU;

#include "Common/StringConvert.h"

#include "Windows/Menu.h"
#include "Windows/ErrorMsg.h"
// FIXME #include "Windows/Clipboard.h"

#include "../../PropID.h"

#include "resource.h"
#include "App.h"
// FIXME #include "AboutDialog.h"
#include "../Common/CompressCall.h"

#include "HelpUtils.h"
#include "LangUtils.h"
#include "PluginInterface.h"

#include "../../MyVersion.h"

static const UINT kOpenBookmarkMenuID = 730;
static const UINT kSetBookmarkMenuID = 740;

extern HINSTANCE g_hInstance;

static LPCWSTR kFMHelpTopic = L"fm/index.htm";

extern void OptionsDialog(HWND hwndOwner, HINSTANCE hInstance);

using namespace NWindows;

enum
{
  kMenuIndex_File = 0,
  kMenuIndex_Edit,
  kMenuIndex_View,
  kMenuIndex_Bookmarks
};

struct CStringLangPair
{
  const wchar_t *String;
  UINT32 LangID;
};

static CStringLangPair kStringLangPairs[] = 
{
  { L"&File",  0x03000102 },
  { L"&Edit",  0x03000103 },
  { L"&View",  0x03000104 },
  { L"&Bookmarks", 0x03000107 },
  { L"&Tools", 0x03000105 },
  { L"&Help",  0x03000106 },
};

UINT32 kAddToFavoritesLangID = 0x03000710;
UINT32 kToolbarsLangID = 0x03000451;

static CIDLangPair kIDLangPairs[] = 
{
  // File
  { IDM_OPEN, 0x03000210 },
  { IDM_OPEN_INSIDE, 0x03000211 },
  { IDM_OPEN_OUTSIDE, 0x03000212 },
  // { IDM_FILE_VIEW, 0x03000220 }, // FIXME : does not exist !
  { IDM_FILE_EDIT, 0x03000221 },
  { IDM_RENAME, 0x03000230 },
  { IDM_COPY_TO, 0x03000231 },
  { IDM_MOVE_TO, 0x03000232 },
  { IDM_DELETE, 0x03000233 },
  { IDM_PROPERTIES, 0x03000240 },
  { IDM_COMMENT, 0x03000241 },
  { IDM_CRC32, 0x03000242 },
  { IDM_DIFF, 0x03000243 },
  { IDM_SPLIT, 0x03000270 },
  { IDM_COMBINE, 0x03000271 },
  { IDM_CREATE_FOLDER, 0x03000250 },
  { IDM_CREATE_FILE, 0x03000251 },
  // FIXME { IDCLOSE, 0x03000260 },

  // Edit
/* FIXME
  { IDM_EDIT_CUT, 0x03000320 },
  { IDM_EDIT_COPY, 0x03000321 },
  { IDM_EDIT_PASTE, 0x03000322 },
*/
  { IDM_SELECT_ALL, 0x03000330 },
  { IDM_DESELECT_ALL, 0x03000331 },
  { IDM_INVERT_SELECTION, 0x03000332 },
  { IDM_SELECT, 0x03000333 },
  { IDM_DESELECT, 0x03000334 },
  { IDM_SELECT_BY_TYPE, 0x03000335 },
  { IDM_DESELECT_BY_TYPE, 0x03000336 },

  { IDM_VIEW_LARGE_ICONS, 0x03000410 },
  { IDM_VIEW_SMALL_ICONS, 0x03000411 },
  { IDM_VIEW_LIST, 0x03000412 },
  { IDM_VIEW_DETAILS, 0x03000413 },

  { IDM_VIEW_ARANGE_BY_NAME, 0x02000204 },
  { IDM_VIEW_ARANGE_BY_TYPE, 0x02000214 },
  { IDM_VIEW_ARANGE_BY_DATE, 0x0200020C },
  { IDM_VIEW_ARANGE_BY_SIZE, 0x02000207 },
  { IDM_VIEW_ARANGE_NO_SORT, 0x03000420 },

  { IDM_OPEN_ROOT_FOLDER, 0x03000430 },
  { IDM_OPEN_PARENT_FOLDER, 0x03000431 },
  { IDM_FOLDERS_HISTORY, 0x03000432 },

  { IDM_VIEW_REFRESH, 0x03000440 },
  
  { IDM_VIEW_FLAT_VIEW, 0x03000449 },
  { IDM_VIEW_TWO_PANELS, 0x03000450 },
  { IDM_VIEW_ARCHIVE_TOOLBAR, 0x03000460 },
  { IDM_VIEW_STANDARD_TOOLBAR, 0x03000461 },
  { IDM_VIEW_TOOLBARS_LARGE_BUTTONS, 0x03000462 },
  { IDM_VIEW_TOOLBARS_SHOW_BUTTONS_TEXT, 0x03000463 },

  { IDM_OPTIONS, 0x03000510 },
  { IDM_BENCHMARK, 0x03000511 },
  
  { IDM_HELP_CONTENTS, 0x03000610 },
  { IDM_ABOUT, 0x03000620 },

  { 12111         , 0x03000710 }, // FIXME kAddToFavoritesLangID
  { 12112         , 0x03000451 } // FIXME kToolbarsLangID
};


#ifdef _WIN32
static int FindLangItem(int ControlID)
{
  for (int i = 0; i < sizeof(kIDLangPairs) / sizeof(kIDLangPairs[0]); i++)
    if (kIDLangPairs[i].ControlID == ControlID)
      return i;
  return -1;
}
#endif


/*
static bool g_IsNew_fMask = true;

class CInit_fMask
{
public:
  CInit_fMask()
  {
    g_IsNew_fMask = false;
    OSVERSIONINFO vi;
    vi.dwOSVersionInfoSize = sizeof(vi);
    if (::GetVersionEx(&vi)) 
    {
      g_IsNew_fMask = (vi.dwMajorVersion > 4 || 
        (vi.dwMajorVersion == 4 && vi.dwMinorVersion > 0));
    }
    g_IsNew_fMask = false;
  }
} g_Init_fMask;

// it's hack for supporting Windows NT
// constants are from WinUser.h

#if(WINVER < 0x0500)
#define MIIM_STRING      0x00000040
#define MIIM_BITMAP      0x00000080
#define MIIM_FTYPE       0x00000100
#endif

static UINT Get_fMaskForString()
{
  return g_IsNew_fMask ? MIIM_STRING : MIIM_TYPE;
}

static UINT Get_fMaskForFTypeAndString()
{
  return g_IsNew_fMask ? (MIIM_STRING | MIIM_FTYPE) : MIIM_TYPE;
}
*/

#ifdef _WIN32
static UINT Get_fMaskForString()
{
  return MIIM_TYPE;
}

static UINT Get_fMaskForFTypeAndString()
{
  return MIIM_TYPE;
}
#endif


static void MyChangeItem(wxMenuItem * mi,int LangID)
{
        UString newString = LangString(LangID);
        if (newString.IsEmpty())
          return;
	wxString ss = mi->GetItemLabel();
        UString shorcutString((const wchar_t *)ss); //  = item.StringValue;
        int tabPos = shorcutString.ReverseFind(wchar_t('\t'));
        if (tabPos >= 0)
          newString += shorcutString.Ptr(tabPos);
	// printf("Change Menu : %ls => %ls\n",(const wchar_t *)ss,(const wchar_t *)newString);
	mi->SetItemLabel((const wchar_t *)newString);

}

static void MyChangeMenu(HMENU menuLoc, int level, int menuIndex)
{
  // Sets the label of the top-level menus
  for (int i1= 0; i1< sizeof(kStringLangPairs) / sizeof(kStringLangPairs[0]); i1++)
  {
       	UString newString = LangString(kStringLangPairs[i1].LangID);
       	if (! newString.IsEmpty()) menuLoc->SetMenuLabel(i1, (const TCHAR *)newString);
  }

  // sub-menu items
  for (int i = 0; i < sizeof(kIDLangPairs) / sizeof(kIDLangPairs[0]); i++)
  {
	wxMenuItem * mi = menuLoc->FindItem(kIDLangPairs[i].ControlID);
	if (mi)
	{
		MyChangeItem(mi,kIDLangPairs[i].LangID);
	}
//	else
//	  printf("Change Menu : id=%d index=%d<>\n",kIDLangPairs[i].ControlID,i);
  }
}

#ifdef _WIN32
CMenu g_FileMenu;

class CFileMenuDestroyer
{
public:
  ~CFileMenuDestroyer()
  {
    if ((HMENU)g_FileMenu != 0)
      g_FileMenu.Destroy();
  }
} g_FileMenuDestroyer;
#endif


void MyLoadMenu(HWND hWnd)
{
#ifdef _WIN32
  if ((HMENU)g_FileMenu != 0)
    g_FileMenu.Destroy();
  HMENU oldMenu = ::GetMenu(hWnd);
  HMENU baseMenu = ::LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_MENU));
  ::SetMenu(hWnd, baseMenu);
  ::DestroyMenu(oldMenu);
  if (!g_LangID.IsEmpty())
  {
    HMENU menuOld = ::GetMenu(hWnd);
    MyChangeMenu(menuOld, 0, 0);
  }
  ::DrawMenuBar(hWnd);
#else
  extern void rc_MyLoadMenu(HWND hWnd);
  rc_MyLoadMenu(hWnd);
  if (!g_LangID.IsEmpty())
  {
    HMENU menuOld = ((wxFrame *)hWnd)->GetMenuBar(); // ::GetMenu(hWnd);
    MyChangeMenu(menuOld, 0, 0);
  }
#endif
}

extern HWND g_HWND;
void MyLoadMenu()
{
  MyLoadMenu(g_HWND);
}

#ifdef _WIN32
static void CopyMenu(HMENU srcMenuSpec, HMENU destMenuSpec)
{
  CMenu srcMenu;
  srcMenu.Attach(srcMenuSpec);
  CMenu destMenu;
  destMenu.Attach(destMenuSpec);
  int startPos = 0;
  for (int i = 0; i < srcMenu.GetItemCount(); i++)
  {
    CMenuItem item;
    item.fMask = MIIM_STATE | MIIM_ID | Get_fMaskForFTypeAndString();
    item.fType = MFT_STRING;
    if (srcMenu.GetItem(i, true, item))
      if (destMenu.InsertItem(startPos, true, item))
        startPos++;
  }
}

void OnMenuActivating(HWND /* hWnd */, HMENU hMenu, int position)
{
  if (::GetSubMenu(::GetMenu(g_HWND), position) != hMenu)
    return;
  if (position == kFileMenuIndex)
  {
    if ((HMENU)g_FileMenu == 0)
    {
      g_FileMenu.CreatePopup();
      CopyMenu(hMenu, g_FileMenu);
    }
    CMenu menu;
    menu.Attach(hMenu);
    while (menu.GetItemCount() > 0)
    {
      if (!menu.RemoveItem(0, MF_BYPOSITION))
        break;
    }
    // CopyMenu(g_FileMenu, hMenu);
    g_App.GetFocusedPanel().CreateFileMenu(hMenu);
  }
  else if (position == kEditMenuIndex)
  {
    /*
    CMenu menu;
    menu.Attach(hMenu);
    menu.EnableItem(IDM_EDIT_CUT, MF_ENABLED);
    menu.EnableItem(IDM_EDIT_COPY, MF_ENABLED);
    menu.EnableItem(IDM_EDIT_PASTE, IsClipboardFormatAvailableHDROP() ? MF_ENABLED : MF_GRAYED);
    */
  }
  else if (position == kViewMenuIndex)
  {
    // View;
    CMenu menu;
    menu.Attach(hMenu);
    menu.CheckRadioItem(IDM_VIEW_LARGE_ICONS, IDM_VIEW_DETAILS, 
      IDM_VIEW_LARGE_ICONS + g_App.GetListViewMode(), MF_BYCOMMAND);
    menu.CheckItem(IDM_VIEW_TWO_PANELS, MF_BYCOMMAND |
        ((g_App.NumPanels == 2) ? MF_CHECKED : MF_UNCHECKED));
    menu.CheckItem(IDM_VIEW_FLAT_VIEW, MF_BYCOMMAND |
        ((g_App.GetFlatMode()) ? MF_CHECKED : MF_UNCHECKED));
    menu.CheckItem(IDM_VIEW_ARCHIVE_TOOLBAR, MF_BYCOMMAND |
        (g_App.ShowArchiveToolbar ? MF_CHECKED : MF_UNCHECKED));
    menu.CheckItem(IDM_VIEW_STANDARD_TOOLBAR, MF_BYCOMMAND |
        (g_App.ShowStandardToolbar ? MF_CHECKED : MF_UNCHECKED));
    menu.CheckItem(IDM_VIEW_TOOLBARS_LARGE_BUTTONS, MF_BYCOMMAND |
        (g_App.LargeButtons ? MF_CHECKED : MF_UNCHECKED));
    menu.CheckItem(IDM_VIEW_TOOLBARS_SHOW_BUTTONS_TEXT, MF_BYCOMMAND |
        (g_App.ShowButtonsLables ? MF_CHECKED : MF_UNCHECKED));
  }
  else if (position == kBookmarksMenuIndex)
  {
    CMenu menu;
    menu.Attach(hMenu);

    CMenu subMenu;
    subMenu.Attach(menu.GetSubMenu(0));
    while (subMenu.GetItemCount() > 0)
      subMenu.RemoveItem(subMenu.GetItemCount() - 1, MF_BYPOSITION);
    int i;
    for (i = 0; i < 10; i++)
    {
      UString s = LangString(IDS_BOOKMARK, 0x03000720);
      s += L" ";
      wchar_t c = (wchar_t)(L'0' + i);
      s += c;
      s += L"\tAlt+Shift+";
      s += c;
      subMenu.AppendItem(MF_STRING, kSetBookmarkMenuID + i, s);
    }

    while (menu.GetItemCount() > 2)
      menu.RemoveItem(menu.GetItemCount() - 1, MF_BYPOSITION);

    for (i = 0; i < 10; i++)
    {
      UString path = g_App.AppState.FastFolders.GetString(i);
      const int kMaxSize = 100;
      const int kFirstPartSize = kMaxSize / 2;
      if (path.Length() > kMaxSize)
      {
        path = path.Left(kFirstPartSize) + UString(L" ... ") +
          path.Right(kMaxSize - kFirstPartSize);
      }
      UString s = path;
      if (s.IsEmpty())
        s = L"-";
      s += L"\tAlt+";
      s += (wchar_t)(L'0' + i);
      menu.AppendItem(MF_STRING, kOpenBookmarkMenuID + i, s);
    }
  }
}

/*
It doesn't help
void OnMenuUnActivating(HWND hWnd, HMENU hMenu, int id)
{
  if (::GetSubMenu(::GetMenu(g_HWND), 0) != hMenu)
    return;
  // g_App.GetFocusedPanel()._contextMenu.Release();
}

void OnMenuUnActivating(HWND hWnd)
{
}
*/


void LoadFileMenu(HMENU hMenu, int startPos, bool /* forFileMode */, bool programMenu)
{
  {
    CMenu srcMenu;
    srcMenu.Attach(::GetSubMenu(::GetMenu(g_HWND), 0));
    if ((HMENU)g_FileMenu == 0)
    {
      g_FileMenu.CreatePopup();
      CopyMenu(srcMenu, g_FileMenu);
    }
  }

  CMenu destMenu;
  destMenu.Attach(hMenu);
  
  for (int i = 0; i < g_FileMenu.GetItemCount(); i++)
  {
    CMenuItem item;

    item.fMask = MIIM_STATE | MIIM_ID | Get_fMaskForFTypeAndString();
    item.fType = MFT_STRING;
    if (g_FileMenu.GetItem(i, true, item))
    {
      if (!programMenu)
        if (item.wID == IDCLOSE)
          continue;
      /*
      bool createItem = (item.wID == IDM_CREATE_FOLDER || item.wID == IDM_CREATE_FILE);
      if (forFileMode)
      {
        if (createItem)
         continue;
      }
      else
      {
        if (!createItem)
         continue;
      }
      */
      if (destMenu.InsertItem(startPos, true, item))
        startPos++;
    }
  }
  while (destMenu.GetItemCount() > 0)
  {
    CMenuItem item;
    item.fMask = MIIM_TYPE;
    item.fType = 0;
    // item.dwTypeData = 0;
    int lastIndex = destMenu.GetItemCount() - 1;
    if (!destMenu.GetItem(lastIndex, true, item))
      break;
    if(item.fType != MFT_SEPARATOR)
      break;
    if (!destMenu.RemoveItem(lastIndex, MF_BYPOSITION))
      break;
  }
}
#endif

bool ExecuteFileCommand(int id)
{
  if (id >= kMenuCmdID_Plugin_Start)
  {
    printf("DEBUG : ExecuteFileCommand(id=%d)-0\n",id);
#ifdef _WIN32
    g_App.GetFocusedPanel().InvokePluginCommand(id);
    g_App.GetFocusedPanel()._sevenZipContextMenu.Release();
    g_App.GetFocusedPanel()._systemContextMenu.Release();
#endif
    return true;
  }

  printf("DEBUG : ExecuteFileCommand(id=%d)-1\n",id);
  switch (id)
  {
    // File
    case IDM_OPEN: g_App.OpenItem(); break;
    case IDM_OPEN_INSIDE:        g_App.OpenItemInside(NULL); break;
    case IDM_OPEN_INSIDE_ONE:    g_App.OpenItemInside(L"*"); break;
    case IDM_OPEN_INSIDE_PARSER: g_App.OpenItemInside(L"#"); break;
    case IDM_OPEN_OUTSIDE: g_App.OpenItemOutside(); break;
    case IDM_FILE_VIEW: g_App.EditItem(false); break;
    case IDM_FILE_EDIT: g_App.EditItem(true); break;
    case IDM_RENAME: g_App.Rename(); break;
    case IDM_COPY_TO: g_App.CopyTo(); break;
    case IDM_MOVE_TO: g_App.MoveTo(); break;
#ifdef _WIN32 // FIXME
    case IDM_DELETE: g_App.Delete(!IsKeyDown(VK_SHIFT)); break;
#else
    case IDM_DELETE: g_App.Delete(true); break; // FIXME
#endif
    
    case IDM_HASH_ALL: g_App.CalculateCrc(L"*"); break;
    case IDM_CRC32: g_App.CalculateCrc(L"CRC32"); break;
    case IDM_CRC64: g_App.CalculateCrc(L"CRC64"); break;
    case IDM_SHA1: g_App.CalculateCrc(L"SHA1"); break;
    case IDM_SHA256: g_App.CalculateCrc(L"SHA256"); break;
    
    case IDM_DIFF: g_App.DiffFiles(); break;
    case IDM_SPLIT: g_App.Split(); break;
    case IDM_COMBINE: g_App.Combine(); break;
    case IDM_PROPERTIES: g_App.Properties(); break;
    case IDM_COMMENT: g_App.Comment(); break;
    case IDM_CREATE_FOLDER: g_App.CreateFolder(); break;
    case IDM_CREATE_FILE: g_App.CreateFile(); break;
    #if 0 // FIXME #ifndef UNDER_CE
    case IDM_LINK: g_App.Link(); break;
    #endif
    default: return false;
  } 
  printf("DEBUG : ExecuteFileCommand(id=%d)-2\n",id);
  return true;
}

#define LLL_(quote) L##quote
#define LLL(quote) LLL_(quote)

void createAboutDialog(void)
{
    wxAboutDialogInfo info;

    UString msg;
  
    msg = L"7-Zip is free software";
    info.SetDescription((const wchar_t *)msg);


    UString version = LLL(MY_VERSION);
    #ifdef MY_CPU_64BIT
    version += L" [";
    version += LangString(IDS_PROP_BIT64);
    version += L']';
    #endif

    info.SetName(_("P7ZIP"));
    // info.SetVersion(wxString(MY_VERSION, wxConvUTF8));
    info.SetVersion((const wchar_t *)version);
    info.SetCopyright(wxString(MY_COPYRIGHT, wxConvUTF8));
    info.SetWebSite(_T("www.7-zip.org"));

    wxAboutBox(info);
}

static void MyBenchmark(bool totalMode)
{
  CPanel::CDisableTimerProcessing disableTimerProcessing1(g_App.Panels[0]);
  CPanel::CDisableTimerProcessing disableTimerProcessing2(g_App.Panels[1]);
  Benchmark(totalMode);
}

bool OnMenuCommand(HWND hWnd, int id)
{
  printf("DEBUG : OnMenuCommand(%p,id=%d)-0\n",hWnd,id);

  if (ExecuteFileCommand(id))
    return true;

  printf("DEBUG : OnMenuCommand(%p,id=%d)-1\n",hWnd,id);

  switch (id)
  {
    // File
    case IDCLOSE:
    /* FIXME
      SendMessage(hWnd, WM_ACTIVATE, MAKEWPARAM(WA_INACTIVE, 0), (LPARAM)hWnd);
      SendMessage (hWnd, WM_CLOSE, 0, 0);
    */
      hWnd->Close(true);
      break;

    // Edit
    /*
    case IDM_EDIT_CUT:
      g_App.EditCut();
      break;
    case IDM_EDIT_COPY:
      g_App.EditCopy();
      break;
    case IDM_EDIT_PASTE:
      g_App.EditPaste();
      break;
    */
    case IDM_SELECT_ALL:
      g_App.SelectAll(true);
      g_App.Refresh_StatusBar();
      break;
    case IDM_DESELECT_ALL:
      g_App.SelectAll(false);
      g_App.Refresh_StatusBar();
      break;
    case IDM_INVERT_SELECTION:
      g_App.InvertSelection();
      g_App.Refresh_StatusBar();
      break;
    case IDM_SELECT:
      g_App.SelectSpec(true);
      g_App.Refresh_StatusBar();
      break;
    case IDM_DESELECT:
      g_App.SelectSpec(false);
      g_App.Refresh_StatusBar();
      break;
    case IDM_SELECT_BY_TYPE:
      g_App.SelectByType(true);
      g_App.Refresh_StatusBar();
      break;
    case IDM_DESELECT_BY_TYPE:
      g_App.SelectByType(false);
      g_App.Refresh_StatusBar();
      break;

    //View
    case IDM_VIEW_LARGE_ICONS:
    case IDM_VIEW_SMALL_ICONS:
    case IDM_VIEW_LIST:
    case IDM_VIEW_DETAILS:
    {
      UINT index = id - IDM_VIEW_LARGE_ICONS;
      if (index < 4)
      {
        g_App.SetListViewMode(index);
        /*
        CMenu menu;
        menu.Attach(::GetSubMenu(::GetMenu(hWnd), kMenuIndex_View));
        menu.CheckRadioItem(IDM_VIEW_LARGE_ICONS, IDM_VIEW_DETAILS,
            id, MF_BYCOMMAND);
        */
      }
      break;
    }
    case IDM_VIEW_ARANGE_BY_NAME: g_App.SortItemsWithPropID(kpidName); break;
    case IDM_VIEW_ARANGE_BY_TYPE: g_App.SortItemsWithPropID(kpidExtension); break;
    case IDM_VIEW_ARANGE_BY_DATE: g_App.SortItemsWithPropID(kpidMTime); break;
    case IDM_VIEW_ARANGE_BY_SIZE: g_App.SortItemsWithPropID(kpidSize); break;
    case IDM_VIEW_ARANGE_NO_SORT: g_App.SortItemsWithPropID(kpidNoProperty); break;

    case IDM_OPEN_ROOT_FOLDER:    g_App.OpenRootFolder(); break;
    case IDM_OPEN_PARENT_FOLDER:  g_App.OpenParentFolder(); break;
    case IDM_FOLDERS_HISTORY:     g_App.FoldersHistory(); break;
    case IDM_VIEW_FLAT_VIEW:      g_App.ChangeFlatMode(); break;
    case IDM_VIEW_REFRESH:        g_App.RefreshView(); break;
    case IDM_VIEW_AUTO_REFRESH:   g_App.Change_AutoRefresh_Mode(); break;

    // case IDM_VIEW_SHOW_STREAMS:     g_App.Change_ShowNtfsStrems_Mode(); break;
    /*
    case IDM_VIEW_SHOW_DELETED:
    {
      g_App.Change_ShowDeleted();
      bool isChecked = g_App.ShowDeletedFiles;
      Save_ShowDeleted(isChecked);
    }
    */
    
    case IDM_VIEW_TWO_PANELS:       g_App.SwitchOnOffOnePanel(); break;
    case IDM_VIEW_STANDARD_TOOLBAR: g_App.SwitchStandardToolbar(); break;
    case IDM_VIEW_ARCHIVE_TOOLBAR:  g_App.SwitchArchiveToolbar(); break;

    case IDM_VIEW_TOOLBARS_SHOW_BUTTONS_TEXT: g_App.SwitchButtonsLables(); break;
    case IDM_VIEW_TOOLBARS_LARGE_BUTTONS:     g_App.SwitchLargeButtons(); break;

    // Tools
    // FIXME case IDM_OPTIONS: OptionsDialog(hWnd, g_hInstance); break;
          
    case IDM_BENCHMARK: MyBenchmark(false); break;
    case IDM_BENCHMARK2: MyBenchmark(true); break;

    // Help
    case IDM_HELP_CONTENTS:
      ShowHelpWindow(NULL, kFMHelpTopic);
      break;
    case IDM_ABOUT:
    {
	    /* FIXME
      CAboutDialog dialog;
      dialog.Create(hWnd);
      */
      createAboutDialog();
      break;
    }
    default:
    {
      if (id >= kOpenBookmarkMenuID && id <= kOpenBookmarkMenuID + 9)
      {
        g_App.OpenBookmark(id - kOpenBookmarkMenuID);
        return true;
      }
      else if (id >= kSetBookmarkMenuID && id <= kSetBookmarkMenuID + 9)
      {
        g_App.SetBookmark(id - kSetBookmarkMenuID);
        return true;
      }
      return false;
    }
  }
  return true;
}

// MyLoadMenu.h

#ifndef __MY_LOAD_MENU_H
#define __MY_LOAD_MENU_H

class myHMENU; // FIXME
typedef myHMENU * HMENU; // FIXME

void OnMenuActivating(HWND hWnd, HMENU hMenu, int position);
// void OnMenuUnActivating(HWND hWnd, HMENU hMenu, int id);
// void OnMenuUnActivating(HWND hWnd);

bool OnMenuCommand(HWND hWnd, int id);
void MyLoadMenu();

struct CFileMenu
{
  bool programMenu;
  bool readOnly;
  bool isFsFolder;
  bool allAreFiles;
  bool isAltStreamsSupported;
  int numItems;
  
  CFileMenu():
      programMenu(false),
      readOnly(false),
      isFsFolder(false),
      allAreFiles(false),
      isAltStreamsSupported(true),
      numItems(0)
    {}

  void Load(HMENU hMenu, unsigned startPos);
};

bool ExecuteFileCommand(int id);

#endif
// MyWindowsNew.h

#ifndef __MY_WINDOWS_NEW_H
#define __MY_WINDOWS_NEW_H

#ifdef _MSC_VER

#include <ShObjIdl.h>

#ifndef __ITaskbarList3_INTERFACE_DEFINED__
#define __ITaskbarList3_INTERFACE_DEFINED__

typedef enum THUMBBUTTONFLAGS
{
  THBF_ENABLED = 0,
  THBF_DISABLED = 0x1,
  THBF_DISMISSONCLICK = 0x2,
  THBF_NOBACKGROUND = 0x4,
  THBF_HIDDEN = 0x8,
  THBF_NONINTERACTIVE = 0x10
} THUMBBUTTONFLAGS;

typedef enum THUMBBUTTONMASK
{
  THB_BITMAP = 0x1,
  THB_ICON = 0x2,
  THB_TOOLTIP = 0x4,
  THB_FLAGS = 0x8
} THUMBBUTTONMASK;

// #include <pshpack8.h>

typedef struct THUMBBUTTON
{
  THUMBBUTTONMASK dwMask;
  UINT iId;
  UINT iBitmap;
  HICON hIcon;
  WCHAR szTip[260];
  THUMBBUTTONFLAGS dwFlags;
} THUMBBUTTON;

typedef struct THUMBBUTTON *LPTHUMBBUTTON;

typedef enum TBPFLAG
{
  TBPF_NOPROGRESS = 0,
  TBPF_INDETERMINATE = 0x1,
  TBPF_NORMAL = 0x2,
  TBPF_ERROR = 0x4,
  TBPF_PAUSED = 0x8
} TBPFLAG;

DEFINE_GUID(IID_ITaskbarList3, 0xEA1AFB91, 0x9E28, 0x4B86, 0x90, 0xE9, 0x9E, 0x9F, 0x8A, 0x5E, 0xEF, 0xAF);

struct ITaskbarList3: public ITaskbarList2
{
  STDMETHOD(SetProgressValue)(HWND hwnd, ULONGLONG ullCompleted, ULONGLONG ullTotal) = 0;
  STDMETHOD(SetProgressState)(HWND hwnd, TBPFLAG tbpFlags) = 0;
  STDMETHOD(RegisterTab)(HWND hwndTab, HWND hwndMDI) = 0;
  STDMETHOD(UnregisterTab)(HWND hwndTab) = 0;
  STDMETHOD(SetTabOrder)(HWND hwndTab, HWND hwndInsertBefore) = 0;
  STDMETHOD(SetTabActive)(HWND hwndTab, HWND hwndMDI, DWORD dwReserved) = 0;
  STDMETHOD(ThumbBarAddButtons)(HWND hwnd, UINT cButtons, LPTHUMBBUTTON pButton) = 0;
  STDMETHOD(ThumbBarUpdateButtons)(HWND hwnd, UINT cButtons, LPTHUMBBUTTON pButton) = 0;
  STDMETHOD(ThumbBarSetImageList)(HWND hwnd, HIMAGELIST himl) = 0;
  STDMETHOD(SetOverlayIcon)(HWND hwnd, HICON hIcon, LPCWSTR pszDescription) = 0;
  STDMETHOD(SetThumbnailTooltip)(HWND hwnd, LPCWSTR pszTip) = 0;
  STDMETHOD(SetThumbnailClip)(HWND hwnd, RECT *prcClip) = 0;
};

#endif

#endif

#endif
// OpenCallback.cpp

#include "StdAfx.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/FileName.h"
#include "../../../Windows/PropVariant.h"

#include "../../Common/FileStreams.h"

#include "../Common/ZipRegistry.h"

#include "OpenCallback.h"
#include "PasswordDialog.h"

using namespace NWindows;

STDMETHODIMP COpenArchiveCallback::SetTotal(const UInt64 *numFiles, const UInt64 *numBytes)
{
  RINOK(ProgressDialog.Sync.CheckStop());
  {
    // NSynchronization::CCriticalSectionLock lock(_criticalSection);
    if (numFiles)
    {
      ProgressDialog.Sync.Set_NumFilesTotal(*numFiles);
      ProgressDialog.Sync.Set_BytesProgressMode(false);
    }
    if (numBytes)
      ProgressDialog.Sync.Set_NumBytesTotal(*numBytes);
  }
  return S_OK;
}

STDMETHODIMP COpenArchiveCallback::SetCompleted(const UInt64 *numFiles, const UInt64 *numBytes)
{
  // NSynchronization::CCriticalSectionLock lock(_criticalSection);
  if (numFiles)
    ProgressDialog.Sync.Set_NumFilesCur(*numFiles);
  if (numBytes)
    ProgressDialog.Sync.Set_NumBytesCur(*numBytes);
  return ProgressDialog.Sync.CheckStop();
}

STDMETHODIMP COpenArchiveCallback::SetTotal(const UInt64 total)
{
  RINOK(ProgressDialog.Sync.CheckStop());
  ProgressDialog.Sync.Set_NumBytesTotal(total);
  return S_OK;
}

STDMETHODIMP COpenArchiveCallback::SetCompleted(const UInt64 *completed)
{
  return ProgressDialog.Sync.Set_NumBytesCur(completed);
}

STDMETHODIMP COpenArchiveCallback::GetProperty(PROPID propID, PROPVARIANT *value)
{
  NCOM::CPropVariant prop;
  if (_subArchiveMode)
  {
    switch (propID)
    {
      case kpidName: prop = _subArchiveName; break;
    }
  }
  else
  {
    switch (propID)
    {
      case kpidName:  prop = _fileInfo.Name; break;
      case kpidIsDir:  prop = _fileInfo.IsDir(); break;
      case kpidSize:  prop = _fileInfo.Size; break;
      case kpidAttrib:  prop = (UInt32)_fileInfo.Attrib; break;
      case kpidCTime:  prop = _fileInfo.CTime; break;
      case kpidATime:  prop = _fileInfo.ATime; break;
      case kpidMTime:  prop = _fileInfo.MTime; break;
    }
  }
  prop.Detach(value);
  return S_OK;
}

STDMETHODIMP COpenArchiveCallback::GetStream(const wchar_t *name, IInStream **inStream)
{
  COM_TRY_BEGIN
  *inStream = NULL;
  if (_subArchiveMode)
    return S_FALSE;

  FString fullPath;
  if (!NFile::NName::GetFullPath(_folderPrefix, us2fs(name), fullPath))
    return S_FALSE;
  if (!_fileInfo.Find(fullPath))
    return S_FALSE;
  if (_fileInfo.IsDir())
    return S_FALSE;
  CInFileStream *inFile = new CInFileStream;
  CMyComPtr<IInStream> inStreamTemp = inFile;
  if (!inFile->Open(fullPath))
    return ::GetLastError();
  *inStream = inStreamTemp.Detach();
  return S_OK;
  COM_TRY_END
}

STDMETHODIMP COpenArchiveCallback::CryptoGetTextPassword(BSTR *password)
{
  COM_TRY_BEGIN
  PasswordWasAsked = true;
  if (!PasswordIsDefined)
  {
    CPasswordDialog dialog;
    bool showPassword = NExtract::Read_ShowPassword();
    dialog.ShowPassword = showPassword;
   
    ProgressDialog.WaitCreating();
    if (dialog.Create(ProgressDialog) != IDOK)
      return E_ABORT;

    Password = dialog.Password;
    PasswordIsDefined = true;
    if (dialog.ShowPassword != showPassword)
      NExtract::Save_ShowPassword(dialog.ShowPassword);
  }
  return StringToBstr(Password, password);
  COM_TRY_END
}
// OpenCallback.h

#ifndef __OPEN_CALLBACK_H
#define __OPEN_CALLBACK_H

#include "../../../Common/MyCom.h"

#include "../../../Windows/FileFind.h"

#include "../../IPassword.h"

#include "../../Archive/IArchive.h"

#ifdef _SFX
#include "ProgressDialog.h"
#else
#include "ProgressDialog2.h"
#endif


class COpenArchiveCallback:
  public IArchiveOpenCallback,
  public IArchiveOpenVolumeCallback,
  public IArchiveOpenSetSubArchiveName,
  public IProgress,
  public ICryptoGetTextPassword,
  public CMyUnknownImp
{
  FString _folderPrefix;
  NWindows::NFile::NFind::CFileInfo _fileInfo;
  // NWindows::NSynchronization::CCriticalSection _criticalSection;
  bool _subArchiveMode;
  UString _subArchiveName;

public:
  bool PasswordIsDefined;
  bool PasswordWasAsked;
  UString Password;
  HWND ParentWindow;
  CProgressDialog ProgressDialog;

  MY_UNKNOWN_IMP5(
    IArchiveOpenCallback,
    IArchiveOpenVolumeCallback,
    IArchiveOpenSetSubArchiveName,
    IProgress,
    ICryptoGetTextPassword)

  INTERFACE_IProgress(;)
  INTERFACE_IArchiveOpenCallback(;)
  INTERFACE_IArchiveOpenVolumeCallback(;)

  // ICryptoGetTextPassword
  STDMETHOD(CryptoGetTextPassword)(BSTR *password);

  STDMETHOD(SetSubArchiveName(const wchar_t *name))
  {
    _subArchiveMode = true;
    _subArchiveName = name;
    return S_OK;
  }

  COpenArchiveCallback():
    ParentWindow(0)
  {
    _subArchiveMode = false;
    PasswordIsDefined = false;
    PasswordWasAsked = false;
  }
  /*
  void Init()
  {
    PasswordIsDefined = false;
    _subArchiveMode = false;
  }
  */
  void LoadFileInfo(const FString &folderPrefix, const FString &fileName)
  {
    _folderPrefix = folderPrefix;
    if (!_fileInfo.Find(_folderPrefix + fileName))
      throw 1;
  }
  void ShowMessage(const UInt64 *completed);

  INT_PTR StartProgressDialog(const UString &title, NWindows::CThread &thread)
  {
    return ProgressDialog.Create(title, thread, ParentWindow);
  }
};

#endif
// OverwriteDialog.cpp

#include "StdAfx.h"

#include "../../../Common/StringConvert.h"

#include "../../../Windows/PropVariantConv.h"
#include "../../../Windows/ResourceString.h"

#include "../../../Windows/Control/Static.h"

#include "FormatUtils.h"
#include "LangUtils.h"
#include "OverwriteDialog.h"

#include "PropertyNameRes.h"

using namespace NWindows;

#ifdef LANG
static const UInt32 kLangIDs[] =
{
  IDT_OVERWRITE_HEADER,
  IDT_OVERWRITE_QUESTION_BEGIN,
  IDT_OVERWRITE_QUESTION_END,
  IDB_YES_TO_ALL,
  IDB_NO_TO_ALL,
  IDB_AUTO_RENAME
};
#endif

static const unsigned kCurrentFileNameSizeLimit = 82;
static const unsigned kCurrentFileNameSizeLimit2 = 30;

void COverwriteDialog::ReduceString(UString &s)
{
  unsigned size = _isBig ? kCurrentFileNameSizeLimit : kCurrentFileNameSizeLimit2;
  if (s.Len() > size)
  {
    s.Delete(size / 2, s.Len() - size);
    s.Insert(size / 2, L" ... ");
  }
}

void COverwriteDialog::SetFileInfoControl(int textID, int iconID,
    const NOverwriteDialog::CFileInfo &fileInfo)
{
  UString sizeString;
  if (fileInfo.SizeIsDefined)
    sizeString = MyFormatNew(IDS_FILE_SIZE, NumberToString(fileInfo.Size));

  const UString &fileName = fileInfo.Name;
  int slashPos = fileName.ReverseFind_PathSepar();
  UString s1 = fileName.Left(slashPos + 1);
  UString s2 = fileName.Ptr(slashPos + 1);

  ReduceString(s1);
  ReduceString(s2);
  
  UString s = s1;
  s.Add_LF();
  s += s2;
  s.Add_LF();
  s += sizeString;
  s.Add_LF();

  if (fileInfo.TimeIsDefined)
  {
    FILETIME localFileTime;
    if (!FileTimeToLocalFileTime(&fileInfo.Time, &localFileTime))
      throw 4190402;
    AddLangString(s, IDS_PROP_MTIME);
    s += L": ";
    wchar_t t[32];
    ConvertFileTimeToString(localFileTime, t);
    s += t;
  }

  NControl::CDialogChildControl control;
  control.Init(*this, textID);
  control.SetText(s);

#if _WIN32
  SHFILEINFO shellFileInfo;
  if (::SHGetFileInfo(
      GetSystemString(fileInfo.Name), FILE_ATTRIBUTE_NORMAL, &shellFileInfo,
      sizeof(shellFileInfo), SHGFI_ICON | SHGFI_USEFILEATTRIBUTES | SHGFI_LARGEICON))
  {
    NControl::CStatic staticContol;
    staticContol.Attach(GetItem(iconID));
    staticContol.SetIcon(shellFileInfo.hIcon);
  }
#endif
}

bool COverwriteDialog::OnInit()
{
  #ifdef LANG
  LangSetWindowText(*this, IDD_OVERWRITE);
  LangSetDlgItems(*this, kLangIDs, ARRAY_SIZE(kLangIDs));
  #endif
  SetFileInfoControl(IDT_OVERWRITE_OLD_FILE_SIZE_TIME, IDI_OVERWRITE_OLD_FILE, OldFileInfo);
  SetFileInfoControl(IDT_OVERWRITE_NEW_FILE_SIZE_TIME, IDI_OVERWRITE_NEW_FILE, NewFileInfo);
  NormalizePosition();
  return CModalDialog::OnInit();
}

bool COverwriteDialog::OnButtonClicked(int buttonID, HWND buttonHWND)
{
  switch (buttonID)
  {
    case IDYES:
    case IDNO:
    case IDB_YES_TO_ALL:
    case IDB_NO_TO_ALL:
    case IDB_AUTO_RENAME:
      End(buttonID);
      return true;
  }
  return CModalDialog::OnButtonClicked(buttonID, buttonHWND);
}
// OverwriteDialog.h

#ifndef __OVERWRITE_DIALOG_H
#define __OVERWRITE_DIALOG_H

#include "../../../Windows/Control/Dialog.h"

#include "DialogSize.h"
#include "OverwriteDialogRes.h"

namespace NOverwriteDialog
{
  struct CFileInfo
  {
    bool SizeIsDefined;
    bool TimeIsDefined;
    UInt64 Size;
    FILETIME Time;
    UString Name;
    
    void SetTime(const FILETIME *t)
    {
      if (t == 0)
        TimeIsDefined = false;
      else
      {
        TimeIsDefined = true;
        Time = *t;
      }
    }
    void SetSize(const UInt64 *size)
    {
      if (size == 0)
        SizeIsDefined = false;
      else
      {
        SizeIsDefined = true;
        Size = *size;
      }
    }
  };
}

class COverwriteDialog: public NWindows::NControl::CModalDialog
{
  bool _isBig;

  void SetFileInfoControl(int textID, int iconID, const NOverwriteDialog::CFileInfo &fileInfo);
  virtual bool OnInit();
  bool OnButtonClicked(int buttonID, HWND buttonHWND);
  void ReduceString(UString &s);

public:
  INT_PTR Create(HWND parent = 0)
  {
    BIG_DIALOG_SIZE(280, 200);
    #ifdef UNDER_CE
    _isBig = isBig;
    #else
    _isBig = true;
    #endif
    return CModalDialog::Create(SIZED_DIALOG(IDD_OVERWRITE), parent);
  }

  NOverwriteDialog::CFileInfo OldFileInfo;
  NOverwriteDialog::CFileInfo NewFileInfo;
};

#endif
#define IDD_OVERWRITE     3500
#define IDD_OVERWRITE_2  13500

#define IDT_OVERWRITE_HEADER          3501
#define IDT_OVERWRITE_QUESTION_BEGIN  3502
#define IDT_OVERWRITE_QUESTION_END    3503
#define IDS_FILE_SIZE                 3504

#define IDB_AUTO_RENAME               3505
#define IDB_YES_TO_ALL                 440
#define IDB_NO_TO_ALL                  441

#define IDI_OVERWRITE_OLD_FILE             100
#define IDI_OVERWRITE_NEW_FILE             101

#define IDT_OVERWRITE_OLD_FILE_SIZE_TIME   102
#define IDT_OVERWRITE_NEW_FILE_SIZE_TIME   103
// OverwriteDialog_rc.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif  

#undef _WIN32

#include "OverwriteDialogRes.h"
#include "Windows/Control/DialogImpl.h"

/*
IDD_OVERWRITE DIALOG 0, 0, xSize, ySize MY_MODAL_DIALOG_STYLE
CAPTION "Confirm File Replace"
MY_FONT
BEGIN
  LTEXT "Destination folder already contains processed file.", IDT_OVERWRITE_HEADER, marg, 7, xSize2, 8
  LTEXT "Would you like to replace the existing file", IDT_OVERWRITE_QUESTION_BEGIN, marg, 28, xSize2, 8
  ICON  "", IDI_OVERWRITE_OLD_FILE,             marg,  44, iconSize, iconSize
  LTEXT "", IDT_OVERWRITE_OLD_FILE_SIZE_TIME,      fiXPos,  44,  fiXSize,  fiYSize, SS_NOPREFIX
  LTEXT "with this one?",IDT_OVERWRITE_QUESTION_END, marg,  98,   xSize2,        8
  ICON  "",IDI_OVERWRITE_NEW_FILE,              marg, 114, iconSize, iconSize
  LTEXT "",IDT_OVERWRITE_NEW_FILE_SIZE_TIME,       fiXPos, 114,  fiXSize,  fiYSize, SS_NOPREFIX
  PUSHBUTTON "&Yes",         IDYES,                             78, b2YPos, bXSize, bYSize
  PUSHBUTTON "Yes to &All",  IDB_YES_TO_ALL,  152, b2YPos, bXSize, bYSize
  PUSHBUTTON "&No",          IDNO,                             226, b2YPos, bXSize, bYSize
  PUSHBUTTON "No to A&ll",   IDB_NO_TO_ALL,   300, b2YPos, bXSize, bYSize
  PUSHBUTTON "A&uto Rename", IDB_AUTO_RENAME, 181, b1YPos,    109, bYSize
  PUSHBUTTON "&Cancel",      IDCANCEL,                         300, b1YPos, bXSize, bYSize
END
*/

class COverwriteDialogImpl : public NWindows::NControl::CModalDialogImpl
{
 public:
   COverwriteDialogImpl(NWindows::NControl::CModalDialog *dialog,wxWindow * parent , int id) : CModalDialogImpl(dialog,parent, id, wxT("Confirm File Replace"))
  {
	///Sizer for adding the controls created by users
	wxBoxSizer* topsizer = new wxBoxSizer(wxVERTICAL);

	topsizer->Add(new wxStaticText(this, IDT_OVERWRITE_HEADER, _T("Destination folder already contains processed file.")) , 0 ,wxALL | wxALIGN_LEFT, 5 );
	topsizer->Add(new wxStaticText(this, IDT_OVERWRITE_QUESTION_BEGIN, _T("Would you like to replace the existing file")) , 0 ,wxALL | wxALIGN_LEFT, 5 );

	// FIXME ICON  "", IDI_OVERWRITE_OLD_FILE,             marg,  44, iconSize, iconSize
	topsizer->Add(new wxStaticText(this, IDT_OVERWRITE_OLD_FILE_SIZE_TIME, _T(""),
		wxDefaultPosition, wxDefaultSize, wxALIGN_LEFT) , 0 ,wxALL | wxALIGN_LEFT, 15 );
	topsizer->Add(new wxStaticText(this, IDT_OVERWRITE_QUESTION_END, _T("with this one?")) , 0 ,wxALL | wxALIGN_LEFT, 5 );

	// FIXME ICON  "",IDI_OVERWRITE_NEW_FILE,              marg, 114, iconSize, iconSize
	topsizer->Add(new wxStaticText(this, IDT_OVERWRITE_NEW_FILE_SIZE_TIME, _T(""),
		wxDefaultPosition, wxDefaultSize, wxALIGN_LEFT) , 0 ,wxALL | wxALIGN_LEFT, 15 );

	wxBoxSizer* Sizer1 = new wxBoxSizer(wxHORIZONTAL);
	Sizer1->Add(new wxButton(this, wxID_YES, _T("&Yes")) ,  0, wxALL | wxALIGN_RIGHT, 5);
	Sizer1->Add(new wxButton(this, IDB_YES_TO_ALL, _T("Yes to &All")) ,  0, wxALL | wxALIGN_RIGHT, 5);
	Sizer1->Add(new wxButton(this, wxID_NO, _T("&No")) ,  0, wxALL | wxALIGN_RIGHT, 5);
	Sizer1->Add(new wxButton(this, IDB_NO_TO_ALL, _T("No to A&ll")) ,  0, wxALL | wxALIGN_RIGHT, 5);
	topsizer->Add(Sizer1 ,  0, wxALL | wxALIGN_RIGHT, 5);

	wxBoxSizer* Sizer2 = new wxBoxSizer(wxHORIZONTAL);
	Sizer2->Add(new wxButton(this, IDB_AUTO_RENAME, _T("A&uto Rename")) ,  0, wxALL | wxALIGN_RIGHT, 5);
	Sizer2->Add(new wxButton(this, wxID_CANCEL, _T("&Cancel")) ,  0, wxALL | wxALIGN_RIGHT, 5);
	topsizer->Add(Sizer2 ,  1, wxALL | wxALIGN_RIGHT, 5);

	this->OnInit();

	SetSizer(topsizer); // use the sizer for layout
	topsizer->SetSizeHints(this); // set size hints to honour minimum size
  }
private:
	// Any class wishing to process wxWindows events must use this macro
	DECLARE_EVENT_TABLE()
};

static CStringTable g_stringTable[] =
{
	{ IDS_FILE_SIZE, L"{0} bytes" },
	{ 0 , 0 }
};

REGISTER_DIALOG(IDD_OVERWRITE,COverwriteDialog,g_stringTable)

BEGIN_EVENT_TABLE(COverwriteDialogImpl, wxDialog)
	EVT_BUTTON(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_MENU(WORKER_EVENT, CModalDialogImpl::OnWorkerEvent)
END_EVENT_TABLE()

// Panel.cpp

#include "StdAfx.h"

// #include <Windowsx.h>

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/FileName.h"
#include "../../../Windows/ErrorMsg.h"
#include "../../../Windows/PropVariant.h"
#include "../../../Windows/Thread.h"

#include "../../PropID.h"

#include "resource.h"
#include "../GUI/ExtractRes.h"

#include "../Common/ArchiveName.h"
#include "../Common/CompressCall.h"

#include "../Agent/IFolderArchive.h"

#include "App.h"
#include "ExtractCallback.h"
#include "FSFolder.h"
#include "FormatUtils.h"
#include "Panel.h"
#include "RootFolder.h"

#include "PropertyNameRes.h"

using namespace NWindows;
using namespace NControl;

#ifndef _UNICODE
extern bool g_IsNT;
#endif

static const UINT_PTR kTimerID = 1;
static const UINT kTimerElapse = 1000;

// FIXME static DWORD kStyles[4] = { LVS_ICON, LVS_SMALLICON, LVS_LIST, LVS_REPORT };

// static const int kCreateFolderID = 101;

extern HINSTANCE g_hInstance;
extern DWORD g_ComCtl32Version;

void CPanel::Release()
{
  // It's for unloading COM dll's: don't change it.
  CloseOpenFolders();
  // FIXME _sevenZipContextMenu.Release();
  // FIXME _systemContextMenu.Release();
}

CPanel::~CPanel()
{
  CloseOpenFolders();
}

HWND CPanel::GetParent()
{
#ifdef _WIN32
  HWND h = CWindow2::GetParent();
  return (h == 0) ? _mainWindow : h;
#else
  return 0;
#endif
}

static LPCWSTR kClassName = L"7-Zip::Panel";


HRESULT CPanel::Create(HWND mainWindow, HWND parentWindow, UINT id,
    const UString &currentFolderPrefix,
    const UString &arcFormat,
    CPanelCallback *panelCallback, CAppState *appState,
    bool &archiveIsOpened, bool &encrypted)
{
  _mainWindow = mainWindow;
  _processTimer = true;
  _processNotify = true;
  _processStatusBar = true;

  _panelCallback = panelCallback;
  _appState = appState;
  // _index = index;
  _baseID = id;
  _comboBoxID = _baseID + 3;
  _statusBarID = _comboBoxID + 1;

  UString cfp = currentFolderPrefix;

  if (!currentFolderPrefix.IsEmpty())
    if (currentFolderPrefix[0] == L'.')
    {
      FString cfpF;
      if (NFile::NDir::MyGetFullPathName(us2fs(currentFolderPrefix), cfpF))
        cfp = fs2us(cfpF);
    }

  RINOK(BindToPath(cfp, arcFormat, archiveIsOpened, encrypted));

#ifdef _WIN32
  if (!CreateEx(0, kClassName, 0, WS_CHILD | WS_VISIBLE,
      0, 0, _xSize, 260,
      parentWindow, (HMENU)(UINT_PTR)id, g_hInstance))
    return E_FAIL;
#else
  {
  	// printf("WARNING CPanel::Create => CreateEx\n");
  	// this->OnCreate(0);
  	extern void registerWindow2(int baseID,NWindows::NControl::CWindow2 *w);
	registerWindow2(_baseID,this);
  }
#endif
  return S_OK;
}

LRESULT CPanel::OnMessage(UINT message, WPARAM wParam, LPARAM lParam)
{
  switch (message)
  {
    case kShiftSelectMessage:
      OnShiftSelectMessage();
      return 0;
    case kReLoadMessage:
      RefreshListCtrl(_selectedState);
      return 0;
    case kSetFocusToListView:
      _listView.SetFocus();
      return 0;
    case kOpenItemChanged:
      return OnOpenItemChanged(lParam);
    case kRefresh_StatusBar:
      if (_processStatusBar)
        Refresh_StatusBar();
      return 0;
#ifdef _WIN32
    #ifdef UNDER_CE
    case kRefresh_HeaderComboBox:
      LoadFullPathAndShow();
      return 0;
    #endif
    case WM_TIMER:
      OnTimer();
      return 0;
    case WM_CONTEXTMENU:
      if (OnContextMenu(HANDLE(wParam), GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)))
        return 0;
      break;
    /*
    case WM_DROPFILES:
      CompressDropFiles(HDROP(wParam));
      return 0;
    */
#endif
  }
  return CWindow2::OnMessage(message, wParam, lParam);
}

LRESULT CMyListView::OnMessage(UINT message, WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
  if (message == WM_CHAR)
  {
    UINT scanCode = (UINT)((lParam >> 16) & 0xFF);
    bool extended = ((lParam & 0x1000000) != 0);
    UINT virtualKey = MapVirtualKey(scanCode, 1);
    if (virtualKey == VK_MULTIPLY || virtualKey == VK_ADD ||
        virtualKey == VK_SUBTRACT)
      return 0;
    if ((wParam == '/' && extended)
        || wParam == '\\' || wParam == '/')
    {
      _panel->OpenDrivesFolder();
      return 0;
    }
  }
  else if (message == WM_SYSCHAR)
  {
    // For Alt+Enter Beep disabling
    UINT scanCode = (UINT)(lParam >> 16) & 0xFF;
    UINT virtualKey = MapVirtualKey(scanCode, 1);
    if (virtualKey == VK_RETURN || virtualKey == VK_MULTIPLY ||
        virtualKey == VK_ADD || virtualKey == VK_SUBTRACT)
      return 0;
  }
  /*
  else if (message == WM_SYSKEYDOWN)
  {
    // return 0;
  }
  */
  else if (message == WM_KEYDOWN)
  {
    bool alt = IsKeyDown(VK_MENU);
    bool ctrl = IsKeyDown(VK_CONTROL);
    bool shift = IsKeyDown(VK_SHIFT);
    switch (wParam)
    {
      /*
      case VK_RETURN:
      {
        if (shift && !alt && !ctrl)
        {
          _panel->OpenSelectedItems(false);
          return 0;
        }
        break;
      }
      */
      case VK_NEXT:
      {
        if (ctrl && !alt && !shift)
        {
          _panel->OpenFocusedItemAsInternal();
          return 0;
        }
        break;
      }
      case VK_PRIOR:
      if (ctrl && !alt && !shift)
      {
        _panel->OpenParentFolder();
        return 0;
      }
    }
  }
  #ifdef UNDER_CE
  else if (message == WM_KEYUP)
  {
    if (wParam == VK_F2) // it's VK_TSOFT2
    {
      // Activate Menu
      ::PostMessage(g_HWND, WM_SYSCOMMAND, SC_KEYMENU, 0);
      return 0;
    }
  }
  #endif
  else if (message == WM_SETFOCUS)
  {
    _panel->_lastFocusedIsList = true;
    _panel->_panelCallback->PanelWasFocused();
  }
#endif
  return CListView2::OnMessage(message, wParam, lParam);
}

/*
static LRESULT APIENTRY ComboBoxSubclassProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  CWindow tempDialog(hwnd);
  CMyComboBox *w = (CMyComboBox *)(tempDialog.GetUserDataLongPtr());
  if (w == NULL)
    return 0;
  return w->OnMessage(message, wParam, lParam);
}

LRESULT CMyComboBox::OnMessage(UINT message, WPARAM wParam, LPARAM lParam)
{
  return CallWindowProc(_origWindowProc, *this, message, wParam, lParam);
}
*/

#ifdef _WIN32
#ifndef UNDER_CE

static LRESULT APIENTRY ComboBoxEditSubclassProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  CWindow tempDialog(hwnd);
  CMyComboBoxEdit *w = (CMyComboBoxEdit *)(tempDialog.GetUserDataLongPtr());
  if (w == NULL)
    return 0;
  return w->OnMessage(message, wParam, lParam);
}

#endif

LRESULT CMyComboBoxEdit::OnMessage(UINT message, WPARAM wParam, LPARAM lParam)
{
  // See MSDN / Subclassing a Combo Box / Creating a Combo-box Toolbar
  switch (message)
  {
    case WM_SYSKEYDOWN:
      switch (wParam)
      {
        case VK_F1:
        case VK_F2:
        {
          // check ALT
          if ((lParam & (1<<29)) == 0)
            break;
          bool alt = IsKeyDown(VK_MENU);
          bool ctrl = IsKeyDown(VK_CONTROL);
          bool shift = IsKeyDown(VK_SHIFT);
          if (alt && !ctrl && !shift)
          {
            _panel->_panelCallback->SetFocusToPath(wParam == VK_F1 ? 0 : 1);
            return 0;
          }
          break;
        }
      }
      break;
    case WM_KEYDOWN:
      switch (wParam)
      {
        case VK_TAB:
          // SendMessage(hwndMain, WM_ENTER, 0, 0);
          _panel->SetFocusToList();
          return 0;
        case VK_F9:
        {
          bool alt = IsKeyDown(VK_MENU);
          bool ctrl = IsKeyDown(VK_CONTROL);
          bool shift = IsKeyDown(VK_SHIFT);
          if (!alt && !ctrl && !shift)
          {
            g_App.SwitchOnOffOnePanel();;
            return 0;
          }
          break;
        }
      }
      break;
    case WM_CHAR:
      switch (wParam)
      {
        case VK_TAB:
        case VK_ESCAPE:
          return 0;
      }
  }
  #ifndef _UNICODE
  if (g_IsNT)
    return CallWindowProcW(_origWindowProc, *this, message, wParam, lParam);
  else
  #endif
    return CallWindowProc(_origWindowProc, *this, message, wParam, lParam);
}

bool CPanel::OnCreate(CREATESTRUCT * /* createStruct */)
{
  // _virtualMode = false;
  // _sortIndex = 0;
  _sortID = kpidName;
  _ascending = true;
  _lastFocusedIsList = true;

  DWORD style = WS_CHILD | WS_VISIBLE; //  | WS_BORDER ; // | LVS_SHAREIMAGELISTS; //  | LVS_SHOWSELALWAYS;;

  style |= LVS_SHAREIMAGELISTS;
  // style  |= LVS_AUTOARRANGE;
  style |= WS_CLIPCHILDREN;
  style |= WS_CLIPSIBLINGS;

  const UInt32 kNumListModes = ARRAY_SIZE(kStyles);
  if (_ListViewMode >= kNumListModes)
    _ListViewMode = kNumListModes - 1;

  style |= kStyles[_ListViewMode]
    | WS_TABSTOP
    | LVS_EDITLABELS;
  if (_mySelectMode)
    style |= LVS_SINGLESEL;

  /*
  if (_virtualMode)
    style |= LVS_OWNERDATA;
  */

  DWORD exStyle;
  exStyle = WS_EX_CLIENTEDGE;

  if (!_listView.CreateEx(exStyle, style, 0, 0, 116, 260,
      *this, (HMENU)(UINT_PTR)(_baseID + 1), g_hInstance, NULL))
    return false;

  _listView.SetUnicodeFormat();
  _listView._panel = this;
  _listView.SetWindowProc();

  _listView.SetImageList(GetSysImageList(true), LVSIL_SMALL);
  _listView.SetImageList(GetSysImageList(false), LVSIL_NORMAL);

  // _exStyle |= LVS_EX_HEADERDRAGDROP;
  // DWORD extendedStyle = _listView.GetExtendedListViewStyle();
  // extendedStyle |= _exStyle;
  //  _listView.SetExtendedListViewStyle(extendedStyle);
  SetExtendedStyle();

  _listView.Show(SW_SHOW);
  _listView.InvalidateRect(NULL, true);
  _listView.Update();
  
  // Ensure that the common control DLL is loaded.
  INITCOMMONCONTROLSEX icex;

  icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
  icex.dwICC  = ICC_BAR_CLASSES;
  InitCommonControlsEx(&icex);

  TBBUTTON tbb [ ] =
  {
    // {0, 0, TBSTATE_ENABLED, BTNS_SEP, 0L, 0},
    {VIEW_PARENTFOLDER, kParentFolderID, TBSTATE_ENABLED, BTNS_BUTTON, 0L, 0},
    // {0, 0, TBSTATE_ENABLED, BTNS_SEP, 0L, 0},
    // {VIEW_NEWFOLDER, kCreateFolderID, TBSTATE_ENABLED, BTNS_BUTTON, 0L, 0},
  };

  #ifndef UNDER_CE
  if (g_ComCtl32Version >= MAKELONG(71, 4))
  #endif
  {
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_COOL_CLASSES | ICC_BAR_CLASSES;
    InitCommonControlsEx(&icex);
    
    // if there is no CCS_NOPARENTALIGN, there is space of some pixels after rebar (Incorrect GetWindowRect ?)

    _headerReBar.Attach(::CreateWindowEx(WS_EX_TOOLWINDOW,
      REBARCLASSNAME,
      NULL, WS_VISIBLE | WS_BORDER | WS_CHILD |
      WS_CLIPCHILDREN | WS_CLIPSIBLINGS
      | CCS_NODIVIDER
      | CCS_NOPARENTALIGN
      | CCS_TOP
      | RBS_VARHEIGHT
      | RBS_BANDBORDERS
      ,0,0,0,0, *this, NULL, g_hInstance, NULL));
  }

  DWORD toolbarStyle =  WS_CHILD | WS_VISIBLE ;
  if (_headerReBar)
  {
    toolbarStyle |= 0
      // | WS_CLIPCHILDREN
      // | WS_CLIPSIBLINGS

      | TBSTYLE_TOOLTIPS
      | CCS_NODIVIDER
      | CCS_NORESIZE
      | TBSTYLE_FLAT
      ;
  }

  _headerToolBar.Attach(::CreateToolbarEx ((*this), toolbarStyle,
      _baseID + 2, 11,
      (HINSTANCE)HINST_COMMCTRL,
      IDB_VIEW_SMALL_COLOR,
      (LPCTBBUTTON)&tbb, ARRAY_SIZE(tbb),
      0, 0, 0, 0, sizeof (TBBUTTON)));

  #ifndef UNDER_CE
  // Load ComboBoxEx class
  icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
  icex.dwICC = ICC_USEREX_CLASSES;
  InitCommonControlsEx(&icex);
  #endif
  
  _headerComboBox.CreateEx(0,
      #ifdef UNDER_CE
      WC_COMBOBOXW
      #else
      WC_COMBOBOXEXW
      #endif
      , NULL,
    WS_BORDER | WS_VISIBLE |WS_CHILD | CBS_DROPDOWN | CBS_AUTOHSCROLL,
      0, 0, 100, 520,
      ((_headerReBar == 0) ? (HWND)*this : _headerToolBar),
      (HMENU)(UINT_PTR)(_comboBoxID),
      g_hInstance, NULL);
  #ifndef UNDER_CE
  _headerComboBox.SetUnicodeFormat(true);

  _headerComboBox.SetImageList(GetSysImageList(true));

  _headerComboBox.SetExtendedStyle(CBES_EX_PATHWORDBREAKPROC, CBES_EX_PATHWORDBREAKPROC);

  /*
  _headerComboBox.SetUserDataLongPtr(LONG_PTR(&_headerComboBox));
  _headerComboBox._panel = this;
  _headerComboBox._origWindowProc =
      (WNDPROC)_headerComboBox.SetLongPtr(GWLP_WNDPROC,
      LONG_PTR(ComboBoxSubclassProc));
  */
  _comboBoxEdit.Attach(_headerComboBox.GetEditControl());

  // _comboBoxEdit.SendMessage(CCM_SETUNICODEFORMAT, (WPARAM)(BOOL)TRUE, 0);

  _comboBoxEdit.SetUserDataLongPtr(LONG_PTR(&_comboBoxEdit));
  _comboBoxEdit._panel = this;
   #ifndef _UNICODE
   if (g_IsNT)
     _comboBoxEdit._origWindowProc =
      (WNDPROC)_comboBoxEdit.SetLongPtrW(GWLP_WNDPROC, LONG_PTR(ComboBoxEditSubclassProc));
   else
   #endif
     _comboBoxEdit._origWindowProc =
      (WNDPROC)_comboBoxEdit.SetLongPtr(GWLP_WNDPROC, LONG_PTR(ComboBoxEditSubclassProc));

  #endif

  if (_headerReBar)
  {
    REBARINFO     rbi;
    rbi.cbSize = sizeof(REBARINFO);  // Required when using this struct.
    rbi.fMask  = 0;
    rbi.himl   = (HIMAGELIST)NULL;
    _headerReBar.SetBarInfo(&rbi);
    
    // Send the TB_BUTTONSTRUCTSIZE message, which is required for
    // backward compatibility.
    // _headerToolBar.SendMessage(TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
    SIZE size;
    _headerToolBar.GetMaxSize(&size);
    
    REBARBANDINFO rbBand;
    rbBand.cbSize = sizeof(REBARBANDINFO);  // Required
    rbBand.fMask = RBBIM_STYLE | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_SIZE;
    rbBand.fStyle = RBBS_NOGRIPPER;
    rbBand.cxMinChild = size.cx;
    rbBand.cyMinChild = size.cy;
    rbBand.cyChild = size.cy;
    rbBand.cx = size.cx;
    rbBand.hwndChild  = _headerToolBar;
    _headerReBar.InsertBand(-1, &rbBand);

    RECT rc;
    ::GetWindowRect(_headerComboBox, &rc);
    rbBand.cxMinChild = 30;
    rbBand.cyMinChild = rc.bottom - rc.top;
    rbBand.cx = 1000;
    rbBand.hwndChild  = _headerComboBox;
    _headerReBar.InsertBand(-1, &rbBand);
    // _headerReBar.MaximizeBand(1, false);
  }

  _statusBar.Create(WS_CHILD | WS_VISIBLE, L"Status", (*this), _statusBarID);
  // _statusBar2.Create(WS_CHILD | WS_VISIBLE, L"Status", (*this), _statusBarID + 1);

  int sizes[] = {160, 250, 350, -1};
  _statusBar.SetParts(4, sizes);
  // _statusBar2.SetParts(5, sizes);

  /*
  RECT rect;
  GetClientRect(&rect);
  OnSize(0, RECT_SIZE_X(rect), RECT_SIZE_Y(rect));
  */

  SetTimer(kTimerID, kTimerElapse);

  // InitListCtrl();
  RefreshListCtrl();
  
  return true;
}
#else
bool CPanel::OnCreate(CREATESTRUCT * /* createStruct */)
{
   printf("WARNING CPanel::OnCreate\n");
  _sortID = kpidName;
  _ascending = true;
  _lastFocusedIsList = true;

  extern HWND g_HWND;
  HWND w = GetDlgItem(g_HWND, _comboBoxID);
  if (w == 0) 
  {
	  printf("Can't find id=%d\n",_comboBoxID);
	  return false;
  }
  printf("CPanel::OnCreate : _headerComboBox.Attach(%p)\n",w);
  _headerComboBox.Attach(w);

  w = GetDlgItem(g_HWND, _statusBarID);
  if (w == 0) 
  {
	  printf("Can't find id=%d\n",_statusBarID);
	  return false;
  }
  printf("CPanel::OnCreate : _statusBar.Attach(%p)\n",w);
  _statusBar.Attach(w);

  w = GetDlgItem(g_HWND, _baseID + 1);
  if (w == 0) 
  {
	  printf("Can't find id=%d\n",_baseID + 1);
	  return false;
  }
  printf("CPanel::OnCreate : _listView.Attach(%p)\n",w);
  _listView.Attach(w);
  
  _listView.SetUnicodeFormat(true);

  // _listView.SetUserDataLongPtr(LONG_PTR(&_listView));
  _listView._panel = this;

  // FIXME _listView.SetImageList(GetSysImageList(true), LVSIL_SMALL);
  // FIXME _listView.SetImageList(GetSysImageList(false), LVSIL_NORMAL);

  // FIXME SetExtendedStyle();

  // FIXME _listView.Show(SW_SHOW);
  // FIXME _listView.InvalidateRect(NULL, true);
  _listView.Update();
  
  /* FIXME
  _headerToolBar.Attach(::CreateToolbarEx ((*this), toolbarStyle,
      _baseID + 2, 11,
      (HINSTANCE)HINST_COMMCTRL,
      IDB_VIEW_SMALL_COLOR,
      (LPCTBBUTTON)&tbb, sizeof(tbb) / sizeof(tbb[0]),
      0, 0, 0, 0, sizeof (TBBUTTON)));
      */

  /* FIXME
  _headerComboBox.CreateEx(0, WC_COMBOBOXEXW, NULL,
    WS_BORDER | WS_VISIBLE |WS_CHILD | CBS_DROPDOWN | CBS_AUTOHSCROLL,
      0, 0, 100, 520,
      ((_headerReBar == 0) ? HWND(*this) : _headerToolBar),
      (HMENU)(UINT_PTR)(_comboBoxID),
      g_hInstance, NULL);
  _headerComboBox.SendMessage(CBEM_SETUNICODEFORMAT, (WPARAM)(BOOL)TRUE, 0);

  _headerComboBox.SetImageList(GetSysImageList(true));

  _headerComboBox.SetExtendedStyle(CBES_EX_PATHWORDBREAKPROC, CBES_EX_PATHWORDBREAKPROC);
  */

  // FIXME _comboBoxEdit.Attach(_headerComboBox.GetEditControl());

  _comboBoxEdit._panel = this;

  // FIXME if (_headerReBar) ...

  // _statusBar.Create(WS_CHILD | WS_VISIBLE, L"Status", (*this), _statusBarID);

  // int sizes[] = {150, 250, 350, -1};
  // _statusBar.SetParts(4, sizes);

  // SetTimer(kTimerID, kTimerElapse);

  // InitListCtrl();
  RefreshListCtrl();
  
  return true;
}
#endif

void CPanel::OnDestroy()
{
  SaveListViewInfo();
  CWindow2::OnDestroy();
}

#ifdef _WIN32
void CPanel::ChangeWindowSize(int xSize, int ySize)
{
  if ((HWND)*this == 0)
    return;
  int kHeaderSize;
  int kStatusBarSize;
  // int kStatusBar2Size;
  RECT rect;
  if (_headerReBar)
    _headerReBar.GetWindowRect(&rect);
  else
    _headerToolBar.GetWindowRect(&rect);

  kHeaderSize = RECT_SIZE_Y(rect);

  _statusBar.GetWindowRect(&rect);
  kStatusBarSize = RECT_SIZE_Y(rect);
  
  // _statusBar2.GetWindowRect(&rect);
  // kStatusBar2Size = RECT_SIZE_Y(rect);
 
  int yListViewSize = MyMax(ySize - kHeaderSize - kStatusBarSize, 0);
  const int kStartXPos = 32;
  if (_headerReBar)
  {
  }
  else
  {
    _headerToolBar.Move(0, 0, xSize, 0);
    _headerComboBox.Move(kStartXPos, 2,
        MyMax(xSize - kStartXPos - 10, kStartXPos), 0);
  }
  _listView.Move(0, kHeaderSize, xSize, yListViewSize);
  _statusBar.Move(0, kHeaderSize + yListViewSize, xSize, kStatusBarSize);
  // _statusBar2.MoveWindow(0, kHeaderSize + yListViewSize + kStatusBarSize, xSize, kStatusBar2Size);
  // _statusBar.MoveWindow(0, 100, xSize, kStatusBarSize);
  // _statusBar2.MoveWindow(0, 200, xSize, kStatusBar2Size);
}

bool CPanel::OnSize(WPARAM /* wParam */, int xSize, int ySize)
{
  if ((HWND)*this == 0)
    return true;
  if (_headerReBar)
    _headerReBar.Move(0, 0, xSize, 0);
  ChangeWindowSize(xSize, ySize);
  return true;
}

bool CPanel::OnNotifyReBar(LPNMHDR header, LRESULT & /* result */)
{
  switch (header->code)
  {
    case RBN_HEIGHTCHANGE:
    {
      RECT rect;
      GetWindowRect(&rect);
      ChangeWindowSize(RECT_SIZE_X(rect), RECT_SIZE_Y(rect));
      return false;
    }
  }
  return false;
}
#endif

bool CPanel::OnNotify(UINT /* controlID */, LPNMHDR header, LRESULT &result)
{
  if (!_processNotify)
    return false;
  if (header->hwndFrom == _headerComboBox)
    return OnNotifyComboBox(header, result);
#ifdef _WIN32
  else if (header->hwndFrom == _headerReBar)
    return OnNotifyReBar(header, result);
#endif
  else if (header->hwndFrom == _listView)
    return OnNotifyList(header, result);
#ifdef _WIN32
  else if (::GetParent(header->hwndFrom) == _listView &&
      header->code == NM_RCLICK)
    return OnRightClick((MY_NMLISTVIEW_NMITEMACTIVATE *)header, result);
#endif
  return false;
}

bool CPanel::OnCommand(int code, int itemID, LPARAM lParam, LRESULT &result)
{
 printf("CPanel::OnCommand(code=%d,itemID=%d)\n",code,itemID);
  if (itemID == kParentFolderID)
  {
    OpenParentFolder();
    result = 0;
    return true;
  }
  /*
  if (itemID == kCreateFolderID)
  {
    CreateFolder();
    result = 0;
    return true;
  }
  */
  if (itemID == _comboBoxID)
  {
    if (OnComboBoxCommand(code, lParam, result))
      return true;
  }
  return CWindow2::OnCommand(code, itemID, lParam, result);
}

void CPanel::MessageBoxInfo(LPCWSTR message, LPCWSTR caption)
  { ::MessageBoxW((HWND)*this, message, caption, MB_OK); }
void CPanel::MessageBox(LPCWSTR message, LPCWSTR caption)
  { ::MessageBoxW((HWND)*this, message, caption, MB_OK | MB_ICONSTOP); }
void CPanel::MessageBox(LPCWSTR message)
  { MessageBox(message, L"7-Zip"); }
/* FIXME
void CPanel::MessageBoxWarning(LPCWSTR message)
  { ::MessageBoxW(NULL, message, L"7-Zip", MB_OK | MB_ICONWARNING); }
*/
void CPanel::MessageBoxMyError(LPCWSTR message)
  { MessageBox(message, L"7-Zip"); }


void CPanel::MessageBoxError(HRESULT errorCode, LPCWSTR caption)
{
  MessageBox(HResultToMessage(errorCode), caption);
}

void CPanel::MessageBoxError2Lines(LPCWSTR message, HRESULT errorCode)
{
  UString m = message;
  if (errorCode != 0)
  {
    m.Add_LF();
    m += HResultToMessage(errorCode);
  }
  MessageBoxMyError(m);
}

void CPanel::MessageBoxError(HRESULT errorCode)
  { MessageBoxError(errorCode, L"7-Zip"); }
void CPanel::MessageBoxLastError(LPCWSTR caption)
  { MessageBoxError(::GetLastError(), caption); }
void CPanel::MessageBoxLastError()
  { MessageBoxLastError(L"7-Zip"); }

void CPanel::MessageBoxErrorLang(UINT resourceID)
  { MessageBox(LangString(resourceID)); }


void CPanel::SetFocusToList()
{
  _listView.SetFocus();
  // SetCurrentPathText();
}

void CPanel::SetFocusToLastRememberedItem()
{
  if (_lastFocusedIsList)
    SetFocusToList();
  // FIXME else
    // FIXME _headerComboBox.SetFocus();
}

UString CPanel::GetFolderTypeID() const
{
  {
    NCOM::CPropVariant prop;
    if (_folder->GetFolderProperty(kpidType, &prop) == S_OK)
      if (prop.vt == VT_BSTR)
        return (const wchar_t *)prop.bstrVal;
  }
  return UString();
}

bool CPanel::IsFolderTypeEqTo(const char *s) const
{
  return StringsAreEqual_Ascii(GetFolderTypeID(), s);
}

bool CPanel::IsRootFolder() const { return IsFolderTypeEqTo("RootFolder"); }
bool CPanel::IsFSFolder() const { return IsFolderTypeEqTo("FSFolder"); }
bool CPanel::IsFSDrivesFolder() const { return IsFolderTypeEqTo("FSDrives"); }
bool CPanel::IsAltStreamsFolder() const { return IsFolderTypeEqTo("AltStreamsFolder"); }
bool CPanel::IsArcFolder() const
{
  return GetFolderTypeID().IsPrefixedBy_Ascii_NoCase("7-Zip");
}

UString CPanel::GetFsPath() const
{
  if (IsFSDrivesFolder() && !IsDeviceDrivesPrefix() && !IsSuperDrivesPrefix())
    return UString();
  return _currentFolderPrefix;
}

UString CPanel::GetDriveOrNetworkPrefix() const
{
  if (!IsFSFolder())
    return UString();
  UString drive = GetFsPath();
  // FIXME drive.DeleteFrom(NFile::NName::GetRootPrefixSize(drive));
  return drive;
}

void CPanel::SetListViewMode(UInt32 index)
{
  if (index >= 4)
    return;
  _ListViewMode = index;
#ifdef _WIN32
  DWORD oldStyle = (DWORD)_listView.GetStyle();
  DWORD newStyle = kStyles[index];

  // DWORD tickCount1 = GetTickCount();
  if ((oldStyle & LVS_TYPEMASK) != newStyle)
    _listView.SetStyle((oldStyle & ~LVS_TYPEMASK) | newStyle);
  // RefreshListCtrlSaveFocused();
  /*
  DWORD tickCount2 = GetTickCount();
  char s[256];
  sprintf(s, "SetStyle = %5d",
      tickCount2 - tickCount1
      );
  OutputDebugStringA(s);
  */
#endif
}

void CPanel::ChangeFlatMode()
{
  _flatMode = !_flatMode;
  if (_parentFolders.Size() > 0)
    _flatModeForArc = _flatMode;
  else
    _flatModeForDisk = _flatMode;
  RefreshListCtrlSaveFocused();
}

/*
void CPanel::Change_ShowNtfsStrems_Mode()
{
  _showNtfsStrems_Mode = !_showNtfsStrems_Mode;
  if (_parentFolders.Size() > 0)
    _showNtfsStrems_ModeForArc = _showNtfsStrems_Mode;
  else
    _showNtfsStrems_ModeForDisk = _showNtfsStrems_Mode;
  RefreshListCtrlSaveFocused();
}
*/

void CPanel::Post_Refresh_StatusBar()
{
  // FIXME if (_processStatusBar)
    // FIXME PostMessage(kRefresh_StatusBar);
}

void CPanel::AddToArchive()
{
  CRecordVector<UInt32> indices;
  GetOperatedItemIndices(indices);
  if (!Is_IO_FS_Folder())
  {
    MessageBoxErrorLang(IDS_OPERATION_IS_NOT_SUPPORTED);
    return;
  }
  if (indices.Size() == 0)
  {
    MessageBoxErrorLang(IDS_SELECT_FILES);
    return;
  }
  UStringVector names;

  const UString curPrefix = GetFsPath();
  UString destCurDirPrefix = curPrefix;
  if (IsFSDrivesFolder())
    destCurDirPrefix = ROOT_FS_FOLDER;

  FOR_VECTOR (i, indices)
    names.Add(curPrefix + GetItemRelPath2(indices[i]));
  bool fromPrev = (names.Size() > 1);
  const UString arcName = CreateArchiveName(names.Front(), fromPrev, false);
  HRESULT res = CompressFiles(destCurDirPrefix, arcName, L"",
      true, // addExtension
      names, false, true, false);
  if (res != S_OK)
  {
    if (destCurDirPrefix.Len() >= MAX_PATH)
      MessageBoxErrorLang(IDS_MESSAGE_UNSUPPORTED_OPERATION_FOR_LONG_PATH_FOLDER);
  }
  // KillSelection();
}

static UString GetSubFolderNameForExtract(const UString &arcPath)
{
  UString s = arcPath;
  int slashPos = s.ReverseFind_PathSepar();
  int dotPos = s.ReverseFind_Dot();
  if (dotPos <= slashPos + 1)
    s += L'~';
  else
  {
    s.DeleteFrom(dotPos);
    s.TrimRight();
  }
  return s;
}

void CPanel::GetFilePaths(const CRecordVector<UInt32> &indices, UStringVector &paths, bool allowFolders)
{
  const UString prefix = GetFsPath();
  FOR_VECTOR (i, indices)
  {
    int index = indices[i];
    if (!allowFolders && IsItem_Folder(index))
    {
      paths.Clear();
      break;
    }
    paths.Add(prefix + GetItemRelPath2(index));
  }
  if (paths.Size() == 0)
  {
    MessageBoxErrorLang(IDS_SELECT_FILES);
    return;
  }
}

void CPanel::ExtractArchives()
{
  if (_parentFolders.Size() > 0)
  {
    _panelCallback->OnCopy(false, false);
    return;
  }
  CRecordVector<UInt32> indices;
  GetOperatedItemIndices(indices);
  UStringVector paths;
  GetFilePaths(indices, paths);
  if (paths.IsEmpty())
    return;
  
  UString outFolder = GetFsPath();
  if (indices.Size() == 1)
    outFolder += GetSubFolderNameForExtract(GetItemRelPath(indices[0]));
  else
    outFolder += L'*';
  outFolder.Add_PathSepar();
  
  ::ExtractArchives(paths, outFolder
      , true // showDialog
      , false // elimDup
      );
}

/*
static void AddValuePair(UINT resourceID, UInt64 value, UString &s)
{
  AddLangString(s, resourceID);
  char sz[32];
  s += L": ";
  ConvertUInt64ToString(value, sz);
  s.AddAsciiStr(sz);
  s.Add_LF();
}
*/

class CThreadTest: public CProgressThreadVirt
{
  HRESULT ProcessVirt();
public:
  CRecordVector<UInt32> Indices;
  CExtractCallbackImp *ExtractCallbackSpec;
  CMyComPtr<IFolderArchiveExtractCallback> ExtractCallback;
  CMyComPtr<IArchiveFolder> ArchiveFolder;
};

// actually now we don't need CThreadTest, since now we call CopyTo for "test command

/*
HRESULT CThreadTest::ProcessVirt()
{
  RINOK(ArchiveFolder->Extract(&Indices[0], Indices.Size(),
      true, // includeAltStreams
      false, // replaceAltStreamColon
      NExtract::NPathMode::kFullPathnames,
      NExtract::NOverwriteMode::kAskBefore,
      NULL, // path
      BoolToInt(true), // testMode
      ExtractCallback));
  if (ExtractCallbackSpec->IsOK())
  {
    UString s;
    AddValuePair(IDS_PROP_FOLDERS, ExtractCallbackSpec->NumFolders, s);
    AddValuePair(IDS_PROP_FILES, ExtractCallbackSpec->NumFiles, s);
    // AddValuePair(IDS_PROP_SIZE, ExtractCallbackSpec->UnpackSize, s);
    // AddSizePair(IDS_COMPRESSED_COLON, Stat.PackSize, s);
    s.Add_LF();
    AddLangString(s, IDS_MESSAGE_NO_ERRORS);
    FinalMessage.OkMessage.Message = s;
  }
  return S_OK;
}
*/

/*
static void AddSizePair(UInt32 langID, UInt64 value, UString &s)
{
  char sz[32];
  AddLangString(s, langID);
  s += L' ';
  ConvertUInt64ToString(value, sz);
  s.AddAsciiStr(sz);
  ConvertUInt64ToString(value >> 20, sz);
  s.AddAsciiStr(" (");
  s.AddAsciiStr(sz);
  s.AddAsciiStr(" MB)");
  s.Add_LF();
}
*/

void CPanel::TestArchives()
{
  CRecordVector<UInt32> indices;
  GetOperatedIndicesSmart(indices);
  CMyComPtr<IArchiveFolder> archiveFolder;
  _folder.QueryInterface(IID_IArchiveFolder, &archiveFolder);
  if (archiveFolder)
  {
    CCopyToOptions options;
    options.streamMode = true;
    options.showErrorMessages = true;
    options.testMode = true;

    UStringVector messages;
    HRESULT res = CopyTo(options, indices, &messages);
    if (res != S_OK)
    {
      if (res != E_ABORT)
        MessageBoxError(res);
    }
    return;

    /*
    {
    CThreadTest extracter;

    extracter.ArchiveFolder = archiveFolder;
    extracter.ExtractCallbackSpec = new CExtractCallbackImp;
    extracter.ExtractCallback = extracter.ExtractCallbackSpec;
    extracter.ExtractCallbackSpec->ProgressDialog = &extracter.ProgressDialog;
    if (!_parentFolders.IsEmpty())
    {
      const CFolderLink &fl = _parentFolders.Back();
      extracter.ExtractCallbackSpec->PasswordIsDefined = fl.UsePassword;
      extracter.ExtractCallbackSpec->Password = fl.Password;
    }

    if (indices.IsEmpty())
      return;

    extracter.Indices = indices;
    
    UString title = LangString(IDS_PROGRESS_TESTING);
    UString progressWindowTitle = L"7-Zip"; // LangString(IDS_APP_TITLE);
    
    extracter.ProgressDialog.CompressingMode = false;
    extracter.ProgressDialog.MainWindow = GetParent();
    extracter.ProgressDialog.MainTitle = progressWindowTitle;
    extracter.ProgressDialog.MainAddTitle = title + L' ';
    
    extracter.ExtractCallbackSpec->OverwriteMode = NExtract::NOverwriteMode::kAskBefore;
    extracter.ExtractCallbackSpec->Init();
    
    if (extracter.Create(title, GetParent()) != S_OK)
      return;
    
    }
    RefreshTitleAlways();
    return;
    */
  }

  if (!IsFSFolder())
  {
    MessageBoxErrorLang(IDS_OPERATION_IS_NOT_SUPPORTED);
    return;
  }
  UStringVector paths;
  GetFilePaths(indices, paths, true);
  if (paths.IsEmpty())
    return;
  ::TestArchives(paths);
}
// Panel.h

#ifndef __PANEL_H
#define __PANEL_H

#include "../../../../C/Alloc.h"

#include "../../../Common/Defs.h"
#include "../../../Common/MyCom.h"

#include "../../../Windows/DLL.h"
#include "../../../Windows/FileDir.h"
#include "../../../Windows/FileFind.h"
#include "../../../Windows/FileName.h"
// #include "../../../Windows/Handle.h"
#include "../../../Windows/Synchronization.h"

#include "../../../Windows/Control/ComboBox.h"
#include "../../../Windows/Control/Edit.h"
#include "../../../Windows/Control/ListView.h"
// FIXME #include "../../../Windows/Control/ReBar.h"
#include "../../../Windows/Control/Static.h"
#include "../../../Windows/Control/StatusBar.h"
// FIXME #include "../../../Windows/Control/ToolBar.h"
#include "../../../Windows/Control/Window2.h"

#include "../../Archive/IArchive.h"

#include "ExtractCallback.h"

#include "AppState.h"
#include "IFolder.h"
// FIXME #include "MyCom2.h"
#include "ProgressDialog2.h"
#include "SysIconUtils.h"

#ifdef UNDER_CE
#define NON_CE_VAR(_v_)
#else
#define NON_CE_VAR(_v_) _v_
#endif

const int kParentFolderID = 100;

const int kParentIndex = -1;

#if !defined(_WIN32) || defined(UNDER_CE)
#define ROOT_FS_FOLDER L"\\"
#else
#define ROOT_FS_FOLDER L"C:\\"
#endif

struct CPanelCallback
{
  virtual void OnTab() = 0;
  virtual void SetFocusToPath(int index) = 0;
  virtual void OnCopy(bool move, bool copyToSame) = 0;
  virtual void OnSetSameFolder() = 0;
  virtual void OnSetSubFolder() = 0;
  virtual void PanelWasFocused() = 0;
  virtual void DragBegin() = 0;
  virtual void DragEnd() = 0;
  virtual void RefreshTitle(bool always) = 0;
};

void PanelCopyItems();

struct CItemProperty
{
  UString Name;
  PROPID ID;
  VARTYPE Type;
  int Order;
  bool IsVisible;
  bool IsRawProp;
  UInt32 Width;

  int Compare(const CItemProperty &a) const { return MyCompare(Order, a.Order); }
};

class CItemProperties: public CObjectVector<CItemProperty>
{
public:
  int FindItemWithID(PROPID id)
  {
    FOR_VECTOR (i, (*this))
      if ((*this)[i].ID == id)
        return i;
    return -1;
  }
};

struct CTempFileInfo
{
  UInt32 FileIndex;  // index of file in folder
  UString RelPath;   // Relative path of file from Folder
  FString FolderPath;
  FString FilePath;
  NWindows::NFile::NFind::CFileInfo FileInfo;
  bool NeedDelete;

  CTempFileInfo(): FileIndex((UInt32)(Int32)-1), NeedDelete(false) {}
  void DeleteDirAndFile() const
  {
    if (NeedDelete)
    {
      NWindows::NFile::NDir::DeleteFileAlways(FilePath);
      NWindows::NFile::NDir::RemoveDir(FolderPath);
    }
  }
  bool WasChanged(const NWindows::NFile::NFind::CFileInfo &newFileInfo) const
  {
    return newFileInfo.Size != FileInfo.Size ||
        CompareFileTime(&newFileInfo.MTime, &FileInfo.MTime) != 0;
  }
};

struct CFolderLink: public CTempFileInfo
{
  NWindows::NDLL::CLibrary Library;
  CMyComPtr<IFolderFolder> ParentFolder; // can be NULL, if parent is FS folder (in _parentFolders[0])
  UString ParentFolderPath; // including tail slash (doesn't include paths parts of parent in next level)
  bool UsePassword;
  UString Password;
  bool IsVirtual;

  UString VirtualPath; // without tail slash
  CFolderLink(): UsePassword(false), IsVirtual(false) {}

  bool WasChanged(const NWindows::NFile::NFind::CFileInfo &newFileInfo) const
  {
    return IsVirtual || CTempFileInfo::WasChanged(newFileInfo);
  }

};

enum MyMessages
{
  // we can use WM_USER, since we have defined new window class.
  // so we don't need WM_APP.
  kShiftSelectMessage = WM_USER + 1,
  kReLoadMessage,
  kSetFocusToListView,
  kOpenItemChanged,
  kRefresh_StatusBar
  #ifdef UNDER_CE
  , kRefresh_HeaderComboBox
  #endif
};

UString GetFolderPath(IFolderFolder *folder);

class CPanel;

class CMyListView: public NWindows::NControl::CListView2
{
public:
  CPanel *_panel;
  LRESULT OnMessage(UINT message, WPARAM wParam, LPARAM lParam);
};

/*
class CMyComboBox: public NWindows::NControl::CComboBoxEx
{
public:
  WNDPROC _origWindowProc;
  CPanel *_panel;
  LRESULT OnMessage(UINT message, WPARAM wParam, LPARAM lParam);
};
*/
class CMyComboBoxEdit: public NWindows::NControl::CEdit
{
public:
  WNDPROC _origWindowProc;
  CPanel *_panel;
  LRESULT OnMessage(UINT message, WPARAM wParam, LPARAM lParam);
};

struct CSelectedState
{
  int FocusedItem;
  UString FocusedName;
  bool SelectFocused;
  UStringVector SelectedNames;
  CSelectedState(): FocusedItem(-1), SelectFocused(false) {}
};

#ifdef UNDER_CE
#define MY_NMLISTVIEW_NMITEMACTIVATE NMLISTVIEW
#else
#define MY_NMLISTVIEW_NMITEMACTIVATE NMITEMACTIVATE
#endif

struct CCopyToOptions
{
  bool streamMode;
  bool moveMode;
  bool testMode;
  bool includeAltStreams;
  bool replaceAltStreamChars;
  bool showErrorMessages;

  UString folder;

  UStringVector hashMethods;

  CVirtFileSystem *VirtFileSystemSpec;
  ISequentialOutStream *VirtFileSystem;
  
  CCopyToOptions():
      streamMode(false),
      moveMode(false),
      testMode(false),
      includeAltStreams(true),
      replaceAltStreamChars(false),
      showErrorMessages(false),
      VirtFileSystemSpec(NULL),
      VirtFileSystem(NULL)
      {}
};
  

class CPanel: public NWindows::NControl::CWindow2
{
  CExtToIconMap _extToIconMap;
  UINT _baseID;
  int _comboBoxID;
  UINT _statusBarID;

  CAppState *_appState;

  bool OnCommand(int code, int itemID, LPARAM lParam, LRESULT &result);
  LRESULT OnMessage(UINT message, WPARAM wParam, LPARAM lParam);
  virtual bool OnCreate(CREATESTRUCT *createStruct);
  // FIXME virtual bool OnSize(WPARAM wParam, int xSize, int ySize);
  virtual void OnDestroy();
  virtual bool OnNotify(UINT controlID, LPNMHDR lParam, LRESULT &result);

  void AddComboBoxItem(const UString &name, int iconIndex, int indent, bool addToList);

  bool OnComboBoxCommand(UINT code, LPARAM param, LRESULT &result);
  
  #ifndef UNDER_CE
  
  LRESULT OnNotifyComboBoxEnter(const UString &s);
  bool OnNotifyComboBoxEndEdit(PNMCBEENDEDITW info, LRESULT &result);
  #ifndef _UNICODE
  bool OnNotifyComboBoxEndEdit(PNMCBEENDEDIT info, LRESULT &result);
  #endif

  #endif

  bool OnNotifyReBar(LPNMHDR lParam, LRESULT &result);
  bool OnNotifyComboBox(LPNMHDR lParam, LRESULT &result);
  void OnItemChanged(NMLISTVIEW *item);
  void OnNotifyActivateItems();
  bool OnNotifyList(LPNMHDR lParam, LRESULT &result);
/* FIXME
  void OnDrag(LPNMLISTVIEW nmListView);
  bool OnKeyDown(LPNMLVKEYDOWN keyDownInfo, LRESULT &result);
  BOOL OnBeginLabelEdit(LV_DISPINFOW * lpnmh);
  BOOL OnEndLabelEdit(LV_DISPINFOW * lpnmh);
*/
  void OnColumnClick(LPNMLISTVIEW info);
  // FIXME bool OnCustomDraw(LPNMLVCUSTOMDRAW lplvcd, LRESULT &result);


public:
  HWND _mainWindow;
  CPanelCallback *_panelCallback;

  void SysIconsWereChanged() { _extToIconMap.Clear(); }

  void DeleteItems(bool toRecycleBin);
  void CreateFolder();
  void CreateFile();
  bool CorrectFsPath(const UString &path, UString &result);
  // bool IsPathForPlugin(const UString &path);

private:

  void ChangeWindowSize(int xSize, int ySize);
 
  HRESULT InitColumns();
  // void InitColumns2(PROPID sortID);
  void InsertColumn(unsigned index);

  void SetFocusedSelectedItem(int index, bool select);
  HRESULT RefreshListCtrl(const UString &focusedName, int focusedPos, bool selectFocused,
      const UStringVector &selectedNames);

  void OnShiftSelectMessage();
  void OnArrowWithShift();

  void OnInsert();
  // void OnUpWithShift();
  // void OnDownWithShift();
public:
  void UpdateSelection();
  void SelectSpec(bool selectMode);
  void SelectByType(bool selectMode);
  void SelectAll(bool selectMode);
  void InvertSelection();
private:

  // UString GetFileType(UInt32 index);
  LRESULT SetItemText(LVITEMW &item);

  // CRecordVector<PROPID> m_ColumnsPropIDs;

public:
  // NWindows::NControl::CReBar _headerReBar;
  // NWindows::NControl::CToolBar _headerToolBar;
  NWindows::NControl::
    #ifdef UNDER_CE
    CComboBox
    #else
    CComboBoxEx
    #endif
    _headerComboBox;
  UStringVector ComboBoxPaths;
  // CMyComboBox _headerComboBox;
  CMyComboBoxEdit _comboBoxEdit;
  CMyListView _listView;
  NWindows::NControl::CStatusBar _statusBar;
  bool _lastFocusedIsList;
  // NWindows::NControl::CStatusBar _statusBar2;

  DWORD _exStyle;
  bool _showDots;
  bool _showRealFileIcons;
  // bool _virtualMode;
  // CUIntVector _realIndices;
  bool _enableItemChangeNotify;
  bool _mySelectMode;
  CBoolVector _selectedStatusVector;

  CSelectedState _selectedState;
  bool _thereAreDeletedItems;
  bool _markDeletedItems;

  HWND GetParent();

  UInt32 GetRealIndex(const LVITEMW &item) const
  {
    /*
    if (_virtualMode)
      return _realIndices[item.iItem];
    */
    return (UInt32)item.lParam;
  }
  
  int GetRealItemIndex(int indexInListView) const
  {
    /*
    if (_virtualMode)
      return indexInListView;
    */
    LPARAM param;
    if (!_listView.GetItemParam(indexInListView, param))
      throw 1;
    return (int)param;
  }

  UInt32 _ListViewMode;
  int _xSize;

  bool _flatMode;
  bool _flatModeForDisk;
  bool _flatModeForArc;

  // bool _showNtfsStrems_Mode;
  // bool _showNtfsStrems_ModeForDisk;
  // bool _showNtfsStrems_ModeForArc;

  bool _dontShowMode;


  UString _currentFolderPrefix;
  
  CObjectVector<CFolderLink> _parentFolders;
  NWindows::NDLL::CLibrary _library;
  
  CMyComPtr<IFolderFolder> _folder;
  CMyComPtr<IFolderCompare> _folderCompare;
  CMyComPtr<IFolderGetItemName> _folderGetItemName;
  CMyComPtr<IArchiveGetRawProps> _folderRawProps;
  CMyComPtr<IFolderAltStreams> _folderAltStreams;
  CMyComPtr<IFolderOperations> _folderOperations;

  void ReleaseFolder();
  void SetNewFolder(IFolderFolder *newFolder);

  // CMyComPtr<IFolderGetSystemIconIndex> _folderGetSystemIconIndex;

  UStringVector _fastFolders;

  void GetSelectedNames(UStringVector &selectedNames);
  void SaveSelectedState(CSelectedState &s);
  HRESULT RefreshListCtrl(const CSelectedState &s);
  HRESULT RefreshListCtrlSaveFocused();

  bool GetItem_BoolProp(UInt32 itemIndex, PROPID propID) const;
  bool IsItem_Deleted(int itemIndex) const;
  bool IsItem_Folder(int itemIndex) const;
  bool IsItem_AltStream(int itemIndex) const;

  UString GetItemName(int itemIndex) const;
  UString GetItemName_for_Copy(int itemIndex) const;
  void GetItemName(int itemIndex, UString &s) const;
  UString GetItemPrefix(int itemIndex) const;
  UString GetItemRelPath(int itemIndex) const;
  UString GetItemRelPath2(int itemIndex) const;
  UString GetItemFullPath(int itemIndex) const;
  UInt64 GetItemSize(int itemIndex) const;

  ////////////////////////
  // PanelFolderChange.cpp

  void SetToRootFolder();
  HRESULT BindToPath(const UString &fullPath, const UString &arcFormat, bool &archiveIsOpened, bool &encrypted); // can be prefix
  HRESULT BindToPathAndRefresh(const UString &path);
  void OpenDrivesFolder();
  
  void SetBookmark(int index);
  void OpenBookmark(int index);
  
  void LoadFullPath();
  void LoadFullPathAndShow();
  void FoldersHistory();
  void OpenParentFolder();
  void CloseOneLevel();
  void CloseOpenFolders();
  void OpenRootFolder();


  HRESULT Create(HWND mainWindow, HWND parentWindow,
      UINT id,
      const UString &currentFolderPrefix,
      const UString &arcFormat,
      CPanelCallback *panelCallback,
      CAppState *appState, bool &archiveIsOpened, bool &encrypted);
  void SetFocusToList();
  void SetFocusToLastRememberedItem();


  void ReadListViewInfo();
  void SaveListViewInfo();

  CPanel() :
      // _virtualMode(flase),
      _exStyle(0),
      _showDots(false),
      _showRealFileIcons(false),
      _needSaveInfo(false),
      _startGroupSelect(0),
      _selectionIsDefined(false),
      _ListViewMode(3),
      _flatMode(false),
      _flatModeForDisk(false),
      _flatModeForArc(false),

      // _showNtfsStrems_Mode(false),
      // _showNtfsStrems_ModeForDisk(false),
      // _showNtfsStrems_ModeForArc(false),

      _xSize(300),
      _mySelectMode(false),
      _thereAreDeletedItems(false),
      _markDeletedItems(true),
      _enableItemChangeNotify(true),
      _dontShowMode(false)
  {}

  void SetExtendedStyle()
  {
/* FIXME
    if (_listView != 0)
      _listView.SetExtendedListViewStyle(_exStyle);
*/
  }


  bool _needSaveInfo;
  UString _typeIDString;
  CListViewInfo _listViewInfo;
  CItemProperties _properties;
  CItemProperties _visibleProperties;
  
  PROPID _sortID;
  // int _sortIndex;
  bool _ascending;
  Int32 _isRawSortProp;

  void SetSortRawStatus();

  void Release();
  ~CPanel();
  // FIXME void OnLeftClick(MY_NMLISTVIEW_NMITEMACTIVATE *itemActivate);
  // FIXME bool OnRightClick(MY_NMLISTVIEW_NMITEMACTIVATE *itemActivate, LRESULT &result);
  void ShowColumnsContextMenu(int x, int y);

  void OnTimer();
  void OnReload();
  bool OnContextMenu(HANDLE windowHandle, int xPos, int yPos);

#ifdef _WIN32
  CMyComPtr<IContextMenu> _sevenZipContextMenu;
  CMyComPtr<IContextMenu> _systemContextMenu;
  HRESULT CreateShellContextMenu(
      const CRecordVector<UInt32> &operatedIndices,
      CMyComPtr<IContextMenu> &systemContextMenu);
  void CreateSystemMenu(HMENU menu,
      const CRecordVector<UInt32> &operatedIndices,
      CMyComPtr<IContextMenu> &systemContextMenu);
  void CreateSevenZipMenu(HMENU menu,
      const CRecordVector<UInt32> &operatedIndices,
      CMyComPtr<IContextMenu> &sevenZipContextMenu);
  void CreateFileMenu(HMENU menu,
      CMyComPtr<IContextMenu> &sevenZipContextMenu,
      CMyComPtr<IContextMenu> &systemContextMenu,
      bool programMenu);
  void CreateFileMenu(HMENU menu);
  bool InvokePluginCommand(int id);
  bool InvokePluginCommand(int id, IContextMenu *sevenZipContextMenu,
      IContextMenu *systemContextMenu);
#endif

  void InvokeSystemCommand(const char *command);
  void Properties();
  void EditCut();
  void EditCopy();
  void EditPaste();

  int _startGroupSelect;

  bool _selectionIsDefined;
  bool _selectMark;
  int _prevFocusedItem;

 
  // void SortItems(int index);
  void SortItemsWithPropID(PROPID propID);

  void GetSelectedItemsIndices(CRecordVector<UInt32> &indices) const;
  void GetOperatedItemIndices(CRecordVector<UInt32> &indices) const;
  void GetAllItemIndices(CRecordVector<UInt32> &indices) const;
  void GetOperatedIndicesSmart(CRecordVector<UInt32> &indices) const;
  // void GetOperatedListViewIndices(CRecordVector<UInt32> &indices) const;
  void KillSelection();

  UString GetFolderTypeID() const;
  
  bool IsFolderTypeEqTo(const char *s) const;
  bool IsRootFolder() const;
  bool IsFSFolder() const;
  bool IsFSDrivesFolder() const;
  bool IsAltStreamsFolder() const;
  bool IsArcFolder() const;
  
  /*
    c:\Dir
    Computer\
    \\?\
    \\.\
  */
  bool Is_IO_FS_Folder() const
  {
    return IsFSFolder() || IsFSDrivesFolder() || IsAltStreamsFolder();
  }

  bool Is_Slow_Icon_Folder() const
  {
    return IsFSFolder() || IsAltStreamsFolder();
  }

  // bool IsFsOrDrivesFolder() const { return IsFSFolder() || IsFSDrivesFolder(); }
  bool IsDeviceDrivesPrefix() const { return _currentFolderPrefix == L"\\\\.\\"; }
  bool IsSuperDrivesPrefix() const { return _currentFolderPrefix == L"\\\\?\\"; }
  
  /*
    c:\Dir
    Computer\
    \\?\
  */
  bool IsFsOrPureDrivesFolder() const { return IsFSFolder() || (IsFSDrivesFolder() && !IsDeviceDrivesPrefix()); }

  /*
    c:\Dir
    Computer\
    \\?\
    \\SERVER\
  */
  bool IsFolder_with_FsItems() const
  {
    if (IsFsOrPureDrivesFolder())
      return true;
    #if defined(_WIN32) && !defined(UNDER_CE)
    FString prefix = us2fs(GetFsPath());
    return (prefix.Len() == NWindows::NFile::NName::GetNetworkServerPrefixSize(prefix));
    #else
    return false;
    #endif
  }

  UString GetFsPath() const;
  UString GetDriveOrNetworkPrefix() const;

  bool DoesItSupportOperations() const { return _folderOperations != NULL; }
  bool IsThereReadOnlyFolder() const;
  bool CheckBeforeUpdate(UINT resourceID);

  bool _processTimer;
  bool _processNotify;
  bool _processStatusBar;

  class CDisableTimerProcessing
  {
    CLASS_NO_COPY(CDisableTimerProcessing);

    bool _processTimer;

    CPanel &_panel;
    
    public:

    CDisableTimerProcessing(CPanel &panel): _panel(panel) { Disable(); }
    ~CDisableTimerProcessing() { Restore(); }
    void Disable()
    {
      _processTimer = _panel._processTimer;
      _panel._processTimer = false;
    }
    void Restore()
    {
      _panel._processTimer = _processTimer;
    }
  };

  class CDisableNotify
  {
    CLASS_NO_COPY(CDisableNotify);

    bool _processNotify;
    bool _processStatusBar;

    CPanel &_panel;

    public:

    CDisableNotify(CPanel &panel): _panel(panel) { Disable(); }
    ~CDisableNotify() { Restore(); }
    void Disable()
    {
      _processNotify = _panel._processNotify;
      _processStatusBar = _panel._processStatusBar;
      _panel._processNotify = false;
      _panel._processStatusBar = false;
    }
    void SetMemMode_Enable()
    {
      _processNotify = true;
      _processStatusBar = true;
    }
    void Restore()
    {
      _panel._processNotify = _processNotify;
      _panel._processStatusBar = _processStatusBar;
    }
  };

  // bool _passwordIsDefined;
  // UString _password;

  void InvalidateList() { _listView.InvalidateRect(NULL, true); }

  HRESULT RefreshListCtrl();

  void MessageBoxInfo(LPCWSTR message, LPCWSTR caption);
  void MessageBox(LPCWSTR message);
  void MessageBoxWarning(LPCWSTR message);
  void MessageBox(LPCWSTR message, LPCWSTR caption);
  void MessageBoxMyError(LPCWSTR message);
  void MessageBoxError(HRESULT errorCode, LPCWSTR caption);
  void MessageBoxError(HRESULT errorCode);
  void MessageBoxError2Lines(LPCWSTR message, HRESULT errorCode);
  void MessageBoxLastError(LPCWSTR caption);
  void MessageBoxLastError();

  // void MessageBoxErrorForUpdate(HRESULT errorCode, UINT resourceID);

  void MessageBoxErrorLang(UINT resourceID);

  void OpenAltStreams();

  void OpenFocusedItemAsInternal(const wchar_t *type = NULL);
  void OpenSelectedItems(bool internal);

  void OpenFolderExternal(int index);

  void OpenFolder(int index);
  HRESULT OpenParentArchiveFolder();
  HRESULT OpenItemAsArchive(IInStream *inStream,
      const CTempFileInfo &tempFileInfo,
      const UString &virtualFilePath,
      const UString &arcFormat,
      bool &encrypted);
  HRESULT OpenItemAsArchive(const UString &relPath, const UString &arcFormat, bool &encrypted);
  HRESULT OpenItemAsArchive(int index, const wchar_t *type = NULL);
  void OpenItemInArchive(int index, bool tryInternal, bool tryExternal,
      bool editMode, bool useEditor, const wchar_t *type = NULL);
  HRESULT OnOpenItemChanged(UInt32 index, const wchar_t *fullFilePath, bool usePassword, const UString &password);
  LRESULT OnOpenItemChanged(LPARAM lParam);

  bool IsVirus_Message(const UString &name);
  void OpenItem(int index, bool tryInternal, bool tryExternal, const wchar_t *type = NULL);
  void EditItem(bool useEditor);
  void EditItem(int index, bool useEditor);

  void RenameFile();
  void ChangeComment();

  void SetListViewMode(UInt32 index);
  UInt32 GetListViewMode() const { return _ListViewMode; }
  PROPID GetSortID() const { return _sortID; }

  void ChangeFlatMode();
  void Change_ShowNtfsStrems_Mode();
  bool GetFlatMode() const { return _flatMode; }
  // bool Get_ShowNtfsStrems_Mode() const { return _showNtfsStrems_Mode; }

  bool AutoRefresh_Mode;
  void Set_AutoRefresh_Mode(bool mode)
  {
    AutoRefresh_Mode = mode;
  }
  
  void Post_Refresh_StatusBar();
  void Refresh_StatusBar();

  void AddToArchive();

  void GetFilePaths(const CRecordVector<UInt32> &indices, UStringVector &paths, bool allowFolders = false);
  void ExtractArchives();
  void TestArchives();

  HRESULT CopyTo(CCopyToOptions &options,
      const CRecordVector<UInt32> &indices,
      UStringVector *messages,
      bool &usePassword, UString &password);

  HRESULT CopyTo(CCopyToOptions &options, const CRecordVector<UInt32> &indices, UStringVector *messages)
  {
    bool usePassword = false;
    UString password;
    if (_parentFolders.Size() > 0)
    {
      const CFolderLink &fl = _parentFolders.Back();
      usePassword = fl.UsePassword;
      password = fl.Password;
    }
    return CopyTo(options, indices, messages, usePassword, password);
  }

  HRESULT CopyFrom(bool moveMode, const UString &folderPrefix, const UStringVector &filePaths,
      bool showErrorMessages, UStringVector *messages);

  void CopyFromNoAsk(const UStringVector &filePaths);
  void CopyFromAsk(const UStringVector &filePaths);

#ifdef _WIN32
  // empty folderPath means create new Archive to path of first fileName.
  void DropObject(IDataObject * dataObject, const UString &folderPath);

  // empty folderPath means create new Archive to path of first fileName.
  void CompressDropFiles(const UStringVector &fileNames, const UString &folderPath);
#endif

  void RefreshTitle(bool always = false) { _panelCallback->RefreshTitle(always);  }
  void RefreshTitleAlways() { RefreshTitle(true);  }

  UString GetItemsInfoString(const CRecordVector<UInt32> &indices);
};

class CMyBuffer
{
  void *_data;
public:
  CMyBuffer(): _data(0) {}
  operator void *() { return _data; }
  bool Allocate(size_t size)
  {
    if (_data != 0)
      return false;
    _data = ::MidAlloc(size);
    return _data != 0;
  }
  ~CMyBuffer() { ::MidFree(_data); }
};

#endif
/// PanelCopy.cpp

#include "StdAfx.h"

#include "../../../Common/MyException.h"

#include "../GUI/HashGUI.h"

#include "ExtractCallback.h"
#include "LangUtils.h"
#include "Panel.h"
#include "resource.h"
#include "UpdateCallback100.h"

using namespace NWindows;

class CPanelCopyThread: public CProgressThreadVirt
{
  HRESULT ProcessVirt();
public:
  const CCopyToOptions *options;
  CMyComPtr<IFolderOperations> FolderOperations;
  CRecordVector<UInt32> Indices;
  CExtractCallbackImp *ExtractCallbackSpec;
  CMyComPtr<IFolderOperationsExtractCallback> ExtractCallback;
  
  CHashBundle Hash;
  UString FirstFilePath;

  HRESULT Result;
  

  CPanelCopyThread(): Result(E_FAIL) {}
};
  
HRESULT CPanelCopyThread::ProcessVirt()
{
  /*
  CMyComPtr<IFolderSetReplaceAltStreamCharsMode> iReplace;
  FolderOperations.QueryInterface(IID_IFolderSetReplaceAltStreamCharsMode, &iReplace);
  if (iReplace)
  {
    RINOK(iReplace->SetReplaceAltStreamCharsMode(ReplaceAltStreamChars ? 1 : 0));
  }
  */

  if (options->testMode)
  {
    CMyComPtr<IArchiveFolder> archiveFolder;
    FolderOperations.QueryInterface(IID_IArchiveFolder, &archiveFolder);
    if (!archiveFolder)
      return E_NOTIMPL;
    CMyComPtr<IFolderArchiveExtractCallback> extractCallback2;
    RINOK(ExtractCallback.QueryInterface(IID_IFolderArchiveExtractCallback, &extractCallback2));
    NExtract::NPathMode::EEnum pathMode =
        NExtract::NPathMode::kCurPaths;
        // NExtract::NPathMode::kFullPathnames;
    Result = archiveFolder->Extract(&Indices.Front(), Indices.Size(),
        BoolToInt(options->includeAltStreams),
        BoolToInt(options->replaceAltStreamChars),
        pathMode, NExtract::NOverwriteMode::kAsk,
        options->folder, BoolToInt(true), extractCallback2);
  }
  else
    Result = FolderOperations->CopyTo(
      BoolToInt(options->moveMode),
      &Indices.Front(), Indices.Size(),
      BoolToInt(options->includeAltStreams),
      BoolToInt(options->replaceAltStreamChars),
      options->folder, ExtractCallback);

  if (Result == S_OK && !ExtractCallbackSpec->ThereAreMessageErrors &&
      (!options->hashMethods.IsEmpty() || options->testMode))
  {
    CProgressMessageBoxPair &pair = GetMessagePair(false); // GetMessagePair(ExtractCallbackSpec->Hash.NumErrors != 0);
    AddHashBundleRes(pair.Message, Hash, FirstFilePath);
  }

  return Result;
}


/*
#ifdef EXTERNAL_CODECS

static void ThrowException_if_Error(HRESULT res)
{
  if (res != S_OK)
    throw CSystemException(res);
}

#endif
*/


HRESULT CPanel::CopyTo(CCopyToOptions &options, const CRecordVector<UInt32> &indices,
    UStringVector *messages,
    bool &usePassword, UString &password)
{
  if (!_folderOperations)
  {
    UString errorMessage = LangString(IDS_OPERATION_IS_NOT_SUPPORTED);
    if (options.showErrorMessages)
      MessageBox(errorMessage);
    else if (messages != 0)
      messages->Add(errorMessage);
    return E_FAIL;
  }

  HRESULT res = S_OK;

  {
  /*
  #ifdef EXTERNAL_CODECS
  CExternalCodecs g_ExternalCodecs;
  #endif
  */
  /* extracter.Hash uses g_ExternalCodecs
     extracter must be declared after g_ExternalCodecs for correct destructor order !!! */

  CPanelCopyThread extracter;

  extracter.ExtractCallbackSpec = new CExtractCallbackImp;
  extracter.ExtractCallback = extracter.ExtractCallbackSpec;

  extracter.options = &options;
  extracter.ExtractCallbackSpec->ProgressDialog = &extracter.ProgressDialog;
  extracter.ProgressDialog.CompressingMode = false;

  extracter.ExtractCallbackSpec->StreamMode = options.streamMode;


  if (indices.Size() == 1)
    extracter.FirstFilePath = GetItemRelPath(indices[0]);

  if (options.VirtFileSystem)
  {
    extracter.ExtractCallbackSpec->VirtFileSystem = options.VirtFileSystem;
    extracter.ExtractCallbackSpec->VirtFileSystemSpec = options.VirtFileSystemSpec;
  }
  extracter.ExtractCallbackSpec->ProcessAltStreams = options.includeAltStreams;

  if (!options.hashMethods.IsEmpty())
  {
    /* this code is used when we call CRC calculation for files in side archive
       But new code uses global codecs so we don't need to call LoadGlobalCodecs again */

    /*
    #ifdef EXTERNAL_CODECS
    ThrowException_if_Error(LoadGlobalCodecs());
    #endif
    */

    extracter.Hash.SetMethods(EXTERNAL_CODECS_VARS_G options.hashMethods);
    extracter.ExtractCallbackSpec->SetHashMethods(&extracter.Hash);
  }
  else if (options.testMode)
  {
    extracter.ExtractCallbackSpec->SetHashCalc(&extracter.Hash);
  }

  extracter.Hash.Init();

  UString title;
  {
    UInt32 titleID = IDS_COPYING;
    if (options.moveMode)
      titleID = IDS_MOVING;
    else if (!options.hashMethods.IsEmpty() && options.streamMode)
    {
      titleID = IDS_CHECKSUM_CALCULATING;
      if (options.hashMethods.Size() == 1)
      {
        const UString &s = options.hashMethods[0];
        if (s != L"*")
          title = s;
      }
    }
    else if (options.testMode)
      titleID = IDS_PROGRESS_TESTING;

    if (title.IsEmpty())
      title = LangString(titleID);
  }

  UString progressWindowTitle = L"7-Zip"; // LangString(IDS_APP_TITLE);
  
  extracter.ProgressDialog.MainWindow = GetParent();
  extracter.ProgressDialog.MainTitle = progressWindowTitle;
  extracter.ProgressDialog.MainAddTitle = title + L' ';
    
  extracter.ExtractCallbackSpec->OverwriteMode = NExtract::NOverwriteMode::kAsk;
  extracter.ExtractCallbackSpec->Init();
  extracter.Indices = indices;
  extracter.FolderOperations = _folderOperations;

  extracter.ExtractCallbackSpec->PasswordIsDefined = usePassword;
  extracter.ExtractCallbackSpec->Password = password;
  
  RINOK(extracter.Create(title, GetParent()));
  
  if (messages != 0)
    *messages = extracter.ProgressDialog.Sync.Messages;
  res = extracter.Result;

  if (res == S_OK && extracter.ExtractCallbackSpec->IsOK())
  {
    usePassword = extracter.ExtractCallbackSpec->PasswordIsDefined;
    password = extracter.ExtractCallbackSpec->Password;
  }
  }
  
  RefreshTitleAlways();
  return res;
}


struct CThreadUpdate
{
  CMyComPtr<IFolderOperations> FolderOperations;
  UString FolderPrefix;
  UStringVector FileNames;
  CRecordVector<const wchar_t *> FileNamePointers;
  CProgressDialog ProgressDialog;
  CMyComPtr<IFolderArchiveUpdateCallback> UpdateCallback;
  CUpdateCallback100Imp *UpdateCallbackSpec;
  HRESULT Result;
  bool MoveMode;
  
  void Process()
  {
    try
    {
      CProgressCloser closer(ProgressDialog);
      Result = FolderOperations->CopyFrom(
        MoveMode,
        FolderPrefix,
        &FileNamePointers.Front(),
        FileNamePointers.Size(),
        UpdateCallback);
    }
    catch(...) { Result = E_FAIL; }
  }
  static THREAD_FUNC_DECL MyThreadFunction(void *param)
  {
    ((CThreadUpdate *)param)->Process();
    return 0;
  }
};

HRESULT CPanel::CopyFrom(bool moveMode, const UString &folderPrefix, const UStringVector &filePaths,
    bool showErrorMessages, UStringVector *messages)
{
  HRESULT res;
  if (!_folderOperations)
    res = E_NOINTERFACE;
  else
  {
  CThreadUpdate updater;
  updater.MoveMode = moveMode;
  updater.UpdateCallbackSpec = new CUpdateCallback100Imp;
  updater.UpdateCallback = updater.UpdateCallbackSpec;
  updater.UpdateCallbackSpec->Init();

  updater.UpdateCallbackSpec->ProgressDialog = &updater.ProgressDialog;

  UString title = LangString(IDS_COPYING);
  UString progressWindowTitle = L"7-Zip"; // LangString(IDS_APP_TITLE);

  updater.ProgressDialog.MainWindow = GetParent();
  updater.ProgressDialog.MainTitle = progressWindowTitle;
  updater.ProgressDialog.MainAddTitle = title + L' ';
  
  {
    if (!_parentFolders.IsEmpty())
    {
      const CFolderLink &fl = _parentFolders.Back();
      updater.UpdateCallbackSpec->PasswordIsDefined = fl.UsePassword;
      updater.UpdateCallbackSpec->Password = fl.Password;
    }
  }

  updater.FolderOperations = _folderOperations;
  updater.FolderPrefix = folderPrefix;
  updater.FileNames.ClearAndReserve(filePaths.Size());
  unsigned i;
  for (i = 0; i < filePaths.Size(); i++)
    updater.FileNames.AddInReserved(filePaths[i]);
  updater.FileNamePointers.ClearAndReserve(updater.FileNames.Size());
  for (i = 0; i < updater.FileNames.Size(); i++)
    updater.FileNamePointers.AddInReserved(updater.FileNames[i]);

  NWindows::CThread thread;
  RINOK(thread.Create(CThreadUpdate::MyThreadFunction, &updater));
  updater.ProgressDialog.Create(title, thread, GetParent());
  
  if (messages != 0)
    *messages = updater.ProgressDialog.Sync.Messages;

  res = updater.Result;
  }

  if (res == E_NOINTERFACE)
  {
    UString errorMessage = LangString(IDS_OPERATION_IS_NOT_SUPPORTED);
    if (showErrorMessages)
      MessageBox(errorMessage);
    else if (messages != 0)
      messages->Add(errorMessage);
    return E_ABORT;
  }

  RefreshTitleAlways();
  return res;
}

void CPanel::CopyFromNoAsk(const UStringVector &filePaths)
{
  CDisableTimerProcessing disableTimerProcessing(*this);

  CSelectedState srcSelState;
  SaveSelectedState(srcSelState);

  HRESULT result = CopyFrom(false, L"", filePaths, true, 0);

  CDisableNotify disableNotify(*this);

  if (result != S_OK)
  {
    disableNotify.Restore();
    // For Password:
    SetFocusToList();
    if (result != E_ABORT)
      MessageBoxError(result);
    return;
  }

  RefreshListCtrl(srcSelState);

  disableNotify.Restore();
  SetFocusToList();
}

void CPanel::CopyFromAsk(const UStringVector &filePaths)
{
  UString title = LangString(IDS_CONFIRM_FILE_COPY);
  UString message = LangString(IDS_WANT_TO_COPY_FILES);
  message += L"\n\'";
  message += _currentFolderPrefix;
  message += L"\' ?";
  int res = ::MessageBoxW(*(this), message, title, MB_YESNOCANCEL | MB_ICONQUESTION);
  if (res != IDYES)
    return;

  CopyFromNoAsk(filePaths);
}
// PanelCrc.cpp

#include "StdAfx.h"

#include "../../../Common/MyException.h"

#include "../../../Windows/FileFind.h"
#include "../../../Windows/FileIO.h"
#include "../../../Windows/FileName.h"

#include "../Common/LoadCodecs.h"

#include "../GUI/HashGUI.h"

#include "App.h"
#include "LangUtils.h"

#include "resource.h"

using namespace NWindows;
using namespace NFile;

#ifdef EXTERNAL_CODECS
extern CExternalCodecs g_ExternalCodecs;
HRESULT LoadGlobalCodecs();
#endif

static const UInt32 kBufSize = (1 << 15);

struct CDirEnumerator
{
  bool EnterToDirs;
  FString BasePrefix;
  FString BasePrefix_for_Open;
  FStringVector FilePaths;

  CObjectVector<NFind::CEnumerator> Enumerators;
  FStringVector Prefixes;
  unsigned Index;

  CDirEnumerator(): EnterToDirs(false), Index(0) {};

  void Init();
  DWORD GetNextFile(NFind::CFileInfo &fi, bool &filled, FString &resPath);
};

void CDirEnumerator::Init()
{
  Enumerators.Clear();
  Prefixes.Clear();
  Index = 0;
}

static DWORD GetNormalizedError()
{
  DWORD error = GetLastError();
  return (error == 0) ? E_FAIL : error;
}

DWORD CDirEnumerator::GetNextFile(NFind::CFileInfo &fi, bool &filled, FString &resPath)
{
  filled = false;
  resPath.Empty();
  
  for (;;)
  {
    #if defined(_WIN32) && !defined(UNDER_CE)
    bool isRootPrefix = (BasePrefix.IsEmpty() || (NName::IsSuperPath(BasePrefix) && BasePrefix[NName::kSuperPathPrefixSize] == 0));
    #endif

    if (Enumerators.IsEmpty())
    {
      if (Index >= FilePaths.Size())
        return S_OK;
      const FString &path = FilePaths[Index++];
      int pos = path.ReverseFind_PathSepar();
      if (pos >= 0)
        resPath.SetFrom(path, pos + 1);

      #if defined(_WIN32) && !defined(UNDER_CE)
      if (isRootPrefix && path.Len() == 2 && NName::IsDrivePath2(path))
      {
        // we use "c:" item as directory item
        fi.ClearBase();
        fi.Name = path;
        fi.SetAsDir();
        fi.Size = 0;
      }
      else
      #endif
      if (!fi.Find(BasePrefix + path))
      {
        DWORD error = GetNormalizedError();
        resPath = path;
        return error;
      }
    
      break;
    }
    
    bool found;
    
    if (Enumerators.Back().Next(fi, found))
    {
      if (found)
      {
        resPath = Prefixes.Back();
        break;
      }
    }
    else
    {
      DWORD error = GetNormalizedError();
      resPath = Prefixes.Back();
      Enumerators.DeleteBack();
      Prefixes.DeleteBack();
      return error;
    }
    
    Enumerators.DeleteBack();
    Prefixes.DeleteBack();
  }
  
  resPath += fi.Name;
  
  if (EnterToDirs && fi.IsDir())
  {
    FString s = resPath;
    s.Add_PathSepar();
    Prefixes.Add(s);
    s += FCHAR_ANY_MASK;
    Enumerators.Add(NFind::CEnumerator(BasePrefix + s));
  }
  
  filled = true;
  return S_OK;
}

class CThreadCrc: public CProgressThreadVirt
{
  HRESULT ProcessVirt();
public:
  CDirEnumerator Enumerator;
  CHashBundle Hash;

  void SetStatus(const UString &s);
  void AddErrorMessage(DWORD systemError, const FChar *name);
};

void CThreadCrc::AddErrorMessage(DWORD systemError, const FChar *name)
{
  ProgressDialog.Sync.AddError_Code_Name(systemError, fs2us(Enumerator.BasePrefix + name));
  Hash.NumErrors++;
}

void CThreadCrc::SetStatus(const UString &s2)
{
  UString s = s2;
  if (!Enumerator.BasePrefix.IsEmpty())
  {
    s.Add_Space_if_NotEmpty();
    s += fs2us(Enumerator.BasePrefix);
  }
  ProgressDialog.Sync.Set_Status(s);
}

HRESULT CThreadCrc::ProcessVirt()
{
  Hash.Init();
  
  CMyBuffer buf;
  if (!buf.Allocate(kBufSize))
    return E_OUTOFMEMORY;

  CProgressSync &sync = ProgressDialog.Sync;
  
  SetStatus(LangString(IDS_SCANNING));

  Enumerator.Init();

  FString path;
  NFind::CFileInfo fi;
  UInt64 numFiles = 0;
  UInt64 numItems = 0, numItems_Prev = 0;
  UInt64 totalSize = 0;

  for (;;)
  {
    bool filled;
    DWORD error = Enumerator.GetNextFile(fi, filled, path);
    if (error != 0)
    {
      AddErrorMessage(error, path);
      continue;
    }
    if (!filled)
      break;
    if (!fi.IsDir())
    {
      totalSize += fi.Size;
      numFiles++;
    }
    numItems++;
    bool needPrint = false;
    // if (fi.IsDir())
    {
      if (numItems - numItems_Prev >= 100)
      {
        needPrint = true;
        numItems_Prev = numItems;
      }
    }
    /*
    else if (numFiles - numFiles_Prev >= 200)
    {
      needPrint = true;
      numFiles_Prev = numFiles;
    }
    */
    if (needPrint)
    {
      RINOK(sync.ScanProgress(numFiles, totalSize, path, fi.IsDir()));
    }
  }
  RINOK(sync.ScanProgress(numFiles, totalSize, FString(), false));
  // sync.SetNumFilesTotal(numFiles);
  // sync.SetProgress(totalSize, 0);
  // SetStatus(LangString(IDS_CHECKSUM_CALCULATING));
  // sync.SetCurFilePath(L"");
  SetStatus(L"");
 
  Enumerator.Init();

  FString tempPath;
  FString firstFilePath;
  bool isFirstFile = true;
  UInt64 errorsFilesSize = 0;

  for (;;)
  {
    bool filled;
    DWORD error = Enumerator.GetNextFile(fi, filled, path);
    if (error != 0)
    {
      AddErrorMessage(error, path);
      continue;
    }
    if (!filled)
      break;
    
    error = 0;
    Hash.InitForNewFile();
    if (!fi.IsDir())
    {
      NIO::CInFile inFile;
      tempPath = Enumerator.BasePrefix_for_Open;
      tempPath += path;
      if (!inFile.Open(tempPath))
      {
        error = GetNormalizedError();
        AddErrorMessage(error, path);
        continue;
      }
      if (isFirstFile)
      {
        firstFilePath = path;
        isFirstFile = false;
      }
      sync.Set_FilePath(fs2us(path));
      sync.Set_NumFilesCur(Hash.NumFiles);
      UInt64 progress_Prev = 0;
      for (;;)
      {
        UInt32 size;
        if (!inFile.Read(buf, kBufSize, size))
        {
          error = GetNormalizedError();
          AddErrorMessage(error, path);
          UInt64 errorSize = 0;
          if (inFile.GetLength(errorSize))
            errorsFilesSize += errorSize;
          break;
        }
        if (size == 0)
          break;
        Hash.Update(buf, size);
        if (Hash.CurSize - progress_Prev >= ((UInt32)1 << 21))
        {
          RINOK(sync.Set_NumBytesCur(errorsFilesSize + Hash.FilesSize + Hash.CurSize));
          progress_Prev = Hash.CurSize;
        }
      }
    }
    if (error == 0)
      Hash.Final(fi.IsDir(), false, fs2us(path));
    RINOK(sync.Set_NumBytesCur(errorsFilesSize + Hash.FilesSize));
  }
  RINOK(sync.Set_NumBytesCur(errorsFilesSize + Hash.FilesSize));
  sync.Set_NumFilesCur(Hash.NumFiles);
  if (Hash.NumFiles != 1)
    sync.Set_FilePath(L"");
  SetStatus(L"");

  CProgressMessageBoxPair &pair = GetMessagePair(Hash.NumErrors != 0);
  AddHashBundleRes(pair.Message, Hash, fs2us(firstFilePath));
  LangString(IDS_CHECKSUM_INFORMATION, pair.Title);
  return S_OK;
}


HRESULT CApp::CalculateCrc2(const UString &methodName)
{
  unsigned srcPanelIndex = GetFocusedPanelIndex();
  CPanel &srcPanel = Panels[srcPanelIndex];

  CRecordVector<UInt32> indices;
  srcPanel.GetOperatedIndicesSmart(indices);
  if (indices.IsEmpty())
    return S_OK;

  if (!srcPanel.Is_IO_FS_Folder())
  {
    CCopyToOptions options;
    options.streamMode = true;
    options.showErrorMessages = true;
    options.hashMethods.Add(methodName);

    UStringVector messages;
    return srcPanel.CopyTo(options, indices, &messages);
  }

  #ifdef EXTERNAL_CODECS

  LoadGlobalCodecs();
    
  #endif

  {
    CThreadCrc t;
    {
      UStringVector methods;
      methods.Add(methodName);
      RINOK(t.Hash.SetMethods(EXTERNAL_CODECS_VARS_G methods));
    }
    FOR_VECTOR (i, indices)
      t.Enumerator.FilePaths.Add(us2fs(srcPanel.GetItemRelPath(indices[i])));

    UString basePrefix = srcPanel.GetFsPath();
    UString basePrefix2 = basePrefix;
    if (basePrefix2.Back() == ':')
    {
      int pos = basePrefix2.ReverseFind_PathSepar();
      if (pos >= 0)
        basePrefix2.DeleteFrom(pos + 1);
    }

    t.Enumerator.BasePrefix = us2fs(basePrefix);
    t.Enumerator.BasePrefix_for_Open = us2fs(basePrefix2);

    t.Enumerator.EnterToDirs = !GetFlatMode();
    
    t.ProgressDialog.ShowCompressionInfo = false;
    
    UString title = LangString(IDS_CHECKSUM_CALCULATING);
    
    t.ProgressDialog.MainWindow = _window;
    t.ProgressDialog.MainTitle = L"7-Zip"; // LangString(IDS_APP_TITLE);
    t.ProgressDialog.MainAddTitle = title;
    t.ProgressDialog.MainAddTitle.Add_Space();
    
    RINOK(t.Create(title, _window));
  }
  RefreshTitleAlways();
  return S_OK;
}

void CApp::CalculateCrc(const UString &methodName)
{
  HRESULT res = CalculateCrc2(methodName);
  if (res != S_OK && res != E_ABORT)
  {
    unsigned srcPanelIndex = GetFocusedPanelIndex();
    CPanel &srcPanel = Panels[srcPanelIndex];
    srcPanel.MessageBoxError(res);
  }
}
// PanelFolderChange.cpp

#include "StdAfx.h"

#include "../../../Common/StringConvert.h"
#include "../../../Common/Wildcard.h"

#include "../../../Windows/FileName.h"
#include "../../../Windows/FileDir.h"
#include "../../../Windows/PropVariant.h"

#include "../../PropID.h"

#ifdef UNDER_CE
#include "FSFolder.h"
#else
#include "FSDrives.h"
#endif
#include "LangUtils.h"
#include "ListViewDialog.h"
#include "Panel.h"
#include "RootFolder.h"
#include "ViewSettings.h"

#include "resource.h"

using namespace NWindows;
using namespace NFile;
using namespace NFind;

void CPanel::ReleaseFolder()
{
  _folder.Release();

  _folderCompare.Release();
  _folderGetItemName.Release();
  _folderRawProps.Release();
  _folderAltStreams.Release();
  _folderOperations.Release();
  
  _thereAreDeletedItems = false;
}

void CPanel::SetNewFolder(IFolderFolder *newFolder)
{
  ReleaseFolder();
  _folder = newFolder;
  if (_folder)
  {
    _folder.QueryInterface(IID_IFolderCompare, &_folderCompare);
    _folder.QueryInterface(IID_IFolderGetItemName, &_folderGetItemName);
    _folder.QueryInterface(IID_IArchiveGetRawProps, &_folderRawProps);
    _folder.QueryInterface(IID_IFolderAltStreams, &_folderAltStreams);
    _folder.QueryInterface(IID_IFolderOperations, &_folderOperations);
  }
}

void CPanel::SetToRootFolder()
{
  ReleaseFolder();
  _library.Free();
  
  CRootFolder *rootFolderSpec = new CRootFolder;
  SetNewFolder(rootFolderSpec);
  rootFolderSpec->Init();
}

HRESULT CPanel::BindToPath(const UString &fullPath, const UString &arcFormat, bool &archiveIsOpened, bool &encrypted)
{
  UString path = fullPath;
  #ifdef _WIN32
  path.Replace(L'/', WCHAR_PATH_SEPARATOR);
  #endif

  archiveIsOpened = false;
  encrypted = false;
  
  CDisableTimerProcessing disableTimerProcessing(*this);
  CDisableNotify disableNotify(*this);

  for (; !_parentFolders.IsEmpty(); CloseOneLevel())
  {
    // ---------- we try to use open archive ----------

    const CFolderLink &link = _parentFolders.Back();
    const UString &virtPath = link.VirtualPath;
    if (!path.IsPrefixedBy(virtPath))
      continue;
    UString relatPath = path.Ptr(virtPath.Len());
    if (!relatPath.IsEmpty())
    {
      if (!IS_PATH_SEPAR(relatPath[0]))
        continue;
      else
        relatPath.Delete(0);
    }
    
    UString relatPath2 = relatPath;
    if (!relatPath2.IsEmpty() && !IS_PATH_SEPAR(relatPath2.Back()))
      relatPath2.Add_PathSepar();

    for (;;)
    {
      const UString foldPath = GetFolderPath(_folder);
      if (relatPath2 == foldPath)
        break;
      if (relatPath.IsPrefixedBy(foldPath))
      {
        path = relatPath.Ptr(foldPath.Len());
        break;
      }
      CMyComPtr<IFolderFolder> newFolder;
      if (_folder->BindToParentFolder(&newFolder) != S_OK)
        throw 20140918;
      if (!newFolder) // we exit from loop above if (relatPath.IsPrefixedBy(empty path for root folder)
        throw 20140918;
      SetNewFolder(newFolder);
    }
    break;
  }

  if (_parentFolders.IsEmpty())
  {
    // ---------- we open file or folder from file system ----------

    CloseOpenFolders();
    UString sysPath = path;
    
    unsigned prefixSize = NName::GetRootPrefixSize(sysPath);
    if (prefixSize == 0 || sysPath[prefixSize] == 0)
      sysPath.Empty();
    
    #if defined(_WIN32) && !defined(UNDER_CE)
    if (!sysPath.IsEmpty() && sysPath.Back() == ':' &&
      (sysPath.Len() != 2 || !NName::IsDrivePath2(sysPath)))
    {
      UString baseFile = sysPath;
      baseFile.DeleteBack();
      if (NFind::DoesFileOrDirExist(us2fs(baseFile)))
        sysPath.Empty();
    }
    #endif
    
    CFileInfo fileInfo;
    
    while (!sysPath.IsEmpty())
    {
      if (fileInfo.Find(us2fs(sysPath)))
        break;
      int pos = sysPath.ReverseFind_PathSepar();
      if (pos < 0)
        sysPath.Empty();
      else
      {
        /*
        if (reducedParts.Size() > 0 || pos < (int)sysPath.Len() - 1)
          reducedParts.Add(sysPath.Ptr(pos + 1));
        */
        #if defined(_WIN32) && !defined(UNDER_CE)
        if (pos == 2 && NName::IsDrivePath2(sysPath) && sysPath.Len() > 3)
          pos++;
        #endif

        sysPath.DeleteFrom(pos);
      }
    }
    
    SetToRootFolder();

    CMyComPtr<IFolderFolder> newFolder;
  
    if (sysPath.IsEmpty())
    {
      _folder->BindToFolder(path, &newFolder);
    }
    else if (fileInfo.IsDir())
    {
      NName::NormalizeDirPathPrefix(sysPath);
      _folder->BindToFolder(sysPath, &newFolder);
    }
    else
    {
      FString dirPrefix, fileName;
      NDir::GetFullPathAndSplit(us2fs(sysPath), dirPrefix, fileName);
      HRESULT res;
      // = OpenItemAsArchive(fs2us(fileName), arcFormat, encrypted);
      {
        CTempFileInfo tfi;
        tfi.RelPath = fs2us(fileName);
        tfi.FolderPath = dirPrefix;
        tfi.FilePath = us2fs(sysPath);
        res = OpenItemAsArchive(NULL, tfi, sysPath, arcFormat, encrypted);
      }
      
      if (res == S_FALSE)
        _folder->BindToFolder(fs2us(dirPrefix), &newFolder);
      else
      {
        RINOK(res);
        archiveIsOpened = true;
        _parentFolders.Back().ParentFolderPath = fs2us(dirPrefix);
        path.DeleteFrontal(sysPath.Len());
        if (!path.IsEmpty() && IS_PATH_SEPAR(path[0]))
          path.Delete(0);
      }
    }
    if (newFolder)
    {
      SetNewFolder(newFolder);
      // LoadFullPath();
      return S_OK;
    }
  }
  
  {
    // ---------- we open folder remPath in archive and sub archives ----------

    for (unsigned curPos = 0; curPos != path.Len();)
    {
      UString s = path.Ptr(curPos);
      int slashPos = NName::FindSepar(s);
      unsigned skipLen = s.Len();
      if (slashPos >= 0)
      {
        s.DeleteFrom(slashPos);
        skipLen = slashPos + 1;
      }

      CMyComPtr<IFolderFolder> newFolder;
      _folder->BindToFolder(s, &newFolder);
      if (newFolder)
        curPos += skipLen;
      else if (_folderAltStreams)
      {
        int pos = s.Find(L':');
        if (pos >= 0)
        {
          UString baseName = s;
          baseName.DeleteFrom(pos);
          if (_folderAltStreams->BindToAltStreams(baseName, &newFolder) == S_OK && newFolder)
            curPos += pos + 1;
        }
      }
      
      if (!newFolder)
        break;

      SetNewFolder(newFolder);
    }
  }

  return S_OK;
}

HRESULT CPanel::BindToPathAndRefresh(const UString &path)
{
  CDisableTimerProcessing disableTimerProcessing(*this);
  CDisableNotify disableNotify(*this);
  bool archiveIsOpened, encrypted;
  RINOK(BindToPath(path, UString(), archiveIsOpened, encrypted));
  RefreshListCtrl(UString(), -1, true, UStringVector());
  return S_OK;
}

void CPanel::SetBookmark(int index)
{
  _appState->FastFolders.SetString(index, _currentFolderPrefix);
}

void CPanel::OpenBookmark(int index)
{
  BindToPathAndRefresh(_appState->FastFolders.GetString(index));
}

UString GetFolderPath(IFolderFolder *folder)
{
  {
    NCOM::CPropVariant prop;
    if (folder->GetFolderProperty(kpidPath, &prop) == S_OK)
      if (prop.vt == VT_BSTR)
        return (wchar_t *)prop.bstrVal;
  }
  return UString();
}

void CPanel::LoadFullPath()
{
  _currentFolderPrefix.Empty();
  FOR_VECTOR (i, _parentFolders)
  {
    const CFolderLink &folderLink = _parentFolders[i];
    _currentFolderPrefix += folderLink.ParentFolderPath;
        // GetFolderPath(folderLink.ParentFolder);
    _currentFolderPrefix += folderLink.RelPath;
    _currentFolderPrefix.Add_PathSepar();
  }
  if (_folder)
    _currentFolderPrefix += GetFolderPath(_folder);
}

static int GetRealIconIndex(CFSTR path, DWORD attributes)
{
  int index = -1;
  if (GetRealIconIndex(path, attributes, index) != 0)
    return index;
  return -1;
}

void CPanel::LoadFullPathAndShow()
{
  LoadFullPath();
  _appState->FolderHistory.AddString(_currentFolderPrefix);

#ifdef _WIN32
  _headerComboBox.SetText(_currentFolderPrefix);
#else
  {
    extern const TCHAR * nameWindowToUnix(const TCHAR * lpFileName);
	UString tmp = nameWindowToUnix(_currentFolderPrefix);
	_headerComboBox.SetText(tmp);
  }	
#endif

#ifdef _WIN32 // FIXME
  #ifndef UNDER_CE

  COMBOBOXEXITEM item;
  item.mask = 0;

  UString path = _currentFolderPrefix;
  if (path.Len() >
      #ifdef _WIN32
      3
      #else
      1
      #endif
      && path.Back() == WCHAR_PATH_SEPARATOR)
    path.DeleteBack();

  DWORD attrib = FILE_ATTRIBUTE_DIRECTORY;

  // GetRealIconIndex is slow for direct DVD/UDF path. So we use dummy path
  if (path.IsPrefixedBy(L"\\\\.\\"))
    path = L"_TestFolder_";
  else
  {
    CFileInfo fi;
    if (fi.Find(us2fs(path)))
      attrib = fi.Attrib;
  }
  item.iImage = GetRealIconIndex(us2fs(path), attrib);

  if (item.iImage >= 0)
  {
    item.iSelectedImage = item.iImage;
    item.mask |= (CBEIF_IMAGE | CBEIF_SELECTEDIMAGE);
  }
  item.iItem = -1;
  _headerComboBox.SetItem(&item);
  
  #endif
#endif

  RefreshTitle();
}

#ifndef UNDER_CE
LRESULT CPanel::OnNotifyComboBoxEnter(const UString &s)
{
  if (BindToPathAndRefresh(GetUnicodeString(s)) == S_OK)
  {
    // FIXME PostMsg(kSetFocusToListView);
    return TRUE;
  }
  return FALSE;
}

bool CPanel::OnNotifyComboBoxEndEdit(PNMCBEENDEDITW info, LRESULT &result)
{
  if (info->iWhy == CBENF_ESCAPE)
  {
    _headerComboBox.SetText(_currentFolderPrefix);
    // FIXME PostMsg(kSetFocusToListView);
    result = FALSE;
    return true;
  }

  /*
  if (info->iWhy == CBENF_DROPDOWN)
  {
    result = FALSE;
    return true;
  }
  */

  if (info->iWhy == CBENF_RETURN)
  {
    // When we use Edit control and press Enter.
    UString s;
    _headerComboBox.GetText(s);
    result = OnNotifyComboBoxEnter(s);
    return true;
  }
  return false;
}
#endif

#ifndef _UNICODE
bool CPanel::OnNotifyComboBoxEndEdit(PNMCBEENDEDIT info, LRESULT &result)
{
  if (info->iWhy == CBENF_ESCAPE)
  {
    _headerComboBox.SetText(_currentFolderPrefix);
    PostMsg(kSetFocusToListView);
    result = FALSE;
    return true;
  }
  /*
  if (info->iWhy == CBENF_DROPDOWN)
  {
    result = FALSE;
    return true;
  }
  */

  if (info->iWhy == CBENF_RETURN)
  {
    UString s;
    _headerComboBox.GetText(s);
    // GetUnicodeString(info->szText)
    result = OnNotifyComboBoxEnter(s);
    return true;
  }
  return false;
}
#endif

void CPanel::AddComboBoxItem(const UString &name, int iconIndex, int indent, bool addToList)
{
  #if 1 // ifdef UNDER_CE

  UString s;
  iconIndex = iconIndex;
  for (int i = 0; i < indent; i++)
    s += L"  ";
  _headerComboBox.AddString(s + name);
  
  #else
  
  COMBOBOXEXITEMW item;
  item.mask = CBEIF_TEXT | CBEIF_INDENT;
  item.iSelectedImage = item.iImage = iconIndex;
  if (iconIndex >= 0)
    item.mask |= (CBEIF_IMAGE | CBEIF_SELECTEDIMAGE);
  item.iItem = -1;
  item.iIndent = indent;
  item.pszText = (LPWSTR)(LPCWSTR)name;
  _headerComboBox.InsertItem(&item);
  
  #endif

  if (addToList)
    ComboBoxPaths.Add(name);
}

extern UString RootFolder_GetName_Computer(int &iconIndex);
extern UString RootFolder_GetName_Network(int &iconIndex);
extern UString RootFolder_GetName_Documents(int &iconIndex);

bool CPanel::OnComboBoxCommand(UINT code, LPARAM /* param */, LRESULT &result)
{
#ifdef _WIN32 // FIXME
  result = FALSE;
  switch (code)
  {
    case CBN_DROPDOWN:
    {
      ComboBoxPaths.Clear();
      _headerComboBox.ResetContent();
      
      unsigned i;
      UStringVector pathParts;
      
      SplitPathToParts(_currentFolderPrefix, pathParts);
      UString sumPass;
      if (!pathParts.IsEmpty())
        pathParts.DeleteBack();
      for (i = 0; i < pathParts.Size(); i++)
      {
        UString name = pathParts[i];
        sumPass += name;
        sumPass.Add_PathSepar();
        CFileInfo info;
        DWORD attrib = FILE_ATTRIBUTE_DIRECTORY;
        if (info.Find(us2fs(sumPass)))
          attrib = info.Attrib;
        AddComboBoxItem(name.IsEmpty() ? L"\\" : name, GetRealIconIndex(us2fs(sumPass), attrib), i, false);
        ComboBoxPaths.Add(sumPass);
      }

      #ifndef UNDER_CE

      int iconIndex;
      UString name;
      name = RootFolder_GetName_Documents(iconIndex);
      AddComboBoxItem(name, iconIndex, 0, true);

      name = RootFolder_GetName_Computer(iconIndex);
      AddComboBoxItem(name, iconIndex, 0, true);
        
      FStringVector driveStrings;
      MyGetLogicalDriveStrings(driveStrings);
      for (i = 0; i < driveStrings.Size(); i++)
      {
        FString s = driveStrings[i];
        ComboBoxPaths.Add(fs2us(s));
        int iconIndex = GetRealIconIndex(s, 0);
        if (s.Len() > 0 && s.Back() == FCHAR_PATH_SEPARATOR)
          s.DeleteBack();
        AddComboBoxItem(fs2us(s), iconIndex, 1, false);
      }

      name = RootFolder_GetName_Network(iconIndex);
      AddComboBoxItem(name, iconIndex, 0, true);

      #endif
    
      return false;
    }

    case CBN_SELENDOK:
    {
      code = code;
      int index = _headerComboBox.GetCurSel();
      if (index >= 0)
      {
        UString pass = ComboBoxPaths[index];
        _headerComboBox.SetCurSel(-1);
        // _headerComboBox.SetText(pass); // it's fix for seclecting by mouse.
        if (BindToPathAndRefresh(pass) == S_OK)
        {
          PostMsg(kSetFocusToListView);
          #ifdef UNDER_CE
          PostMsg(kRefresh_HeaderComboBox);
          #endif
          return true;
        }
      }
      return false;
    }
    /*
    case CBN_CLOSEUP:
    {
      LoadFullPathAndShow();
      true;

    }
    case CBN_SELCHANGE:
    {
      // LoadFullPathAndShow();
      return true;
    }
    */
  }
#endif
  return false;
}

bool CPanel::OnNotifyComboBox(LPNMHDR NON_CE_VAR(header), LRESULT & NON_CE_VAR(result))
{
  #ifndef UNDER_CE
  switch (header->code)
  {
    case CBEN_BEGINEDIT:
    {
      _lastFocusedIsList = false;
      _panelCallback->PanelWasFocused();
      break;
    }
#ifdef _WIN32
    #ifndef _UNICODE
    case CBEN_ENDEDIT:
    {
      return OnNotifyComboBoxEndEdit((PNMCBEENDEDIT)header, result);
    }
    #endif
#endif
    case CBEN_ENDEDITW:
    {
      return OnNotifyComboBoxEndEdit((PNMCBEENDEDITW)header, result);
    }
  }
  #endif
  return false;
}


void CPanel::FoldersHistory()
{
  CListViewDialog listViewDialog;
  listViewDialog.DeleteIsAllowed = true;
  LangString(IDS_FOLDERS_HISTORY, listViewDialog.Title);
  _appState->FolderHistory.GetList(listViewDialog.Strings);
  if (listViewDialog.Create(GetParent()) != IDOK)
    return;
  UString selectString;
  if (listViewDialog.StringsWereChanged)
  {
    _appState->FolderHistory.RemoveAll();
    for (int i = listViewDialog.Strings.Size() - 1; i >= 0; i--)
      _appState->FolderHistory.AddString(listViewDialog.Strings[i]);
    if (listViewDialog.FocusedItemIndex >= 0)
      selectString = listViewDialog.Strings[listViewDialog.FocusedItemIndex];
  }
  else
  {
    if (listViewDialog.FocusedItemIndex >= 0)
      selectString = listViewDialog.Strings[listViewDialog.FocusedItemIndex];
  }
  if (listViewDialog.FocusedItemIndex >= 0)
    BindToPathAndRefresh(selectString);
}

void CPanel::OpenParentFolder()
{
  LoadFullPath(); // Maybe we don't need it ??
  
  UString parentFolderPrefix;
  UString focusedName;
  
  if (!_currentFolderPrefix.IsEmpty())
  {
    wchar_t c = _currentFolderPrefix.Back();
    if (c == WCHAR_PATH_SEPARATOR || c == ':')
    {
      focusedName = _currentFolderPrefix;
      focusedName.DeleteBack();
      /*
      if (c == ':' && !focusedName.IsEmpty() && focusedName.Back() == WCHAR_PATH_SEPARATOR)
      {
        focusedName.DeleteBack();
      }
      else
      */
      if (focusedName != L"\\\\." &&
          focusedName != L"\\\\?")
      {
        int pos = focusedName.ReverseFind_PathSepar();
        if (pos >= 0)
        {
          parentFolderPrefix = focusedName;
          parentFolderPrefix.DeleteFrom(pos + 1);
          focusedName.DeleteFrontal(pos + 1);
        }
      }
    }
  }

  CDisableTimerProcessing disableTimerProcessing(*this);
  CDisableNotify disableNotify(*this);
  
  CMyComPtr<IFolderFolder> newFolder;
  _folder->BindToParentFolder(&newFolder);

  // newFolder.Release(); // for test
  
  if (newFolder)
    SetNewFolder(newFolder);
  else
  {
    bool needSetFolder = true;
    if (!_parentFolders.IsEmpty())
    {
      {
        const CFolderLink &link = _parentFolders.Back();
        parentFolderPrefix = link.ParentFolderPath;
        focusedName = link.RelPath;
      }
      CloseOneLevel();
      needSetFolder = (!_folder);
    }
    
    if (needSetFolder)
    {
      {
        bool archiveIsOpened;
        bool encrypted;
        BindToPath(parentFolderPrefix, UString(), archiveIsOpened, encrypted);
      }
    }
  }
    
  UStringVector selectedItems;
  /*
  if (!focusedName.IsEmpty())
    selectedItems.Add(focusedName);
  */
  LoadFullPath();
  // ::SetCurrentDirectory(::_currentFolderPrefix);
  RefreshListCtrl(focusedName, -1, true, selectedItems);
  // _listView.EnsureVisible(_listView.GetFocusedItem(), false);
}

void CPanel::CloseOneLevel()
{
  ReleaseFolder();
  _library.Free();
  {
    CFolderLink &link = _parentFolders.Back();
    if (link.ParentFolder)
      SetNewFolder(link.ParentFolder);
    _library.Attach(link.Library.Detach());
  }
  if (_parentFolders.Size() > 1)
    OpenParentArchiveFolder();
  _parentFolders.DeleteBack();
  if (_parentFolders.IsEmpty())
    _flatMode = _flatModeForDisk;
}

void CPanel::CloseOpenFolders()
{
  while (!_parentFolders.IsEmpty())
    CloseOneLevel();
  _flatMode = _flatModeForDisk;
  ReleaseFolder();
  _library.Free();
}

void CPanel::OpenRootFolder()
{
  CDisableTimerProcessing disableTimerProcessing(*this);
  CDisableNotify disableNotify(*this);
  _parentFolders.Clear();
  SetToRootFolder();
  RefreshListCtrl(UString(), -1, true, UStringVector());
  // ::SetCurrentDirectory(::_currentFolderPrefix);
  /*
  BeforeChangeFolder();
  _currentFolderPrefix.Empty();
  AfterChangeFolder();
  SetCurrentPathText();
  RefreshListCtrl(UString(), 0, UStringVector());
  _listView.EnsureVisible(_listView.GetFocusedItem(), false);
  */
}

void CPanel::OpenDrivesFolder()
{
  CloseOpenFolders();
  #ifdef UNDER_CE
  NFsFolder::CFSFolder *folderSpec = new NFsFolder::CFSFolder;
  SetNewFolder(folderSpec);
  folderSpec->InitToRoot();
  #else
  CFSDrives *folderSpec = new CFSDrives;
  SetNewFolder(folderSpec);
  folderSpec->Init();
  #endif
  RefreshListCtrl();
}

void CPanel::OpenFolder(int index)
{
  if (index == kParentIndex)
  {
    OpenParentFolder();
    return;
  }
  CMyComPtr<IFolderFolder> newFolder;
  _folder->BindToFolder(index, &newFolder);
  if (!newFolder)
    return;
  SetNewFolder(newFolder);
  LoadFullPath();
  RefreshListCtrl();
  _listView.SetItemState_Selected(_listView.GetFocusedItem());
  _listView.EnsureVisible(_listView.GetFocusedItem(), false);
}

void CPanel::OpenAltStreams()
{
  CRecordVector<UInt32> indices;
  GetOperatedItemIndices(indices);
  Int32 realIndex = -1;
  if (indices.Size() > 1)
    return;
  if (indices.Size() == 1)
    realIndex = indices[0];

  if (_folderAltStreams)
  {
    CMyComPtr<IFolderFolder> newFolder;
    _folderAltStreams->BindToAltStreams(realIndex, &newFolder);
    if (newFolder)
    {
      CDisableTimerProcessing disableTimerProcessing(*this);
      CDisableNotify disableNotify(*this);
      SetNewFolder(newFolder);
      RefreshListCtrl(UString(), -1, true, UStringVector());
      return;
    }
    return;
  }
  
  #if defined(_WIN32) && !defined(UNDER_CE)
  UString path;
  if (realIndex >= 0)
    path = GetItemFullPath(realIndex);
  else
  {
    path = GetFsPath();
    if (!NName::IsDriveRootPath_SuperAllowed(us2fs(path)))
      if (!path.IsEmpty() && IS_PATH_SEPAR(path.Back()))
        path.DeleteBack();
  }

  path += L':';
  BindToPathAndRefresh(path);
  #endif
}
// PanelItemOpen.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif
#include "wx/mimetype.h"

#undef _WIN32

// #include <tlhelp32.h>

#include "../../../Common/AutoPtr.h"
#include "../../../Common/StringConvert.h"

// #include "../../../Windows/ProcessUtils.h"
#include "../../../Windows/FileName.h"
#include "../../../Windows/PropVariant.h"
#include "../../../Windows/PropVariantConv.h"

#include "../../Common/FileStreams.h"
#include "../../Common/StreamObjects.h"

#include "../Common/ExtractingFilePath.h"

#include "App.h"

#include "FileFolderPluginOpen.h"
#include "FormatUtils.h"
#include "LangUtils.h"
#include "RegistryUtils.h"
#include "UpdateCallback100.h"

#include "resource.h"

using namespace NWindows;
using namespace NSynchronization;
using namespace NFile;
using namespace NDir;

extern UInt64 g_RAM_Size;

#ifndef _UNICODE
extern bool g_IsNT;
#endif

static CFSTR kTempDirPrefix = FTEXT("7zO");

#if 0 // ifndef UNDER_CE

class CProcessSnapshot
{
  HANDLE _handle;
public:
  CProcessSnapshot(): _handle(INVALID_HANDLE_VALUE) {};
  ~CProcessSnapshot() { Close(); }

  bool Close()
  {
    if (_handle == INVALID_HANDLE_VALUE)
      return true;
    if (!::CloseHandle(_handle))
      return false;
    _handle = INVALID_HANDLE_VALUE;
    return true;
  }

  bool Create()
  {
    _handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    return (_handle != INVALID_HANDLE_VALUE);
  }

  bool GetFirstProcess(PROCESSENTRY32 *pe) { return BOOLToBool(Process32First(_handle, pe)); }
  bool GetNextProcess(PROCESSENTRY32 *pe) { return BOOLToBool(Process32Next(_handle, pe)); }
};

typedef DWORD (WINAPI *GetProcessIdFunc)(HANDLE process);

class CChildProcesses
{
  #ifndef UNDER_CE
  CRecordVector<DWORD> _ids;
  #endif
public:
  CRecordVector<HANDLE> Handles;
  CRecordVector<bool> NeedWait;

  ~CChildProcesses() { CloseAll(); }
  void DisableWait(int index) { NeedWait[index] = false; }
  
  void CloseAll()
  {
    FOR_VECTOR (i,  Handles)
    {
      HANDLE h = Handles[i];
      if (h != NULL)
        CloseHandle(h);
    }
    Handles.Clear();
    NeedWait.Clear();
  }

  void AddProcess(HANDLE h)
  {
    #ifndef UNDER_CE
    GetProcessIdFunc func = (GetProcessIdFunc)::GetProcAddress(::GetModuleHandleA("kernel32.dll"), "GetProcessId");
    if (func)
      _ids.AddToUniqueSorted(func(h));
    #endif
    Handles.Add(h);
    NeedWait.Add(true);
  }

  void Update()
  {
    #ifndef UNDER_CE
    CRecordVector<DWORD> ids, parents;
    {
      CProcessSnapshot snapshot;
      if (snapshot.Create())
      {
        PROCESSENTRY32 pe;
        memset(&pe, 0, sizeof(pe));
        pe.dwSize = sizeof(pe);
        BOOL res = snapshot.GetFirstProcess(&pe);
        while (res)
        {
          ids.Add(pe.th32ProcessID);
          parents.Add(pe.th32ParentProcessID);
          res = snapshot.GetNextProcess(&pe);
        }
      }
    }

    for (;;)
    {
      unsigned i;
      for (i = 0; i < ids.Size(); i++)
      {
        DWORD id = ids[i];
        if (_ids.FindInSorted(parents[i]) >= 0 &&
            _ids.FindInSorted(id) < 0)
        {
          HANDLE hProcess = OpenProcess(SYNCHRONIZE, FALSE, id);
          if (hProcess)
          {
            _ids.AddToUniqueSorted(id);
            Handles.Add(hProcess);
            NeedWait.Add(true);
            break;
          }
        }
      }
      if (i == ids.Size())
        break;
    }
    #endif
  }
};
#endif

struct CTmpProcessInfo: public CTempFileInfo
{
  HANDLE ProcessHandle; // CChildProcesses Processes;
  HWND Window;
  UString FullPathFolderPrefix;
  bool UsePassword;
  UString Password;

  CTmpProcessInfo(): UsePassword(false) {}
};

class CTmpProcessInfoRelease
{
  CTmpProcessInfo *_tmpProcessInfo;
public:
  bool _needDelete;
  CTmpProcessInfoRelease(CTmpProcessInfo &tpi):
      _tmpProcessInfo(&tpi), _needDelete(true) {}
  ~CTmpProcessInfoRelease()
  {
    if (_needDelete)
      _tmpProcessInfo->DeleteDirAndFile();
  }
};

HRESULT CPanel::OpenItemAsArchive(IInStream *inStream,
    const CTempFileInfo &tempFileInfo,
    const UString &virtualFilePath,
    const UString &arcFormat,
    bool &encrypted)
{
  encrypted = false;
  CFolderLink folderLink;
  (CTempFileInfo &)folderLink = tempFileInfo;
  if (inStream)
    folderLink.IsVirtual = true;
  else
  {
    if (!folderLink.FileInfo.Find(folderLink.FilePath))
      return ::GetLastError();
    if (folderLink.FileInfo.IsDir())
      return S_FALSE;
    folderLink.IsVirtual = false;
  }

  folderLink.VirtualPath = virtualFilePath;

  CMyComPtr<IFolderFolder> newFolder;

  // _passwordIsDefined = false;
  // _password.Empty();

  NDLL::CLibrary library;

  UString password;
  RINOK(OpenFileFolderPlugin(inStream,
      folderLink.FilePath.IsEmpty() ? us2fs(virtualFilePath) : folderLink.FilePath,
      arcFormat,
      &library, &newFolder, GetParent(), encrypted, password));
 
  folderLink.Password = password;
  folderLink.UsePassword = encrypted;

  if (_folder)
    folderLink.ParentFolderPath = GetFolderPath(_folder);
  else
    folderLink.ParentFolderPath = _currentFolderPrefix;
  if (!_parentFolders.IsEmpty())
    folderLink.ParentFolder = _folder;

  _parentFolders.Add(folderLink);
  _parentFolders.Back().Library.Attach(_library.Detach());

  ReleaseFolder();
  _library.Free();
  SetNewFolder(newFolder);
  _library.Attach(library.Detach());

  _flatMode = _flatModeForArc;

  CMyComPtr<IGetFolderArcProps> getFolderArcProps;
  _folder.QueryInterface(IID_IGetFolderArcProps, &getFolderArcProps);
  _thereAreDeletedItems = false;
  if (getFolderArcProps)
  {
    CMyComPtr<IFolderArcProps> arcProps;
    getFolderArcProps->GetFolderArcProps(&arcProps);
    if (arcProps)
    {
      /*
      UString s;
      UInt32 numLevels;
      if (arcProps->GetArcNumLevels(&numLevels) != S_OK)
        numLevels = 0;
      for (UInt32 level2 = 0; level2 <= numLevels; level2++)
      {
        UInt32 level = numLevels - level2;
        PROPID propIDs[] = { kpidError, kpidPath, kpidType, kpidErrorType } ;
        UString values[4];
        for (Int32 i = 0; i < 4; i++)
        {
          CMyComBSTR name;
          NCOM::CPropVariant prop;
          if (arcProps->GetArcProp(level, propIDs[i], &prop) != S_OK)
            continue;
          if (prop.vt != VT_EMPTY)
            values[i] = (prop.vt == VT_BSTR) ? prop.bstrVal : L"?";
        }
        UString s2;
        if (!values[3].IsEmpty())
        {
          s2 = L"Can not open the file as [" + values[3] + L"] archive";
          if (level2 != 0)
            s2 += L"\nThe file is open as [" + values[2] + L"] archive";
        }
        if (!values[0].IsEmpty())
        {
          if (!s2.IsEmpty())
            s2.Add_LF();
          s2 += L"[";
          s2 += values[2];
          s2 += L"] Error: ";
          s2 += values[0];
        }
        if (!s2.IsEmpty())
        {
          if (!s.IsEmpty())
            s += L"--------------------\n";
          s += values[1];
          s.Add_LF();
          s += s2;
        }
      }
      */
      /*
      if (!s.IsEmpty())
        MessageBoxWarning(s);
      else
      */
      // after MessageBoxWarning it throws exception in nested archives in Debug Mode. why ?.
        // MessageBoxWarning(L"test error");
    }
  }

  return S_OK;
}

HRESULT CPanel::OpenItemAsArchive(const UString &relPath, const UString &arcFormat, bool &encrypted)
{
  CTempFileInfo tfi;
  tfi.RelPath = relPath;
  tfi.FolderPath = us2fs(GetFsPath());
  const UString fullPath = GetFsPath() + relPath;
  tfi.FilePath = us2fs(fullPath);
  return OpenItemAsArchive(NULL, tfi, fullPath, arcFormat, encrypted);
}

HRESULT CPanel::OpenItemAsArchive(int index, const wchar_t *type)
{
  CDisableTimerProcessing disableTimerProcessing1(*this);
  CDisableNotify disableNotify(*this);
  bool encrypted;
  HRESULT res = OpenItemAsArchive(GetItemRelPath2(index), type ? type : L"", encrypted);
  if (res != S_OK)
  {
    RefreshTitle(true); // in case of error we must refresh changed title of 7zFM
    return res;
  }
  RefreshListCtrl();
  return S_OK;
}

HRESULT CPanel::OpenParentArchiveFolder()
{
  CDisableTimerProcessing disableTimerProcessing(*this);
  CDisableNotify disableNotify(*this);
  if (_parentFolders.Size() < 2)
    return S_OK;
  const CFolderLink &folderLinkPrev = _parentFolders[_parentFolders.Size() - 2];
  const CFolderLink &folderLink = _parentFolders.Back();
  NFind::CFileInfo newFileInfo;
  if (newFileInfo.Find(folderLink.FilePath))
  {
    if (folderLink.WasChanged(newFileInfo))
    {
      UString message = MyFormatNew(IDS_WANT_UPDATE_MODIFIED_FILE, folderLink.RelPath);
      if (::MessageBoxW((HWND)*this, message, L"7-Zip", MB_OKCANCEL | MB_ICONQUESTION) == IDOK)
      {
        if (OnOpenItemChanged(folderLink.FileIndex, fs2us(folderLink.FilePath),
            folderLinkPrev.UsePassword, folderLinkPrev.Password) != S_OK)
        {
          ::MessageBoxW((HWND)*this, MyFormatNew(IDS_CANNOT_UPDATE_FILE,
              fs2us(folderLink.FilePath)), L"7-Zip", MB_OK | MB_ICONSTOP);
          return S_OK;
        }
      }
    }
  }
  folderLink.DeleteDirAndFile();
  return S_OK;
}

static const char *kStartExtensions =
  #ifdef UNDER_CE
  " cab"
  #endif
  " exe bat com"
  " chm"
  " msi doc xls ppt pps wps wpt wks xlr wdb vsd pub"

  " docx docm dotx dotm xlsx xlsm xltx xltm xlsb xps"
  " xlam pptx pptm potx potm ppam ppsx ppsm xsn"
  " mpp"
  " msg"
  " dwf"

  " flv swf"
  
  " odt ods"
  " wb3"
  " pdf"
  " ";

static bool FindExt(const char *p, const UString &name)
{
  int dotPos = name.ReverseFind_Dot();
  if (dotPos < 0 || dotPos == (int)name.Len() - 1)
    return false;

  AString s;
  for (unsigned pos = dotPos + 1;; pos++)
  {
    wchar_t c = name[pos];
    if (c == 0)
      break;
    if (c >= 0x80)
      return false;
    s += (char)MyCharLower_Ascii((char)c);
  }
  for (unsigned i = 0; p[i] != 0;)
  {
    unsigned j;
    for (j = i; p[j] != ' '; j++);
    if (s.Len() == j - i && memcmp(p + i, (const char *)s, s.Len()) == 0)
      return true;
    i = j + 1;
  }
  return false;
}

static bool DoItemAlwaysStart(const UString &name)
{
  return FindExt(kStartExtensions, name);
}

UString GetQuotedString(const UString &s);

static void StartEditApplication(const UString &path, bool useEditor, HWND window /* , CProcess &process */ )
{
  UString command;
  ReadRegEditor(useEditor, command);
  if (command.IsEmpty())
  {
#ifdef _WIN32
    #ifdef UNDER_CE
    command = L"\\Windows\\";
    #else
    FString winDir;
    if (!GetWindowsDir(winDir))
      return 0;
    NName::NormalizeDirPathPrefix(winDir);
    command = fs2us(winDir);
    #endif
    command += L"notepad.exe";
#else
    command += L"vi";
#endif
  }

#ifdef _WIN32
  HRESULT res = process.Create(command, GetQuotedString(path), NULL);
  if (res != SZ_OK)
    ::MessageBoxW(window, LangString(IDS_CANNOT_START_EDITOR), L"7-Zip", MB_OK  | MB_ICONSTOP);
  return res;
#else
  wxString cmd = (const wchar_t *)command;
  long pid = wxExecute(cmd, wxEXEC_ASYNC);
  if (pid) return ;
  ::MessageBoxW(window, LangString(IDS_CANNOT_START_EDITOR), L"7-Zip", MB_OK  | MB_ICONSTOP);
#endif
}

void CApp::DiffFiles()
{
  const CPanel &panel = GetFocusedPanel();
  
  CRecordVector<UInt32> indices;
  panel.GetSelectedItemsIndices(indices);

  UString path1, path2;
  if (indices.Size() == 2)
  {
    path1 = panel.GetItemFullPath(indices[0]);
    path2 = panel.GetItemFullPath(indices[1]);
  }
  else if (indices.Size() == 1 && NumPanels >= 2)
  {
    const CPanel &destPanel = Panels[1 - LastFocusedPanel];
    path1 = panel.GetItemFullPath(indices[0]);
    CRecordVector<UInt32> indices2;
    destPanel.GetSelectedItemsIndices(indices2);
    if (indices2.Size() == 1)
      path2 = destPanel.GetItemFullPath(indices2[0]);
    else
    {
      UString relPath = panel.GetItemRelPath2(indices[0]);
      if (panel._flatMode && !destPanel._flatMode)
        relPath = panel.GetItemName(indices[0]);
      path2 = destPanel._currentFolderPrefix + relPath;
    }
  }
  else
    return;

  UString command;
  ReadRegDiff(command);
  if (command.IsEmpty())
    return;

  UString param = GetQuotedString(path1);
  param.Add_Space();
  param += GetQuotedString(path2);

#ifdef _WIN32
  HRESULT res = MyCreateProcess(command, param);
  if (res == SZ_OK)
    return;
#else
  wxString cmd = (const wchar_t *)command;
  cmd += L" ";
  cmd += (const wchar_t *)param;

  long pid = wxExecute(cmd, wxEXEC_ASYNC);
  if (pid) return ;
#endif
  ::MessageBoxW(_window, LangString(IDS_CANNOT_START_EDITOR), L"7-Zip", MB_OK  | MB_ICONSTOP);
}

#ifndef _UNICODE
typedef BOOL (WINAPI * ShellExecuteExWP)(LPSHELLEXECUTEINFOW lpExecInfo);
#endif

static void StartApplication(const UString &dir, const UString &path, HWND window /* , CProcess &process */ )
{
  // FIXME
  extern const TCHAR * nameWindowToUnix(const TCHAR * lpFileName);
  UString tmpPath = path;

  wxString filename(nameWindowToUnix(tmpPath));


  wxString ext = filename.AfterLast(_T('.'));

  printf("StartApplication(%ls) ext='%ls'\n",(const wchar_t *)filename,(const wchar_t *)ext);

  if ( ! ext.empty() )
  {
    wxFileType *ft = wxTheMimeTypesManager->GetFileTypeFromExtension(ext);
    // printf("StartApplication(%ls) ft=%p\n",(const wchar_t *)filename,ft);
    if (ft)
    {
      wxString cmd;
      // wxString type; ft->GetMimeType(&type);
      wxFileType::MessageParameters params(filename); // , type);
      bool ok = ft->GetOpenCommand(&cmd, params);
      // printf("StartApplication(%ls) ok=%d\n",(const wchar_t *)filename,(int)ok);
      delete ft;
      if ( ok )
      {
        printf("StartApplication(%ls) cmd='%ls'\n",(const wchar_t *)filename,(const wchar_t *)cmd);
        long pid = wxExecute(cmd, wxEXEC_ASYNC);
        if (pid) return ;
      }
    }	   
  }
  ::MessageBoxW(window, 
          // NError::MyFormatMessageW(::GetLastError()),
          L"There is no application associated with the given file name extension",
          L"7-Zip", MB_OK | MB_ICONSTOP);

}

static void StartApplicationDontWait(const UString &dir, const UString &path, HWND window)
{
   // CProcess process;
  StartApplication(dir, path, window /* , process */ );
}

void CPanel::EditItem(int index, bool useEditor)
{
  if (!_parentFolders.IsEmpty())
  {
    OpenItemInArchive(index, false, true, true, useEditor);
    return;
  }
   // CProcess process;
  StartEditApplication(GetItemFullPath(index), useEditor, (HWND)*this /* , process */ );
}

void CPanel::OpenFolderExternal(int index)
{
  UString fsPrefix = GetFsPath();
  UString name;
  if (index == kParentIndex)
  {
    int pos = fsPrefix.ReverseFind_PathSepar();
    if (pos >= 0 && pos == (int)fsPrefix.Len() - 1)
    {
      UString s = fsPrefix.Left(pos);
      pos = s.ReverseFind_PathSepar();
      if (pos >= 0)
        fsPrefix.SetFrom(s, pos + 1);
    }
    name = fsPrefix;
  }
  else
    name = fsPrefix + GetItemRelPath(index) + WCHAR_PATH_SEPARATOR;
  StartApplicationDontWait(fsPrefix, name, (HWND)*this);
}

bool CPanel::IsVirus_Message(const UString &name)
{
  UString name2;

  const wchar_t cRLO = (wchar_t)0x202E;
  bool isVirus = false;
  bool isSpaceError = false;
  name2 = name;
  
  if (name2.Find(cRLO) >= 0)
  {
    UString badString = cRLO;
    name2.Replace(badString, L"[RLO]");
    isVirus = true;
  }
  {
    const wchar_t *kVirusSpaces = L"     ";
    // const unsigned kNumSpaces = strlen(kVirusSpaces);
    for (;;)
    {
      int pos = name2.Find(kVirusSpaces);
      if (pos < 0)
        break;
      isVirus = true;
      isSpaceError = true;
      name2.Replace(kVirusSpaces, L" ");
    }
  }
  
  if (!isVirus)
    return false;

  UString s = LangString(IDS_VIRUS);
  
  if (!isSpaceError)
  {
    int pos1 = s.Find(L'(');
    if (pos1 >= 0)
    {
      int pos2 = s.Find(L')', pos1 + 1);
      if (pos2 >= 0)
      {
        s.Delete(pos1, pos2 + 1 - pos1);
        if (pos1 > 0 && s[pos1 - 1] == ' ' && s[pos1] == '.')
          s.Delete(pos1 - 1);
      }
    }
  }

  UString name3 = name;
  name3.Replace(L'\n', L'_');
  name2.Replace(L'\n', L'_');

  s.Add_LF(); s += name2;
  s.Add_LF(); s += name3;

  MessageBoxMyError(s);
  return true;
}

void CPanel::OpenItem(int index, bool tryInternal, bool tryExternal, const wchar_t *type)
{
  CDisableTimerProcessing disableTimerProcessing(*this);
  UString name = GetItemRelPath2(index);
  
  if (IsVirus_Message(name))
    return;

  if (!_parentFolders.IsEmpty())
  {
    OpenItemInArchive(index, tryInternal, tryExternal, false, false, type);
    return;
  }

  CDisableNotify disableNotify(*this);
  UString prefix = GetFsPath();
  UString fullPath = prefix + name;

  if (tryInternal)
    if (!tryExternal || !DoItemAlwaysStart(name))
    {
      HRESULT res = OpenItemAsArchive(index, type);
      disableNotify.Restore(); // we must restore to allow text notification update
      InvalidateList();
      if (res == S_OK || res == E_ABORT)
        return;
      if (res != S_FALSE)
      {
        MessageBoxError(res);
        return;
      }
    }
  
  if (tryExternal)
  {
    // SetCurrentDirectory opens HANDLE to folder!!!
    // NDirectory::MySetCurrentDirectory(prefix);
    StartApplicationDontWait(prefix, fullPath, (HWND)*this);
  }
}

class CThreadCopyFrom: public CProgressThreadVirt
{
  HRESULT ProcessVirt();
public:
  UString FullPath;
  UInt32 ItemIndex;

  CMyComPtr<IFolderOperations> FolderOperations;
  CMyComPtr<IProgress> UpdateCallback;
  CUpdateCallback100Imp *UpdateCallbackSpec;
};
  
HRESULT CThreadCopyFrom::ProcessVirt()
{
  return FolderOperations->CopyFromFile(ItemIndex, FullPath, UpdateCallback);
}
      
HRESULT CPanel::OnOpenItemChanged(UInt32 index, const wchar_t *fullFilePath,
    bool usePassword, const UString &password)
{
  if (!_folderOperations)
  {
    MessageBoxErrorLang(IDS_OPERATION_IS_NOT_SUPPORTED);
    return E_FAIL;
  }

  CThreadCopyFrom t;
  t.UpdateCallbackSpec = new CUpdateCallback100Imp;
  t.UpdateCallback = t.UpdateCallbackSpec;
  t.UpdateCallbackSpec->ProgressDialog = &t.ProgressDialog;
  t.ItemIndex = index;
  t.FullPath = fullFilePath;
  t.FolderOperations = _folderOperations;

  t.UpdateCallbackSpec->Init();
  t.UpdateCallbackSpec->PasswordIsDefined = usePassword;
  t.UpdateCallbackSpec->Password = password;


  RINOK(t.Create(GetItemName(index), (HWND)*this));
  return t.Result;
}

LRESULT CPanel::OnOpenItemChanged(LPARAM lParam)
{
  CTmpProcessInfo &tpi = *(CTmpProcessInfo *)lParam;
  if (tpi.FullPathFolderPrefix != _currentFolderPrefix)
    return 0;
  UInt32 fileIndex = tpi.FileIndex;
  UInt32 numItems;
  _folder->GetNumberOfItems(&numItems);
  
  // This code is not 100% OK for cases when there are several files with
  // tpi.RelPath name and there are changes in archive before update.
  // So tpi.FileIndex can point to another file.
 
  if (fileIndex >= numItems || GetItemRelPath(fileIndex) != tpi.RelPath)
  {
    UInt32 i;
    for (i = 0; i < numItems; i++)
      if (GetItemRelPath(i) == tpi.RelPath)
        break;
    if (i == numItems)
      return 0;
    fileIndex = i;
  }

  CSelectedState state;
  SaveSelectedState(state);

  CDisableNotify disableNotify(*this); // do we need it??

  HRESULT result = OnOpenItemChanged(fileIndex, fs2us(tpi.FilePath), tpi.UsePassword, tpi.Password);
  RefreshListCtrl(state);
  if (result != S_OK)
    return 0;
  return 1;
}

class CExitEventLauncher
{
public:
  NWindows::NSynchronization::CManualResetEvent _exitEvent;
  CExitEventLauncher()
  {
    if (_exitEvent.Create(false) != S_OK)
      throw 9387173;
  };
  ~CExitEventLauncher() {  _exitEvent.Set(); }
} g_ExitEventLauncher;

#ifdef _WIN32
static THREAD_FUNC_DECL MyThreadFunction(void *param)
{
  CMyAutoPtr<CTmpProcessInfo> tmpProcessInfoPtr((CTmpProcessInfo *)param);
  CTmpProcessInfo *tpi = tmpProcessInfoPtr.get();
  CChildProcesses &processes = tpi->Processes;

  for (;;)
  {
    CRecordVector<HANDLE> handles;
    CRecordVector<int> indices;
    
    FOR_VECTOR (i, processes.Handles)
    {
      if (processes.NeedWait[i])
      {
        handles.Add(processes.Handles[i]);
        indices.Add(i);
      }
    }
    
    if (handles.IsEmpty())
      break;

    handles.Add(g_ExitEventLauncher._exitEvent);

    DWORD waitResult = ::WaitForMultipleObjects(handles.Size(), &handles.Front(), FALSE, INFINITE);

    if (waitResult >= (DWORD)handles.Size() - 1)
    {
      processes.CloseAll();
      return waitResult >= (DWORD)handles.Size() ? 1 : 0;
    }
    processes.Update();
    processes.DisableWait(indices[waitResult]);
  }

  NFind::CFileInfo newFileInfo;
  if (newFileInfo.Find(tpi->FilePath))
  {
    if (tpi->WasChanged(newFileInfo))
    {
      UString message = MyFormatNew(IDS_WANT_UPDATE_MODIFIED_FILE, tpi->RelPath);
      if (::MessageBoxW(g_HWND, message, L"7-Zip", MB_OKCANCEL | MB_ICONQUESTION) == IDOK)
      {
        if (SendMessage(tpi->Window, kOpenItemChanged, 0, (LONG_PTR)tpi) != 1)
        {
          ::MessageBoxW(g_HWND, MyFormatNew(IDS_CANNOT_UPDATE_FILE,
              fs2us(tpi->FilePath)), L"7-Zip", MB_OK | MB_ICONSTOP);
          return 0;
        }
      }
    }
  }
  tpi->DeleteDirAndFile();
  return 0;
}
#endif

#if defined(_WIN32) && !defined(UNDER_CE)
static const FChar *k_ZoneId_StreamName = FTEXT(":Zone.Identifier");
#endif


#ifndef UNDER_CE

static void ReadZoneFile(CFSTR fileName, CByteBuffer &buf)
{
  buf.Free();
  NIO::CInFile file;
  if (!file.Open(fileName))
    return;
  UInt64 fileSize;
  if (!file.GetLength(fileSize))
    return;
  if (fileSize == 0 || fileSize >= ((UInt32)1 << 20))
    return;
  buf.Alloc((size_t)fileSize);
  UInt32 processed;
  if (file.Read(buf, (UInt32)fileSize, processed) && processed == fileSize)
    return;
  buf.Free();
}

static bool WriteZoneFile(CFSTR fileName, const CByteBuffer &buf)
{
  NIO::COutFile file;
  if (!file.Create(fileName, true))
    return false;
  UInt32 processed;
  if (!file.Write(buf, (UInt32)buf.Size(), processed))
    return false;
  return processed == buf.Size();
}

#endif

/*
class CBufSeqOutStream_WithFile:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  Byte *_buffer;
  size_t _size;
  size_t _pos;


  size_t _fileWritePos;
  bool fileMode;
public:

  bool IsStreamInMem() const { return !fileMode; }
  size_t GetMemStreamWrittenSize() const { return _pos; }

  // ISequentialOutStream *FileStream;
  FString FilePath;
  COutFileStream *outFileStreamSpec;
  CMyComPtr<ISequentialOutStream> outFileStream;

  CBufSeqOutStream_WithFile(): outFileStreamSpec(NULL) {}

  void Init(Byte *buffer, size_t size)
  {
    fileMode = false;
    _buffer = buffer;
    _pos = 0;
    _size = size;
    _fileWritePos = 0;
  }

  HRESULT FlushToFile();
  size_t GetPos() const { return _pos; }

  MY_UNKNOWN_IMP
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
};

static const UInt32 kBlockSize = ((UInt32)1 << 31);

STDMETHODIMP CBufSeqOutStream_WithFile::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (!fileMode)
  {
    if (_size - _pos >= size)
    {
      if (size != 0)
      {
        memcpy(_buffer + _pos, data, size);
        _pos += size;
      }
      if (processedSize)
        *processedSize = (UInt32)size;
      return S_OK;
    }

    fileMode = true;
  }
  RINOK(FlushToFile());
  return outFileStream->Write(data, size, processedSize);
}

HRESULT CBufSeqOutStream_WithFile::FlushToFile()
{
  if (!outFileStream)
  {
    outFileStreamSpec = new COutFileStream;
    outFileStream = outFileStreamSpec;
    if (!outFileStreamSpec->Create(FilePath, false))
    {
      outFileStream.Release();
      return E_FAIL;
      // MessageBoxMyError(UString(L"Can't create file ") + fs2us(tempFilePath));
    }
  }
  while (_fileWritePos != _pos)
  {
    size_t cur = _pos - _fileWritePos;
    UInt32 curSize = (cur < kBlockSize) ? (UInt32)cur : kBlockSize;
    UInt32 processedSizeLoc = 0;
    HRESULT res = outFileStream->Write(_buffer + _fileWritePos, curSize, &processedSizeLoc);
    _fileWritePos += processedSizeLoc;
    RINOK(res);
    if (processedSizeLoc == 0)
      return E_FAIL;
  }
  return S_OK;
}
*/

/*
static HRESULT GetTime(IFolderFolder *folder, UInt32 index, PROPID propID, FILETIME &filetime, bool &filetimeIsDefined)
{
  filetimeIsDefined = false;
  NCOM::CPropVariant prop;
  RINOK(folder->GetProperty(index, propID, &prop));
  if (prop.vt == VT_FILETIME)
  {
    filetime = prop.filetime;
    filetimeIsDefined = (filetime.dwHighDateTime != 0 || filetime.dwLowDateTime != 0);
  }
  else if (prop.vt != VT_EMPTY)
    return E_FAIL;
  return S_OK;
}
*/

void CPanel::OpenItemInArchive(int index, bool tryInternal, bool tryExternal, bool editMode, bool useEditor, const wchar_t *type)
{
  const UString name = GetItemName(index);
  const UString relPath = GetItemRelPath(index);
  
  if (IsVirus_Message(name))
    return;

  if (!_folderOperations)
  {
    MessageBoxErrorLang(IDS_OPERATION_IS_NOT_SUPPORTED);
    return;
  }

  bool tryAsArchive = tryInternal && (!tryExternal || !DoItemAlwaysStart(name));

  UString fullVirtPath = _currentFolderPrefix + relPath;

  CTempDir tempDirectory;
  if (!tempDirectory.Create(kTempDirPrefix))
  {
    MessageBoxLastError();
    return;
  }
  FString tempDir = tempDirectory.GetPath();
  FString tempDirNorm = tempDir;
  NName::NormalizeDirPathPrefix(tempDirNorm);
  const FString tempFilePath = tempDirNorm + us2fs(Get_Correct_FsFile_Name(name));

  CTempFileInfo tempFileInfo;
  tempFileInfo.FileIndex = index;
  tempFileInfo.RelPath = relPath;
  tempFileInfo.FolderPath = tempDir;
  tempFileInfo.FilePath = tempFilePath;
  tempFileInfo.NeedDelete = true;

  if (tryAsArchive)
  {
    CMyComPtr<IInArchiveGetStream> getStream;
    _folder.QueryInterface(IID_IInArchiveGetStream, &getStream);
    if (getStream)
    {
      CMyComPtr<ISequentialInStream> subSeqStream;
      getStream->GetStream(index, &subSeqStream);
      if (subSeqStream)
      {
        CMyComPtr<IInStream> subStream;
        subSeqStream.QueryInterface(IID_IInStream, &subStream);
        if (subStream)
        {
          bool encrypted;
          HRESULT res = OpenItemAsArchive(subStream, tempFileInfo, fullVirtPath, type ? type : L"", encrypted);
          if (res == S_OK)
          {
            tempDirectory.DisableDeleting();
            RefreshListCtrl();
            return;
          }
          if (res == E_ABORT)
            return;
          if (res != S_FALSE)
          {
            // probably we must show some message here
            // return;
          }
        }
      }
    }
  }


  CRecordVector<UInt32> indices;
  indices.Add(index);

  UStringVector messages;

  bool usePassword = false;
  UString password;
  if (_parentFolders.Size() > 0)
  {
    const CFolderLink &fl = _parentFolders.Back();
    usePassword = fl.UsePassword;
    password = fl.Password;
  }

  #if defined(_WIN32) && !defined(UNDER_CE)
  CByteBuffer zoneBuf;
  #ifndef _UNICODE
  if (g_IsNT)
  #endif
  if (_parentFolders.Size() > 0)
  {
    const CFolderLink &fl = _parentFolders.Front();
    if (!fl.IsVirtual && !fl.FilePath.IsEmpty())
      ReadZoneFile(fl.FilePath + k_ZoneId_StreamName, zoneBuf);
  }
  #endif


  CVirtFileSystem *virtFileSystemSpec = NULL;
  CMyComPtr<ISequentialOutStream> virtFileSystem;

  bool isAltStream = IsItem_AltStream(index);

  CCopyToOptions options;
  options.includeAltStreams = true;
  options.replaceAltStreamChars = isAltStream;
  
  if (tryAsArchive)
  {
    NCOM::CPropVariant prop;
    _folder->GetProperty(index, kpidSize, &prop);
    UInt64 fileLimit = g_RAM_Size / 4;
    UInt64 fileSize = 0;
    if (!ConvertPropVariantToUInt64(prop, fileSize))
      fileSize = fileLimit;
    if (fileSize <= fileLimit && fileSize > 0)
    {
      options.streamMode = true;
      virtFileSystemSpec = new CVirtFileSystem;
      virtFileSystem = virtFileSystemSpec;
      // we allow additional total size for small alt streams;
      virtFileSystemSpec->MaxTotalAllocSize = fileSize + (1 << 10);
      
      virtFileSystemSpec->DirPrefix = tempDirNorm;
      virtFileSystemSpec->Init();
      options.VirtFileSystem = virtFileSystem;
      options.VirtFileSystemSpec = virtFileSystemSpec;
    }
  }

  options.folder = fs2us(tempDirNorm);
  options.showErrorMessages = true;
  HRESULT result = CopyTo(options, indices, &messages, usePassword, password);

  if (_parentFolders.Size() > 0)
  {
    CFolderLink &fl = _parentFolders.Back();
    fl.UsePassword = usePassword;
    fl.Password = password;
  }

  if (!messages.IsEmpty())
    return;
  if (result != S_OK)
  {
    if (result != E_ABORT)
      MessageBoxError(result);
    return;
  }

  if (options.VirtFileSystem)
  {
    if (virtFileSystemSpec->IsStreamInMem())
    {
      const CVirtFile &file = virtFileSystemSpec->Files[0];

      size_t streamSize = (size_t)file.Size;
      CBufInStream *bufInStreamSpec = new CBufInStream;
      CMyComPtr<IInStream> bufInStream = bufInStreamSpec;
      bufInStreamSpec->Init(file.Data, streamSize, virtFileSystem);
      bool encrypted;
      if (OpenItemAsArchive(bufInStream, tempFileInfo, fullVirtPath, type ? type : L"", encrypted) == S_OK)
      {
        tempDirectory.DisableDeleting();
        RefreshListCtrl();
        return;
      }
      if (virtFileSystemSpec->FlushToDisk(true) != S_OK)
        return;
    }
  }


  #if defined(_WIN32) && !defined(UNDER_CE)
  if (zoneBuf.Size() != 0)
  {
    if (NFind::DoesFileExist(tempFilePath))
    {
      WriteZoneFile(tempFilePath + k_ZoneId_StreamName, zoneBuf);
    }
  }
  #endif


  if (tryAsArchive)
  {
    bool encrypted;
    if (OpenItemAsArchive(NULL, tempFileInfo, fullVirtPath, type ? type : L"", encrypted) == S_OK)
    {
      tempDirectory.DisableDeleting();
      RefreshListCtrl();
      return;
    }
  }

  CMyAutoPtr<CTmpProcessInfo> tmpProcessInfoPtr(new CTmpProcessInfo());
  CTmpProcessInfo *tpi = tmpProcessInfoPtr.get();
  tpi->FolderPath = tempDir;
  tpi->FilePath = tempFilePath;
  tpi->NeedDelete = true;
  tpi->UsePassword = usePassword;
  tpi->Password = password;

  if (!tpi->FileInfo.Find(tempFilePath))
    return;

  CTmpProcessInfoRelease tmpProcessInfoRelease(*tpi);

  if (!tryExternal)
    return;

  // CProcess process;
  // HRESULT res;
  if (editMode)
    /* res = */ StartEditApplication(fs2us(tempFilePath), useEditor, (HWND)*this /* , process */ );
  else
    /* res =  */ StartApplication(fs2us(tempDirNorm), fs2us(tempFilePath), (HWND)*this /* , process */ );

#ifdef _WIN32
  if ((HANDLE)process == 0)
    return;

  tpi->Window = (HWND)(*this);
  tpi->FullPathFolderPrefix = _currentFolderPrefix;
  tpi->FileIndex = index;
  tpi->RelPath = relPath;
  tpi->Processes.AddProcess(process.Detach());

  NWindows::CThread thread;
  if (thread.Create(MyThreadFunction, tpi) != S_OK)
    throw 271824;
#endif
  tempDirectory.DisableDeleting();
  tmpProcessInfoPtr.release();
  tmpProcessInfoRelease._needDelete = false;
}

/*
static const UINT64 kTimeLimit = UINT64(10000000) * 3600 * 24;

static bool CheckDeleteItem(UINT64 currentFileTime, UINT64 folderFileTime)
{
  return (currentFileTime - folderFileTime > kTimeLimit &&
      folderFileTime - currentFileTime > kTimeLimit);
}

void DeleteOldTempFiles()
{
  UString tempPath;
  if(!MyGetTempPath(tempPath))
    throw 1;

  UINT64 currentFileTime;
  NTime::GetCurUtcFileTime(currentFileTime);
  UString searchWildCard = tempPath + kTempDirPrefix + L"*.tmp";
  searchWildCard += WCHAR(NName::kAnyStringWildcard);
  NFind::CEnumeratorW enumerator(searchWildCard);
  NFind::CFileInfo fileInfo;
  while(enumerator.Next(fileInfo))
  {
    if (!fileInfo.IsDir())
      continue;
    const UINT64 &cTime = *(const UINT64 *)(&fileInfo.CTime);
    if(CheckDeleteItem(cTime, currentFileTime))
      RemoveDirectoryWithSubItems(tempPath + fileInfo.Name);
  }
}
*/
// PanelItems.cpp

#include "StdAfx.h"

#include "../../../../C/Sort.h"

#include "../../../Windows/FileName.h"
#include "../../../Windows/Menu.h"
#include "../../../Windows/PropVariant.h"
#include "../../../Windows/PropVariantConv.h"

#include "../../PropID.h"

#include "resource.h"

#include "LangUtils.h"
#include "Panel.h"
#include "PropertyName.h"
#include "RootFolder.h"

using namespace NWindows;

static bool GetColumnVisible(PROPID propID, bool isFsFolder)
{
  if (isFsFolder)
  {
    switch (propID)
    {
      case kpidATime:
      case kpidAttrib:
      case kpidPackSize:
      case kpidINode:
      case kpidLinks:
      case kpidNtReparse:
        return false;
    }
  }
  return true;
}

static int GetColumnWidth(PROPID propID, VARTYPE /* varType */)
{
  switch (propID)
  {
    case kpidName: return 160;
  }
  return 100;
}

static int GetColumnAlign(PROPID propID, VARTYPE varType)
{
  switch (propID)
  {
    case kpidCTime:
    case kpidATime:
    case kpidMTime:
      return LVCFMT_LEFT;
  }

  switch (varType)
  {
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_INT:
    case VT_UI4:
    case VT_UINT:
    case VT_I8:
    case VT_UI8:
    case VT_BOOL:
      return LVCFMT_RIGHT;

    case VT_EMPTY:
    case VT_I1:
    case VT_FILETIME:
    case VT_BSTR:
      return LVCFMT_LEFT;

    default:
      return LVCFMT_CENTER;
  }
}

HRESULT CPanel::InitColumns()
{
printf("CPanel::InitColumns\n");
  if (_needSaveInfo)
    SaveListViewInfo();

  _listView.DeleteAllItems();
  _selectedStatusVector.Clear();
  // printf("CPanel::InitColumns : _selectedStatusVector.Clear()\n");

  ReadListViewInfo();

  // PROPID sortID;
  /*
  if (_listViewInfo.SortIndex >= 0)
    sortID = _listViewInfo.Columns[_listViewInfo.SortIndex].PropID;
  */
  // sortID = _listViewInfo.SortID;

  _ascending = _listViewInfo.Ascending;

  _properties.Clear();

  _needSaveInfo = true;
  bool isFsFolder = IsFSFolder() || IsAltStreamsFolder();

  {
    UInt32 numProps;
    _folder->GetNumberOfProperties(&numProps);

    for (UInt32 i = 0; i < numProps; i++)
    {
      CMyComBSTR name;
      PROPID propID;
      VARTYPE varType;
      HRESULT res = _folder->GetPropertyInfo(i, &name, &propID, &varType);

      if (res != S_OK)
      {
        /* We can return ERROR, but in that case, other code will not be called,
           and user can see empty window without error message. So we just ignore that field */
        continue;
      }
      if (propID == kpidIsDir)
        continue;
      CItemProperty prop;
      prop.Type = varType;
      prop.ID = propID;
      prop.Name = GetNameOfProperty(propID, name);
      prop.Order = -1;
      prop.IsVisible = GetColumnVisible(propID, isFsFolder);
      prop.Width = GetColumnWidth(propID, varType);
      prop.IsRawProp = false;
      _properties.Add(prop);
    }
  }

  if (_folderRawProps)
  {
    UInt32 numProps;
    _folderRawProps->GetNumRawProps(&numProps);
    for (UInt32 i = 0; i < numProps; i++)
    {
      CMyComBSTR name;
      PROPID propID;
      RINOK(_folderRawProps->GetRawPropInfo(i, &name, &propID));

      CItemProperty prop;
      prop.Type = VT_EMPTY;
      prop.ID = propID;
      prop.Name = GetNameOfProperty(propID, name);
      prop.Order = -1;
      prop.IsVisible = GetColumnVisible(propID, isFsFolder);
      prop.Width = GetColumnWidth(propID, VT_BSTR);;
      prop.IsRawProp = true;
      _properties.Add(prop);
    }
  }

  // InitColumns2(sortID);

  for (;;)
    if (!_listView.DeleteColumn(0))
      break;

  unsigned order = 0;
  unsigned i;
  for (i = 0; i < _listViewInfo.Columns.Size(); i++)
  {
    const CColumnInfo &columnInfo = _listViewInfo.Columns[i];
    int index = _properties.FindItemWithID(columnInfo.PropID);
    if (index >= 0)
    {
      CItemProperty &item = _properties[index];
      item.IsVisible = columnInfo.IsVisible;
      item.Width = columnInfo.Width;
      if (columnInfo.IsVisible)
        item.Order = order++;
      continue;
    }
  }

  for (i = 0; i < _properties.Size(); i++)
  {
    CItemProperty &item = _properties[i];
    if (item.Order < 0)
      item.Order = order++;
  }

  _visibleProperties.Clear();
  for (i = 0; i < _properties.Size(); i++)
  {
    const CItemProperty &prop = _properties[i];
    if (prop.IsVisible)
      _visibleProperties.Add(prop);
  }

  // _sortIndex = 0;
  _sortID = kpidName;
  /*
  if (_listViewInfo.SortIndex >= 0)
  {
    int sortIndex = _properties.FindItemWithID(sortID);
    if (sortIndex >= 0)
      _sortIndex = sortIndex;
  }
  */
  _sortID = _listViewInfo.SortID;

  _visibleProperties.Sort();
  for (i = 0; i < _visibleProperties.Size(); i++)
  {
    InsertColumn(i);
  }
  return S_OK;
}

void CPanel::InsertColumn(unsigned index)
{
  const CItemProperty &prop = _visibleProperties[index];
  LV_COLUMNW column;
  column.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_ORDER;
  column.cx = prop.Width;
  column.fmt = GetColumnAlign(prop.ID, prop.Type);
  // FIXME not available column.iOrder = prop.Order;
  // iOrder must be <= _listView.ItemCount
  column.iSubItem = index;
  column.pszText = const_cast<wchar_t *>((const wchar_t *)prop.Name);
  // printf("CPanel::InsertColumn(%d)=>'%ls'\n",index,column.pszText); fflush(stdout);
  _listView.InsertColumn(index, &column);
}

HRESULT CPanel::RefreshListCtrl()
{
  return RefreshListCtrl(UString(), -1, true, UStringVector());
}

// int CALLBACK CompareItems(LPARAM lParam1, LPARAM lParam2, LPARAM lpData);
int
#if defined(__WIN32__) && !defined(__WXMICROWIN__) // FIXME
  wxCALLBACK
#endif
 CompareItems_WX(long item1, long item2, long sortData);


void CPanel::GetSelectedNames(UStringVector &selectedNames)
{
  CRecordVector<UInt32> indices;
  GetSelectedItemsIndices(indices);
  selectedNames.ClearAndReserve(indices.Size());
  FOR_VECTOR (i, indices)
    selectedNames.AddInReserved(GetItemRelPath(indices[i]));

  /*
  for (int i = 0; i < _listView.GetItemCount(); i++)
  {
    const int kSize = 1024;
    WCHAR name[kSize + 1];
    LVITEMW item;
    item.iItem = i;
    item.pszText = name;
    item.cchTextMax = kSize;
    item.iSubItem = 0;
    item.mask = LVIF_TEXT | LVIF_PARAM;
    if (!_listView.GetItem(&item))
      continue;
    int realIndex = GetRealIndex(item);
    if (realIndex == kParentIndex)
      continue;
    if (_selectedStatusVector[realIndex])
      selectedNames.Add(item.pszText);
  }
  */
  selectedNames.Sort();
}

void CPanel::SaveSelectedState(CSelectedState &s)
{
  s.FocusedName.Empty();
  s.SelectedNames.Clear();
  s.FocusedItem = _listView.GetFocusedItem();
  {
    if (s.FocusedItem >= 0)
    {
      int realIndex = GetRealItemIndex(s.FocusedItem);
      if (realIndex != kParentIndex)
        s.FocusedName = GetItemRelPath(realIndex);
        /*
        const int kSize = 1024;
        WCHAR name[kSize + 1];
        LVITEMW item;
        item.iItem = focusedItem;
        item.pszText = name;
        item.cchTextMax = kSize;
        item.iSubItem = 0;
        item.mask = LVIF_TEXT;
        if (_listView.GetItem(&item))
        focusedName = item.pszText;
      */
    }
  }
  GetSelectedNames(s.SelectedNames);
}

HRESULT CPanel::RefreshListCtrl(const CSelectedState &s)
{
printf("CPanel::RefreshListCtrl\n");
  bool selectFocused = s.SelectFocused;
  if (_mySelectMode)
    selectFocused = true;
  return RefreshListCtrl(s.FocusedName, s.FocusedItem, selectFocused, s.SelectedNames);
}

HRESULT CPanel::RefreshListCtrlSaveFocused()
{
  CSelectedState state;
  SaveSelectedState(state);
  return RefreshListCtrl(state);
}

void CPanel::SetFocusedSelectedItem(int index, bool select)
{
  UINT state = LVIS_FOCUSED;
  if (select)
    state |= LVIS_SELECTED;
  _listView.SetItemState(index, state, state);
  if (!_mySelectMode && select)
  {
    int realIndex = GetRealItemIndex(index);
    if (realIndex != kParentIndex)
    {
       // printf("CPanel::SetFocusedSelectedItem(%d,%d) : _selectedStatusVector[%d]=%d => true\n",index,select,realIndex,_selectedStatusVector[realIndex]);
      _selectedStatusVector[realIndex] = true;
    }
  }
}

HRESULT CPanel::RefreshListCtrl(const UString &focusedName, int focusedPos, bool selectFocused,
    const UStringVector &selectedNames)
{
  _dontShowMode = false;
  LoadFullPathAndShow();
  // OutputDebugStringA("=======\n");
  // OutputDebugStringA("s1 \n");
  CDisableTimerProcessing timerProcessing(*this);
  CDisableNotify disableNotify(*this);

  if (focusedPos < 0)
    focusedPos = 0;

  _listView.SetRedraw(false);
  // m_RedrawEnabled = false;

#ifdef _WIN32
  LVITEMW item;
  ZeroMemory(&item, sizeof(item));
#else
  LVITEMW item = { 0 };
#endif

  // DWORD tickCount0 = GetTickCount();
  _enableItemChangeNotify = false;
  _listView.DeleteAllItems();
  _enableItemChangeNotify = true;


  int listViewItemCount = 0;

  // printf("&&&&&&&&&&&&&& _selectedStatusVector.Clear() &&&&&&&&&&&&&&\n");
  _selectedStatusVector.Clear();
  // _realIndices.Clear();
  _startGroupSelect = 0;

  _selectionIsDefined = false;

  // m_Files.Clear();

  if (!_folder)
  {
    // throw 1;
    SetToRootFolder();
  }

  // FIXME _headerToolBar.EnableButton(kParentFolderID, !IsRootFolder());

  {
    CMyComPtr<IFolderSetFlatMode> folderSetFlatMode;
    _folder.QueryInterface(IID_IFolderSetFlatMode, &folderSetFlatMode);
    if (folderSetFlatMode)
      folderSetFlatMode->SetFlatMode(BoolToInt(_flatMode));
  }

  /*
  {
    CMyComPtr<IFolderSetShowNtfsStreamsMode> setShow;
    _folder.QueryInterface(IID_IFolderSetShowNtfsStreamsMode, &setShow);
    if (setShow)
      setShow->SetShowNtfsStreamsMode(BoolToInt(_showNtfsStrems_Mode));
  }
  */

  // DWORD tickCount1 = GetTickCount();
  RINOK(_folder->LoadItems());
  // DWORD tickCount2 = GetTickCount();
  RINOK(InitColumns());

  // OutputDebugString(TEXT("Start Dir\n"));
  UInt32 numItems;
  _folder->GetNumberOfItems(&numItems);

  bool showDots = _showDots && !IsRootFolder();

  _listView.SetItemCount(numItems + (showDots ? 1 : 0));

  _selectedStatusVector.ClearAndReserve(numItems);
  // printf("_selectedStatusVector.ClearAndReserve(%d)\n",numItems);
  int cursorIndex = -1;

  CMyComPtr<IFolderGetSystemIconIndex> folderGetSystemIconIndex;
  if (!Is_Slow_Icon_Folder() || _showRealFileIcons)
    _folder.QueryInterface(IID_IFolderGetSystemIconIndex, &folderGetSystemIconIndex);

  if (!IsFSFolder())
  {
    CMyComPtr<IGetFolderArcProps> getFolderArcProps;
    _folder.QueryInterface(IID_IGetFolderArcProps, &getFolderArcProps);
    _thereAreDeletedItems = false;
    if (getFolderArcProps)
    {
      CMyComPtr<IFolderArcProps> arcProps;
      getFolderArcProps->GetFolderArcProps(&arcProps);
      if (arcProps)
      {
        UInt32 numLevels;
        if (arcProps->GetArcNumLevels(&numLevels) != S_OK)
          numLevels = 0;
        NCOM::CPropVariant prop;
        if (arcProps->GetArcProp(numLevels - 1, kpidIsDeleted, &prop) == S_OK)
          if (prop.vt == VT_BOOL && VARIANT_BOOLToBool(prop.boolVal))
            _thereAreDeletedItems = true;
      }
    }
  }

  if (showDots)
  {
    UString itemName = L"..";
    item.iItem = listViewItemCount;
    if (itemName == focusedName)
      cursorIndex = item.iItem;
    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    int subItem = 0;
    item.iSubItem = subItem++;
    item.lParam = kParentIndex;
    item.pszText = const_cast<wchar_t *>((const wchar_t *)itemName); // FIXME item.pszText = LPSTR_TEXTCALLBACKW;
    UInt32 attrib = FILE_ATTRIBUTE_DIRECTORY;
    item.iImage = _extToIconMap.GetIconIndex(attrib, itemName);
    if (item.iImage < 0)
      item.iImage = 0;
    if (_listView.InsertItem(&item) == -1)
      return E_FAIL;

    listViewItemCount++;
  }

  // OutputDebugStringA("S1\n");

  UString correctedName;
  UString itemName;
  UString relPath;

  printf("ADD ITEMS - BEGIN\n");
  for (UInt32 i = 0; i < numItems; i++)
  {
    const wchar_t *name = NULL;
    unsigned nameLen = 0;

    if (_folderGetItemName)
      _folderGetItemName->GetItemName(i, &name, &nameLen);
    if (!name)
    {
      GetItemName(i, itemName);
      name = itemName;
      nameLen = itemName.Len();
    }

    bool selected = false;

    if (!focusedName.IsEmpty() || !selectedNames.IsEmpty())
    {
      relPath.Empty();

      // relPath += GetItemPrefix(i);
      // change it (_flatMode)
      if (i != kParentIndex && _flatMode)
      {
        const wchar_t *prefix = NULL;
        if (_folderGetItemName)
        {
          unsigned prefixLen = 0;
          _folderGetItemName->GetItemPrefix(i, &prefix, &prefixLen);
          if (prefix)
            relPath += prefix;
        }
        if (!prefix)
        {
          NCOM::CPropVariant prop;
          if (_folder->GetProperty(i, kpidPrefix, &prop) != S_OK)
            throw 2723400;
          if (prop.vt == VT_BSTR)
            relPath += prop.bstrVal;
        }
      }
      relPath += name;
      if (relPath == focusedName)
        cursorIndex = listViewItemCount;
      if (selectedNames.FindInSorted(relPath) >= 0)
        selected = true;
    }

    _selectedStatusVector.AddInReserved(selected);
    // printf("_selectedStatusVector.AddInReserved(%d)\n",selected);


    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;

    if (!_mySelectMode)
      if (selected)
      {
        item.mask |= LVIF_STATE;
        item.state = LVIS_SELECTED;
      }

    int subItem = 0;
    item.iItem = listViewItemCount;

    item.iSubItem = subItem++;
    item.lParam = i;

    /*
    int finish = nameLen - 4;
    int j;
    for (j = 0; j < finish; j++)
    {
      if (name[j    ] == ' ' &&
          name[j + 1] == ' ' &&
          name[j + 2] == ' ' &&
          name[j + 3] == ' ' &&
          name[j + 4] == ' ')
        break;
    }
    if (j < finish)
    {
      correctedName.Empty();
      correctedName = L"virus";
      int pos = 0;
      for (;;)
      {
        int posNew = itemName.Find(L"     ", pos);
        if (posNew < 0)
        {
          correctedName += itemName.Ptr(pos);
          break;
        }
        correctedName += itemName.Mid(pos, posNew - pos);
        correctedName += L" ... ";
        pos = posNew;
        while (itemName[++pos] == ' ');
      }
      item.pszText = const_cast<wchar_t *>((const wchar_t *)correctedName);
    }
    else
    */
    {
      item.pszText = const_cast<wchar_t *>((const wchar_t *)name); // FIXME item.pszText = LPSTR_TEXTCALLBACKW;
      /* LPSTR_TEXTCALLBACKW works, but in some cases there are problems,
      since we block notify handler. */
    }

    UInt32 attrib = 0;
    // for (int yyy = 0; yyy < 6000000; yyy++) {
    NCOM::CPropVariant prop;
    RINOK(_folder->GetProperty(i, kpidAttrib, &prop));
    if (prop.vt == VT_UI4)
    {
      // char s[256]; sprintf(s, "attrib = %7x", attrib); OutputDebugStringA(s);
      attrib = prop.ulVal;
    }
    else if (IsItem_Folder(i))
      attrib |= FILE_ATTRIBUTE_DIRECTORY;
    // }

    bool defined = false;
#ifdef _WIN32
    if (folderGetSystemIconIndex)
    {
      folderGetSystemIconIndex->GetSystemIconIndex(i, &item.iImage);
      defined = (item.iImage > 0);
    }
#endif
    if (!defined)
    {
      if (_currentFolderPrefix.IsEmpty())
      {
        int iconIndexTemp;
        GetRealIconIndex(us2fs((UString)name) + FCHAR_PATH_SEPARATOR, attrib, iconIndexTemp);
        item.iImage = iconIndexTemp;
      }
      else
      {
        item.iImage = _extToIconMap.GetIconIndex(attrib, name);
      }
    }

    if (item.iImage < 0)
      item.iImage = 0;

    if (_listView.InsertItem(&item) == -1)
      return E_FAIL;


    // FIXME Added
    item.pszText = (LPWSTR)malloc(4096); // FIXME
    for(int col=1;col <  _listView.GetColumnCount(); col++)
    {
      item.iSubItem = col;
      item.cchTextMax = 4096 / sizeof(item.pszText[0]);
      this->SetItemText(item);
      _listView.SetItem(&item);
    }
    free(item.pszText); item.pszText = 0;

    listViewItemCount++;
  }
  printf("ADD ITEMS - END\n");

  // OutputDebugStringA("End2\n");

#if _WIN32
  // FIXME : with wxWidget, after sortitems, the item is unselected and unfocused
  if (_listView.GetItemCount() > 0 && cursorIndex >= 0)
    SetFocusedSelectedItem(cursorIndex, selectFocused);
#endif
  // DWORD tickCount3 = GetTickCount();
  SetSortRawStatus();
  _listView.SortItems(CompareItems_WX, (LPARAM)this);



  // DWORD tickCount4 = GetTickCount();
  if (cursorIndex < 0 && _listView.GetItemCount() > 0)
  {
    if (focusedPos >= _listView.GetItemCount())
      focusedPos = _listView.GetItemCount() - 1;
    // we select item only in showDots mode.
    SetFocusedSelectedItem(focusedPos, showDots);
  }
  // m_RedrawEnabled = true;
  // DWORD tickCount5 = GetTickCount();
  _listView.EnsureVisible(_listView.GetFocusedItem(), false);
  // DWORD tickCount6 = GetTickCount();

  disableNotify.SetMemMode_Enable();
  disableNotify.Restore();
  _listView.SetRedraw(true);
  // DWORD tickCount7 = GetTickCount();
  _listView.InvalidateRect(NULL, true);
  // DWORD tickCount8 = GetTickCount();
  // OutputDebugStringA("End1\n");
  /*
  _listView.UpdateWindow();
  */
  Refresh_StatusBar();
  // DWORD tickCount9 = GetTickCount();
  /*
  char s[256];
  sprintf(s,
      // "attribMap = %5d, extMap = %5d, "
      "delete = %5d, load = %5d, list = %5d, sort = %5d, end = %5d",
      // _extToIconMap._attribMap.Size(),
      // _extToIconMap._extMap.Size(),
      tickCount1 - tickCount0,
      tickCount2 - tickCount1,
      tickCount3 - tickCount2,
      tickCount4 - tickCount3,
      tickCount5 - tickCount4
      );
  sprintf(s,
      "5 = %5d, 6 = %5d, 7 = %5d, 8 = %5d, 9 = %5d",
      tickCount5 - tickCount4,
      tickCount6 - tickCount5,
      tickCount7 - tickCount6,
      tickCount8 - tickCount7,
      tickCount9 - tickCount8
      );
  OutputDebugStringA(s);
  */
  return S_OK;
}

void CPanel::GetSelectedItemsIndices(CRecordVector<UInt32> &indices) const
{
  indices.Clear();
  /*
  int itemIndex = -1;
  while ((itemIndex = _listView.GetNextSelectedItem(itemIndex)) != -1)
  {
    LPARAM param;
    if (_listView.GetItemParam(itemIndex, param))
      indices.Add(param);
  }
  */
  FOR_VECTOR (i, _selectedStatusVector)
    if (_selectedStatusVector[i])
      indices.Add(i);
  // HeapSort(&indices.Front(), indices.Size());
}

void CPanel::GetOperatedItemIndices(CRecordVector<UInt32> &indices) const
{
  GetSelectedItemsIndices(indices);
  if (!indices.IsEmpty())
    return;
  if (_listView.GetSelectedCount() == 0)
    return;
  int focusedItem = _listView.GetFocusedItem();
  if (focusedItem >= 0)
  {
    if (_listView.IsItemSelected(focusedItem))
    {
      int realIndex = GetRealItemIndex(focusedItem);
      if (realIndex != kParentIndex)
        indices.Add(realIndex);
    }
  }
}

void CPanel::GetAllItemIndices(CRecordVector<UInt32> &indices) const
{
  indices.Clear();
  UInt32 numItems;
  if (_folder->GetNumberOfItems(&numItems) == S_OK)
    for (UInt32 i = 0; i < numItems; i++)
      indices.Add(i);
}

void CPanel::GetOperatedIndicesSmart(CRecordVector<UInt32> &indices) const
{
  GetOperatedItemIndices(indices);
  if (indices.IsEmpty() || (indices.Size() == 1 && indices[0] == (UInt32)(Int32)-1))
    GetAllItemIndices(indices);
}

/*
void CPanel::GetOperatedListViewIndices(CRecordVector<UInt32> &indices) const
{
  indices.Clear();
  int numItems = _listView.GetItemCount();
  for (int i = 0; i < numItems; i++)
  {
    int realIndex = GetRealItemIndex(i);
    if (realIndex >= 0)
      if (_selectedStatusVector[realIndex])
        indices.Add(i);
  }
  if (indices.IsEmpty())
  {
    int focusedItem = _listView.GetFocusedItem();
      if (focusedItem >= 0)
        indices.Add(focusedItem);
  }
}
*/

void CPanel::EditItem(bool useEditor)
{
  if (!useEditor)
  {
    CMyComPtr<IFolderCalcItemFullSize> calcItemFullSize;
    _folder.QueryInterface(IID_IFolderCalcItemFullSize, &calcItemFullSize);
    if (calcItemFullSize)
    {
      bool needRefresh = false;
      CRecordVector<UInt32> indices;
      GetOperatedItemIndices(indices);
      FOR_VECTOR (i, indices)
      {
        UInt32 index = indices[i];
        if (IsItem_Folder(index))
        {
          calcItemFullSize->CalcItemFullSize(index, NULL);
          needRefresh = true;
        }
      }
      if (needRefresh)
      {
        // _listView.RedrawItem(0);
        // _listView.RedrawAllItems();
        InvalidateList();
        return;
      }
    }
  }


  int focusedItem = _listView.GetFocusedItem();
  if (focusedItem < 0)
    return;
  int realIndex = GetRealItemIndex(focusedItem);
  if (realIndex == kParentIndex)
    return;
  if (!IsItem_Folder(realIndex))
    EditItem(realIndex, useEditor);
}

void CPanel::OpenFocusedItemAsInternal(const wchar_t *type)
{
  int focusedItem = _listView.GetFocusedItem();
  if (focusedItem < 0)
    return;
  int realIndex = GetRealItemIndex(focusedItem);
  if (IsItem_Folder(realIndex))
    OpenFolder(realIndex);
  else
    OpenItem(realIndex, true, false, type);
}

void CPanel::OpenSelectedItems(bool tryInternal)
{
  CRecordVector<UInt32> indices;
  GetOperatedItemIndices(indices);
  if (indices.Size() > 20)
  {
    MessageBoxErrorLang(IDS_TOO_MANY_ITEMS);
    return;
  }

  int focusedItem = _listView.GetFocusedItem();

  // printf("###### CPanel::OpenSelectedItems(tryInternal=%d)-1 focusedItem=%d indices.Size()=%d\n",(int)tryInternal,focusedItem,(int)indices.Size());

  if (focusedItem >= 0)
  {
    int realIndex = GetRealItemIndex(focusedItem);
    if (realIndex == kParentIndex && (tryInternal || indices.Size() == 0) && _listView.IsItemSelected(focusedItem))
      indices.Insert(0, realIndex);
      // printf("###### CPanel::OpenSelectedItems(tryInternal=%d) realIndex=%d indices.Size()=%d\n",(int)tryInternal,realIndex,(int)indices.Size());
  }

  bool dirIsStarted = false;
  FOR_VECTOR (i, indices)
  {
    UInt32 index = indices[i];
    // CFileInfo &aFile = m_Files[index];
    if (IsItem_Folder(index))
    {
      if (!dirIsStarted)
      {
        if (tryInternal)
        {
          OpenFolder(index);
          dirIsStarted = true;
          break;
        }
        else
          OpenFolderExternal(index);
      }
    }
    else
      OpenItem(index, (tryInternal && indices.Size() == 1), true);
  }
}

UString CPanel::GetItemName(int itemIndex) const
{
  if (itemIndex == kParentIndex)
    return L"..";
  NCOM::CPropVariant prop;
  if (_folder->GetProperty(itemIndex, kpidName, &prop) != S_OK)
    throw 2723400;
  if (prop.vt != VT_BSTR)
    throw 2723401;
  return prop.bstrVal;
}

UString CPanel::GetItemName_for_Copy(int itemIndex) const
{
  if (itemIndex == kParentIndex)
    return L"..";
  {
    NCOM::CPropVariant prop;
    if (_folder->GetProperty(itemIndex, kpidOutName, &prop) == S_OK)
    {
      if (prop.vt == VT_BSTR)
        return prop.bstrVal;
      if (prop.vt != VT_EMPTY)
        throw 2723401;
    }
  }
  return GetItemName(itemIndex);
}

void CPanel::GetItemName(int itemIndex, UString &s) const
{
  if (itemIndex == kParentIndex)
  {
    s = L"..";
    return;
  }
  NCOM::CPropVariant prop;
  if (_folder->GetProperty(itemIndex, kpidName, &prop) != S_OK)
    throw 2723400;
  if (prop.vt != VT_BSTR)
    throw 2723401;
  s.SetFromBstr(prop.bstrVal);
}

UString CPanel::GetItemPrefix(int itemIndex) const
{
  if (itemIndex == kParentIndex)
    return UString();
  NCOM::CPropVariant prop;
  if (_folder->GetProperty(itemIndex, kpidPrefix, &prop) != S_OK)
    throw 2723400;
  UString prefix;
  if (prop.vt == VT_BSTR)
    prefix.SetFromBstr(prop.bstrVal);
  return prefix;
}

UString CPanel::GetItemRelPath(int itemIndex) const
{
  return GetItemPrefix(itemIndex) + GetItemName(itemIndex);
}

UString CPanel::GetItemRelPath2(int itemIndex) const
{
  UString s = GetItemRelPath(itemIndex);
  #if defined(_WIN32) && !defined(UNDER_CE)
  if (s.Len() == 2 && NFile::NName::IsDrivePath2(s))
  {
    if (IsFSDrivesFolder() && !IsDeviceDrivesPrefix())
      s.Add_PathSepar();
  }
  #endif
  return s;
}

UString CPanel::GetItemFullPath(int itemIndex) const
{
  return GetFsPath() + GetItemRelPath2(itemIndex);
}

bool CPanel::GetItem_BoolProp(UInt32 itemIndex, PROPID propID) const
{
  NCOM::CPropVariant prop;
  if (_folder->GetProperty(itemIndex, propID, &prop) != S_OK)
    throw 2723400;
  if (prop.vt == VT_BOOL)
    return VARIANT_BOOLToBool(prop.boolVal);
  if (prop.vt == VT_EMPTY)
    return false;
  throw 2723401;
}

bool CPanel::IsItem_Deleted(int itemIndex) const
{
  if (itemIndex == kParentIndex)
    return false;
  return GetItem_BoolProp(itemIndex, kpidIsDeleted);
}

bool CPanel::IsItem_Folder(int itemIndex) const
{
  if (itemIndex == kParentIndex)
    return true;
  return GetItem_BoolProp(itemIndex, kpidIsDir);
}

bool CPanel::IsItem_AltStream(int itemIndex) const
{
  if (itemIndex == kParentIndex)
    return false;
  return GetItem_BoolProp(itemIndex, kpidIsAltStream);
}

UInt64 CPanel::GetItemSize(int itemIndex) const
{
  if (itemIndex == kParentIndex)
    return 0;
  if (_folderGetItemName)
    return _folderGetItemName->GetItemSize(itemIndex);
  NCOM::CPropVariant prop;
  if (_folder->GetProperty(itemIndex, kpidSize, &prop) != S_OK)
    throw 2723400;
  UInt64 val = 0;
  if (ConvertPropVariantToUInt64(prop, val))
    return val;
  return 0;
}

void CPanel::ReadListViewInfo()
{
  _typeIDString = GetFolderTypeID();
  if (!_typeIDString.IsEmpty())
    _listViewInfo.Read(_typeIDString);
}

void CPanel::SaveListViewInfo()
{
  unsigned i;

  printf("CPanel::SaveListViewInfo - BEGIN\n");
  for (i = 0; i < _visibleProperties.Size(); i++)
  {
    CItemProperty &prop = _visibleProperties[i];
    LVCOLUMN winColumnInfo;
    winColumnInfo.mask = LVCF_ORDER | LVCF_WIDTH;
    if (!_listView.GetColumn(i, &winColumnInfo))
      throw 1;
    // FIXME printf("CPanel::SaveListViewInfo - i=%d  ID=%d Order=%d => %d\n",i,prop.ID,prop.Order,winColumnInfo.iOrder);
    // FIXME prop.Order = winColumnInfo.iOrder;  winColumnInfo.iOrder not set with _listView.GetColumn
    prop.Width = winColumnInfo.cx;
  }
  printf("CPanel::SaveListViewInfo - END\n");

  CListViewInfo viewInfo;

  // PROPID sortPropID = _properties[_sortIndex].ID;
  PROPID sortPropID = _sortID;

  _visibleProperties.Sort();

  for (i = 0; i < _visibleProperties.Size(); i++)
  {
    const CItemProperty &prop = _visibleProperties[i];
    CColumnInfo columnInfo;
    columnInfo.IsVisible = prop.IsVisible;
    columnInfo.PropID = prop.ID;
    columnInfo.Width = prop.Width;
    viewInfo.Columns.Add(columnInfo);
  }

  for (i = 0; i < _properties.Size(); i++)
  {
    const CItemProperty &prop = _properties[i];
    if (!prop.IsVisible)
    {
      CColumnInfo columnInfo;
      columnInfo.IsVisible = prop.IsVisible;
      columnInfo.PropID = prop.ID;
      columnInfo.Width = prop.Width;
      viewInfo.Columns.Add(columnInfo);
    }
  }

  viewInfo.SortID = sortPropID;
  viewInfo.Ascending = _ascending;
  if (!_listViewInfo.IsEqual(viewInfo))
  {
    viewInfo.Save(_typeIDString);
    _listViewInfo = viewInfo;
  }
}

#ifdef _WIN32
bool CPanel::OnRightClick(MY_NMLISTVIEW_NMITEMACTIVATE *itemActiveate, LRESULT &result)
{
  if (itemActiveate->hdr.hwndFrom == HWND(_listView))
    return false;
  POINT point;
  ::GetCursorPos(&point);
  ShowColumnsContextMenu(point.x, point.y);
  result = TRUE;
  return true;
}

void CPanel::ShowColumnsContextMenu(int x, int y)
{
  CMenu menu;
  CMenuDestroyer menuDestroyer(menu);

  menu.CreatePopup();

  const int kCommandStart = 100;
  FOR_VECTOR (i, _properties)
  {
    const CItemProperty &prop = _properties[i];
    UINT flags =  MF_STRING;
    if (prop.IsVisible)
      flags |= MF_CHECKED;
    if (i == 0)
      flags |= MF_GRAYED;
    menu.AppendItem(flags, kCommandStart + i, prop.Name);
  }

  int menuResult = menu.Track(TPM_LEFTALIGN | TPM_RETURNCMD | TPM_NONOTIFY, x, y, _listView);

  if (menuResult >= kCommandStart && menuResult <= kCommandStart + (int)_properties.Size())
  {
    int index = menuResult - kCommandStart;
    CItemProperty &prop = _properties[index];
    prop.IsVisible = !prop.IsVisible;

    if (prop.IsVisible)
    {
      unsigned num = _visibleProperties.Size();
      prop.Order = num;
      _visibleProperties.Add(prop);
      InsertColumn(num);
    }
    else
    {
      int visibleIndex = _visibleProperties.FindItemWithID(prop.ID);
      if (visibleIndex >= 0)
      {
        _visibleProperties.Delete(visibleIndex);
        /*
        if (_sortIndex == index)
        {
        _sortIndex = 0;
        _ascending = true;
        }
        */
        if (_sortID == prop.ID)
        {
          _sortID = kpidName;
          _ascending = true;
        }

        _listView.DeleteColumn(visibleIndex);
      }
    }
  }
}
#endif

void CPanel::OnReload()
{
  HRESULT res = RefreshListCtrlSaveFocused();
  if (res != S_OK)
    MessageBoxError(res);
}

void CPanel::OnTimer()
{
  if (!_processTimer)
    return;
  if (!AutoRefresh_Mode)
    return;
  CMyComPtr<IFolderWasChanged> folderWasChanged;
  if (_folder.QueryInterface(IID_IFolderWasChanged, &folderWasChanged) != S_OK)
    return;
  Int32 wasChanged;
  if (folderWasChanged->WasChanged(&wasChanged) != S_OK)
    return;
  if (wasChanged == 0)
    return;
  OnReload();
}
// PanelListNotify.cpp

#include "StdAfx.h"

#include "resource.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/PropVariant.h"
#include "../../../Windows/PropVariantConv.h"

#include "../Common/PropIDUtils.h"
#include "../../PropID.h"

#include "App.h"
#include "Panel.h"
#include "FormatUtils.h"

using namespace NWindows;

#define INT_TO_STR_SPEC(v) \
  while (v >= 10) { temp[i++] = (unsigned char)('0' + (unsigned)(v % 10)); v /= 10; } \
  *s++ = (unsigned char)('0' + (unsigned)v);

static void ConvertSizeToString(UInt64 val, wchar_t *s) throw()
{
  unsigned char temp[32];
  unsigned i = 0;

  if (val <= (UInt32)0xFFFFFFFF)
  {
    UInt32 val32 = (UInt32)val;
    INT_TO_STR_SPEC(val32)
  }
  else
  {
    INT_TO_STR_SPEC(val)
  }

  if (i < 3)
  {
    if (i != 0)
    {
      *s++ = temp[i - 1];
      if (i == 2)
        *s++ = temp[0];
    }
    *s = 0;
    return;
  }

  unsigned r = i % 3;
  if (r != 0)
  {
    s[0] = temp[--i];
    if (r == 2)
      s[1] = temp[--i];
    s += r;
  }

  do
  {
    s[0] = ' ';
    s[1] = temp[i - 1];
    s[2] = temp[i - 2];
    s[3] = temp[i - 3];
    s += 4;
  }
  while (i -= 3);

  *s = 0;
}

UString ConvertSizeToString(UInt64 value)
{
  wchar_t s[32];
  ConvertSizeToString(value, s);
  return s;
}

static inline unsigned GetHex(unsigned v)
{
  return (v < 10) ? ('0' + v) : ('A' + (v - 10));
}

/*
static void HexToString(char *dest, const Byte *data, UInt32 size)
{
  for (UInt32 i = 0; i < size; i++)
  {
    unsigned b = data[i];
    dest[0] = GetHex((b >> 4) & 0xF);
    dest[1] = GetHex(b & 0xF);
    dest += 2;
  }
  *dest = 0;
}
*/

bool IsSizeProp(UINT propID) throw()
{
  switch (propID)
  {
    case kpidSize:
    case kpidPackSize:
    case kpidNumSubDirs:
    case kpidNumSubFiles:
    case kpidOffset:
    case kpidLinks:
    case kpidNumBlocks:
    case kpidNumVolumes:
    case kpidPhySize:
    case kpidHeadersSize:
    case kpidTotalSize:
    case kpidFreeSpace:
    case kpidClusterSize:
    case kpidNumErrors:
    case kpidNumStreams:
    case kpidNumAltStreams:
    case kpidAltStreamsSize:
    case kpidVirtualSize:
    case kpidUnpackSize:
    case kpidTotalPhySize:
    case kpidTailSize:
    case kpidEmbeddedStubSize:
      return true;
  }
  return false;
}

LRESULT CPanel::SetItemText(LVITEMW &item)
{
  if (_dontShowMode)
    return 0;
  UInt32 realIndex = GetRealIndex(item);

  /*
  if ((item.mask & LVIF_IMAGE) != 0)
  {
    bool defined  = false;
    CComPtr<IFolderGetSystemIconIndex> folderGetSystemIconIndex;
    _folder.QueryInterface(&folderGetSystemIconIndex);
    if (folderGetSystemIconIndex)
    {
      folderGetSystemIconIndex->GetSystemIconIndex(index, &item.iImage);
      defined = (item.iImage > 0);
    }
    if (!defined)
    {
      NCOM::CPropVariant prop;
      _folder->GetProperty(index, kpidAttrib, &prop);
      UINT32 attrib = 0;
      if (prop.vt == VT_UI4)
        attrib = prop.ulVal;
      else if (IsItemFolder(index))
        attrib |= FILE_ATTRIBUTE_DIRECTORY;
      if (_currentFolderPrefix.IsEmpty())
        throw 1;
      else
        item.iImage = _extToIconMap.GetIconIndex(attrib, GetSystemString(GetItemName(index)));
    }
    // item.iImage = 1;
  }
  */

  if ((item.mask & LVIF_TEXT) == 0)
    return 0;

  LPWSTR text = item.pszText;

  if (item.cchTextMax > 0)
    text[0] = 0;

  if (item.cchTextMax <= 1)
    return 0;

  const CItemProperty &property = _visibleProperties[item.iSubItem];
  PROPID propID = property.ID;

  if (realIndex == kParentIndex)
  {
    if (propID == kpidName)
    {
      if (item.cchTextMax > 2)
      {
        text[0] = '.';
        text[1] = '.';
        text[2] = 0;
      }
    }
    return 0;
  }


  if (property.IsRawProp)
  {
    const void *data;
    UInt32 dataSize;
    UInt32 propType;
    RINOK(_folderRawProps->GetRawProp(realIndex, propID, &data, &dataSize, &propType));
    unsigned limit = item.cchTextMax - 1;
    if (dataSize == 0)
    {
      text[0] = 0;
      return 0;
    }

#ifdef _WIN32
    if (propID == kpidNtReparse)
    {
      UString s;
      ConvertNtReparseToString((const Byte *)data, dataSize, s);
      if (!s.IsEmpty())
      {
        unsigned i;
        for (i = 0; i < limit; i++)
        {
          wchar_t c = s[i];
          if (c == 0)
            break;
          text[i] = c;
        }
        text[i] = 0;
        return 0;
      }
    }
#endif
    else if (propID == kpidNtSecure)
    {
      AString s;
      ConvertNtSecureToString((const Byte *)data, dataSize, s);
      if (!s.IsEmpty())
      {
        unsigned i;
        for (i = 0; i < limit; i++)
        {
          wchar_t c = (Byte)s[i];
          if (c == 0)
            break;
          text[i] = c;
        }
        text[i] = 0;
        return 0;
      }
    }
    {
      const unsigned kMaxDataSize = 64;
      if (dataSize > kMaxDataSize)
      {
        char temp[32];
        MyStringCopy(temp, "data:");
        ConvertUInt32ToString(dataSize, temp + 5);
        unsigned i;
        for (i = 0; i < limit; i++)
        {
          wchar_t c = (Byte)temp[i];
          if (c == 0)
            break;
          text[i] = c;
        }
        text[i] = 0;
      }
      else
      {
        if (dataSize > limit)
          dataSize = limit;
        WCHAR *dest = text;
        for (UInt32 i = 0; i < dataSize; i++)
        {
          unsigned b = ((const Byte *)data)[i];
          dest[0] = (WCHAR)GetHex((b >> 4) & 0xF);
          dest[1] = (WCHAR)GetHex(b & 0xF);
          dest += 2;
        }
        *dest = 0;
      }
    }
    return 0;
  }
  /*
  {
    NCOM::CPropVariant prop;
    if (propID == kpidType)
      string = GetFileType(index);
    else
    {
      HRESULT result = m_ArchiveFolder->GetProperty(index, propID, &prop);
      if (result != S_OK)
      {
        // PrintMessage("GetPropertyValue error");
        return 0;
      }
      string = ConvertPropertyToString(prop, propID, false);
    }
  }
  */
  // const NFind::CFileInfo &aFileInfo = m_Files[index];

  NCOM::CPropVariant prop;
  /*
  bool needRead = true;
  if (propID == kpidSize)
  {
    CComPtr<IFolderGetItemFullSize> getItemFullSize;
    if (_folder.QueryInterface(&getItemFullSize) == S_OK)
    {
      if (getItemFullSize->GetItemFullSize(index, &prop) == S_OK)
        needRead = false;
    }
  }
  if (needRead)
  */

  if (item.cchTextMax < 32)
    return 0;

  if (propID == kpidName)
  {
    if (_folderGetItemName)
    {
      const wchar_t *name = NULL;
      unsigned nameLen = 0;
      _folderGetItemName->GetItemName(realIndex, &name, &nameLen);

      if (name)
      {
        unsigned dest = 0;
        unsigned limit = item.cchTextMax - 1;

        for (unsigned i = 0; dest < limit;)
        {
          wchar_t c = name[i++];
          if (c == 0)
            break;
          text[dest++] = c;

          if (c != ' ')
          {
            if (c != 0x202E) // RLO
              continue;
            text[dest - 1] = '_';
            continue;
          }

          if (name[i + 1] != ' ')
            continue;

          unsigned t = 2;
          for (; name[i + t] == ' '; t++);

          if (t >= 4 && dest + 4 <= limit)
          {
            text[dest++] = '.';
            text[dest++] = '.';
            text[dest++] = '.';
            text[dest++] = ' ';
            i += t;
          }
        }

        text[dest] = 0;
        return 0;
      }
    }
  }

  if (propID == kpidPrefix)
  {
    if (_folderGetItemName)
    {
      const wchar_t *name = NULL;
      unsigned nameLen = 0;
      _folderGetItemName->GetItemPrefix(realIndex, &name, &nameLen);
      if (name)
      {
        unsigned dest = 0;
        unsigned limit = item.cchTextMax - 1;
        for (unsigned i = 0; dest < limit;)
        {
          wchar_t c = name[i++];
          if (c == 0)
            break;
          text[dest++] = c;
        }
        text[dest] = 0;
        return 0;
      }
    }
  }

  HRESULT res = _folder->GetProperty(realIndex, propID, &prop);

  if (res != S_OK)
  {
    MyStringCopy(text, L"Error: ");
    // s = UString(L"Error: ") + HResultToMessage(res);
  }
  else if ((prop.vt == VT_UI8 || prop.vt == VT_UI4 || prop.vt == VT_UI2) && IsSizeProp(propID))
  {
    UInt64 v = 0;
    ConvertPropVariantToUInt64(prop, v);
    ConvertSizeToString(v, text);
  }
  else if (prop.vt == VT_BSTR)
  {
    unsigned limit = item.cchTextMax - 1;
    const wchar_t *src = prop.bstrVal;
    unsigned i;
    for (i = 0; i < limit; i++)
    {
      wchar_t c = src[i];
      if (c == 0) break;
      if (c == 0xA) c = ' ';
      if (c == 0xD) c = ' ';
      text[i] = c;
    }
    text[i] = 0;
  }
  else
  {
    char temp[64];
    ConvertPropertyToShortString(temp, prop, propID, false);
    unsigned i;
    unsigned limit = item.cchTextMax - 1;
    for (i = 0; i < limit; i++)
    {
      wchar_t c = (Byte)temp[i];
      if (c == 0)
        break;
      text[i] = c;
    }
    text[i] = 0;
  }

  return 0;
}

#ifndef UNDER_CE
extern DWORD g_ComCtl32Version;
#endif

void CPanel::OnItemChanged(NMLISTVIEW *item)
{
  int index = (int)item->lParam;
  if (index == kParentIndex)
    return;
  bool oldSelected = (item->uOldState & LVIS_SELECTED) != 0;
  bool newSelected = (item->uNewState & LVIS_SELECTED) != 0;
  // Don't change this code. It works only with such check
  if (oldSelected != newSelected)
  {
      printf("CPanel::OnItemChanged : _selectedStatusVector[%d]= %d %d => %d\n",index,_selectedStatusVector[index],oldSelected,newSelected);
    _selectedStatusVector[index] = newSelected;
  }
}

extern bool g_LVN_ITEMACTIVATE_Support;

void CPanel::OnNotifyActivateItems()
{
#ifdef _WIN32
  bool alt = IsKeyDown(VK_MENU);
  bool ctrl = IsKeyDown(VK_CONTROL);
  bool shift = IsKeyDown(VK_SHIFT);
  if (!shift && alt && !ctrl)
    Properties();
  else
    OpenSelectedItems(!shift || alt || ctrl);
#else
    OpenSelectedItems(true);
#endif
}

bool CPanel::OnNotifyList(LPNMHDR header, LRESULT &result)
{
  switch (header->code)
  {
    case LVN_ITEMCHANGED:
    {
      if (_enableItemChangeNotify)
      {
        if (!_mySelectMode)
          OnItemChanged((LPNMLISTVIEW)header);

        // Post_Refresh_StatusBar();
        /* 9.26: we don't call Post_Refresh_StatusBar.
           it was very slow if we select big number of files
           and then clead slection by selecting just new file.
           probably it called slow Refresh_StatusBar for each item deselection.
           I hope Refresh_StatusBar still will be called for each key / mouse action.
        */
      }
      return false;
    }
    /*

    case LVN_ODSTATECHANGED:
      {
      break;
      }
    */

#ifdef _WIN32
    case LVN_GETDISPINFOW:
    {
      LV_DISPINFOW *dispInfo = (LV_DISPINFOW *)header;

      //is the sub-item information being requested?

      if ((dispInfo->item.mask & LVIF_TEXT) != 0 ||
        (dispInfo->item.mask & LVIF_IMAGE) != 0)
        SetItemText(dispInfo->item);
      return false;
    }
    case LVN_KEYDOWN:
    {
      LPNMLVKEYDOWN keyDownInfo = LPNMLVKEYDOWN(header);
      bool boolResult = OnKeyDown(keyDownInfo, result);
      switch (keyDownInfo->wVKey)
      {
        case VK_CONTROL:
        case VK_SHIFT:
        case VK_MENU:
          break;
        default:
          Post_Refresh_StatusBar();
      }
      return boolResult;
    }
#endif

    case LVN_COLUMNCLICK:
      OnColumnClick(LPNMLISTVIEW(header));
      return false;

#ifdef _WIN32
    case LVN_ITEMACTIVATE:
      if (g_LVN_ITEMACTIVATE_Support)
      {
        OnNotifyActivateItems();
        return false;
      }
      break;
#endif
    case NM_DBLCLK:
    // FIXME case NM_RETURN:
      // FIXME if (!g_LVN_ITEMACTIVATE_Support)
      {
        OnNotifyActivateItems();
        return false;
      }
      break;

#ifdef _WIN32
    case NM_RCLICK:
      Post_Refresh_StatusBar();
      break;

    /*
      return OnRightClick((LPNMITEMACTIVATE)header, result);
    */
      /*
      case NM_CLICK:
      SendRefreshStatusBarMessage();
      return 0;

        // TODO : Handler default action...
        return 0;
        case LVN_ITEMCHANGED:
        {
        NMLISTVIEW *pNMLV = (NMLISTVIEW *) lpnmh;
        SelChange(pNMLV);
        return TRUE;
        }
        case NM_SETFOCUS:
        return onSetFocus(NULL);
        case NM_KILLFOCUS:
        return onKillFocus(NULL);
      */
    case NM_CLICK:
    {
      // we need SetFocusToList, if we drag-select items from other panel.
      SetFocusToList();
      Post_Refresh_StatusBar();
      if (_mySelectMode)
        #ifndef UNDER_CE
        if (g_ComCtl32Version >= MAKELONG(71, 4))
        #endif
          OnLeftClick((MY_NMLISTVIEW_NMITEMACTIVATE *)header);
      return false;
    }
    case LVN_BEGINLABELEDITW:
      result = OnBeginLabelEdit((LV_DISPINFOW *)header);
      return true;
    case LVN_ENDLABELEDITW:
      result = OnEndLabelEdit((LV_DISPINFOW *)header);
      return true;

    case NM_CUSTOMDRAW:
    {
      if (_mySelectMode || (_markDeletedItems && _thereAreDeletedItems))
        return OnCustomDraw((LPNMLVCUSTOMDRAW)header, result);
      break;
    }
    case LVN_BEGINDRAG:
    {
      OnDrag((LPNMLISTVIEW)header);
      Post_Refresh_StatusBar();
      break;
    }
    // case LVN_BEGINRDRAG:
#endif
  }
  return false;
}

#ifdef _WIN32
bool CPanel::OnCustomDraw(LPNMLVCUSTOMDRAW lplvcd, LRESULT &result)
{
  switch (lplvcd->nmcd.dwDrawStage)
  {
  case CDDS_PREPAINT :
    result = CDRF_NOTIFYITEMDRAW;
    return true;

  case CDDS_ITEMPREPAINT:
    /*
    SelectObject(lplvcd->nmcd.hdc,
    GetFontForItem(lplvcd->nmcd.dwItemSpec,
    lplvcd->nmcd.lItemlParam) );
    lplvcd->clrText = GetColorForItem(lplvcd->nmcd.dwItemSpec,
    lplvcd->nmcd.lItemlParam);
    lplvcd->clrTextBk = GetBkColorForItem(lplvcd->nmcd.dwItemSpec,
    lplvcd->nmcd.lItemlParam);
    */
    int realIndex = (int)lplvcd->nmcd.lItemlParam;
    lplvcd->clrTextBk = _listView.GetBkColor();
    if (_mySelectMode)
    {
      if (realIndex != kParentIndex && _selectedStatusVector[realIndex])
       lplvcd->clrTextBk = RGB(255, 192, 192);
    }

    if (_markDeletedItems && _thereAreDeletedItems)
    {
      if (IsItem_Deleted(realIndex))
        lplvcd->clrText = RGB(255, 0, 0);
    }
    // lplvcd->clrText = RGB(0, 0, 0);
    // result = CDRF_NEWFONT;
    result = CDRF_NOTIFYITEMDRAW;
    return true;

    // return false;
    // return true;
    /*
    case CDDS_SUBITEM | CDDS_ITEMPREPAINT:
    if (lplvcd->iSubItem == 0)
    {
    // lplvcd->clrText = RGB(255, 0, 0);
    lplvcd->clrTextBk = RGB(192, 192, 192);
    }
    else
    {
    lplvcd->clrText = RGB(0, 0, 0);
    lplvcd->clrTextBk = RGB(255, 255, 255);
    }
    return true;
    */

        /* At this point, you can change the background colors for the item
        and any subitems and return CDRF_NEWFONT. If the list-view control
        is in report mode, you can simply return CDRF_NOTIFYSUBITEMREDRAW
        to customize the item's subitems individually */
  }
  return false;
}
#endif

void CPanel::Refresh_StatusBar()
{
#ifdef _WIN32
  /*
  g_name_cnt++;
  char s[256];
  sprintf(s, "g_name_cnt = %8d", g_name_cnt);
  OutputDebugStringA(s);
  */
  // DWORD dw = GetTickCount();

  CRecordVector<UInt32> indices;
  GetOperatedItemIndices(indices);

  wchar_t temp[32];
  ConvertUInt32ToString(indices.Size(), temp);

  // UString s1 = MyFormatNew(g_App.LangString_N_SELECTED_ITEMS, NumberToString(indices.Size()));
  // UString s1 = MyFormatNew(IDS_N_SELECTED_ITEMS, NumberToString(indices.Size()));
  _statusBar.SetText(0, MyFormatNew(g_App.LangString_N_SELECTED_ITEMS, temp));
  // _statusBar.SetText(0, MyFormatNew(IDS_N_SELECTED_ITEMS, NumberToString(indices.Size())));

  wchar_t selectSizeString[32];
  selectSizeString[0] = 0;

  if (indices.Size() > 0)
  {
    // for (unsigned ttt = 0; ttt < 1000; ttt++) {
    UInt64 totalSize = 0;
    FOR_VECTOR (i, indices)
      totalSize += GetItemSize(indices[i]);
    ConvertSizeToString(totalSize, selectSizeString);
    // }
  }
  _statusBar.SetText(1, selectSizeString);

  int focusedItem = _listView.GetFocusedItem();
  wchar_t sizeString[32];
  sizeString[0] = 0;
  wchar_t dateString[32];
  dateString[0] = 0;
  if (focusedItem >= 0 && _listView.GetSelectedCount() > 0)
  {
    int realIndex = GetRealItemIndex(focusedItem);
    if (realIndex != kParentIndex)
    {
      ConvertSizeToString(GetItemSize(realIndex), sizeString);
      NCOM::CPropVariant prop;
      if (_folder->GetProperty(realIndex, kpidMTime, &prop) == S_OK)
      {
        char dateString2[32];
        dateString2[0] = 0;
        ConvertPropertyToShortString(dateString2, prop, kpidMTime, false);
        for (unsigned i = 0;; i++)
        {
          char c = dateString2[i];
          dateString[i] = (Byte)c;
          if (c == 0)
            break;
        }
      }
    }
  }
  _statusBar.SetText(2, sizeString);
  _statusBar.SetText(3, dateString);

  // _statusBar.SetText(4, nameString);
  // _statusBar2.SetText(1, MyFormatNew(L"{0} bytes", NumberToStringW(totalSize)));
  // }
  /*
  dw = GetTickCount() - dw;
  sprintf(s, "status = %8d ms", dw);
  OutputDebugStringA(s);
  */
#endif
}
#include "StdAfx.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/COM.h"
#include "../../../Windows/Clipboard.h"
#include "../../../Windows/Menu.h"
#include "../../../Windows/PropVariant.h"
#include "../../../Windows/PropVariantConv.h"

#include "../../PropID.h"
#include "../Common/PropIDUtils.h"
#include "../Explorer/ContextMenu.h"

#include "App.h"
#include "LangUtils.h"
#include "MyLoadMenu.h"
#include "PropertyName.h"

#include "resource.h"
#include "PropertyNameRes.h"

using namespace NWindows;

LONG g_DllRefCount = 0;

static const UINT kSevenZipStartMenuID = kMenuCmdID_Plugin_Start;
static const UINT kSystemStartMenuID = kMenuCmdID_Plugin_Start + 100;

void CPanel::InvokeSystemCommand(const char *command)
{
#ifdef _WIN32
  NCOM::CComInitializer comInitializer;
  if (!IsFsOrPureDrivesFolder())
    return;
  CRecordVector<UInt32> operatedIndices;
  GetOperatedItemIndices(operatedIndices);
  if (operatedIndices.IsEmpty())
    return;
  CMyComPtr<IContextMenu> contextMenu;
  if (CreateShellContextMenu(operatedIndices, contextMenu) != S_OK)
    return;

  CMINVOKECOMMANDINFO ci;
  ZeroMemory(&ci, sizeof(ci));
  ci.cbSize = sizeof(CMINVOKECOMMANDINFO);
  ci.hwnd = GetParent();
  ci.lpVerb = command;
  contextMenu->InvokeCommand(&ci);
#else
  printf(" WARNING CPanel::InvokeSystemCommand(%s)\n",command);
#endif
}

static const char *kSeparator = "----------------------------\n";
static const char *kSeparatorSmall = "----\n";
static const char *kPropValueSeparator = ": ";

extern UString ConvertSizeToString(UInt64 value) throw();
bool IsSizeProp(UINT propID) throw();

UString GetOpenArcErrorMessage(UInt32 errorFlags);

static void AddPropertyString(PROPID propID, const wchar_t *nameBSTR,
    const NCOM::CPropVariant &prop, UString &s)
{
  if (prop.vt != VT_EMPTY)
  {
    UString val;

    if (propID == kpidErrorFlags ||
        propID == kpidWarningFlags)
    {
      UInt32 flags = GetOpenArcErrorFlags(prop);
      if (flags == 0)
        return;
      if (flags != 0)
        val = GetOpenArcErrorMessage(flags);
    }
    if (val.IsEmpty())
    if ((prop.vt == VT_UI8 || prop.vt == VT_UI4 || prop.vt == VT_UI2) && IsSizeProp(propID))
    {
      UInt64 v = 0;
      ConvertPropVariantToUInt64(prop, v);
      val = ConvertSizeToString(v);
    }
    else
      ConvertPropertyToString(val, prop, propID);

    if (!val.IsEmpty())
    {
      s += GetNameOfProperty(propID, nameBSTR);
      s.AddAscii(kPropValueSeparator);
      /*
      if (propID == kpidComment)
        s.Add_LF();
      */
      s += val;
      s.Add_LF();
    }
  }
}

static inline char GetHex(Byte value)
{
  return (char)((value < 10) ? ('0' + value) : ('A' + (value - 10)));
}

static const Byte kSpecProps[] =
{
  kpidPath,
  kpidType,
  kpidErrorType,
  kpidError,
  kpidErrorFlags,
  kpidWarning,
  kpidWarningFlags,
  kpidOffset,
  kpidPhySize,
  kpidTailSize
};

void CPanel::Properties()
{
  CMyComPtr<IGetFolderArcProps> getFolderArcProps;
  _folder.QueryInterface(IID_IGetFolderArcProps, &getFolderArcProps);
  if (!getFolderArcProps)
  {
    InvokeSystemCommand("properties");
    return;
  }
  
  {
    UString message;

    CRecordVector<UInt32> operatedIndices;
    GetOperatedItemIndices(operatedIndices);
    if (operatedIndices.Size() == 1)
    {
      UInt32 index = operatedIndices[0];
      // message += L"Item:\n";
      UInt32 numProps;
      if (_folder->GetNumberOfProperties(&numProps) == S_OK)
      {
        for (UInt32 i = 0; i < numProps; i++)
        {
          CMyComBSTR name;
          PROPID propID;
          VARTYPE varType;
          
          if (_folder->GetPropertyInfo(i, &name, &propID, &varType) != S_OK)
            continue;
          
          NCOM::CPropVariant prop;
          if (_folder->GetProperty(index, propID, &prop) != S_OK)
            continue;
          AddPropertyString(propID, name, prop, message);
        }
      }


      if (_folderRawProps)
      {
        _folderRawProps->GetNumRawProps(&numProps);
        for (UInt32 i = 0; i < numProps; i++)
        {
          CMyComBSTR name;
          PROPID propID;
          if (_folderRawProps->GetRawPropInfo(i, &name, &propID) != S_OK)
            continue;

          const void *data;
          UInt32 dataSize;
          UInt32 propType;
          if (_folderRawProps->GetRawProp(index, propID, &data, &dataSize, &propType) != S_OK)
            continue;

          if (dataSize != 0)
          {
            AString s;
            if (propID == kpidNtSecure)
              ConvertNtSecureToString((const Byte *)data, dataSize, s);
            else
            {
              const UInt32 kMaxDataSize = 64;
              if (dataSize > kMaxDataSize)
              {
                char temp[64];
                s += "data:";
                ConvertUInt32ToString(dataSize, temp);
                s += temp;
              }
              else
              {
                for (UInt32 i = 0; i < dataSize; i++)
                {
                  Byte b = ((const Byte *)data)[i];
                  s += GetHex((Byte)((b >> 4) & 0xF));
                  s += GetHex((Byte)(b & 0xF));
                }
              }
            }
            message += GetNameOfProperty(propID, name);
            message.AddAscii(kPropValueSeparator);
            message.AddAscii(s);
            message.Add_LF();
          }
        }
      }

      message.AddAscii(kSeparator);
    }
        
    /*
    AddLangString(message, IDS_PROP_FILE_TYPE);
    message += kPropValueSeparator;
    message += GetFolderTypeID();
    message.Add_LF();
    */

    {
      NCOM::CPropVariant prop;
      if (_folder->GetFolderProperty(kpidPath, &prop) == S_OK)
      {
        AddPropertyString(kpidName, L"Path", prop, message);
      }
    }

    CMyComPtr<IFolderProperties> folderProperties;
    _folder.QueryInterface(IID_IFolderProperties, &folderProperties);
    if (folderProperties)
    {
      UInt32 numProps;
      if (folderProperties->GetNumberOfFolderProperties(&numProps) == S_OK)
      {
        for (UInt32 i = 0; i < numProps; i++)
        {
          CMyComBSTR name;
          PROPID propID;
          VARTYPE vt;
          if (folderProperties->GetFolderPropertyInfo(i, &name, &propID, &vt) != S_OK)
            continue;
          NCOM::CPropVariant prop;
          if (_folder->GetFolderProperty(propID, &prop) != S_OK)
            continue;
          AddPropertyString(propID, name, prop, message);
        }
      }
    }

    CMyComPtr<IGetFolderArcProps> getFolderArcProps;
    _folder.QueryInterface(IID_IGetFolderArcProps, &getFolderArcProps);
    if (getFolderArcProps)
    {
      CMyComPtr<IFolderArcProps> getProps;
      getFolderArcProps->GetFolderArcProps(&getProps);
      if (getProps)
      {
        UInt32 numLevels;
        if (getProps->GetArcNumLevels(&numLevels) != S_OK)
          numLevels = 0;
        for (UInt32 level2 = 0; level2 < numLevels; level2++)
        {
          {
            UInt32 level = numLevels - 1 - level2;
            UInt32 numProps;
            if (getProps->GetArcNumProps(level, &numProps) == S_OK)
            {
              const int kNumSpecProps = ARRAY_SIZE(kSpecProps);

              message.AddAscii(kSeparator);
              
              for (Int32 i = -(int)kNumSpecProps; i < (Int32)numProps; i++)
              {
                CMyComBSTR name;
                PROPID propID;
                VARTYPE vt;
                if (i < 0)
                  propID = kSpecProps[i + kNumSpecProps];
                else if (getProps->GetArcPropInfo(level, i, &name, &propID, &vt) != S_OK)
                  continue;
                NCOM::CPropVariant prop;
                if (getProps->GetArcProp(level, propID, &prop) != S_OK)
                  continue;
                AddPropertyString(propID, name, prop, message);
              }
            }
          }
          
          if (level2 != numLevels - 1)
          {
            UInt32 level = numLevels - 1 - level2;
            UInt32 numProps;
            if (getProps->GetArcNumProps2(level, &numProps) == S_OK)
            {
              message.AddAscii(kSeparatorSmall);
              for (Int32 i = 0; i < (Int32)numProps; i++)
              {
                CMyComBSTR name;
                PROPID propID;
                VARTYPE vt;
                if (getProps->GetArcPropInfo2(level, i, &name, &propID, &vt) != S_OK)
                  continue;
                NCOM::CPropVariant prop;
                if (getProps->GetArcProp2(level, propID, &prop) != S_OK)
                  continue;
                AddPropertyString(propID, name, prop, message);
              }
            }
          }
        }
      }
    }
    ::MessageBoxW(*(this), message, LangString(IDS_PROPERTIES), MB_OK);
  }
}

void CPanel::EditCut()
{
  // InvokeSystemCommand("cut");
}

void CPanel::EditCopy()
{
  /*
  CMyComPtr<IGetFolderArcProps> getFolderArcProps;
  _folder.QueryInterface(IID_IGetFolderArcProps, &getFolderArcProps);
  if (!getFolderArcProps)
  {
    InvokeSystemCommand("copy");
    return;
  }
  */
  UString s;
  CRecordVector<UInt32> indices;
  GetSelectedItemsIndices(indices);
  FOR_VECTOR (i, indices)
  {
    if (i > 0)
      s += L"\xD\n";
    s += GetItemName(indices[i]);
  }
  ClipboardSetText(_mainWindow, s);
}

void CPanel::EditPaste()
{
  /*
  UStringVector names;
  ClipboardGetFileNames(names);
  CopyFromNoAsk(names);
  UString s;
  for (int i = 0; i < names.Size(); i++)
  {
    s += L' ';
    s += names[i];
  }

  MessageBoxW(0, s, L"", 0);
  */

  // InvokeSystemCommand("paste");
}

#ifdef _WIN32
HRESULT CPanel::CreateShellContextMenu(
    const CRecordVector<UInt32> &operatedIndices,
    CMyComPtr<IContextMenu> &systemContextMenu)
{
  systemContextMenu.Release();
  UString folderPath = GetFsPath();

  CMyComPtr<IShellFolder> desktopFolder;
  RINOK(::SHGetDesktopFolder(&desktopFolder));
  if (!desktopFolder)
  {
    // ShowMessage("Failed to get Desktop folder.");
    return E_FAIL;
  }
  
  // Separate the file from the folder.

  
  // Get a pidl for the folder the file
  // is located in.
  LPITEMIDLIST parentPidl;
  DWORD eaten;
  RINOK(desktopFolder->ParseDisplayName(
      GetParent(), 0, (wchar_t *)(const wchar_t *)folderPath,
      &eaten, &parentPidl, 0));
  
  // Get an IShellFolder for the folder
  // the file is located in.
  CMyComPtr<IShellFolder> parentFolder;
  RINOK(desktopFolder->BindToObject(parentPidl,
      0, IID_IShellFolder, (void**)&parentFolder));
  if (!parentFolder)
  {
    // ShowMessage("Invalid file name.");
    return E_FAIL;
  }
  
  // Get a pidl for the file itself.
  CRecordVector<LPITEMIDLIST> pidls;
  pidls.ClearAndReserve(operatedIndices.Size());
  FOR_VECTOR (i, operatedIndices)
  {
    LPITEMIDLIST pidl;
    UString fileName = GetItemRelPath2(operatedIndices[i]);
    RINOK(parentFolder->ParseDisplayName(GetParent(), 0,
      (wchar_t *)(const wchar_t *)fileName, &eaten, &pidl, 0));
    pidls.AddInReserved(pidl);
  }

  ITEMIDLIST temp;
  if (pidls.Size() == 0)
  {
    temp.mkid.cb = 0;
    /*
    LPITEMIDLIST pidl;
    HRESULT result = parentFolder->ParseDisplayName(GetParent(), 0,
      L"." WSTRING_PATH_SEPARATOR, &eaten, &pidl, 0);
    if (result != NOERROR)
      return;
    */
    pidls.Add(&temp);
  }

  // Get the IContextMenu for the file.
  CMyComPtr<IContextMenu> cm;
  RINOK( parentFolder->GetUIObjectOf(GetParent(), pidls.Size(),
      (LPCITEMIDLIST *)&pidls.Front(), IID_IContextMenu, 0, (void**)&cm));
  if (!cm)
  {
    // ShowMessage("Unable to get context menu interface.");
    return E_FAIL;
  }
  systemContextMenu = cm;
  return S_OK;
}

void CPanel::CreateSystemMenu(HMENU menuSpec,
    const CRecordVector<UInt32> &operatedIndices,
    CMyComPtr<IContextMenu> &systemContextMenu)
{
  systemContextMenu.Release();

  CreateShellContextMenu(operatedIndices, systemContextMenu);

  if (systemContextMenu == 0)
    return;
  
  // Set up a CMINVOKECOMMANDINFO structure.
  CMINVOKECOMMANDINFO ci;
  ZeroMemory(&ci, sizeof(ci));
  ci.cbSize = sizeof(CMINVOKECOMMANDINFO);
  ci.hwnd = GetParent();
  
  /*
  if (Sender == GoBtn)
  {
    // Verbs that can be used are cut, paste,
    // properties, delete, and so on.
    String action;
    if (CutRb->Checked)
      action = "cut";
    else if (CopyRb->Checked)
      action = "copy";
    else if (DeleteRb->Checked)
      action = "delete";
    else if (PropertiesRb->Checked)
      action = "properties";
    
    ci.lpVerb = action.c_str();
    result = cm->InvokeCommand(&ci);
    if (result)
      ShowMessage(
      "Error copying file to clipboard.");
    
  }
  else
  */
  {
    // HMENU hMenu = CreatePopupMenu();
    CMenu popupMenu;
    // CMenuDestroyer menuDestroyer(popupMenu);
    if (!popupMenu.CreatePopup())
      throw 210503;

    HMENU hMenu = popupMenu;

    DWORD Flags = CMF_EXPLORE;
    // Optionally the shell will show the extended
    // context menu on some operating systems when
    // the shift key is held down at the time the
    // context menu is invoked. The following is
    // commented out but you can uncommnent this
    // line to show the extended context menu.
    // Flags |= 0x00000080;
    systemContextMenu->QueryContextMenu(hMenu, 0, kSystemStartMenuID, 0x7FFF, Flags);
    

    {
      CMenu menu;
      menu.Attach(menuSpec);
      CMenuItem menuItem;
      menuItem.fMask = MIIM_SUBMENU | MIIM_TYPE | MIIM_ID;
      menuItem.fType = MFT_STRING;
      menuItem.hSubMenu = popupMenu.Detach();
      // menuDestroyer.Disable();
      LangString(IDS_SYSTEM, menuItem.StringValue);
      menu.InsertItem(0, true, menuItem);
    }
    /*
    if (Cmd < 100 && Cmd != 0)
    {
      ci.lpVerb = MAKEINTRESOURCE(Cmd - 1);
      ci.lpParameters = "";
      ci.lpDirectory = "";
      ci.nShow = SW_SHOWNORMAL;
      cm->InvokeCommand(&ci);
    }
    // If Cmd is > 100 then it's one of our
    // inserted menu items.
    else
      // Find the menu item.
      for (int i = 0; i < popupMenu1->Items->Count; i++)
      {
        TMenuItem* menu = popupMenu1->Items->Items[i];
        // Call its OnClick handler.
        if (menu->Command == Cmd - 100)
          menu->OnClick(this);
      }
      // Release the memory allocated for the menu.
      DestroyMenu(hMenu);
    */
  }
}

void CPanel::CreateFileMenu(HMENU menuSpec)
{
  CreateFileMenu(menuSpec, _sevenZipContextMenu, _systemContextMenu, true);
}

void CPanel::CreateSevenZipMenu(HMENU menuSpec,
    const CRecordVector<UInt32> &operatedIndices,
    CMyComPtr<IContextMenu> &sevenZipContextMenu)
{
  sevenZipContextMenu.Release();

  CMenu menu;
  menu.Attach(menuSpec);
  // CMenuDestroyer menuDestroyer(menu);
  // menu.CreatePopup();

  bool sevenZipMenuCreated = false;

  CZipContextMenu *contextMenuSpec = new CZipContextMenu;
  CMyComPtr<IContextMenu> contextMenu = contextMenuSpec;
  // if (contextMenu.CoCreateInstance(CLSID_CZipContextMenu, IID_IContextMenu) == S_OK)
  {
    /*
    CMyComPtr<IInitContextMenu> initContextMenu;
    if (contextMenu.QueryInterface(IID_IInitContextMenu, &initContextMenu) != S_OK)
      return;
    */
    UString currentFolderUnicode = GetFsPath();
    UStringVector names;
    unsigned i;
    for (i = 0; i < operatedIndices.Size(); i++)
      names.Add(currentFolderUnicode + GetItemRelPath2(operatedIndices[i]));
    CRecordVector<const wchar_t *> namePointers;
    for (i = 0; i < operatedIndices.Size(); i++)
      namePointers.Add(names[i]);
    
    // NFile::NDirectory::MySetCurrentDirectory(currentFolderUnicode);
    if (contextMenuSpec->InitContextMenu(currentFolderUnicode, &namePointers.Front(),
        operatedIndices.Size()) == S_OK)
    {
      HRESULT res = contextMenu->QueryContextMenu(menu, 0, kSevenZipStartMenuID,
          kSystemStartMenuID - 1, 0);
      sevenZipMenuCreated = (HRESULT_SEVERITY(res) == SEVERITY_SUCCESS);
      if (sevenZipMenuCreated)
        sevenZipContextMenu = contextMenu;
      // int code = HRESULT_CODE(res);
      // int nextItemID = code;
    }
  }
}

#endif

static bool IsReadOnlyFolder(IFolderFolder *folder)
{
  if (!folder)
    return false;

  bool res = false;
  {
    NCOM::CPropVariant prop;
    if (folder->GetFolderProperty(kpidReadOnly, &prop) == S_OK)
      if (prop.vt == VT_BOOL)
        res = VARIANT_BOOLToBool(prop.boolVal);
  }
  return res;
}

bool CPanel::IsThereReadOnlyFolder() const
{
  if (!_folderOperations)
    return true;
  if (IsReadOnlyFolder(_folder))
    return true;
  FOR_VECTOR (i, _parentFolders)
  {
    if (IsReadOnlyFolder(_parentFolders[i].ParentFolder))
      return true;
  }
  return false;
}

bool CPanel::CheckBeforeUpdate(UINT resourceID)
{
  if (!_folderOperations)
  {
    MessageBoxErrorLang(IDS_OPERATION_IS_NOT_SUPPORTED);
    // resourceID = resourceID;
    // MessageBoxErrorForUpdate(E_NOINTERFACE, resourceID);
    return false;
  }

  for (int i = (int)_parentFolders.Size(); i >= 0; i--)
  {
    IFolderFolder *folder;
    if (i == (int)_parentFolders.Size())
      folder = _folder;
    else
      folder = _parentFolders[i].ParentFolder;
    
    if (!IsReadOnlyFolder(folder))
      continue;
    
    UString s;
    AddLangString(s, resourceID);
    s.Add_LF();
    AddLangString(s, IDS_OPERATION_IS_NOT_SUPPORTED);
    s.Add_LF();
    if (i == 0)
      s += GetFolderPath(folder);
    else
      s += _parentFolders[i - 1].VirtualPath;
    s.Add_LF();
    AddLangString(s, IDS_PROP_READ_ONLY);
    MessageBoxMyError(s);
    return false;
  }

  return true;
}

#ifdef _WIN32
void CPanel::CreateFileMenu(HMENU menuSpec,
    CMyComPtr<IContextMenu> &sevenZipContextMenu,
    CMyComPtr<IContextMenu> &systemContextMenu,
    bool programMenu)
{
  sevenZipContextMenu.Release();
  systemContextMenu.Release();

  CRecordVector<UInt32> operatedIndices;
  GetOperatedItemIndices(operatedIndices);

  CMenu menu;
  menu.Attach(menuSpec);

  if (!IsArcFolder())
  {
    CreateSevenZipMenu(menu, operatedIndices, sevenZipContextMenu);
    // CreateSystemMenu is very slow if you call it inside ZIP archive with big number of files
    // Windows probably can parse items inside ZIP archive.
    if (g_App.ShowSystemMenu)
      CreateSystemMenu(menu, operatedIndices, systemContextMenu);
  }

  /*
  if (menu.GetItemCount() > 0)
    menu.AppendItem(MF_SEPARATOR, 0, (LPCTSTR)0);
  */

  unsigned i;
  for (i = 0; i < operatedIndices.Size(); i++)
    if (IsItem_Folder(operatedIndices[i]))
      break;
  bool allAreFiles = (i == operatedIndices.Size());

  CFileMenu fm;
  
  fm.readOnly = IsThereReadOnlyFolder();
  fm.isFsFolder = Is_IO_FS_Folder();
  fm.programMenu = programMenu;
  fm.allAreFiles = allAreFiles;
  fm.numItems = operatedIndices.Size();

  fm.isAltStreamsSupported = false;
  
  if (_folderAltStreams)
  {
    if (operatedIndices.Size() <= 1)
    {
      Int32 realIndex = -1;
      if (operatedIndices.Size() == 1)
        realIndex = operatedIndices[0];
      Int32 val = 0;
      if (_folderAltStreams->AreAltStreamsSupported(realIndex, &val) == S_OK)
        fm.isAltStreamsSupported = IntToBool(val);
    }
  }
  else
  {
    if (fm.numItems == 0)
      fm.isAltStreamsSupported = IsFSFolder();
    else
      fm.isAltStreamsSupported = IsFolder_with_FsItems();
  }

  fm.Load(menu, menu.GetItemCount());
}

bool CPanel::InvokePluginCommand(int id)
{
  return InvokePluginCommand(id, _sevenZipContextMenu, _systemContextMenu);
}

#if defined(_MSC_VER) && !defined(UNDER_CE)
#define use_CMINVOKECOMMANDINFOEX
#endif

bool CPanel::InvokePluginCommand(int id,
    IContextMenu *sevenZipContextMenu, IContextMenu *systemContextMenu)
{
  UInt32 offset;
  bool isSystemMenu = (id >= kSystemStartMenuID);
  if (isSystemMenu)
    offset = id  - kSystemStartMenuID;
  else
    offset = id  - kSevenZipStartMenuID;

  #ifdef use_CMINVOKECOMMANDINFOEX
    CMINVOKECOMMANDINFOEX
  #else
    CMINVOKECOMMANDINFO
  #endif
      commandInfo;
  
  memset(&commandInfo, 0, sizeof(commandInfo));
  commandInfo.cbSize = sizeof(commandInfo);
  
  commandInfo.fMask = 0
  #ifdef use_CMINVOKECOMMANDINFOEX
    | CMIC_MASK_UNICODE
  #endif
    ;

  commandInfo.hwnd = GetParent();
  commandInfo.lpVerb = (LPCSTR)(MAKEINTRESOURCE(offset));
  commandInfo.lpParameters = NULL;
  CSysString currentFolderSys = GetSystemString(_currentFolderPrefix);
  commandInfo.lpDirectory = (LPCSTR)(LPCTSTR)(currentFolderSys);
  commandInfo.nShow = SW_SHOW;
  
  #ifdef use_CMINVOKECOMMANDINFOEX
  
  commandInfo.lpParametersW = NULL;
  commandInfo.lpTitle = "";
  commandInfo.lpVerbW = (LPCWSTR)(MAKEINTRESOURCEW(offset));
  UString currentFolderUnicode = _currentFolderPrefix;
  commandInfo.lpDirectoryW = currentFolderUnicode;
  commandInfo.lpTitleW = L"";
  // commandInfo.ptInvoke.x = xPos;
  // commandInfo.ptInvoke.y = yPos;
  commandInfo.ptInvoke.x = 0;
  commandInfo.ptInvoke.y = 0;
  
  #endif
  
  HRESULT result;
  if (isSystemMenu)
    result = systemContextMenu->InvokeCommand(LPCMINVOKECOMMANDINFO(&commandInfo));
  else
    result = sevenZipContextMenu->InvokeCommand(LPCMINVOKECOMMANDINFO(&commandInfo));
  if (result == NOERROR)
  {
    KillSelection();
    return true;
  }
  return false;
}

bool CPanel::OnContextMenu(HANDLE windowHandle, int xPos, int yPos)
{
  if (::GetParent((HWND)windowHandle) == _listView)
  {
    ShowColumnsContextMenu(xPos, yPos);
    return true;
  }

  if (windowHandle != _listView)
    return false;
  /*
  POINT point;
  point.x = xPos;
  point.y = yPos;
  if (!_listView.ScreenToClient(&point))
    return false;

  LVHITTESTINFO info;
  info.pt = point;
  int index = _listView.HitTest(&info);
  */

  CRecordVector<UInt32> operatedIndices;
  GetOperatedItemIndices(operatedIndices);

  // negative x,y are possible for multi-screen modes.
  // x=-1 && y=-1 for keyboard call (SHIFT+F10 and others).
  if (xPos == -1 && yPos == -1)
  {
    if (operatedIndices.Size() == 0)
    {
      xPos = 0;
      yPos = 0;
    }
    else
    {
      int itemIndex = _listView.GetNextItem(-1, LVNI_FOCUSED);
      if (itemIndex == -1)
        return false;
      RECT rect;
      if (!_listView.GetItemRect(itemIndex, &rect, LVIR_ICON))
        return false;
      xPos = (rect.left + rect.right) / 2;
      yPos = (rect.top + rect.bottom) / 2;
    }
    POINT point = {xPos, yPos};
    _listView.ClientToScreen(&point);
    xPos = point.x;
    yPos = point.y;
  }

  CMenu menu;
  CMenuDestroyer menuDestroyer(menu);
  menu.CreatePopup();

  CMyComPtr<IContextMenu> sevenZipContextMenu;
  CMyComPtr<IContextMenu> systemContextMenu;
  CreateFileMenu(menu, sevenZipContextMenu, systemContextMenu, false);

  int result = menu.Track(TPM_LEFTALIGN
      #ifndef UNDER_CE
      | TPM_RIGHTBUTTON
      #endif
      | TPM_RETURNCMD | TPM_NONOTIFY,
    xPos, yPos, _listView);

  if (result == 0)
    return true;

  if (result >= kMenuCmdID_Plugin_Start)
  {
    InvokePluginCommand(result, sevenZipContextMenu, systemContextMenu);
    return true;
  }
  if (ExecuteFileCommand(result))
    return true;
  return true;
}
#endif

// PanelOperations.cpp

#include "StdAfx.h"

#include "../../../Common/DynamicBuffer.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/Wildcard.h"

#include "../../../Windows/COM.h"
#include "../../../Windows/FileName.h"
#include "../../../Windows/PropVariant.h"

#include "ComboDialog.h"

#include "FSFolder.h"
#include "FormatUtils.h"
#include "LangUtils.h"
#include "Panel.h"
#include "UpdateCallback100.h"

#include "resource.h"

using namespace NWindows;
using namespace NFile;
using namespace NName;

#ifndef _UNICODE
extern bool g_IsNT;
#endif

enum EFolderOpType
{
  FOLDER_TYPE_CREATE_FOLDER = 0,
  FOLDER_TYPE_DELETE = 1,
  FOLDER_TYPE_RENAME = 2
};

class CThreadFolderOperations: public CProgressThreadVirt
{
  HRESULT ProcessVirt();
public:
  EFolderOpType OpType;
  UString Name;
  UInt32 Index;
  CRecordVector<UInt32> Indices;

  CMyComPtr<IFolderOperations> FolderOperations;
  CMyComPtr<IProgress> UpdateCallback;
  CUpdateCallback100Imp *UpdateCallbackSpec;
  
  HRESULT Result;

  CThreadFolderOperations(EFolderOpType opType): OpType(opType), Result(E_FAIL) {}
  HRESULT DoOperation(CPanel &panel, const UString &progressTitle, const UString &titleError);
};
  
HRESULT CThreadFolderOperations::ProcessVirt()
{
  // FIXME NCOM::CComInitializer comInitializer;
  switch(OpType)
  {
    case FOLDER_TYPE_CREATE_FOLDER:
      Result = FolderOperations->CreateFolder(Name, UpdateCallback);
      break;
    case FOLDER_TYPE_DELETE:
      Result = FolderOperations->Delete(&Indices.Front(), Indices.Size(), UpdateCallback);
      break;
    case FOLDER_TYPE_RENAME:
      Result = FolderOperations->Rename(Index, Name, UpdateCallback);
      break;
    default:
      Result = E_FAIL;
  }
  return Result;
}


HRESULT CThreadFolderOperations::DoOperation(CPanel &panel, const UString &progressTitle, const UString &titleError)
{
  UpdateCallbackSpec = new CUpdateCallback100Imp;
  UpdateCallback = UpdateCallbackSpec;
  UpdateCallbackSpec->ProgressDialog = &ProgressDialog;

  // FIXME ProgressDialog.WaitMode = true;
  ProgressDialog.Sync.FinalMessage.ErrorMessage.Title = titleError;
  Result = S_OK;

  UpdateCallbackSpec->Init();

  if (panel._parentFolders.Size() > 0)
  {
    const CFolderLink &fl = panel._parentFolders.Back();
    UpdateCallbackSpec->PasswordIsDefined = fl.UsePassword;
    UpdateCallbackSpec->Password = fl.Password;
  }


  ProgressDialog.MainWindow = panel._mainWindow; // panel.GetParent()
  ProgressDialog.MainTitle = L"7-Zip"; // LangString(IDS_APP_TITLE);
  ProgressDialog.MainAddTitle = progressTitle + L' ';

  RINOK(Create(progressTitle, ProgressDialog.MainWindow));
  return Result;
}

#ifndef _UNICODE
typedef int (WINAPI * SHFileOperationWP)(LPSHFILEOPSTRUCTW lpFileOp);
#endif

/*
void CPanel::MessageBoxErrorForUpdate(HRESULT errorCode, UINT resourceID)
{
  if (errorCode == E_NOINTERFACE)
    MessageBoxErrorLang(IDS_OPERATION_IS_NOT_SUPPORTED);
  else
    MessageBoxError(errorCode, LangString(resourceID));
}
*/

void CPanel::DeleteItems(bool NON_CE_VAR(toRecycleBin))
{
  CDisableTimerProcessing disableTimerProcessing(*this);
  CRecordVector<UInt32> indices;
  GetOperatedItemIndices(indices);
  if (indices.IsEmpty())
    return;
  CSelectedState state;
  SaveSelectedState(state);

  #ifndef UNDER_CE
  // WM6 / SHFileOperationW doesn't ask user! So we use internal delete
  if (IsFSFolder() && toRecycleBin)
  {
    bool useInternalDelete = false;
    #ifndef _UNICODE
    if (!g_IsNT)
    {
      CDynamicBuffer<CHAR> buffer;
      FOR_VECTOR (i, indices)
      {
        const AString path = GetSystemString(GetItemFullPath(indices[i]));
        buffer.AddData(path, path.Len() + 1);
      }
      *buffer.GetCurPtrAndGrow(1) = 0;
      SHFILEOPSTRUCTA fo;
      fo.hwnd = GetParent();
      fo.wFunc = FO_DELETE;
      fo.pFrom = (const CHAR *)buffer;
      fo.pTo = 0;
      fo.fFlags = 0;
      if (toRecycleBin)
        fo.fFlags |= FOF_ALLOWUNDO;
      // fo.fFlags |= FOF_NOCONFIRMATION;
      // fo.fFlags |= FOF_NOERRORUI;
      // fo.fFlags |= FOF_SILENT;
      // fo.fFlags |= FOF_WANTNUKEWARNING;
      fo.fAnyOperationsAborted = FALSE;
      fo.hNameMappings = 0;
      fo.lpszProgressTitle = 0;
      /* int res = */ ::SHFileOperationA(&fo);
    }
    else
    #endif
    {
      CDynamicBuffer<WCHAR> buffer;
      unsigned maxLen = 0;
      const UString prefix = GetFsPath();
      FOR_VECTOR (i, indices)
      {
        // L"\\\\?\\") doesn't work here.
        const UString path = prefix + GetItemRelPath2(indices[i]);
        if (path.Len() > maxLen)
          maxLen = path.Len();
        buffer.AddData(path, path.Len() + 1);
      }
      *buffer.GetCurPtrAndGrow(1) = 0;
#ifdef _WIN32
      if (maxLen >= MAX_PATH)
      {
        if (toRecycleBin)
        {
          MessageBoxErrorLang(IDS_ERROR_LONG_PATH_TO_RECYCLE);
          return;
        }
        useInternalDelete = true;
      }
      else
      {
        SHFILEOPSTRUCTW fo;
        fo.hwnd = GetParent();
        fo.wFunc = FO_DELETE;
        fo.pFrom = (const WCHAR *)buffer;
        fo.pTo = 0;
        fo.fFlags = 0;
        if (toRecycleBin)
          fo.fFlags |= FOF_ALLOWUNDO;
        fo.fAnyOperationsAborted = FALSE;
        fo.hNameMappings = 0;
        fo.lpszProgressTitle = 0;
        // int res;
        #ifdef _UNICODE
        /* res = */ ::SHFileOperationW(&fo);
        #else
        SHFileOperationWP shFileOperationW = (SHFileOperationWP)
          ::GetProcAddress(::GetModuleHandleW(L"shell32.dll"), "SHFileOperationW");
        if (shFileOperationW == 0)
          return;
        /* res = */ shFileOperationW(&fo);
        #endif
      }
#else
      // FIXME - how to use the recycle bin undex Gnome or KDE ?
      useInternalDelete = true;
#endif
    }
    /*
    if (fo.fAnyOperationsAborted)
      MessageBoxError(result, LangString(IDS_ERROR_DELETING, 0x03020217));
    */
    if (!useInternalDelete)
    {
      RefreshListCtrl(state);
      return;
    }
  }
  #endif
 
  // DeleteItemsInternal

  if (!CheckBeforeUpdate(IDS_ERROR_DELETING))
    return;

  UInt32 titleID, messageID;
  UString messageParam;
  if (indices.Size() == 1)
  {
    int index = indices[0];
    messageParam = GetItemRelPath2(index);
    if (IsItem_Folder(index))
    {
      titleID = IDS_CONFIRM_FOLDER_DELETE;
      messageID = IDS_WANT_TO_DELETE_FOLDER;
    }
    else
    {
      titleID = IDS_CONFIRM_FILE_DELETE;
      messageID = IDS_WANT_TO_DELETE_FILE;
    }
  }
  else
  {
    titleID = IDS_CONFIRM_ITEMS_DELETE;
    messageID = IDS_WANT_TO_DELETE_ITEMS;
    messageParam = NumberToString(indices.Size());
  }
  if (::MessageBoxW(GetParent(), MyFormatNew(messageID, messageParam), LangString(titleID), MB_OKCANCEL | MB_ICONQUESTION) != IDOK)
    return;

  CDisableNotify disableNotify(*this);
  {
    CThreadFolderOperations op(FOLDER_TYPE_DELETE);
    op.FolderOperations = _folderOperations;
    op.Indices = indices;
    op.DoOperation(*this,
        LangString(IDS_DELETING),
        LangString(IDS_ERROR_DELETING));
  }
  RefreshTitleAlways();
  RefreshListCtrl(state);
}

#ifdef _WIN32
BOOL CPanel::OnBeginLabelEdit(LV_DISPINFOW * lpnmh)
{
  int realIndex = GetRealIndex(lpnmh->item);
  if (realIndex == kParentIndex)
    return TRUE;
  if (IsThereReadOnlyFolder())
    return TRUE;
  return FALSE;
}
#endif

bool IsCorrectFsName(const UString &name)
{
  const UString lastPart = name.Ptr(name.ReverseFind_PathSepar() + 1);
  return
      lastPart != L"." &&
      lastPart != L"..";
}

bool CorrectFsPath(const UString &relBase, const UString &path, UString &result);

bool CPanel::CorrectFsPath(const UString &path2, UString &result)
{
  return ::CorrectFsPath(GetFsPath(), path2, result);
}

#ifdef _WIN32
BOOL CPanel::OnEndLabelEdit(LV_DISPINFOW * lpnmh)
{
  if (lpnmh->item.pszText == NULL)
    return FALSE;
  CDisableTimerProcessing disableTimerProcessing2(*this);

  if (!CheckBeforeUpdate(IDS_ERROR_RENAMING))
    return FALSE;

  UString newName = lpnmh->item.pszText;
  if (!IsCorrectFsName(newName))
  {
    MessageBoxError(E_INVALIDARG);
    return FALSE;
  }

  if (IsFSFolder())
  {
    UString correctName;
    if (!CorrectFsPath(newName, correctName))
    {
      MessageBoxError(E_INVALIDARG);
      return FALSE;
    }
    newName = correctName;
  }

  SaveSelectedState(_selectedState);

  int realIndex = GetRealIndex(lpnmh->item);
  if (realIndex == kParentIndex)
    return FALSE;
  const UString prefix = GetItemPrefix(realIndex);


  CDisableNotify disableNotify(*this);
  {
    CThreadFolderOperations op(FOLDER_TYPE_RENAME);
    op.FolderOperations = _folderOperations;
    op.Index = realIndex;
    op.Name = newName;
    /* HRESULTres = */ op.DoOperation(*this,
        LangString(IDS_RENAMING),
        LangString(IDS_ERROR_RENAMING));
    // fixed in 9.26: we refresh list even after errors
    // (it's more safe, since error can be at different stages, so list can be incorrect).
    /*
    if (res != S_OK)
      return FALSE;
    */
  }

  // Can't use RefreshListCtrl here.
  // RefreshListCtrlSaveFocused();
  _selectedState.FocusedName = prefix + newName;
  _selectedState.SelectFocused = true;

  // We need clear all items to disable GetText before Reload:
  // number of items can change.
  // _listView.DeleteAllItems();
  // But seems it can still call GetText (maybe for current item)
  // so we can't delete items.

  _dontShowMode = true;

  PostMessage(kReLoadMessage);
  return TRUE;
}
#endif

bool Dlg_CreateFolder(HWND wnd, UString &destName);

void CPanel::CreateFolder()
{
  if (!CheckBeforeUpdate(IDS_CREATE_FOLDER_ERROR))
    return;

  CDisableTimerProcessing disableTimerProcessing2(*this);
  CSelectedState state;
  SaveSelectedState(state);

  UString newName;
  if (!Dlg_CreateFolder(GetParent(), newName))
    return;
  
  if (!IsCorrectFsName(newName))
  {
    MessageBoxError(E_INVALIDARG);
    return;
  }

  if (IsFSFolder())
  {
    UString correctName;
    if (!CorrectFsPath(newName, correctName))
    {
      MessageBoxError(E_INVALIDARG);
      return;
    }
    newName = correctName;
  }
  
  HRESULT res;
  CDisableNotify disableNotify(*this);
  {
    CThreadFolderOperations op(FOLDER_TYPE_CREATE_FOLDER);
    op.FolderOperations = _folderOperations;
    op.Name = newName;
    res = op.DoOperation(*this,
        LangString(IDS_CREATE_FOLDER),
        LangString(IDS_CREATE_FOLDER_ERROR));
    /*
    // fixed for 9.26: we must refresh always
    if (res != S_OK)
      return;
    */
  }
  if (res == S_OK)
  {
    int pos = newName.Find(WCHAR_PATH_SEPARATOR);
    if (pos >= 0)
      newName.DeleteFrom(pos);
    if (!_mySelectMode)
      state.SelectedNames.Clear();
    state.FocusedName = newName;
    state.SelectFocused = true;
  }
  RefreshTitleAlways();
  RefreshListCtrl(state);
}

void CPanel::CreateFile()
{
  if (!CheckBeforeUpdate(IDS_CREATE_FILE_ERROR))
    return;

  CDisableTimerProcessing disableTimerProcessing2(*this);
  CSelectedState state;
  SaveSelectedState(state);
  CComboDialog dlg;
  LangString(IDS_CREATE_FILE, dlg.Title);
  LangString(IDS_CREATE_FILE_NAME, dlg.Static);
  LangString(IDS_CREATE_FILE_DEFAULT_NAME, dlg.Value);

  if (dlg.Create(GetParent()) != IDOK)
    return;

  CDisableNotify disableNotify(*this);
  
  UString newName = dlg.Value;

  if (IsFSFolder())
  {
    UString correctName;
    if (!CorrectFsPath(newName, correctName))
    {
      MessageBoxError(E_INVALIDARG);
      return;
    }
    newName = correctName;
  }

  HRESULT result = _folderOperations->CreateFile(newName, 0);
  if (result != S_OK)
  {
    MessageBoxError(result, LangString(IDS_CREATE_FILE_ERROR));
    // MessageBoxErrorForUpdate(result, IDS_CREATE_FILE_ERROR);
    return;
  }
  int pos = newName.Find(WCHAR_PATH_SEPARATOR);
  if (pos >= 0)
    newName.DeleteFrom(pos);
  if (!_mySelectMode)
    state.SelectedNames.Clear();
  state.FocusedName = newName;
  state.SelectFocused = true;
  RefreshListCtrl(state);
}

void CPanel::RenameFile()
{
  if (!CheckBeforeUpdate(IDS_ERROR_RENAMING))
    return;
  int index = _listView.GetFocusedItem();
  if (index >= 0)
    _listView.EditLabel(index);
}

void CPanel::ChangeComment()
{
  if (!CheckBeforeUpdate(IDS_COMMENT))
    return;
  CDisableTimerProcessing disableTimerProcessing2(*this);
  int index = _listView.GetFocusedItem();
  if (index < 0)
    return;
  int realIndex = GetRealItemIndex(index);
  if (realIndex == kParentIndex)
    return;
  CSelectedState state;
  SaveSelectedState(state);
  UString comment;
  {
    NCOM::CPropVariant propVariant;
    if (_folder->GetProperty(realIndex, kpidComment, &propVariant) != S_OK)
      return;
    if (propVariant.vt == VT_BSTR)
      comment = propVariant.bstrVal;
    else if (propVariant.vt != VT_EMPTY)
      return;
  }
  UString name = GetItemRelPath2(realIndex);
  CComboDialog dlg;
  dlg.Title = name;
  dlg.Title += L" : ";
  AddLangString(dlg.Title, IDS_COMMENT);
  dlg.Value = comment;
  LangString(IDS_COMMENT2, dlg.Static);
  if (dlg.Create(GetParent()) != IDOK)
    return;
  NCOM::CPropVariant propVariant = dlg.Value.Ptr();

  CDisableNotify disableNotify(*this);
  HRESULT result = _folderOperations->SetProperty(realIndex, kpidComment, &propVariant, NULL);
  if (result != S_OK)
  {
    if (result == E_NOINTERFACE)
      MessageBoxErrorLang(IDS_OPERATION_IS_NOT_SUPPORTED);
    else
      MessageBoxError(result, L"Set Comment Error");
  }
  RefreshListCtrl(state);
}

// From CPP/7zip/UI/FileManager/BrowseDialog.cpp
bool Dlg_CreateFolder(HWND wnd, UString &destName)
{
  destName.Empty();
  CComboDialog dlg;
  LangString(IDS_CREATE_FOLDER, dlg.Title);
  LangString(IDS_CREATE_FOLDER_NAME, dlg.Static);
  LangString(IDS_CREATE_FOLDER_DEFAULT_NAME, dlg.Value);
  if (dlg.Create(wnd) != IDOK)
    return false;
  destName = dlg.Value;
  return true;
}

// PanelSelect.cpp

#include "StdAfx.h"

#include "resource.h"

#include "../../../Common/StringConvert.h"
#include "../../../Common/Wildcard.h"

#include "ComboDialog.h"
#include "LangUtils.h"
#include "Panel.h"

void CPanel::OnShiftSelectMessage()
{
  if (!_mySelectMode)
    return;
  int focusedItem = _listView.GetFocusedItem();
  if (focusedItem < 0)
    return;
  if (!_selectionIsDefined)
    return;
  int startItem = MyMin(focusedItem, _prevFocusedItem);
  int finishItem = MyMax(focusedItem, _prevFocusedItem);

  int numItems = _listView.GetItemCount();
  for (int i = 0; i < numItems; i++)
  {
    int realIndex = GetRealItemIndex(i);
    if (realIndex == kParentIndex)
      continue;
    if (i >= startItem && i <= finishItem)
      if (_selectedStatusVector[realIndex] != _selectMark)
      {
          printf("CPanel::OnShiftSelectMessage : __selectedStatusVector[%d]=%d => %d\n",
          realIndex,_selectedStatusVector[realIndex] , _selectMark);
        _selectedStatusVector[realIndex] = _selectMark;
        _listView.RedrawItem(i);
      }
  }

  _prevFocusedItem = focusedItem;
}

#ifdef _WIN32
void CPanel::OnArrowWithShift()
{
  if (!_mySelectMode)
    return;
  int focusedItem = _listView.GetFocusedItem();
  if (focusedItem < 0)
    return;
  int realIndex = GetRealItemIndex(focusedItem);

  if (_selectionIsDefined)
  {
    if (realIndex != kParentIndex)
      _selectedStatusVector[realIndex] = _selectMark;
  }
  else
  {
    if (realIndex == kParentIndex)
    {
      _selectionIsDefined = true;
      _selectMark = true;
    }
    else
    {
      _selectionIsDefined = true;
      _selectMark = !_selectedStatusVector[realIndex];
      _selectedStatusVector[realIndex] = _selectMark;
    }
  }

  _prevFocusedItem = focusedItem;
  PostMessage(kShiftSelectMessage);
  _listView.RedrawItem(focusedItem);
}

void CPanel::OnInsert()
{
  /*
  const int kState = CDIS_MARKED; // LVIS_DROPHILITED;
  UINT state = (_listView.GetItemState(focusedItem, LVIS_CUT) == 0) ?
      LVIS_CUT : 0;
  _listView.SetItemState(focusedItem, state, LVIS_CUT);
  // _listView.SetItemState_Selected(focusedItem);

  */
  int focusedItem = _listView.GetFocusedItem();
  if (focusedItem < 0)
    return;
  int realIndex = GetRealItemIndex(focusedItem);
  bool isSelected = !_selectedStatusVector[realIndex];
  if (realIndex != kParentIndex)
    _selectedStatusVector[realIndex] = isSelected;

  if (!_mySelectMode)
    _listView.SetItemState_Selected(focusedItem, isSelected);

  _listView.RedrawItem(focusedItem);

  int nextIndex = focusedItem + 1;
  if (nextIndex < _listView.GetItemCount())
  {
    _listView.SetItemState_FocusedSelected(nextIndex);
    _listView.EnsureVisible(nextIndex, false);
  }
}
#endif

/*
void CPanel::OnUpWithShift()
{
  int focusedItem = _listView.GetFocusedItem();
  if (focusedItem < 0)
    return;
  int index = GetRealItemIndex(focusedItem);
  _selectedStatusVector[index] = !_selectedStatusVector[index];
  _listView.RedrawItem(index);
}

void CPanel::OnDownWithShift()
{
  int focusedItem = _listView.GetFocusedItem();
  if (focusedItem < 0)
    return;
  int index = GetRealItemIndex(focusedItem);
  _selectedStatusVector[index] = !_selectedStatusVector[index];
  _listView.RedrawItem(index);
}
*/

void CPanel::UpdateSelection()
{
  if (!_mySelectMode)
  {
    bool enableTemp = _enableItemChangeNotify;
    _enableItemChangeNotify = false;
    int numItems = _listView.GetItemCount();
    for (int i = 0; i < numItems; i++)
    {
      int realIndex = GetRealItemIndex(i);
      if (realIndex != kParentIndex)
        _listView.SetItemState_Selected(i, _selectedStatusVector[realIndex]);
    }
    _enableItemChangeNotify = enableTemp;
  }
  _listView.RedrawAllItems();
}


void CPanel::SelectSpec(bool selectMode)
{
  CComboDialog dlg;
  LangString(selectMode ? IDS_SELECT : IDS_DESELECT, dlg.Title );
  LangString(IDS_SELECT_MASK, dlg.Static);
  dlg.Value = L'*';
  if (dlg.Create(GetParent()) != IDOK)
    return;
  const UString &mask = dlg.Value;
  FOR_VECTOR (i, _selectedStatusVector)
    if (DoesWildcardMatchName(mask, GetItemName(i)))
    {
      printf("CPanel::SelectSpec : __selectedStatusVector[%d]=%d => %d\n",
          i,_selectedStatusVector[i] , selectMode);
       _selectedStatusVector[i] = selectMode;
    }
  UpdateSelection();
}

void CPanel::SelectByType(bool selectMode)
{
  int focusedItem = _listView.GetFocusedItem();
  if (focusedItem < 0)
    return;
  int realIndex = GetRealItemIndex(focusedItem);
  UString name = GetItemName(realIndex);
  bool isItemFolder = IsItem_Folder(realIndex);

  if (isItemFolder)
  {
    FOR_VECTOR (i, _selectedStatusVector)
      if (IsItem_Folder(i) == isItemFolder)
      {
        printf("CPanel::SelectByType : __selectedStatusVector[%d]=%d => %d\n",i,_selectedStatusVector[i] , selectMode);
        _selectedStatusVector[i] = selectMode;
      }
  }
  else
  {
    int pos = name.ReverseFind_Dot();
    if (pos < 0)
    {
      FOR_VECTOR (i, _selectedStatusVector)
        if (IsItem_Folder(i) == isItemFolder && GetItemName(i).ReverseFind_Dot() < 0)
        {
            printf("CPanel::SelectByType-2 : __selectedStatusVector[%d]=%d => %d\n",i,_selectedStatusVector[i] , selectMode);
          _selectedStatusVector[i] = selectMode;
        }
    }
    else
    {
      UString mask = L'*';
      mask += name.Ptr(pos);
      FOR_VECTOR (i, _selectedStatusVector)
        if (IsItem_Folder(i) == isItemFolder && DoesWildcardMatchName(mask, GetItemName(i)))
        {
            printf("CPanel::SelectByType-3 : __selectedStatusVector[%d]=%d => %d\n",i,_selectedStatusVector[i] , selectMode);
          _selectedStatusVector[i] = selectMode;
      }
    }
  }

  UpdateSelection();
}

void CPanel::SelectAll(bool selectMode)
{
    printf("CPanel::SelectAll\n");
  FOR_VECTOR (i, _selectedStatusVector)
    _selectedStatusVector[i] = selectMode;
  UpdateSelection();
}

void CPanel::InvertSelection()
{
    printf("CPanel::InvertSelection\n");
  if (!_mySelectMode)
  {
    unsigned numSelected = 0;
    FOR_VECTOR (i, _selectedStatusVector)
      if (_selectedStatusVector[i])
        numSelected++;
    if (numSelected == 1)
    {
      int focused = _listView.GetFocusedItem();
      if (focused >= 0)
      {
        int realIndex = GetRealItemIndex(focused);
        if (realIndex >= 0)
          if (_selectedStatusVector[realIndex])
            _selectedStatusVector[realIndex] = false;
      }
    }
  }
  FOR_VECTOR (i, _selectedStatusVector)
    _selectedStatusVector[i] = !_selectedStatusVector[i];
  UpdateSelection();
}

void CPanel::KillSelection()
{
  SelectAll(false);
  if (!_mySelectMode)
  {
    int focused = _listView.GetFocusedItem();
    if (focused >= 0)
    {
      // CPanel::OnItemChanged notify for LVIS_SELECTED change doesn't work here. Why?
      // so we change _selectedStatusVector[realIndex] here.
      int realIndex = GetRealItemIndex(focused);
      if (realIndex != kParentIndex)
      {
          printf("CPanel::KillSelection _selectedStatusVector[%d]=%d => true\n",realIndex,_selectedStatusVector[realIndex]);

        _selectedStatusVector[realIndex] = true;
       }
      _listView.SetItemState_Selected(focused);
    }
  }
}

#ifdef _WIN32
void CPanel::OnLeftClick(MY_NMLISTVIEW_NMITEMACTIVATE *itemActivate)
{
  if (itemActivate->hdr.hwndFrom != HWND(_listView))
    return;
  // It will work only for Version 4.71 (IE 4);
  int indexInList = itemActivate->iItem;
  if (indexInList < 0)
    return;

  #ifndef UNDER_CE
  if ((itemActivate->uKeyFlags & LVKF_SHIFT) != 0)
  {
    // int focusedIndex = _listView.GetFocusedItem();
    int focusedIndex = _startGroupSelect;
    if (focusedIndex < 0)
      return;
    int startItem = MyMin(focusedIndex, indexInList);
    int finishItem = MyMax(focusedIndex, indexInList);

    int numItems = _listView.GetItemCount();
    for (int i = 0; i < numItems; i++)
    {
      int realIndex = GetRealItemIndex(i);
      if (realIndex == kParentIndex)
        continue;
      bool selected = (i >= startItem && i <= finishItem);
      if (_selectedStatusVector[realIndex] != selected)
      {
        _selectedStatusVector[realIndex] = selected;
        _listView.RedrawItem(i);
      }
    }
  }
  else
  #endif
  {
    _startGroupSelect = indexInList;

    #ifndef UNDER_CE
    if ((itemActivate->uKeyFlags & LVKF_CONTROL) != 0)
    {
      int realIndex = GetRealItemIndex(indexInList);
      if (realIndex != kParentIndex)
      {
        _selectedStatusVector[realIndex] = !_selectedStatusVector[realIndex];
        _listView.RedrawItem(indexInList);
      }
    }
    #endif
  }

  return;
}
#endif

// PanelSort.cpp

#include "StdAfx.h"

#include "../../../../C/CpuArch.h"
#include "../../../Windows/PropVariant.h"

#include "../../PropID.h"

#include "Panel.h"

using namespace NWindows;

int CompareFileNames_ForFolderList(const wchar_t *s1, const wchar_t *s2)
{
  for (;;)
  {
    wchar_t c1 = *s1;
    wchar_t c2 = *s2;
    if ((c1 >= '0' && c1 <= '9') &&
        (c2 >= '0' && c2 <= '9'))
    {
      for (; *s1 == '0'; s1++);
      for (; *s2 == '0'; s2++);
      size_t len1 = 0;
      size_t len2 = 0;
      for (; (s1[len1] >= '0' && s1[len1] <= '9'); len1++);
      for (; (s2[len2] >= '0' && s2[len2] <= '9'); len2++);
      if (len1 < len2) return -1;
      if (len1 > len2) return 1;
      for (; len1 > 0; s1++, s2++, len1--)
      {
        if (*s1 == *s2) continue;
        return (*s1 < *s2) ? -1 : 1;
      }
      c1 = *s1;
      c2 = *s2;
    }
    s1++;
    s2++;
    if (c1 != c2)
    {
      // Probably we need to change the order for special characters like in Explorer.
      wchar_t u1 = MyCharUpper(c1);
      wchar_t u2 = MyCharUpper(c2);
      if (u1 < u2) return -1;
      if (u1 > u2) return 1;
    }
    if (c1 == 0) return 0;
  }
}

static int CompareFileNames_Le16(const Byte *s1, unsigned size1, const Byte *s2, unsigned size2)
{
  size1 &= ~1;
  size2 &= ~1;
  for (unsigned i = 0;; i += 2)
  {
    if (i >= size1)
      return (i >= size2) ? 0 : -1;
    if (i >= size2)
      return 1;
    UInt16 c1 = GetUi16(s1 + i);
    UInt16 c2 = GetUi16(s2 + i);
    if (c1 == c2)
    {
      if (c1 == 0)
        return 0;
      continue;
    }
    if (c1 < c2)
      return -1;
    return 1;
  }
}

static inline const wchar_t *GetExtensionPtr(const UString &name)
{
  int dotPos = name.ReverseFind_Dot();
  return name.Ptr((dotPos < 0) ? name.Len() : dotPos);
}

void CPanel::SetSortRawStatus()
{
  _isRawSortProp = false;
  FOR_VECTOR (i, _properties)
  {
    const CItemProperty &prop = _properties[i];
    if (prop.ID == _sortID)
    {
      _isRawSortProp = prop.IsRawProp ? 1 : 0;
      return;
    }
  }
}


int CALLBACK CompareItems2(LPARAM lParam1, LPARAM lParam2, LPARAM lpData)
{
  if (lpData == 0)
    return 0;
  CPanel *panel = (CPanel*)lpData;
  

  PROPID propID = panel->_sortID;

  if (propID == kpidNoProperty)
    return MyCompare(lParam1, lParam2);

  if (panel->_isRawSortProp)
  {
    // Sha1, NtSecurity, NtReparse
    const void *data1;
    const void *data2;
    UInt32 dataSize1;
    UInt32 dataSize2;
    UInt32 propType1;
    UInt32 propType2;
    if (panel->_folderRawProps->GetRawProp((UInt32)lParam1, propID, &data1, &dataSize1, &propType1) != 0) return 0;
    if (panel->_folderRawProps->GetRawProp((UInt32)lParam2, propID, &data2, &dataSize2, &propType2) != 0) return 0;
    if (dataSize1 == 0)
      return (dataSize2 == 0) ? 0 : -1;
    if (dataSize2 == 0)
      return 1;
    if (propType1 != NPropDataType::kRaw) return 0;
    if (propType2 != NPropDataType::kRaw) return 0;
#ifdef _WIN32
    if (propID == kpidNtReparse)
    {
      NFile::CReparseShortInfo r1; r1.Parse((const Byte *)data1, dataSize1);
      NFile::CReparseShortInfo r2; r2.Parse((const Byte *)data2, dataSize2);
      return CompareFileNames_Le16(
          (const Byte *)data1 + r1.Offset, r1.Size,
          (const Byte *)data2 + r2.Offset, r2.Size);
    }
#endif
  }

  if (panel->_folderCompare)
    return panel->_folderCompare->CompareItems((UInt32)lParam1, (UInt32)lParam2, propID, panel->_isRawSortProp);
  
  switch (propID)
  {
    // if (panel->_sortIndex == 0)
    case kpidName:
    {
      const UString name1 = panel->GetItemName((int)lParam1);
      const UString name2 = panel->GetItemName((int)lParam2);
      int res = CompareFileNames_ForFolderList(name1, name2);
      /*
      if (res != 0 || !panel->_flatMode)
        return res;
      const UString prefix1 = panel->GetItemPrefix(lParam1);
      const UString prefix2 = panel->GetItemPrefix(lParam2);
      return res = CompareFileNames_ForFolderList(prefix1, prefix2);
      */
      return res;
    }
    case kpidExtension:
    {
      const UString name1 = panel->GetItemName((int)lParam1);
      const UString name2 = panel->GetItemName((int)lParam2);
      return CompareFileNames_ForFolderList(
          GetExtensionPtr(name1),
          GetExtensionPtr(name2));
    }
  }
  /*
  if (panel->_sortIndex == 1)
    return MyCompare(file1.Size, file2.Size);
  return ::CompareFileTime(&file1.MTime, &file2.MTime);
  */

  // PROPID propID = panel->_properties[panel->_sortIndex].ID;

  NCOM::CPropVariant prop1, prop2;
  // Name must be first property
  panel->_folder->GetProperty((UInt32)lParam1, propID, &prop1);
  panel->_folder->GetProperty((UInt32)lParam2, propID, &prop2);
  if (prop1.vt != prop2.vt)
  {
    return MyCompare(prop1.vt, prop2.vt);
  }
  if (prop1.vt == VT_BSTR)
  {
    return _wcsicmp(prop1.bstrVal, prop2.bstrVal);
  }
  return prop1.Compare(prop2);
  // return 0;
}

int CALLBACK CompareItems(LPARAM lParam1, LPARAM lParam2, LPARAM lpData)
{
  if (lpData == 0) return 0;
  if (lParam1 == kParentIndex) return -1;
  if (lParam2 == kParentIndex) return 1;

  CPanel *panel = (CPanel*)lpData;

  bool isDir1 = panel->IsItem_Folder((int)lParam1);
  bool isDir2 = panel->IsItem_Folder((int)lParam2);
  
  if (isDir1 && !isDir2) return -1;
  if (isDir2 && !isDir1) return 1;

  int result = CompareItems2(lParam1, lParam2, lpData);
  return panel->_ascending ? result: (-result);
}

int 
#if defined(__WIN32__) && !defined(__WXMICROWIN__) // FIXME
  wxCALLBACK
#endif
 CompareItems_WX(long item1, long item2, long sortData)
{
        return CompareItems(item1,item2,sortData);
}


/*
void CPanel::SortItems(int index)
{
  if (index == _sortIndex)
    _ascending = !_ascending;
  else
  {
    _sortIndex = index;
    _ascending = true;
    switch (_properties[_sortIndex].ID)
    {
      case kpidSize:
      case kpidPackedSize:
      case kpidCTime:
      case kpidATime:
      case kpidMTime:
      _ascending = false;
      break;
    }
  }
  _listView.SortItems(CompareItems, (LPARAM)this);
  _listView.EnsureVisible(_listView.GetFocusedItem(), false);
}
void CPanel::SortItemsWithPropID(PROPID propID)
{
  int index = _properties.FindItemWithID(propID);
  if (index >= 0)
    SortItems(index);
}
*/
void CPanel::SortItemsWithPropID(PROPID propID)
{
  if (propID == _sortID)
    _ascending = !_ascending;
  else
  {
    _sortID = propID;
    _ascending = true;
    switch (propID)
    {
      case kpidSize:
      case kpidPackSize:
      case kpidCTime:
      case kpidATime:
      case kpidMTime:
        _ascending = false;
      break;
    }
  }
  SetSortRawStatus();
  if (sizeof(long) != sizeof(LPARAM)) {
    printf("INTERNAL ERROR : sizeof(long) != sizeof(LPARAM)\n");
    exit(-1);
  }
  _listView.SortItems(CompareItems_WX, (LPARAM)this); // FIXED _listView.SortItems(CompareItems, (LPARAM)this);
  _listView.EnsureVisible(_listView.GetFocusedItem(), false);
}


void CPanel::OnColumnClick(LPNMLISTVIEW info)
{
  /*
  int index = _properties.FindItemWithID(_visibleProperties[info->iSubItem].ID);
  SortItems(index);
  */
  SortItemsWithPropID(_visibleProperties[info->iSubItem].ID);
}
// PanelSplitFile.cpp

#include "StdAfx.h"

#include "../../../Common/IntToString.h"

#include "../../../Windows/ErrorMsg.h"
#include "../../../Windows/FileName.h"

#include "../GUI/ExtractRes.h"

#include "resource.h"

#include "App.h"
#include "CopyDialog.h"
#include "FormatUtils.h"
#include "LangUtils.h"
#include "SplitDialog.h"
#include "SplitUtils.h"

#include "PropertyNameRes.h"

using namespace NWindows;
using namespace NFile;
using namespace NDir;

static const wchar_t *g_Message_FileWriteError = L"File write error";

struct CVolSeqName
{
  UString UnchangedPart;
  UString ChangedPart;
  CVolSeqName(): ChangedPart(L"000") {};

  void SetNumDigits(UInt64 numVolumes)
  {
    ChangedPart = L"000";
    while (numVolumes > 999)
    {
      numVolumes /= 10;
      ChangedPart += L'0';
    }
  }

  bool ParseName(const UString &name)
  {
    if (name.Len() < 2)
      return false;
    if (name.Back() != L'1' || name[name.Len() - 2] != L'0')
      return false;

    unsigned pos = name.Len() - 2;
    for (; pos > 0 && name[pos - 1] == '0'; pos--);
    UnchangedPart.SetFrom(name, pos);
    ChangedPart = name.Ptr(pos);
    return true;
  }

  UString GetNextName();
};


UString CVolSeqName::GetNextName()
{
  for (int i = (int)ChangedPart.Len() - 1; i >= 0; i--)
  {
    wchar_t c = ChangedPart[i];
    if (c != L'9')
    {
      ChangedPart.ReplaceOneCharAtPos(i, (wchar_t)(c + 1));
      break;
    }
    ChangedPart.ReplaceOneCharAtPos(i, L'0');
    if (i == 0)
      ChangedPart.InsertAtFront(L'1');
  }
  return UnchangedPart + ChangedPart;
}

static const UInt32 kBufSize = (1 << 20);

class CThreadSplit: public CProgressThreadVirt
{
  HRESULT ProcessVirt();
public:
  FString FilePath;
  FString VolBasePath;
  UInt64 NumVolumes;
  CRecordVector<UInt64> VolumeSizes;
};

HRESULT CThreadSplit::ProcessVirt()
{
  NIO::CInFile inFile;
  if (!inFile.Open(FilePath))
    return GetLastError();
  NIO::COutFile outFile;
  CMyBuffer bufferObject;
  if (!bufferObject.Allocate(kBufSize))
    return E_OUTOFMEMORY;
  Byte *buffer = (Byte *)(void *)bufferObject;
  UInt64 curVolSize = 0;
  CVolSeqName seqName;
  seqName.SetNumDigits(NumVolumes);
  UInt64 length;
  if (!inFile.GetLength(length))
    return GetLastError();
  
  CProgressSync &sync = ProgressDialog.Sync;
  sync.Set_NumBytesTotal(length);
  UInt64 pos = 0;
  
  UInt64 numFiles = 0;
  unsigned volIndex = 0;
  
  for (;;)
  {
    UInt64 volSize;
    if (volIndex < VolumeSizes.Size())
      volSize = VolumeSizes[volIndex];
    else
      volSize = VolumeSizes.Back();
    
    UInt32 needSize = (UInt32)(MyMin((UInt64)kBufSize, volSize - curVolSize));
    UInt32 processedSize;
    if (!inFile.Read(buffer, needSize, processedSize))
      return GetLastError();
    if (processedSize == 0)
      break;
    needSize = processedSize;
    if (curVolSize == 0)
    {
      FString name = VolBasePath;
      name += FTEXT('.');
      name += us2fs(seqName.GetNextName());
      sync.Set_FilePath(fs2us(name));
      sync.Set_NumFilesCur(numFiles++);
      if (!outFile.Create(name, false))
      {
        HRESULT res = GetLastError();
        AddErrorPath(name);
        return res;
      }
    }
    if (!outFile.Write(buffer, needSize, processedSize))
      return GetLastError();
    if (needSize != processedSize)
      throw g_Message_FileWriteError;
    curVolSize += processedSize;
    if (curVolSize == volSize)
    {
      outFile.Close();
      if (volIndex < VolumeSizes.Size())
        volIndex++;
      curVolSize = 0;
    }
    pos += processedSize;
    RINOK(sync.Set_NumBytesCur(pos));
  }
  sync.Set_NumFilesCur(numFiles);
  return S_OK;
}

void CApp::Split()
{
  int srcPanelIndex = GetFocusedPanelIndex();
  CPanel &srcPanel = Panels[srcPanelIndex];
  if (!srcPanel.Is_IO_FS_Folder())
  {
    srcPanel.MessageBoxErrorLang(IDS_OPERATION_IS_NOT_SUPPORTED);
    return;
  }
  CRecordVector<UInt32> indices;
  srcPanel.GetOperatedItemIndices(indices);
  if (indices.IsEmpty())
    return;
  if (indices.Size() != 1)
  {
    srcPanel.MessageBoxErrorLang(IDS_SELECT_ONE_FILE);
    return;
  }
  int index = indices[0];
  if (srcPanel.IsItem_Folder(index))
  {
    srcPanel.MessageBoxErrorLang(IDS_SELECT_ONE_FILE);
    return;
  }
  const UString itemName = srcPanel.GetItemName(index);

  UString srcPath = srcPanel.GetFsPath() + srcPanel.GetItemPrefix(index);
  UString path = srcPath;
  int destPanelIndex = (NumPanels <= 1) ? srcPanelIndex : (1 - srcPanelIndex);
  CPanel &destPanel = Panels[destPanelIndex];
  if (NumPanels > 1)
    if (destPanel.IsFSFolder())
      path = destPanel.GetFsPath();
  CSplitDialog splitDialog;
  splitDialog.FilePath = srcPanel.GetItemRelPath(index);
  splitDialog.Path = path;
  if (splitDialog.Create(srcPanel.GetParent()) != IDOK)
    return;

  NFind::CFileInfo fileInfo;
  if (!fileInfo.Find(us2fs(srcPath + itemName)))
  {
    srcPanel.MessageBoxMyError(L"Can not find file");
    return;
  }
  if (fileInfo.Size <= splitDialog.VolumeSizes.Front())
  {
    srcPanel.MessageBoxErrorLang(IDS_SPLIT_VOL_MUST_BE_SMALLER);
    return;
  }
  const UInt64 numVolumes = GetNumberOfVolumes(fileInfo.Size, splitDialog.VolumeSizes);
  if (numVolumes >= 100)
  {
    wchar_t s[32];
    ConvertUInt64ToString(numVolumes, s);
    if (::MessageBoxW(srcPanel, MyFormatNew(IDS_SPLIT_CONFIRM_MESSAGE, s),
        LangString(IDS_SPLIT_CONFIRM_TITLE),
        MB_YESNOCANCEL | MB_ICONQUESTION) != IDYES)
      return;
  }

  path = splitDialog.Path;
  NName::NormalizeDirPathPrefix(path);
  if (!CreateComplexDir(us2fs(path)))
  {
    srcPanel.MessageBoxError2Lines(MyFormatNew(IDS_CANNOT_CREATE_FOLDER, path), ::GetLastError());
    return;
  }

  {
  CThreadSplit spliter;
  spliter.NumVolumes = numVolumes;

  CProgressDialog &progressDialog = spliter.ProgressDialog;

  UString progressWindowTitle = L"7-Zip"; // LangString(IDS_APP_TITLE, 0x03000000);
  UString title = LangString(IDS_SPLITTING);

  progressDialog.ShowCompressionInfo = false;

  progressDialog.MainWindow = _window;
  progressDialog.MainTitle = progressWindowTitle;
  progressDialog.MainAddTitle = title;
  progressDialog.MainAddTitle.Add_Space();
  progressDialog.Sync.Set_TitleFileName(itemName);


  spliter.FilePath = us2fs(srcPath + itemName);
  spliter.VolBasePath = us2fs(path + srcPanel.GetItemName_for_Copy(index));
  spliter.VolumeSizes = splitDialog.VolumeSizes;
  
  // if (splitDialog.VolumeSizes.Size() == 0) return;

  // CPanel::CDisableTimerProcessing disableTimerProcessing1(srcPanel);
  // CPanel::CDisableTimerProcessing disableTimerProcessing2(destPanel);

  if (spliter.Create(title, _window) != 0)
    return;
  }
  RefreshTitleAlways();


  // disableNotify.Restore();
  // disableNotify.Restore();
  // srcPanel.SetFocusToList();
  // srcPanel.RefreshListCtrlSaveFocused();
}


class CThreadCombine: public CProgressThreadVirt
{
  HRESULT ProcessVirt();
public:
  FString InputDirPrefix;
  FStringVector Names;
  FString OutputPath;
  UInt64 TotalSize;
};

HRESULT CThreadCombine::ProcessVirt()
{
  NIO::COutFile outFile;
  if (!outFile.Create(OutputPath, false))
  {
    HRESULT res = GetLastError();
    AddErrorPath(OutputPath);
    return res;
  }
  
  CProgressSync &sync = ProgressDialog.Sync;
  sync.Set_NumBytesTotal(TotalSize);
  
  CMyBuffer bufferObject;
  if (!bufferObject.Allocate(kBufSize))
    return E_OUTOFMEMORY;
  Byte *buffer = (Byte *)(void *)bufferObject;
  UInt64 pos = 0;
  FOR_VECTOR (i, Names)
  {
    NIO::CInFile inFile;
    const FString nextName = InputDirPrefix + Names[i];
    if (!inFile.Open(nextName))
    {
      HRESULT res = GetLastError();
      AddErrorPath(nextName);
      return res;
    }
    sync.Set_FilePath(fs2us(nextName));
    for (;;)
    {
      UInt32 processedSize;
      if (!inFile.Read(buffer, kBufSize, processedSize))
      {
        HRESULT res = GetLastError();
        AddErrorPath(nextName);
        return res;
      }
      if (processedSize == 0)
        break;
      UInt32 needSize = processedSize;
      if (!outFile.Write(buffer, needSize, processedSize))
      {
        HRESULT res = GetLastError();
        AddErrorPath(OutputPath);
        return res;
      }
      if (needSize != processedSize)
        throw g_Message_FileWriteError;
      pos += processedSize;
      RINOK(sync.Set_NumBytesCur(pos));
    }
  }
  return S_OK;
}

extern void AddValuePair2(UString &s, UINT resourceID, UInt64 num, UInt64 size);

static void AddInfoFileName(UString &dest, const UString &name)
{
  dest += L"\n  ";
  dest += name;
}

void CApp::Combine()
{
  int srcPanelIndex = GetFocusedPanelIndex();
  CPanel &srcPanel = Panels[srcPanelIndex];
  if (!srcPanel.IsFSFolder())
  {
    srcPanel.MessageBoxErrorLang(IDS_OPERATION_IS_NOT_SUPPORTED);
    return;
  }
  CRecordVector<UInt32> indices;
  srcPanel.GetOperatedItemIndices(indices);
  if (indices.IsEmpty())
    return;
  int index = indices[0];
  if (indices.Size() != 1 || srcPanel.IsItem_Folder(index))
  {
    srcPanel.MessageBoxErrorLang(IDS_COMBINE_SELECT_ONE_FILE);
    return;
  }
  const UString itemName = srcPanel.GetItemName(index);

  UString srcPath = srcPanel.GetFsPath() + srcPanel.GetItemPrefix(index);
  UString path = srcPath;
  int destPanelIndex = (NumPanels <= 1) ? srcPanelIndex : (1 - srcPanelIndex);
  CPanel &destPanel = Panels[destPanelIndex];
  if (NumPanels > 1)
    if (destPanel.IsFSFolder())
      path = destPanel.GetFsPath();

  CVolSeqName volSeqName;
  if (!volSeqName.ParseName(itemName))
  {
    srcPanel.MessageBoxErrorLang(IDS_COMBINE_CANT_DETECT_SPLIT_FILE);
    return;
  }
  
  {
  CThreadCombine combiner;
  
  UString nextName = itemName;
  combiner.TotalSize = 0;
  for (;;)
  {
    NFind::CFileInfo fileInfo;
    if (!fileInfo.Find(us2fs(srcPath + nextName)) || fileInfo.IsDir())
      break;
    combiner.Names.Add(us2fs(nextName));
    combiner.TotalSize += fileInfo.Size;
    nextName = volSeqName.GetNextName();
  }
  if (combiner.Names.Size() == 1)
  {
    srcPanel.MessageBoxErrorLang(IDS_COMBINE_CANT_FIND_MORE_THAN_ONE_PART);
    return;
  }
  
  if (combiner.TotalSize == 0)
  {
    srcPanel.MessageBoxMyError(L"No data");
    return;
  }
  
  UString info;
  AddValuePair2(info, IDS_PROP_FILES, combiner.Names.Size(), combiner.TotalSize);
  
  info.Add_LF();
  info += srcPath;
  
  unsigned i;
  for (i = 0; i < combiner.Names.Size() && i < 2; i++)
    AddInfoFileName(info, fs2us(combiner.Names[i]));
  if (i != combiner.Names.Size())
  {
    if (i + 1 != combiner.Names.Size())
      AddInfoFileName(info, L"...");
    AddInfoFileName(info, fs2us(combiner.Names.Back()));
  }
  
  {
    CCopyDialog copyDialog;
    copyDialog.Value = path;
    LangString(IDS_COMBINE, copyDialog.Title);
    copyDialog.Title.Add_Space();
    copyDialog.Title += srcPanel.GetItemRelPath(index);
    LangString(IDS_COMBINE_TO, copyDialog.Static);
    copyDialog.Info = info;
    if (copyDialog.Create(srcPanel.GetParent()) != IDOK)
      return;
    path = copyDialog.Value;
  }

  NName::NormalizeDirPathPrefix(path);
  if (!CreateComplexDir(us2fs(path)))
  {
    srcPanel.MessageBoxError2Lines(MyFormatNew(IDS_CANNOT_CREATE_FOLDER, path), ::GetLastError());
    return;
  }
  
  UString outName = volSeqName.UnchangedPart;
  while (!outName.IsEmpty())
  {
    if (outName.Back() != L'.')
      break;
    outName.DeleteBack();
  }
  if (outName.IsEmpty())
    outName = L"file";
  
  NFind::CFileInfo fileInfo;
  UString destFilePath = path + outName;
  combiner.OutputPath = us2fs(destFilePath);
  if (fileInfo.Find(combiner.OutputPath))
  {
    srcPanel.MessageBoxMyError(MyFormatNew(IDS_FILE_EXIST, destFilePath));
    return;
  }
  
    CProgressDialog &progressDialog = combiner.ProgressDialog;
    progressDialog.ShowCompressionInfo = false;
  
    UString progressWindowTitle = L"7-Zip"; // LangString(IDS_APP_TITLE, 0x03000000);
    UString title = LangString(IDS_COMBINING);
    
    progressDialog.MainWindow = _window;
    progressDialog.MainTitle = progressWindowTitle;
    progressDialog.MainAddTitle = title;
    progressDialog.MainAddTitle.Add_Space();
    
    combiner.InputDirPrefix = us2fs(srcPath);
    
    // CPanel::CDisableTimerProcessing disableTimerProcessing1(srcPanel);
    // CPanel::CDisableTimerProcessing disableTimerProcessing2(destPanel);
    
    if (combiner.Create(title, _window) != 0)
      return;
  }
  RefreshTitleAlways();

  // disableNotify.Restore();
  // disableNotify.Restore();
  // srcPanel.SetFocusToList();
  // srcPanel.RefreshListCtrlSaveFocused();
}
// PasswordDialog.cpp

#include "StdAfx.h"

#include "PasswordDialog.h"

#ifdef LANG
#include "LangUtils.h"
#endif

#ifdef LANG
static const UInt32 kLangIDs[] =
{
  IDT_PASSWORD_ENTER,
  IDX_PASSWORD_SHOW
};
#endif

void CPasswordDialog::ReadControls()
{
  _passwordEdit.GetText(Password);
  ShowPassword = IsButtonCheckedBool(IDX_PASSWORD_SHOW);
}

void CPasswordDialog::SetTextSpec()
{
  _passwordEdit.SetPasswordChar(ShowPassword ? 0: TEXT('*'));
  _passwordEdit.SetText(Password);
}

bool CPasswordDialog::OnInit()
{
  #ifdef LANG
  LangSetWindowText(*this, IDD_PASSWORD);
  LangSetDlgItems(*this, kLangIDs, ARRAY_SIZE(kLangIDs));
  #endif
  _passwordEdit.Attach(GetItem(IDE_PASSWORD_PASSWORD));
  CheckButton(IDX_PASSWORD_SHOW, ShowPassword);
  SetTextSpec();
  return CModalDialog::OnInit();
}

bool CPasswordDialog::OnButtonClicked(int buttonID, HWND buttonHWND)
{
  if (buttonID == IDX_PASSWORD_SHOW)
  {
    ReadControls();
    SetTextSpec();
    return true;
  }
  return CDialog::OnButtonClicked(buttonID, buttonHWND);
}

void CPasswordDialog::OnOK()
{
  ReadControls();
  CModalDialog::OnOK();
}
// PasswordDialog.h

#ifndef __PASSWORD_DIALOG_H
#define __PASSWORD_DIALOG_H

#include "../../../Windows/Control/Dialog.h"
#include "../../../Windows/Control/Edit.h"

#include "PasswordDialogRes.h"

class CPasswordDialog: public NWindows::NControl::CModalDialog
{
  NWindows::NControl::CEdit _passwordEdit;

  virtual void OnOK();
  virtual bool OnInit();
  virtual bool OnButtonClicked(int buttonID, HWND buttonHWND);
  void SetTextSpec();
  void ReadControls();
public:
  UString Password;
  bool ShowPassword;
  
  CPasswordDialog(): ShowPassword(false) {}
  INT_PTR Create(HWND parentWindow = 0) { return CModalDialog::Create(IDD_PASSWORD, parentWindow); }
};

#endif
#define IDD_PASSWORD        3800
#define IDT_PASSWORD_ENTER  3801
#define IDX_PASSWORD_SHOW   3803

#define IDE_PASSWORD_PASSWORD  120
// PasswordDialog.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif  

#undef _WIN32

#include "Windows/Control/DialogImpl.h"

#include "PasswordDialogRes.h"

class CPasswordDialogImpl : public NWindows::NControl::CModalDialogImpl
{
  public:
   CPasswordDialogImpl(NWindows::NControl::CModalDialog *dialog,wxWindow * parent,int id) : CModalDialogImpl(dialog, parent, id, wxT("Enter password"))
  {
	bool bShowPassword = false;

	wxBoxSizer* topsizer = new wxBoxSizer(wxVERTICAL);

	{
	wxStaticBoxSizer *passwdSizer = new wxStaticBoxSizer(new wxStaticBox(this,IDT_PASSWORD_ENTER,_T("&Enter password:")),wxVERTICAL);

	wxTextCtrl *TxtPasswd = new wxTextCtrl(this, IDE_PASSWORD_PASSWORD, L"", 
		wxDefaultPosition, wxSize(260,-1), bShowPassword?wxTE_LEFT:wxTE_PASSWORD );

	wxCheckBox *ChkShowPasswd = new wxCheckBox(this, IDX_PASSWORD_SHOW, wxT("&Show password"));

	ChkShowPasswd->SetValue(bShowPassword);
	passwdSizer->Add(TxtPasswd, 0, wxALL, 5);
	passwdSizer->Add(ChkShowPasswd, 0, wxALL, 5);

	topsizer->Add(passwdSizer, 0, wxALL, 5);
	}
	topsizer->Add(CreateButtonSizer(wxOK|wxCANCEL), 0, wxALL|wxEXPAND, 5);

	this->OnInit();

	SetSizer(topsizer); // use the sizer for layout
	topsizer->SetSizeHints(this); // set size hints to honour minimum size
  }
private:
	// Any class wishing to process wxWindows events must use this macro
	DECLARE_EVENT_TABLE()
};

REGISTER_DIALOG(IDD_PASSWORD,CPasswordDialog,0)

BEGIN_EVENT_TABLE(CPasswordDialogImpl, wxDialog)
	EVT_BUTTON(wxID_ANY,   CModalDialogImpl::OnAnyButton)
	EVT_CHECKBOX(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_MENU(WORKER_EVENT, CModalDialogImpl::OnWorkerEvent)
END_EVENT_TABLE()

// PluginInterface.h

#ifndef __PLUGIN_INTERFACE_H
#define __PLUGIN_INTERFACE_H

/*
#include "../../../Common/Types.h"
#include "../../IDecl.h"

#define PLUGIN_INTERFACE(i, x) DECL_INTERFACE(i, 0x0A, x)

PLUGIN_INTERFACE(IInitContextMenu, 0x00)
{
  STDMETHOD(InitContextMenu)(const wchar_t *folder, const wchar_t * const *names, UInt32 numFiles) PURE;
};

PLUGIN_INTERFACE(IPluginOptionsCallback, 0x01)
{
  STDMETHOD(GetProgramFolderPath)(BSTR *value) PURE;
  STDMETHOD(GetProgramPath)(BSTR *value) PURE;
  STDMETHOD(GetRegistryCUPath)(BSTR *value) PURE;
};

PLUGIN_INTERFACE(IPluginOptions, 0x02)
{
  STDMETHOD(PluginOptions)(HWND hWnd, IPluginOptionsCallback *callback) PURE;
  // STDMETHOD(GetFileExtensions)(BSTR *extensions) PURE;
};
*/

#endif
// PluginLoader.h

#ifndef __PLUGIN_LOADER_H
#define __PLUGIN_LOADER_H

#include "../../../Windows/DLL.h"

#include "IFolder.h"

class CPluginLibrary: public NWindows::NDLL::CLibrary
{
public:
  HRESULT CreateManager(REFGUID clsID, IFolderManager **manager)
  {
    Func_CreateObject createObject = (Func_CreateObject)GetProc("CreateObject");
    if (!createObject)
      return GetLastError();
    return createObject(&clsID, &IID_IFolderManager, (void **)manager);
  }
  HRESULT LoadAndCreateManager(CFSTR filePath, REFGUID clsID, IFolderManager **manager)
  {
    if (!Load(filePath))
      return GetLastError();
    return CreateManager(clsID, manager);
  }
};

#endif
// ProgramLocation.cpp

#include "StdAfx.h"
// ProgramLocation.h

#ifndef __PROGRAM_LOCATION_H
#define __PROGRAM_LOCATION_H

#endif
// ProgressDialog2.cpp

#include "StdAfx.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/Control/Static.h"
#include "../../../Windows/ErrorMsg.h"

#include "../GUI/ExtractRes.h"

#include "LangUtils.h"

#include "DialogSize.h"
#include "ProgressDialog2.h"
#include "ProgressDialog2Res.h"

using namespace NWindows;

extern HINSTANCE g_hInstance;

static const UINT_PTR kTimerID = 3;

static const UINT kCloseMessage = WM_APP + 1;
// we can't use WM_USER, since WM_USER can be used by standard Windows procedure for Dialog

static const UINT kTimerElapse =
  #ifdef UNDER_CE
  500
  #else
  200
  #endif
  ;

static const UINT kCreateDelay =
  #ifdef UNDER_CE
  2500
  #else
  500
  #endif
  ;

static const DWORD kPauseSleepTime = 100;

#ifdef LANG

static const UInt32 kLangIDs[] =
{
  IDT_PROGRESS_ELAPSED,
  IDT_PROGRESS_REMAINING,
  IDT_PROGRESS_TOTAL,
  IDT_PROGRESS_SPEED,
  IDT_PROGRESS_PROCESSED,
  IDT_PROGRESS_RATIO,
  IDT_PROGRESS_ERRORS,
  IDB_PROGRESS_BACKGROUND,
  IDB_PAUSE
};

static const UInt32 kLangIDs_Colon[] =
{
  IDT_PROGRESS_PACKED,
  IDT_PROGRESS_FILES
};

#endif


#define UNDEFINED_VAL ((UInt64)(Int64)-1)
#define INIT_AS_UNDEFINED(v) v = UNDEFINED_VAL;
#define IS_UNDEFINED_VAL(v) ((v) == UNDEFINED_VAL)
#define IS_DEFINED_VAL(v) ((v) != UNDEFINED_VAL)

CProgressSync::CProgressSync():
    _stopped(false), _paused(false),
    _bytesProgressMode(true),
    _totalBytes(UNDEFINED_VAL), _completedBytes(0),
    _totalFiles(UNDEFINED_VAL), _curFiles(0),
    _inSize(UNDEFINED_VAL),
    _outSize(UNDEFINED_VAL),
    _isDir(false)
    {}

#define CHECK_STOP  if (_stopped) return E_ABORT; if (!_paused) return S_OK;
#define CRITICAL_LOCK NSynchronization::CCriticalSectionLock lock(_cs);

bool CProgressSync::Get_Paused()
{
  CRITICAL_LOCK
  return _paused;
}

HRESULT CProgressSync::CheckStop()
{
  for (;;)
  {
    {
      CRITICAL_LOCK
      CHECK_STOP
    }
    ::Sleep(kPauseSleepTime);
  }
}

HRESULT CProgressSync::ScanProgress(UInt64 numFiles, UInt64 totalSize, const FString &fileName, bool isDir)
{
  {
    CRITICAL_LOCK
    _totalFiles = numFiles;
    _totalBytes = totalSize;
    _filePath = fs2us(fileName);
    _isDir = isDir;
    // _completedBytes = 0;
    CHECK_STOP
  }
  return CheckStop();
}

HRESULT CProgressSync::Set_NumFilesTotal(UInt64 val)
{
  {
    CRITICAL_LOCK
    _totalFiles = val;
    CHECK_STOP
  }
  return CheckStop();
}

void CProgressSync::Set_NumBytesTotal(UInt64 val)
{
  CRITICAL_LOCK
  _totalBytes = val;
}

void CProgressSync::Set_NumFilesCur(UInt64 val)
{
  CRITICAL_LOCK
  _curFiles = val;
}

HRESULT CProgressSync::Set_NumBytesCur(const UInt64 *val)
{
  {
    CRITICAL_LOCK
    if (val)
      _completedBytes = *val;
    CHECK_STOP
  }
  return CheckStop();
}

HRESULT CProgressSync::Set_NumBytesCur(UInt64 val)
{
  {
    CRITICAL_LOCK
    _completedBytes = val;
    CHECK_STOP
  }
  return CheckStop();
}

void CProgressSync::Set_Ratio(const UInt64 *inSize, const UInt64 *outSize)
{
  CRITICAL_LOCK
  if (inSize)
    _inSize = *inSize;
  if (outSize)
    _outSize = *outSize;
}

void CProgressSync::Set_TitleFileName(const UString &fileName)
{
  CRITICAL_LOCK
  _titleFileName = fileName;
}

void CProgressSync::Set_Status(const UString &s)
{
  CRITICAL_LOCK
  _status = s;
}

HRESULT CProgressSync::Set_Status2(const UString &s, const wchar_t *path, bool isDir)
{
  {
    CRITICAL_LOCK
    _status = s;
    if (path)
      _filePath = path;
    else
      _filePath.Empty();
    _isDir = isDir;
  }
  return CheckStop();
}

void CProgressSync::Set_FilePath(const wchar_t *path, bool isDir)
{
  CRITICAL_LOCK
  if (path)
    _filePath = path;
  else
    _filePath.Empty();
  _isDir = isDir;
}


void CProgressSync::AddError_Message(const wchar_t *message)
{
  CRITICAL_LOCK
  Messages.Add(message);
}

void CProgressSync::AddError_Message_Name(const wchar_t *message, const wchar_t *name)
{
  UString s;
  if (name && *name != 0)
    s += name;
  if (message && *message != 0 )
  {
    if (!s.IsEmpty())
      s.Add_LF();
    s += message;
    if (!s.IsEmpty() && s.Back() == L'\n')
      s.DeleteBack();
  }
  AddError_Message(s);
}

void CProgressSync::AddError_Code_Name(DWORD systemError, const wchar_t *name)
{
  UString s = NError::MyFormatMessage(systemError);
  if (systemError == 0)
    s = L"Error";
  AddError_Message_Name(s, name);
}

CProgressDialog::CProgressDialog(): _timer(0), CompressingMode(true), MainWindow(0)
{
  _isDir = false;

  _numMessages = 0;
  IconID = -1;
  MessagesDisplayed = false;
  _wasCreated = false;
  _needClose = false;
  _inCancelMessageBox = false;
  _externalCloseMessageWasReceived = false;
  
  _numPostedMessages = 0;
  _numAutoSizeMessages = 0;
  _errorsWereDisplayed = false;
  _waitCloseByCancelButton = false;
  _cancelWasPressed = false;
  ShowCompressionInfo = true;
  // FIXME not supported   WaitMode = false;
  if (_dialogCreatedEvent.Create() != S_OK)
    throw 1334987;
  if (_createDialogEvent.Create() != S_OK)
    throw 1334987;
  #ifdef __ITaskbarList3_INTERFACE_DEFINED__
  CoCreateInstance(CLSID_TaskbarList, NULL, CLSCTX_INPROC_SERVER, IID_ITaskbarList3, (void**)&_taskbarList);
  if (_taskbarList)
    _taskbarList->HrInit();
  #endif
}

#ifndef _SFX

CProgressDialog::~CProgressDialog()
{
  #ifdef __ITaskbarList3_INTERFACE_DEFINED__
  SetTaskbarProgressState(TBPF_NOPROGRESS);
  #endif
  AddToTitle(L"");
}
void CProgressDialog::AddToTitle(LPCWSTR s)
{
  if (MainWindow != 0)
  {
    CWindow window(MainWindow);
    window.SetText((UString)s + MainTitle);
  }
}

#endif


void CProgressDialog::SetTaskbarProgressState()
{
  #ifdef __ITaskbarList3_INTERFACE_DEFINED__
  if (_taskbarList && _hwndForTaskbar)
  {
    TBPFLAG tbpFlags;
    if (Sync.Get_Paused())
      tbpFlags = TBPF_PAUSED;
    else
      tbpFlags = _errorsWereDisplayed ? TBPF_ERROR: TBPF_NORMAL;
    SetTaskbarProgressState(tbpFlags);
  }
  #endif
}

static const unsigned kTitleFileNameSizeLimit = 36;
static const unsigned kCurrentFileNameSizeLimit = 82;

static void ReduceString(UString &s, unsigned size)
{
  if (s.Len() <= size)
    return;
  s.Delete(size / 2, s.Len() - size);
  s.Insert(size / 2, L" ... ");
}

void CProgressDialog::EnableErrorsControls(bool enable)
{
  ShowItem_Bool(IDT_PROGRESS_ERRORS, enable);
  ShowItem_Bool(IDT_PROGRESS_ERRORS_VAL, enable);
  ShowItem_Bool(IDL_PROGRESS_MESSAGES, enable);
}

bool CProgressDialog::OnInit()
{
#ifdef _WIN32
  _hwndForTaskbar = MainWindow;
  if (!_hwndForTaskbar)
    _hwndForTaskbar = GetParent();
  if (!_hwndForTaskbar)
    _hwndForTaskbar = *this;
#endif

  INIT_AS_UNDEFINED(_progressBar_Range);
  INIT_AS_UNDEFINED(_progressBar_Pos);

  INIT_AS_UNDEFINED(_prevPercentValue);
  INIT_AS_UNDEFINED(_prevElapsedSec);
  INIT_AS_UNDEFINED(_prevRemainingSec);

  INIT_AS_UNDEFINED(_prevSpeed);
  _prevSpeed_MoveBits = 0;
  
  _prevTime = ::GetTickCount();
  _elapsedTime = 0;

  INIT_AS_UNDEFINED(_totalBytes_Prev);
  INIT_AS_UNDEFINED(_processed_Prev);
  INIT_AS_UNDEFINED(_packed_Prev);
  INIT_AS_UNDEFINED(_ratio_Prev);
  _filesStr_Prev.Empty();

  _foreground = true;

  m_ProgressBar.Attach(GetItem(IDC_PROGRESS1));
  // FIXME _messageList.Attach(GetItem(IDL_PROGRESS_MESSAGES));
  // FIXME _messageList.SetUnicodeFormat();

  _wasCreated = true;
  _dialogCreatedEvent.Set();

  #ifdef LANG
  LangSetDlgItems(*this, kLangIDs, ARRAY_SIZE(kLangIDs));
  LangSetDlgItems_Colon(*this, kLangIDs_Colon, ARRAY_SIZE(kLangIDs_Colon));
  #endif

  CWindow window(GetItem(IDB_PROGRESS_BACKGROUND));
  window.GetText(_background_String);
  _backgrounded_String = _background_String;
  _backgrounded_String.RemoveChar(L'&');

  window = GetItem(IDB_PAUSE);
  window.GetText(_pause_String);

  LangString(IDS_PROGRESS_FOREGROUND, _foreground_String);
  LangString(IDS_CONTINUE, _continue_String);
  LangString(IDS_PROGRESS_PAUSED, _paused_String);

  SetText(_title);
  SetPauseText();
  SetPriorityText();

  // FIXME _messageList.InsertColumn(0, L"", 30);
  // FIXME _messageList.InsertColumn(1, L"", 600);

  // FIXME _messageList.SetColumnWidthAuto(0);
  // FIXME _messageList.SetColumnWidthAuto(1);

  EnableErrorsControls(false);

  // FIXME GetItemSizes(IDCANCEL, _buttonSizeX, _buttonSizeY);
  _numReduceSymbols = kCurrentFileNameSizeLimit;
  NormalizeSize(true);

  if (!ShowCompressionInfo)
  {
    HideItem(IDT_PROGRESS_PACKED);
    HideItem(IDT_PROGRESS_PACKED_VAL);
    HideItem(IDT_PROGRESS_RATIO);
    HideItem(IDT_PROGRESS_RATIO_VAL);
  }

#ifdef _WIN32
  if (IconID >= 0)
  {
    HICON icon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IconID));
    // SetIcon(ICON_SMALL, icon);
    SetIcon(ICON_BIG, icon);
  }
#endif
  _timer = SetTimer(kTimerID, kTimerElapse);
  #ifdef UNDER_CE
  Foreground();
  #endif

  CheckNeedClose();

  SetTaskbarProgressState();

  return CModalDialog::OnInit();
}

static const UINT kIDs[] =
{
  IDT_PROGRESS_ELAPSED,   IDT_PROGRESS_ELAPSED_VAL,
  IDT_PROGRESS_REMAINING, IDT_PROGRESS_REMAINING_VAL,
  IDT_PROGRESS_FILES,     IDT_PROGRESS_FILES_VAL,
  IDT_PROGRESS_RATIO,     IDT_PROGRESS_RATIO_VAL,
  IDT_PROGRESS_ERRORS,    IDT_PROGRESS_ERRORS_VAL,
  
  IDT_PROGRESS_TOTAL,     IDT_PROGRESS_TOTAL_VAL,
  IDT_PROGRESS_SPEED,     IDT_PROGRESS_SPEED_VAL,
  IDT_PROGRESS_PROCESSED, IDT_PROGRESS_PROCESSED_VAL,
  IDT_PROGRESS_PACKED,    IDT_PROGRESS_PACKED_VAL
};

bool CProgressDialog::OnSize(WPARAM /* wParam */, int xSize, int ySize)
{
#ifdef _WIN32
  int sY;
  int sStep;
  int mx, my;
  {
    RECT r;
    GetClientRectOfItem(IDT_PROGRESS_ELAPSED, r);
    mx = r.left;
    my = r.top;
    sY = RECT_SIZE_Y(r);
    GetClientRectOfItem(IDT_PROGRESS_REMAINING, r);
    sStep = r.top - my;
  }

  InvalidateRect(NULL);

  int xSizeClient = xSize - mx * 2;

  {
    int i;
    for (i = 800; i > 40; i = i * 9 / 10)
      if (Units_To_Pixels_X(i) <= xSizeClient)
        break;
    _numReduceSymbols = i / 4;
  }

  int yPos = ySize - my - _buttonSizeY;

  ChangeSubWindowSizeX(GetItem(IDT_PROGRESS_STATUS), xSize - mx * 2);
  ChangeSubWindowSizeX(GetItem(IDT_PROGRESS_FILE_NAME), xSize - mx * 2);
  ChangeSubWindowSizeX(GetItem(IDC_PROGRESS1), xSize - mx * 2);

  int bSizeX = _buttonSizeX;
  int mx2 = mx;
  for (;; mx2--)
  {
    int bSize2 = bSizeX * 3 + mx2 * 2;
    if (bSize2 <= xSizeClient)
      break;
    if (mx2 < 5)
    {
      bSizeX = (xSizeClient - mx2 * 2) / 3;
      break;
    }
  }
  if (bSizeX < 2)
    bSizeX = 2;

  {
    RECT r;
    GetClientRectOfItem(IDL_PROGRESS_MESSAGES, r);
    int y = r.top;
    int ySize2 = yPos - my - y;
    const int kMinYSize = _buttonSizeY + _buttonSizeY * 3 / 4;
    int xx = xSize - mx * 2;
    if (ySize2 < kMinYSize)
    {
      ySize2 = kMinYSize;
      if (xx > bSizeX * 2)
        xx -= bSizeX;
    }

    _messageList.Move(mx, y, xx, ySize2);
  }

  {
    int xPos = xSize - mx;
    xPos -= bSizeX;
    MoveItem(IDCANCEL, xPos, yPos, bSizeX, _buttonSizeY);
    xPos -= (mx2 + bSizeX);
    MoveItem(IDB_PAUSE, xPos, yPos, bSizeX, _buttonSizeY);
    xPos -= (mx2 + bSizeX);
    MoveItem(IDB_PROGRESS_BACKGROUND, xPos, yPos, bSizeX, _buttonSizeY);
  }

  int valueSize;
  int labelSize;
  int padSize;

  labelSize = Units_To_Pixels_X(MY_PROGRESS_LABEL_UNITS_MIN);
  valueSize = Units_To_Pixels_X(MY_PROGRESS_VAL_UNITS);
  padSize = Units_To_Pixels_X(MY_PROGRESS_PAD_UNITS);
  int requiredSize = (labelSize + valueSize) * 2 + padSize;

  int gSize;
  {
    if (requiredSize < xSizeClient)
    {
      int incr = (xSizeClient - requiredSize) / 3;
      labelSize += incr;
    }
    else
      labelSize = (xSizeClient - valueSize * 2 - padSize) / 2;
    if (labelSize < 0)
      labelSize = 0;

    gSize = labelSize + valueSize;
    padSize = xSizeClient - gSize * 2;
  }

  labelSize = gSize - valueSize;

  yPos = my;
  for (int i = 0; i < ARRAY_SIZE(kIDs); i += 2)
  {
    int x = mx;
    const int kNumColumn1Items = 5 * 2;
    if (i >= kNumColumn1Items)
    {
      if (i == kNumColumn1Items)
        yPos = my;
      x = mx + gSize + padSize;
    }
    MoveItem(kIDs[i], x, yPos, labelSize, sY);
    MoveItem(kIDs[i + 1], x + labelSize, yPos, valueSize, sY);
    yPos += sStep;
  }
#endif
  return false;
}

void CProgressDialog::OnCancel() { Sync.Set_Stopped(true); }
void CProgressDialog::OnOK() { }

void CProgressDialog::SetProgressRange(UInt64 range)
{
  if (range == _progressBar_Range)
    return;
  _progressBar_Range = range;
  INIT_AS_UNDEFINED(_progressBar_Pos);
  _progressConv.Init(range);
  m_ProgressBar.SetRange32(0, _progressConv.Count(range));
}

void CProgressDialog::SetProgressPos(UInt64 pos)
{
  if (pos >= _progressBar_Range ||
      pos <= _progressBar_Pos ||
      pos - _progressBar_Pos >= (_progressBar_Range >> 10))
  {
    m_ProgressBar.SetPos(_progressConv.Count(pos));
    #ifdef __ITaskbarList3_INTERFACE_DEFINED__
    if (_taskbarList && _hwndForTaskbar)
      _taskbarList->SetProgressValue(_hwndForTaskbar, pos, _progressBar_Range);
    #endif
    _progressBar_Pos = pos;
  }
}

#define UINT_TO_STR_2(val) { s[0] = (wchar_t)('0' + (val) / 10); s[1] = (wchar_t)('0' + (val) % 10); s += 2; }

void GetTimeString(UInt64 timeValue, wchar_t *s)
{
  UInt64 hours = timeValue / 3600;
  UInt32 seconds = (UInt32)(timeValue - hours * 3600);
  UInt32 minutes = seconds / 60;
  seconds %= 60;
  if (hours > 99)
  {
    ConvertUInt64ToString(hours, s);
    for (; *s != 0; s++);
  }
  else
  {
    UInt32 hours32 = (UInt32)hours;
    UINT_TO_STR_2(hours32);
  }
  *s++ = ':'; UINT_TO_STR_2(minutes);
  *s++ = ':'; UINT_TO_STR_2(seconds);
  *s = 0;
}

static void ConvertSizeToString(UInt64 v, wchar_t *s)
{
  Byte c = 0;
       if (v >= ((UInt64)100000 << 20)) { v >>= 30; c = 'G'; }
  else if (v >= ((UInt64)100000 << 10)) { v >>= 20; c = 'M'; }
  else if (v >= ((UInt64)100000 <<  0)) { v >>= 10; c = 'K'; }
  ConvertUInt64ToString(v, s);
  if (c != 0)
  {
    s += MyStringLen(s);
    *s++ = ' ';
    *s++ = c;
    *s++ = 0;
  }
}

void CProgressDialog::ShowSize(int id, UInt64 val, UInt64 &prev)
{
  if (val == prev)
    return;
  prev = val;
  wchar_t s[40];
  s[0] = 0;
  if (IS_DEFINED_VAL(val))
    ConvertSizeToString(val, s);
  SetItemText(id, s);
}

static void GetChangedString(const UString &newStr, UString &prevStr, bool &hasChanged)
{
  hasChanged = !(prevStr == newStr);
  if (hasChanged)
    prevStr = newStr;
}

static unsigned GetPower32(UInt32 val)
{
  const unsigned kStart = 32;
  UInt32 mask = ((UInt32)1 << (kStart - 1));
  for (unsigned i = kStart;; i--)
  {
    if (i == 0 || (val & mask) != 0)
      return i;
    mask >>= 1;
  }
}

static unsigned GetPower64(UInt64 val)
{
  UInt32 high = (UInt32)(val >> 32);
  if (high == 0)
    return GetPower32((UInt32)val);
  return GetPower32(high) + 32;
}

static UInt64 MyMultAndDiv(UInt64 mult1, UInt64 mult2, UInt64 divider)
{
  unsigned pow1 = GetPower64(mult1);
  unsigned pow2 = GetPower64(mult2);
  while (pow1 + pow2 > 64)
  {
    if (pow1 > pow2) { pow1--; mult1 >>= 1; }
    else             { pow2--; mult2 >>= 1; }
    divider >>= 1;
  }
  UInt64 res = mult1 * mult2;
  if (divider != 0)
    res /= divider;
  return res;
}

void CProgressDialog::UpdateStatInfo(bool showAll)
{
  UInt64 total, completed, totalFiles, completedFiles, inSize, outSize;
  bool bytesProgressMode;

  bool titleFileName_Changed;
  bool curFilePath_Changed;
  bool status_Changed;
  unsigned numErrors;
  {
    NSynchronization::CCriticalSectionLock lock(Sync._cs);
    total = Sync._totalBytes;
    completed = Sync._completedBytes;
    totalFiles = Sync._totalFiles;
    completedFiles = Sync._curFiles;
    inSize = Sync._inSize;
    outSize = Sync._outSize;
    bytesProgressMode = Sync._bytesProgressMode;

    GetChangedString(Sync._titleFileName, _titleFileName, titleFileName_Changed);
    GetChangedString(Sync._filePath, _filePath, curFilePath_Changed);
    GetChangedString(Sync._status, _status, status_Changed);
    if (_isDir != Sync._isDir)
    {
      curFilePath_Changed = true;
      _isDir = Sync._isDir;
    }
    numErrors = Sync.Messages.Size();
  }

  UInt32 curTime = ::GetTickCount();

  const UInt64 progressTotal = bytesProgressMode ? total : totalFiles;
  const UInt64 progressCompleted = bytesProgressMode ? completed : completedFiles;
  {
    if (IS_UNDEFINED_VAL(progressTotal))
    {
      // SetPos(0);
      // SetRange(progressCompleted);
    }
    else
    {
      if (_progressBar_Pos != 0 || progressCompleted != 0 ||
          (_progressBar_Range == 0 && progressTotal != 0))
      {
        SetProgressRange(progressTotal);
        SetProgressPos(progressCompleted);
      }
    }
  }

  ShowSize(IDT_PROGRESS_TOTAL_VAL, total, _totalBytes_Prev);

  _elapsedTime += (curTime - _prevTime);
  _prevTime = curTime;
  UInt64 elapsedSec = _elapsedTime / 1000;
  bool elapsedChanged = false;
  if (elapsedSec != _prevElapsedSec)
  {
    _prevElapsedSec = elapsedSec;
    elapsedChanged = true;
    wchar_t s[40];
    GetTimeString(elapsedSec, s);
    SetItemText(IDT_PROGRESS_ELAPSED_VAL, s);
  }

  bool needSetTitle = false;
  if (elapsedChanged || showAll)
  {
    if (numErrors > _numPostedMessages)
    {
      UpdateMessagesDialog();
      wchar_t s[32];
      ConvertUInt64ToString(numErrors, s);
      SetItemText(IDT_PROGRESS_ERRORS_VAL, s);
      if (!_errorsWereDisplayed)
      {
        _errorsWereDisplayed = true;
        EnableErrorsControls(true);
        SetTaskbarProgressState();
      }
    }

    if (progressCompleted != 0)
    {
      if (IS_UNDEFINED_VAL(progressTotal))
      {
        if (IS_DEFINED_VAL(_prevRemainingSec))
        {
          INIT_AS_UNDEFINED(_prevRemainingSec);
          SetItemText(IDT_PROGRESS_REMAINING_VAL, L"");
        }
      }
      else
      {
        UInt64 remainingTime = 0;
        if (progressCompleted < progressTotal)
          remainingTime = MyMultAndDiv(_elapsedTime, progressTotal - progressCompleted, progressCompleted);
        UInt64 remainingSec = remainingTime / 1000;
        if (remainingSec != _prevRemainingSec)
        {
          _prevRemainingSec = remainingSec;
          wchar_t s[40];
          GetTimeString(remainingSec, s);
          SetItemText(IDT_PROGRESS_REMAINING_VAL, s);
        }
      }
      {
        UInt64 elapsedTime = (_elapsedTime == 0) ? 1 : _elapsedTime;
        UInt64 v = (progressCompleted * 1000) / elapsedTime;
        Byte c = 0;
        unsigned moveBits = 0;
             if (v >= ((UInt64)10000 << 10)) { moveBits = 20; c = 'M'; }
        else if (v >= ((UInt64)10000 <<  0)) { moveBits = 10; c = 'K'; }
        v >>= moveBits;
        if (moveBits != _prevSpeed_MoveBits || v != _prevSpeed)
        {
          _prevSpeed_MoveBits = moveBits;
          _prevSpeed = v;
          wchar_t s[40];
          ConvertUInt64ToString(v, s);
          unsigned pos = MyStringLen(s);
          s[pos++] = ' ';
          if (moveBits != 0)
            s[pos++] = c;
          s[pos++] = 'B';
          s[pos++] = '/';
          s[pos++] = 's';
          s[pos++] = 0;
          SetItemText(IDT_PROGRESS_SPEED_VAL, s);
        }
      }
    }

    {
      UInt64 percent = 0;
      {
        if (IS_DEFINED_VAL(progressTotal))
        {
          percent = progressCompleted * 100;
          if (progressTotal != 0)
            percent /= progressTotal;
        }
      }
      if (percent != _prevPercentValue)
      {
        _prevPercentValue = percent;
        needSetTitle = true;
      }
    }
    
    {
      wchar_t s[64];
      ConvertUInt64ToString(completedFiles, s);
      if (IS_DEFINED_VAL(totalFiles))
      {
        wcscat(s, L" / ");
        ConvertUInt64ToString(totalFiles, s + wcslen(s));
      }
      if (_filesStr_Prev != s)
      {
        _filesStr_Prev = s;
        SetItemText(IDT_PROGRESS_FILES_VAL, s);
      }
    }
    
    const UInt64 packSize   = CompressingMode ? outSize : inSize;
    const UInt64 unpackSize = CompressingMode ? inSize : outSize;

    if (IS_UNDEFINED_VAL(unpackSize) &&
        IS_UNDEFINED_VAL(packSize))
    {
      ShowSize(IDT_PROGRESS_PROCESSED_VAL, completed, _processed_Prev);
      ShowSize(IDT_PROGRESS_PACKED_VAL, UNDEFINED_VAL, _packed_Prev);
    }
    else
    {
      ShowSize(IDT_PROGRESS_PROCESSED_VAL, unpackSize, _processed_Prev);
      ShowSize(IDT_PROGRESS_PACKED_VAL, packSize, _packed_Prev);
      
      if (IS_DEFINED_VAL(packSize) &&
          IS_DEFINED_VAL(unpackSize) &&
          unpackSize != 0)
      {
        wchar_t s[32];
        UInt64 ratio = packSize * 100 / unpackSize;
        if (_ratio_Prev != ratio)
        {
          _ratio_Prev = ratio;
          ConvertUInt64ToString(ratio, s);
          wcscat(s, L"%");
          SetItemText(IDT_PROGRESS_RATIO_VAL, s);
        }
      }
    }
  }

  if (needSetTitle || titleFileName_Changed)
    SetTitleText();

  if (status_Changed)
  {
    UString s = _status;
    ReduceString(s, _numReduceSymbols);
    SetItemText(IDT_PROGRESS_STATUS, _status);
  }

  if (curFilePath_Changed)
  {
    UString s1, s2;
    if (_isDir)
      s1 = _filePath;
    else
    {
      int slashPos = _filePath.ReverseFind_PathSepar();
      if (slashPos >= 0)
      {
        s1.SetFrom(_filePath, slashPos + 1);
        s2 = _filePath.Ptr(slashPos + 1);
      }
      else
        s2 = _filePath;
    }
    ReduceString(s1, _numReduceSymbols);
    ReduceString(s2, _numReduceSymbols);
    s1.Add_LF();
    s1 += s2;
    SetItemText(IDT_PROGRESS_FILE_NAME, s1);
  }
}

bool CProgressDialog::OnTimer(WPARAM /* timerID */, LPARAM /* callback */)
{
  if (Sync.Get_Paused())
    return true;
  CheckNeedClose();
  UpdateStatInfo(false);
  return true;
}

#ifdef _WIN32 // FIXME
struct CWaitCursor
{
  HCURSOR _waitCursor;
  HCURSOR _oldCursor;
  CWaitCursor()
  {
    _waitCursor = LoadCursor(NULL, IDC_WAIT);
    if (_waitCursor != NULL)
      _oldCursor = SetCursor(_waitCursor);
  }
  ~CWaitCursor()
  {
    if (_waitCursor != NULL)
      SetCursor(_oldCursor);
  }
};
#endif

INT_PTR CProgressDialog::Create(const UString &title, NWindows::CThread &thread, HWND wndParent)
{
  INT_PTR res = 0;
  try
  {
#ifdef _WIN32
    if (WaitMode)
    {
      CWaitCursor waitCursor;
      HANDLE h[] = { thread, _createDialogEvent };
      
      WRes res = WaitForMultipleObjects(ARRAY_SIZE(h), h, FALSE, kCreateDelay);
      if (res == WAIT_OBJECT_0 && !Sync.ThereIsMessage())
        return 0;
    }
#endif
    _title = title;
    BIG_DIALOG_SIZE(360, 192);
    res = CModalDialog::Create(SIZED_DIALOG(IDD_PROGRESS), wndParent);
  }
  catch(...)
  {
    _wasCreated = true;
    _dialogCreatedEvent.Set();
    res = res;
  }
  thread.Wait();
  if (!MessagesDisplayed)
    MessageBoxW(wndParent, L"Progress Error", L"7-Zip", MB_ICONERROR);
  return res;
}

bool CProgressDialog::OnExternalCloseMessage()
{
  // it doesn't work if there is MessageBox.
  #ifdef __ITaskbarList3_INTERFACE_DEFINED__
  SetTaskbarProgressState(TBPF_NOPROGRESS);
  #endif
  // AddToTitle(L"Finished ");
  // SetText(L"Finished2 ");

  UpdateStatInfo(true);
  
  SetItemText(IDCANCEL, LangString(IDS_CLOSE));
  // FIXME ::SendMessage(GetItem(IDCANCEL), BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));
  HideItem(IDB_PROGRESS_BACKGROUND);
  HideItem(IDB_PAUSE);
  
  bool thereAreMessages;
  CProgressFinalMessage fm;
  {
    NSynchronization::CCriticalSectionLock lock(Sync._cs);
    thereAreMessages = !Sync.Messages.IsEmpty();
    fm = Sync.FinalMessage;
  }
  if (!fm.ErrorMessage.Message.IsEmpty())
  {
    MessagesDisplayed = true;
    if (fm.ErrorMessage.Title.IsEmpty())
      fm.ErrorMessage.Title = L"7-Zip";
    MessageBoxW(*this, fm.ErrorMessage.Message, fm.ErrorMessage.Title, MB_ICONERROR);
  }
  else if (!thereAreMessages)
  {
    MessagesDisplayed = true;
    if (!fm.OkMessage.Message.IsEmpty())
    {
      if (fm.OkMessage.Title.IsEmpty())
        fm.OkMessage.Title = L"7-Zip";
      MessageBoxW(*this, fm.OkMessage.Message, fm.OkMessage.Title, MB_OK);
    }
  }

  if (thereAreMessages && !_cancelWasPressed)
  {
#ifdef _WIN32
    _waitCloseByCancelButton = true;
    UpdateMessagesDialog();
    return true;
#else
 
	// FIXME : p7zip does not have a messages zone
	// FIXME : even if so, the close button does not close the main window
	// So p7zip uses a MessageBoxW ...
	  UStringVector messages;
	  {
		  NWindows::NSynchronization::CCriticalSectionLock lock(Sync._cs);
		  for (int i = 0; i < Sync.Messages.Size(); i++)
			  messages.Add(Sync.Messages[i]);
		  _numPostedMessages = Sync.Messages.Size();
	  }
	  
	  if (!messages.IsEmpty())
	  {
		  for (int i = 0; i < messages.Size(); i++)
			  fm.ErrorMessage.Message = fm.ErrorMessage.Message + messages[i] + L"\n";
	  }
	  else
		  fm.ErrorMessage.Message = L"Error(s) in the archive";
	  
	  MessageBoxW(*this, fm.ErrorMessage.Message, L"7-Zip - ERROR", MB_ICONERROR | MB_OK);

	  MessagesDisplayed = true;
#endif	  
  }

  End(0);
  return true;
}

bool CProgressDialog::OnMessage(UINT message, WPARAM wParam, LPARAM lParam)
{
  switch (message)
  {
    case kCloseMessage:
    {
      KillTimer(_timer);
      _timer = 0;
      if (_inCancelMessageBox)
      {
        _externalCloseMessageWasReceived = true;
        break;
      }
      return OnExternalCloseMessage();
    }
    /*
    case WM_SETTEXT:
    {
      if (_timer == 0)
        return true;
      break;
    }
    */
  }
  return CModalDialog::OnMessage(message, wParam, lParam);
}

void CProgressDialog::SetTitleText()
{
  UString s;
  if (Sync.Get_Paused())
  {
    s += _paused_String;
    s.Add_Space();
  }
  if (IS_DEFINED_VAL(_prevPercentValue))
  {
    char temp[32];
    ConvertUInt64ToString(_prevPercentValue, temp);
    s.AddAscii(temp);
    s += L'%';
  }
  if (!_foreground)
  {
    s.Add_Space();
    s += _backgrounded_String;
  }

  s.Add_Space();
  #ifndef _SFX
  {
    unsigned len = s.Len();
    s += MainAddTitle;
    AddToTitle(s);
    s.DeleteFrom(len);
  }
  #endif

  s += _title;
  if (!_titleFileName.IsEmpty())
  {
    UString fileName = _titleFileName;
    ReduceString(fileName, kTitleFileNameSizeLimit);
    s.Add_Space();
    s += fileName;
  }
  SetText(s);
}

void CProgressDialog::SetPauseText()
{
  SetItemText(IDB_PAUSE, Sync.Get_Paused() ? _continue_String : _pause_String);
  SetTitleText();
}

void CProgressDialog::OnPauseButton()
{
  bool paused = !Sync.Get_Paused();
  Sync.Set_Paused(paused);
  UInt32 curTime = ::GetTickCount();
  if (paused)
    _elapsedTime += (curTime - _prevTime);
  SetTaskbarProgressState();
  _prevTime = curTime;
  SetPauseText();
}

void CProgressDialog::SetPriorityText()
{
  SetItemText(IDB_PROGRESS_BACKGROUND, _foreground ?
      _background_String :
      _foreground_String);
  SetTitleText();
}

void CProgressDialog::OnPriorityButton()
{
  _foreground = !_foreground;
  #ifndef UNDER_CE
  SetPriorityClass(GetCurrentProcess(), _foreground ? NORMAL_PRIORITY_CLASS: IDLE_PRIORITY_CLASS);
  #endif
  SetPriorityText();
}

void CProgressDialog::AddMessageDirect(LPCWSTR message, bool needNumber)
{
#ifdef _WIN32 // FIXME
  int itemIndex = _messageList.GetItemCount();
  wchar_t sz[16];
  sz[0] = 0;
  if (needNumber)
    ConvertUInt32ToString(_numMessages + 1, sz);
  _messageList.InsertItem(itemIndex, sz);
  _messageList.SetSubItem(itemIndex, 1, message);
#endif
}

void CProgressDialog::AddMessage(LPCWSTR message)
{
  UString s = message;
  bool needNumber = true;
  while (!s.IsEmpty())
  {
    int pos = s.Find(L'\n');
    if (pos < 0)
      break;
    AddMessageDirect(s.Left(pos), needNumber);
    needNumber = false;
    s.DeleteFrontal(pos + 1);
  }
  AddMessageDirect(s, needNumber);
  _numMessages++;
}

static unsigned GetNumDigits(UInt32 val)
{
  unsigned i;
  for (i = 0; val >= 10; i++)
    val /= 10;
  return i;
}

void CProgressDialog::UpdateMessagesDialog()
{
  UStringVector messages;
  {
    NSynchronization::CCriticalSectionLock lock(Sync._cs);
    unsigned num = Sync.Messages.Size();
    if (num > _numPostedMessages)
    {
      messages.ClearAndReserve(num - _numPostedMessages);
      for (unsigned i = _numPostedMessages; i < num; i++)
        messages.AddInReserved(Sync.Messages[i]);
      _numPostedMessages = num;
    }
  }
  if (!messages.IsEmpty())
  {
    FOR_VECTOR (i, messages)
      AddMessage(messages[i]);
    if (_numAutoSizeMessages < 256 || GetNumDigits(_numPostedMessages) > GetNumDigits(_numAutoSizeMessages))
    {
      // FIXME _messageList.SetColumnWidthAuto(0);
      // FIXME _messageList.SetColumnWidthAuto(1);
      _numAutoSizeMessages = _numPostedMessages;
    }
  }
}


bool CProgressDialog::OnButtonClicked(int buttonID, HWND buttonHWND)
{
  switch (buttonID)
  {
    // case IDOK: // if IDCANCEL is not DEFPUSHBUTTON
    case IDCANCEL:
    {
      if (_waitCloseByCancelButton)
      {
        MessagesDisplayed = true;
        End(IDCLOSE);
        break;
      }
        
      bool paused = Sync.Get_Paused();
      if (!paused)
        OnPauseButton();
      _inCancelMessageBox = true;
      int res = ::MessageBoxW(*this, LangString(IDS_PROGRESS_ASK_CANCEL), _title, MB_YESNOCANCEL);
      _inCancelMessageBox = false;
      if (!paused)
        OnPauseButton();
      if (res == IDCANCEL || res == IDNO)
      {
        if (_externalCloseMessageWasReceived)
          OnExternalCloseMessage();
        return true;
      }

      _cancelWasPressed = true;
      MessagesDisplayed = true;
      break;
    }

    case IDB_PAUSE:
      OnPauseButton();
      return true;
    case IDB_PROGRESS_BACKGROUND:
      OnPriorityButton();
      return true;
  }
  return CModalDialog::OnButtonClicked(buttonID, buttonHWND);
}

void CProgressDialog::CheckNeedClose()
{
  if (_needClose)
  {
    PostMsg(kCloseMessage);
    _needClose = false;
  }
}

void CProgressDialog::ProcessWasFinished()
{
  // Set Window title here.
  // FIXME - not supported if (!WaitMode)
    WaitCreating();
  
  if (_wasCreated)
    PostMsg(kCloseMessage);
  else
    _needClose = true;
}


HRESULT CProgressThreadVirt::Create(const UString &title, HWND parentWindow)
{
  NWindows::CThread thread;
  RINOK(thread.Create(MyThreadFunction, this));
  ProgressDialog.Create(title, thread, parentWindow);
  return S_OK;
}

static void AddMessageToString(UString &dest, const UString &src)
{
  if (!src.IsEmpty())
  {
    if (!dest.IsEmpty())
      dest.Add_LF();
    dest += src;
  }
}

void CProgressThreadVirt::Process()
{
  CProgressCloser closer(ProgressDialog);
  UString m;
  try { Result = ProcessVirt(); }
  catch(const wchar_t *s) { m = s; }
  catch(const UString &s) { m = s; }
  catch(const char *s) { m = GetUnicodeString(s); }
  catch(int v)
  {
    wchar_t s[16];
    ConvertUInt32ToString(v, s);
    m = L"Error #";
    m += s;
  }
  catch(...) { m = L"Error"; }
  if (Result != E_ABORT)
  {
    if (m.IsEmpty() && Result != S_OK)
      m = HResultToMessage(Result);
  }
  AddMessageToString(m, FinalMessage.ErrorMessage.Message);

  {
    FOR_VECTOR(i, ErrorPaths)
    {
      if (i >= 32)
        break;
      AddMessageToString(m, fs2us(ErrorPaths[i]));
    }
  }

  CProgressSync &sync = ProgressDialog.Sync;
  NSynchronization::CCriticalSectionLock lock(sync._cs);
  if (m.IsEmpty())
  {
    if (!FinalMessage.OkMessage.Message.IsEmpty())
      sync.FinalMessage.OkMessage = FinalMessage.OkMessage;
  }
  else
  {
    sync.FinalMessage.ErrorMessage.Message = m;
    if (Result == S_OK)
      Result = E_FAIL;
  }
}

UString HResultToMessage(HRESULT errorCode)
{
  if (errorCode == E_OUTOFMEMORY)
    return LangString(IDS_MEM_ERROR);
  else
    return NError::MyFormatMessage(errorCode);
}
// ProgressDialog2.h

#ifndef __PROGRESS_DIALOG_2_H
#define __PROGRESS_DIALOG_2_H

#include "../../../Common/MyCom.h"

#include "../../../Windows/ErrorMsg.h"
#include "../../../Windows/Synchronization.h"
#include "../../../Windows/Thread.h"

#include "../../../Windows/Control/Dialog.h"
#include "../../../Windows/Control/ListView.h"
#include "../../../Windows/Control/ProgressBar.h"

#include "MyWindowsNew.h"

struct CProgressMessageBoxPair
{
  UString Title;
  UString Message;
};

struct CProgressFinalMessage
{
  CProgressMessageBoxPair ErrorMessage;
  CProgressMessageBoxPair OkMessage;

  bool ThereIsMessage() const { return !ErrorMessage.Message.IsEmpty() || !OkMessage.Message.IsEmpty(); }
};

class CProgressSync
{
  bool _stopped;
  bool _paused;

public:
  bool _bytesProgressMode;
  UInt64 _totalBytes;
  UInt64 _completedBytes;
  UInt64 _totalFiles;
  UInt64 _curFiles;
  UInt64 _inSize;
  UInt64 _outSize;
  
  UString _titleFileName;
  UString _status;
  UString _filePath;
  bool _isDir;

  UStringVector Messages;
  CProgressFinalMessage FinalMessage;

  NWindows::NSynchronization::CCriticalSection _cs;

  CProgressSync();

  bool Get_Stopped()
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(_cs);
    return _stopped;
  }
  void Set_Stopped(bool val)
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(_cs);
    _stopped = val;
  }
  
  bool Get_Paused();
  void Set_Paused(bool val)
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(_cs);
    _paused = val;
  }
  
  void Set_BytesProgressMode(bool bytesProgressMode)
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(_cs);
    _bytesProgressMode = bytesProgressMode;
  }
  
  HRESULT CheckStop();
  HRESULT ScanProgress(UInt64 numFiles, UInt64 totalSize, const FString &fileName, bool isDir = false);

  HRESULT Set_NumFilesTotal(UInt64 val);
  void Set_NumBytesTotal(UInt64 val);
  void Set_NumFilesCur(UInt64 val);
  HRESULT Set_NumBytesCur(const UInt64 *val);
  HRESULT Set_NumBytesCur(UInt64 val);
  void Set_Ratio(const UInt64 *inSize, const UInt64 *outSize);

  void Set_TitleFileName(const UString &fileName);
  void Set_Status(const UString &s);
  HRESULT Set_Status2(const UString &s, const wchar_t *path, bool isDir = false);
  void Set_FilePath(const wchar_t *path, bool isDir = false);

  void AddError_Message(const wchar_t *message);
  void AddError_Message_Name(const wchar_t *message, const wchar_t *name);
  void AddError_Code_Name(DWORD systemError, const wchar_t *name);

  bool ThereIsMessage() const { return !Messages.IsEmpty() || FinalMessage.ThereIsMessage(); }
};

class CProgressDialog: public NWindows::NControl::CModalDialog
{
  UString _titleFileName;
  UString _filePath;
  UString _status;
  bool _isDir;

  UString _background_String;
  UString _backgrounded_String;
  UString _foreground_String;
  UString _pause_String;
  UString _continue_String;
  UString _paused_String;

  int _buttonSizeX;
  int _buttonSizeY;

  UINT_PTR _timer;

  UString _title;

  class CU64ToI32Converter
  {
    unsigned _numShiftBits;
    UInt64 _range;
  public:
    CU64ToI32Converter(): _numShiftBits(0), _range(1) {}
    void Init(UInt64 range)
    {
      _range = range;
      // Windows CE doesn't like big number for ProgressBar.
      for (_numShiftBits = 0; range >= ((UInt32)1 << 15); _numShiftBits++)
        range >>= 1;
    }
    int Count(UInt64 val)
    {
      int res = (int)(val >> _numShiftBits);
      if (val == _range)
        res++;
      return res;
    }
  };
  
  CU64ToI32Converter _progressConv;
  UInt64 _progressBar_Pos;
  UInt64 _progressBar_Range;
  
  NWindows::NControl::CProgressBar m_ProgressBar;
  // FIXME NWindows::NControl::CListView _messageList;
  
  int _numMessages;

  #ifdef __ITaskbarList3_INTERFACE_DEFINED__
  CMyComPtr<ITaskbarList3> _taskbarList;
  #endif
  HWND _hwndForTaskbar;

  UInt32 _prevTime;
  UInt64 _elapsedTime;

  UInt64 _prevPercentValue;
  UInt64 _prevElapsedSec;
  UInt64 _prevRemainingSec;

  UInt64 _totalBytes_Prev;
  UInt64 _processed_Prev;
  UInt64 _packed_Prev;
  UInt64 _ratio_Prev;
  UString _filesStr_Prev;

  unsigned _prevSpeed_MoveBits;
  UInt64 _prevSpeed;

  bool _foreground;

  unsigned _numReduceSymbols;

  bool _wasCreated;
  bool _needClose;

  unsigned _numPostedMessages;
  UInt32 _numAutoSizeMessages;

  bool _errorsWereDisplayed;

  bool _waitCloseByCancelButton;
  bool _cancelWasPressed;
  
  bool _inCancelMessageBox;
  bool _externalCloseMessageWasReceived;


  #ifdef __ITaskbarList3_INTERFACE_DEFINED__
  void SetTaskbarProgressState(TBPFLAG tbpFlags)
  {
    if (_taskbarList && _hwndForTaskbar)
      _taskbarList->SetProgressState(_hwndForTaskbar, tbpFlags);
  }
  #endif
  void SetTaskbarProgressState();

  void UpdateStatInfo(bool showAll);
  bool OnTimer(WPARAM timerID, LPARAM callback);
  void SetProgressRange(UInt64 range);
  void SetProgressPos(UInt64 pos);
  virtual bool OnInit();
  virtual bool OnSize(WPARAM wParam, int xSize, int ySize);
  virtual void OnCancel();
  virtual void OnOK();
  NWindows::NSynchronization::CManualResetEvent _createDialogEvent;
  NWindows::NSynchronization::CManualResetEvent _dialogCreatedEvent;
  #ifndef _SFX
  void AddToTitle(LPCWSTR string);
  #endif

  void SetPauseText();
  void SetPriorityText();
  void OnPauseButton();
  void OnPriorityButton();
  bool OnButtonClicked(int buttonID, HWND buttonHWND);
  bool OnMessage(UINT message, WPARAM wParam, LPARAM lParam);

  void SetTitleText();
  void ShowSize(int id, UInt64 val, UInt64 &prev);

  void UpdateMessagesDialog();

  void AddMessageDirect(LPCWSTR message, bool needNumber);
  void AddMessage(LPCWSTR message);

  bool OnExternalCloseMessage();
  void EnableErrorsControls(bool enable);

  void ShowAfterMessages(HWND wndParent);

  void CheckNeedClose();
public:
  CProgressSync Sync;
  bool CompressingMode;
  // FIXME - not supported bool WaitMode;
  bool ShowCompressionInfo;
  bool MessagesDisplayed; // = true if user pressed OK on all messages or there are no messages.
  int IconID;

  HWND MainWindow;
  #ifndef _SFX
  UString MainTitle;
  UString MainAddTitle;
  ~CProgressDialog();
  #endif

  CProgressDialog();
  void WaitCreating()
  {
    _createDialogEvent.Set();
    _dialogCreatedEvent.Lock();
  }

  INT_PTR Create(const UString &title, NWindows::CThread &thread, HWND wndParent = 0);

  void ProcessWasFinished();
};


class CProgressCloser
{
  CProgressDialog *_p;
public:
  CProgressCloser(CProgressDialog &p) : _p(&p) {}
  ~CProgressCloser() { _p->ProcessWasFinished(); }
};

class CProgressThreadVirt
{
protected:
  FStringVector ErrorPaths;
  CProgressFinalMessage FinalMessage;

  // error if any of HRESULT, ErrorMessage, ErrorPath
  virtual HRESULT ProcessVirt() = 0;
  void Process();
public:
  HRESULT Result;
  bool ThreadFinishedOK; // if there is no fatal exception
  CProgressDialog ProgressDialog;

  static THREAD_FUNC_DECL MyThreadFunction(void *param)
  {
    CProgressThreadVirt *p = (CProgressThreadVirt *)param;
    try
    {
      p->Process();
      p->ThreadFinishedOK = true;
    }
    catch (...) { p->Result = E_FAIL; }
    return 0;
  }

  void AddErrorPath(const FString &path) { ErrorPaths.Add(path); }

  HRESULT Create(const UString &title, HWND parentWindow = 0);
  CProgressThreadVirt(): Result(E_FAIL), ThreadFinishedOK(false) {}

  CProgressMessageBoxPair &GetMessagePair(bool isError) { return isError ? FinalMessage.ErrorMessage : FinalMessage.OkMessage; }

};

UString HResultToMessage(HRESULT errorCode);

#endif
#define IDD_PROGRESS       97
#define IDD_PROGRESS_2  10097

#define IDS_CLOSE                  408
#define IDS_CONTINUE               411

#define IDB_PROGRESS_BACKGROUND    444
#define IDS_PROGRESS_FOREGROUND    445
#define IDB_PAUSE                  446
#define IDS_PROGRESS_PAUSED        447
#define IDS_PROGRESS_ASK_CANCEL    448

#define IDT_PROGRESS_PACKED       1008
#define IDT_PROGRESS_FILES        1032

#define IDT_PROGRESS_ELAPSED      3900
#define IDT_PROGRESS_REMAINING    3901
#define IDT_PROGRESS_TOTAL        3902
#define IDT_PROGRESS_SPEED        3903
#define IDT_PROGRESS_PROCESSED    3904
#define IDT_PROGRESS_RATIO        3905
#define IDT_PROGRESS_ERRORS       3906

#define IDC_PROGRESS1              100
#define IDL_PROGRESS_MESSAGES      101
#define IDT_PROGRESS_FILE_NAME     102
#define IDT_PROGRESS_STATUS        103

#define IDT_PROGRESS_PACKED_VAL    110
#define IDT_PROGRESS_FILES_VAL     111

#define IDT_PROGRESS_ELAPSED_VAL   120
#define IDT_PROGRESS_REMAINING_VAL 121
#define IDT_PROGRESS_TOTAL_VAL     122
#define IDT_PROGRESS_SPEED_VAL     123
#define IDT_PROGRESS_PROCESSED_VAL 124
#define IDT_PROGRESS_RATIO_VAL     125
#define IDT_PROGRESS_ERRORS_VAL    126


#ifdef UNDER_CE
#define MY_PROGRESS_VAL_UNITS  44
#else
#define MY_PROGRESS_VAL_UNITS  76
#endif
#define MY_PROGRESS_LABEL_UNITS_MIN   60
#define MY_PROGRESS_LABEL_UNITS_START 90
#define MY_PROGRESS_PAD_UNITS  4
// ProgressDialog2_rc.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#undef _WIN32

#include "ProgressDialog2Res.h"

#include "Windows/Control/DialogImpl.h"

/*
IDD_PROGRESS  DIALOG  0, 0, xSize, ySize  MY_MODAL_DIALOG_STYLE | WS_MINIMIZEBOX 
CAPTION "Progress"
MY_FONT
BEGIN
  PUSHBUTTON  "&Background", IDB_PROGRESS_BACKGROUND,  bXPos3, bYPos, bXSize, bYSize
  PUSHBUTTON  "&Pause",      IDB_PAUSE,              bXPos2, bYPos, bXSize, bYSize
  PUSHBUTTON  "Cancel",      IDCANCEL,                      bXPos1, bYPos, bXSize, bYSize
  LTEXT  "Elapsed time:",   IDT_PROGRESS_ELAPSED,   marg, y0, x0Size, 8
  LTEXT  "Remaining time:", IDT_PROGRESS_REMAINING, marg, y1, x0Size, 8
  LTEXT  "Files:",          IDT_PROGRESS_FILES,     marg, y2, x0Size, 8
  LTEXT  "Compression ratio:",IDT_PROGRESS_RATIO,   marg, y3, x0Size, 8

  LTEXT  "Total size:",      IDT_PROGRESS_TOTAL,    x2, y0, x2Size, 8
  LTEXT  "Speed:",           IDT_PROGRESS_SPEED,    x2, y1, x2Size, 8
  LTEXT  "Processed:",       IDT_PROGRESS_PROCESSED, x2, y2, x2Size, 8
  LTEXT  "Compressed size:", IDT_PROGRESS_PACKED,   x2, y3, x2Size, 8

  RTEXT  "00:00:00",  IDT_PROGRESS_ELAPSED_VAL,     x1, y0, x1Size, 8
  RTEXT  "",          IDT_PROGRESS_REMAINING_VAL,   x1, y1, x1Size, 8
  RTEXT  "",          IDT_PROGRESS_FILES_VAL,       x1, y2, x1Size, 8
  RTEXT  "",          IDT_PROGRESS_RATIO_VAL,       x1, y3, x1Size, 8

  RTEXT  "",          IDT_PROGRESS_TOTAL_VAL,       x3, y0, x3Size, 8
  RTEXT  "",          IDT_PROGRESS_SPEED_VAL,       x3, y1, x3Size, 8
  RTEXT  "",          IDT_PROGRESS_PROCESSED_VAL,    x3, y2, x3Size, 8
  RTEXT  "",          IDT_PROGRESS_PACKED_VAL,      x3, y3, x3Size, 8

  LTEXT  "", IDT_PROGRESS_FILE_NAME, marg, bYPos - 30, xSize2, 8, SS_NOPREFIX
  CONTROL "Progress1", IDC_PROGRESS1, "msctls_progress32", PBS_SMOOTH | WS_BORDER, marg, bYPos - 20, xSize2, 13
END


STRINGTABLE DISCARDABLE 
BEGIN
  IDS_PROGRESS_PAUSED     "Paused"
  IDS_PROGRESS_FOREGROUND "&Foreground"
  IDS_PROGRESS_CONTINUE   "&Continue"
  IDS_PROGRESS_ASK_CANCEL "Are you sure you want to cancel?"
END

*/
class CProgressDialogImpl : public NWindows::NControl::CModalDialogImpl
{
  public:
   CProgressDialogImpl(NWindows::NControl::CModalDialog *dialog,wxWindow * parent , int id) : CModalDialogImpl(dialog,parent, id, wxT("Progress"))
  {
// FIXME : ProgressDialog2 but ProgressDialog ...

	///Sizer for adding the controls created by users
	wxBoxSizer* topsizer = new wxBoxSizer(wxVERTICAL);

	wxStaticText *pStaticTextElapsedTime = new wxStaticText(this, IDT_PROGRESS_ELAPSED, wxT("Elapsed time:"));
	wxStaticText *m_pStaticTextElapsedTime = new wxStaticText(this, IDT_PROGRESS_ELAPSED_VAL, wxT("00:00:00"), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);
	wxStaticText *pStaticTextRemainingTime = new wxStaticText(this, IDT_PROGRESS_REMAINING, wxT("Remaining time"));
	wxStaticText *m_pStaticTextRemainingTime = new wxStaticText(this, IDT_PROGRESS_REMAINING_VAL, wxT("00:00:00"), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);

	wxStaticText *pStaticTextFiles = new wxStaticText(this, IDT_PROGRESS_FILES, wxT("Files:"));
	wxStaticText *m_pStaticTextFiles = new wxStaticText(this, IDT_PROGRESS_FILES_VAL, wxT("      "), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);

	wxStaticText *pStaticTextRatio = new wxStaticText(this, IDT_PROGRESS_RATIO, wxT("Compression ratio:"));
	wxStaticText *m_pStaticTextRatio = new wxStaticText(this, IDT_PROGRESS_RATIO_VAL, wxT("       "), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);


	wxStaticText *pStaticTextSize = new wxStaticText(this, IDT_PROGRESS_TOTAL, wxT("Total Size:"));
	wxStaticText *m_pStaticTextSize = new wxStaticText(this, IDT_PROGRESS_TOTAL_VAL, wxT("          "), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);
	wxStaticText *pStaticTextSpeed = new wxStaticText(this, IDT_PROGRESS_SPEED, wxT("Speed:"));
	wxStaticText *m_pStaticTextSpeed = new wxStaticText(this, IDT_PROGRESS_SPEED_VAL, wxT("          "), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);

	wxStaticText *pStaticTextUnpacked = new wxStaticText(this, IDT_PROGRESS_PROCESSED, wxT("Processed:"));
	wxStaticText *m_pStaticTextUnpacked = new wxStaticText(this, IDT_PROGRESS_PROCESSED_VAL, wxT("          "), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);
	
	wxStaticText *pStaticTextPacked = new wxStaticText(this, IDT_PROGRESS_PACKED, wxT("Compressed size:"));
	wxStaticText *m_pStaticTextPacked = new wxStaticText(this, IDT_PROGRESS_PACKED_VAL, wxT("          "), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);

	wxBoxSizer *pInfoSizer = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer *pTimeSizer = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer *pTimeLabelSizer = new wxBoxSizer(wxVERTICAL);
	pTimeLabelSizer->Add(pStaticTextElapsedTime  , 0, wxALL|wxEXPAND, 5);
	pTimeLabelSizer->Add(pStaticTextRemainingTime, 0, wxALL|wxEXPAND, 5);
	pTimeLabelSizer->Add(pStaticTextFiles        , 0, wxALL|wxEXPAND, 5);
	pTimeLabelSizer->Add(pStaticTextRatio        , 0, wxALL|wxEXPAND, 5);
	wxBoxSizer *pTimeInfoSizer = new wxBoxSizer(wxVERTICAL);
	pTimeInfoSizer->Add(m_pStaticTextElapsedTime  , 0, wxALL|wxEXPAND, 5);
	pTimeInfoSizer->Add(m_pStaticTextRemainingTime, 0, wxALL|wxEXPAND, 5);
	pTimeInfoSizer->Add(m_pStaticTextFiles        , 0, wxALL|wxEXPAND, 5);
	pTimeInfoSizer->Add(m_pStaticTextRatio        , 0, wxALL|wxEXPAND, 5);
	pTimeSizer->Add(pTimeLabelSizer               , 0, wxALL|wxEXPAND, 5);
	pTimeSizer->Add(pTimeInfoSizer                , 0, wxALL|wxEXPAND, 5);
	wxBoxSizer *pSizeSpeedSizer = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer *pSizeSpeedLabelSizer = new wxBoxSizer(wxVERTICAL);
	pSizeSpeedLabelSizer->Add(pStaticTextSize     , 0, wxALL|wxEXPAND, 5);
	pSizeSpeedLabelSizer->Add(pStaticTextSpeed    , 0, wxALL|wxEXPAND, 5);
	pSizeSpeedLabelSizer->Add(pStaticTextUnpacked , 0, wxALL|wxEXPAND, 5);
	pSizeSpeedLabelSizer->Add(pStaticTextPacked   , 0, wxALL|wxEXPAND, 5);

	wxBoxSizer *pSizeSpeedInfoSizer = new wxBoxSizer(wxVERTICAL);
	pSizeSpeedInfoSizer->Add(m_pStaticTextSize    , 0, wxALL|wxEXPAND, 5);
	pSizeSpeedInfoSizer->Add(m_pStaticTextSpeed   , 0, wxALL|wxEXPAND, 5);
	pSizeSpeedInfoSizer->Add(m_pStaticTextUnpacked, 0, wxALL|wxEXPAND, 5);
	pSizeSpeedInfoSizer->Add(m_pStaticTextPacked  , 0, wxALL|wxEXPAND, 5);

	pSizeSpeedSizer->Add(pSizeSpeedLabelSizer, 1, wxALL|wxEXPAND, 5);
	pSizeSpeedSizer->Add(pSizeSpeedInfoSizer, 1, wxALL|wxEXPAND, 5);
	pInfoSizer->Add(pTimeSizer, 0, wxALL|wxEXPAND, 5);
	pInfoSizer->Add(pSizeSpeedSizer, 0, wxALL|wxEXPAND, 5);

	// wxStaticText *m_pStaticArchiveName = new wxStaticText(this, IDT_PROGRESS_FILE_NAME, wxT(" \n "));
	wxStaticText *m_pStaticArchiveName = new wxStaticText(this, IDT_PROGRESS_FILE_NAME, wxT(""));
	// m_pStaticArchiveName->Wrap( -1 ); // No Wrapping 
	  
	wxGauge *m_pGaugeProgress = new wxGauge(this, IDC_PROGRESS1, 100);

	wxBoxSizer *pButtonSizer = new wxBoxSizer(wxHORIZONTAL);
	wxButton *m_pButtonBackground = new wxButton(this, IDB_PROGRESS_BACKGROUND, wxT("&Background"));
	wxButton *m_pButtonPause = new wxButton(this, IDB_PAUSE, wxT("&Pause"));
	wxButton *m_pButtonCancel = new wxButton(this, wxID_CANCEL, wxT("&Cancel"));
	// FIXME pButtonSizer->AddStretchSpacer(1);
	pButtonSizer->Add(m_pButtonBackground, 0, wxALL|wxEXPAND, 5);
	pButtonSizer->Add(m_pButtonPause, 0, wxALL|wxEXPAND, 5);
	pButtonSizer->Add(m_pButtonCancel, 0, wxALL|wxEXPAND, 5);

	topsizer->Add(pInfoSizer, 0, wxBOTTOM|wxEXPAND, 5);
	topsizer->Add(m_pStaticArchiveName, 0, wxEXPAND | wxALL | wxALIGN_LEFT, 10);
	topsizer->Add(m_pGaugeProgress, 0, wxALL|wxEXPAND, 10);
	topsizer->Add(pButtonSizer, 0, wxALL|wxEXPAND, 5);

	this->OnInit();

	SetSizer(topsizer); // use the sizer for layout
	topsizer->SetSizeHints(this); // set size hints to honour minimum size
  }

private:
	// Any class wishing to process wxWindows events must use this macro
	DECLARE_EVENT_TABLE()
};

static CStringTable g_stringTable[] =
{
	{ IDS_PROGRESS_PAUSED     , L"Paused" },
	{ IDS_PROGRESS_FOREGROUND , L"&Foreground" },
	{ IDS_CONTINUE            , L"&Continue" },
	{ IDS_PROGRESS_ASK_CANCEL , L"Are you sure you want to cancel?" },
	{ IDS_CLOSE               , L"&Close" },
	{ 0 , 0 }
};

REGISTER_DIALOG(IDD_PROGRESS,CProgressDialog,g_stringTable)

BEGIN_EVENT_TABLE(CProgressDialogImpl, wxDialog)
	EVT_TIMER(wxID_ANY, CModalDialogImpl::OnAnyTimer)
	EVT_BUTTON(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_MENU(WORKER_EVENT, CModalDialogImpl::OnWorkerEvent)
END_EVENT_TABLE()

#define IDD_PROGRESS  97

#define IDC_PROGRESS1  100
// PropertyName.cpp

#include "StdAfx.h"

#include "../../../Common/IntToString.h"

#include "LangUtils.h"
#include "PropertyName.h"

UString GetNameOfProperty(PROPID propID, const wchar_t *name)
{
  if (propID < 1000)
  {
    UString s = LangString(1000 + propID);
    if (!s.IsEmpty())
      return s;
  }
  if (name)
    return name;
  wchar_t temp[16];
  ConvertUInt32ToString(propID, temp);
  return temp;
}
// PropertyName.h

#ifndef __PROPERTY_NAME_H
#define __PROPERTY_NAME_H

#include "../../../Common/MyString.h"

UString GetNameOfProperty(PROPID propID, const wchar_t *name);

#endif


#define IDS_PROP_PATH             1003
#define IDS_PROP_NAME             1004
#define IDS_PROP_EXTENSION        1005
#define IDS_PROP_IS_FOLDER        1006
#define IDS_PROP_SIZE             1007
#define IDS_PROP_PACKED_SIZE      1008
#define IDS_PROP_ATTRIBUTES       1009
#define IDS_PROP_CTIME            1010
#define IDS_PROP_ATIME            1011
#define IDS_PROP_MTIME            1012
#define IDS_PROP_SOLID            1013
#define IDS_PROP_C0MMENTED        1014
#define IDS_PROP_ENCRYPTED        1015
#define IDS_PROP_SPLIT_BEFORE     1016
#define IDS_PROP_SPLIT_AFTER      1017
#define IDS_PROP_DICTIONARY_SIZE  1018
#define IDS_PROP_CRC              1019
#define IDS_PROP_FILE_TYPE        1020
#define IDS_PROP_ANTI             1021
#define IDS_PROP_METHOD           1022
#define IDS_PROP_HOST_OS          1023
#define IDS_PROP_FILE_SYSTEM      1024
#define IDS_PROP_USER             1025
#define IDS_PROP_GROUP            1026
#define IDS_PROP_BLOCK            1027
#define IDS_PROP_COMMENT          1028
#define IDS_PROP_POSITION         1029
#define IDS_PROP_PREFIX           1030
#define IDS_PROP_FOLDERS          1031
#define IDS_PROP_FILES            1032
#define IDS_PROP_VERSION          1033
#define IDS_PROP_VOLUME           1034
#define IDS_PROP_IS_VOLUME        1035
#define IDS_PROP_OFFSET           1036
#define IDS_PROP_LINKS            1037
#define IDS_PROP_NUM_BLOCKS       1038
#define IDS_PROP_NUM_VOLUMES      1039

#define IDS_PROP_BIT64            1041
#define IDS_PROP_BIG_ENDIAN       1042
#define IDS_PROP_CPU              1043
#define IDS_PROP_PHY_SIZE         1044
#define IDS_PROP_HEADERS_SIZE     1045
#define IDS_PROP_CHECKSUM         1046
#define IDS_PROP_CHARACTS         1047
#define IDS_PROP_VA               1048
#define IDS_PROP_ID               1049
#define IDS_PROP_SHORT_NAME       1050
#define IDS_PROP_CREATOR_APP      1051
#define IDS_PROP_SECTOR_SIZE      1052
#define IDS_PROP_POSIX_ATTRIB     1053
#define IDS_PROP_SYM_LINK         1054
#define IDS_PROP_ERROR            1055
#define IDS_PROP_TOTAL_SIZE       1056
#define IDS_PROP_FREE_SPACE       1057
#define IDS_PROP_CLUSTER_SIZE     1058
#define IDS_PROP_VOLUME_NAME      1059
#define IDS_PROP_LOCAL_NAME       1060
#define IDS_PROP_PROVIDER         1061
#define IDS_PROP_NT_SECURITY      1062
#define IDS_PROP_ALT_STREAM       1063
#define IDS_PROP_AUX              1064
#define IDS_PROP_DELETED          1065
#define IDS_PROP_IS_TREE          1066
#define IDS_PROP_SHA1             1067
#define IDS_PROP_SHA256           1068
#define IDS_PROP_ERROR_TYPE       1069
#define IDS_PROP_NUM_ERRORS       1070
#define IDS_PROP_ERROR_FLAGS      1071
#define IDS_PROP_WARNING_FLAGS    1072
#define IDS_PROP_WARNING          1073
#define IDS_PROP_NUM_STREAMS      1074
#define IDS_PROP_NUM_ALT_STREAMS  1075
#define IDS_PROP_ALT_STREAMS_SIZE 1076
#define IDS_PROP_VIRTUAL_SIZE     1077
#define IDS_PROP_UNPACK_SIZE      1078
#define IDS_PROP_TOTAL_PHY_SIZE   1079
#define IDS_PROP_VOLUME_INDEX     1080
#define IDS_PROP_SUBTYPE          1081
#define IDS_PROP_SHORT_COMMENT    1082
#define IDS_PROP_CODE_PAGE        1083
#define IDS_PROP_IS_NOT_ARC_TYPE  1084
#define IDS_PROP_PHY_SIZE_CANT_BE_DETECTED 1085
#define IDS_PROP_ZEROS_TAIL_IS_ALLOWED 1086
#define IDS_PROP_TAIL_SIZE        1087
#define IDS_PROP_EMB_STUB_SIZE    1088
#define IDS_PROP_NT_REPARSE       1089
#define IDS_PROP_HARD_LINK        1090
#define IDS_PROP_INODE            1091
#define IDS_PROP_STREAM_ID        1092
#define IDS_PROP_READ_ONLY        1093
#define IDS_PROP_OUT_NAME         1094
// RegistryAssociations.cpp

#include "StdAfx.h"

#include "RegistryAssociations.h"

#include "Common/IntToString.h"
#include "Common/StringConvert.h"
#include "Common/StringToInt.h"

#include "Windows/Registry.h"
#include "Windows/Synchronization.h"

#include "StringUtils.h"

using namespace NWindows;
using namespace NRegistry;

namespace NRegistryAssociations {
  
static NSynchronization::CCriticalSection g_CriticalSection;

#define REG_PATH_FM TEXT("Software") TEXT(STRING_PATH_SEPARATOR) TEXT("7-Zip") TEXT(STRING_PATH_SEPARATOR) TEXT("FM")

/*

static const TCHAR *kCUKeyPath = REG_PATH_FM;
static const WCHAR *kExtPlugins = L"Plugins";
static const TCHAR *kExtEnabled = TEXT("Enabled");

#define kAssociations TEXT("Associations")
#define kAssociationsPath REG_PATH_FM TEXT(STRING_PATH_SEPARATOR) kAssociations

bool ReadInternalAssociation(const wchar_t *ext, CExtInfo &extInfo)
{
  NSynchronization::CCriticalSectionLock lock(g_CriticalSection);
  CKey key;
  if (key.Open(HKEY_CURRENT_USER,
      CSysString(kAssociationsPath TEXT(STRING_PATH_SEPARATOR)) +
      GetSystemString(ext), KEY_READ) != ERROR_SUCCESS)
    return false;
  UString pluginsString;
  key.QueryValue(kExtPlugins, pluginsString);
  SplitString(pluginsString, extInfo.Plugins);
  return true;
}

void ReadInternalAssociations(CObjectVector<CExtInfo> &items)
{
  items.Clear();
  NSynchronization::CCriticalSectionLock lock(g_CriticalSection);
  CKey associationsKey;
  if (associationsKey.Open(HKEY_CURRENT_USER, kAssociationsPath, KEY_READ) != ERROR_SUCCESS)
    return;
  CSysStringVector extNames;
  associationsKey.EnumKeys(extNames);
  for(int i = 0; i < extNames.Size(); i++)
  {
    const CSysString extName = extNames[i];
    CExtInfo extInfo;
    // extInfo.Enabled = false;
    extInfo.Ext = GetUnicodeString(extName);
    CKey key;
    if (key.Open(associationsKey, extName, KEY_READ) != ERROR_SUCCESS)
      return;
    UString pluginsString;
    key.QueryValue(kExtPlugins, pluginsString);
    SplitString(pluginsString, extInfo.Plugins);
    // if (key.QueryValue(kExtEnabled, extInfo.Enabled) != ERROR_SUCCESS)
    //   extInfo.Enabled = false;
    items.Add(extInfo);
  }
}

void WriteInternalAssociations(const CObjectVector<CExtInfo> &items)
{
  NSynchronization::CCriticalSectionLock lock(g_CriticalSection);
  CKey mainKey;
  mainKey.Create(HKEY_CURRENT_USER, kCUKeyPath);
  mainKey.RecurseDeleteKey(kAssociations);
  CKey associationsKey;
  associationsKey.Create(mainKey, kAssociations);
  for(int i = 0; i < items.Size(); i++)
  {
    const CExtInfo &extInfo = items[i];
    CKey key;
    key.Create(associationsKey, GetSystemString(extInfo.Ext));
    key.SetValue(kExtPlugins, JoinStrings(extInfo.Plugins));
    // key.SetValue(kExtEnabled, extInfo.Enabled);
  }
}
*/

///////////////////////////////////
// External

static const TCHAR *kShellNewKeyName = TEXT("ShellNew");
static const TCHAR *kShellNewDataValueName = TEXT("Data");
  
static const TCHAR *kDefaultIconKeyName = TEXT("DefaultIcon");
static const TCHAR *kShellKeyName = TEXT("shell");
static const TCHAR *kOpenKeyName = TEXT("open");
static const TCHAR *kCommandKeyName = TEXT("command");
static const TCHAR *k7zipPrefix = TEXT("7-Zip.");

static CSysString GetExtensionKeyName(const CSysString &extension)
{
  return CSysString(TEXT(".")) + extension;
}

static CSysString GetExtProgramKeyName(const CSysString &extension)
{
  return CSysString(k7zipPrefix) + extension;
}

static bool CheckShellExtensionInfo2(const CSysString &extension,
    CSysString programKeyName, UString &iconPath, int &iconIndex)
{
  iconIndex = -1;
  iconPath.Empty();
  NSynchronization::CCriticalSectionLock lock(g_CriticalSection);
  CKey extKey;
  if (extKey.Open(HKEY_CLASSES_ROOT, GetExtensionKeyName(extension), KEY_READ) != ERROR_SUCCESS)
    return false;
  if (extKey.QueryValue(NULL, programKeyName) != ERROR_SUCCESS)
    return false;
  UString s = GetUnicodeString(k7zipPrefix);
  if (s.CompareNoCase(GetUnicodeString(programKeyName.Left(s.Length()))) != 0)
    return false;
  CKey iconKey;
  if (extKey.Open(HKEY_CLASSES_ROOT, programKeyName + CSysString(TEXT(CHAR_PATH_SEPARATOR)) + kDefaultIconKeyName, KEY_READ) != ERROR_SUCCESS)
    return false;
  UString value;
  if (extKey.QueryValue(NULL, value) == ERROR_SUCCESS)
  {
    int pos = value.ReverseFind(L',');
    iconPath = value;
    if (pos >= 0)
    {
      const wchar_t *end;
      UInt64 index = ConvertStringToUInt64((const wchar_t *)value + pos + 1, &end);
      if (*end == 0)
      {
        iconIndex = (int)index;
        iconPath = value.Left(pos);
      }
    }
  }
  return true;
}

bool CheckShellExtensionInfo(const CSysString &extension, UString &iconPath, int &iconIndex)
{
  NSynchronization::CCriticalSectionLock lock(g_CriticalSection);
  CSysString programKeyName;
  if (!CheckShellExtensionInfo2(extension, programKeyName, iconPath, iconIndex))
    return false;
  CKey extProgKey;
  return (extProgKey.Open(HKEY_CLASSES_ROOT, programKeyName, KEY_READ) == ERROR_SUCCESS);
}

static void DeleteShellExtensionKey(const CSysString &extension)
{
  NSynchronization::CCriticalSectionLock lock(g_CriticalSection);
  CKey rootKey;
  rootKey.Attach(HKEY_CLASSES_ROOT);
  rootKey.RecurseDeleteKey(GetExtensionKeyName(extension));
  rootKey.Detach();
}

static void DeleteShellExtensionProgramKey(const CSysString &extension)
{
  NSynchronization::CCriticalSectionLock lock(g_CriticalSection);
  CKey rootKey;
  rootKey.Attach(HKEY_CLASSES_ROOT);
  rootKey.RecurseDeleteKey(GetExtProgramKeyName(extension));
  rootKey.Detach();
}

void DeleteShellExtensionInfo(const CSysString &extension)
{
  CSysString programKeyName;
  UString iconPath;
  int iconIndex;
  if (CheckShellExtensionInfo2(extension, programKeyName, iconPath, iconIndex))
    DeleteShellExtensionKey(extension);
  DeleteShellExtensionProgramKey(extension);
}

void AddShellExtensionInfo(const CSysString &extension,
    const UString &programTitle,
    const UString &programOpenCommand,
    const UString &iconPath, int iconIndex,
    const void *shellNewData, int shellNewDataSize)
{
  DeleteShellExtensionKey(extension);
  DeleteShellExtensionProgramKey(extension);
  NSynchronization::CCriticalSectionLock lock(g_CriticalSection);
  CSysString programKeyName;
  {
    CSysString ext = extension;
    if (iconIndex < 0)
      ext = TEXT("*");
    programKeyName = GetExtProgramKeyName(ext);
  }
  {
    CKey extKey;
    extKey.Create(HKEY_CLASSES_ROOT, GetExtensionKeyName(extension));
    extKey.SetValue(NULL, programKeyName);
    if (shellNewData != NULL)
    {
      CKey shellNewKey;
      shellNewKey.Create(extKey, kShellNewKeyName);
      shellNewKey.SetValue(kShellNewDataValueName, shellNewData, shellNewDataSize);
    }
  }
  CKey programKey;
  programKey.Create(HKEY_CLASSES_ROOT, programKeyName);
  programKey.SetValue(NULL, programTitle);
  {
    CKey iconKey;
    iconKey.Create(programKey, kDefaultIconKeyName);
    UString iconPathFull = iconPath;
    if (iconIndex < 0)
      iconIndex = 0;
    // if (iconIndex >= 0)
    {
      iconPathFull += L",";
      wchar_t s[16];
      ConvertUInt32ToString(iconIndex, s);
      iconPathFull += s;
    }
    iconKey.SetValue(NULL, iconPathFull);
  }

  CKey shellKey;
  shellKey.Create(programKey, kShellKeyName);
  shellKey.SetValue(NULL, TEXT(""));

  CKey openKey;
  openKey.Create(shellKey, kOpenKeyName);
  openKey.SetValue(NULL, TEXT(""));
  
  CKey commandKey;
  commandKey.Create(openKey, kCommandKeyName);

  commandKey.SetValue(NULL, programOpenCommand);
}

///////////////////////////
// ContextMenu
/*

static const TCHAR *kContextMenuKeyName = TEXT("\\shellex\\ContextMenuHandlers\\7-Zip");
static const TCHAR *kContextMenuHandlerCLASSIDValue =
    TEXT("{23170F69-40C1-278A-1000-000100020000}");
static const TCHAR *kRootKeyNameForFile = TEXT("*");
static const TCHAR *kRootKeyNameForFolder = TEXT("Folder");

static CSysString GetFullContextMenuKeyName(const CSysString &aKeyName)
  { return (aKeyName + kContextMenuKeyName); }

static bool CheckContextMenuHandlerCommon(const CSysString &aKeyName)
{
  NSynchronization::CCriticalSectionLock lock(&g_CriticalSection, true);
  CKey aKey;
  if (aKey.Open(HKEY_CLASSES_ROOT, GetFullContextMenuKeyName(aKeyName), KEY_READ)
      != ERROR_SUCCESS)
    return false;
  CSysString aValue;
  if (aKey.QueryValue(NULL, aValue) != ERROR_SUCCESS)
    return false;
  return (aValue.CompareNoCase(kContextMenuHandlerCLASSIDValue) == 0);
}

bool CheckContextMenuHandler()
{
  return CheckContextMenuHandlerCommon(kRootKeyNameForFile) &&
    CheckContextMenuHandlerCommon(kRootKeyNameForFolder);
}

static void DeleteContextMenuHandlerCommon(const CSysString &aKeyName)
{
  CKey rootKey;
  rootKey.Attach(HKEY_CLASSES_ROOT);
  rootKey.RecurseDeleteKey(GetFullContextMenuKeyName(aKeyName));
  rootKey.Detach();
}

void DeleteContextMenuHandler()
{
  DeleteContextMenuHandlerCommon(kRootKeyNameForFile);
  DeleteContextMenuHandlerCommon(kRootKeyNameForFolder);
}

static void AddContextMenuHandlerCommon(const CSysString &aKeyName)
{
  DeleteContextMenuHandlerCommon(aKeyName);
  NSynchronization::CCriticalSectionLock lock(&g_CriticalSection, true);
  CKey aKey;
  aKey.Create(HKEY_CLASSES_ROOT, GetFullContextMenuKeyName(aKeyName));
  aKey.SetValue(NULL, kContextMenuHandlerCLASSIDValue);
}

void AddContextMenuHandler()
{
  AddContextMenuHandlerCommon(kRootKeyNameForFile);
  AddContextMenuHandlerCommon(kRootKeyNameForFolder);
}
*/

}
// RegistryAssociations.h

#ifndef __REGISTRYASSOCIATIONS_H
#define __REGISTRYASSOCIATIONS_H

#include "Common/MyString.h"

namespace NRegistryAssociations {

  /*
  struct CExtInfo
  {
    UString Ext;
    UStringVector Plugins;
    // bool Enabled;
  };
  bool ReadInternalAssociation(const wchar_t *ext, CExtInfo &extInfo);
  void ReadInternalAssociations(CObjectVector<CExtInfo> &items);
  void WriteInternalAssociations(const CObjectVector<CExtInfo> &items);
  */

  bool CheckShellExtensionInfo(const CSysString &extension, UString &iconPath, int &iconIndex);

  // void ReadCompressionInfo(NZipSettings::NCompression::CInfo &anInfo,
  void DeleteShellExtensionInfo(const CSysString &extension);

  void AddShellExtensionInfo(const CSysString &extension,
      const UString &programTitle,
      const UString &programOpenCommand,
      const UString &iconPath, int iconIndex,
      const void *shellNewData, int shellNewDataSize);


  ///////////////////////////
  // ContextMenu
  /*
  bool CheckContextMenuHandler();
  void AddContextMenuHandler();
  void DeleteContextMenuHandler();
  */

}

// bool GetProgramDirPrefix(CSysString &aFolder);

#endif
// RegistryPlugins.h

#ifndef __REGISTRY_PLUGINS_H
#define __REGISTRY_PLUGINS_H

#include "../../../Common/MyString.h"

enum EPluginType
{
  kPluginTypeFF = 0
};

struct CPluginInfo
{
  FString FilePath;
  EPluginType Type;
  UString Name;
  CLSID ClassID;
  CLSID OptionsClassID;
  bool ClassIDDefined;
  bool OptionsClassIDDefined;

  // CSysString Extension;
  // CSysString AddExtension;
  // bool UpdateEnabled;
  // bool KeepName;
};

void ReadPluginInfoList(CObjectVector<CPluginInfo> &plugins);
void ReadFileFolderPluginInfoList(CObjectVector<CPluginInfo> &plugins);

#endif
// RegistryUtils.cpp

#include "StdAfx.h"

#include "../../../Common/IntToString.h"

#include "../../../Windows/Registry.h"

#include "RegistryUtils.h"

using namespace NWindows;
using namespace NRegistry;

#define REG_PATH_7Z TEXT("Software") TEXT(STRING_PATH_SEPARATOR) TEXT("7-Zip")

static const TCHAR *kCUBasePath = REG_PATH_7Z;
static const TCHAR *kCU_FMPath = REG_PATH_7Z TEXT(STRING_PATH_SEPARATOR) TEXT("FM");
// static const TCHAR *kLM_Path = REG_PATH_7Z TEXT(STRING_PATH_SEPARATOR) TEXT("FM");

static const WCHAR *kLangValueName = L"Lang";
static const WCHAR *kViewer = L"Viewer";
static const WCHAR *kEditor = L"Editor";
static const WCHAR *kDiff = L"Diff";
static const TCHAR *kShowDots = TEXT("ShowDots");
static const TCHAR *kShowRealFileIcons = TEXT("ShowRealFileIcons");
static const TCHAR *kShowSystemMenu = TEXT("ShowSystemMenu");

static const TCHAR *kFullRow = TEXT("FullRow");
static const TCHAR *kShowGrid = TEXT("ShowGrid");
static const TCHAR *kAlternativeSelection = TEXT("AlternativeSelection");
// static const TCHAR *kLockMemoryAdd = TEXT("LockMemoryAdd");
static const TCHAR *kLargePagesEnable = TEXT("LargePages");
static const TCHAR *kSingleClick = TEXT("SingleClick");
// static const TCHAR *kUnderline = TEXT("Underline");

static const TCHAR *kFlatViewName = TEXT("FlatViewArc");
// static const TCHAR *kShowDeletedFiles = TEXT("ShowDeleted");

static void SaveCuString(LPCTSTR keyPath, LPCWSTR valuePath, LPCWSTR value)
{
  CKey key;
  key.Create(HKEY_CURRENT_USER, keyPath);
  key.SetValue(valuePath, value);
}

static void ReadCuString(LPCTSTR keyPath, LPCWSTR valuePath, UString &res)
{
  res.Empty();
  CKey key;
  if (key.Open(HKEY_CURRENT_USER, keyPath, KEY_READ) == ERROR_SUCCESS)
    key.QueryValue(valuePath, res);
}

void SaveRegLang(const UString &path) { SaveCuString(kCUBasePath, kLangValueName, path); }
void ReadRegLang(UString &path) { ReadCuString(kCUBasePath, kLangValueName, path); }

void SaveRegEditor(bool useEditor, const UString &path) { SaveCuString(kCU_FMPath, useEditor ? kEditor : kViewer, path); }
void ReadRegEditor(bool useEditor, UString &path) { ReadCuString(kCU_FMPath, useEditor ? kEditor : kViewer, path); }

void SaveRegDiff(const UString &path) { SaveCuString(kCU_FMPath, kDiff, path); }
void ReadRegDiff(UString &path) { ReadCuString(kCU_FMPath, kDiff, path); }

static void Save7ZipOption(const TCHAR *value, bool enabled)
{
  CKey key;
  key.Create(HKEY_CURRENT_USER, kCUBasePath);
  key.SetValue(value, enabled);
}

static void SaveOption(const TCHAR *value, bool enabled)
{
  CKey key;
  key.Create(HKEY_CURRENT_USER, kCU_FMPath);
  key.SetValue(value, enabled);
}

static bool Read7ZipOption(const TCHAR *value, bool defaultValue)
{
  CKey key;
  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) == ERROR_SUCCESS)
  {
    bool enabled;
    if (key.QueryValue(value, enabled) == ERROR_SUCCESS)
      return enabled;
  }
  return defaultValue;
}

static bool ReadOption(const TCHAR *value, bool defaultValue)
{
  CKey key;
  if (key.Open(HKEY_CURRENT_USER, kCU_FMPath, KEY_READ) == ERROR_SUCCESS)
  {
    bool enabled;
    if (key.QueryValue(value, enabled) == ERROR_SUCCESS)
      return enabled;
  }
  return defaultValue;
}

/*
static void SaveLmOption(const TCHAR *value, bool enabled)
{
  CKey key;
  key.Create(HKEY_LOCAL_MACHINE, kLM_Path);
  key.SetValue(value, enabled);
}

static bool ReadLmOption(const TCHAR *value, bool defaultValue)
{
  CKey key;
  if (key.Open(HKEY_LOCAL_MACHINE, kLM_Path, KEY_READ) == ERROR_SUCCESS)
  {
    bool enabled;
    if (key.QueryValue(value, enabled) == ERROR_SUCCESS)
      return enabled;
  }
  return defaultValue;
}
*/

void SaveShowDots(bool showDots) { SaveOption(kShowDots, showDots); }
bool ReadShowDots() { return ReadOption(kShowDots, false); }

void SaveShowRealFileIcons(bool show)  { SaveOption(kShowRealFileIcons, show); }
bool ReadShowRealFileIcons() { return ReadOption(kShowRealFileIcons, false); }

void Save_ShowSystemMenu(bool show) { SaveOption(kShowSystemMenu, show); }
bool Read_ShowSystemMenu(){ return ReadOption(kShowSystemMenu, false); }

void SaveFullRow(bool enable) { SaveOption(kFullRow, enable); }
bool ReadFullRow() { return ReadOption(kFullRow, false); }

void SaveShowGrid(bool enable) { SaveOption(kShowGrid, enable); }
bool ReadShowGrid(){ return ReadOption(kShowGrid, false); }

void SaveAlternativeSelection(bool enable) { SaveOption(kAlternativeSelection, enable); }
bool ReadAlternativeSelection(){ return ReadOption(kAlternativeSelection, false); }

void SaveSingleClick(bool enable) { SaveOption(kSingleClick, enable); }
bool ReadSingleClick(){ return ReadOption(kSingleClick, false); }

/*
void SaveUnderline(bool enable) { SaveOption(kUnderline, enable); }
bool ReadUnderline(){ return ReadOption(kUnderline, false); }
*/

// void SaveLockMemoryAdd(bool enable) { SaveLmOption(kLockMemoryAdd, enable); }
// bool ReadLockMemoryAdd() { return ReadLmOption(kLockMemoryAdd, true); }

void SaveLockMemoryEnable(bool enable) { Save7ZipOption(kLargePagesEnable, enable); }
bool ReadLockMemoryEnable() { return Read7ZipOption(kLargePagesEnable, false); }

static CSysString GetFlatViewName(UInt32 panelIndex)
{
  TCHAR panelString[16];
  ConvertUInt32ToString(panelIndex, panelString);
  return (CSysString)kFlatViewName + panelString;
}

void SaveFlatView(UInt32 panelIndex, bool enable) { SaveOption(GetFlatViewName(panelIndex), enable); }
bool ReadFlatView(UInt32 panelIndex) { return ReadOption(GetFlatViewName(panelIndex), false); }

/*
void Save_ShowDeleted(bool enable) { SaveOption(kShowDeletedFiles, enable); }
bool Read_ShowDeleted() { return ReadOption(kShowDeletedFiles, false); }
*/// RegistryUtils.h

#ifndef __REGISTRY_UTILS_H
#define __REGISTRY_UTILS_H

#include "../../../Common/MyTypes.h"
#include "../../../Common/MyString.h"

void SaveRegLang(const UString &path);
void ReadRegLang(UString &path);

void SaveRegEditor(bool useEditor, const UString &path);
void ReadRegEditor(bool useEditor, UString &path);

void SaveRegDiff(const UString &path);
void ReadRegDiff(UString &path);

void SaveShowDots(bool showDots);
bool ReadShowDots();

void SaveShowRealFileIcons(bool show);
bool ReadShowRealFileIcons();

void Save_ShowSystemMenu(bool showSystemMenu);
bool Read_ShowSystemMenu();

void SaveFullRow(bool enable);
bool ReadFullRow();

void SaveShowGrid(bool enable);
bool ReadShowGrid();

void SaveAlternativeSelection(bool enable);
bool ReadAlternativeSelection();

// void SaveLockMemoryAdd(bool enable);
// bool ReadLockMemoryAdd();

bool ReadLockMemoryEnable();
void SaveLockMemoryEnable(bool enable);

void SaveSingleClick(bool enable);
bool ReadSingleClick();

/*
void SaveUnderline(bool enable);
bool ReadUnderline();
*/

void SaveFlatView(UInt32 panelIndex, bool enable);
bool ReadFlatView(UInt32 panelIndex);

/*
void Save_ShowDeleted(bool enable);
bool Read_ShowDeleted();
*/

#endif
// RootFolder.cpp

#include "StdAfx.h"

#include "../../../Common/StringConvert.h"

#include "../../../Windows/DLL.h"
#include "../../../Windows/FileName.h"
#include "../../../Windows/PropVariant.h"

#include "../../PropID.h"

#if defined(_WIN32) && !defined(UNDER_CE)
#define USE_WIN_PATHS
#endif

static const unsigned kNumRootFolderItems =
  #ifdef USE_WIN_PATHS
  4
  #else
  1
  #endif
  ;


#include "FSFolder.h"
#include "LangUtils.h"
#ifdef USE_WIN_PATHS
#include "NetFolder.h"
#include "FSDrives.h"
#include "AltStreamsFolder.h"
#endif
#include "RootFolder.h"
#include "SysIconUtils.h"

#include "resource.h"

using namespace NWindows;

static const Byte  kProps[] =
{
  kpidName
};

UString RootFolder_GetName_Computer(int &iconIndex)
{
  #ifdef USE_WIN_PATHS
  iconIndex = GetIconIndexForCSIDL(CSIDL_DRIVES);
  #else
  GetRealIconIndex(FSTRING_PATH_SEPARATOR, FILE_ATTRIBUTE_DIRECTORY, iconIndex);
  #endif
  return LangString(IDS_COMPUTER);
}

UString RootFolder_GetName_Network(int &iconIndex)
{
  iconIndex = 0; // FIXME GetIconIndexForCSIDL(CSIDL_NETWORK);
  return LangString(IDS_NETWORK);
}

UString RootFolder_GetName_Documents(int &iconIndex)
{
  iconIndex = 0; // FIXME GetIconIndexForCSIDL(CSIDL_PERSONAL);
  return LangString(IDS_DOCUMENTS);
}

enum
{
  ROOT_INDEX_COMPUTER = 0
  #ifdef USE_WIN_PATHS
  , ROOT_INDEX_DOCUMENTS
  , ROOT_INDEX_NETWORK
  , ROOT_INDEX_VOLUMES
  #endif
};

#ifdef USE_WIN_PATHS
static const wchar_t *kVolPrefix = L"\\\\.";
#endif

void CRootFolder::Init()
{
  // FIXME _names[ROOT_INDEX_COMPUTER] = RootFolder_GetName_Computer(_iconIndices[ROOT_INDEX_COMPUTER]);
  #ifdef USE_WIN_PATHS
  _names[ROOT_INDEX_DOCUMENTS] = RootFolder_GetName_Documents(_iconIndices[ROOT_INDEX_DOCUMENTS]);
  _names[ROOT_INDEX_NETWORK] = RootFolder_GetName_Network(_iconIndices[ROOT_INDEX_NETWORK]);
  _names[ROOT_INDEX_VOLUMES] = kVolPrefix;
  _iconIndices[ROOT_INDEX_VOLUMES] = GetIconIndexForCSIDL(CSIDL_DRIVES);
  #endif
}

STDMETHODIMP CRootFolder::LoadItems()
{
  Init();
  return S_OK;
}

STDMETHODIMP CRootFolder::GetNumberOfItems(UInt32 *numItems)
{
  *numItems = kNumRootFolderItems;
  return S_OK;
}

STDMETHODIMP CRootFolder::GetProperty(UInt32 itemIndex, PROPID propID, PROPVARIANT *value)
{
  NCOM::CPropVariant prop;
  switch (propID)
  {
    case kpidIsDir:  prop = true; break;
    case kpidName:  prop = _names[itemIndex]; break;
  }
  prop.Detach(value);
  return S_OK;
}

#ifdef _WIN32
typedef BOOL (WINAPI *SHGetSpecialFolderPathWp)(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);
typedef BOOL (WINAPI *SHGetSpecialFolderPathAp)(HWND hwnd, LPSTR pszPath, int csidl, BOOL fCreate);

UString GetMyDocsPath()
{
  UString us;
  WCHAR s[MAX_PATH + 1];
  SHGetSpecialFolderPathWp getW = (SHGetSpecialFolderPathWp)
      #ifdef UNDER_CE
      My_GetProcAddress(GetModuleHandle(TEXT("coredll.dll")), "SHGetSpecialFolderPath");
      #else
      My_GetProcAddress(GetModuleHandle(TEXT("shell32.dll")), "SHGetSpecialFolderPathW");
      #endif
  if (getW && getW(0, s, CSIDL_PERSONAL, FALSE))
    us = s;
  #ifndef _UNICODE
  else
  {
    SHGetSpecialFolderPathAp getA = (SHGetSpecialFolderPathAp)
        ::GetProcAddress(::GetModuleHandleA("shell32.dll"), "SHGetSpecialFolderPathA");
    CHAR s2[MAX_PATH + 1];
    if (getA && getA(0, s2, CSIDL_PERSONAL, FALSE))
      us = GetUnicodeString(s2);
  }
  #endif
  NFile::NName::NormalizeDirPathPrefix(us);
  return us;
}
#endif

STDMETHODIMP CRootFolder::BindToFolder(UInt32 index, IFolderFolder **resultFolder)
{
  *resultFolder = NULL;
  CMyComPtr<IFolderFolder> subFolder;

  #ifdef USE_WIN_PATHS
  if (index == ROOT_INDEX_COMPUTER || index == ROOT_INDEX_VOLUMES)
  {
    CFSDrives *fsDrivesSpec = new CFSDrives;
    subFolder = fsDrivesSpec;
    fsDrivesSpec->Init(index == ROOT_INDEX_VOLUMES);
  }
  else if (index == ROOT_INDEX_NETWORK)
  {
    CNetFolder *netFolderSpec = new CNetFolder;
    subFolder = netFolderSpec;
    netFolderSpec->Init(0, 0, _names[ROOT_INDEX_NETWORK] + WCHAR_PATH_SEPARATOR);
  }
  else if (index == ROOT_INDEX_DOCUMENTS)
  {
    UString s = GetMyDocsPath();
    if (!s.IsEmpty())
    {
      NFsFolder::CFSFolder *fsFolderSpec = new NFsFolder::CFSFolder;
      subFolder = fsFolderSpec;
      RINOK(fsFolderSpec->Init(us2fs(s)));
    }
  }
  #else
  if (index == ROOT_INDEX_COMPUTER)
  {
    NFsFolder::CFSFolder *fsFolder = new NFsFolder::CFSFolder;
    subFolder = fsFolder;
    fsFolder->InitToRoot();
  }
  #endif
  else
    return E_INVALIDARG;

  *resultFolder = subFolder.Detach();
  return S_OK;
}

static bool AreEqualNames(const UString &path, const wchar_t *name)
{
  unsigned len = MyStringLen(name);
  if (len > path.Len() || len + 1 < path.Len())
    return false;
  if (len + 1 == path.Len() && path[len] != WCHAR_PATH_SEPARATOR)
    return false;
  return path.IsPrefixedBy(name);
}

STDMETHODIMP CRootFolder::BindToFolder(const wchar_t *name, IFolderFolder **resultFolder)
{
  *resultFolder = 0;
  UString name2 = name;
  name2.Trim();
  
  if (name2.IsEmpty())
  {
    CRootFolder *rootFolderSpec = new CRootFolder;
    CMyComPtr<IFolderFolder> rootFolder = rootFolderSpec;
    rootFolderSpec->Init();
    *resultFolder = rootFolder.Detach();
    return S_OK;
  }
  
  for (unsigned i = 0; i < kNumRootFolderItems; i++)
    if (AreEqualNames(name2, _names[i]))
      return BindToFolder((UInt32)i, resultFolder);
  
  #ifdef USE_WIN_PATHS
  if (AreEqualNames(name2, L"My Documents") ||
      AreEqualNames(name2, L"Documents"))
    return BindToFolder((UInt32)ROOT_INDEX_DOCUMENTS, resultFolder);
  #else
  if (name2 == WSTRING_PATH_SEPARATOR)
    return BindToFolder((UInt32)ROOT_INDEX_COMPUTER, resultFolder);
  #endif
  
  if (AreEqualNames(name2, L"My Computer") ||
      AreEqualNames(name2, L"Computer"))
    return BindToFolder((UInt32)ROOT_INDEX_COMPUTER, resultFolder);
  
  if (name2 == WSTRING_PATH_SEPARATOR)
  {
    CMyComPtr<IFolderFolder> subFolder = this;
    *resultFolder = subFolder.Detach();
    return S_OK;
  }

  if (name2.Len() < 2)
    return E_INVALIDARG;

  CMyComPtr<IFolderFolder> subFolder;
  
  #ifdef USE_WIN_PATHS
  if (name2.IsPrefixedBy(kVolPrefix))
  {
    CFSDrives *folderSpec = new CFSDrives;
    subFolder = folderSpec;
    folderSpec->Init(true);
  }
  else if (name2 == NFile::NName::kSuperPathPrefix)
  {
    CFSDrives *folderSpec = new CFSDrives;
    subFolder = folderSpec;
    folderSpec->Init(false, true);
  }
  else if (name2.Back() == ':')
  {
    NAltStreamsFolder::CAltStreamsFolder *folderSpec = new NAltStreamsFolder::CAltStreamsFolder;
    subFolder = folderSpec;
    if (folderSpec->Init(us2fs(name2)) != S_OK)
      return E_INVALIDARG;
  }
  else
  #endif
  {
    NFile::NName::NormalizeDirPathPrefix(name2);
    NFsFolder::CFSFolder *fsFolderSpec = new NFsFolder::CFSFolder;
    subFolder = fsFolderSpec;
    if (fsFolderSpec->Init(us2fs(name2)) != S_OK)
    {
      #ifdef USE_WIN_PATHS
      if (name2[0] == WCHAR_PATH_SEPARATOR)
      {
        CNetFolder *netFolderSpec = new CNetFolder;
        subFolder = netFolderSpec;
        netFolderSpec->Init(name2);
      }
      else
      #endif
        return E_INVALIDARG;
    }
  }
  
  *resultFolder = subFolder.Detach();
  return S_OK;
}

STDMETHODIMP CRootFolder::BindToParentFolder(IFolderFolder **resultFolder)
{
  *resultFolder = 0;
  return S_OK;
}

IMP_IFolderFolder_Props(CRootFolder)

STDMETHODIMP CRootFolder::GetFolderProperty(PROPID propID, PROPVARIANT *value)
{
  NCOM::CPropVariant prop;
  switch (propID)
  {
    case kpidType: prop = "RootFolder"; break;
    case kpidPath: prop = ""; break;
  }
  prop.Detach(value);
  return S_OK;
}

STDMETHODIMP CRootFolder::GetSystemIconIndex(UInt32 index, Int32 *iconIndex)
{
  *iconIndex = _iconIndices[index];
  return S_OK;
}
// RootFolder.h

#ifndef __ROOT_FOLDER_H
#define __ROOT_FOLDER_H

#include "../../../Common/MyString.h"

#include "IFolder.h"

const unsigned kNumRootFolderItems_Max = 4;

class CRootFolder:
  public IFolderFolder,
  public IFolderGetSystemIconIndex,
  public CMyUnknownImp
{
  UString _names[kNumRootFolderItems_Max];
  int _iconIndices[kNumRootFolderItems_Max];

public:
  MY_UNKNOWN_IMP1(IFolderGetSystemIconIndex)
  INTERFACE_FolderFolder(;)
  STDMETHOD(GetSystemIconIndex)(UInt32 index, Int32 *iconIndex);
  void Init();
};

#endif
// SplitDialog.cpp

#include "StdAfx.h"

#include "../../../Windows/FileName.h"

#ifdef LANG
#include "LangUtils.h"
#endif

#include "BrowseDialog.h"
#include "CopyDialogRes.h"
#include "SplitDialog.h"
#include "SplitUtils.h"
#include "resourceGui.h"

using namespace NWindows;

#ifdef LANG
static const UInt32 kLangIDs[] =
{
  IDT_SPLIT_PATH,
  IDT_SPLIT_VOLUME
};
#endif


bool CSplitDialog::OnInit()
{
  #ifdef LANG
  LangSetWindowText(*this, IDD_SPLIT);
  LangSetDlgItems(*this, kLangIDs, ARRAY_SIZE(kLangIDs));
  #endif
  _pathCombo.Attach(GetItem(IDC_SPLIT_PATH));
  _volumeCombo.Attach(GetItem(IDC_SPLIT_VOLUME));
  
  if (!FilePath.IsEmpty())
  {
    UString title;
    GetText(title);
    title.Add_Space();
    title += FilePath;
    SetText(title);
  }
  _pathCombo.SetText(Path);
  AddVolumeItems(_volumeCombo);
  _volumeCombo.SetCurSel(0);
  NormalizeSize();
  return CModalDialog::OnInit();
}

bool CSplitDialog::OnSize(WPARAM /* wParam */, int xSize, int ySize)
{
#ifdef _WIN32
  int mx, my;
  GetMargins(8, mx, my);
  int bx1, bx2, by;
  GetItemSizes(IDCANCEL, bx1, by);
  GetItemSizes(IDOK, bx2, by);
  int yPos = ySize - my - by;
  int xPos = xSize - mx - bx1;

  InvalidateRect(NULL);

  {
    RECT r;
    GetClientRectOfItem(IDB_SPLIT_PATH, r);
    int bx = RECT_SIZE_X(r);
    MoveItem(IDB_SPLIT_PATH, xSize - mx - bx, r.top, bx, RECT_SIZE_Y(r));
    ChangeSubWindowSizeX(_pathCombo, xSize - mx - mx - bx - mx);
  }

  MoveItem(IDCANCEL, xPos, yPos, bx1, by);
  MoveItem(IDOK, xPos - mx - bx2, yPos, bx2, by);
#endif
  return false;
}

bool CSplitDialog::OnButtonClicked(int buttonID, HWND buttonHWND)
{
  switch (buttonID)
  {
    case IDB_SPLIT_PATH:
      OnButtonSetPath();
      return true;
  }
  return CModalDialog::OnButtonClicked(buttonID, buttonHWND);
}

void CSplitDialog::OnButtonSetPath()
{
  UString currentPath;
  _pathCombo.GetText(currentPath);
  // UString title = L"Specify a location for output folder";
  UString title = LangString(IDS_SET_FOLDER);

  UString resultPath;
  if (!MyBrowseForFolder(*this, title, currentPath, resultPath))
    return;
  NFile::NName::NormalizeDirPathPrefix(resultPath);
  _pathCombo.SetCurSel(-1);
  _pathCombo.SetText(resultPath);
}

void CSplitDialog::OnOK()
{
  _pathCombo.GetText(Path);
  UString volumeString;
  _volumeCombo.GetText(volumeString);
  volumeString.Trim();
  if (!ParseVolumeSizes(volumeString, VolumeSizes) || VolumeSizes.Size() == 0)
  {
    ::MessageBoxW(*this, LangString(IDS_INCORRECT_VOLUME_SIZE), L"7-Zip", MB_ICONERROR);
    return;
  }
  CModalDialog::OnOK();
}
// SplitDialog.h

#ifndef __SPLIT_DIALOG_H
#define __SPLIT_DIALOG_H

#include "../../../Windows/Control/Dialog.h"
#include "../../../Windows/Control/ComboBox.h"

#include "SplitDialogRes.h"

class CSplitDialog: public NWindows::NControl::CModalDialog
{
  NWindows::NControl::CComboBox _pathCombo;
  NWindows::NControl::CComboBox _volumeCombo;
  virtual void OnOK();
  virtual bool OnInit();
  virtual bool OnSize(WPARAM wParam, int xSize, int ySize);
  virtual bool OnButtonClicked(int buttonID, HWND buttonHWND);
  void OnButtonSetPath();
public:
  UString FilePath;
  UString Path;
  CRecordVector<UInt64> VolumeSizes;
  INT_PTR Create(HWND parentWindow = 0)
    { return CModalDialog::Create(IDD_SPLIT, parentWindow); }
};

#endif
#define IDD_SPLIT  7300

#define IDT_SPLIT_PATH    7301
#define IDT_SPLIT_VOLUME  7302

#define IDC_SPLIT_PATH     100
#define IDB_SPLIT_PATH     101
#define IDC_SPLIT_VOLUME   102
// PasswordDialog.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif  

#undef _WIN32

#include "Windows/Control/DialogImpl.h"

#include "SplitDialogRes.h"

class CSplitDialogImpl : public NWindows::NControl::CModalDialogImpl
{
  public:
   CSplitDialogImpl(NWindows::NControl::CModalDialog *dialog,wxWindow * parent,int id) : CModalDialogImpl(dialog, parent, id, wxT("Split File"))
  {

	wxArrayString pathArray;

	wxBoxSizer* topsizer = new wxBoxSizer(wxVERTICAL);


	topsizer->Add(new wxStaticText(this, IDT_SPLIT_PATH, _T("&Split to:")) , 0 ,wxALL | wxALIGN_LEFT, 5 );


	{
	wxBoxSizer *pathSizer = new wxBoxSizer(wxHORIZONTAL);

	wxComboBox *combo = new wxComboBox(this, IDC_SPLIT_PATH, wxEmptyString, wxDefaultPosition, wxSize(600,-1), pathArray, wxCB_DROPDOWN|wxCB_SORT);
	wxButton *button = new wxButton(this, IDB_SPLIT_PATH, wxT("..."), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);
	pathSizer->Add(combo, 1, wxLEFT|wxRIGHT|wxEXPAND, 5);
	pathSizer->Add(button, 0, wxLEFT|wxRIGHT|wxEXPAND, 5);

	topsizer->Add(pathSizer, 0 ,wxALL | wxALIGN_LEFT, 5 );
	}

	topsizer->Add(new wxStaticText(this, IDT_SPLIT_VOLUME, _T("Split to &volumes,  bytes:")) , 0 ,wxALL | wxALIGN_LEFT, 5 );

	wxComboBox *combo = new wxComboBox(this, IDC_SPLIT_VOLUME, wxEmptyString, wxDefaultPosition, wxSize(600,-1), pathArray, wxCB_DROPDOWN|wxCB_SORT);

	topsizer->Add(combo, 0 ,wxALL | wxALIGN_LEFT, 5 );


	topsizer->Add(CreateButtonSizer(wxOK|wxCANCEL), 0, wxALL|wxEXPAND, 5);

	this->OnInit();

	SetSizer(topsizer); // use the sizer for layout
	topsizer->SetSizeHints(this); // set size hints to honour minimum size
  }
private:
	// Any class wishing to process wxWindows events must use this macro
	DECLARE_EVENT_TABLE()
};

static CStringTable g_stringTable[] =
{
	{ 0 , 0 }
};


REGISTER_DIALOG(IDD_SPLIT,CSplitDialog,g_stringTable)

BEGIN_EVENT_TABLE(CSplitDialogImpl, wxDialog)
	EVT_BUTTON(wxID_ANY,   CModalDialogImpl::OnAnyButton)
	EVT_CHECKBOX(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_MENU(WORKER_EVENT, CModalDialogImpl::OnWorkerEvent)
END_EVENT_TABLE()

// SplitUtils.cpp

#include "StdAfx.h"

#include "../../../Common/StringToInt.h"

#include "SplitUtils.h"

bool ParseVolumeSizes(const UString &s, CRecordVector<UInt64> &values)
{
  values.Clear();
  bool prevIsNumber = false;
  for (unsigned i = 0; i < s.Len();)
  {
    wchar_t c = s[i++];
    if (c == L' ')
      continue;
    if (c == L'-')
      return true;
    if (prevIsNumber)
    {
      prevIsNumber = false;
      unsigned numBits = 0;
      switch (MyCharLower_Ascii(c))
      {
        case 'b': continue;
        case 'k': numBits = 10; break;
        case 'm': numBits = 20; break;
        case 'g': numBits = 30; break;
        case 't': numBits = 40; break;
      }
      if (numBits != 0)
      {
        UInt64 &val = values.Back();
        if (val >= ((UInt64)1 << (64 - numBits)))
          return false;
        val <<= numBits;

        for (; i < s.Len(); i++)
          if (s[i] == L' ')
            break;
        continue;
      }
    }
    i--;
    const wchar_t *start = s.Ptr(i);
    const wchar_t *end;
    UInt64 val = ConvertStringToUInt64(start, &end);
    if (start == end)
      return false;
    if (val == 0)
      return false;
    values.Add(val);
    prevIsNumber = true;
    i += (unsigned)(end - start);
  }
  return true;
}

void AddVolumeItems(NWindows::NControl::CComboBox &combo)
{
  combo.AddString(TEXT("10M"));
  combo.AddString(TEXT("650M - CD"));
  combo.AddString(TEXT("700M - CD"));
  combo.AddString(TEXT("4092M - FAT"));
  combo.AddString(TEXT("4480M - DVD"));     //  4489 MiB limit
  combo.AddString(TEXT("8128M - DVD DL"));  //  8147 MiB limit
  combo.AddString(TEXT("23040M - BD"));     // 23866 MiB limit
  combo.AddString(TEXT("1457664 - 3.5\" floppy"));
}

UInt64 GetNumberOfVolumes(UInt64 size, const CRecordVector<UInt64> &volSizes)
{
  if (size == 0 || volSizes.Size() == 0)
    return 1;
  FOR_VECTOR (i, volSizes)
  {
    UInt64 volSize = volSizes[i];
    if (volSize >= size)
      return i + 1;
    size -= volSize;
  }
  UInt64 volSize = volSizes.Back();
  if (volSize == 0)
    return (UInt64)(Int64)-1;
  return volSizes.Size() + (size - 1) / volSize + 1;
}
// SplitUtils.h

#ifndef __SPLIT_UTILS_H
#define __SPLIT_UTILS_H

#include "../../../Common/MyTypes.h"
#include "../../../Common/MyString.h"

#include "../../../Windows/Control/ComboBox.h"

bool ParseVolumeSizes(const UString &s, CRecordVector<UInt64> &values);
void AddVolumeItems(NWindows::NControl::CComboBox &volumeCombo);
UInt64 GetNumberOfVolumes(UInt64 size, const CRecordVector<UInt64> &volSizes);

#endif
// StringUtils.cpp

#include "StdAfx.h"

#include "StringUtils.h"

void SplitStringToTwoStrings(const UString &src, UString &dest1, UString &dest2)
{
  dest1.Empty();
  dest2.Empty();
  bool quoteMode = false;
  unsigned i;
  for (i = 0; i < src.Len(); i++)
  {
    wchar_t c = src[i];
    if (c == L'\"')
      quoteMode = !quoteMode;
    else if (c == L' ' && !quoteMode)
    {
      if (!quoteMode)
      {
        i++;
        break;
      }
    }
    else
      dest1 += c;
  }
  dest2 = src.Ptr(i);
}

void SplitString(const UString &srcString, UStringVector &destStrings)
{
  destStrings.Clear();
  unsigned len = srcString.Len();
  if (len == 0)
    return;
  UString s;
  for (unsigned i = 0; i < len; i++)
  {
    wchar_t c = srcString[i];
    if (c == L' ')
    {
      if (!s.IsEmpty())
      {
        destStrings.Add(s);
        s.Empty();
      }
    }
    else
      s += c;
  }
  if (!s.IsEmpty())
    destStrings.Add(s);
}

/*
UString JoinStrings(const UStringVector &srcStrings)
{

  UString s;
  FOR_VECTOR (i, srcStrings)
  {
    if (i != 0)
      s.Add_Space();
    s += srcStrings[i];
  }
  return s;
}
*/
// StringUtils.h

#ifndef __STRING_UTILS_H
#define __STRING_UTILS_H

#include "../../../Common/MyString.h"

void SplitStringToTwoStrings(const UString &src, UString &dest1, UString &dest2);

void SplitString(const UString &srcString, UStringVector &destStrings);
UString JoinStrings(const UStringVector &srcStrings);

#endif
// SysIconUtils.cpp

#include "StdAfx.h"

#ifndef _UNICODE
#include "../../../Common/StringConvert.h"
#endif

#include "../../../Windows/FileDir.h"

#include "SysIconUtils.h"

#ifndef _UNICODE
extern bool g_IsNT;
#endif

#ifdef _WIN32
int GetIconIndexForCSIDL(int csidl)
{
  LPITEMIDLIST pidl = 0;
  SHGetSpecialFolderLocation(NULL, csidl, &pidl);
  if (pidl)
  {
    SHFILEINFO shellInfo;
    SHGetFileInfo(LPCTSTR(pidl), FILE_ATTRIBUTE_NORMAL,
      &shellInfo, sizeof(shellInfo),
      SHGFI_PIDL | SHGFI_SYSICONINDEX);
    IMalloc  *pMalloc;
    SHGetMalloc(&pMalloc);
    if (pMalloc)
    {
      pMalloc->Free(pidl);
      pMalloc->Release();
    }
    return shellInfo.iIcon;
  }
  return 0;
}

#ifndef _UNICODE
typedef int (WINAPI * SHGetFileInfoWP)(LPCWSTR pszPath, DWORD attrib, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);

struct CSHGetFileInfoInit
{
  SHGetFileInfoWP shGetFileInfoW;
  CSHGetFileInfoInit()
  {
    shGetFileInfoW = (SHGetFileInfoWP)
    ::GetProcAddress(::GetModuleHandleW(L"shell32.dll"), "SHGetFileInfoW");
  }
} g_SHGetFileInfoInit;
#endif

static DWORD_PTR MySHGetFileInfoW(LPCWSTR pszPath, DWORD attrib, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags)
{
  #ifdef _UNICODE
  return SHGetFileInfo
  #else
  if (g_SHGetFileInfoInit.shGetFileInfoW == 0)
    return 0;
  return g_SHGetFileInfoInit.shGetFileInfoW
  #endif
  (pszPath, attrib, psfi, cbFileInfo, uFlags);
}

DWORD_PTR GetRealIconIndex(CFSTR path, DWORD attrib, int &iconIndex)
{
  #ifndef _UNICODE
  if (!g_IsNT)
  {
    SHFILEINFO shellInfo;
    DWORD_PTR res = ::SHGetFileInfo(fs2fas(path), FILE_ATTRIBUTE_NORMAL | attrib, &shellInfo,
      sizeof(shellInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX);
    iconIndex = shellInfo.iIcon;
    return res;
  }
  else
  #endif
  {
    SHFILEINFOW shellInfo;
    DWORD_PTR res = ::MySHGetFileInfoW(fs2us(path), FILE_ATTRIBUTE_NORMAL | attrib, &shellInfo,
      sizeof(shellInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX);
    iconIndex = shellInfo.iIcon;
    return res;
  }
}

/*
DWORD_PTR GetRealIconIndex(const UString &fileName, DWORD attrib, int &iconIndex, UString *typeName)
{
  #ifndef _UNICODE
  if (!g_IsNT)
  {
    SHFILEINFO shellInfo;
    shellInfo.szTypeName[0] = 0;
    DWORD_PTR res = ::SHGetFileInfoA(GetSystemString(fileName), FILE_ATTRIBUTE_NORMAL | attrib, &shellInfo,
        sizeof(shellInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX | SHGFI_TYPENAME);
    if (typeName)
      *typeName = GetUnicodeString(shellInfo.szTypeName);
    iconIndex = shellInfo.iIcon;
    return res;
  }
  else
  #endif
  {
    SHFILEINFOW shellInfo;
    shellInfo.szTypeName[0] = 0;
    DWORD_PTR res = ::MySHGetFileInfoW(fileName, FILE_ATTRIBUTE_NORMAL | attrib, &shellInfo,
        sizeof(shellInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX | SHGFI_TYPENAME);
    if (typeName)
      *typeName = shellInfo.szTypeName;
    iconIndex = shellInfo.iIcon;
    return res;
  }
}
*/

static int FindInSorted_Attrib(const CRecordVector<CAttribIconPair> &vect, DWORD attrib, int &insertPos)
{
  unsigned left = 0, right = vect.Size();
  while (left != right)
  {
    unsigned mid = (left + right) / 2;
    DWORD midAttrib = vect[mid].Attrib;
    if (attrib == midAttrib)
      return mid;
    if (attrib < midAttrib)
      right = mid;
    else
      left = mid + 1;
  }
  insertPos = left;
  return -1;
}

static int FindInSorted_Ext(const CObjectVector<CExtIconPair> &vect, const wchar_t *ext, int &insertPos)
{
  unsigned left = 0, right = vect.Size();
  while (left != right)
  {
    unsigned mid = (left + right) / 2;
    int compare = MyStringCompareNoCase(ext, vect[mid].Ext);
    if (compare == 0)
      return mid;
    if (compare < 0)
      right = mid;
    else
      left = mid + 1;
  }
  insertPos = left;
  return -1;
}

int CExtToIconMap::GetIconIndex(DWORD attrib, const wchar_t *fileName /*, UString *typeName */)
{
  int dotPos = -1;
  unsigned i;
  for (i = 0;; i++)
  {
    wchar_t c = fileName[i];
    if (c == 0)
      break;
    if (c == '.')
      dotPos = i;
  }

  /*
  if (MyStringCompareNoCase(fileName, L"$Recycle.Bin") == 0)
  {
    char s[256];
    sprintf(s, "SPEC i = %3d, attr = %7x", _attribMap.Size(), attrib);
    OutputDebugStringA(s);
    OutputDebugStringW(fileName);
  }
  */

  if ((attrib & FILE_ATTRIBUTE_DIRECTORY) != 0 || dotPos < 0)
  {
    int insertPos = 0;
    int index = FindInSorted_Attrib(_attribMap, attrib, insertPos);
    if (index >= 0)
    {
      // if (typeName) *typeName = _attribMap[index].TypeName;
      return _attribMap[index].IconIndex;
    }
    CAttribIconPair pair;
    GetRealIconIndex(
        #ifdef UNDER_CE
        FTEXT("\\")
        #endif
        FTEXT("__DIR__")
        , attrib, pair.IconIndex
        // , pair.TypeName
        );

    /*
    char s[256];
    sprintf(s, "i = %3d, attr = %7x", _attribMap.Size(), attrib);
    OutputDebugStringA(s);
    */

    pair.Attrib = attrib;
    _attribMap.Insert(insertPos, pair);
    // if (typeName) *typeName = pair.TypeName;
    return pair.IconIndex;
  }

  const wchar_t *ext = fileName + dotPos + 1;
  int insertPos = 0;
  int index = FindInSorted_Ext(_extMap, ext, insertPos);
  if (index >= 0)
  {
    const CExtIconPair &pa = _extMap[index];
    // if (typeName) *typeName = pa.TypeName;
    return pa.IconIndex;
  }

  for (i = 0;; i++)
  {
    wchar_t c = ext[i];
    if (c == 0)
      break;
    if (c < L'0' || c > L'9')
      break;
  }
  if (i != 0 && ext[i] == 0)
  {
    // GetRealIconIndex is too slow for big number of split extensions: .001, .002, .003
    if (!SplitIconIndex_Defined)
    {
      GetRealIconIndex(
          #ifdef UNDER_CE
          FTEXT("\\")
          #endif
          FTEXT("__FILE__.001"), 0, SplitIconIndex);
      SplitIconIndex_Defined = true;
    }
    return SplitIconIndex;
  }

  CExtIconPair pair;
  pair.Ext = ext;
  GetRealIconIndex(us2fs(fileName + dotPos), attrib, pair.IconIndex);
  _extMap.Insert(insertPos, pair);
  // if (typeName) *typeName = pair.TypeName;
  return pair.IconIndex;
}

/*
int CExtToIconMap::GetIconIndex(DWORD attrib, const UString &fileName)
{
  return GetIconIndex(attrib, fileName, NULL);
}
*/

#endif

DWORD_PTR GetRealIconIndex(CFSTR path, DWORD attrib, int &iconIndex)
{
	iconIndex = 0; // FIXME
	return 0; 
}

int CExtToIconMap::GetIconIndex(DWORD attrib, const wchar_t *fileName /*, UString *typeName */)
{
	return 0;
}

// SysIconUtils.h

#ifndef __SYS_ICON_UTILS_H
#define __SYS_ICON_UTILS_H

#include "Common/MyString.h"

struct CExtIconPair
{
  UString Ext;
  int IconIndex;
  // UString TypeName;

  // int Compare(const CExtIconPair &a) const { return MyStringCompareNoCase(Ext, a.Ext); }
};

struct CAttribIconPair
{
  DWORD Attrib;
  int IconIndex;
  // UString TypeName;

  // int Compare(const CAttribIconPair &a) const { return Ext.Compare(a.Ext); }
};

class CExtToIconMap
{
public:
  CRecordVector<CAttribIconPair> _attribMap;
  CObjectVector<CExtIconPair> _extMap;
  int SplitIconIndex;
  int SplitIconIndex_Defined;
  
  CExtToIconMap(): SplitIconIndex_Defined(false) {}

  void Clear()
  {
    SplitIconIndex_Defined = false;
    _extMap.Clear();
    _attribMap.Clear();
  }
  int GetIconIndex(DWORD attrib, const wchar_t *fileName /* , UString *typeName */);
  // int GetIconIndex(DWORD attrib, const UString &fileName);
};

DWORD_PTR GetRealIconIndex(CFSTR path, DWORD attrib, int &iconIndex);
int GetIconIndexForCSIDL(int csidl);

#ifdef WIN32
inline HIMAGELIST GetSysImageList(bool smallIcons)
{
  SHFILEINFO shellInfo;
  return (HIMAGELIST)SHGetFileInfo(TEXT(""),
      FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_DIRECTORY,
      &shellInfo, sizeof(shellInfo),
      SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX | (smallIcons ? SHGFI_SMALLICON : SHGFI_ICON));
}
#endif

#endif
// TextPairs.cpp

#include "StdAfx.h"

#include "TextPairs.h"

static const wchar_t kNewLineChar = '\n';
static const wchar_t kQuoteChar = '\"';

static const wchar_t kBOM = (wchar_t)0xFEFF;

static bool IsSeparatorChar(wchar_t c)
{
  return (c == ' ' || c == '\t');
}

static void RemoveCr(UString &s)
{
  s.RemoveChar(L'\x0D');
}

static UString GetIDString(const wchar_t *srcString, unsigned &finishPos)
{
  UString result;
  bool quotes = false;
  for (finishPos = 0;;)
  {
    wchar_t c = srcString[finishPos];
    if (c == 0)
      break;
    finishPos++;
    bool isSeparatorChar = IsSeparatorChar(c);
    if (c == kNewLineChar || (isSeparatorChar && !quotes)
        || (c == kQuoteChar && quotes))
      break;
    else if (c == kQuoteChar)
      quotes = true;
    else
      result += c;
  }
  result.Trim();
  RemoveCr(result);
  return result;
}

static UString GetValueString(const wchar_t *srcString, unsigned &finishPos)
{
  UString result;
  for (finishPos = 0;;)
  {
    wchar_t c = srcString[finishPos];
    if (c == 0)
      break;
    finishPos++;
    if (c == kNewLineChar)
      break;
    result += c;
  }
  result.Trim();
  RemoveCr(result);
  return result;
}

static bool GetTextPairs(const UString &srcString, CObjectVector<CTextPair> &pairs)
{
  pairs.Clear();
  unsigned pos = 0;
  
  if (srcString.Len() > 0)
  {
    if (srcString[0] == kBOM)
      pos++;
  }
  while (pos < srcString.Len())
  {
    unsigned finishPos;
    UString id = GetIDString((const wchar_t *)srcString + pos, finishPos);
    pos += finishPos;
    if (id.IsEmpty())
      continue;
    UString value = GetValueString((const wchar_t *)srcString + pos, finishPos);
    pos += finishPos;
    if (!id.IsEmpty())
    {
      CTextPair pair;
      pair.ID = id;
      pair.Value = value;
      pairs.Add(pair);
    }
  }
  return true;
}

static int ComparePairIDs(const UString &s1, const UString &s2)
  { return MyStringCompareNoCase(s1, s2); }

static int ComparePairItems(const CTextPair &p1, const CTextPair &p2)
  { return ComparePairIDs(p1.ID, p2.ID); }

static int ComparePairItems(void *const *a1, void *const *a2, void * /* param */)
  { return ComparePairItems(**(const CTextPair **)a1, **(const CTextPair **)a2); }

void CPairsStorage::Sort() { Pairs.Sort(ComparePairItems, 0); }

int CPairsStorage::FindID(const UString &id, int &insertPos) const
{
  int left = 0, right = Pairs.Size();
  while (left != right)
  {
    int mid = (left + right) / 2;
    int compResult = ComparePairIDs(id, Pairs[mid].ID);
    if (compResult == 0)
      return mid;
    if (compResult < 0)
      right = mid;
    else
      left = mid + 1;
  }
  insertPos = left;
  return -1;
}

int CPairsStorage::FindID(const UString &id) const
{
  int pos;
  return FindID(id, pos);
}

void CPairsStorage::AddPair(const CTextPair &pair)
{
  int insertPos;
  int pos = FindID(pair.ID, insertPos);
  if (pos >= 0)
    Pairs[pos] = pair;
  else
    Pairs.Insert(insertPos, pair);
}

void CPairsStorage::DeletePair(const UString &id)
{
  int pos = FindID(id);
  if (pos >= 0)
    Pairs.Delete(pos);
}

bool CPairsStorage::GetValue(const UString &id, UString &value) const
{
  value.Empty();
  int pos = FindID(id);
  if (pos < 0)
    return false;
  value = Pairs[pos].Value;
  return true;
}

UString CPairsStorage::GetValue(const UString &id) const
{
  int pos = FindID(id);
  if (pos < 0)
    return UString();
  return Pairs[pos].Value;
}

bool CPairsStorage::ReadFromString(const UString &text)
{
  bool result = ::GetTextPairs(text, Pairs);
  if (result)
    Sort();
  else
    Pairs.Clear();
  return result;
}

void CPairsStorage::SaveToString(UString &text) const
{
  FOR_VECTOR (i, Pairs)
  {
    const CTextPair &pair = Pairs[i];
    bool multiWord = (pair.ID.Find(L' ') >= 0);
    if (multiWord)
      text += L'\"';
    text += pair.ID;
    if (multiWord)
      text += L'\"';
    text += L' ';
    text += pair.Value;
    text += L'\x0D';
    text.Add_LF();
  }
}
// TextPairs.h

#ifndef __FM_TEXT_PAIRS_H
#define __FM_TEXT_PAIRS_H

#include "../../../Common/MyString.h"

struct CTextPair
{
  UString ID;
  UString Value;
};

class CPairsStorage
{
  CObjectVector<CTextPair> Pairs;
  
  int FindID(const UString &id, int &insertPos) const;
  int FindID(const UString &id) const;
  void Sort();
public:
  void Clear() { Pairs.Clear(); }
  bool ReadFromString(const UString &text);
  void SaveToString(UString &text) const;

  bool GetValue(const UString &id, UString &value) const;
  UString GetValue(const UString &id) const;
  void AddPair(const CTextPair &pair);
  void DeletePair(const UString &id);
};

#endif
// UpdateCallback100.cpp

#include "StdAfx.h"

#include "../../../Windows/ErrorMsg.h"

#include "../GUI/resource3.h"

#include "LangUtils.h"
#include "UpdateCallback100.h"

STDMETHODIMP CUpdateCallback100Imp::ScanProgress(UInt64 /* numFolders */, UInt64 numFiles, UInt64 totalSize, const wchar_t *path, Int32 /* isDir */)
{
  return ProgressDialog->Sync.ScanProgress(numFiles, totalSize, us2fs(path));
}

STDMETHODIMP CUpdateCallback100Imp::ScanError(const wchar_t *path, HRESULT errorCode)
{
  ProgressDialog->Sync.AddError_Code_Name(errorCode, path);
  return S_OK;
}

STDMETHODIMP CUpdateCallback100Imp::SetNumFiles(UInt64 numFiles)
{
  return ProgressDialog->Sync.Set_NumFilesTotal(numFiles);
}

STDMETHODIMP CUpdateCallback100Imp::SetTotal(UInt64 size)
{
  ProgressDialog->Sync.Set_NumBytesTotal(size);
  return S_OK;
}

STDMETHODIMP CUpdateCallback100Imp::SetCompleted(const UInt64 *completed)
{
  return ProgressDialog->Sync.Set_NumBytesCur(completed);
}

STDMETHODIMP CUpdateCallback100Imp::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)
{
  ProgressDialog->Sync.Set_Ratio(inSize, outSize);
  return S_OK;
}

STDMETHODIMP CUpdateCallback100Imp::CompressOperation(const wchar_t *name)
{
  return SetOperation_Base(NUpdateNotifyOp::kAdd, name, false);
}

STDMETHODIMP CUpdateCallback100Imp::DeleteOperation(const wchar_t *name)
{
  return SetOperation_Base(NUpdateNotifyOp::kDelete, name, false);
}

STDMETHODIMP CUpdateCallback100Imp::OperationResult(Int32 /* operationResult */)
{
  ProgressDialog->Sync.Set_NumFilesCur(++NumFiles);
  return S_OK;
}

void SetExtractErrorMessage(Int32 opRes, Int32 encrypted, const wchar_t *fileName, UString &s);

HRESULT CUpdateCallback100Imp::ReportExtractResult(Int32 opRes, Int32 isEncrypted, const wchar_t *name)
{
  if (opRes != NArchive::NExtract::NOperationResult::kOK)
  {
    UString s;
    SetExtractErrorMessage(opRes, isEncrypted, name, s);
    ProgressDialog->Sync.AddError_Message(s);
  }
  return S_OK;
}

HRESULT CUpdateCallback100Imp::ReportUpdateOperation(UInt32 notifyOp, const wchar_t *name, Int32 isDir)
{
  return SetOperation_Base(notifyOp, name, IntToBool(isDir));
}

STDMETHODIMP CUpdateCallback100Imp::UpdateErrorMessage(const wchar_t *message)
{
  ProgressDialog->Sync.AddError_Message(message);
  return S_OK;
}

HRESULT CUpdateCallback100Imp::OpenFileError(const wchar_t *path, HRESULT errorCode)
{
  ProgressDialog->Sync.AddError_Code_Name(errorCode, path);
  return S_OK;
}

STDMETHODIMP CUpdateCallback100Imp::ReadingFileError(const wchar_t *path, HRESULT errorCode)
{
  ProgressDialog->Sync.AddError_Code_Name(errorCode, path);
  return S_OK;
}

STDMETHODIMP CUpdateCallback100Imp::CryptoGetTextPassword2(Int32 *passwordIsDefined, BSTR *password)
{
  *password = NULL;
  *passwordIsDefined = BoolToInt(PasswordIsDefined);
  if (!PasswordIsDefined)
    return S_OK;
  return StringToBstr(Password, password);
}

STDMETHODIMP CUpdateCallback100Imp::SetTotal(const UInt64 * /* files */, const UInt64 * /* bytes */)
{
  return S_OK;
}

STDMETHODIMP CUpdateCallback100Imp::SetCompleted(const UInt64 * /* files */, const UInt64 * /* bytes */)
{
  return ProgressDialog->Sync.CheckStop();
}

STDMETHODIMP CUpdateCallback100Imp::CryptoGetTextPassword(BSTR *password)
{
  *password = NULL;
  if (!PasswordIsDefined)
  {
    RINOK(ShowAskPasswordDialog())
  }
  return StringToBstr(Password, password);
}
// UpdateCallback100.h

#ifndef __UPDATE_CALLBACK100_H
#define __UPDATE_CALLBACK100_H

#include "../../../Common/MyCom.h"

#include "../../IPassword.h"

#include "../Agent/IFolderArchive.h"

#include "../GUI/UpdateCallbackGUI2.h"

#include "ProgressDialog2.h"

class CUpdateCallback100Imp:
  public IFolderArchiveUpdateCallback,
  public IFolderArchiveUpdateCallback2,
  public IFolderScanProgress,
  public ICryptoGetTextPassword2,
  public ICryptoGetTextPassword,
  public IArchiveOpenCallback,
  public ICompressProgressInfo,
  public CUpdateCallbackGUI2,
  public CMyUnknownImp
{
public:

  // CUpdateCallback100Imp() {}

  MY_UNKNOWN_IMP7(
    IFolderArchiveUpdateCallback,
    IFolderArchiveUpdateCallback2,
    IFolderScanProgress,
    ICryptoGetTextPassword2,
    ICryptoGetTextPassword,
    IArchiveOpenCallback,
    ICompressProgressInfo)

  INTERFACE_IProgress(;)
  INTERFACE_IArchiveOpenCallback(;)
  INTERFACE_IFolderArchiveUpdateCallback(;)
  INTERFACE_IFolderArchiveUpdateCallback2(;)
  INTERFACE_IFolderScanProgress(;)

  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize);

  STDMETHOD(CryptoGetTextPassword)(BSTR *password);
  STDMETHOD(CryptoGetTextPassword2)(Int32 *passwordIsDefined, BSTR *password);
};

#endif
// ViewSettings.cpp

#include "StdAfx.h"

#include "../../../../C/CpuArch.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/Registry.h"
#include "../../../Windows/Synchronization.h"

#include "ViewSettings.h"

using namespace NWindows;
using namespace NRegistry;

#define REG_PATH_FM TEXT("Software") TEXT(STRING_PATH_SEPARATOR) TEXT("7-Zip") TEXT(STRING_PATH_SEPARATOR) TEXT("FM")

static const TCHAR *kCUBasePath = REG_PATH_FM;
static const TCHAR *kCulumnsKeyName = REG_PATH_FM TEXT(STRING_PATH_SEPARATOR) TEXT("Columns");

static const TCHAR *kPositionValueName = TEXT("Position");
static const TCHAR *kPanelsInfoValueName = TEXT("Panels");
static const TCHAR *kToolbars = TEXT("Toolbars");

static const WCHAR *kPanelPathValueName = L"PanelPath";
static const TCHAR *kListMode = TEXT("ListMode");
static const TCHAR *kFolderHistoryValueName = TEXT("FolderHistory");
static const TCHAR *kFastFoldersValueName = TEXT("FolderShortcuts");
static const TCHAR *kCopyHistoryValueName = TEXT("CopyHistory");

static NSynchronization::CCriticalSection g_CS;

#define Set32(p, v) SetUi32(((Byte *)p), v)
#define SetBool(p, v) Set32(p, ((v) ? 1 : 0))

#define Get32(p, dest) dest = GetUi32((const Byte *)p)
#define GetBool(p, dest) dest = (GetUi32(p) != 0);

/*
struct CColumnHeader
{
  UInt32 Version;
  UInt32 SortID;
  UInt32 Ascending; // bool
};
*/

static const UInt32 kListViewHeaderSize = 3 * 4;
static const UInt32 kColumnInfoSize = 3 * 4;
static const UInt32 kListViewVersion = 1;

void CListViewInfo::Save(const UString &id) const
{
  const UInt32 dataSize = kListViewHeaderSize + kColumnInfoSize * Columns.Size();
  CByteArr buf(dataSize);

  Set32(buf, kListViewVersion);
  Set32(buf + 4, SortID);
  SetBool(buf + 8, Ascending);
  FOR_VECTOR (i, Columns)
  {
    const CColumnInfo &column = Columns[i];
    Byte *p = buf + kListViewHeaderSize + i * kColumnInfoSize;
    Set32(p, column.PropID);
    SetBool(p + 4, column.IsVisible);
    Set32(p + 8, column.Width);
  }
  {
    NSynchronization::CCriticalSectionLock lock(g_CS);
    CKey key;
    key.Create(HKEY_CURRENT_USER, kCulumnsKeyName);
    key.SetValue(GetSystemString(id), (const Byte *)buf, dataSize);
  }
}

void CListViewInfo::Read(const UString &id)
{
  Clear();
  CByteBuffer buf;
  UInt32 size;
  {
    NSynchronization::CCriticalSectionLock lock(g_CS);
    CKey key;
    if (key.Open(HKEY_CURRENT_USER, kCulumnsKeyName, KEY_READ) != ERROR_SUCCESS)
      return;
    if (key.QueryValue(GetSystemString(id), buf, size) != ERROR_SUCCESS)
      return;
  }
  if (size < kListViewHeaderSize)
    return;
  UInt32 version;
  Get32(buf, version);
  if (version != kListViewVersion)
    return;
  Get32(buf + 4, SortID);
  GetBool(buf + 8, Ascending);

  size -= kListViewHeaderSize;
  if (size % kColumnInfoSize != 0)
    return;
  unsigned numItems = size / kColumnInfoSize;
  Columns.ClearAndReserve(numItems);
  for (unsigned i = 0; i < numItems; i++)
  {
    CColumnInfo column;
    const Byte *p = buf + kListViewHeaderSize + i * kColumnInfoSize;
    Get32(p, column.PropID);
    GetBool(p + 4, column.IsVisible);
    Get32(p + 8, column.Width);
    Columns.AddInReserved(column);
  }
}


/*
struct CWindowPosition
{
  RECT Rect;
  UInt32 Maximized; // bool
};

struct CPanelsInfo
{
  UInt32 NumPanels;
  UInt32 CurrentPanel;
  UInt32 SplitterPos;
};
*/

static const UInt32 kWindowPositionHeaderSize = 5 * 4;
static const UInt32 kPanelsInfoHeaderSize = 3 * 4;

#ifdef _WIN32
void CWindowInfo::Save() const
{
  NSynchronization::CCriticalSectionLock lock(g_CS);
  CKey key;
  key.Create(HKEY_CURRENT_USER, kCUBasePath);
  {
    Byte buf[kWindowPositionHeaderSize];
    Set32(buf,      rect.left);
    Set32(buf +  4, rect.top);
    Set32(buf +  8, rect.right);
    Set32(buf + 12, rect.bottom);
    SetBool(buf + 16, maximized);
    key.SetValue(kPositionValueName, buf, kWindowPositionHeaderSize);
  }
  {
    Byte buf[kPanelsInfoHeaderSize];
    Set32(buf,      numPanels);
    Set32(buf +  4, currentPanel);
    Set32(buf +  8, splitterPos);
    key.SetValue(kPanelsInfoValueName, buf, kPanelsInfoHeaderSize);
  }
}

static bool QueryBuf(CKey &key, LPCTSTR name, CByteBuffer &buf, UInt32 dataSize)
{
  UInt32 size;
  return key.QueryValue(name, buf, size) == ERROR_SUCCESS && size == dataSize;
}

void CWindowInfo::Read(bool &windowPosDefined, bool &panelInfoDefined)
{
  windowPosDefined = false;
  panelInfoDefined = false;
  NSynchronization::CCriticalSectionLock lock(g_CS);
  CKey key;
  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) != ERROR_SUCCESS)
    return;
  CByteBuffer buf;
  if (QueryBuf(key, kPositionValueName, buf, kWindowPositionHeaderSize))
  {
    Get32(buf,      rect.left);
    Get32(buf +  4, rect.top);
    Get32(buf +  8, rect.right);
    Get32(buf + 12, rect.bottom);
    GetBool(buf + 16, maximized);
    windowPosDefined = true;
  }
  if (QueryBuf(key, kPanelsInfoValueName, buf, kPanelsInfoHeaderSize))
  {
    Get32(buf,      numPanels);
    Get32(buf +  4, currentPanel);
    Get32(buf +  8, splitterPos);
    panelInfoDefined = true;
  }
  return;
}
#endif


void SaveUi32Val(const TCHAR *name, UInt32 value)
{
  CKey key;
  key.Create(HKEY_CURRENT_USER, kCUBasePath);
  key.SetValue(name, value);
}

bool ReadUi32Val(const TCHAR *name, UInt32 &value)
{
  CKey key;
  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) != ERROR_SUCCESS)
    return false;
  return key.QueryValue(name, value) == ERROR_SUCCESS;
}

void SaveToolbarsMask(UInt32 toolbarMask)
{
  SaveUi32Val(kToolbars, toolbarMask);
}

static const UInt32 kDefaultToolbarMask = ((UInt32)1 << 31) | 8 | 4 | 1;

UInt32 ReadToolbarsMask()
{
  UInt32 mask;
  if (!ReadUi32Val(kToolbars, mask))
    return kDefaultToolbarMask;
  return mask;
}


void CListMode::Save() const
{
  UInt32 t = 0;
  for (int i = 0; i < 2; i++)
    t |= ((Panels[i]) & 0xFF) << (i * 8);
  SaveUi32Val(kListMode, t);
}

void CListMode::Read()
{
  Init();
  UInt32 t;
  if (!ReadUi32Val(kListMode, t))
    return;
  for (int i = 0; i < 2; i++)
  {
    Panels[i] = (t & 0xFF);
    t >>= 8;
  }
}

static UString GetPanelPathName(UInt32 panelIndex)
{
  WCHAR s[16];
  ConvertUInt32ToString(panelIndex, s);
  return (UString)kPanelPathValueName + s;
}

void SavePanelPath(UInt32 panel, const UString &path)
{
  NSynchronization::CCriticalSectionLock lock(g_CS);
  CKey key;
  key.Create(HKEY_CURRENT_USER, kCUBasePath);
  key.SetValue(GetPanelPathName(panel), path);
}

bool ReadPanelPath(UInt32 panel, UString &path)
{
  NSynchronization::CCriticalSectionLock lock(g_CS);
  CKey key;
  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) != ERROR_SUCCESS)
    return false;
  return (key.QueryValue(GetPanelPathName(panel), path) == ERROR_SUCCESS);
}


static void SaveStringList(LPCTSTR valueName, const UStringVector &folders)
{
  NSynchronization::CCriticalSectionLock lock(g_CS);
  CKey key;
  key.Create(HKEY_CURRENT_USER, kCUBasePath);
  key.SetValue_Strings(valueName, folders);
}

static void ReadStringList(LPCTSTR valueName, UStringVector &folders)
{
  folders.Clear();
  NSynchronization::CCriticalSectionLock lock(g_CS);
  CKey key;
  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) == ERROR_SUCCESS)
    key.GetValue_Strings(valueName, folders);
}

void SaveFolderHistory(const UStringVector &folders)
  { SaveStringList(kFolderHistoryValueName, folders); }
void ReadFolderHistory(UStringVector &folders)
  { ReadStringList(kFolderHistoryValueName, folders); }

void SaveFastFolders(const UStringVector &folders)
  { SaveStringList(kFastFoldersValueName, folders); }
void ReadFastFolders(UStringVector &folders)
  { ReadStringList(kFastFoldersValueName, folders); }

void SaveCopyHistory(const UStringVector &folders)
  { SaveStringList(kCopyHistoryValueName, folders); }
void ReadCopyHistory(UStringVector &folders)
  { ReadStringList(kCopyHistoryValueName, folders); }

void AddUniqueStringToHeadOfList(UStringVector &list, const UString &s)
{
  for (unsigned i = 0; i < list.Size();)
    if (s.IsEqualTo_NoCase(list[i]))
      list.Delete(i);
    else
      i++;
  list.Insert(0, s);
}
// ViewSettings.h

#ifndef __VIEW_SETTINGS_H
#define __VIEW_SETTINGS_H

#include "../../../Common/MyTypes.h"
#include "../../../Common/MyString.h"

struct CColumnInfo
{
  PROPID PropID;
  bool IsVisible;
  UInt32 Width;

  bool IsEqual(const CColumnInfo &a) const
  {
    return PropID == a.PropID && IsVisible == a.IsVisible && Width == a.Width;
  }
};

struct CListViewInfo
{
  CRecordVector<CColumnInfo> Columns;
  PROPID SortID;
  bool Ascending;

  void Clear()
  {
    SortID = 0;
    Ascending = true;
    Columns.Clear();
  }

  /*
  int FindColumnWithID(PROPID propID) const
  {
    FOR_VECTOR (i, Columns)
      if (Columns[i].PropID == propID)
        return i;
    return -1;
  }
  */

  bool IsEqual(const CListViewInfo &info) const
  {
    if (Columns.Size() != info.Columns.Size() ||
        SortID != info.SortID ||
        Ascending != info.Ascending)
      return false;
    FOR_VECTOR (i, Columns)
      if (!Columns[i].IsEqual(info.Columns[i]))
        return false;
    return true;
  }

  void Save(const UString &id) const;
  void Read(const UString &id);
};


#ifdef _WIN32
struct CWindowInfo
{
  RECT rect;
  bool maximized;

  UInt32 numPanels;
  UInt32 currentPanel;
  UInt32 splitterPos;

  void Save() const;
  void Read(bool &windowPosDefined, bool &panelInfoDefined);
};
#endif

void SaveToolbarsMask(UInt32 toolbarMask);
UInt32 ReadToolbarsMask();

const UInt32 kListMode_Report = 3;

struct CListMode
{
  UInt32 Panels[2];
  
  void Init() { Panels[0] = Panels[1] = kListMode_Report; }
  CListMode() { Init(); }
  
  void Save() const ;
  void Read();
};



void SavePanelPath(UInt32 panel, const UString &path);
bool ReadPanelPath(UInt32 panel, UString &path);


void SaveFolderHistory(const UStringVector &folders);
void ReadFolderHistory(UStringVector &folders);

void SaveFastFolders(const UStringVector &folders);
void ReadFastFolders(UStringVector &folders);

void SaveCopyHistory(const UStringVector &folders);
void ReadCopyHistory(UStringVector &folders);

void AddUniqueStringToHeadOfList(UStringVector &list, const UString &s);

#endif

TARGET_FLAGS=`wx-config --unicode=yes --cxxflags`

include ../../../../makefile.crc32
include ../../../../makefile.machine

LIBS=`wx-config --unicode=yes --libs` $(LOCAL_LIBS_DLL)

include ../../../../makefile.glb



# WARNING : automatically generated by utils/generate.py

PROG=../../../../bin/7zFM_do_not_use$(BINSUFFIX)

all: $(PCH_NAME) $(PROG)

LOCAL_FLAGS=$(TARGET_FLAGS) \
  -DLANG \
  -DNEW_FOLDER_INTERFACE \
  -DEXTERNAL_CODECS \
  -D_FILE_OFFSET_BITS=64 \
  -D_LARGEFILE_SOURCE \
  -D_REENTRANT \
  -DENV_UNIX \
  -DBREAK_HANDLER \
  -DUNICODE \
  -D_UNICODE \
  -DUNIX_USE_WIN_FILE \

SRCS=\
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilePathAutoRename.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/UI/Agent/Agent.cpp \
  ../../../../CPP/7zip/UI/Agent/AgentOut.cpp \
  ../../../../CPP/7zip/UI/Agent/AgentProxy.cpp \
  ../../../../CPP/7zip/UI/Agent/ArchiveFolder.cpp \
  ../../../../CPP/7zip/UI/Agent/ArchiveFolderOpen.cpp \
  ../../../../CPP/7zip/UI/Agent/ArchiveFolderOut.cpp \
  ../../../../CPP/7zip/UI/Agent/UpdateCallbackAgent.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveName.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp \
  ../../../../CPP/7zip/UI/Common/CompressCall.cpp \
  ../../../../CPP/7zip/UI/Common/DefaultName.cpp \
  ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp \
  ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp \
  ../../../../CPP/7zip/UI/Common/HashCalc.cpp \
  ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp \
  ../../../../CPP/7zip/UI/Common/OpenArchive.cpp \
  ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp \
  ../../../../CPP/7zip/UI/Common/SetProperties.cpp \
  ../../../../CPP/7zip/UI/Common/SortUtils.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateAction.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp \
  ../../../../CPP/7zip/UI/Common/UpdatePair.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp \
  ../../../../CPP/7zip/UI/Common/WorkDir.cpp \
  ../../../../CPP/7zip/UI/Common/ZipRegistry.cpp \
  ../../../../CPP/7zip/UI/FileManager/App.cpp \
  ../../../../CPP/7zip/UI/FileManager/ClassDefs.cpp \
  ../../../../CPP/7zip/UI/FileManager/ComboDialog.cpp \
  ../../../../CPP/7zip/UI/FileManager/ComboDialog_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/CopyDialog.cpp \
  ../../../../CPP/7zip/UI/FileManager/CopyDialog_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/ExtractCallback.cpp \
  ../../../../CPP/7zip/UI/FileManager/FM.cpp \
  ../../../../CPP/7zip/UI/FileManager/FM_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/FSDrives.cpp \
  ../../../../CPP/7zip/UI/FileManager/FSFolder.cpp \
  ../../../../CPP/7zip/UI/FileManager/FSFolderCopy.cpp \
  ../../../../CPP/7zip/UI/FileManager/FileFolderPluginOpen.cpp \
  ../../../../CPP/7zip/UI/FileManager/FormatUtils.cpp \
  ../../../../CPP/7zip/UI/FileManager/LangUtils.cpp \
  ../../../../CPP/7zip/UI/FileManager/ListViewDialog.cpp \
  ../../../../CPP/7zip/UI/FileManager/ListViewDialog_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/MessagesDialog.cpp \
  ../../../../CPP/7zip/UI/FileManager/MessagesDialog_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/MyLoadMenu.cpp \
  ../../../../CPP/7zip/UI/FileManager/OpenCallback.cpp \
  ../../../../CPP/7zip/UI/FileManager/OverwriteDialog.cpp \
  ../../../../CPP/7zip/UI/FileManager/OverwriteDialog_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/Panel.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelCopy.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelCrc.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelFolderChange.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelItemOpen.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelItems.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelListNotify.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelMenu.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelOperations.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelSelect.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelSort.cpp \
  ../../../../CPP/7zip/UI/FileManager/PanelSplitFile.cpp \
  ../../../../CPP/7zip/UI/FileManager/PasswordDialog.cpp \
  ../../../../CPP/7zip/UI/FileManager/PasswordDialog_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/ProgramLocation.cpp \
  ../../../../CPP/7zip/UI/FileManager/ProgressDialog2.cpp \
  ../../../../CPP/7zip/UI/FileManager/ProgressDialog2_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/PropertyName.cpp \
  ../../../../CPP/7zip/UI/FileManager/RegistryUtils.cpp \
  ../../../../CPP/7zip/UI/FileManager/RootFolder.cpp \
  ../../../../CPP/7zip/UI/FileManager/SplitDialog.cpp \
  ../../../../CPP/7zip/UI/FileManager/SplitDialog_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/SplitUtils.cpp \
  ../../../../CPP/7zip/UI/FileManager/StringUtils.cpp \
  ../../../../CPP/7zip/UI/FileManager/SysIconUtils.cpp \
  ../../../../CPP/7zip/UI/FileManager/TextPairs.cpp \
  ../../../../CPP/7zip/UI/FileManager/UpdateCallback100.cpp \
  ../../../../CPP/7zip/UI/FileManager/ViewSettings.cpp \
  ../../../../CPP/7zip/UI/FileManager/wxFM.cpp \
  ../../../../CPP/7zip/UI/GUI/HashGUI.cpp \
  ../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI2.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CrcReg.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/Lang.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/NewHandler.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/TextConfig.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Windows/Clipboard.cpp \
  ../../../../CPP/Windows/Control/Controls.cpp \
  ../../../../CPP/Windows/Control/Dialog.cpp \
  ../../../../CPP/Windows/Control/Window2.cpp \
  ../../../../CPP/Windows/DLL.cpp \
  ../../../../CPP/Windows/ErrorMsg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantConv.cpp \
  ../../../../CPP/Windows/Registry.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/Windows/Window.cpp \
  ../../../../CPP/myWindows/wine_GetXXXDefaultLangID.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \

SRCS_C=\
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/Alloc.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Sha256.c \
  ../../../../C/Sort.c \
  ../../../../C/Threads.c \

StdAfx.h.gch : ../../../myWindows/StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) ../../../myWindows/StdAfx.h -o StdAfx.h.gch
7zCrc.o : ../../../../C/7zCrc.c
	$(CC) $(CFLAGS) ../../../../C/7zCrc.c
7zCrcOpt.o : ../../../../C/7zCrcOpt.c
	$(CC) $(CFLAGS) ../../../../C/7zCrcOpt.c
Alloc.o : ../../../../C/Alloc.c
	$(CC) $(CFLAGS) ../../../../C/Alloc.c
CpuArch.o : ../../../../C/CpuArch.c
	$(CC) $(CFLAGS) ../../../../C/CpuArch.c
Sha256.o : ../../../../C/Sha256.c
	$(CC) $(CFLAGS) ../../../../C/Sha256.c
Sort.o : ../../../../C/Sort.c
	$(CC) $(CFLAGS) ../../../../C/Sort.c
Threads.o : ../../../../C/Threads.c
	$(CC) $(CFLAGS) ../../../../C/Threads.c
OutStreamWithCRC.o : ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
CreateCoder.o : ../../../../CPP/7zip/Common/CreateCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CreateCoder.cpp
FilePathAutoRename.o : ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
FileStreams.o : ../../../../CPP/7zip/Common/FileStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FileStreams.cpp
FilterCoder.o : ../../../../CPP/7zip/Common/FilterCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilterCoder.cpp
LimitedStreams.o : ../../../../CPP/7zip/Common/LimitedStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/LimitedStreams.cpp
MethodProps.o : ../../../../CPP/7zip/Common/MethodProps.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MethodProps.cpp
ProgressUtils.o : ../../../../CPP/7zip/Common/ProgressUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/ProgressUtils.cpp
PropId.o : ../../../../CPP/7zip/Common/PropId.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/PropId.cpp
StreamObjects.o : ../../../../CPP/7zip/Common/StreamObjects.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamObjects.cpp
StreamUtils.o : ../../../../CPP/7zip/Common/StreamUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamUtils.cpp
UniqBlocks.o : ../../../../CPP/7zip/Common/UniqBlocks.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/UniqBlocks.cpp
CopyCoder.o : ../../../../CPP/7zip/Compress/CopyCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyCoder.cpp
Agent.o : ../../../../CPP/7zip/UI/Agent/Agent.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Agent/Agent.cpp
AgentOut.o : ../../../../CPP/7zip/UI/Agent/AgentOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Agent/AgentOut.cpp
AgentProxy.o : ../../../../CPP/7zip/UI/Agent/AgentProxy.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Agent/AgentProxy.cpp
ArchiveFolder.o : ../../../../CPP/7zip/UI/Agent/ArchiveFolder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Agent/ArchiveFolder.cpp
ArchiveFolderOpen.o : ../../../../CPP/7zip/UI/Agent/ArchiveFolderOpen.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Agent/ArchiveFolderOpen.cpp
ArchiveFolderOut.o : ../../../../CPP/7zip/UI/Agent/ArchiveFolderOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Agent/ArchiveFolderOut.cpp
UpdateCallbackAgent.o : ../../../../CPP/7zip/UI/Agent/UpdateCallbackAgent.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Agent/UpdateCallbackAgent.cpp
ArchiveExtractCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
ArchiveName.o : ../../../../CPP/7zip/UI/Common/ArchiveName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveName.cpp
ArchiveOpenCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
CompressCall.o : ../../../../CPP/7zip/UI/Common/CompressCall.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/CompressCall.cpp
DefaultName.o : ../../../../CPP/7zip/UI/Common/DefaultName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/DefaultName.cpp
EnumDirItems.o : ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp
ExtractingFilePath.o : ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
HashCalc.o : ../../../../CPP/7zip/UI/Common/HashCalc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/HashCalc.cpp
LoadCodecs.o : ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
OpenArchive.o : ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
PropIDUtils.o : ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
SetProperties.o : ../../../../CPP/7zip/UI/Common/SetProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/SetProperties.cpp
SortUtils.o : ../../../../CPP/7zip/UI/Common/SortUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/SortUtils.cpp
UpdateAction.o : ../../../../CPP/7zip/UI/Common/UpdateAction.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateAction.cpp
UpdateCallback.o : ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp
UpdatePair.o : ../../../../CPP/7zip/UI/Common/UpdatePair.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdatePair.cpp
UpdateProduce.o : ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp
WorkDir.o : ../../../../CPP/7zip/UI/Common/WorkDir.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/WorkDir.cpp
ZipRegistry.o : ../../../../CPP/7zip/UI/Common/ZipRegistry.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ZipRegistry.cpp
App.o : ../../../../CPP/7zip/UI/FileManager/App.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/App.cpp
ClassDefs.o : ../../../../CPP/7zip/UI/FileManager/ClassDefs.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ClassDefs.cpp
ComboDialog.o : ../../../../CPP/7zip/UI/FileManager/ComboDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ComboDialog.cpp
ComboDialog_rc.o : ../../../../CPP/7zip/UI/FileManager/ComboDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ComboDialog_rc.cpp
CopyDialog.o : ../../../../CPP/7zip/UI/FileManager/CopyDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/CopyDialog.cpp
CopyDialog_rc.o : ../../../../CPP/7zip/UI/FileManager/CopyDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/CopyDialog_rc.cpp
ExtractCallback.o : ../../../../CPP/7zip/UI/FileManager/ExtractCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ExtractCallback.cpp
FM.o : ../../../../CPP/7zip/UI/FileManager/FM.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/FM.cpp
FM_rc.o : ../../../../CPP/7zip/UI/FileManager/FM_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/FM_rc.cpp
FSDrives.o : ../../../../CPP/7zip/UI/FileManager/FSDrives.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/FSDrives.cpp
FSFolder.o : ../../../../CPP/7zip/UI/FileManager/FSFolder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/FSFolder.cpp
FSFolderCopy.o : ../../../../CPP/7zip/UI/FileManager/FSFolderCopy.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/FSFolderCopy.cpp
FileFolderPluginOpen.o : ../../../../CPP/7zip/UI/FileManager/FileFolderPluginOpen.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/FileFolderPluginOpen.cpp
FormatUtils.o : ../../../../CPP/7zip/UI/FileManager/FormatUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/FormatUtils.cpp
LangUtils.o : ../../../../CPP/7zip/UI/FileManager/LangUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/LangUtils.cpp
ListViewDialog.o : ../../../../CPP/7zip/UI/FileManager/ListViewDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ListViewDialog.cpp
ListViewDialog_rc.o : ../../../../CPP/7zip/UI/FileManager/ListViewDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ListViewDialog_rc.cpp
MessagesDialog.o : ../../../../CPP/7zip/UI/FileManager/MessagesDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/MessagesDialog.cpp
MessagesDialog_rc.o : ../../../../CPP/7zip/UI/FileManager/MessagesDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/MessagesDialog_rc.cpp
MyLoadMenu.o : ../../../../CPP/7zip/UI/FileManager/MyLoadMenu.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/MyLoadMenu.cpp
OpenCallback.o : ../../../../CPP/7zip/UI/FileManager/OpenCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/OpenCallback.cpp
OverwriteDialog.o : ../../../../CPP/7zip/UI/FileManager/OverwriteDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/OverwriteDialog.cpp
OverwriteDialog_rc.o : ../../../../CPP/7zip/UI/FileManager/OverwriteDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/OverwriteDialog_rc.cpp
Panel.o : ../../../../CPP/7zip/UI/FileManager/Panel.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/Panel.cpp
PanelCopy.o : ../../../../CPP/7zip/UI/FileManager/PanelCopy.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelCopy.cpp
PanelCrc.o : ../../../../CPP/7zip/UI/FileManager/PanelCrc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelCrc.cpp
PanelFolderChange.o : ../../../../CPP/7zip/UI/FileManager/PanelFolderChange.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelFolderChange.cpp
PanelItemOpen.o : ../../../../CPP/7zip/UI/FileManager/PanelItemOpen.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelItemOpen.cpp
PanelItems.o : ../../../../CPP/7zip/UI/FileManager/PanelItems.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelItems.cpp
PanelListNotify.o : ../../../../CPP/7zip/UI/FileManager/PanelListNotify.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelListNotify.cpp
PanelMenu.o : ../../../../CPP/7zip/UI/FileManager/PanelMenu.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelMenu.cpp
PanelOperations.o : ../../../../CPP/7zip/UI/FileManager/PanelOperations.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelOperations.cpp
PanelSelect.o : ../../../../CPP/7zip/UI/FileManager/PanelSelect.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelSelect.cpp
PanelSort.o : ../../../../CPP/7zip/UI/FileManager/PanelSort.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelSort.cpp
PanelSplitFile.o : ../../../../CPP/7zip/UI/FileManager/PanelSplitFile.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PanelSplitFile.cpp
PasswordDialog.o : ../../../../CPP/7zip/UI/FileManager/PasswordDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PasswordDialog.cpp
PasswordDialog_rc.o : ../../../../CPP/7zip/UI/FileManager/PasswordDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PasswordDialog_rc.cpp
ProgramLocation.o : ../../../../CPP/7zip/UI/FileManager/ProgramLocation.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ProgramLocation.cpp
ProgressDialog2.o : ../../../../CPP/7zip/UI/FileManager/ProgressDialog2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ProgressDialog2.cpp
ProgressDialog2_rc.o : ../../../../CPP/7zip/UI/FileManager/ProgressDialog2_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ProgressDialog2_rc.cpp
PropertyName.o : ../../../../CPP/7zip/UI/FileManager/PropertyName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PropertyName.cpp
RegistryUtils.o : ../../../../CPP/7zip/UI/FileManager/RegistryUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/RegistryUtils.cpp
RootFolder.o : ../../../../CPP/7zip/UI/FileManager/RootFolder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/RootFolder.cpp
SplitDialog.o : ../../../../CPP/7zip/UI/FileManager/SplitDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/SplitDialog.cpp
SplitDialog_rc.o : ../../../../CPP/7zip/UI/FileManager/SplitDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/SplitDialog_rc.cpp
SplitUtils.o : ../../../../CPP/7zip/UI/FileManager/SplitUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/SplitUtils.cpp
StringUtils.o : ../../../../CPP/7zip/UI/FileManager/StringUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/StringUtils.cpp
SysIconUtils.o : ../../../../CPP/7zip/UI/FileManager/SysIconUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/SysIconUtils.cpp
TextPairs.o : ../../../../CPP/7zip/UI/FileManager/TextPairs.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/TextPairs.cpp
UpdateCallback100.o : ../../../../CPP/7zip/UI/FileManager/UpdateCallback100.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/UpdateCallback100.cpp
ViewSettings.o : ../../../../CPP/7zip/UI/FileManager/ViewSettings.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ViewSettings.cpp
wxFM.o : ../../../../CPP/7zip/UI/FileManager/wxFM.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/wxFM.cpp
HashGUI.o : ../../../../CPP/7zip/UI/GUI/HashGUI.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/HashGUI.cpp
UpdateCallbackGUI2.o : ../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI2.cpp
CRC.o : ../../../../CPP/Common/CRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CRC.cpp
CrcReg.o : ../../../../CPP/Common/CrcReg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CrcReg.cpp
IntToString.o : ../../../../CPP/Common/IntToString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/IntToString.cpp
Lang.o : ../../../../CPP/Common/Lang.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Lang.cpp
MyString.o : ../../../../CPP/Common/MyString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyString.cpp
MyVector.o : ../../../../CPP/Common/MyVector.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyVector.cpp
MyWindows.o : ../../../../CPP/Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyWindows.cpp
NewHandler.o : ../../../../CPP/Common/NewHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/NewHandler.cpp
StringConvert.o : ../../../../CPP/Common/StringConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringConvert.cpp
StringToInt.o : ../../../../CPP/Common/StringToInt.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringToInt.cpp
TextConfig.o : ../../../../CPP/Common/TextConfig.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/TextConfig.cpp
UTFConvert.o : ../../../../CPP/Common/UTFConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/UTFConvert.cpp
Wildcard.o : ../../../../CPP/Common/Wildcard.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Wildcard.cpp
Clipboard.o : ../../../../CPP/Windows/Clipboard.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Clipboard.cpp
Controls.o : ../../../../CPP/Windows/Control/Controls.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Control/Controls.cpp
Dialog.o : ../../../../CPP/Windows/Control/Dialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Control/Dialog.cpp
Window2.o : ../../../../CPP/Windows/Control/Window2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Control/Window2.cpp
DLL.o : ../../../../CPP/Windows/DLL.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/DLL.cpp
ErrorMsg.o : ../../../../CPP/Windows/ErrorMsg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/ErrorMsg.cpp
FileDir.o : ../../../../CPP/Windows/FileDir.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileDir.cpp
FileFind.o : ../../../../CPP/Windows/FileFind.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileFind.cpp
FileIO.o : ../../../../CPP/Windows/FileIO.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileIO.cpp
FileName.o : ../../../../CPP/Windows/FileName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileName.cpp
PropVariant.o : ../../../../CPP/Windows/PropVariant.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariant.cpp
PropVariantConv.o : ../../../../CPP/Windows/PropVariantConv.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariantConv.cpp
Registry.o : ../../../../CPP/Windows/Registry.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Registry.cpp
Synchronization.o : ../../../../CPP/Windows/Synchronization.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Synchronization.cpp
System.o : ../../../../CPP/Windows/System.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/System.cpp
TimeUtils.o : ../../../../CPP/Windows/TimeUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/TimeUtils.cpp
Window.o : ../../../../CPP/Windows/Window.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Window.cpp
wine_GetXXXDefaultLangID.o : ../../../../CPP/myWindows/wine_GetXXXDefaultLangID.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_GetXXXDefaultLangID.cpp
wine_date_and_time.o : ../../../../CPP/myWindows/wine_date_and_time.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_date_and_time.cpp

OBJS=\
 7zCrc.o \
 $(OBJ_CRC32) \
 Alloc.o \
 CpuArch.o \
 Sha256.o \
 Sort.o \
 Threads.o \
 OutStreamWithCRC.o \
 CreateCoder.o \
 FilePathAutoRename.o \
 FileStreams.o \
 FilterCoder.o \
 LimitedStreams.o \
 MethodProps.o \
 ProgressUtils.o \
 PropId.o \
 StreamObjects.o \
 StreamUtils.o \
 UniqBlocks.o \
 CopyCoder.o \
 Agent.o \
 AgentOut.o \
 AgentProxy.o \
 ArchiveFolder.o \
 ArchiveFolderOpen.o \
 ArchiveFolderOut.o \
 UpdateCallbackAgent.o \
 ArchiveExtractCallback.o \
 ArchiveName.o \
 ArchiveOpenCallback.o \
 CompressCall.o \
 DefaultName.o \
 EnumDirItems.o \
 ExtractingFilePath.o \
 HashCalc.o \
 LoadCodecs.o \
 OpenArchive.o \
 PropIDUtils.o \
 SetProperties.o \
 SortUtils.o \
 UpdateAction.o \
 UpdateCallback.o \
 UpdatePair.o \
 UpdateProduce.o \
 WorkDir.o \
 ZipRegistry.o \
 App.o \
 ClassDefs.o \
 ComboDialog.o \
 ComboDialog_rc.o \
 CopyDialog.o \
 CopyDialog_rc.o \
 ExtractCallback.o \
 FM.o \
 FM_rc.o \
 FSDrives.o \
 FSFolder.o \
 FSFolderCopy.o \
 FileFolderPluginOpen.o \
 FormatUtils.o \
 LangUtils.o \
 ListViewDialog.o \
 ListViewDialog_rc.o \
 MessagesDialog.o \
 MessagesDialog_rc.o \
 MyLoadMenu.o \
 OpenCallback.o \
 OverwriteDialog.o \
 OverwriteDialog_rc.o \
 Panel.o \
 PanelCopy.o \
 PanelCrc.o \
 PanelFolderChange.o \
 PanelItemOpen.o \
 PanelItems.o \
 PanelListNotify.o \
 PanelMenu.o \
 PanelOperations.o \
 PanelSelect.o \
 PanelSort.o \
 PanelSplitFile.o \
 PasswordDialog.o \
 PasswordDialog_rc.o \
 ProgramLocation.o \
 ProgressDialog2.o \
 ProgressDialog2_rc.o \
 PropertyName.o \
 RegistryUtils.o \
 RootFolder.o \
 SplitDialog.o \
 SplitDialog_rc.o \
 SplitUtils.o \
 StringUtils.o \
 SysIconUtils.o \
 TextPairs.o \
 UpdateCallback100.o \
 ViewSettings.o \
 wxFM.o \
 HashGUI.o \
 UpdateCallbackGUI2.o \
 CRC.o \
 CrcReg.o \
 IntToString.o \
 Lang.o \
 MyString.o \
 MyVector.o \
 MyWindows.o \
 NewHandler.o \
 StringConvert.o \
 StringToInt.o \
 TextConfig.o \
 UTFConvert.o \
 Wildcard.o \
 Clipboard.o \
 Controls.o \
 Dialog.o \
 Window2.o \
 DLL.o \
 ErrorMsg.o \
 FileDir.o \
 FileFind.o \
 FileIO.o \
 FileName.o \
 PropVariant.o \
 PropVariantConv.o \
 Registry.o \
 Synchronization.o \
 System.o \
 TimeUtils.o \
 Window.o \
 wine_GetXXXDefaultLangID.o \
 wine_date_and_time.o \

#include "resourceGui.h"

#define IDR_MENUBAR1      70
#define IDM_MENU          71
#define IDR_ACCELERATOR1  72

#define IDB_ADD      100
#define IDB_EXTRACT  101
#define IDB_TEST     102
#define IDB_COPY     103
#define IDB_MOVE     104
#define IDB_DELETE   105
#define IDB_INFO     106

#define IDB_ADD2     150
#define IDB_EXTRACT2 151
#define IDB_TEST2    152
#define IDB_COPY2    153
#define IDB_MOVE2    154
#define IDB_DELETE2  155
#define IDB_INFO2    156

#define IDM_HASH_ALL             101
#define IDM_CRC32                102
#define IDM_CRC64                103
#define IDM_SHA1                 104
#define IDM_SHA256               105

#define IDM_OPEN                 540
#define IDM_OPEN_INSIDE          541
#define IDM_OPEN_OUTSIDE         542
#define IDM_FILE_VIEW            543
#define IDM_FILE_EDIT            544
#define IDM_RENAME               545
#define IDM_COPY_TO              546
#define IDM_MOVE_TO              547
#define IDM_DELETE               548
#define IDM_SPLIT                549
#define IDM_COMBINE              550
#define IDM_PROPERTIES           551
#define IDM_COMMENT              552
#define IDM_CRC                  553
#define IDM_DIFF                 554
#define IDM_CREATE_FOLDER        555
#define IDM_CREATE_FILE          556
// #define IDM_EXIT                 557
#define IDM_LINK                 558
#define IDM_ALT_STREAMS          559

#define IDM_OPEN_INSIDE_ONE      590
#define IDM_OPEN_INSIDE_PARSER   591

#define IDM_SELECT_ALL           600
#define IDM_DESELECT_ALL         601
#define IDM_INVERT_SELECTION     602
#define IDM_SELECT               603
#define IDM_DESELECT             604
#define IDM_SELECT_BY_TYPE       605
#define IDM_DESELECT_BY_TYPE     606

#define IDM_VIEW_LARGE_ICONS     700
#define IDM_VIEW_SMALL_ICONS     701
#define IDM_VIEW_LIST            702
#define IDM_VIEW_DETAILS         703

#define IDM_VIEW_ARANGE_BY_NAME  710
#define IDM_VIEW_ARANGE_BY_TYPE  711
#define IDM_VIEW_ARANGE_BY_DATE  712
#define IDM_VIEW_ARANGE_BY_SIZE  713

#define IDM_VIEW_ARANGE_NO_SORT  730
#define IDM_VIEW_FLAT_VIEW       731
#define IDM_VIEW_TWO_PANELS      732
#define IDM_VIEW_TOOLBARS        733
#define IDM_OPEN_ROOT_FOLDER     734
#define IDM_OPEN_PARENT_FOLDER   735
#define IDM_FOLDERS_HISTORY      736
#define IDM_VIEW_REFRESH         737
#define IDM_VIEW_AUTO_REFRESH    738
// #define IDM_VIEW_SHOW_DELETED    739
// #define IDM_VIEW_SHOW_STREAMS    740

#define IDM_VIEW_ARCHIVE_TOOLBAR            750
#define IDM_VIEW_STANDARD_TOOLBAR           751
#define IDM_VIEW_TOOLBARS_LARGE_BUTTONS     752
#define IDM_VIEW_TOOLBARS_SHOW_BUTTONS_TEXT 753

#define IDS_BOOKMARK             801

#define IDM_OPTIONS              900
#define IDM_BENCHMARK            901
#define IDM_BENCHMARK2           902

#define IDM_HELP_CONTENTS        960
#define IDM_ABOUT                5014  /* FIXME 961   5014 = wxID_ABOUT */

#define IDS_OPTIONS                     2100

#define IDS_N_SELECTED_ITEMS            3002

#define IDS_FILE_EXIST                  3008
#define IDS_WANT_UPDATE_MODIFIED_FILE   3009
#define IDS_CANNOT_UPDATE_FILE          3010
#define IDS_CANNOT_START_EDITOR         3011
#define IDS_VIRUS                       3012
#define IDS_MESSAGE_UNSUPPORTED_OPERATION_FOR_LONG_PATH_FOLDER  3013
#define IDS_SELECT_ONE_FILE             3014
#define IDS_SELECT_FILES                3015
#define IDS_TOO_MANY_ITEMS              3016

#define IDS_COPY                        6000
#define IDS_MOVE                        6001
#define IDS_COPY_TO                     6002
#define IDS_MOVE_TO                     6003
#define IDS_COPYING                     6004
#define IDS_MOVING                      6005
#define IDS_RENAMING                    6006

#define IDS_OPERATION_IS_NOT_SUPPORTED  6008
#define IDS_ERROR_RENAMING              6009
#define IDS_CONFIRM_FILE_COPY           6010
#define IDS_WANT_TO_COPY_FILES          6011

#define IDS_CONFIRM_FILE_DELETE         6100
#define IDS_CONFIRM_FOLDER_DELETE       6101
#define IDS_CONFIRM_ITEMS_DELETE        6102
#define IDS_WANT_TO_DELETE_FILE         6103
#define IDS_WANT_TO_DELETE_FOLDER       6104
#define IDS_WANT_TO_DELETE_ITEMS        6105
#define IDS_DELETING                    6106
#define IDS_ERROR_DELETING              6107
#define IDS_ERROR_LONG_PATH_TO_RECYCLE  6108

#define IDS_CREATE_FOLDER               6300
#define IDS_CREATE_FILE                 6301
#define IDS_CREATE_FOLDER_NAME          6302
#define IDS_CREATE_FILE_NAME            6303
#define IDS_CREATE_FOLDER_DEFAULT_NAME  6304
#define IDS_CREATE_FILE_DEFAULT_NAME    6305
#define IDS_CREATE_FOLDER_ERROR         6306
#define IDS_CREATE_FILE_ERROR           6307

#define IDS_COMMENT                     6400
#define IDS_COMMENT2                    6401
#define IDS_SELECT                      6402
#define IDS_DESELECT                    6403
#define IDS_SELECT_MASK                 6404

#define IDS_PROPERTIES                  6600
#define IDS_FOLDERS_HISTORY             6601

#define IDS_COMPUTER                    7100
#define IDS_NETWORK                     7101
#define IDS_DOCUMENTS                   7102
#define IDS_SYSTEM                      7103

#define IDS_ADD                         7200
#define IDS_EXTRACT                     7201
#define IDS_TEST                        7202
#define IDS_BUTTON_COPY                 7203
#define IDS_BUTTON_MOVE                 7204
#define IDS_BUTTON_DELETE               7205
#define IDS_BUTTON_INFO                 7206

#define IDS_SPLITTING                   7303
#define IDS_SPLIT_CONFIRM_TITLE         7304
#define IDS_SPLIT_CONFIRM_MESSAGE       7305
#define IDS_SPLIT_VOL_MUST_BE_SMALLER   7306

#define IDS_COMBINE                     7400
#define IDS_COMBINE_TO                  7401
#define IDS_COMBINING                   7402
#define IDS_COMBINE_SELECT_ONE_FILE     7403
#define IDS_COMBINE_CANT_DETECT_SPLIT_FILE 7404
#define IDS_COMBINE_CANT_FIND_MORE_THAN_ONE_PART 7405
#define IDI_ICON  1

#define IDS_MESSAGE_NO_ERRORS           3001

#define IDS_PROGRESS_TESTING            3302
#define IDS_OPENNING                    3303
#define IDS_SCANNING                    3304

#define IDS_CHECKSUM_CALCULATING        7500
#define IDS_CHECKSUM_INFORMATION        7501
#define IDS_CHECKSUM_CRC_DATA           7502
#define IDS_CHECKSUM_CRC_DATA_NAMES     7503
#define IDS_CHECKSUM_CRC_STREAMS_NAMES  7504

#define IDS_INCORRECT_VOLUME_SIZE       7307
// wxFM.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#undef _WIN32
 
#ifdef __WXMAC__

#define UInt32 max_UInt32
#include <ApplicationServices/ApplicationServices.h>
#undef UInt32

#endif

#include "Windows/Control/Dialog.h" // REGISTER_STRINGTABLE

#include "Common/StringConvert.h"

bool GetProgramFolderPath(UString &folder)
{
  const char *p7zip_home_dir = getenv("P7ZIP_HOME_DIR");
  if (p7zip_home_dir == 0) p7zip_home_dir="./";

  folder = MultiByteToUnicodeString(p7zip_home_dir);

  return true;
}

// FIXME

static pthread_t g_main_thread;

void verify_main_thread(void)
{
	if (g_main_thread != pthread_self())
	{
		printf("verify_main_thread-wxFM\n");
		abort();
	}
}

// #include "../GUI/p7zip_32.xpm"

int Main1(int argc,TCHAR **argv);

/*
int Main1(int argc,TCHAR **argv)
{
	// FIXME
	Sleep(10000);
}
*/
	

#include "Windows/Registry.h"
using namespace NWindows;
using namespace NRegistry;


#include "Common/StringConvert.h"
#include "Windows/FileDir.h"
#include "Windows/Synchronization.h"

// FIXME #include "ExtractRes.h"
#include "../Explorer/MyMessages.h"

// FIXME #include "ExtractGUI.h"
// FIXME #include "UpdateGUI.h"
// FIXME #include "BenchmarkDialog.h"
#include "RegistryUtils.h"

using namespace NWindows;
using namespace NFile;

#include "../FileManager/ProgramLocation.h"

static LPCWSTR kHelpFileName = L"help/";

void ShowHelpWindow(HWND hwnd, LPCWSTR topicFile)
{
  UString path;
  if (!::GetProgramFolderPath(path))
    return;
  path += kHelpFileName;
  path += topicFile;
  printf("ShowHelpWindow(%p,%ls)=>%ls\n",hwnd,topicFile,(const wchar_t *)path);
  // HtmlHelp(hwnd, GetSystemString(path), HH_DISPLAY_TOPIC, NULL);
  wxString path2(path);
  wxLaunchDefaultBrowser(path2);
}

//////////////////////////////////

#define NEED_NAME_WINDOWS_TO_UNIX
#include "myPrivate.h" // global_use_utf16_conversion

void mySplitCommandLineW(int numArguments, TCHAR  **arguments,UStringVector &parts) {

  parts.Clear();
  for(int ind=0;ind < numArguments; ind++) {
      UString tmp = arguments[ind];
      // tmp.Trim(); " " is a valid filename ...
      if (!tmp.IsEmpty()) {
        parts.Add(tmp);
      }
  }
}

// ----------------------------------------------------------------------------
// private classes
// ----------------------------------------------------------------------------

// Define a new application type, each program should derive a class from wxApp
class MyApp : public wxApp
{
public:
    // override base class virtuals
    // ----------------------------

    // this one is called on application startup and is a good place for the app
    // initialization (doing it here and not in the ctor allows to have an error
    // return: if OnInit() returns false, the application terminates)
    virtual bool OnInit();

#ifdef __WXMAC__
	virtual void MacOpenFile	(	const wxString & 	fileName	 ) ;	
#endif
	
};

// Create a new application object: this macro will allow wxWidgets to create
// the application object during program execution (it's better than using a
// static object for many reasons) and also implements the accessor function
// wxGetApp() which will return the reference of the right type (i.e. MyApp and
// not wxApp)
IMPLEMENT_APP(MyApp)

time_t g_T0 = 0;

#if 0
class MyThread : public wxThread
{
	int _argc;
	TCHAR **_argv;
public:
	MyThread(int argc,TCHAR **argv): wxThread(),_argc(argc), _argv(argv) {}

	// thread execution starts here
	virtual void *Entry()
	{
		int ret = Main1(_argc,_argv);
		exit(ret);
	}
};
#endif

#ifdef __WXMAC__
void doMacOpenFile(	const UString & fileName	 );

void MyApp::MacOpenFile	(	const wxString & 	fileName	 ) 
{
	const wchar_t * wstr =	fileName.wc_str ();
	
	// ::MessageBoxW(0, L"MyApp::MacOpenFile 2", wstr  , MB_OKCANCEL | MB_ICONQUESTION);
	
	doMacOpenFile(wstr);
}
#endif

// 'Main program' equivalent: the program execution "starts" here
bool MyApp::OnInit()
{
    // don't parse the command-line options !
    // : if ( !wxApp::OnInit() ) return false;

/*
*/	
#ifdef __WXMAC__
ProcessSerialNumber PSN;
GetCurrentProcess(&PSN);
TransformProcessType(&PSN,kProcessTransformToForegroundApplication);
#endif


/*
	UString args(L"Args=");
	
	for(int i = 0 ; i < wxApp::argc ; i++)
		args = args + L" '" + wxApp::argv[i] + L"'";
	
	
	::MessageBoxW(0, L"MyApp::OnInit 3", args, MB_OKCANCEL | MB_ICONQUESTION);
*/

	g_main_thread = pthread_self();

  { // define P7ZIP_HOME_DIR
    extern void my_windows_split_path(const AString &p_path, AString &dir , AString &base);
    static char p7zip_home_dir[MAX_PATH];

    UString fullPath;
    NDir::MyGetFullPathName(wxApp::argv[0], fullPath);
    AString afullPath = GetAnsiString(fullPath);

    AString dir,name;

    my_windows_split_path(afullPath,dir,name);

    const char *dir2 = nameWindowToUnix((const char *)dir);
    snprintf(p7zip_home_dir,sizeof(p7zip_home_dir),"P7ZIP_HOME_DIR=%s/",dir2);
    p7zip_home_dir[sizeof(p7zip_home_dir)-1] = 0;
    putenv(p7zip_home_dir);
    // DEBUG printf("putenv(%s)\n",p7zip_home_dir);
  }
  global_use_utf16_conversion = 1; // UNICODE !

  g_T0 = time(0);
  // DEBUG printf("MAIN Thread : 0x%lx\n",wxThread::GetCurrentId());

   // Create the main frame window
#if 0
    MyFrame *frame = new MyFrame((wxFrame *)NULL, _T("7-zip Main Window"), 50, 50, 450, 340);
   // Don't Show the frame !
   frame->Show(true); // FIXME

    SetTopWindow(frame);

#endif

    /*
    MyThread *thread = new MyThread(wxApp::argc,wxApp::argv);
    thread->Create(); //  != wxTHREAD_NO_ERROR
    thread->Run();
    */

    wxInitAllImageHandlers();

    Main1(wxApp::argc,wxApp::argv);

  // success: wxApp::OnRun() will be called which will enter the main message
  // loop and the application will run. If we returned false here, the
  // application would exit immediately.
    return true;
}

//////////////////////////////////////////

#include "resourceGui.h"

static CStringTable g_stringTable[] =
{
  /* resourceGui.rc */
  /******************/
  { IDS_MESSAGE_NO_ERRORS     ,L"There are no errors" },

  { IDS_PROGRESS_TESTING      ,L"Testing" },

  { IDS_CHECKSUM_CALCULATING    ,L"Checksum calculating..." },
  { IDS_CHECKSUM_INFORMATION    ,L"Checksum information" },
  { IDS_CHECKSUM_CRC_DATA       ,L"CRC checksum for data:" },
  { IDS_CHECKSUM_CRC_DATA_NAMES ,L"CRC checksum for data and names:" },
  { IDS_CHECKSUM_CRC_STREAMS_NAMES ,L"CRC checksum for streams and names:" },

  { IDS_INCORRECT_VOLUME_SIZE ,L"Incorrect volume size" },

  { IDS_OPENNING  ,L"Opening..." },
  { IDS_SCANNING  ,L"Scanning..." },

	{ 0 , 0 }
};

REGISTER_STRINGTABLE(g_stringTable)

#if 0
#include "resource.h"
#include "ExtractRes.h"

static CStringTable g_stringTable[] =
{
  /* resource.rc */	  
  /***************/
	{ IDS_OPEN_TYPE_ALL_FILES, L"All Files" },
	{ IDS_METHOD_STORE, L"Store" },
	{ IDS_METHOD_NORMAL, L"Normal" },
	{ IDS_METHOD_MAXIMUM, L"Maximum" },
	{ IDS_METHOD_FAST, L"Fast" },
	{ IDS_METHOD_FASTEST, L"Fastest" },
	{ IDS_METHOD_ULTRA, L"Ultra" },
	{ IDS_COMPRESS_NON_SOLID, L"Non-solid" },
	{ IDS_COMPRESS_SOLID, L"Solid" },

	{ IDS_COMPRESS_UPDATE_MODE_ADD, L"Add and replace files" },
	{ IDS_COMPRESS_UPDATE_MODE_UPDATE, L"Update and add files" },
	{ IDS_COMPRESS_UPDATE_MODE_FRESH, L"Freshen existing files" },
	{ IDS_COMPRESS_UPDATE_MODE_SYNCHRONIZE, L"Synchronize files" },
	{ IDS_COMPRESS_SET_ARCHIVE_DIALOG_TITLE, L"Browse" },
	{ IDS_COMPRESS_INCORRECT_VOLUME_SIZE, L"Incorrect volume size" },
	{ IDS_COMPRESS_SPLIT_CONFIRM_MESSAGE, L"Specified volume size: {0} bytes.\nAre you sure you want to split archive into such volumes?" },

	{ IDS_PASSWORD_USE_ASCII, L"Use only English letters, numbers and special characters (!, #, $, ...) for password." },
	{ IDS_PASSWORD_PASSWORDS_DO_NOT_MATCH, L"Passwords do not match" },
	{ IDS_PASSWORD_IS_TOO_LONG, L"Password is too long" },

	{ IDS_PROGRESS_COMPRESSING, L"Compressing" },
	{ IDS_PROGRESS_TESTING, L"Testing" },
	{ IDS_MESSAGE_NO_ERRORS, L"There are no errors" },
	{ IDS_FILES_COLON, L"Files:" },
	{ IDS_FOLDERS_COLON, L"Folders:" },
	{ IDS_SIZE_COLON, L"Size:" },
	{ IDS_COMPRESSED_COLON, L"Compressed size:" },
	{ IDS_ARCHIVES_COLON, L"Archives:" },

  /* Extract.rc */	  
  /**************/
	{ IDS_CANNOT_CREATE_FOLDER , L"Cannot create folder '{0}'"},
	{ IDS_OPEN_IS_NOT_SUPORTED_ARCHIVE, L"File is not supported archive."},

	{ IDS_MESSAGES_DIALOG_EXTRACT_MESSAGE_CRC , L"CRC failed in '{0}'. File is broken."},
	{ IDS_MESSAGES_DIALOG_EXTRACT_MESSAGE_DATA_ERROR , L"Data error in '{0}'. File is broken"},
	{ IDS_MESSAGES_DIALOG_EXTRACT_MESSAGE_UNSUPPORTED_METHOD , L"Unsupported compression method for '{0}'."},
	{ IDS_MESSAGES_DIALOG_EXTRACT_MESSAGE_CRC_ENCRYPTED , L"CRC failed in encrypted file '{0}'. Wrong password?"},
	{ IDS_MESSAGES_DIALOG_EXTRACT_MESSAGE_DATA_ERROR_ENCRYPTED , L"Data error in encrypted file '{0}'. Wrong password?"},

	{ IDS_EXTRACT_SET_FOLDER , L"Specify a location for extracted files."},
	{ IDS_MESSAGES_DIALOG_EXTRACT_MESSAGE_CANNOT_OPEN_FILE, L"Can not open output file '{0}'."},
	{ IDS_PROGRESS_EXTRACTING, L"Extracting" },

	{ IDS_CANT_OPEN_ARCHIVE , L"Can not open file '{0}' as archive"},
	{ IDS_CANT_OPEN_ENCRYPTED_ARCHIVE , L"Can not open encrypted archive '{0}'. Wrong password?"},

	{ 0 , 0 }
};

REGISTER_STRINGTABLE(g_stringTable)
#endif


///////////////////////////////////////////

namespace NFsFolder {

	// FIXME
	bool wxw_CopyFile(LPCWSTR existingFile, LPCWSTR newFile, bool overwrite)
	{
		return wxCopyFile(wxString(existingFile), wxString(newFile), overwrite);
	}
}

static const unsigned char ADD2_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x12, 0x59, 0x20, 0xcb, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x3b, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x60, 0xc0, 0x0b, 0x78, 0xef, 0xde, 
0xbd, 0x8b, 0xe0, 0xac, 0x5a, 0xb5, 0xb6, 0x80, 0x6c, 0x0e, 0xc8, 0x28, 
0x20, 0x07, 0x62, 0x20, 0x50, 0x18, 0x02, 0x40, 0x92, 0x64, 0x71, 0xe0, 
0xa6, 0x81, 0x4c, 0x2f, 0x2f, 0x2f, 0x07, 0x72, 0x80, 0x64, 0x01, 0xf9, 
0x0e, 0x85, 0x1a, 0x05, 0x01, 0x70, 0xa3, 0x70, 0x01, 0x00, 0x61, 0xed, 
0x52, 0x81, 0x19, 0x73, 0x26, 0x18, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 
0x4e, 0x44, 0xae, 0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char ADD_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x24, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x6b, 0xa4, 0x39, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x4d, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x60, 0xa0, 0x01, 0xe0, 0xbd, 0x0b, 
0x04, 0x17, 0xb0, 0x49, 0xac, 0x02, 0x82, 0xeb, 0x43, 0x5b, 0x02, 0xe4, 
0xb7, 0xbb, 0x20, 0x09, 0x30, 0x03, 0x49, 0xe2, 0xd6, 0x2a, 0x24, 0xb0, 
0xb6, 0x60, 0xc8, 0x4a, 0xa0, 0x7a, 0x10, 0x49, 0x82, 0xbd, 0xbc, 0xbc, 
0xbc, 0x16, 0x1c, 0x24, 0x40, 0x46, 0x39, 0x92, 0x04, 0xe9, 0x81, 0x38, 
0xf0, 0x12, 0x20, 0xbf, 0x61, 0x93, 0x60, 0x00, 0xf9, 0xad, 0x1c, 0x9b, 
0x04, 0xcd, 0x00, 0x00, 0xa3, 0xbb, 0xae, 0x61, 0x7b, 0x93, 0x6d, 0x0f, 
0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82, 
0x00, 
};
static const unsigned char COPY2_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x12, 0x59, 0x20, 0xcb, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x52, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x95, 0xce, 0x31, 0x0a, 0xc0, 0x30, 0x08, 
0x40, 0x51, 0xb7, 0xdc, 0xd4, 0x4d, 0x70, 0xf3, 0x9a, 0x99, 0xec, 0xe4, 
0x5d, 0x9a, 0x18, 0x68, 0xff, 0x1a, 0xc9, 0xf2, 0x79, 0x22, 0x11, 0xb9, 
0x9a, 0xc9, 0x28, 0x46, 0x92, 0xd2, 0x18, 0xda, 0x54, 0xb5, 0x5e, 0xa5, 
0xda, 0x59, 0xf0, 0xd4, 0x3d, 0x93, 0x61, 0x8c, 0x4d, 0xbf, 0x38, 0xe2, 
0xe9, 0x6b, 0x7e, 0xae, 0x2d, 0x90, 0x11, 0x3e, 0x22, 0xb2, 0xe1, 0xfb, 
0x81, 0x23, 0x00, 0x52, 0x00, 0x21, 0x5c, 0xcd, 0x0b, 0x7e, 0x4c, 0x37, 
0xbb, 0x3f, 0x86, 0x84, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 
0x44, 0xae, 0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char COPY_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x24, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x6b, 0xa4, 0x39, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x80, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0xbd, 0xd1, 0x31, 0x0e, 0x80, 0x20, 0x0c, 
0x85, 0xe1, 0x6e, 0x4e, 0x5c, 0x93, 0x8d, 0xa4, 0x1b, 0xd7, 0x64, 0x2a, 
0x53, 0xef, 0xe2, 0x43, 0x23, 0x12, 0xed, 0x5b, 0xe9, 0x60, 0x62, 0x7e, 
0xbf, 0x00, 0x22, 0xb2, 0x7d, 0x1a, 0x0b, 0xce, 0x82, 0x31, 0x62, 0x85, 
0x85, 0x4c, 0x88, 0x65, 0x42, 0x2c, 0x13, 0x82, 0x10, 0x13, 0x84, 0x85, 
0x24, 0x77, 0xec, 0xdf, 0xc7, 0x8c, 0xf0, 0x92, 0x84, 0x17, 0xbd, 0x3e, 
0xbe, 0xa7, 0xb1, 0x50, 0x58, 0x98, 0xe4, 0x17, 0x0a, 0x0b, 0x9d, 0xad, 
0xa1, 0x24, 0xf4, 0xb9, 0x38, 0x0e, 0xa0, 0xcb, 0x39, 0x1e, 0x20, 0x52, 
0x6b, 0x55, 0x39, 0xf0, 0xac, 0xb6, 0x82, 0xef, 0xbf, 0x52, 0x12, 0x42, 
0x30, 0xee, 0x23, 0x04, 0x08, 0x31, 0xc0, 0x9d, 0xc7, 0x40, 0x8c, 0x00, 
0x71, 0x02, 0x84, 0x81, 0xcd, 0x73, 0x02, 0xb6, 0x2b, 0x69, 0xbd, 0x15, 
0x92, 0x2f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 
0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char DELETE2_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x12, 0x59, 0x20, 0xcb, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x5a, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x9d, 0x8e, 0xc1, 0x11, 0x00, 0x21, 0x08, 
0x03, 0x69, 0xc0, 0x5e, 0x6d, 0xe0, 0x0a, 0xc9, 0xc3, 0x9e, 0xf8, 0x31, 
0x76, 0x73, 0x80, 0x06, 0x7d, 0xde, 0x5c, 0x46, 0xf3, 0x60, 0x27, 0x10, 
0x91, 0xcf, 0x6a, 0x65, 0xae, 0xa9, 0x34, 0x9f, 0x61, 0x6c, 0x8b, 0x19, 
0xa0, 0xcb, 0x92, 0x60, 0xc4, 0xef, 0x44, 0xfe, 0x6c, 0x6f, 0x03, 0x0a, 
0x24, 0x22, 0x58, 0x29, 0x82, 0x24, 0x2a, 0x77, 0xe6, 0x00, 0x9e, 0xc9, 
0xc4, 0x83, 0xd3, 0xc0, 0xae, 0x06, 0xbe, 0xaa, 0x55, 0x03, 0xa3, 0x05, 
0xea, 0xb4, 0x1f, 0x7a, 0x01, 0xc5, 0x78, 0x3b, 0x10, 0xc3, 0x1f, 0xc3, 
0xce, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 
0x82, 0x00, 
};
static const unsigned char DELETE_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x24, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x6b, 0xa4, 0x39, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x81, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0xc5, 0xd1, 0xc1, 0x0d, 0x80, 0x30, 0x08, 
0x05, 0x50, 0x17, 0x60, 0x57, 0xd7, 0xe1, 0xd0, 0x9d, 0x7a, 0x23, 0x6e, 
0x63, 0x2c, 0x14, 0x2d, 0xff, 0x7b, 0x55, 0x2e, 0xfd, 0x31, 0xbc, 0x58, 
0xe8, 0xb6, 0x7d, 0x57, 0x1d, 0x82, 0x97, 0xb4, 0x1a, 0xa2, 0x0e, 0xed, 
0x25, 0x44, 0x9f, 0x6a, 0x5b, 0x43, 0x02, 0xf5, 0xce, 0x0c, 0xb7, 0x18, 
0x9d, 0xe3, 0xdc, 0x09, 0xb9, 0x0e, 0x5b, 0x6f, 0x35, 0x08, 0x82, 0x20, 
0x08, 0x82, 0x10, 0xe0, 0x84, 0x00, 0x27, 0x0c, 0x04, 0x41, 0xc0, 0x66, 
0x78, 0x8a, 0x8e, 0xdf, 0xe3, 0x1f, 0x2f, 0x80, 0x90, 0x9c, 0x83, 0x01, 
0xab, 0xbb, 0xcd, 0x2b, 0x09, 0x92, 0xd8, 0x12, 0x90, 0x39, 0x03, 0x90, 
0x5c, 0x2b, 0x79, 0x41, 0x1f, 0x5a, 0xf0, 0x05, 0xad, 0x84, 0x49, 0x66, 
0x9f, 0xd4, 0x75, 0x19, 0x84, 0x3f, 0xeb, 0x04, 0x1a, 0xa7, 0x7e, 0xab, 
0x5a, 0xf7, 0xe4, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 
0xae, 0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char EXTRACT2_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x12, 0x59, 0x20, 0xcb, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x22, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x60, 0xa0, 0x17, 0xe0, 0xbd, 0x0b, 
0x05, 0x17, 0x40, 0x9c, 0x33, 0x50, 0x70, 0x9d, 0x5c, 0x0e, 0xcc, 0x34, 
0x10, 0x87, 0xa1, 0x1c, 0x06, 0xe8, 0xe6, 0x1b, 0x00, 0xa6, 0x78, 0x38, 
0x15, 0x21, 0xee, 0x22, 0xc7, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 
0x44, 0xae, 0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char EXTRACT_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x24, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x6b, 0xa4, 0x39, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x28, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x60, 0x18, 0x05, 0xa4, 0x81, 0xbb, 
0x28, 0x00, 0x49, 0xe2, 0xce, 0x19, 0x24, 0x70, 0xb6, 0x60, 0xc8, 0x4a, 
0xa0, 0x7a, 0x10, 0x49, 0x82, 0xbd, 0x1c, 0x19, 0x20, 0x49, 0x8c, 0x02, 
0x8a, 0x00, 0x00, 0x11, 0x6c, 0x7c, 0x67, 0x00, 0x94, 0xd4, 0x2c, 0x00, 
0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char INFO2_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x12, 0x59, 0x20, 0xcb, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x46, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x60, 0x40, 0x07, 0xbc, 0x77, 0xef, 
0x5e, 0x40, 0x70, 0x76, 0xef, 0xbe, 0x8e, 0x83, 0x73, 0xf7, 0x2e, 0x82, 
0xc3, 0x50, 0x5e, 0x5e, 0x8e, 0x61, 0x10, 0x54, 0x15, 0xc2, 0x34, 0xa0, 
0x7e, 0x84, 0x01, 0xbc, 0x77, 0x91, 0x4d, 0xab, 0xc5, 0x6d, 0x0f, 0xe9, 
0x1c, 0x90, 0xd1, 0x70, 0x5b, 0x41, 0x96, 0xc2, 0xa5, 0x40, 0xce, 0x41, 
0x38, 0xbb, 0xbc, 0x1c, 0x97, 0xb3, 0x09, 0x03, 0x00, 0x3a, 0xb2, 0x32, 
0x23, 0xbc, 0x78, 0x77, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 
0x44, 0xae, 0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char INFO_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x24, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x6b, 0xa4, 0x39, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x57, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x60, 0xa0, 0x05, 0xb8, 0x0b, 0x04, 
0x17, 0xb0, 0x49, 0xdc, 0xde, 0xbd, 0x7b, 0xf7, 0x75, 0xea, 0x48, 0x80, 
0xec, 0xc0, 0x2a, 0xc1, 0x5e, 0x0e, 0x04, 0xc4, 0xba, 0x94, 0x2c, 0xc0, 
0x7b, 0x17, 0x87, 0x07, 0x79, 0x77, 0xef, 0xc6, 0xee, 0x5c, 0xdc, 0x12, 
0x77, 0x71, 0x79, 0xb0, 0x9c, 0x8a, 0x61, 0x35, 0x18, 0x25, 0x20, 0x3e, 
0xbf, 0x7b, 0x17, 0x53, 0x02, 0x1c, 0x56, 0xbb, 0xf7, 0x16, 0x10, 0x2f, 
0x71, 0x17, 0x02, 0x30, 0x24, 0x18, 0xca, 0x21, 0x00, 0x53, 0x62, 0x30, 
0x01, 0x00, 0xd3, 0xa5, 0x67, 0xc0, 0x11, 0x9d, 0x79, 0xc0, 0x00, 0x00, 
0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char MOVE2_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x12, 0x59, 0x20, 0xcb, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x4c, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x95, 0xce, 0xb1, 0x0d, 0xc0, 0x20, 0x0c, 
0x44, 0xd1, 0xeb, 0xb2, 0x18, 0xad, 0x77, 0xa1, 0x63, 0x4d, 0x0a, 0x4b, 
0xa9, 0xbc, 0x4b, 0x82, 0x41, 0xf0, 0x5b, 0xae, 0xfb, 0x3c, 0xc9, 0x42, 
0xba, 0x5a, 0x67, 0x04, 0xc3, 0x49, 0x6e, 0x8c, 0x92, 0x14, 0x39, 0x2f, 
0x36, 0xdf, 0xd6, 0x3a, 0xc3, 0x18, 0x83, 0x8e, 0x54, 0xc4, 0xcb, 0x6b, 
0x3f, 0xe8, 0x69, 0x63, 0x9e, 0xb0, 0x7f, 0x50, 0x11, 0x00, 0x05, 0x40, 
0x84, 0xab, 0x7d, 0xa9, 0x14, 0x30, 0x23, 0x6c, 0x8b, 0xd3, 0x1c, 0x00, 
0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char MOVE_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x24, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x6b, 0xa4, 0x39, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x71, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0xbd, 0xd1, 0xb1, 0x0d, 0xc0, 0x20, 0x0c, 
0x05, 0x51, 0x2f, 0xc0, 0x56, 0x6e, 0xd9, 0x85, 0x2e, 0x6b, 0x52, 0x58, 
0xa2, 0x62, 0x97, 0x98, 0x22, 0x84, 0x10, 0x5f, 0xcb, 0x6f, 0x4f, 0x4f, 
0x08, 0x10, 0x39, 0xbe, 0x4a, 0xa1, 0x53, 0x30, 0x22, 0x96, 0x29, 0x28, 
0x10, 0x53, 0x20, 0xa6, 0x40, 0x3c, 0xc4, 0xc4, 0xc3, 0x42, 0x52, 0x9f, 
0x1b, 0xe1, 0x25, 0x49, 0xbf, 0xab, 0x14, 0x32, 0x85, 0x49, 0x7e, 0x21, 
0x53, 0x68, 0x74, 0x46, 0x81, 0xd0, 0xe6, 0xe1, 0xdb, 0x3d, 0x1e, 0x20, 
0x72, 0xcd, 0xd9, 0x0a, 0xf6, 0xb7, 0x2a, 0x10, 0x42, 0x30, 0xfe, 0x23, 
0x04, 0x1e, 0x62, 0xe0, 0x7f, 0x1e, 0x03, 0x31, 0x00, 0xd2, 0x01, 0x08, 
0x81, 0xc3, 0xbb, 0x01, 0xf5, 0x5d, 0x59, 0xea, 0x53, 0xc3, 0x86, 0x77, 
0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82, 
0x00, 
};
static unsigned char PARENT_FOLDER_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 
0x08, 0x03, 0x00, 0x00, 0x00, 0x28, 0x2d, 0x0f, 0x53, 0x00, 0x00, 0x03, 
0x00, 0x50, 0x4c, 0x54, 0x45, 0x01, 0x67, 0x01, 0x08, 0x6e, 0x05, 0x08, 
0x77, 0x04, 0x0c, 0x79, 0x07, 0x11, 0x70, 0x0a, 0x11, 0x7c, 0x09, 0x16, 
0x7c, 0x0c, 0x17, 0x79, 0x13, 0x1f, 0x78, 0x1f, 0x37, 0x7a, 0x0b, 0x21, 
0x7d, 0x21, 0x14, 0x8c, 0x0b, 0x19, 0x98, 0x0d, 0x1c, 0xa0, 0x0f, 0x22, 
0x81, 0x17, 0x27, 0x8c, 0x14, 0x27, 0x8f, 0x14, 0x26, 0x8b, 0x1a, 0x27, 
0x8c, 0x1b, 0x2f, 0x94, 0x1f, 0x31, 0x81, 0x1b, 0x2f, 0x81, 0x2f, 0x3b, 
0x85, 0x2e, 0x3d, 0x8a, 0x3d, 0x3e, 0x8a, 0x3f, 0x3c, 0xa1, 0x1f, 0x34, 
0xb3, 0x1b, 0x41, 0x8c, 0x3e, 0x51, 0x8e, 0x29, 0x43, 0xad, 0x22, 0x44, 
0xb7, 0x22, 0x49, 0xbd, 0x25, 0x59, 0xbe, 0x39, 0x61, 0x93, 0x2e, 0x4e, 
0x8f, 0x41, 0x6b, 0xa5, 0x6c, 0x6c, 0xa6, 0x6d, 0x79, 0xad, 0x7a, 0x57, 
0xc4, 0x2c, 0x67, 0xcc, 0x34, 0x6c, 0xd1, 0x39, 0x60, 0xc5, 0x40, 0x75, 
0xda, 0x42, 0x74, 0xd8, 0x47, 0x7f, 0xe3, 0x4c, 0xb9, 0x9c, 0x11, 0x81, 
0xac, 0x47, 0x85, 0xea, 0x53, 0x8e, 0xf4, 0x5c, 0xcc, 0x99, 0x01, 0xd6, 
0xa5, 0x17, 0xd1, 0xa4, 0x1e, 0xd3, 0xa9, 0x2c, 0xdd, 0xaf, 0x35, 0xde, 
0xb5, 0x36, 0xdf, 0xba, 0x3c, 0xe6, 0xbc, 0x3e, 0xde, 0xbe, 0x51, 0xd9, 
0xb9, 0x58, 0xdb, 0xbe, 0x66, 0xe2, 0xb8, 0x43, 0xe6, 0xbc, 0x51, 0xdf, 
0xc3, 0x6b, 0xe6, 0xc2, 0x44, 0xec, 0xc6, 0x4e, 0xea, 0xc0, 0x57, 0xf2, 
0xcc, 0x5b, 0xe2, 0xc6, 0x71, 0xe6, 0xc9, 0x79, 0xe6, 0xd1, 0x63, 0xf2, 
0xd5, 0x64, 0xf5, 0xdf, 0x79, 0xff, 0xdc, 0x77, 0xef, 0xe0, 0x7b, 0xfc, 
0xe4, 0x7c, 0x89, 0xb7, 0x8b, 0x8f, 0xbc, 0x87, 0xb7, 0xd3, 0xba, 0xdf, 
0xec, 0x86, 0xdf, 0xe6, 0xaf, 0xe3, 0xce, 0x92, 0xe4, 0xd3, 0x9e, 0xe4, 
0xd4, 0x9e, 0xec, 0xd9, 0x99, 0xec, 0xd9, 0x9f, 0xfc, 0xd4, 0x83, 0xff, 
0xdb, 0x89, 0xe5, 0xd6, 0xa3, 0xe5, 0xd7, 0xab, 0xef, 0xdf, 0xab, 0xff, 
0xe8, 0x83, 0xff, 0xea, 0x95, 0xff, 0xf2, 0x8c, 0xff, 0xf9, 0x93, 0xff, 
0xff, 0x99, 0xef, 0xf5, 0xbc, 0xf2, 0xe6, 0xa4, 0xff, 0xe6, 0xa0, 0xff, 
0xf2, 0xa9, 0xff, 0xf8, 0xa6, 0xff, 0xff, 0xac, 0xff, 0xff, 0xbe, 0xc6, 
0xdb, 0xc9, 0xd6, 0xe3, 0xd9, 0xea, 0xe2, 0xca, 0xeb, 0xe7, 0xd6, 0xee, 
0xea, 0xdb, 0xf5, 0xea, 0xc1, 0xff, 0xf4, 0xc8, 0xff, 0xfe, 0xc6, 0xfc, 
0xf9, 0xcf, 0xff, 0xff, 0xd1, 0xff, 0xff, 0xd9, 0xe5, 0xed, 0xe9, 0xff, 
0xff, 0xe7, 0xf3, 0xf4, 0xf7, 0xff, 0xff, 0xf2, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xf5, 0xd0, 0xf6, 0xa4, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0e, 0xc4, 0x00, 0x00, 
0x0e, 0xc4, 0x01, 0x95, 0x2b, 0x0e, 0x1b, 0x00, 0x00, 0x00, 0xc1, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x28, 0x86, 0x02, 0x15, 0x89, 0x74, 
0x30, 0xcd, 0x00, 0xe5, 0xfb, 0x32, 0xf1, 0xb0, 0x7b, 0x23, 0x09, 0x14, 
0x72, 0xf1, 0x4a, 0xc9, 0x09, 0x88, 0xa6, 0xc1, 0x05, 0x94, 0xb9, 0xa5, 
0xe4, 0xd5, 0xd4, 0x25, 0x19, 0x55, 0xc1, 0x02, 0xa6, 0xa6, 0xa6, 0x0c, 
0xcc, 0xac, 0xb2, 0xea, 0x1a, 0x1c, 0xac, 0xac, 0x20, 0x01, 0xd3, 0xe0, 
0xbc, 0x78, 0xa0, 0x18, 0xbf, 0x86, 0x96, 0x38, 0xc4, 0x0c, 0xd3, 0xdc, 
0xb8, 0xb8, 0xd4, 0xfc, 0x5c, 0x36, 0x2d, 0x1d, 0x31, 0xa8, 0x40, 0x72, 
0x2c, 0x10, 0x98, 0x72, 0xea, 0x68, 0x2b, 0x99, 0x9a, 0x82, 0x05, 0xa2, 
0xbd, 0xdc, 0xec, 0xcd, 0x43, 0xa4, 0xf5, 0x15, 0x7c, 0x4a, 0xec, 0xc0, 
0x02, 0x61, 0x36, 0x91, 0x45, 0x05, 0xb9, 0x7c, 0x06, 0x82, 0xfe, 0x09, 
0xe1, 0x60, 0x81, 0x50, 0xe7, 0x94, 0xb8, 0x38, 0x3f, 0x61, 0x4d, 0xc5, 
0x24, 0x4b, 0x88, 0x19, 0x8e, 0xd9, 0x31, 0x31, 0x31, 0x7a, 0x42, 0x22, 
0x9e, 0xee, 0x01, 0x10, 0x01, 0xdb, 0x9c, 0xa8, 0xa8, 0x28, 0x16, 0x19, 
0x57, 0x07, 0xb3, 0x2c, 0x88, 0x80, 0x4b, 0xa2, 0x87, 0x93, 0x85, 0xae, 
0xa1, 0xb1, 0x55, 0x10, 0xd4, 0xda, 0x10, 0x23, 0x43, 0x13, 0xeb, 0xc0, 
0x8c, 0x62, 0x98, 0x6f, 0x4d, 0x4d, 0x23, 0x32, 0x8b, 0xe1, 0x00, 0x00, 
0xfc, 0x33, 0x50, 0x72, 0x6d, 0x03, 0x36, 0xf2, 0x00, 0x00, 0x00, 0x00, 
0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82, 
};
static const unsigned char TEST2_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x12, 0x59, 0x20, 0xcb, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x47, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0xb5, 0xcd, 0xbb, 0x11, 0x00, 0x20, 0x08, 
0x03, 0x50, 0x16, 0x60, 0x57, 0x47, 0xb5, 0xb3, 0xc2, 0x0d, 0xcc, 0x0c, 
0x22, 0x9f, 0xc3, 0xde, 0x33, 0x05, 0x29, 0x5e, 0xee, 0x20, 0xfa, 0x1e, 
0x16, 0x91, 0x1e, 0x97, 0x26, 0xb0, 0x9a, 0x17, 0x31, 0x80, 0x71, 0x06, 
0xda, 0x3d, 0xc0, 0x29, 0xc0, 0x29, 0xc1, 0x28, 0xc1, 0x29, 0xc1, 0x68, 
0xd4, 0xc7, 0x0b, 0x94, 0x0a, 0x94, 0x2e, 0x78, 0xc9, 0x06, 0xae, 0xb5, 
0x39, 0x27, 0x85, 0x82, 0xfa, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 
0x4e, 0x44, 0xae, 0x42, 0x60, 0x82, 0x00, 
};
static const unsigned char TEST_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x24, 
0x04, 0x03, 0x00, 0x00, 0x00, 0x3d, 0x6b, 0xa4, 0x39, 0x00, 0x00, 0x00, 
0x30, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 
0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x00, 
0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x14, 0x3b, 0x9d, 0x00, 0x00, 0x00, 
0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 
0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xea, 0x65, 0x16, 0xa4, 0x00, 0x00, 0x00, 0x75, 0x49, 
0x44, 0x41, 0x54, 0x78, 0x9c, 0xd5, 0xd1, 0x31, 0x1a, 0x80, 0x20, 0x08, 
0x05, 0x60, 0xc7, 0x96, 0xee, 0xdb, 0xd8, 0x05, 0xb8, 0x9b, 0x9b, 0x53, 
0xdd, 0xa0, 0xce, 0x10, 0x20, 0xfa, 0x55, 0xef, 0xd5, 0x2e, 0x23, 0xf2, 
0x2b, 0x60, 0x4a, 0x63, 0xc4, 0x66, 0x91, 0x31, 0x3f, 0x9f, 0x1a, 0xc7, 
0x82, 0x07, 0xbb, 0x1d, 0x94, 0xf5, 0x1f, 0xdc, 0x6f, 0x7d, 0x00, 0xf1, 
0x2a, 0xf2, 0xc2, 0xe4, 0x65, 0x99, 0xbc, 0xd0, 0xc9, 0xbb, 0xa5, 0x4e, 
0xa0, 0xa5, 0x20, 0x38, 0x43, 0x10, 0x32, 0x43, 0x25, 0x64, 0xe8, 0x4a, 
0xd8, 0xd0, 0x12, 0x79, 0xd8, 0x52, 0x23, 0xb8, 0x25, 0xe1, 0xa0, 0x11, 
0xb2, 0x56, 0x27, 0xec, 0x1f, 0x9c, 0x30, 0x60, 0x84, 0x02, 0x23, 0x1c, 
0x28, 0xe1, 0x40, 0xc9, 0x07, 0x18, 0x21, 0x2e, 0x97, 0xf8, 0xa1, 0xe3, 
0xf9, 0x5b, 0x6d, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 
0xae, 0x42, 0x60, 0x82, 0x00, 
};
// BenchmarkDialog.cpp

#include "StdAfx.h"

#include "../../../../C/CpuArch.h"

#include "../../../Common/Defs.h"
#include "../../../Common/IntToString.h"
#include "../../../Common/MyException.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/StringToInt.h"

#include "../../../Windows/System.h"
#include "../../../Windows/Thread.h"

#include "../../Common/MethodProps.h"

#include "../FileManager/HelpUtils.h"

#include "../../MyVersion.h"

#include "BenchmarkDialog.h"

using namespace NWindows;

void GetCpuName(AString &s);

static LPCWSTR kHelpTopic = L"fm/benchmark.htm";

static const UINT_PTR kTimerID = 4;
static const UINT kTimerElapse = 1000;

#ifdef LANG
#include "../FileManager/LangUtils.h"
#endif

using namespace NWindows;

UString HResultToMessage(HRESULT errorCode);

#ifdef LANG
static const UInt32 kLangIDs[] =
{
  IDT_BENCH_DICTIONARY,
  IDT_BENCH_MEMORY,
  IDT_BENCH_NUM_THREADS,
  IDT_BENCH_SPEED,
  IDT_BENCH_RATING_LABEL,
  IDT_BENCH_USAGE_LABEL,
  IDT_BENCH_RPU_LABEL,
  IDG_BENCH_COMPRESSING,
  IDG_BENCH_DECOMPRESSING,
  IDG_BENCH_TOTAL_RATING,
  IDT_BENCH_CURRENT,
  IDT_BENCH_RESULTING,
  IDT_BENCH_ELAPSED,
  IDT_BENCH_PASSES,
  IDB_STOP,
  IDB_RESTART
};

static const UInt32 kLangIDs_Colon[] =
{
  IDT_BENCH_SIZE
};

#endif

static const LPCTSTR kProcessingString = TEXT("...");
static const LPCTSTR kMB = TEXT(" MB");
static const LPCTSTR kMIPS = TEXT(" MIPS");
static const LPCTSTR kKBs = TEXT(" KB/s");

static const unsigned kMinDicLogSize =
  #ifdef UNDER_CE
    20;
  #else
    21;
  #endif

static const UInt32 kMinDicSize = (1 << kMinDicLogSize);
static const UInt32 kMaxDicSize =
    #ifdef MY_CPU_64BIT
    (1 << 30);
    #else
    (1 << 27);
    #endif

bool CBenchmarkDialog::OnInit()
{
  #ifdef LANG
  LangSetWindowText(*this, IDD_BENCH);
  LangSetDlgItems(*this, kLangIDs, ARRAY_SIZE(kLangIDs));
  LangSetDlgItems_Colon(*this, kLangIDs_Colon, ARRAY_SIZE(kLangIDs_Colon));
  LangSetDlgItemText(*this, IDT_BENCH_CURRENT2, IDT_BENCH_CURRENT);
  LangSetDlgItemText(*this, IDT_BENCH_RESULTING2, IDT_BENCH_RESULTING);
  #endif

  Sync.Init();

#ifdef _WIN32
  if (TotalMode)
  {
    _consoleEdit.Attach(GetItem(IDE_BENCH2_EDIT));
    LOGFONT f;
    memset(&f, 0, sizeof(f));
    f.lfHeight = 14;
    f.lfWidth = 0;
    f.lfWeight = FW_DONTCARE;
    f.lfCharSet = DEFAULT_CHARSET;
    f.lfOutPrecision = OUT_DEFAULT_PRECIS;
    f.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    f.lfQuality = DEFAULT_QUALITY;

    f.lfPitchAndFamily = FIXED_PITCH;
    // MyStringCopy(f.lfFaceName, TEXT(""));
    // f.lfFaceName[0] = 0;
    _font.Create(&f);
    if (_font._font)
      _consoleEdit.SendMsg(WM_SETFONT, (WPARAM)_font._font, TRUE);
  }
#endif

  {
    TCHAR s[40];
    s[0] = '/';
    s[1] = ' ';
    ConvertUInt32ToString(NSystem::GetNumberOfProcessors(), s + 2);
    SetItemText(IDT_BENCH_HARDWARE_THREADS, s);
  }

  {
    UString s;
    {
      AString cpuName;
      GetCpuName(cpuName);
      s.SetFromAscii(cpuName);
      SetItemText(IDT_BENCH_CPU, s);
    }

    s.SetFromAscii("7-Zip " MY_VERSION " ["
        #ifdef MY_CPU_64BIT
          "64-bit"
        #elif defined MY_CPU_32BIT
          "32-bit"
        #endif
        "]");
    SetItemText(IDT_BENCH_VER, s);
  }


  UInt32 numCPUs = NSystem::GetNumberOfProcessors();
  if (numCPUs < 1)
    numCPUs = 1;
  numCPUs = MyMin(numCPUs, (UInt32)(1 << 8));

  if (Sync.NumThreads == (UInt32)(Int32)-1)
  {
    Sync.NumThreads = numCPUs;
    if (Sync.NumThreads > 1)
      Sync.NumThreads &= ~1;
  }
  m_NumThreads.Attach(GetItem(IDC_BENCH_NUM_THREADS));
  int cur = 0;
  for (UInt32 num = 1; num <= numCPUs * 2;)
  {
    TCHAR s[16];
    ConvertUInt32ToString(num, s);
    int index = (int)m_NumThreads.AddString(s);
    m_NumThreads.SetItemData(index, num);
    if (num <= Sync.NumThreads)
      cur = index;
    if (num > 1)
      num++;
    num++;
  }
  m_NumThreads.SetCurSel(cur);
  Sync.NumThreads = GetNumberOfThreads();

  m_Dictionary.Attach(GetItem(IDC_BENCH_DICTIONARY));
  cur = 0;
  
  UInt64 ramSize = (UInt64)(sizeof(size_t)) << 29;
  bool ramSize_Defined = NSystem::GetRamSize(ramSize);
  
  #ifdef UNDER_CE
  const UInt32 kNormalizedCeSize = (16 << 20);
  if (ramSize > kNormalizedCeSize && ramSize < (33 << 20))
    ramSize = kNormalizedCeSize;
  #endif

  if (Sync.DictionarySize == (UInt32)(Int32)-1)
  {
    unsigned dicSizeLog = 25;

    #ifdef UNDER_CE
    dicSizeLog = 20;
    #endif

    if (ramSize_Defined)
    for (; dicSizeLog > kBenchMinDicLogSize; dicSizeLog--)
      if (GetBenchMemoryUsage(Sync.NumThreads, ((UInt32)1 << dicSizeLog)) + (8 << 20) <= ramSize)
        break;
    Sync.DictionarySize = (1 << dicSizeLog);
  }
  
  if (Sync.DictionarySize < kMinDicSize) Sync.DictionarySize = kMinDicSize;
  if (Sync.DictionarySize > kMaxDicSize) Sync.DictionarySize = kMaxDicSize;

  for (unsigned i = kMinDicLogSize; i <= 30; i++)
    for (unsigned j = 0; j < 2; j++)
    {
      UInt32 dict = (1 << i) + (j << (i - 1));
      if (dict > kMaxDicSize)
        continue;
      TCHAR s[16];
      ConvertUInt32ToString((dict >> 20), s);
      lstrcat(s, kMB);
      int index = (int)m_Dictionary.AddString(s);
      m_Dictionary.SetItemData(index, dict);
      if (dict <= Sync.DictionarySize)
        cur = index;
    }
  m_Dictionary.SetCurSel(cur);

  OnChangeSettings();

  Sync._startEvent.Set();
  _timer = SetTimer(kTimerID, kTimerElapse);

  if (TotalMode)
    NormalizeSize(true);
  else
    NormalizePosition();
  return CModalDialog::OnInit();
}

#ifdef _WIN32
bool CBenchmarkDialog::OnSize(WPARAM /* wParam */, int xSize, int ySize)
{
  if (!TotalMode)
    return false;
  int mx, my;
  GetMargins(8, mx, my);
  int bx1, bx2, by;
  GetItemSizes(IDCANCEL, bx1, by);
  GetItemSizes(IDHELP, bx2, by);

  {
    int y = ySize - my - by;
    int x = xSize - mx - bx1;
    
    InvalidateRect(NULL);
    
    MoveItem(IDCANCEL, x, y, bx1, by);
    MoveItem(IDHELP, x - mx - bx2, y, bx2, by);
  }

  if (_consoleEdit)
  {
    int yPos = ySize - my - by;
    RECT rect;
    GetClientRectOfItem(IDE_BENCH2_EDIT, rect);
    int y = rect.top;
    int ySize2 = yPos - my - y;
    const int kMinYSize = 20;
    int xx = xSize - mx * 2;
    if (ySize2 < kMinYSize)
    {
      ySize2 = kMinYSize;
    }
    _consoleEdit.Move(mx, y, xx, ySize2);
  }
  return false;
}
#endif

UInt32 CBenchmarkDialog::GetNumberOfThreads()
{
  return (UInt32)m_NumThreads.GetItemData_of_CurSel();
}

UInt32 CBenchmarkDialog::OnChangeDictionary()
{
  UInt32 dict = (UInt32)m_Dictionary.GetItemData_of_CurSel();
  UInt64 memUsage = GetBenchMemoryUsage(GetNumberOfThreads(), dict);
  memUsage = (memUsage + (1 << 20) - 1) >> 20;
  TCHAR s[40];
  ConvertUInt64ToString(memUsage, s);
  lstrcat(s, kMB);
  SetItemText(IDT_BENCH_MEMORY_VAL, s);
  return dict;
}

static const UInt32 g_IDs[] =
{
  IDT_BENCH_COMPRESS_USAGE1,
  IDT_BENCH_COMPRESS_USAGE2,
  IDT_BENCH_COMPRESS_SPEED1,
  IDT_BENCH_COMPRESS_SPEED2,
  IDT_BENCH_COMPRESS_RATING1,
  IDT_BENCH_COMPRESS_RATING2,
  IDT_BENCH_COMPRESS_RPU1,
  IDT_BENCH_COMPRESS_RPU2,
  
  IDT_BENCH_DECOMPR_SPEED1,
  IDT_BENCH_DECOMPR_SPEED2,
  IDT_BENCH_DECOMPR_RATING1,
  IDT_BENCH_DECOMPR_RATING2,
  IDT_BENCH_DECOMPR_USAGE1,
  IDT_BENCH_DECOMPR_USAGE2,
  IDT_BENCH_DECOMPR_RPU1,
  IDT_BENCH_DECOMPR_RPU2,
  
  IDT_BENCH_TOTAL_USAGE_VAL,
  IDT_BENCH_TOTAL_RATING_VAL,
  IDT_BENCH_TOTAL_RPU_VAL
};
  
void CBenchmarkDialog::OnChangeSettings()
{
  EnableItem(IDB_STOP, true);
  UInt32 dict = OnChangeDictionary();
  
  for (int i = 0; i < ARRAY_SIZE(g_IDs); i++)
    SetItemText(g_IDs[i], kProcessingString);
  _startTime = GetTickCount();
  PrintTime();
  NWindows::NSynchronization::CCriticalSectionLock lock(Sync.CS);
  Sync.Init();
  Sync.DictionarySize = dict;
  Sync.Changed = true;
  Sync.NumThreads = GetNumberOfThreads();
}

void CBenchmarkDialog::OnRestartButton()
{
  OnChangeSettings();
}

void CBenchmarkDialog::OnStopButton()
{
  EnableItem(IDB_STOP, false);
  Sync.Pause();
}

void CBenchmarkDialog::OnHelp()
{
  ShowHelpWindow(NULL, kHelpTopic);
}

void CBenchmarkDialog::OnCancel()
{
  Sync.Stop();
  KillTimer(_timer);
  CModalDialog::OnCancel();
}

void GetTimeString(UInt64 timeValue, wchar_t *s);

void CBenchmarkDialog::PrintTime()
{
  UInt32 curTime = ::GetTickCount();
  UInt32 elapsedTime = (curTime - _startTime);
  UInt32 elapsedSec = elapsedTime / 1000;
  if (elapsedSec != 0 && Sync.WasPaused())
    return;
  WCHAR s[40];
  GetTimeString(elapsedSec, s);
  SetItemText(IDT_BENCH_ELAPSED_VAL, s);
}

void CBenchmarkDialog::PrintRating(UInt64 rating, UINT controlID)
{
  TCHAR s[40];
  ConvertUInt64ToString(rating / 1000000, s);
  lstrcat(s, kMIPS);
  SetItemText(controlID, s);
}

void CBenchmarkDialog::PrintUsage(UInt64 usage, UINT controlID)
{
  TCHAR s[40];
  ConvertUInt64ToString((usage + 5000) / 10000, s);
  lstrcat(s, TEXT("%"));
  SetItemText(controlID, s);
}

void CBenchmarkDialog::PrintResults(
    UInt32 dictionarySize,
    const CBenchInfo2 &info,
    UINT usageID, UINT speedID, UINT rpuID, UINT ratingID,
    bool decompressMode)
{
  if (info.GlobalTime == 0)
    return;

  TCHAR s[40];
  {
    UInt64 speed = info.UnpackSize * info.NumIterations * info.GlobalFreq / info.GlobalTime;
    ConvertUInt64ToString(speed / 1024, s);
    lstrcat(s, kKBs);
    SetItemText(speedID, s);
  }
  UInt64 rating;
  if (decompressMode)
    rating = info.GetDecompressRating();
  else
    rating = info.GetCompressRating(dictionarySize);

  PrintRating(rating, ratingID);
  PrintRating(info.GetRatingPerUsage(rating), rpuID);
  PrintUsage(info.GetUsage(), usageID);
}

bool CBenchmarkDialog::OnTimer(WPARAM /* timerID */, LPARAM /* callback */)
{
  bool printTime = true;
  if (TotalMode)
  {
    if (Sync.WasStopped())
      printTime = false;
  }
  if (printTime)
    PrintTime();
  NWindows::NSynchronization::CCriticalSectionLock lock(Sync.CS);

  if (TotalMode)
  {
    if (Sync.TextWasChanged)
    {
      _consoleEdit.SetText(GetSystemString(Sync.Text));
      Sync.TextWasChanged = false;
    }
    return true;
  }

  TCHAR s[40];
  ConvertUInt64ToString((Sync.ProcessedSize >> 20), s);
  lstrcat(s, kMB);
  SetItemText(IDT_BENCH_SIZE_VAL, s);

  ConvertUInt64ToString(Sync.NumPasses, s);
  SetItemText(IDT_BENCH_PASSES_VAL, s);

  /*
  if (Sync.FreqWasChanged)
  {
    SetItemText(IDT_BENCH_FREQ, Sync.Freq);
    Sync.FreqWasChanged  = false;
  }
  */

  {
    UInt32 dicSizeTemp = (UInt32)MyMax(Sync.ProcessedSize, UInt64(1) << 20);
    dicSizeTemp = MyMin(dicSizeTemp, Sync.DictionarySize),
    PrintResults(dicSizeTemp,
      Sync.CompressingInfoTemp,
      IDT_BENCH_COMPRESS_USAGE1,
      IDT_BENCH_COMPRESS_SPEED1,
      IDT_BENCH_COMPRESS_RPU1,
      IDT_BENCH_COMPRESS_RATING1);
  }

  {
    PrintResults(
      Sync.DictionarySize,
      Sync.CompressingInfo,
      IDT_BENCH_COMPRESS_USAGE2,
      IDT_BENCH_COMPRESS_SPEED2,
      IDT_BENCH_COMPRESS_RPU2,
      IDT_BENCH_COMPRESS_RATING2);
  }

  {
    PrintResults(
      Sync.DictionarySize,
      Sync.DecompressingInfoTemp,
      IDT_BENCH_DECOMPR_USAGE1,
      IDT_BENCH_DECOMPR_SPEED1,
      IDT_BENCH_DECOMPR_RPU1,
      IDT_BENCH_DECOMPR_RATING1,
      true);
  }
  {
    PrintResults(
      Sync.DictionarySize,
      Sync.DecompressingInfo,
      IDT_BENCH_DECOMPR_USAGE2,
      IDT_BENCH_DECOMPR_SPEED2,
      IDT_BENCH_DECOMPR_RPU2,
      IDT_BENCH_DECOMPR_RATING2,
      true);
    if (Sync.DecompressingInfo.GlobalTime > 0 &&
        Sync.CompressingInfo.GlobalTime > 0)
    {
      UInt64 comprRating = Sync.CompressingInfo.GetCompressRating(Sync.DictionarySize);
      UInt64 decomprRating = Sync.DecompressingInfo.GetDecompressRating();
      PrintRating((comprRating + decomprRating) / 2, IDT_BENCH_TOTAL_RATING_VAL);
      PrintRating((
          Sync.CompressingInfo.GetRatingPerUsage(comprRating) +
          Sync.DecompressingInfo.GetRatingPerUsage(decomprRating)) / 2, IDT_BENCH_TOTAL_RPU_VAL);
      PrintUsage(
        (Sync.CompressingInfo.GetUsage() +
         Sync.DecompressingInfo.GetUsage()) / 2, IDT_BENCH_TOTAL_USAGE_VAL);
    }
  }
  return true;
}

bool CBenchmarkDialog::OnCommand(int code, int itemID, LPARAM lParam)
{
  if (code == CBN_SELCHANGE &&
      (itemID == IDC_BENCH_DICTIONARY ||
       itemID == IDC_BENCH_NUM_THREADS))
  {
    OnChangeSettings();
    return true;
  }
  return CModalDialog::OnCommand(code, itemID, lParam);
}

bool CBenchmarkDialog::OnButtonClicked(int buttonID, HWND buttonHWND)
{
  switch (buttonID)
  {
    case IDB_RESTART:
      OnRestartButton();
      return true;
    case IDB_STOP:
      OnStopButton();
      return true;
  }
  return CModalDialog::OnButtonClicked(buttonID, buttonHWND);
}

struct CThreadBenchmark
{
  CBenchmarkDialog *BenchmarkDialog;
  DECL_EXTERNAL_CODECS_LOC_VARS2;
  // UInt32 dictionarySize;
  // UInt32 numThreads;

  HRESULT Process();
  HRESULT Result;
  static THREAD_FUNC_DECL MyThreadFunction(void *param)
  {
    ((CThreadBenchmark *)param)->Result = ((CThreadBenchmark *)param)->Process();
    return 0;
  }
};

struct CBenchCallback: public IBenchCallback
{
  UInt32 dictionarySize;
  CProgressSyncInfo *Sync;
  
  // void AddCpuFreq(UInt64 cpuFreq);
  HRESULT SetFreq(bool showFreq, UInt64 cpuFreq);
  HRESULT SetEncodeResult(const CBenchInfo &info, bool final);
  HRESULT SetDecodeResult(const CBenchInfo &info, bool final);
};

/*
void CBenchCallback::AddCpuFreq(UInt64 cpuFreq)
{
  NSynchronization::CCriticalSectionLock lock(Sync->CS);
  {
    wchar_t s[32];
    ConvertUInt64ToString(cpuFreq, s);
    Sync->Freq.Add_Space_if_NotEmpty();
    Sync->Freq += s;
    Sync->FreqWasChanged = true;
  }
}
*/

HRESULT CBenchCallback::SetFreq(bool /* showFreq */, UInt64 /* cpuFreq */)
{
  return S_OK;
}

HRESULT CBenchCallback::SetEncodeResult(const CBenchInfo &info, bool final)
{
  NSynchronization::CCriticalSectionLock lock(Sync->CS);
  if (Sync->Changed || Sync->Paused || Sync->Stopped)
    return E_ABORT;
  Sync->ProcessedSize = info.UnpackSize * info.NumIterations;
  if (final && Sync->CompressingInfo.GlobalTime == 0)
  {
    (CBenchInfo&)Sync->CompressingInfo = info;
    if (Sync->CompressingInfo.GlobalTime == 0)
      Sync->CompressingInfo.GlobalTime = 1;
  }
  else
    (CBenchInfo&)Sync->CompressingInfoTemp = info;

  return S_OK;
}

HRESULT CBenchCallback::SetDecodeResult(const CBenchInfo &info, bool final)
{
  NSynchronization::CCriticalSectionLock lock(Sync->CS);
  if (Sync->Changed || Sync->Paused || Sync->Stopped)
    return E_ABORT;
  CBenchInfo info2 = info;
  if (final && Sync->DecompressingInfo.GlobalTime == 0)
  {
    (CBenchInfo&)Sync->DecompressingInfo = info2;
    if (Sync->DecompressingInfo.GlobalTime == 0)
      Sync->DecompressingInfo.GlobalTime = 1;
  }
  else
    (CBenchInfo&)Sync->DecompressingInfoTemp = info2;
  return S_OK;
}

struct CBenchCallback2: public IBenchPrintCallback
{
  CProgressSyncInfo *Sync;

  void Print(const char *s);
  void NewLine();
  HRESULT CheckBreak();
};

void CBenchCallback2::Print(const char *s)
{
  NSynchronization::CCriticalSectionLock lock(Sync->CS);
  Sync->Text += s;
  Sync->TextWasChanged = true;
}

void CBenchCallback2::NewLine()
{
  Print("\xD\n");
}

HRESULT CBenchCallback2::CheckBreak()
{
  if (Sync->Changed || Sync->Paused || Sync->Stopped)
    return E_ABORT;
  return S_OK;
}


HRESULT CThreadBenchmark::Process()
{
  CProgressSyncInfo &sync = BenchmarkDialog->Sync;
  sync.WaitCreating();
  try
  {
    for (;;)
    {
      if (sync.WasStopped())
        return 0;
      if (sync.WasPaused())
      {
        Sleep(200);
        continue;
      }
      UInt32 dictionarySize;
      UInt32 numThreads;
      {
        NSynchronization::CCriticalSectionLock lock(sync.CS);
        if (sync.Stopped || sync.Paused)
          continue;
        if (sync.Changed)
          sync.Init();
        dictionarySize = sync.DictionarySize;
        numThreads = sync.NumThreads;
      }
      
      CBenchCallback callback;
      callback.dictionarySize = dictionarySize;
      callback.Sync = &sync;
      CBenchCallback2 callback2;
      callback2.Sync = &sync;
      HRESULT result;
     
      try
      {
        CObjectVector<CProperty> props;
        if (BenchmarkDialog->TotalMode)
        {
          props = BenchmarkDialog->Props;
        }
        else
        {
          {
            CProperty prop;
            prop.Name = L"mt";
            wchar_t s[16];
            ConvertUInt32ToString(numThreads, s);
            prop.Value = s;
            props.Add(prop);
          }
          {
            CProperty prop;
            prop.Name = L'd';
            wchar_t s[16];
            ConvertUInt32ToString(dictionarySize, s);
            prop.Name += s;
            prop.Name += L'b';
            props.Add(prop);
          }
        }
        result = Bench(EXTERNAL_CODECS_LOC_VARS
            BenchmarkDialog->TotalMode ? &callback2 : NULL,
            BenchmarkDialog->TotalMode ? NULL : &callback,
            props, 1, false);
        if (BenchmarkDialog->TotalMode)
        {
          sync.Stop();
        }
      }
      catch(...)
      {
        result = E_FAIL;
      }

      if (result != S_OK)
      {
        if (result != E_ABORT)
        {
          {
            NSynchronization::CCriticalSectionLock lock(sync.CS);
            sync.Pause();
          }
          UString message;
          if (result == S_FALSE)
            message = L"Decoding error";
          else if (result == CLASS_E_CLASSNOTAVAILABLE)
            message = L"Can't find 7z.dll";
          else
            message = HResultToMessage(result);
          BenchmarkDialog->MessageBoxError(message);
        }
      }
      else
      {
        NSynchronization::CCriticalSectionLock lock(sync.CS);
        sync.NumPasses++;
      }
    }
    // return S_OK;
  }
  catch(CSystemException &e)
  {
    BenchmarkDialog->MessageBoxError(HResultToMessage(e.ErrorCode));
    return E_FAIL;
  }
  catch(...)
  {
    BenchmarkDialog->MessageBoxError(HResultToMessage(E_FAIL));
    return E_FAIL;
  }
}

static void ParseNumberString(const UString &s, NCOM::CPropVariant &prop)
{
  const wchar_t *end;
  UInt64 result = ConvertStringToUInt64(s, &end);
  if (*end != 0 || s.IsEmpty())
    prop = s;
  else if (result <= (UInt32)0xFFFFFFFF)
    prop = (UInt32)result;
  else
    prop = result;
}

HRESULT Benchmark(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const CObjectVector<CProperty> props, HWND hwndParent)
{
  CThreadBenchmark benchmarker;
  #ifdef EXTERNAL_CODECS
  benchmarker.__externalCodecs = __externalCodecs;
  #endif

  CBenchmarkDialog bd;
  bd.Props = props;
  bd.TotalMode = false;
  bd.Sync.DictionarySize = (UInt32)(Int32)-1;
  bd.Sync.NumThreads = (UInt32)(Int32)-1;

  COneMethodInfo method;

  UInt32 numCPUs = 1;
  #ifndef _7ZIP_ST
  numCPUs = NSystem::GetNumberOfProcessors();
  #endif
  UInt32 numThreads = numCPUs;

  FOR_VECTOR (i, props)
  {
    const CProperty &prop = props[i];
    UString name = prop.Name;
    name.MakeLower_Ascii();
    if (name.IsEqualTo_Ascii_NoCase("m") && prop.Value == L"*")
    {
      bd.TotalMode = true;
      continue;
    }

    NCOM::CPropVariant propVariant;
    if (!prop.Value.IsEmpty())
      ParseNumberString(prop.Value, propVariant);
    if (name.IsPrefixedBy(L"mt"))
    {
      #ifndef _7ZIP_ST
      RINOK(ParseMtProp(name.Ptr(2), propVariant, numCPUs, numThreads));
      if (numThreads != numCPUs)
        bd.Sync.NumThreads = numThreads;
      #endif
      continue;
    }
    if (name.IsEqualTo("testtime"))
    {
      // UInt32 testTime = 4;
      // RINOK(ParsePropToUInt32(L"", propVariant, testTime));
      continue;
    }
    RINOK(method.ParseMethodFromPROPVARIANT(name, propVariant));
  }

  // bool totalBenchMode = (method.MethodName == L"*");

  {
    UInt32 dict;
    if (method.Get_DicSize(dict))
      bd.Sync.DictionarySize = dict;
  }

  benchmarker.BenchmarkDialog = &bd;

  NWindows::CThread thread;
  RINOK(thread.Create(CThreadBenchmark::MyThreadFunction, &benchmarker));
  bd.Create(hwndParent);
  return thread.Wait();
}
// BenchmarkDialog.h

#ifndef __BENCHMARK_DIALOG_H
#define __BENCHMARK_DIALOG_H

#include "../../../Windows/Synchronization.h"

#include "../../../Windows/Control/ComboBox.h"
#include "../../../Windows/Control/Edit.h"

#include "../Common/Bench.h"

#include "../FileManager/DialogSize.h"

#include "BenchmarkDialogRes.h"

struct CBenchInfo2 : public CBenchInfo
{
  void Init()  { GlobalTime = UserTime = 0; }

  UInt64 GetCompressRating(UInt32 dictSize) const
  {
    return ::GetCompressRating(dictSize, GlobalTime, GlobalFreq, UnpackSize * NumIterations);
  }

  UInt64 GetDecompressRating() const
  {
    return ::GetDecompressRating(GlobalTime, GlobalFreq, UnpackSize, PackSize, NumIterations);
  }
};

class CProgressSyncInfo
{
public:
  bool Stopped;
  bool Paused;
  bool Changed;
  UInt32 DictionarySize;
  UInt32 NumThreads;
  UInt64 NumPasses;
  NWindows::NSynchronization::CManualResetEvent _startEvent;
  NWindows::NSynchronization::CCriticalSection CS;

  CBenchInfo2 CompressingInfoTemp;
  CBenchInfo2 CompressingInfo;
  UInt64 ProcessedSize;

  CBenchInfo2 DecompressingInfoTemp;
  CBenchInfo2 DecompressingInfo;

  AString Text;
  bool TextWasChanged;

  // UString Freq;
  // bool FreqWasChanged;

  CProgressSyncInfo()
  {
    if (_startEvent.Create() != S_OK)
      throw 3986437;
  }
  
  void Init()
  {
    Changed = false;
    Stopped = false;
    Paused = false;
    CompressingInfoTemp.Init();
    CompressingInfo.Init();
    ProcessedSize = 0;
    
    DecompressingInfoTemp.Init();
    DecompressingInfo.Init();

    NumPasses = 0;

    // Freq.SetFromAscii("MHz: ");
    // FreqWasChanged = true;

    Text.Empty();
    TextWasChanged = true;
  }
  
  void Stop()
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(CS);
    Stopped = true;
  }
  bool WasStopped()
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(CS);
    return Stopped;
  }
  void Pause()
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(CS);
    Paused = true;
  }
  void Start()
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(CS);
    Paused = false;
  }
  bool WasPaused()
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(CS);
    return Paused;
  }
  void WaitCreating() { _startEvent.Lock(); }
};

#ifdef _WIN32
struct CMyFont
{
  HFONT _font;
  CMyFont(): _font(NULL) {}
  ~CMyFont()
  {
    if (_font)
      DeleteObject(_font);
  }
  void Create(const LOGFONT *lplf)
  {
    _font = CreateFontIndirect(lplf);
  }
};
#else
struct CMyFont
{
  CMyFont() {}
};
#endif


class CBenchmarkDialog:
  public NWindows::NControl::CModalDialog
{
  NWindows::NControl::CComboBox m_Dictionary;
  NWindows::NControl::CComboBox m_NumThreads;
  NWindows::NControl::CEdit _consoleEdit;
  UINT_PTR _timer;
  UInt32 _startTime;
  CMyFont _font;

  bool OnSize(WPARAM /* wParam */, int xSize, int ySize);
  bool OnTimer(WPARAM timerID, LPARAM callback);
  virtual bool OnInit();
  void OnRestartButton();
  void OnStopButton();
  void OnHelp();
  virtual void OnCancel();
  bool OnButtonClicked(int buttonID, HWND buttonHWND);
  bool OnCommand(int code, int itemID, LPARAM lParam);

  void PrintTime();
  void PrintRating(UInt64 rating, UINT controlID);
  void PrintUsage(UInt64 usage, UINT controlID);
  void PrintResults(
      UInt32 dictionarySize,
      const CBenchInfo2 &info, UINT usageID, UINT speedID, UINT rpuID, UINT ratingID,
      bool decompressMode = false);

  UInt32 GetNumberOfThreads();
  UInt32 OnChangeDictionary();
  void OnChangeSettings();
public:
  CProgressSyncInfo Sync;
  bool TotalMode;
  CObjectVector<CProperty> Props;

  CBenchmarkDialog(): _timer(0), TotalMode(false) {}
  INT_PTR Create(HWND wndParent = 0)
  {
    BIG_DIALOG_SIZE(332, 228);
    return CModalDialog::Create(TotalMode ? IDD_BENCH_TOTAL : SIZED_DIALOG(IDD_BENCH), wndParent);
  }
  void MessageBoxError(LPCWSTR message)
  {
    MessageBoxW(*this, message, L"7-Zip", MB_ICONERROR);
  }
};

HRESULT Benchmark(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const CObjectVector<CProperty> props, HWND hwndParent = NULL);

#endif
#define IDD_BENCH         7600
#define IDD_BENCH_2      17600
#define IDD_BENCH_TOTAL 7699

#define IDE_BENCH2_EDIT            100

#define IDC_BENCH_DICTIONARY       101
#define IDT_BENCH_MEMORY_VAL       102
#define IDC_BENCH_NUM_THREADS      103
#define IDT_BENCH_HARDWARE_THREADS 104

#define IDT_BENCH_VER              105
#define IDT_BENCH_CPU              106

#define IDT_BENCH_COMPRESS_SPEED1  110
#define IDT_BENCH_COMPRESS_SPEED2  111
#define IDT_BENCH_COMPRESS_RATING1 112
#define IDT_BENCH_COMPRESS_RATING2 113
#define IDT_BENCH_COMPRESS_USAGE1  114
#define IDT_BENCH_COMPRESS_USAGE2  115
#define IDT_BENCH_COMPRESS_RPU1    116
#define IDT_BENCH_COMPRESS_RPU2    117

#define IDT_BENCH_DECOMPR_SPEED1   118
#define IDT_BENCH_DECOMPR_SPEED2   119
#define IDT_BENCH_DECOMPR_RATING1  120
#define IDT_BENCH_DECOMPR_RATING2  121
#define IDT_BENCH_DECOMPR_USAGE1   122
#define IDT_BENCH_DECOMPR_USAGE2   123
#define IDT_BENCH_DECOMPR_RPU1     124
#define IDT_BENCH_DECOMPR_RPU2     125

#define IDT_BENCH_TOTAL_RATING_VAL 130
#define IDT_BENCH_TOTAL_RPU_VAL    131
#define IDT_BENCH_TOTAL_USAGE_VAL  133

#define IDT_BENCH_ELAPSED_VAL      140
#define IDT_BENCH_SIZE_VAL         141
#define IDT_BENCH_PASSES_VAL       142


#define IDB_STOP                 442
#define IDB_RESTART              443

#define IDT_BENCH_DICTIONARY    4006
#define IDT_BENCH_NUM_THREADS   4009

#define IDT_BENCH_SIZE          1007
#define IDT_BENCH_ELAPSED       3900
#define IDT_BENCH_SPEED         3903

#define IDT_BENCH_MEMORY        7601

#define IDG_BENCH_COMPRESSING   7602
#define IDG_BENCH_DECOMPRESSING 7603
#define IDG_BENCH_TOTAL_RATING  7605

#define IDT_BENCH_RATING_LABEL  7604
#define IDT_BENCH_CURRENT       7606
#define IDT_BENCH_RESULTING     7607
#define IDT_BENCH_USAGE_LABEL   7608
#define IDT_BENCH_RPU_LABEL     7609
#define IDT_BENCH_PASSES        7610
#define IDT_BENCH_CURRENT2     (7606+50)
#define IDT_BENCH_RESULTING2   (7607+50)
// BenchmarkDialog.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif  

#undef _WIN32

#include "Windows/Control/DialogImpl.h"
#include "BenchmarkDialogRes.h"

#if 0

IDD_BENCH  DIALOG  0, 0, xs, ys  MY_MODAL_DIALOG_STYLE | WS_MINIMIZEBOX
CAPTION "Benchmark"
MY_FONT
BEGIN
  PUSHBUTTON  "&Restart", IDB_RESTART, bx1, m, bxs, bys
  PUSHBUTTON  "&Stop",    IDB_STOP,    bx1, m + bys + 6, bxs, bys
  
  PUSHBUTTON  "&Help",  IDHELP,   bx2, by, bxs, bys
  PUSHBUTTON  "Cancel", IDCANCEL, bx1, by, bxs, bys
  
  LTEXT  "&Dictionary size:", IDT_BENCH_DICTIONARY, m, m + 1, g0xs, 8
  COMBOBOX  IDC_BENCH_DICTIONARY, g1x, m, g1xs, 140, MY_COMBO

  LTEXT  "Memory usage:", IDT_BENCH_MEMORY, gc2x, m + 1, gc2xs, 8
  LTEXT  "", IDT_BENCH_MEMORY_VAL, gc2x + gc2xs, m + 1, 40, 8

  LTEXT  "&Number of CPU threads:", IDT_BENCH_NUM_THREADS, m, 28, g0xs, 8
  COMBOBOX  IDC_BENCH_NUM_THREADS, g1x, 27, g1xs, 140, MY_COMBO
  LTEXT  "", IDT_BENCH_HARDWARE_THREADS, gc2x, 28, 40, 8

  RTEXT  "CPU Usage", IDT_BENCH_USAGE_LABEL,    xUsage,  54, sUsage,  8
  RTEXT  "Speed", IDT_BENCH_SPEED,              xSpeed,  54, sSpeed,  8
  RTEXT  "Rating / Usage", IDT_BENCH_RPU_LABEL, xRpu,    54, sRpu,    8
  RTEXT  "Rating", IDT_BENCH_RATING_LABEL,      xRating, 54, sRating, 8
  
  GROUPBOX  "Compressing", IDG_BENCH_COMPRESSING, m, 64, xc, GROUP_Y_SIZE
 
  LTEXT  "Current", IDT_BENCH_CURRENT,   g4x,      76, sLabel,  8
  RTEXT  "", IDT_BENCH_COMPRESS_USAGE1,  xUsage,   76, sUsage,  8
  RTEXT  "", IDT_BENCH_COMPRESS_SPEED1,  xSpeed,   76, sSpeed,  8
  RTEXT  "", IDT_BENCH_COMPRESS_RPU1,    xRpu,     76, sRpu,    8
  RTEXT  "", IDT_BENCH_COMPRESS_RATING1, xRating,  76, sRating, 8
  
  LTEXT  "Resulting", IDT_BENCH_RESULTING, g4x,    89, sLabel,  8
  RTEXT  "", IDT_BENCH_COMPRESS_USAGE2,  xUsage,   89, sUsage,  8
  RTEXT  "", IDT_BENCH_COMPRESS_SPEED2,  xSpeed,   89, sSpeed,  8
  RTEXT  "", IDT_BENCH_COMPRESS_RPU2,    xRpu,     89, sRpu,    8
  RTEXT  "", IDT_BENCH_COMPRESS_RATING2, xRating,  89, sRating, 8
  
  GROUPBOX  "Decompressing", IDG_BENCH_DECOMPRESSING, m, 111, xc, GROUP_Y_SIZE

  LTEXT  "Current", IDT_BENCH_CURRENT2,  g4x,     123, sLabel,  8
  RTEXT  "", IDT_BENCH_DECOMPR_USAGE1,   xUsage,  123, sUsage,  8
  RTEXT  "", IDT_BENCH_DECOMPR_SPEED1,   xSpeed,  123, sSpeed,  8
  RTEXT  "", IDT_BENCH_DECOMPR_RPU1,     xRpu,    123, sRpu,    8
  RTEXT  "", IDT_BENCH_DECOMPR_RATING1,  xRating, 123, sRating, 8
  
  LTEXT  "Resulting", IDT_BENCH_RESULTING2, g4x,  136, sLabel,  8
  RTEXT  "", IDT_BENCH_DECOMPR_USAGE2,   xUsage,  136, sUsage,  8
  RTEXT  "", IDT_BENCH_DECOMPR_SPEED2,   xSpeed,  136, sSpeed,  8
  RTEXT  "", IDT_BENCH_DECOMPR_RPU2,     xRpu,    136, sRpu,    8
  RTEXT  "", IDT_BENCH_DECOMPR_RATING2,  xRating, 136, sRating, 8
  
  GROUPBOX  "Total Rating", IDG_BENCH_TOTAL_RATING, xTotalRating, 163, sTotalRating, GROUP_Y2_SIZE

  RTEXT  "", IDT_BENCH_TOTAL_USAGE_VAL,  xUsage,  176, sUsage,  8
  RTEXT  "", IDT_BENCH_TOTAL_RPU_VAL,    xRpu,    176, sRpu,    8
  RTEXT  "", IDT_BENCH_TOTAL_RATING_VAL, xRating, 176, sRating, 8

  RTEXT  "", IDT_BENCH_CPU, m, 202, xc, 8
  RTEXT  "", IDT_BENCH_VER, m, 216, xc, 8
  
  LTEXT  "Elapsed time:", IDT_BENCH_ELAPSED, m, 163, g2xs, 8
  LTEXT  "Size:", IDT_BENCH_SIZE,            m, 176, g2xs, 8
  LTEXT  "Passes:", IDT_BENCH_PASSES,        m, 189, g2xs, 8

  RTEXT  "", IDT_BENCH_ELAPSED_VAL,        g3x, 163, g3xs, 8
  RTEXT  "", IDT_BENCH_SIZE_VAL,           g3x, 176, g3xs, 8
  RTEXT  "", IDT_BENCH_PASSES_VAL,         g3x, 189, g3xs, 8
END
#endif // #if 0

class CBenchmarkDialogImpl : public NWindows::NControl::CModalDialogImpl
{
  public:
   CBenchmarkDialogImpl(NWindows::NControl::CModalDialog *dialog,wxWindow * parent , int id) : CModalDialogImpl(dialog,parent, id, wxT("Benchmark"))
  {

	wxSizer *topsizer = new wxBoxSizer(wxVERTICAL);

	wxSizer *sizerLine1 = new wxBoxSizer(wxHORIZONTAL);

	wxSizer *sizeLine1Btn = new wxBoxSizer(wxVERTICAL);
	sizeLine1Btn->Add(new wxButton(this, IDB_RESTART, _T("&Restart")) , 0, wxALL|wxEXPAND, 5 );
	sizeLine1Btn->Add(new wxButton(this, IDB_STOP, _T("&Stop")) , 0, wxALL|wxEXPAND, 5 );

	wxSizer *sizeLine1Combo = new wxBoxSizer(wxVERTICAL);

	wxComboBox * chcDicoSize = new wxComboBox(this, IDC_BENCH_DICTIONARY,
		 wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);

	wxComboBox * chcThread = new wxComboBox(this, IDC_BENCH_NUM_THREADS,
		 wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);

	sizeLine1Combo->Add(chcDicoSize , 0, wxALL, 5 );
	sizeLine1Combo->Add(chcThread , 0, wxALL, 5 );

	wxSizer *sizeLine1ComboLabel = new wxBoxSizer(wxVERTICAL);
	sizeLine1ComboLabel->Add(new wxStaticText(this, IDT_BENCH_DICTIONARY, _T("&Dictionary size:")) , 1, wxALL|wxEXPAND, 5 );
	sizeLine1ComboLabel->Add(new wxStaticText(this, IDT_BENCH_MEMORY, _T("&Number of CPU threads:")) , 1, wxALL|wxEXPAND, 5 );

	wxSizer *sizeLine1Col3 = new wxBoxSizer(wxVERTICAL);
	sizeLine1Col3->Add(new wxStaticText(this, IDT_BENCH_MEMORY, _T("Memory usage:")) , 1, wxALL|wxEXPAND, 5 );
	// FIXME sizeLine1Col3->Add(new wxStaticText(this, IDC_BENCHMARK_HARDWARE_THREADS, _T("1")) , 1, wxALL|wxEXPAND, 5 );

	wxSizer *sizeLine1Col4 = new wxBoxSizer(wxVERTICAL);
	sizeLine1Col4->Add(new wxStaticText(this, IDT_BENCH_MEMORY_VAL, _T("0 MB")) , 0, wxALL|wxEXPAND, 5 );

	sizerLine1->Add(sizeLine1ComboLabel,0, wxALL|wxEXPAND, 5);
	sizerLine1->Add(sizeLine1Combo,0, wxALL|wxEXPAND, 5);
	sizerLine1->Add(sizeLine1Col3,0, wxALL|wxEXPAND, 5);
	sizerLine1->Add(sizeLine1Col4,0, wxALL|wxEXPAND, 5);
	sizerLine1->Add(sizeLine1Btn,0, wxALL|wxEXPAND, 5);

	// LABEL (copy the structure of the compressing or decompressing group

	wxStaticBoxSizer * sizerLine2 = new wxStaticBoxSizer(new wxStaticBox(this,wxID_ANY,_T("")),wxVERTICAL);
	wxSizer *sizerLabel = new wxBoxSizer(wxHORIZONTAL);
	sizerLabel->Add(new wxStaticText(this, wxID_ANY, _T(" ")) , 1, wxALL|wxEXPAND, 5 );
	sizerLabel->Add(new wxStaticText(this, IDT_BENCH_SPEED, _T("Speed")) , 1, wxALL|wxEXPAND, 5 );
	sizerLabel->Add(new wxStaticText(this, IDT_BENCH_USAGE_LABEL, _T("CPU Usage")) , 1, wxALL|wxEXPAND, 5 );
	sizerLabel->Add(new wxStaticText(this, IDT_BENCH_RPU_LABEL, _T("Rating / Usage")), 1, wxALL|wxEXPAND, 5 );
	sizerLabel->Add(new wxStaticText(this, IDT_BENCH_RATING_LABEL, _T("Rating")) , 1, wxALL|wxEXPAND, 5 );

	sizerLine2->Add(sizerLabel, 0, wxALL|wxEXPAND, 5);

	// GROUP COMPRESSING

	wxStaticBoxSizer * grpCompress = new wxStaticBoxSizer(new wxStaticBox(this,IDG_BENCH_COMPRESSING,_T("Compressing")),wxVERTICAL);
	wxSizer *grpCompress1 = new wxBoxSizer(wxHORIZONTAL);
	grpCompress1->Add(new wxStaticText(this, IDT_BENCH_CURRENT, _T("Current")) , 1, wxALL|wxEXPAND, 5 );
	grpCompress1->Add(new wxStaticText(this, IDT_BENCH_COMPRESS_SPEED1, _T("100 KB/s")) , 1, wxALL|wxEXPAND, 5 );
	grpCompress1->Add(new wxStaticText(this, IDT_BENCH_COMPRESS_USAGE1, _T("100%")) , 1, wxALL|wxEXPAND, 5 );
	grpCompress1->Add(new wxStaticText(this, IDT_BENCH_COMPRESS_RPU1, _T("0")), 1, wxALL|wxEXPAND, 5 );
	grpCompress1->Add(new wxStaticText(this, IDT_BENCH_COMPRESS_RATING1, _T("0")) , 1, wxALL|wxEXPAND, 5 );

	wxSizer *grpCompress2 = new wxBoxSizer(wxHORIZONTAL);
	grpCompress2->Add(new wxStaticText(this, IDT_BENCH_RESULTING, _T("Resulting")) , 1, wxALL|wxEXPAND, 5 );
	grpCompress2->Add(new wxStaticText(this, IDT_BENCH_COMPRESS_SPEED2, _T("100 KB/s")) , 1, wxALL|wxEXPAND, 5 );
	grpCompress2->Add(new wxStaticText(this, IDT_BENCH_COMPRESS_USAGE2, _T("100%")) , 1, wxALL|wxEXPAND, 5 );
	grpCompress2->Add(new wxStaticText(this, IDT_BENCH_COMPRESS_RPU2, _T("0")) , 1, wxALL|wxEXPAND, 5);
	grpCompress2->Add(new wxStaticText(this, IDT_BENCH_COMPRESS_RATING2, _T("0")) , 1, wxALL|wxEXPAND, 5 );

	grpCompress->Add(grpCompress1, 0, wxALL|wxEXPAND, 5);
	grpCompress->Add(grpCompress2, 0, wxALL|wxEXPAND, 5);

	// GROUP DECOMPRESSING

	wxStaticBoxSizer * grpDecompress = new wxStaticBoxSizer(new wxStaticBox(this,IDG_BENCH_DECOMPRESSING,_T("Decompressing")),wxVERTICAL);
	wxSizer *grpDecompress1 = new wxBoxSizer(wxHORIZONTAL);
	grpDecompress1->Add(new wxStaticText(this, IDT_BENCH_CURRENT2, _T("Current")) , 1, wxALL|wxEXPAND, 5 );
	grpDecompress1->Add(new wxStaticText(this, IDT_BENCH_DECOMPR_SPEED1, _T("100 KB/s")) , 1, wxALL|wxEXPAND, 5 );
	grpDecompress1->Add(new wxStaticText(this, IDT_BENCH_DECOMPR_USAGE1, _T("100%")) , 1, wxALL|wxEXPAND, 5 );
	grpDecompress1->Add(new wxStaticText(this, IDT_BENCH_DECOMPR_RPU1, _T("0")), 1, wxALL|wxEXPAND, 5 );
	grpDecompress1->Add(new wxStaticText(this, IDT_BENCH_DECOMPR_RATING1, _T("0")) , 1, wxALL|wxEXPAND, 5 );

	wxSizer *grpDecompress2 = new wxBoxSizer(wxHORIZONTAL);
	grpDecompress2->Add(new wxStaticText(this, IDT_BENCH_RESULTING2, _T("Resulting")) , 1, wxALL|wxEXPAND, 5 );
	grpDecompress2->Add(new wxStaticText(this, IDT_BENCH_DECOMPR_SPEED2, _T("100 KB/s")) , 1, wxALL|wxEXPAND, 5 );
	grpDecompress2->Add(new wxStaticText(this, IDT_BENCH_DECOMPR_USAGE2, _T("100%")) , 1, wxALL|wxEXPAND, 5 );
	grpDecompress2->Add(new wxStaticText(this, IDT_BENCH_DECOMPR_RPU2, _T("0")) , 1, wxALL|wxEXPAND, 5);
	grpDecompress2->Add(new wxStaticText(this, IDT_BENCH_DECOMPR_RATING2, _T("0")) , 1, wxALL|wxEXPAND, 5 );

	grpDecompress->Add(grpDecompress1, 0, wxALL|wxEXPAND, 5);
	grpDecompress->Add(grpDecompress2, 0, wxALL|wxEXPAND, 5);

	// GROUPE TOTAL RATING
	wxStaticBoxSizer * grpTotalRating = new wxStaticBoxSizer(new wxStaticBox(this,IDG_BENCH_TOTAL_RATING,_T("Total Rating")),wxHORIZONTAL);
	grpTotalRating->Add(new wxStaticText(this, wxID_ANY, _T("")) , 1, wxALL|wxEXPAND, 5 );
	grpTotalRating->Add(new wxStaticText(this, IDT_BENCH_TOTAL_USAGE_VAL, _T("0")) , 1, wxALL|wxEXPAND, 5 );
	grpTotalRating->Add(new wxStaticText(this, IDT_BENCH_TOTAL_RPU_VAL, _T("0")) , 1, wxALL|wxEXPAND, 5 );
	grpTotalRating->Add(new wxStaticText(this, IDT_BENCH_TOTAL_RATING_VAL, _T("0")) , 1, wxALL|wxEXPAND, 5 );

	// GROUPE ELAPSED TIME
	wxSizer * grpElapsedTime = new wxBoxSizer(wxHORIZONTAL);

	wxSizer * grpElapsedTime1 = new wxBoxSizer(wxVERTICAL);
	grpElapsedTime1->Add(new wxStaticText(this, IDT_BENCH_ELAPSED, _T("Elapsed time:")) , 0, wxALL|wxEXPAND, 5 );
	grpElapsedTime1->Add(new wxStaticText(this, IDT_BENCH_SIZE, _T("Size:")) , 0, wxALL|wxEXPAND, 5 );
	grpElapsedTime1->Add(new wxStaticText(this, IDT_BENCH_PASSES, _T("Passes:")) , 0, wxALL|wxEXPAND, 5 );

	wxSizer * grpElapsedTime2 = new wxBoxSizer(wxVERTICAL);
	grpElapsedTime2->Add(new wxStaticText(this, IDT_BENCH_ELAPSED_VAL, _T("00:00:00")) , 0, wxALL|wxEXPAND, 5 );
	grpElapsedTime2->Add(new wxStaticText(this, IDT_BENCH_SIZE_VAL, _T("0")) , 0, wxALL|wxEXPAND, 5 );
	grpElapsedTime2->Add(new wxStaticText(this, IDT_BENCH_PASSES_VAL, _T("0")) , 0, wxALL|wxEXPAND, 5 );

	grpElapsedTime->Add(grpElapsedTime1,0, wxALL|wxEXPAND, 5);
	grpElapsedTime->Add(grpElapsedTime2,0, wxALL|wxEXPAND, 5);

	wxSizer * grp_ElapsedTime_TotalRating = new wxBoxSizer(wxHORIZONTAL);
	grp_ElapsedTime_TotalRating->Add(grpElapsedTime, 0, wxALL|wxEXPAND, 5);
	grp_ElapsedTime_TotalRating->Add(grpTotalRating, 1, wxALL|wxEXPAND, 5);

	// TOP
	topsizer->Add(sizerLine1,0, wxALL|wxEXPAND, 5);
	topsizer->Add(sizerLine2,0, wxALL|wxEXPAND, 5);
	topsizer->Add(grpCompress, 0, wxALL|wxEXPAND, 5);
	topsizer->Add(grpDecompress, 0, wxALL|wxEXPAND, 5);
	topsizer->Add(grp_ElapsedTime_TotalRating, 0, wxALL|wxEXPAND, 5);

	topsizer->Add(new wxStaticText(this, IDT_BENCH_CPU, _T("")) , 0,  wxALL|wxALIGN_RIGHT, 5 );
	topsizer->Add(new wxStaticText(this, IDT_BENCH_VER, _T("")) , 0,  wxALL|wxALIGN_RIGHT, 5 );

	topsizer->Add(CreateButtonSizer(wxHELP|wxCANCEL), 0, wxALL|wxEXPAND, 5);

	this->OnInit();

	SetSizer(topsizer); // use the sizer for layout
	topsizer->SetSizeHints(this); // set size hints to honour minimum size
  }
private:
	// Any class wishing to process wxWindows events must use this macro
	DECLARE_EVENT_TABLE()
};

REGISTER_DIALOG(IDD_BENCH,CBenchmarkDialog,0)

// ----------------------------------------------------------------------------
// event tables and other macros for wxWidgets
// ----------------------------------------------------------------------------

// the event tables connect the wxWidgets events with the functions (event
// handlers) which process them. It can be also done at run-time, but for the
// simple menu events like this the static method is much simpler.
BEGIN_EVENT_TABLE(CBenchmarkDialogImpl, wxDialog)
	EVT_TIMER(wxID_ANY, CModalDialogImpl::OnAnyTimer)
	EVT_BUTTON(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_COMBOBOX(wxID_ANY,    CModalDialogImpl::OnAnyChoice)
	EVT_MENU(WORKER_EVENT, CModalDialogImpl::OnWorkerEvent)
END_EVENT_TABLE()

// CompressDialog.cpp

#include "StdAfx.h"

#include "../../../../C/CpuArch.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/FileDir.h"
#include "../../../Windows/FileName.h"
#include "../../../Windows/System.h"

#include "../FileManager/BrowseDialog.h"
#include "../FileManager/FormatUtils.h"
#include "../FileManager/HelpUtils.h"
#include "../FileManager/SplitUtils.h"

#include "../Explorer/MyMessages.h"

#include "../Common/ZipRegistry.h"

#include "CompressDialog.h"

#ifndef _UNICODE
extern bool g_IsNT;
#endif

#ifdef LANG
#include "../FileManager/LangUtils.h"
#endif

#include "CompressDialogRes.h"
#include "ExtractRes.h"

#ifdef LANG
static const UInt32 kLangIDs[] =
{
  IDT_COMPRESS_ARCHIVE,
  IDT_COMPRESS_UPDATE_MODE,
  IDT_COMPRESS_FORMAT,
  IDT_COMPRESS_LEVEL,
  IDT_COMPRESS_METHOD,
  IDT_COMPRESS_DICTIONARY,
  IDT_COMPRESS_ORDER,
  IDT_COMPRESS_SOLID,
  IDT_COMPRESS_THREADS,
  IDT_COMPRESS_PARAMETERS,
  
  IDG_COMPRESS_OPTIONS,
  IDX_COMPRESS_SFX,
  IDX_COMPRESS_SHARED,
  IDX_COMPRESS_DEL,

  IDT_COMPRESS_MEMORY,
  IDT_COMPRESS_MEMORY_DE,

  IDX_COMPRESS_NT_SYM_LINKS,
  IDX_COMPRESS_NT_HARD_LINKS,
  IDX_COMPRESS_NT_ALT_STREAMS,
  IDX_COMPRESS_NT_SECUR,

  IDG_COMPRESS_ENCRYPTION,
  IDT_COMPRESS_ENCRYPTION_METHOD,
  IDX_COMPRESS_ENCRYPT_FILE_NAMES,

  IDT_PASSWORD_ENTER,
  IDT_PASSWORD_REENTER,
  IDX_PASSWORD_SHOW,

  IDT_SPLIT_TO_VOLUMES,
  IDT_COMPRESS_PATH_MODE
};
#endif

using namespace NWindows;
using namespace NFile;
using namespace NName;
using namespace NDir;

static const unsigned kHistorySize = 20;

static LPCWSTR kExeExt = L".exe";
static LPCWSTR k7zFormat = L"7z";

static const UInt32 g_Levels[] =
{
  IDS_METHOD_STORE,
  IDS_METHOD_FASTEST,
  0,
  IDS_METHOD_FAST,
  0,
  IDS_METHOD_NORMAL,
  0,
  IDS_METHOD_MAXIMUM,
  0,
  IDS_METHOD_ULTRA
};

enum EMethodID
{
  kCopy,
  kLZMA,
  kLZMA2,
  kPPMd,
  kBZip2,
  kDeflate,
  kDeflate64,
  kPPMdZip
};

static const LPCWSTR kMethodsNames[] =
{
  L"Copy",
  L"LZMA",
  L"LZMA2",
  L"PPMd",
  L"BZip2",
  L"Deflate",
  L"Deflate64",
  L"PPMd"
};

static const EMethodID g_7zMethods[] =
{
  kLZMA2,
  kLZMA,
  kPPMd,
  kBZip2
};

static const EMethodID g_7zSfxMethods[] =
{
  kCopy,
  kLZMA,
  kLZMA2,
  kPPMd
};

static const EMethodID g_ZipMethods[] =
{
  kDeflate,
  kDeflate64,
  kBZip2,
  kLZMA,
  kPPMdZip
};

static const EMethodID g_GZipMethods[] =
{
  kDeflate
};

static const EMethodID g_BZip2Methods[] =
{
  kBZip2
};

static const EMethodID g_XzMethods[] =
{
  kLZMA2
};

static const EMethodID g_SwfcMethods[] =
{
  kDeflate
  // kLZMA
};

struct CFormatInfo
{
  LPCWSTR Name;
  UInt32 LevelsMask;
  const EMethodID *MathodIDs;
  unsigned NumMethods;
  bool Filter;
  bool Solid;
  bool MultiThread;
  bool SFX;
  
  bool Encrypt;
  bool EncryptFileNames;
};

#define METHODS_PAIR(x) x, ARRAY_SIZE(x)

static const CFormatInfo g_Formats[] =
{
  {
    L"",
    (1 << 0) | (1 << 1) | (1 << 3) | (1 << 5) | (1 << 7) | (1 << 9),
    0, 0,
    false, false, false, false, false, false
  },
  {
    k7zFormat,
    (1 << 0) | (1 << 1) | (1 << 3) | (1 << 5) | (1 << 7) | (1 << 9),
    METHODS_PAIR(g_7zMethods),
    true, true, true, true, true, true
  },
  {
    L"Zip",
    (1 << 0) | (1 << 1) | (1 << 3) | (1 << 5) | (1 << 7) | (1 << 9),
    METHODS_PAIR(g_ZipMethods),
    false, false, true, false, true, false
  },
  {
    L"GZip",
    (1 << 1) | (1 << 5) | (1 << 7) | (1 << 9),
    METHODS_PAIR(g_GZipMethods),
    false, false, false, false, false, false
  },
  {
    L"BZip2",
    (1 << 1) | (1 << 3) | (1 << 5) | (1 << 7) | (1 << 9),
    METHODS_PAIR(g_BZip2Methods),
    false, false, true, false, false, false
  },
  {
    L"xz",
    (1 << 1) | (1 << 3) | (1 << 5) | (1 << 7) | (1 << 9),
    METHODS_PAIR(g_XzMethods),
    false, false, true, false, false, false
  },
  {
    L"Swfc",
    (1 << 1) | (1 << 3) | (1 << 5) | (1 << 7) | (1 << 9),
    METHODS_PAIR(g_SwfcMethods),
    false, false, true, false, false, false
  },
  {
    L"Tar",
    (1 << 0),
    0, 0,
    false, false, false, false, false, false
  },
  {
    L"wim",
    (1 << 0),
    0, 0,
    false, false, false, false, false, false
  }
};

static bool IsMethodSupportedBySfx(int methodID)
{
  for (int i = 0; i < ARRAY_SIZE(g_7zSfxMethods); i++)
    if (methodID == g_7zSfxMethods[i])
      return true;
  return false;
}

static bool GetMaxRamSizeForProgram(UInt64 &physSize)
{
  physSize = (UInt64)(sizeof(size_t)) << 29;
  bool ramSize_Defined = NSystem::GetRamSize(physSize);
  const UInt64 kMinSysSize = (1 << 24);
  if (physSize <= kMinSysSize)
    physSize = 0;
  else
    physSize -= kMinSysSize;
  const UInt64 kMinUseSize = (1 << 24);
  if (physSize < kMinUseSize)
    physSize = kMinUseSize;
  return ramSize_Defined;
}


static const
  // NCompressDialog::NUpdateMode::EEnum
  int
  k_UpdateMode_Vals[] =
{
  NCompressDialog::NUpdateMode::kAdd,
  NCompressDialog::NUpdateMode::kUpdate,
  NCompressDialog::NUpdateMode::kFresh,
  NCompressDialog::NUpdateMode::kSync
};
  
static const UInt32 k_UpdateMode_IDs[] =
{
  IDS_COMPRESS_UPDATE_MODE_ADD,
  IDS_COMPRESS_UPDATE_MODE_UPDATE,
  IDS_COMPRESS_UPDATE_MODE_FRESH,
  IDS_COMPRESS_UPDATE_MODE_SYNC
};

static const
  // NWildcard::ECensorPathMode
  int
  k_PathMode_Vals[] =
{
  NWildcard::k_RelatPath,
  NWildcard::k_FullPath,
  NWildcard::k_AbsPath,
};

static const UInt32 k_PathMode_IDs[] =
{
  IDS_PATH_MODE_RELAT,
  IDS_EXTRACT_PATHS_FULL,
  IDS_EXTRACT_PATHS_ABS
};

void AddComboItems(NControl::CComboBox &combo, const UInt32 *langIDs, unsigned numItems, const int *values, int curVal);
bool GetBoolsVal(const CBoolPair &b1, const CBoolPair &b2);

void CCompressDialog::CheckButton_TwoBools(UINT id, const CBoolPair &b1, const CBoolPair &b2)
{
  CheckButton(id, GetBoolsVal(b1, b2));
}

void CCompressDialog::GetButton_Bools(UINT id, CBoolPair &b1, CBoolPair &b2)
{
  bool val = IsButtonCheckedBool(id);
  bool oldVal = GetBoolsVal(b1, b2);
  if (val != oldVal)
    b1.Def = b2.Def = true;
  b1.Val = b2.Val = val;
}

                                            
bool CCompressDialog::OnInit()
{
  #ifdef LANG
  LangSetWindowText(*this, IDD_COMPRESS);
  LangSetDlgItems(*this, kLangIDs, ARRAY_SIZE(kLangIDs));
  #endif

  _password1Control.Attach(GetItem(IDE_COMPRESS_PASSWORD1));
  _password2Control.Attach(GetItem(IDE_COMPRESS_PASSWORD2));
  _password1Control.SetText(Info.Password);
  _password2Control.SetText(Info.Password);
  _encryptionMethod.Attach(GetItem(IDC_COMPRESS_ENCRYPTION_METHOD));

  m_ArchivePath.Attach(GetItem(IDC_COMPRESS_ARCHIVE));
  m_Format.Attach(GetItem(IDC_COMPRESS_FORMAT));
  m_Level.Attach(GetItem(IDC_COMPRESS_LEVEL));
  m_Method.Attach(GetItem(IDC_COMPRESS_METHOD));
  m_Dictionary.Attach(GetItem(IDC_COMPRESS_DICTIONARY));
  m_Order.Attach(GetItem(IDC_COMPRESS_ORDER));
  m_Solid.Attach(GetItem(IDC_COMPRESS_SOLID));
  m_NumThreads.Attach(GetItem(IDC_COMPRESS_THREADS));
  
  m_UpdateMode.Attach(GetItem(IDC_COMPRESS_UPDATE_MODE));
  m_PathMode.Attach(GetItem(IDC_COMPRESS_PATH_MODE));

  m_Volume.Attach(GetItem(IDC_COMPRESS_VOLUME));
  m_Params.Attach(GetItem(IDE_COMPRESS_PARAMETERS));

  AddVolumeItems(m_Volume);

  m_RegistryInfo.Load();
  CheckButton(IDX_PASSWORD_SHOW, m_RegistryInfo.ShowPassword);
  CheckButton(IDX_COMPRESS_ENCRYPT_FILE_NAMES, m_RegistryInfo.EncryptHeaders);
  
  CheckButton_TwoBools(IDX_COMPRESS_NT_SYM_LINKS,   Info.SymLinks,   m_RegistryInfo.SymLinks);
  CheckButton_TwoBools(IDX_COMPRESS_NT_HARD_LINKS,  Info.HardLinks,  m_RegistryInfo.HardLinks);
  CheckButton_TwoBools(IDX_COMPRESS_NT_ALT_STREAMS, Info.AltStreams, m_RegistryInfo.AltStreams);
  CheckButton_TwoBools(IDX_COMPRESS_NT_SECUR,       Info.NtSecurity, m_RegistryInfo.NtSecurity);

  UpdatePasswordControl();

  {
    bool needSetMain = (Info.FormatIndex < 0);
    FOR_VECTOR(i, ArcIndices)
    {
      unsigned arcIndex = ArcIndices[i];
      const CArcInfoEx &ai = (*ArcFormats)[arcIndex];
      int index = (int)m_Format.AddString(ai.Name);
      m_Format.SetItemData(index, arcIndex);
      if (!needSetMain)
      {
        if (Info.FormatIndex == (int)arcIndex)
          m_Format.SetCurSel(index);
        continue;
      }
      if (i == 0 || ai.Name.IsEqualTo_NoCase(m_RegistryInfo.ArcType))
      {
        m_Format.SetCurSel(index);
        Info.FormatIndex = arcIndex;
      }
    }
  }

  {
    UString fileName;
    SetArcPathFields(Info.ArcPath, fileName, true);
    StartDirPrefix = DirPrefix;
    SetArchiveName(fileName);
  }
  SetLevel();
  SetParams();
  
  for (unsigned i = 0; i < m_RegistryInfo.ArcPaths.Size() && i < kHistorySize; i++)
    m_ArchivePath.AddString(m_RegistryInfo.ArcPaths[i]);

  AddComboItems(m_UpdateMode, k_UpdateMode_IDs, ARRAY_SIZE(k_UpdateMode_IDs),
      k_UpdateMode_Vals, Info.UpdateMode);

  AddComboItems(m_PathMode, k_PathMode_IDs, ARRAY_SIZE(k_PathMode_IDs),
      k_PathMode_Vals, Info.PathMode);

  SetSolidBlockSize();
  SetNumThreads();

  TCHAR s[40] = { TEXT('/'), TEXT(' '), 0 };
  ConvertUInt32ToString(NSystem::GetNumberOfProcessors(), s + 2);
  SetItemText(IDT_COMPRESS_HARDWARE_THREADS, s);

  CheckButton(IDX_COMPRESS_SFX, Info.SFXMode);
  CheckButton(IDX_COMPRESS_SHARED, Info.OpenShareForWrite);
  CheckButton(IDX_COMPRESS_DEL, Info.DeleteAfterCompressing);

  CheckControlsEnable();

  // OnButtonSFX();

  SetEncryptionMethod();
  SetMemoryUsage();

  NormalizePosition();

  return CModalDialog::OnInit();
}

/*
namespace NCompressDialog
{
  bool CInfo::GetFullPathName(UString &result) const
  {
    #ifndef UNDER_CE
    // NDirectory::MySetCurrentDirectory(CurrentDirPrefix);
    #endif
    FString resultF;
    bool res = MyGetFullPathName(us2fs(ArchiveName), resultF);
    result = fs2us(resultF);
    return res;
  }
}
*/

void CCompressDialog::UpdatePasswordControl()
{
  bool showPassword = IsShowPasswordChecked();
  TCHAR c = showPassword ? (TCHAR)0: TEXT('*');
  _password1Control.SetPasswordChar(c);
  _password2Control.SetPasswordChar(c);
  UString password;
  _password1Control.GetText(password);
  _password1Control.SetText(password);
  _password2Control.GetText(password);
  _password2Control.SetText(password);

  ShowItem_Bool(IDT_PASSWORD_REENTER, !showPassword);
  _password2Control.Show_Bool(!showPassword);
}

bool CCompressDialog::OnButtonClicked(int buttonID, HWND buttonHWND)
{
  switch (buttonID)
  {
    case IDB_COMPRESS_SET_ARCHIVE:
    {
      OnButtonSetArchive();
      return true;
    }
    case IDX_COMPRESS_SFX:
    {
      SetMethod(GetMethodID());
      OnButtonSFX();
      SetMemoryUsage();
      return true;
    }
    case IDX_PASSWORD_SHOW:
    {
      UpdatePasswordControl();
      return true;
    }
  }
  return CModalDialog::OnButtonClicked(buttonID, buttonHWND);
}

void CCompressDialog::CheckSFXControlsEnable()
{
  const CFormatInfo &fi = g_Formats[GetStaticFormatIndex()];
  bool enable = fi.SFX;
  if (enable)
  {
    int methodID = GetMethodID();
    enable = (methodID == -1 || IsMethodSupportedBySfx(methodID));
  }
  if (!enable)
    CheckButton(IDX_COMPRESS_SFX, false);
  EnableItem(IDX_COMPRESS_SFX, enable);
}

/*
void CCompressDialog::CheckVolumeEnable()
{
  bool isSFX = IsSFX();
  m_Volume.Enable(!isSFX);
  if (isSFX)
    m_Volume.SetText(TEXT(""));
}
*/

void CCompressDialog::CheckControlsEnable()
{
  const CFormatInfo &fi = g_Formats[GetStaticFormatIndex()];
  Info.SolidIsSpecified = fi.Solid;
  bool multiThreadEnable = fi.MultiThread;
  Info.MultiThreadIsAllowed = multiThreadEnable;
  Info.EncryptHeadersIsAllowed = fi.EncryptFileNames;
  
  EnableItem(IDC_COMPRESS_SOLID, fi.Solid);
  EnableItem(IDC_COMPRESS_THREADS, multiThreadEnable);

  CheckSFXControlsEnable();

  {
    const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
    
    ShowItem_Bool(IDX_COMPRESS_NT_SYM_LINKS, ai.Flags_SymLinks());
    ShowItem_Bool(IDX_COMPRESS_NT_HARD_LINKS, ai.Flags_HardLinks());
    ShowItem_Bool(IDX_COMPRESS_NT_ALT_STREAMS, ai.Flags_AltStreams());
    ShowItem_Bool(IDX_COMPRESS_NT_SECUR, ai.Flags_NtSecure());

    ShowItem_Bool(IDG_COMPRESS_NTFS,
           ai.Flags_SymLinks()
        || ai.Flags_HardLinks()
        || ai.Flags_AltStreams()
        || ai.Flags_NtSecure());
  }
  // CheckVolumeEnable();

  EnableItem(IDG_COMPRESS_ENCRYPTION, fi.Encrypt);

  EnableItem(IDT_PASSWORD_ENTER, fi.Encrypt);
  EnableItem(IDT_PASSWORD_REENTER, fi.Encrypt);
  EnableItem(IDE_COMPRESS_PASSWORD1, fi.Encrypt);
  EnableItem(IDE_COMPRESS_PASSWORD2, fi.Encrypt);
  EnableItem(IDX_PASSWORD_SHOW, fi.Encrypt);

  EnableItem(IDT_COMPRESS_ENCRYPTION_METHOD, fi.Encrypt);
  EnableItem(IDC_COMPRESS_ENCRYPTION_METHOD, fi.Encrypt);
  EnableItem(IDX_COMPRESS_ENCRYPT_FILE_NAMES, fi.EncryptFileNames);

  ShowItem_Bool(IDX_COMPRESS_ENCRYPT_FILE_NAMES, fi.EncryptFileNames);
}

bool CCompressDialog::IsSFX()
{
  CWindow sfxButton = GetItem(IDX_COMPRESS_SFX);
  return sfxButton.IsEnabled() && IsButtonCheckedBool(IDX_COMPRESS_SFX);
}

static int GetExtDotPos(const UString &s)
{
  int dotPos = s.ReverseFind_Dot();
  if (dotPos > s.ReverseFind_PathSepar() + 1)
    return dotPos;
  return -1;
}

void CCompressDialog::OnButtonSFX()
{
  UString fileName;
  m_ArchivePath.GetText(fileName);
  int dotPos = GetExtDotPos(fileName);
  if (IsSFX())
  {
    if (dotPos >= 0)
      fileName.DeleteFrom(dotPos);
    fileName += kExeExt;
    m_ArchivePath.SetText(fileName);
  }
  else
  {
    if (dotPos >= 0)
    {
      UString ext = fileName.Ptr(dotPos);
      if (ext.IsEqualTo_NoCase(kExeExt))
      {
        fileName.DeleteFrom(dotPos);
        m_ArchivePath.SetText(fileName);
      }
    }
    SetArchiveName2(false); // it's for OnInit
  }

  // CheckVolumeEnable();
}

bool CCompressDialog::GetFinalPath_Smart(UString &resPath)
{
  UString name;
  m_ArchivePath.GetText(name);
  name.Trim();
  UString tempPath = name;
  if (!IsAbsolutePath(name))
  {
    UString newDirPrefix = DirPrefix;
    if (newDirPrefix.IsEmpty())
      newDirPrefix = StartDirPrefix;
    FString resultF;
    if (!MyGetFullPathName(us2fs(newDirPrefix + name), resultF))
      return false;
    tempPath = fs2us(resultF);
  }
  if (!SetArcPathFields(tempPath, name, false))
    return false;
  FString resultF;
  if (!MyGetFullPathName(us2fs(DirPrefix + name), resultF))
    return false;
  resPath = fs2us(resultF);
  return true;
}

bool CCompressDialog::SetArcPathFields(const UString &path, UString &name, bool always)
{
  FString resDirPrefix;
  FString resFileName;
  bool res = GetFullPathAndSplit(us2fs(path), resDirPrefix, resFileName);
  if (res)
  {
    DirPrefix = fs2us(resDirPrefix);
    name = fs2us(resFileName);
  }
  else
  {
    if (!always)
      return false;
    DirPrefix.Empty();
    name = path;
  }
  SetItemText(IDT_COMPRESS_ARCHIVE_FOLDER, DirPrefix);
  m_ArchivePath.SetText(name);
  return res;
}

static const wchar_t *k_IncorrectPathMessage = L"Incorrect archive path";

void CCompressDialog::OnButtonSetArchive()
{
  UString path;
  if (!GetFinalPath_Smart(path))
  {
    ShowErrorMessage(*this, k_IncorrectPathMessage);
    return;
  }

  UString title = LangString(IDS_COMPRESS_SET_ARCHIVE_BROWSE);
  UString filterDescription = LangString(IDS_OPEN_TYPE_ALL_FILES);
  filterDescription += L" (*.*)";
  UString resPath;
  CurrentDirWasChanged = true;
  if (!MyBrowseForFile(*this, title,
      // DirPrefix.IsEmpty() ? NULL : (const wchar_t *)DirPrefix,
      // NULL,
      path,
      filterDescription,
      NULL, // L"*.*",
      resPath))
    return;
  UString dummyName;
  SetArcPathFields(resPath, dummyName, true);
}

// in ExtractDialog.cpp
extern void AddUniqueString(UStringVector &strings, const UString &srcString);

static bool IsAsciiString(const UString &s)
{
  for (unsigned i = 0; i < s.Len(); i++)
  {
    wchar_t c = s[i];
    if (c < 0x20 || c > 0x7F)
      return false;
  }
  return true;
}

void CCompressDialog::OnOK()
{
  _password1Control.GetText(Info.Password);
  if (IsZipFormat())
  {
    if (!IsAsciiString(Info.Password))
    {
      ShowErrorMessageHwndRes(*this, IDS_PASSWORD_USE_ASCII);
      return;
    }
    UString method = GetEncryptionMethodSpec();
    if (method.IsPrefixedBy_Ascii_NoCase("aes"))
    {
      if (Info.Password.Len() > 99)
      {
        ShowErrorMessageHwndRes(*this, IDS_PASSWORD_TOO_LONG);
        return;
      }
    }
  }
  if (!IsShowPasswordChecked())
  {
    UString password2;
    _password2Control.GetText(password2);
    if (password2 != Info.Password)
    {
      ShowErrorMessageHwndRes(*this, IDS_PASSWORD_NOT_MATCH);
      return;
    }
  }

  SaveOptionsInMem();
  {
    UString s;
    if (!GetFinalPath_Smart(s))
    {
      ShowErrorMessage(*this, k_IncorrectPathMessage);
      return;
    }
    
    m_RegistryInfo.ArcPaths.Clear();
    AddUniqueString(m_RegistryInfo.ArcPaths, s);
    Info.ArcPath = s;
  }
  
  Info.UpdateMode = (NCompressDialog::NUpdateMode::EEnum)k_UpdateMode_Vals[m_UpdateMode.GetCurSel()];;
  Info.PathMode = (NWildcard::ECensorPathMode)k_PathMode_Vals[m_PathMode.GetCurSel()];

  Info.Level = GetLevelSpec();
  Info.Dictionary = GetDictionarySpec();
  Info.Order = GetOrderSpec();
  Info.OrderMode = GetOrderMode();
  Info.NumThreads = GetNumThreadsSpec();

  UInt32 solidLogSize = GetBlockSizeSpec();
  Info.SolidBlockSize = 0;
  if (solidLogSize > 0 && solidLogSize != (UInt32)(Int32)-1)
    Info.SolidBlockSize = (solidLogSize >= 64) ? (UInt64)(Int64)-1 : ((UInt64)1 << solidLogSize);

  Info.Method = GetMethodSpec();
  Info.EncryptionMethod = GetEncryptionMethodSpec();
  Info.FormatIndex = GetFormatIndex();
  Info.SFXMode = IsSFX();
  Info.OpenShareForWrite = IsButtonCheckedBool(IDX_COMPRESS_SHARED);
  Info.DeleteAfterCompressing = IsButtonCheckedBool(IDX_COMPRESS_DEL);

  m_RegistryInfo.EncryptHeaders =
    Info.EncryptHeaders = IsButtonCheckedBool(IDX_COMPRESS_ENCRYPT_FILE_NAMES);


  GetButton_Bools(IDX_COMPRESS_NT_SYM_LINKS,   Info.SymLinks,   m_RegistryInfo.SymLinks);
  GetButton_Bools(IDX_COMPRESS_NT_HARD_LINKS,  Info.HardLinks,  m_RegistryInfo.HardLinks);
  GetButton_Bools(IDX_COMPRESS_NT_ALT_STREAMS, Info.AltStreams, m_RegistryInfo.AltStreams);
  GetButton_Bools(IDX_COMPRESS_NT_SECUR,       Info.NtSecurity, m_RegistryInfo.NtSecurity);

  {
    const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
    if (!ai.Flags_SymLinks()) Info.SymLinks.Val = false;
    if (!ai.Flags_HardLinks()) Info.HardLinks.Val = false;
    if (!ai.Flags_AltStreams()) Info.AltStreams.Val = false;
    if (!ai.Flags_NtSecure()) Info.NtSecurity.Val = false;
  }

  m_Params.GetText(Info.Options);
  
  UString volumeString;
  m_Volume.GetText(volumeString);
  volumeString.Trim();
  Info.VolumeSizes.Clear();
  
  if (!volumeString.IsEmpty())
  {
    if (!ParseVolumeSizes(volumeString, Info.VolumeSizes))
    {
      ShowErrorMessageHwndRes(*this, IDS_INCORRECT_VOLUME_SIZE);
      return;
    }
    if (!Info.VolumeSizes.IsEmpty())
    {
      const UInt64 volumeSize = Info.VolumeSizes.Back();
      if (volumeSize < (100 << 10))
      {
        wchar_t s[32];
        ConvertUInt64ToString(volumeSize, s);
        if (::MessageBoxW(*this, MyFormatNew(IDS_SPLIT_CONFIRM, s),
            L"7-Zip", MB_YESNOCANCEL | MB_ICONQUESTION) != IDYES)
          return;
      }
    }
  }

  for (int i = 0; i < m_ArchivePath.GetCount(); i++)
  {
    UString sTemp;
    m_ArchivePath.GetLBText(i, sTemp);
    sTemp.Trim();
    AddUniqueString(m_RegistryInfo.ArcPaths, sTemp);
  }
  
  if (m_RegistryInfo.ArcPaths.Size() > kHistorySize)
    m_RegistryInfo.ArcPaths.DeleteBack();
  
  if (Info.FormatIndex >= 0)
    m_RegistryInfo.ArcType = (*ArcFormats)[Info.FormatIndex].Name;
  m_RegistryInfo.ShowPassword = IsShowPasswordChecked();

  m_RegistryInfo.Save();
  
  CModalDialog::OnOK();
}

static LPCWSTR kHelpTopic = L"fm/plugins/7-zip/add.htm";

void CCompressDialog::OnHelp()
{
  ShowHelpWindow(NULL, kHelpTopic);
}

bool CCompressDialog::OnCommand(int code, int itemID, LPARAM lParam)
{
  if (code == CBN_SELCHANGE)
  {
    switch (itemID)
    {
      case IDC_COMPRESS_ARCHIVE:
      {
        // we can 't change m_ArchivePath in that handler !
        DirPrefix.Empty();
        SetItemText(IDT_COMPRESS_ARCHIVE_FOLDER, DirPrefix);

        /*
        UString path;
        m_ArchivePath.GetText(path);
        m_ArchivePath.SetText(L"");
        if (IsAbsolutePath(path))
        {
          UString fileName;
          SetArcPathFields(path, fileName);
          SetArchiveName(fileName);
        }
        */
        return true;
      }
      case IDC_COMPRESS_FORMAT:
      {
        bool isSFX = IsSFX();
        SaveOptionsInMem();
        SetLevel();
        SetSolidBlockSize();
        SetNumThreads();
        SetParams();
        CheckControlsEnable();
        SetArchiveName2(isSFX);
        SetEncryptionMethod();
        SetMemoryUsage();
        return true;
      }
      case IDC_COMPRESS_LEVEL:
      {
        const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
        int index = FindRegistryFormatAlways(ai.Name);
        NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
        fo.ResetForLevelChange();
        SetMethod();
        SetSolidBlockSize();
        SetNumThreads();
        CheckSFXNameChange();
        SetMemoryUsage();
        return true;
      }
      case IDC_COMPRESS_METHOD:
      {
        SetDictionary();
        SetOrder();
        SetSolidBlockSize();
        SetNumThreads();
        CheckSFXNameChange();
        SetMemoryUsage();
        return true;
      }
      case IDC_COMPRESS_DICTIONARY:
      case IDC_COMPRESS_ORDER:
      {
        SetSolidBlockSize();
        SetMemoryUsage();
        return true;
      }
      case IDC_COMPRESS_THREADS:
      {
        SetMemoryUsage();
        return true;
      }
    }
  }
  return CModalDialog::OnCommand(code, itemID, lParam);
}

void CCompressDialog::CheckSFXNameChange()
{
  bool isSFX = IsSFX();
  CheckSFXControlsEnable();
  if (isSFX != IsSFX())
    SetArchiveName2(isSFX);
}

void CCompressDialog::SetArchiveName2(bool prevWasSFX)
{
  UString fileName;
  m_ArchivePath.GetText(fileName);
  const CArcInfoEx &prevArchiverInfo = (*ArcFormats)[m_PrevFormat];
  if (prevArchiverInfo.Flags_KeepName() || Info.KeepName)
  {
    UString prevExtension;
    if (prevWasSFX)
      prevExtension = kExeExt;
    else
      prevExtension = UString(L'.') + prevArchiverInfo.GetMainExt();
    const unsigned prevExtensionLen = prevExtension.Len();
    if (fileName.Len() >= prevExtensionLen)
      if (StringsAreEqualNoCase(fileName.RightPtr(prevExtensionLen), prevExtension))
        fileName.DeleteFrom(fileName.Len() - prevExtensionLen);
  }
  SetArchiveName(fileName);
}

// if type.KeepName then use OriginalFileName
// else if !KeepName remove extension
// add new extension

void CCompressDialog::SetArchiveName(const UString &name)
{
  UString fileName = name;
  Info.FormatIndex = GetFormatIndex();
  const CArcInfoEx &ai = (*ArcFormats)[Info.FormatIndex];
  m_PrevFormat = Info.FormatIndex;
  if (ai.Flags_KeepName())
  {
    fileName = OriginalFileName;
  }
  else
  {
    if (!Info.KeepName)
    {
      int dotPos = GetExtDotPos(fileName);
      if (dotPos >= 0)
        fileName.DeleteFrom(dotPos);
    }
  }

  if (IsSFX())
    fileName += kExeExt;
  else
  {
    fileName += L'.';
    fileName += ai.GetMainExt();
  }
  m_ArchivePath.SetText(fileName);
}

int CCompressDialog::FindRegistryFormat(const UString &name)
{
  FOR_VECTOR (i, m_RegistryInfo.Formats)
  {
    const NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[i];
    if (name.IsEqualTo_NoCase(GetUnicodeString(fo.FormatID)))
      return i;
  }
  return -1;
}

int CCompressDialog::FindRegistryFormatAlways(const UString &name)
{
  int index = FindRegistryFormat(name);
  if (index < 0)
  {
    NCompression::CFormatOptions fo;
    fo.FormatID = GetSystemString(name);
    index = m_RegistryInfo.Formats.Add(fo);
  }
  return index;
}

int CCompressDialog::GetStaticFormatIndex()
{
  const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
  for (unsigned i = 0; i < ARRAY_SIZE(g_Formats); i++)
    if (ai.Name.IsEqualTo_NoCase(g_Formats[i].Name))
      return i;
  return 0; // -1;
}

void CCompressDialog::SetNearestSelectComboBox(NControl::CComboBox &comboBox, UInt32 value)
{
  for (int i = comboBox.GetCount() - 1; i >= 0; i--)
    if ((UInt32)comboBox.GetItemData(i) <= value)
    {
      comboBox.SetCurSel(i);
      return;
    }
  if (comboBox.GetCount() > 0)
    comboBox.SetCurSel(0);
}

void CCompressDialog::SetLevel()
{
  m_Level.ResetContent();
  const CFormatInfo &fi = g_Formats[GetStaticFormatIndex()];
  const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
  UInt32 level = 5;
  {
    int index = FindRegistryFormat(ai.Name);
    if (index >= 0)
    {
      const NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
      if (fo.Level <= 9)
        level = fo.Level;
      else
        level = 9;
    }
  }
  
  for (unsigned i = 0; i <= 9; i++)
  {
    if ((fi.LevelsMask & (1 << i)) != 0)
    {
      UInt32 langID = g_Levels[i];
      int index = (int)m_Level.AddString(LangString(langID));
      m_Level.SetItemData(index, i);
    }
  }
  SetNearestSelectComboBox(m_Level, level);
  SetMethod();
}

void CCompressDialog::SetMethod(int keepMethodId)
{
  m_Method.ResetContent();
  UInt32 level = GetLevel();
  if (level == 0)
  {
    SetDictionary();
    SetOrder();
    return;
  }
  const CFormatInfo &fi = g_Formats[GetStaticFormatIndex()];
  const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
  int index = FindRegistryFormat(ai.Name);
  UString defaultMethod;
  if (index >= 0)
  {
    const NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
    defaultMethod = fo.Method;
  }
  bool isSfx = IsSFX();
  bool weUseSameMethod = false;
  
  for (unsigned m = 0; m < fi.NumMethods; m++)
  {
    EMethodID methodID = fi.MathodIDs[m];
    if (isSfx)
      if (!IsMethodSupportedBySfx(methodID))
        continue;
    const LPCWSTR method = kMethodsNames[methodID];
    int itemIndex = (int)m_Method.AddString(GetSystemString(method));
    m_Method.SetItemData(itemIndex, methodID);
    if (keepMethodId == methodID)
    {
      m_Method.SetCurSel(itemIndex);
      weUseSameMethod = true;
      continue;
    }
    if ((defaultMethod.IsEqualTo_NoCase(method) || m == 0) && !weUseSameMethod)
      m_Method.SetCurSel(itemIndex);
  }
  
  if (!weUseSameMethod)
  {
    SetDictionary();
    SetOrder();
  }
}

bool CCompressDialog::IsZipFormat()
{
  const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
  return ai.Name.IsEqualTo_Ascii_NoCase("zip");
}

void CCompressDialog::SetEncryptionMethod()
{
  _encryptionMethod.ResetContent();
  const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
  if (ai.Name.IsEqualTo_Ascii_NoCase("7z"))
  {
    _encryptionMethod.AddString(TEXT("AES-256"));
    _encryptionMethod.SetCurSel(0);
  }
  else if (ai.Name.IsEqualTo_Ascii_NoCase("zip"))
  {
    int index = FindRegistryFormat(ai.Name);
    UString encryptionMethod;
    if (index >= 0)
    {
      const NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
      encryptionMethod = fo.EncryptionMethod;
    }
    _encryptionMethod.AddString(TEXT("ZipCrypto"));
    _encryptionMethod.AddString(TEXT("AES-256"));
    _encryptionMethod.SetCurSel(encryptionMethod.IsPrefixedBy_Ascii_NoCase("aes") ? 1 : 0);
  }
}

int CCompressDialog::GetMethodID()
{
  if (m_Method.GetCount() <= 0)
    return -1;
  return (int)(UInt32)m_Method.GetItemData_of_CurSel();
}

UString CCompressDialog::GetMethodSpec()
{
  if (m_Method.GetCount() <= 1)
    return UString();
  return kMethodsNames[GetMethodID()];
}

UString CCompressDialog::GetEncryptionMethodSpec()
{
  if (_encryptionMethod.GetCount() <= 1)
    return UString();
  if (_encryptionMethod.GetCurSel() <= 0)
    return UString();
  UString result;
  _encryptionMethod.GetText(result);
  result.RemoveChar(L'-');
  return result;
}

void CCompressDialog::AddDictionarySize(UInt32 size)
{
  Byte c = 0;
  unsigned moveBits = 0;
  if ((size & 0xFFFFF) == 0)    { moveBits = 20; c = 'M'; }
  else if ((size & 0x3FF) == 0) { moveBits = 10; c = 'K'; }
  TCHAR s[40];
  ConvertUInt32ToString(size >> moveBits, s);
  unsigned pos = MyStringLen(s);
  s[pos++] = ' ';
  if (moveBits != 0)
    s[pos++] = c;
  s[pos++] = 'B';
  s[pos++] = 0;
  int index = (int)m_Dictionary.AddString(s);
  m_Dictionary.SetItemData(index, size);
}

void CCompressDialog::SetDictionary()
{
  m_Dictionary.ResetContent();
  const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
  int index = FindRegistryFormat(ai.Name);
  UInt32 defaultDict = (UInt32)(Int32)-1;
  
  if (index >= 0)
  {
    const NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
    if (fo.Method.IsEqualTo_NoCase(GetMethodSpec()))
      defaultDict = fo.Dictionary;
  }
  
  int methodID = GetMethodID();
  UInt32 level = GetLevel2();
  if (methodID < 0)
    return;
  UInt64 maxRamSize;
  bool maxRamSize_Defined = GetMaxRamSizeForProgram(maxRamSize);
  
  switch (methodID)
  {
    case kLZMA:
    case kLZMA2:
    {
      static const UInt32 kMinDicSize = (1 << 16);
      if (defaultDict == (UInt32)(Int32)-1)
      {
             if (level >= 9) defaultDict = (1 << 26);
        else if (level >= 7) defaultDict = (1 << 25);
        else if (level >= 5) defaultDict = (1 << 24);
        else if (level >= 3) defaultDict = (1 << 20);
        else                 defaultDict = (kMinDicSize);
      }
      
      AddDictionarySize(kMinDicSize);
      m_Dictionary.SetCurSel(0);
      
      for (unsigned i = 20; i <= 31; i++)
        for (unsigned j = 0; j < 2; j++)
        {
          if (i == 20 && j > 0)
            continue;
          UInt32 dict = ((UInt32)(2 + j) << (i - 1));
          
          if (dict >
            #ifdef MY_CPU_64BIT
              (3 << 29)
            #else
              (1 << 26)
            #endif
            )
            continue;
          
          AddDictionarySize(dict);
          UInt64 decomprSize;
          UInt64 requiredComprSize = GetMemoryUsage(dict, decomprSize);
          if (dict <= defaultDict && (!maxRamSize_Defined || requiredComprSize <= maxRamSize))
            m_Dictionary.SetCurSel(m_Dictionary.GetCount() - 1);
        }

      // SetNearestSelectComboBox(m_Dictionary, defaultDict);
      break;
    }
    
    case kPPMd:
    {
      if (defaultDict == (UInt32)(Int32)-1)
      {
             if (level >= 9) defaultDict = (192 << 20);
        else if (level >= 7) defaultDict = ( 64 << 20);
        else if (level >= 5) defaultDict = ( 16 << 20);
        else                 defaultDict = (  4 << 20);
      }

      for (unsigned i = 20; i < 31; i++)
        for (unsigned j = 0; j < 2; j++)
        {
          if (i == 20 && j > 0)
            continue;
          UInt32 dict = ((UInt32)(2 + j) << (i - 1));
          if (dict >
            #ifdef MY_CPU_64BIT
              (1 << 30)
            #else
              (1 << 29)
            #endif
            )
            continue;
          AddDictionarySize(dict);
          UInt64 decomprSize;
          UInt64 requiredComprSize = GetMemoryUsage(dict, decomprSize);
          if ((dict <= defaultDict && (!maxRamSize_Defined || requiredComprSize <= maxRamSize))
              || m_Dictionary.GetCount() == 1)
            m_Dictionary.SetCurSel(m_Dictionary.GetCount() - 1);
        }
      
      // SetNearestSelectComboBox(m_Dictionary, defaultDict);
      break;
    }

    case kDeflate:
    {
      AddDictionarySize(32 << 10);
      m_Dictionary.SetCurSel(0);
      break;
    }
    
    case kDeflate64:
    {
      AddDictionarySize(64 << 10);
      m_Dictionary.SetCurSel(0);
      break;
    }
    
    case kBZip2:
    {
      if (defaultDict == (UInt32)(Int32)-1)
      {
             if (level >= 5) defaultDict = (900 << 10);
        else if (level >= 3) defaultDict = (500 << 10);
        else                 defaultDict = (100 << 10);
      }
      
      for (unsigned i = 1; i <= 9; i++)
      {
        UInt32 dict = ((UInt32)i * 100) << 10;
        AddDictionarySize(dict);
        if (dict <= defaultDict || m_Dictionary.GetCount() == 0)
          m_Dictionary.SetCurSel(m_Dictionary.GetCount() - 1);
      }
      
      break;
    }
    
    case kPPMdZip:
    {
      if (defaultDict == (UInt32)(Int32)-1)
        defaultDict = (1 << (19 + (level > 8 ? 8 : level)));
      
      for (unsigned i = 20; i <= 28; i++)
      {
        UInt32 dict = (1 << i);
        AddDictionarySize(dict);
        UInt64 decomprSize;
        UInt64 requiredComprSize = GetMemoryUsage(dict, decomprSize);
        if ((dict <= defaultDict && (!maxRamSize_Defined || requiredComprSize <= maxRamSize))
            || m_Dictionary.GetCount() == 1)
          m_Dictionary.SetCurSel(m_Dictionary.GetCount() - 1);
      }
      
      // SetNearestSelectComboBox(m_Dictionary, defaultDict);
      break;
    }
  }
}

UInt32 CCompressDialog::GetComboValue(NWindows::NControl::CComboBox &c, int defMax)
{
  if (c.GetCount() <= defMax)
    return (UInt32)(Int32)-1;
  return (UInt32)c.GetItemData_of_CurSel();
}

UInt32 CCompressDialog::GetLevel2()
{
  UInt32 level = GetLevel();
  if (level == (UInt32)(Int32)-1)
    level = 5;
  return level;
}

int CCompressDialog::AddOrder(UInt32 size)
{
  TCHAR s[40];
  ConvertUInt32ToString(size, s);
  int index = (int)m_Order.AddString(s);
  m_Order.SetItemData(index, size);
  return index;
}

void CCompressDialog::SetOrder()
{
  m_Order.ResetContent();
  const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
  int index = FindRegistryFormat(ai.Name);
  UInt32 defaultOrder = (UInt32)(Int32)-1;
  
  if (index >= 0)
  {
    const NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
    if (fo.Method.IsEqualTo_NoCase(GetMethodSpec()))
      defaultOrder = fo.Order;
  }

  int methodID = GetMethodID();
  UInt32 level = GetLevel2();
  if (methodID < 0)
    return;
  
  switch (methodID)
  {
    case kLZMA:
    case kLZMA2:
    {
      if (defaultOrder == (UInt32)(Int32)-1)
        defaultOrder = (level >= 7) ? 64 : 32;
      for (unsigned i = 3; i <= 8; i++)
        for (unsigned j = 0; j < 2; j++)
        {
          UInt32 order = ((UInt32)(2 + j) << (i - 1));
          if (order <= 256)
            AddOrder(order);
        }
      AddOrder(273);
      SetNearestSelectComboBox(m_Order, defaultOrder);
      break;
    }
    
    case kPPMd:
    {
      if (defaultOrder == (UInt32)(Int32)-1)
      {
             if (level >= 9) defaultOrder = 32;
        else if (level >= 7) defaultOrder = 16;
        else if (level >= 5) defaultOrder = 6;
        else                 defaultOrder = 4;
      }
      
      AddOrder(2);
      AddOrder(3);
      
      for (unsigned i = 2; i < 8; i++)
        for (unsigned j = 0; j < 4; j++)
        {
          UInt32 order = (4 + j) << (i - 2);
          if (order < 32)
            AddOrder(order);
        }
      
      AddOrder(32);
      SetNearestSelectComboBox(m_Order, defaultOrder);
      break;
    }
    
    case kDeflate:
    case kDeflate64:
    {
      if (defaultOrder == (UInt32)(Int32)-1)
      {
             if (level >= 9) defaultOrder = 128;
        else if (level >= 7) defaultOrder = 64;
        else                 defaultOrder = 32;
      }
      
      for (unsigned i = 3; i <= 8; i++)
        for (unsigned j = 0; j < 2; j++)
        {
          UInt32 order = ((UInt32)(2 + j) << (i - 1));;
          if (order <= 256)
            AddOrder(order);
        }
      
      AddOrder(methodID == kDeflate64 ? 257 : 258);
      SetNearestSelectComboBox(m_Order, defaultOrder);
      break;
    }
    
    case kBZip2:
      break;
    
    case kPPMdZip:
    {
      if (defaultOrder == (UInt32)(Int32)-1)
        defaultOrder = level + 3;
      for (unsigned i = 2; i <= 16; i++)
        AddOrder(i);
      SetNearestSelectComboBox(m_Order, defaultOrder);
      break;
    }
  }
}

bool CCompressDialog::GetOrderMode()
{
  switch (GetMethodID())
  {
    case kPPMd:
    case kPPMdZip:
      return true;
  }
  return false;
}

static const UInt32 kNoSolidBlockSize = 0;
static const UInt32 kSolidBlockSize = 64;

void CCompressDialog::SetSolidBlockSize()
{
  m_Solid.ResetContent();
  const CFormatInfo &fi = g_Formats[GetStaticFormatIndex()];
  if (!fi.Solid)
    return;

  UInt32 level = GetLevel2();
  if (level == 0)
    return;

  UInt32 dict = GetDictionarySpec();
  if (dict == (UInt32)(Int32)-1)
    dict = 1;

  UInt32 defaultBlockSize = (UInt32)(Int32)-1;

  const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
  {
    int index = FindRegistryFormat(ai.Name);
    if (index >= 0)
    {
      const NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
      if (fo.Method.IsEqualTo_NoCase(GetMethodSpec()))
        defaultBlockSize = fo.BlockLogSize;
    }
  }

  {
    int index = (int)m_Solid.AddString(LangString(IDS_COMPRESS_NON_SOLID));
    m_Solid.SetItemData(index, (UInt32)kNoSolidBlockSize);
    m_Solid.SetCurSel(0);
  }
  
  bool needSet = (defaultBlockSize == (UInt32)(Int32)-1);
  
  for (unsigned i = 20; i <= 36; i++)
  {
    if (needSet && dict >= (((UInt64)1 << (i - 7))) && i <= 32)
      defaultBlockSize = i;
    TCHAR s[40];
    ConvertUInt32ToString(1 << (i % 10), s);
    if (i < 30) lstrcat(s, TEXT(" M"));
    else        lstrcat(s, TEXT(" G"));
    lstrcat(s, TEXT("B"));
    int index = (int)m_Solid.AddString(s);
    m_Solid.SetItemData(index, (UInt32)i);
  }
  
  {
    int index = (int)m_Solid.AddString(LangString(IDS_COMPRESS_SOLID));
    m_Solid.SetItemData(index, kSolidBlockSize);
  }
  
  if (defaultBlockSize == (UInt32)(Int32)-1)
    defaultBlockSize = kSolidBlockSize;
  if (defaultBlockSize != kNoSolidBlockSize)
    SetNearestSelectComboBox(m_Solid, defaultBlockSize);
}

void CCompressDialog::SetNumThreads()
{
  m_NumThreads.ResetContent();

  const CFormatInfo &fi = g_Formats[GetStaticFormatIndex()];
  if (!fi.MultiThread)
    return;

  UInt32 numHardwareThreads = NSystem::GetNumberOfProcessors();
  UInt32 defaultValue = numHardwareThreads;

  {
    const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
    int index = FindRegistryFormat(ai.Name);
    if (index >= 0)
    {
      const NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
      if (fo.Method.IsEqualTo_NoCase(GetMethodSpec()) && fo.NumThreads != (UInt32)(Int32)-1)
        defaultValue = fo.NumThreads;
    }
  }

  UInt32 numAlgoThreadsMax = 1;
  int methodID = GetMethodID();
  switch (methodID)
  {
    case kLZMA: numAlgoThreadsMax = 2; break;
    case kLZMA2: numAlgoThreadsMax = 32; break;
    case kBZip2: numAlgoThreadsMax = 32; break;
  }
  if (IsZipFormat())
    numAlgoThreadsMax = 128;
  for (UInt32 i = 1; i <= numHardwareThreads * 2 && i <= numAlgoThreadsMax; i++)
  {
    TCHAR s[40];
    ConvertUInt32ToString(i, s);
    int index = (int)m_NumThreads.AddString(s);
    m_NumThreads.SetItemData(index, (UInt32)i);
  }
  SetNearestSelectComboBox(m_NumThreads, defaultValue);
}

UInt64 CCompressDialog::GetMemoryUsage(UInt32 dict, UInt64 &decompressMemory)
{
  decompressMemory = UInt64(Int64(-1));
  UInt32 level = GetLevel2();
  if (level == 0)
  {
    decompressMemory = (1 << 20);
    return decompressMemory;
  }
  UInt64 size = 0;

  const CFormatInfo &fi = g_Formats[GetStaticFormatIndex()];
  if (fi.Filter && level >= 9)
    size += (12 << 20) * 2 + (5 << 20);
  UInt32 numThreads = GetNumThreads2();
  
  if (IsZipFormat())
  {
    UInt32 numSubThreads = 1;
    if (GetMethodID() == kLZMA && numThreads > 1 && level >= 5)
      numSubThreads = 2;
    UInt32 numMainThreads = numThreads / numSubThreads;
    if (numMainThreads > 1)
      size += (UInt64)numMainThreads << 25;
  }
  
  int methidId = GetMethodID();
  
  switch (methidId)
  {
    case kLZMA:
    case kLZMA2:
    {
      UInt32 hs = dict - 1;
      hs |= (hs >> 1);
      hs |= (hs >> 2);
      hs |= (hs >> 4);
      hs |= (hs >> 8);
      hs >>= 1;
      hs |= 0xFFFF;
      if (hs > (1 << 24))
        hs >>= 1;
      hs++;
      UInt64 size1 = (UInt64)hs * 4;
      size1 += (UInt64)dict * 4;
      if (level >= 5)
        size1 += (UInt64)dict * 4;
      size1 += (2 << 20);

      UInt32 numThreads1 = 1;
      if (numThreads > 1 && level >= 5)
      {
        size1 += (2 << 20) + (4 << 20);
        numThreads1 = 2;
      }
      
      UInt32 numBlockThreads = numThreads / numThreads1;
    
      if (methidId == kLZMA || numBlockThreads == 1)
        size1 += (UInt64)dict * 3 / 2;
      else
      {
        UInt64 chunkSize = (UInt64)dict << 2;
        chunkSize = MyMax(chunkSize, (UInt64)(1 << 20));
        chunkSize = MyMin(chunkSize, (UInt64)(1 << 28));
        chunkSize = MyMax(chunkSize, (UInt64)dict);
        size1 += chunkSize * 2;
      }
      size += size1 * numBlockThreads;

      decompressMemory = dict + (2 << 20);
      return size;
    }
  
    case kPPMd:
    {
      decompressMemory = dict + (2 << 20);
      return size + decompressMemory;
    }
    
    case kDeflate:
    case kDeflate64:
    {
      UInt32 order = GetOrder();
      if (order == (UInt32)(Int32)-1)
        order = 32;
      if (level >= 7)
        size += (1 << 20);
      size += 3 << 20;
      decompressMemory = (2 << 20);
      return size;
    }
    
    case kBZip2:
    {
      decompressMemory = (7 << 20);
      UInt64 memForOneThread = (10 << 20);
      return size + memForOneThread * numThreads;
    }
    
    case kPPMdZip:
    {
      decompressMemory = dict + (2 << 20);
      return size + (UInt64)decompressMemory * numThreads;
    }
  }
  
  return (UInt64)(Int64)-1;
}

UInt64 CCompressDialog::GetMemoryUsage(UInt64 &decompressMemory)
{
  return GetMemoryUsage(GetDictionary(), decompressMemory);
}

void CCompressDialog::PrintMemUsage(UINT res, UInt64 value)
{
  if (value == (UInt64)(Int64)-1)
  {
    SetItemText(res, TEXT("?"));
    return;
  }
  value = (value + (1 << 20) - 1) >> 20;
  TCHAR s[40];
  ConvertUInt64ToString(value, s);
  lstrcat(s, TEXT(" MB"));
  SetItemText(res, s);
}
    
void CCompressDialog::SetMemoryUsage()
{
  UInt64 decompressMem;
  UInt64 memUsage = GetMemoryUsage(decompressMem);
  PrintMemUsage(IDT_COMPRESS_MEMORY_VALUE, memUsage);
  PrintMemUsage(IDT_COMPRESS_MEMORY_DE_VALUE, decompressMem);
}

void CCompressDialog::SetParams()
{
  const CArcInfoEx &ai = (*ArcFormats)[GetFormatIndex()];
  m_Params.SetText(TEXT(""));
  int index = FindRegistryFormat(ai.Name);
  if (index >= 0)
  {
    const NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
    m_Params.SetText(fo.Options);
  }
}

void CCompressDialog::SaveOptionsInMem()
{
  const CArcInfoEx &ai = (*ArcFormats)[Info.FormatIndex];
  int index = FindRegistryFormatAlways(ai.Name);
  m_Params.GetText(Info.Options);
  Info.Options.Trim();
  NCompression::CFormatOptions &fo = m_RegistryInfo.Formats[index];
  fo.Options = Info.Options;
  fo.Level = GetLevelSpec();
  fo.Dictionary = GetDictionarySpec();
  fo.Order = GetOrderSpec();
  fo.Method = GetMethodSpec();
  fo.EncryptionMethod = GetEncryptionMethodSpec();
  fo.NumThreads = GetNumThreadsSpec();
  fo.BlockLogSize = GetBlockSizeSpec();
}

unsigned CCompressDialog::GetFormatIndex()
{
  return (unsigned)m_Format.GetItemData_of_CurSel();
}
// CompressDialog.h

#ifndef __COMPRESS_DIALOG_H
#define __COMPRESS_DIALOG_H

#include "../../../Common/Wildcard.h"

#include "../../../Windows/Control/ComboBox.h"
#include "../../../Windows/Control/Edit.h"

#include "../Common/LoadCodecs.h"
#include "../Common/ZipRegistry.h"

#include "../FileManager/DialogSize.h"

#include "CompressDialogRes.h"

namespace NCompressDialog
{
  namespace NUpdateMode
  {
    enum EEnum
    {
      kAdd,
      kUpdate,
      kFresh,
      kSync
    };
  }
  
  struct CInfo
  {
    NUpdateMode::EEnum UpdateMode;
    NWildcard::ECensorPathMode PathMode;

    bool SolidIsSpecified;
    bool MultiThreadIsAllowed;
    UInt64 SolidBlockSize;
    UInt32 NumThreads;

    CRecordVector<UInt64> VolumeSizes;

    UInt32 Level;
    UString Method;
    UInt32 Dictionary;
    bool OrderMode;
    UInt32 Order;
    UString Options;

    UString EncryptionMethod;

    bool SFXMode;
    bool OpenShareForWrite;
    bool DeleteAfterCompressing;
    
    CBoolPair SymLinks;
    CBoolPair HardLinks;
    CBoolPair AltStreams;
    CBoolPair NtSecurity;
    
    UString ArcPath; // in: Relative or abs ; out: Relative or abs
    
    // FString CurrentDirPrefix;
    bool KeepName;

    bool GetFullPathName(UString &result) const;

    int FormatIndex;

    UString Password;
    bool EncryptHeadersIsAllowed;
    bool EncryptHeaders;

    CInfo():
        UpdateMode(NCompressDialog::NUpdateMode::kAdd),
        PathMode(NWildcard::k_RelatPath),
        SFXMode(false),
        OpenShareForWrite(false),
        DeleteAfterCompressing(false),
        FormatIndex(-1)
    {
      Level = Dictionary = Order = UInt32(-1);
      OrderMode = false;
      Method.Empty();
      Options.Empty();
      EncryptionMethod.Empty();
    }
  };
}

class CCompressDialog: public NWindows::NControl::CModalDialog
{
  NWindows::NControl::CComboBox m_ArchivePath;
  NWindows::NControl::CComboBox m_Format;
  NWindows::NControl::CComboBox m_Level;
  NWindows::NControl::CComboBox m_Method;
  NWindows::NControl::CComboBox m_Dictionary;
  NWindows::NControl::CComboBox m_Order;
  NWindows::NControl::CComboBox m_Solid;
  NWindows::NControl::CComboBox m_NumThreads;

  NWindows::NControl::CComboBox m_UpdateMode;
  NWindows::NControl::CComboBox m_PathMode;
  
  NWindows::NControl::CComboBox m_Volume;
  NWindows::NControl::CDialogChildControl m_Params;

  NWindows::NControl::CEdit _password1Control;
  NWindows::NControl::CEdit _password2Control;
  NWindows::NControl::CComboBox _encryptionMethod;

  NCompression::CInfo m_RegistryInfo;

  int m_PrevFormat;
  UString DirPrefix;
  UString StartDirPrefix;

  void CheckButton_TwoBools(UINT id, const CBoolPair &b1, const CBoolPair &b2);
  void GetButton_Bools(UINT id, CBoolPair &b1, CBoolPair &b2);

  void SetArchiveName(const UString &name);
  int FindRegistryFormat(const UString &name);
  int FindRegistryFormatAlways(const UString &name);
  
  void CheckSFXNameChange();
  void SetArchiveName2(bool prevWasSFX);
  
  int GetStaticFormatIndex();

  void SetNearestSelectComboBox(NWindows::NControl::CComboBox &comboBox, UInt32 value);

  void SetLevel();
  
  void SetMethod(int keepMethodId = -1);
  int GetMethodID();
  UString GetMethodSpec();
  UString GetEncryptionMethodSpec();

  bool IsZipFormat();

  void SetEncryptionMethod();

  void AddDictionarySize(UInt32 size);
  
  void SetDictionary();

  UInt32 GetComboValue(NWindows::NControl::CComboBox &c, int defMax = 0);

  UInt32 GetLevel()  { return GetComboValue(m_Level); }
  UInt32 GetLevelSpec()  { return GetComboValue(m_Level, 1); }
  UInt32 GetLevel2();
  UInt32 GetDictionary() { return GetComboValue(m_Dictionary); }
  UInt32 GetDictionarySpec() { return GetComboValue(m_Dictionary, 1); }
  UInt32 GetOrder() { return GetComboValue(m_Order); }
  UInt32 GetOrderSpec() { return GetComboValue(m_Order, 1); }
  UInt32 GetNumThreadsSpec() { return GetComboValue(m_NumThreads, 1); }
  UInt32 GetNumThreads2() { UInt32 num = GetNumThreadsSpec(); if (num == UInt32(-1)) num = 1; return num; }
  UInt32 GetBlockSizeSpec() { return GetComboValue(m_Solid, 1); }

  int AddOrder(UInt32 size);
  void SetOrder();
  bool GetOrderMode();

  void SetSolidBlockSize();
  void SetNumThreads();

  UInt64 GetMemoryUsage(UInt32 dict, UInt64 &decompressMemory);
  UInt64 GetMemoryUsage(UInt64 &decompressMemory);
  void PrintMemUsage(UINT res, UInt64 value);
  void SetMemoryUsage();
  void SetParams();
  void SaveOptionsInMem();

  void UpdatePasswordControl();
  bool IsShowPasswordChecked() const { return IsButtonCheckedBool(IDX_PASSWORD_SHOW); }

  unsigned GetFormatIndex();
  bool SetArcPathFields(const UString &path, UString &name, bool always);
  bool GetFinalPath_Smart(UString &resPath);

public:
  CObjectVector<CArcInfoEx> *ArcFormats;
  CUIntVector ArcIndices; // can not be empty, must contain Info.FormatIndex, if Info.FormatIndex >= 0

  NCompressDialog::CInfo Info;
  UString OriginalFileName; // for bzip2, gzip2
  bool CurrentDirWasChanged;

  INT_PTR Create(HWND wndParent = 0)
  {
    BIG_DIALOG_SIZE(400, 304);
    return CModalDialog::Create(SIZED_DIALOG(IDD_COMPRESS), wndParent);
  }

  CCompressDialog(): CurrentDirWasChanged(false) {};

protected:

  void CheckSFXControlsEnable();
  // void CheckVolumeEnable();
  void CheckControlsEnable();

  void OnButtonSetArchive();
  bool IsSFX();
  void OnButtonSFX();

  virtual bool OnInit();
  virtual bool OnCommand(int code, int itemID, LPARAM lParam);
  virtual bool OnButtonClicked(int buttonID, HWND buttonHWND);
  virtual void OnOK();
  virtual void OnHelp();

};

#endif
#define IDD_COMPRESS     4000
#define IDD_COMPRESS_2  14000

#define IDC_COMPRESS_ARCHIVE             100
#define IDB_COMPRESS_SET_ARCHIVE         101
#define IDC_COMPRESS_LEVEL               102
#define IDC_COMPRESS_UPDATE_MODE         103
#define IDC_COMPRESS_FORMAT              104
#define IDC_COMPRESS_VOLUME              105
#define IDC_COMPRESS_METHOD              106
#define IDC_COMPRESS_DICTIONARY          107
#define IDC_COMPRESS_ORDER               108
#define IDC_COMPRESS_SOLID               109
#define IDC_COMPRESS_THREADS             110
#define IDE_COMPRESS_PARAMETERS          111

#define IDT_COMPRESS_HARDWARE_THREADS    112
#define IDT_COMPRESS_MEMORY_VALUE        113
#define IDT_COMPRESS_MEMORY_DE_VALUE     114

#define IDG_COMPRESS_NTFS                115
#define IDC_COMPRESS_PATH_MODE           116

#define IDE_COMPRESS_PASSWORD1           120
#define IDE_COMPRESS_PASSWORD2           121
#define IDC_COMPRESS_ENCRYPTION_METHOD   122

#define IDT_COMPRESS_ARCHIVE_FOLDER      130

#define IDT_COMPRESS_PATH_MODE          3410

#define IDT_PASSWORD_ENTER              3801
#define IDT_PASSWORD_REENTER            3802
#define IDX_PASSWORD_SHOW               3803
#define IDS_PASSWORD_NOT_MATCH          3804
#define IDS_PASSWORD_USE_ASCII          3805
#define IDS_PASSWORD_TOO_LONG           3806

#define IDT_COMPRESS_ARCHIVE            4001
#define IDT_COMPRESS_UPDATE_MODE        4002
#define IDT_COMPRESS_FORMAT             4003
#define IDT_COMPRESS_LEVEL              4004
#define IDT_COMPRESS_METHOD             4005
#define IDT_COMPRESS_DICTIONARY         4006
#define IDT_COMPRESS_ORDER              4007
#define IDT_COMPRESS_SOLID              4008
#define IDT_COMPRESS_THREADS            4009
#define IDT_COMPRESS_PARAMETERS         4010
#define IDG_COMPRESS_OPTIONS            4011

#define IDX_COMPRESS_SFX                4012
#define IDX_COMPRESS_SHARED             4013

#define IDG_COMPRESS_ENCRYPTION         4014
#define IDT_COMPRESS_ENCRYPTION_METHOD  4015
#define IDX_COMPRESS_ENCRYPT_FILE_NAMES 4016
                                         
#define IDT_COMPRESS_MEMORY             4017
#define IDT_COMPRESS_MEMORY_DE          4018

#define IDX_COMPRESS_DEL                4019

#define IDX_COMPRESS_NT_SYM_LINKS       4040
#define IDX_COMPRESS_NT_HARD_LINKS      4041
#define IDX_COMPRESS_NT_ALT_STREAMS     4042
#define IDX_COMPRESS_NT_SECUR           4043

#define IDS_METHOD_STORE                4050
#define IDS_METHOD_FASTEST              4051
#define IDS_METHOD_FAST                 4052
#define IDS_METHOD_NORMAL               4053
#define IDS_METHOD_MAXIMUM              4054
#define IDS_METHOD_ULTRA                4055

#define IDS_COMPRESS_UPDATE_MODE_ADD    4060
#define IDS_COMPRESS_UPDATE_MODE_UPDATE 4061
#define IDS_COMPRESS_UPDATE_MODE_FRESH  4062
#define IDS_COMPRESS_UPDATE_MODE_SYNC   4063

#define IDS_COMPRESS_SET_ARCHIVE_BROWSE 4070
#define IDS_OPEN_TYPE_ALL_FILES         4071
#define IDS_COMPRESS_NON_SOLID          4072
#define IDS_COMPRESS_SOLID              4073

#define IDT_SPLIT_TO_VOLUMES            7302
#define IDS_INCORRECT_VOLUME_SIZE       7307
#define IDS_SPLIT_CONFIRM               7308
// CompressDialog.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif 

#undef _WIN32

#include "resource2.h"
#include "Windows/Control/DialogImpl.h"

#include "CompressDialogRes.h"

class CCompressDialogImpl : public NWindows::NControl::CModalDialogImpl
{
  public:
   CCompressDialogImpl(NWindows::NControl::CModalDialog *dialog,wxWindow * parent , int id) : CModalDialogImpl(dialog,parent, id, wxT("Add to Archive"))
  {
	wxStaticText *m_pStaticTextMemoryCompress;
	wxStaticText *m_pStaticTextMemoryDecompress;
	wxTextCtrl *m_pTextCtrlPassword;
	wxTextCtrl *m_pTextCtrlRePassword;
	wxTextCtrl *m_pTextCtrlParameters;
	wxComboBox *m_pComboBoxArchiveName;
	wxComboBox *m_pComboBoxArchiveFormat;
	wxComboBox *m_pComboBoxCompressionLevel;
	wxComboBox *m_pComboBoxCompressionMethod;
	wxComboBox *m_pComboBoxDictionarySize;
	wxComboBox *m_pComboBoxWordSize;
	wxComboBox *m_pComboBoxUpdateMode;
	wxComboBox *m_pComboBoxPathMode;
	wxComboBox *m_pComboBoxEncryptionMethod;
	wxComboBox *m_pComboBoxSplitToVolumes;
	wxCheckBox *m_pCheckBoxShowPassword;
	wxCheckBox *m_pCheckBoxEncryptFileNames;
	wxButton   *m_pButtonBrowse;


	///Sizer for adding the controls created by users
	wxBoxSizer* topsizer = new wxBoxSizer(wxVERTICAL);

	wxStaticText *pStaticTextArchive = new wxStaticText(this, IDT_COMPRESS_ARCHIVE, wxT("&Archive:"));
	wxBoxSizer *pArchiveNameSizer = new wxBoxSizer(wxHORIZONTAL);
	m_pComboBoxArchiveName = new wxComboBox(this, IDC_COMPRESS_ARCHIVE, wxEmptyString, wxDefaultPosition, wxSize(600,-1), wxArrayString(), wxCB_DROPDOWN|wxCB_SORT);
	m_pButtonBrowse = new wxButton(this, IDB_COMPRESS_SET_ARCHIVE, wxT("..."), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);
	pArchiveNameSizer->Add(m_pComboBoxArchiveName, 1, wxALL|wxEXPAND, 5);
	pArchiveNameSizer->Add(m_pButtonBrowse, 0, wxALL|wxEXPAND, 5);
	wxBoxSizer *pControlSizer = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer *pLeftSizer = new wxBoxSizer(wxVERTICAL);

	wxBoxSizer *pCompressionOptionsSizer = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer *pCompressionStaticSizer = new wxBoxSizer(wxVERTICAL);
	wxBoxSizer *pCompressionComboSizer = new wxBoxSizer(wxVERTICAL);

	wxStaticText *pStaticTextArchiveFormat = new wxStaticText(this, IDT_COMPRESS_FORMAT, wxT("Archive &format:"));
	/*
	wxArrayString archiveFormatArray;
	archiveFormatArray.Add(wxT("7z"));
	archiveFormatArray.Add(wxT("Tar"));
	archiveFormatArray.Add(wxT("Zip"));
	m_pComboBoxArchiveFormat = new wxComboBox(this, IDC_COMPRESS_COMBO_FORMAT, archiveFormatArray.Item(0), wxDefaultPosition, wxDefaultSize, archiveFormatArray, wxCB_READONLY);
	*/

	m_pComboBoxArchiveFormat = new wxComboBox(this, IDC_COMPRESS_FORMAT, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);

	wxStaticText *pStaticTextCompressionLevel = new wxStaticText(this, IDT_COMPRESS_LEVEL, wxT("Compression &level:"));
	wxArrayString compressionLevelArray;
	/*
	compressionLevelArray.Add(wxT("Store"));
	compressionLevelArray.Add(wxT("Fastest"));
	compressionLevelArray.Add(wxT("Fast"));
	compressionLevelArray.Add(wxT("Normal"));
	compressionLevelArray.Add(wxT("Maximum"));
	compressionLevelArray.Add(wxT("Ultra"));
	m_pComboBoxCompressionLevel = new wxComboBox(this, IDC_COMPRESS_COMBO_LEVEL, compressionLevelArray.Item(0), wxDefaultPosition, wxDefaultSize, compressionLevelArray, wxCB_READONLY);
	*/
	m_pComboBoxCompressionLevel = new wxComboBox(this, IDC_COMPRESS_LEVEL, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);

	wxStaticText *pStaticTextCompressionMethod = new wxStaticText(this, IDT_COMPRESS_METHOD, wxT("Compression &method:"));
/*
	wxArrayString compressionMethodArray;
	compressionMethodArray.Add(wxT("LZMA"));
	compressionMethodArray.Add(wxT("PPMd"));
	compressionMethodArray.Add(wxT("BZip2"));
	m_pComboBoxCompressionMethod = new wxComboBox(this, IDC_COMPRESS_COMBO_METHOD, compressionMethodArray.Item(0), wxDefaultPosition, wxDefaultSize, compressionMethodArray, wxCB_READONLY);
*/
	m_pComboBoxCompressionMethod = new wxComboBox(this, IDC_COMPRESS_METHOD, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);

	wxStaticText *pStaticTextDictionarySize = new wxStaticText(this, IDT_COMPRESS_DICTIONARY, wxT("&Dictionary size:"));
/*
	wxArrayString dictionarySizeArray;
	dictionarySizeArray.Add(wxT("64 KB"));
	dictionarySizeArray.Add(wxT("1 MB"));
	dictionarySizeArray.Add(wxT("1 MB"));
	dictionarySizeArray.Add(wxT("2 MB"));
	dictionarySizeArray.Add(wxT("3 MB"));
	dictionarySizeArray.Add(wxT("4 MB"));
	dictionarySizeArray.Add(wxT("6 MB"));
	dictionarySizeArray.Add(wxT("8 MB"));
	dictionarySizeArray.Add(wxT("12 MB"));
	dictionarySizeArray.Add(wxT("16 MB"));
	dictionarySizeArray.Add(wxT("24 MB"));
	dictionarySizeArray.Add(wxT("32 MB"));
	dictionarySizeArray.Add(wxT("48 MB"));
	dictionarySizeArray.Add(wxT("64 MB"));
	dictionarySizeArray.Add(wxT("96 MB"));
	dictionarySizeArray.Add(wxT("128 MB"));
	m_pComboBoxDictionarySize = new wxComboBox(this, IDC_COMPRESS_COMBO_DICTIONARY, dictionarySizeArray.Item(0), wxDefaultPosition, wxDefaultSize, dictionarySizeArray, wxCB_READONLY);
*/
	m_pComboBoxDictionarySize = new wxComboBox(this, IDC_COMPRESS_DICTIONARY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);

	wxStaticText *pStaticTextNumberOfThreads = new wxStaticText(this, IDT_COMPRESS_THREADS, wxT("&Number of CPU threads:"));
/*
	wxArrayString numberOfThreadsArray;
	numberOfThreadsArray.Add(wxT("1"));
	numberOfThreadsArray.Add(wxT("2"));
	wxComboBox *m_pComboBoxNumberOfThreads = new wxComboBox(this, IDC_COMPRESS_COMBO_THREADS, numberOfThreadsArray.Item(0), wxDefaultPosition, wxDefaultSize, numberOfThreadsArray, wxCB_READONLY);
*/
	wxComboBox *m_pComboBoxNumberOfThreads = new wxComboBox(this, IDC_COMPRESS_THREADS, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);






	wxStaticText *pStaticTextWordSize = new wxStaticText(this, IDT_COMPRESS_ORDER, wxT("&Word size:"));
/*
	wxArrayString wordSizeArray;
	wordSizeArray.Add(wxT("8"));
	wordSizeArray.Add(wxT("12"));
	wordSizeArray.Add(wxT("16"));
	wordSizeArray.Add(wxT("24"));
	wordSizeArray.Add(wxT("32"));
	wordSizeArray.Add(wxT("48"));
	wordSizeArray.Add(wxT("64"));
	wordSizeArray.Add(wxT("96"));
	wordSizeArray.Add(wxT("128"));
	wordSizeArray.Add(wxT("192"));
	wordSizeArray.Add(wxT("256"));
	wordSizeArray.Add(wxT("273"));
	m_pComboBoxWordSize = new wxComboBox(this, IDC_COMPRESS_COMBO_ORDER, wordSizeArray.Item(0), wxDefaultPosition, wxDefaultSize, wordSizeArray, wxCB_READONLY);
*/
	m_pComboBoxWordSize = new wxComboBox(this, IDC_COMPRESS_ORDER, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);


	wxStaticText *pStaticTextBlockSize = new wxStaticText(this, IDT_COMPRESS_SOLID, wxT("&Solid Block size:"));

	wxComboBox *m_pComboBoxBlockSize = new wxComboBox(this, IDC_COMPRESS_SOLID, wxEmptyString, wxDefaultPosition, wxDefaultSize,  wxArrayString(), wxCB_READONLY);

	pCompressionStaticSizer->Add(pStaticTextArchiveFormat, 1, wxALL|wxEXPAND, 5);
	pCompressionStaticSizer->Add(pStaticTextCompressionLevel, 1, wxALL|wxEXPAND, 5);
	pCompressionStaticSizer->Add(pStaticTextCompressionMethod, 1, wxALL|wxEXPAND, 5);
	pCompressionStaticSizer->Add(pStaticTextDictionarySize, 1, wxALL|wxEXPAND, 5);
	pCompressionStaticSizer->Add(pStaticTextWordSize, 1, wxALL|wxEXPAND, 5);
	pCompressionStaticSizer->Add(pStaticTextBlockSize, 1, wxALL|wxEXPAND, 5);
	pCompressionStaticSizer->Add(pStaticTextNumberOfThreads, 1, wxALL|wxEXPAND, 5);
	pCompressionComboSizer->Add(m_pComboBoxArchiveFormat, 1, wxALL|wxEXPAND, 5);
	pCompressionComboSizer->Add(m_pComboBoxCompressionLevel, 1, wxALL|wxEXPAND, 5);
	pCompressionComboSizer->Add(m_pComboBoxCompressionMethod, 1, wxALL|wxEXPAND, 5);
	pCompressionComboSizer->Add(m_pComboBoxDictionarySize, 1, wxALL|wxEXPAND, 5);
	pCompressionComboSizer->Add(m_pComboBoxWordSize, 1, wxALL|wxEXPAND, 5);
	pCompressionComboSizer->Add(m_pComboBoxBlockSize, 1, wxALL|wxEXPAND, 5);
	pCompressionComboSizer->Add(m_pComboBoxNumberOfThreads, 1, wxALL|wxEXPAND, 5);
	pCompressionOptionsSizer->Add(pCompressionStaticSizer, 1, wxALL|wxEXPAND, 0);
	pCompressionOptionsSizer->Add(pCompressionComboSizer, 1, wxALL|wxEXPAND, 0);

	wxBoxSizer *pMemoryUsageSizer = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer *pMemoryUsageLabelSizer = new wxBoxSizer(wxVERTICAL);
	wxBoxSizer *pMemoryUsageInfoSizer = new wxBoxSizer(wxVERTICAL);
	wxStaticText *pStaticTextCompressMemoryUsage = new wxStaticText(this, IDT_COMPRESS_MEMORY, wxT("Memory usage for Compressing:"));
	m_pStaticTextMemoryCompress = new wxStaticText(this, IDT_COMPRESS_MEMORY_VALUE, wxT("709 MB"), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);
	wxStaticText *pStaticTextDecompressMemoryUsage = new wxStaticText(this, IDT_COMPRESS_MEMORY_DE, wxT("Memory usage for Decompressing"));
	m_pStaticTextMemoryDecompress = new wxStaticText(this, IDT_COMPRESS_MEMORY_DE_VALUE, wxT("66 MB"), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT);
	pMemoryUsageLabelSizer->Add(pStaticTextCompressMemoryUsage, 1, wxALL|wxEXPAND, 5);
	pMemoryUsageLabelSizer->Add(pStaticTextDecompressMemoryUsage, 1, wxALL|wxEXPAND, 5);
	pMemoryUsageInfoSizer->Add(m_pStaticTextMemoryCompress, 1, wxALL|wxEXPAND, 5);
	pMemoryUsageInfoSizer->Add(m_pStaticTextMemoryDecompress, 1, wxALL|wxEXPAND, 5);
	pMemoryUsageSizer->Add(pMemoryUsageLabelSizer, 1, wxALL|wxEXPAND, 0);
	pMemoryUsageSizer->Add(pMemoryUsageInfoSizer, 0, wxALL|wxEXPAND, 0);

	wxStaticText *pStaticSplit2Volumes = new wxStaticText(this, IDT_SPLIT_TO_VOLUMES, wxT("Split to &volumes, bytes:"));
/*
	wxArrayString split2VolumesArray;
	split2VolumesArray.Add(wxT("1457664 - 3.5\" floppy"));
	split2VolumesArray.Add(wxT("650M - CD"));
	split2VolumesArray.Add(wxT("700M - CD"));
	split2VolumesArray.Add(wxT("4480M - DVD"));
	m_pComboBoxSplitToVolumes = new wxComboBox(this, IDC_COMPRESS_COMBO_VOLUME, wxEmptyString, wxDefaultPosition, wxDefaultSize, split2VolumesArray, wxCB_DROPDOWN);
*/
	m_pComboBoxSplitToVolumes = new wxComboBox(this, IDC_COMPRESS_VOLUME, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_DROPDOWN);

	pLeftSizer->Add(pCompressionOptionsSizer, 0, wxALL|wxEXPAND, 0);
	pLeftSizer->Add(pMemoryUsageSizer, 1, wxALL|wxEXPAND, 0);
	pLeftSizer->Add(pStaticSplit2Volumes, 0, wxALL|wxEXPAND, 5);
	pLeftSizer->Add(m_pComboBoxSplitToVolumes, 0, wxALL|wxEXPAND, 5);

	wxBoxSizer *pRightSizer = new wxBoxSizer(wxVERTICAL);
	wxStaticText *pStaticTextUpdateMode = new wxStaticText(this, IDT_COMPRESS_UPDATE_MODE, wxT("&Update mode:"));
/*
	wxArrayString updateModeArray;
	updateModeArray.Add(wxT("Add and replace files"));
	updateModeArray.Add(wxT("Update and add files"));
	updateModeArray.Add(wxT("Freshen existing files"));
	updateModeArray.Add(wxT("Synchronize files"));
	m_pComboBoxUpdateMode = new wxComboBox(this, IDC_COMPRESS_COMBO_UPDATE_MODE, updateModeArray.Item(0), wxDefaultPosition, wxDefaultSize, updateModeArray, wxCB_READONLY);
*/
	m_pComboBoxUpdateMode = new wxComboBox(this, IDC_COMPRESS_UPDATE_MODE, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);


	wxStaticText *pStaticTextPathMode = new wxStaticText(this, IDT_COMPRESS_PATH_MODE, wxT("Path mode:"));
	m_pComboBoxPathMode = new wxComboBox(this, IDC_COMPRESS_PATH_MODE, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);




	wxStaticBoxSizer *pOptionsSizer = new wxStaticBoxSizer(new wxStaticBox(this,IDG_COMPRESS_OPTIONS,_T("Options")),wxVERTICAL);
	wxCheckBox *m_pCheckBoxSFXArchive = new wxCheckBox(this, IDX_COMPRESS_SFX, wxT("Create SF&X archive"));
	pOptionsSizer->Add(m_pCheckBoxSFXArchive, 1, wxALL|wxEXPAND, 5);
	wxCheckBox *m_pCheckBoxCompressSharedFiles = new wxCheckBox(this, IDX_COMPRESS_SHARED, wxT("Compress shared files"));
	m_pCheckBoxCompressSharedFiles->Show(false); // this option is useless undex Unix ...
	pOptionsSizer->Add(m_pCheckBoxCompressSharedFiles, 1, wxALL|wxEXPAND, 5);

	wxStaticBoxSizer * pEncryptSizer = new wxStaticBoxSizer(new wxStaticBox(this,IDG_COMPRESS_ENCRYPTION,_T("Encryption")),wxVERTICAL);
	wxStaticText *pStaticTextPassword = new wxStaticText(this, IDT_PASSWORD_ENTER, wxT("Enter password:"));
	m_pTextCtrlPassword = new wxTextCtrl(this, IDE_COMPRESS_PASSWORD1, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PASSWORD);
	wxStaticText *pStaticTextRePassword = new wxStaticText(this, IDT_PASSWORD_REENTER, wxT("Re-enter password:"));
	m_pTextCtrlRePassword = new wxTextCtrl(this, IDE_COMPRESS_PASSWORD2, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PASSWORD);
	m_pCheckBoxShowPassword = new wxCheckBox(this, IDX_PASSWORD_SHOW, wxT("Show Password"));
	wxBoxSizer *pEncryptionMethodSizer = new wxBoxSizer(wxHORIZONTAL);
	wxStaticText *pStaticTextEncryptionMethod = new wxStaticText(this, IDT_COMPRESS_ENCRYPTION_METHOD, wxT("&Encryption method:"));
/*
	wxArrayString encryptionMethodArray;
	encryptionMethodArray.Add(wxT("AES-256"));
	m_pComboBoxEncryptionMethod =new wxComboBox(this, IDC_COMPRESS_COMBO_ENCRYPTION_METHOD, encryptionMethodArray.Item(0), wxDefaultPosition, wxDefaultSize, encryptionMethodArray, wxCB_READONLY);
*/
	m_pComboBoxEncryptionMethod =new wxComboBox(this, IDC_COMPRESS_ENCRYPTION_METHOD, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxArrayString(), wxCB_READONLY);

	pEncryptionMethodSizer->Add(pStaticTextEncryptionMethod, 1, wxALL|wxEXPAND, 5);
	pEncryptionMethodSizer->Add(m_pComboBoxEncryptionMethod, 1, wxALL|wxEXPAND, 5);
	m_pCheckBoxEncryptFileNames = new wxCheckBox(this, IDX_COMPRESS_ENCRYPT_FILE_NAMES, wxT("Encrypt file &names"));
	pEncryptSizer->Add(pStaticTextPassword, 0, wxALL|wxEXPAND, 5);
	pEncryptSizer->Add(m_pTextCtrlPassword, 0, wxLEFT|wxRIGHT|wxEXPAND, 5);
	pEncryptSizer->Add(pStaticTextRePassword, 0, wxALL|wxEXPAND, 5);
	pEncryptSizer->Add(m_pTextCtrlRePassword, 0, wxLEFT|wxRIGHT|wxBOTTOM|wxEXPAND, 5);
	pEncryptSizer->Add(m_pCheckBoxShowPassword, 0, wxALL|wxEXPAND, 5);
	pEncryptSizer->Add(pEncryptionMethodSizer, 0, wxLEFT|wxRIGHT|wxEXPAND, 0);
	pEncryptSizer->Add(m_pCheckBoxEncryptFileNames, 0, wxALL|wxEXPAND, 5);

	pRightSizer->Add(pStaticTextUpdateMode, 0, wxALL|wxEXPAND, 5);
	pRightSizer->Add(m_pComboBoxUpdateMode, 0, wxALL|wxEXPAND, 5);

	pRightSizer->Add(pStaticTextPathMode, 0, wxALL|wxEXPAND, 5);
	pRightSizer->Add(m_pComboBoxPathMode, 0, wxALL|wxEXPAND, 5);

	pRightSizer->Add(pOptionsSizer, 1, wxALL|wxEXPAND, 5);
	pRightSizer->Add(pEncryptSizer, 0, wxALL|wxEXPAND, 5);

	pControlSizer->Add(pLeftSizer, 1, wxALL|wxEXPAND, 5);
	pControlSizer->Add(pRightSizer, 1, wxALL|wxEXPAND, 5);
	wxStaticText *pStaticTextParameters = new wxStaticText(this, IDT_COMPRESS_PARAMETERS, wxT("&Parameters:"));
	m_pTextCtrlParameters = new wxTextCtrl(this, IDE_COMPRESS_PARAMETERS, wxEmptyString);
	topsizer->Add(pStaticTextArchive, 0, wxLEFT | wxRIGHT | wxTOP |wxEXPAND, 10);
	topsizer->Add(pArchiveNameSizer, 1, wxLEFT | wxRIGHT |wxEXPAND, 5);
	topsizer->Add(pControlSizer, 0, wxALL|wxEXPAND, 5);
	topsizer->Add(pStaticTextParameters, 0, wxLEFT | wxRIGHT | wxBOTTOM |wxEXPAND, 10);
	topsizer->Add(m_pTextCtrlParameters, 0, wxLEFT | wxRIGHT |wxEXPAND, 10);
	topsizer->Add(CreateButtonSizer(wxOK | wxCANCEL | wxHELP), 0, wxALL|wxEXPAND, 10);

	this->OnInit();

	SetSizer(topsizer); // use the sizer for layout
	topsizer->SetSizeHints(this); // set size hints to honour minimum size
  }
private:
	// Any class wishing to process wxWindows events must use this macro
	DECLARE_EVENT_TABLE()
};

static CStringTable g_stringTable[] =
{
    { IDS_PASSWORD_NOT_MATCH  ,L"Passwords do not match" },
    { IDS_PASSWORD_USE_ASCII  ,L"Use only English letters, numbers and special characters (!, #, $, ...) for password." },
    { IDS_PASSWORD_TOO_LONG   ,L"Password is too long" },

    { IDS_METHOD_STORE    ,L"Store" },
    { IDS_METHOD_FASTEST  ,L"Fastest" },
    { IDS_METHOD_FAST     ,L"Fast" },
    { IDS_METHOD_NORMAL   ,L"Normal" },
    { IDS_METHOD_MAXIMUM  ,L"Maximum" },
    { IDS_METHOD_ULTRA    ,L"Ultra" },

    { IDS_COMPRESS_UPDATE_MODE_ADD    ,L"Add and replace files" },
    { IDS_COMPRESS_UPDATE_MODE_UPDATE ,L"Update and add files" },
    { IDS_COMPRESS_UPDATE_MODE_FRESH  ,L"Freshen existing files" },
    { IDS_COMPRESS_UPDATE_MODE_SYNC   ,L"Synchronize files" },

    { IDS_OPEN_TYPE_ALL_FILES  ,L"All Files" },
    { IDS_COMPRESS_SET_ARCHIVE_BROWSE  ,L"Browse" },

    { IDS_COMPRESS_NON_SOLID  ,L"Non-solid" },
    { IDS_COMPRESS_SOLID      ,L"Solid" },

    { IDS_SPLIT_CONFIRM  ,L"Specified volume size: {0} bytes.\nAre you sure you want to split archive into such volumes?" },


	{ 0 , 0 }
};

REGISTER_DIALOG(IDD_COMPRESS,CCompressDialog,g_stringTable)

BEGIN_EVENT_TABLE(CCompressDialogImpl, wxDialog)
	EVT_BUTTON(wxID_ANY,   CModalDialogImpl::OnAnyButton)
	EVT_CHECKBOX(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_COMBOBOX(wxID_ANY, CModalDialogImpl::OnAnyChoice)
	EVT_MENU(WORKER_EVENT, CModalDialogImpl::OnWorkerEvent)
END_EVENT_TABLE()

// ExtractDialog.cpp

#include "StdAfx.h"

#include "../../../Common/StringConvert.h"
#include "../../../Common/Wildcard.h"

#include "../../../Windows/FileName.h"
#include "../../../Windows/FileDir.h"
#include "../../../Windows/ResourceString.h"

#ifndef NO_REGISTRY
#include "../FileManager/HelpUtils.h"
#endif


#include "../FileManager/BrowseDialog.h"
#include "../FileManager/LangUtils.h"
#include "../FileManager/resourceGui.h"

#include "ExtractDialog.h"
#include "ExtractDialogRes.h"
#include "ExtractRes.h"

using namespace NWindows;
using namespace NFile;
using namespace NName;

extern HINSTANCE g_hInstance;

static const UInt32 kPathMode_IDs[] =
{
  IDS_EXTRACT_PATHS_FULL,
  IDS_EXTRACT_PATHS_NO,
  IDS_EXTRACT_PATHS_ABS
};

static const UInt32 kOverwriteMode_IDs[] =
{
  IDS_EXTRACT_OVERWRITE_ASK,
  IDS_EXTRACT_OVERWRITE_WITHOUT_PROMPT,
  IDS_EXTRACT_OVERWRITE_SKIP_EXISTING,
  IDS_EXTRACT_OVERWRITE_RENAME,
  IDS_EXTRACT_OVERWRITE_RENAME_EXISTING
};

#ifndef _SFX

static const
  // NExtract::NPathMode::EEnum
  int
  kPathModeButtonsVals[] =
{
  NExtract::NPathMode::kFullPaths,
  NExtract::NPathMode::kNoPaths,
  NExtract::NPathMode::kAbsPaths
};

static const
  int
  // NExtract::NOverwriteMode::EEnum
  kOverwriteButtonsVals[] =
{
  NExtract::NOverwriteMode::kAsk,
  NExtract::NOverwriteMode::kOverwrite,
  NExtract::NOverwriteMode::kSkip,
  NExtract::NOverwriteMode::kRename,
  NExtract::NOverwriteMode::kRenameExisting
};

#endif

#ifdef LANG

static const UInt32 kLangIDs[] =
{
  IDT_EXTRACT_EXTRACT_TO,
  IDT_EXTRACT_PATH_MODE,
  IDT_EXTRACT_OVERWRITE_MODE,
  // IDX_EXTRACT_ALT_STREAMS,
  IDX_EXTRACT_NT_SECUR,
  IDX_EXTRACT_ELIM_DUP,
  IDG_PASSWORD,
  IDX_PASSWORD_SHOW
};
#endif

// static const int kWildcardsButtonIndex = 2;

#ifndef NO_REGISTRY
static const unsigned kHistorySize = 16;
#endif

#ifndef _SFX

// it's used in CompressDialog also
void AddComboItems(NControl::CComboBox &combo, const UInt32 *langIDs, unsigned numItems, const int *values, int curVal)
{
  int curSel = 0;
  for (unsigned i = 0; i < numItems; i++)
  {
    UString s = LangString(langIDs[i]);
    s.RemoveChar(L'&');
    int index = (int)combo.AddString(s);
    combo.SetItemData(index, i);
    if (values[i] == curVal)
      curSel = i;
  }
  combo.SetCurSel(curSel);
}

// it's used in CompressDialog also
bool GetBoolsVal(const CBoolPair &b1, const CBoolPair &b2)
{
  if (b1.Def) return b1.Val;
  if (b2.Def) return b2.Val;
  return b1.Val;
}

void CExtractDialog::CheckButton_TwoBools(UINT id, const CBoolPair &b1, const CBoolPair &b2)
{
  CheckButton(id, GetBoolsVal(b1, b2));
}

void CExtractDialog::GetButton_Bools(UINT id, CBoolPair &b1, CBoolPair &b2)
{
  bool val = IsButtonCheckedBool(id);
  bool oldVal = GetBoolsVal(b1, b2);
  if (val != oldVal)
    b1.Def = b2.Def = true;
  b1.Val = b2.Val = val;
}

#endif

bool CExtractDialog::OnInit()
{
  #ifdef LANG
  {
    UString s;
    LangString_OnlyFromLangFile(IDD_EXTRACT, s);
    if (s.IsEmpty())
      GetText(s);
    if (!ArcPath.IsEmpty())
    {
      s.AddAscii(" : ");
      s += ArcPath;
    }
    SetText(s);
    // LangSetWindowText(*this, IDD_EXTRACT);
    LangSetDlgItems(*this, kLangIDs, ARRAY_SIZE(kLangIDs));
  }
  #endif
  
  #ifndef _SFX
  _passwordControl.Attach(GetItem(IDE_EXTRACT_PASSWORD));
  _passwordControl.SetText(Password);
  _passwordControl.SetPasswordChar(TEXT('*'));
  _pathName.Attach(GetItem(IDE_EXTRACT_NAME));
  #endif

  #ifdef NO_REGISTRY
  
  PathMode = NExtract::NPathMode::kFullPaths;
  OverwriteMode = NExtract::NOverwriteMode::kAsk;
  
  #else
  
  _info.Load();

  if (_info.PathMode == NExtract::NPathMode::kCurPaths)
    _info.PathMode = NExtract::NPathMode::kFullPaths;

  if (!PathMode_Force && _info.PathMode_Force)
    PathMode = _info.PathMode;
  if (!OverwriteMode_Force && _info.OverwriteMode_Force)
    OverwriteMode = _info.OverwriteMode;

  // CheckButton_TwoBools(IDX_EXTRACT_ALT_STREAMS, AltStreams, _info.AltStreams);
  CheckButton_TwoBools(IDX_EXTRACT_NT_SECUR,    NtSecurity, _info.NtSecurity);
  CheckButton_TwoBools(IDX_EXTRACT_ELIM_DUP,    ElimDup,    _info.ElimDup);
  
  CheckButton(IDX_PASSWORD_SHOW, _info.ShowPassword.Val);
  UpdatePasswordControl();

  #endif

  _path.Attach(GetItem(IDC_EXTRACT_PATH));

  UString pathPrefix = DirPath;

  #ifndef _SFX
  
  if (_info.SplitDest.Val)
  {
    CheckButton(IDX_EXTRACT_NAME_ENABLE, true);
    UString pathName;
    SplitPathToParts_Smart(DirPath, pathPrefix, pathName);
    if (pathPrefix.IsEmpty())
      pathPrefix = pathName;
    else
      _pathName.SetText(pathName);
  }
  else
    ShowItem_Bool(IDE_EXTRACT_NAME, false);

  #endif

  _path.SetText(pathPrefix);

  #ifndef NO_REGISTRY
  for (unsigned i = 0; i < _info.Paths.Size() && i < kHistorySize; i++)
    _path.AddString(_info.Paths[i]);
  #endif

  /*
  if (_info.Paths.Size() > 0)
    _path.SetCurSel(0);
  else
    _path.SetCurSel(-1);
  */

  #ifndef _SFX

  _pathMode.Attach(GetItem(IDC_EXTRACT_PATH_MODE));
  _overwriteMode.Attach(GetItem(IDC_EXTRACT_OVERWRITE_MODE));

  AddComboItems(_pathMode, kPathMode_IDs, ARRAY_SIZE(kPathMode_IDs), kPathModeButtonsVals, PathMode);
  AddComboItems(_overwriteMode, kOverwriteMode_IDs, ARRAY_SIZE(kOverwriteMode_IDs), kOverwriteButtonsVals, OverwriteMode);

  #endif

#ifdef _WIN32
  HICON icon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON));
  SetIcon(ICON_BIG, icon);
#endif
 
  // CWindow filesWindow = GetItem(IDC_EXTRACT_RADIO_FILES);
  // filesWindow.Enable(_enableFilesButton);

  NormalizePosition();

  return CModalDialog::OnInit();
}

#ifndef _SFX
void CExtractDialog::UpdatePasswordControl()
{
  _passwordControl.SetPasswordChar(IsShowPasswordChecked() ? 0 : TEXT('*'));
  UString password;
  _passwordControl.GetText(password);
  _passwordControl.SetText(password);
}
#endif

bool CExtractDialog::OnButtonClicked(int buttonID, HWND buttonHWND)
{
  switch (buttonID)
  {
    case IDB_EXTRACT_SET_PATH:
      OnButtonSetPath();
      return true;
    #ifndef _SFX
    case IDX_EXTRACT_NAME_ENABLE:
      ShowItem_Bool(IDE_EXTRACT_NAME, IsButtonCheckedBool(IDX_EXTRACT_NAME_ENABLE));
      return true;
    case IDX_PASSWORD_SHOW:
    {
      UpdatePasswordControl();
      return true;
    }
    #endif
  }
  return CModalDialog::OnButtonClicked(buttonID, buttonHWND);
}

void CExtractDialog::OnButtonSetPath()
{
  UString currentPath;
  _path.GetText(currentPath);
  UString title = LangString(IDS_EXTRACT_SET_FOLDER);
  UString resultPath;
  if (!MyBrowseForFolder(*this, title, currentPath, resultPath))
    return;
  #ifndef NO_REGISTRY
  _path.SetCurSel(-1);
  #endif
  _path.SetText(resultPath);
}

void AddUniqueString(UStringVector &list, const UString &s)
{
  FOR_VECTOR (i, list)
    if (s.IsEqualTo_NoCase(list[i]))
      return;
  list.Add(s);
}

void CExtractDialog::OnOK()
{
  #ifndef _SFX
  int pathMode2 = kPathModeButtonsVals[_pathMode.GetCurSel()];
  if (PathMode != NExtract::NPathMode::kCurPaths ||
      pathMode2 != NExtract::NPathMode::kFullPaths)
    PathMode = (NExtract::NPathMode::EEnum)pathMode2;

  OverwriteMode = (NExtract::NOverwriteMode::EEnum)kOverwriteButtonsVals[_overwriteMode.GetCurSel()];

  // _filesMode = (NExtractionDialog::NFilesMode::EEnum)GetFilesMode();

  _passwordControl.GetText(Password);

  #endif

  #ifndef NO_REGISTRY

  // GetButton_Bools(IDX_EXTRACT_ALT_STREAMS, AltStreams, _info.AltStreams);
  GetButton_Bools(IDX_EXTRACT_NT_SECUR,    NtSecurity, _info.NtSecurity);
  GetButton_Bools(IDX_EXTRACT_ELIM_DUP,    ElimDup,    _info.ElimDup);

  bool showPassword = IsShowPasswordChecked();
  if (showPassword != _info.ShowPassword.Val)
  {
    _info.ShowPassword.Def = true;
    _info.ShowPassword.Val = showPassword;
  }

  if (_info.PathMode != pathMode2)
  {
    _info.PathMode_Force = true;
    _info.PathMode = (NExtract::NPathMode::EEnum)pathMode2;
    /*
    // we allow kAbsPaths in registry.
    if (_info.PathMode == NExtract::NPathMode::kAbsPaths)
      _info.PathMode = NExtract::NPathMode::kFullPaths;
    */
  }

  if (!OverwriteMode_Force && _info.OverwriteMode != OverwriteMode)
    _info.OverwriteMode_Force = true;
  _info.OverwriteMode = OverwriteMode;


  #else
  
  ElimDup.Val = IsButtonCheckedBool(IDX_EXTRACT_ELIM_DUP);

  #endif
  
  UString s;
  
  #ifdef NO_REGISTRY
  
  _path.GetText(s);
  
  #else

  int currentItem = _path.GetCurSel();
  if (currentItem == CB_ERR)
  {
    _path.GetText(s);
    if (_path.GetCount() >= kHistorySize)
      currentItem = _path.GetCount() - 1;
  }
  else
    _path.GetLBText(currentItem, s);
  
  #endif

  s.Trim();
  NName::NormalizeDirPathPrefix(s);
  
  #ifndef _SFX
  
  bool splitDest = IsButtonCheckedBool(IDX_EXTRACT_NAME_ENABLE);
  if (splitDest)
  {
    UString pathName;
    _pathName.GetText(pathName);
    pathName.Trim();
    s += pathName;
    NName::NormalizeDirPathPrefix(s);
  }
  if (splitDest != _info.SplitDest.Val)
  {
    _info.SplitDest.Def = true;
    _info.SplitDest.Val = splitDest;
  }

  #endif

  DirPath = s;
  
  #ifndef NO_REGISTRY
  _info.Paths.Clear();
  #ifndef _SFX
  AddUniqueString(_info.Paths, s);
  #endif
  for (int i = 0; i < _path.GetCount(); i++)
    if (i != currentItem)
    {
      UString sTemp;
      _path.GetLBText(i, sTemp);
      sTemp.Trim();
      AddUniqueString(_info.Paths, sTemp);
    }
  _info.Save();
  #endif
  
  CModalDialog::OnOK();
}

#ifndef NO_REGISTRY
static LPCWSTR kHelpTopic = L"fm/plugins/7-zip/extract.htm";
void CExtractDialog::OnHelp()
{
  ShowHelpWindow(NULL, kHelpTopic);
  CModalDialog::OnHelp();
}
#endif
// ExtractDialog.h

#ifndef __EXTRACT_DIALOG_H
#define __EXTRACT_DIALOG_H

#include "ExtractDialogRes.h"

#include "../../../Windows/Control/ComboBox.h"
#include "../../../Windows/Control/Edit.h"

#include "../Common/ExtractMode.h"

#include "../FileManager/DialogSize.h"

#ifndef NO_REGISTRY
#include "../Common/ZipRegistry.h"
#endif

namespace NExtractionDialog
{
  /*
  namespace NFilesMode
  {
    enum EEnum
    {
      kSelected,
      kAll,
      kSpecified
    };
  }
  */
}

class CExtractDialog: public NWindows::NControl::CModalDialog
{
  #ifdef NO_REGISTRY
  NWindows::NControl::CDialogChildControl _path;
  #else
  NWindows::NControl::CComboBox _path;
  #endif

  #ifndef _SFX
  NWindows::NControl::CEdit _pathName;
  NWindows::NControl::CEdit _passwordControl;
  NWindows::NControl::CComboBox _pathMode;
  NWindows::NControl::CComboBox _overwriteMode;
  #endif

  #ifndef _SFX
  // int GetFilesMode() const;
  void UpdatePasswordControl();
  #endif
  
  void OnButtonSetPath();

  void CheckButton_TwoBools(UINT id, const CBoolPair &b1, const CBoolPair &b2);
  void GetButton_Bools(UINT id, CBoolPair &b1, CBoolPair &b2);
  virtual bool OnInit();
  virtual bool OnButtonClicked(int buttonID, HWND buttonHWND);
  virtual void OnOK();
  
  #ifndef NO_REGISTRY

  virtual void OnHelp();

  NExtract::CInfo _info;
  
  #endif
  
  bool IsShowPasswordChecked() const { return IsButtonCheckedBool(IDX_PASSWORD_SHOW); }
public:
  // bool _enableSelectedFilesButton;
  // bool _enableFilesButton;
  // NExtractionDialog::NFilesMode::EEnum FilesMode;

  UString DirPath;
  UString ArcPath;

  #ifndef _SFX
  UString Password;
  #endif
  bool PathMode_Force;
  bool OverwriteMode_Force;
  NExtract::NPathMode::EEnum PathMode;
  NExtract::NOverwriteMode::EEnum OverwriteMode;

  #ifndef _SFX
  // CBoolPair AltStreams;
  CBoolPair NtSecurity;
  #endif

  CBoolPair ElimDup;

  INT_PTR Create(HWND aWndParent = 0)
  {
    #ifdef _SFX
    BIG_DIALOG_SIZE(240, 64);
    #else
    BIG_DIALOG_SIZE(300, 160);
    #endif
    return CModalDialog::Create(SIZED_DIALOG(IDD_EXTRACT), aWndParent);
  }

  CExtractDialog():
    PathMode_Force(false),
    OverwriteMode_Force(false)
  {
    ElimDup.Val = true;
  }

};

#endif
#define IDD_EXTRACT     3400
#define IDD_EXTRACT_2  13400

#define IDC_EXTRACT_PATH             100
#define IDB_EXTRACT_SET_PATH         101
#define IDC_EXTRACT_PATH_MODE        102
#define IDC_EXTRACT_OVERWRITE_MODE   103

#define IDE_EXTRACT_PASSWORD         120

#define IDE_EXTRACT_NAME             130
#define IDX_EXTRACT_NAME_ENABLE      131


#define IDT_EXTRACT_EXTRACT_TO      3401
#define IDT_EXTRACT_PATH_MODE       3410
#define IDT_EXTRACT_OVERWRITE_MODE  3420

#define IDX_EXTRACT_ELIM_DUP        3430
#define IDX_EXTRACT_NT_SECUR        3431
// #define IDX_EXTRACT_ALT_STREAMS     3432

#define IDX_PASSWORD_SHOW           3803
#define IDG_PASSWORD                3807
// ExtractDialog.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif 

#undef _WIN32

#include "Windows/Control/DialogImpl.h"

#include "ExtractRes.h"
#include "ExtractDialogRes.h"

/*
IDD_EXTRACT  DIALOG  0, 0, xs, ys  MY_MODAL_DIALOG_STYLE  MY_FONT
CAPTION "Extract"
BEGIN
  LTEXT     "E&xtract to:", IDT_EXTRACT_EXTRACT_TO, m, m, xc, 8
  COMBOBOX  IDC_EXTRACT_PATH, m, m + 12, xc - bxsDots - 12, 100, MY_COMBO_WITH_EDIT
  PUSHBUTTON  "...", IDB_EXTRACT_SET_PATH, xs - m - bxsDots, m + 12 - 2, bxsDots, bys, WS_GROUP

  CONTROL   "", IDX_EXTRACT_NAME_ENABLE, MY_CHECKBOX, m, m + 34, 12, 10
  EDITTEXT  IDE_EXTRACT_NAME, m + 12 + 2, m + 32, g1xs - 12 - 2, 14, ES_AUTOHSCROLL

  LTEXT     "Path mode:", IDT_EXTRACT_PATH_MODE, m, m + 52, g1xs, 8
  COMBOBOX  IDC_EXTRACT_PATH_MODE, m, m + 64, g1xs, 140, MY_COMBO

  CONTROL   "Eliminate duplication of root folder", IDX_EXTRACT_ELIM_DUP, MY_CHECKBOX,
            m, m + 84, g1xs, 10

  LTEXT     "Overwrite mode:", IDT_EXTRACT_OVERWRITE_MODE, m, m + 104, g1xs, 8
  COMBOBOX  IDC_EXTRACT_OVERWRITE_MODE, m, m + 116, g1xs, 140, MY_COMBO


  GROUPBOX  "Password", IDG_PASSWORD, g2x, m + 36, g2xs, GROUP_Y_SIZE
  EDITTEXT  IDE_EXTRACT_PASSWORD, g2x2, m + 50, g2xs2, 14, ES_PASSWORD | ES_AUTOHSCROLL
  CONTROL   "Show Password", IDX_PASSWORD_SHOW, MY_CHECKBOX, g2x2, m + 72, g2xs2, 10

//  CONTROL   "Restore alternate data streams", IDX_EXTRACT_ALT_STREAMS, MY_CHECKBOX,
//            g2x, m + 104, g2xs, 10
  CONTROL   "Restore file security", IDX_EXTRACT_NT_SECUR, MY_CHECKBOX,
            g2x, m + 104, g2xs, 10
  
  DEFPUSHBUTTON  "OK",     IDOK,     bx3, by, bxs, bys, WS_GROUP
  PUSHBUTTON     "Cancel", IDCANCEL, bx2, by, bxs, bys
  PUSHBUTTON     "Help",   IDHELP,   bx1, by, bxs, bys
END
*/


class CExtractDialogImpl : public NWindows::NControl::CModalDialogImpl
{
 public:
   CExtractDialogImpl(NWindows::NControl::CModalDialog *dialog,wxWindow * parent , int id) : CModalDialogImpl(dialog,parent, id, wxT("Extract"))
  {
	wxStaticText *m_pStaticTextExtractTo;
	wxTextCtrl *m_pTextCtrlPassword;
	wxButton *m_pButtonBrowse;
	wxComboBox *m_pComboBoxExtractTo;
	wxCheckBox *m_pCheckBoxShowPassword;

	wxTextCtrl *m_pTextCtrlName;
	wxCheckBox *m_pCheckBoxNameEnable;

	wxComboBox *m_pPathMode;

	wxCheckBox * m_pCheckBoxElimDup;
	wxCheckBox * m_pCheckBoxNtSecur;

	wxComboBox *m_pOverWriteMode;

	///Sizer for adding the controls created by users
	wxBoxSizer* topsizer = new wxBoxSizer(wxVERTICAL);

	wxArrayString pathArray;
	m_pStaticTextExtractTo = new wxStaticText(this, IDT_EXTRACT_EXTRACT_TO, wxT("E&xtract To:"));
	wxBoxSizer *pPathSizer = new wxBoxSizer(wxHORIZONTAL);
	// m_pComboBoxExtractTo = new wxComboBox(this, IDC_EXTRACT_PATH, wxEmptyString, wxDefaultPosition, wxDefaultSize, pathArray, wxCB_DROPDOWN|wxCB_SORT);
	m_pComboBoxExtractTo = new wxComboBox(this, IDC_EXTRACT_PATH, wxEmptyString, wxDefaultPosition, wxSize(600,-1), pathArray, wxCB_DROPDOWN|wxCB_SORT);
	m_pButtonBrowse = new wxButton(this, IDB_EXTRACT_SET_PATH, wxT("..."), wxDefaultPosition, wxDefaultSize, wxBU_EXACTFIT);
	pPathSizer->Add(m_pComboBoxExtractTo, 1, wxLEFT|wxRIGHT|wxEXPAND, 5);
	pPathSizer->Add(m_pButtonBrowse, 0, wxLEFT|wxRIGHT|wxEXPAND, 5);

	wxBoxSizer *pControlSizer = new wxBoxSizer(wxHORIZONTAL);

	wxStaticBoxSizer * grpPathMode = new wxStaticBoxSizer(new wxStaticBox(this,IDT_EXTRACT_PATH_MODE,_T("Path mode :")),wxVERTICAL);

	m_pPathMode = new wxComboBox(this, IDC_EXTRACT_PATH_MODE, wxEmptyString, wxDefaultPosition, wxDefaultSize, pathArray, wxCB_DROPDOWN);

	grpPathMode->Add(m_pPathMode, 1, wxLEFT|wxRIGHT|wxEXPAND, 5);

	wxBoxSizer *pLeftSizer  = new wxBoxSizer(wxVERTICAL);
	wxBoxSizer *pRightSizer = new wxBoxSizer(wxVERTICAL);


	m_pTextCtrlName = new wxTextCtrl(this, IDE_EXTRACT_NAME, wxEmptyString, wxDefaultPosition, wxDefaultSize);
	m_pCheckBoxNameEnable = new wxCheckBox(this, IDX_EXTRACT_NAME_ENABLE, wxT(""));

	m_pCheckBoxElimDup = new wxCheckBox(this, IDX_EXTRACT_ELIM_DUP, wxT("Eliminate duplication of root folder"));

	m_pCheckBoxNtSecur = new wxCheckBox(this, IDX_EXTRACT_NT_SECUR, wxT("Restore file security"));

	wxStaticBoxSizer * grpOverWriteMode = new wxStaticBoxSizer(new wxStaticBox(this,IDT_EXTRACT_OVERWRITE_MODE,wxT("Overwrite mode :")),wxVERTICAL);
	m_pOverWriteMode = new wxComboBox(this, IDC_EXTRACT_OVERWRITE_MODE, wxEmptyString, wxDefaultPosition, wxDefaultSize, pathArray, wxCB_DROPDOWN);
	grpOverWriteMode->Add(m_pOverWriteMode, 1, wxLEFT|wxRIGHT|wxEXPAND, 5);



	wxStaticBoxSizer *pPasswordSizer = new wxStaticBoxSizer(new wxStaticBox(this,IDG_PASSWORD,wxT("Password")),wxVERTICAL);
	m_pTextCtrlPassword = new wxTextCtrl(this, IDE_EXTRACT_PASSWORD, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PASSWORD);
	m_pCheckBoxShowPassword = new wxCheckBox(this, IDX_PASSWORD_SHOW, wxT("Show Password"));
	pPasswordSizer->Add(m_pTextCtrlPassword, 0, wxALL|wxEXPAND, 5);
	pPasswordSizer->Add(m_pCheckBoxShowPassword, 0, wxALL|wxEXPAND, 5);

	pLeftSizer->Add(m_pCheckBoxNameEnable, 0, wxALL|wxEXPAND, 5);
	pLeftSizer->Add(m_pTextCtrlName, 1, wxALL|wxEXPAND, 5);

	pLeftSizer->Add(grpPathMode, 1, wxALL|wxEXPAND, 5);
	pLeftSizer->Add(m_pCheckBoxElimDup, 1, wxALL|wxEXPAND, 5);
	pLeftSizer->Add(grpOverWriteMode, 0, wxALL|wxEXPAND, 5);

	pRightSizer->Add(pPasswordSizer, 0, wxALL|wxEXPAND, 5);
	pRightSizer->Add(m_pCheckBoxNtSecur, 1, wxALL|wxEXPAND, 5);

	pControlSizer->Add(pLeftSizer, 1, wxALL|wxEXPAND, 5);
	pControlSizer->Add(pRightSizer, 1, wxLEFT | wxRIGHT | wxEXPAND, 5);

	topsizer->Add(m_pStaticTextExtractTo, 0, wxALL | wxEXPAND , 10);
	topsizer->Add(pPathSizer, 0, wxLEFT | wxRIGHT | wxBOTTOM | wxEXPAND , 5);
	topsizer->Add(pControlSizer, 1, wxALL | wxEXPAND , 5);
	topsizer->Add(CreateButtonSizer(wxOK | wxCANCEL | wxHELP), 0, wxALL | wxEXPAND , 5);

	this->OnInit();

	SetSizer(topsizer); // use the sizer for layout
	topsizer->SetSizeHints(this); // set size hints to honour minimum size
  }
private:
	// Any class wishing to process wxWindows events must use this macro
	DECLARE_EVENT_TABLE()
};

REGISTER_DIALOG(IDD_EXTRACT,CExtractDialog,0)

BEGIN_EVENT_TABLE(CExtractDialogImpl, wxDialog)
	EVT_BUTTON(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_CHECKBOX(wxID_ANY, CModalDialogImpl::OnAnyButton)
	EVT_MENU(WORKER_EVENT, CModalDialogImpl::OnWorkerEvent)
END_EVENT_TABLE()

// ExtractGUI.cpp

#include "StdAfx.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/FileDir.h"
#include "../../../Windows/FileFind.h"
#include "../../../Windows/FileName.h"
#include "../../../Windows/Thread.h"

#include "../FileManager/ExtractCallback.h"
#include "../FileManager/FormatUtils.h"
#include "../FileManager/LangUtils.h"
#include "../FileManager/resourceGui.h"
#include "../FileManager/OverwriteDialogRes.h"

#include "../Common/ArchiveExtractCallback.h"
#include "../Common/PropIDUtils.h"

#include "../Explorer/MyMessages.h"

#include "resource2.h"
#include "ExtractRes.h"

#include "ExtractDialog.h"
#include "ExtractGUI.h"
#include "HashGUI.h"

#include "../FileManager/PropertyNameRes.h"

using namespace NWindows;
using namespace NFile;
using namespace NDir;

static const wchar_t *kIncorrectOutDir = L"Incorrect output directory path";

#ifndef _SFX

static void AddValuePair(UString &s, UINT resourceID, UInt64 value, bool addColon = true)
{
  AddLangString(s, resourceID);
  if (addColon)
    s += L':';
  s.Add_Space();
  char sz[32];
  ConvertUInt64ToString(value, sz);
  s.AddAscii(sz);
  s.Add_LF();
}

static void AddSizePair(UString &s, UINT resourceID, UInt64 value)
{
  wchar_t sz[32];
  AddLangString(s, resourceID);
  s += L": ";
  ConvertUInt64ToString(value, sz);
  s += MyFormatNew(IDS_FILE_SIZE, sz);
  // s += sz;
  if (value >= (1 << 20))
  {
    ConvertUInt64ToString(value >> 20, sz);
    s += L" (";
    s += sz;
    s += L" MB)";
  }
  s.Add_LF();
}

#endif

class CThreadExtracting: public CProgressThreadVirt
{
  HRESULT ProcessVirt();
public:
  CCodecs *codecs;
  CExtractCallbackImp *ExtractCallbackSpec;
  const CObjectVector<COpenType> *FormatIndices;
  const CIntVector *ExcludedFormatIndices;

  UStringVector *ArchivePaths;
  UStringVector *ArchivePathsFull;
  const NWildcard::CCensorNode *WildcardCensor;
  const CExtractOptions *Options;
  #ifndef _SFX
  CHashBundle *HashBundle;
  #endif
  CMyComPtr<IExtractCallbackUI> ExtractCallback;
  UString Title;
};

HRESULT CThreadExtracting::ProcessVirt()
{
  CDecompressStat Stat;
  #ifndef _SFX
  if (HashBundle)
    HashBundle->Init();
  #endif

  HRESULT res = Extract(codecs,
      *FormatIndices, *ExcludedFormatIndices,
      *ArchivePaths, *ArchivePathsFull,
      *WildcardCensor, *Options, ExtractCallbackSpec, ExtractCallback,
      #ifndef _SFX
        HashBundle,
      #endif
      FinalMessage.ErrorMessage.Message, Stat);
  #ifndef _SFX
  if (res == S_OK && Options->TestMode && ExtractCallbackSpec->IsOK())
  {
    UString s;
    
    AddValuePair(s, IDS_ARCHIVES_COLON, Stat.NumArchives, false);
    AddSizePair(s, IDS_PROP_PACKED_SIZE, Stat.PackSize);

    if (!HashBundle)
    {
      if (Stat.NumFolders != 0)
        AddValuePair(s, IDS_PROP_FOLDERS, Stat.NumFolders);
      AddValuePair(s, IDS_PROP_FILES, Stat.NumFiles);
      AddSizePair(s, IDS_PROP_SIZE, Stat.UnpackSize);
      if (Stat.NumAltStreams != 0)
      {
        s.Add_LF();
        AddValuePair(s, IDS_PROP_NUM_ALT_STREAMS, Stat.NumAltStreams);
        AddSizePair(s, IDS_PROP_ALT_STREAMS_SIZE, Stat.AltStreams_UnpackSize);
      }
    }
    
    if (HashBundle)
    {
      s.Add_LF();
      AddHashBundleRes(s, *HashBundle, UString());
    }
    
    s.Add_LF();
    AddLangString(s, IDS_MESSAGE_NO_ERRORS);
    
    FinalMessage.OkMessage.Title = Title;
    FinalMessage.OkMessage.Message = s;
  }
  #endif
  return res;
}

HRESULT ExtractGUI(
    CCodecs *codecs,
    const CObjectVector<COpenType> &formatIndices,
    const CIntVector &excludedFormatIndices,
    UStringVector &archivePaths,
    UStringVector &archivePathsFull,
    const NWildcard::CCensorNode &wildcardCensor,
    CExtractOptions &options,
    #ifndef _SFX
    CHashBundle *hb,
    #endif
    bool showDialog,
    bool &messageWasDisplayed,
    CExtractCallbackImp *extractCallback,
    HWND hwndParent)
{
  messageWasDisplayed = false;

  CThreadExtracting extracter;
  extracter.codecs = codecs;
  extracter.FormatIndices = &formatIndices;
  extracter.ExcludedFormatIndices = &excludedFormatIndices;

  if (!options.TestMode)
  {
    FString outputDir = options.OutputDir;
    #ifndef UNDER_CE
    if (outputDir.IsEmpty())
      GetCurrentDir(outputDir);
    #endif
    if (showDialog)
    {
      CExtractDialog dialog;
      FString outputDirFull;
      if (!MyGetFullPathName(outputDir, outputDirFull))
      {
        ShowErrorMessage(kIncorrectOutDir);
        messageWasDisplayed = true;
        return E_FAIL;
      }
      NName::NormalizeDirPathPrefix(outputDirFull);

      dialog.DirPath = fs2us(outputDirFull);
#ifndef _WIN32
      {
	extern const TCHAR * nameWindowToUnix(const TCHAR * lpFileName);
        UString tmpDirectoryPath = dialog.DirPath;
	dialog.DirPath = nameWindowToUnix(tmpDirectoryPath);
      }
#endif

      dialog.OverwriteMode = options.OverwriteMode;
      dialog.OverwriteMode_Force = options.OverwriteMode_Force;
      dialog.PathMode = options.PathMode;
      dialog.PathMode_Force = options.PathMode_Force;
      dialog.ElimDup = options.ElimDup;

      if (archivePathsFull.Size() == 1)
        dialog.ArcPath = archivePathsFull[0];

      #ifndef _SFX
      // dialog.AltStreams = options.NtOptions.AltStreams;
      dialog.NtSecurity = options.NtOptions.NtSecurity;
      if (extractCallback->PasswordIsDefined)
        dialog.Password = extractCallback->Password;
      #endif

      if (dialog.Create(hwndParent) != IDOK)
        return E_ABORT;

      outputDir = us2fs(dialog.DirPath);

      options.OverwriteMode = dialog.OverwriteMode;
      options.PathMode = dialog.PathMode;
      options.ElimDup = dialog.ElimDup;
      
      #ifndef _SFX
      // options.NtOptions.AltStreams = dialog.AltStreams;
      options.NtOptions.NtSecurity = dialog.NtSecurity;
      extractCallback->Password = dialog.Password;
      extractCallback->PasswordIsDefined = !dialog.Password.IsEmpty();
      #endif
    }
    if (!MyGetFullPathName(outputDir, options.OutputDir))
    {
      ShowErrorMessage(kIncorrectOutDir);
      messageWasDisplayed = true;
      return E_FAIL;
    }
    NName::NormalizeDirPathPrefix(options.OutputDir);
    
    /*
    if (!CreateComplexDirectory(options.OutputDir))
    {
      UString s = GetUnicodeString(NError::MyFormatMessage(GetLastError()));
      UString s2 = MyFormatNew(IDS_CANNOT_CREATE_FOLDER,
      #ifdef LANG
      0x02000603,
      #endif
      options.OutputDir);
      s2.Add_LF();
      s2 += s;
      MyMessageBox(s2);
      return E_FAIL;
    }
    */
  }
  
  UString title = LangString(options.TestMode ? IDS_PROGRESS_TESTING : IDS_PROGRESS_EXTRACTING);

  extracter.Title = title;
  extracter.ExtractCallbackSpec = extractCallback;
  extracter.ExtractCallbackSpec->ProgressDialog = &extracter.ProgressDialog;
  extracter.ExtractCallback = extractCallback;
  extracter.ExtractCallbackSpec->Init();

  extracter.ProgressDialog.CompressingMode = false;

  extracter.ArchivePaths = &archivePaths;
  extracter.ArchivePathsFull = &archivePathsFull;
  extracter.WildcardCensor = &wildcardCensor;
  extracter.Options = &options;
  #ifndef _SFX
  extracter.HashBundle = hb;
  #endif

  extracter.ProgressDialog.IconID = IDI_ICON;

  RINOK(extracter.Create(title, hwndParent));
  messageWasDisplayed = extracter.ThreadFinishedOK &
      extracter.ProgressDialog.MessagesDisplayed;
  return extracter.Result;
}
// GUI/ExtractGUI.h

#ifndef __EXTRACT_GUI_H
#define __EXTRACT_GUI_H

#include "../Common/Extract.h"

#include "../FileManager/ExtractCallback.h"

/*
  RESULT can be S_OK, even if there are errors!!!
  if RESULT == S_OK, check extractCallback->IsOK() after ExtractGUI().

  RESULT = E_ABORT - user break.
  RESULT != E_ABORT:
  {
   messageWasDisplayed = true  - message was displayed already.
   messageWasDisplayed = false - there was some internal error, so you must show error message.
  }
*/

HRESULT ExtractGUI(
    CCodecs *codecs,
    const CObjectVector<COpenType> &formatIndices,
    const CIntVector &excludedFormatIndices,
    UStringVector &archivePaths,
    UStringVector &archivePathsFull,
    const NWildcard::CCensorNode &wildcardCensor,
    CExtractOptions &options,
    #ifndef _SFX
    CHashBundle *hb,
    #endif
    bool showDialog,
    bool &messageWasDisplayed,
    CExtractCallbackImp *extractCallback,
    HWND hwndParent = NULL);

#endif
#define IDS_MEM_ERROR                   3000

#define IDS_CANNOT_CREATE_FOLDER        3003
#define IDS_UPDATE_NOT_SUPPORTED        3004
#define IDS_CANT_OPEN_ARCHIVE           3005
#define IDS_CANT_OPEN_ENCRYPTED_ARCHIVE 3006
#define IDS_UNSUPPORTED_ARCHIVE_TYPE    3007

#define IDS_CANT_OPEN_AS_TYPE           3017
#define IDS_IS_OPEN_AS_TYPE             3018
#define IDS_IS_OPEN_WITH_OFFSET         3019

#define IDS_PROGRESS_EXTRACTING         3300

#define IDS_PROGRESS_SKIPPING           3325

#define IDS_EXTRACT_SET_FOLDER          3402

#define IDS_EXTRACT_PATHS_FULL          3411
#define IDS_EXTRACT_PATHS_NO            3412
#define IDS_EXTRACT_PATHS_ABS           3413
#define IDS_PATH_MODE_RELAT             3414

#define IDS_EXTRACT_OVERWRITE_ASK             3421
#define IDS_EXTRACT_OVERWRITE_WITHOUT_PROMPT  3422
#define IDS_EXTRACT_OVERWRITE_SKIP_EXISTING   3423
#define IDS_EXTRACT_OVERWRITE_RENAME          3424
#define IDS_EXTRACT_OVERWRITE_RENAME_EXISTING 3425

#define IDS_EXTRACT_MESSAGE_UNSUPPORTED_METHOD    3700
#define IDS_EXTRACT_MESSAGE_DATA_ERROR            3701
#define IDS_EXTRACT_MESSAGE_CRC_ERROR             3702
#define IDS_EXTRACT_MESSAGE_DATA_ERROR_ENCRYPTED  3703
#define IDS_EXTRACT_MESSAGE_CRC_ERROR_ENCRYPTED   3704

#define IDS_EXTRACT_MSG_WRONG_PSW_GUESS      3710
// #define IDS_EXTRACT_MSG_ENCRYPTED            3711

#define IDS_EXTRACT_MSG_UNSUPPORTED_METHOD   3721
#define IDS_EXTRACT_MSG_DATA_ERROR           3722
#define IDS_EXTRACT_MSG_CRC_ERROR            3723
#define IDS_EXTRACT_MSG_UNAVAILABLE_DATA     3724
#define IDS_EXTRACT_MSG_UEXPECTED_END        3725
#define IDS_EXTRACT_MSG_DATA_AFTER_END       3726
#define IDS_EXTRACT_MSG_IS_NOT_ARC           3727
#define IDS_EXTRACT_MSG_HEADERS_ERROR        3728
#define IDS_EXTRACT_MSG_WRONG_PSW_CLAIM      3729

#define IDS_OPEN_MSG_UNAVAILABLE_START       3763
#define IDS_OPEN_MSG_UNCONFIRMED_START       3764
#define IDS_OPEN_MSG_UNSUPPORTED_FEATURE     3768
// GUI.cpp

#include "StdAfx.h"

#include "../../../../C/Alloc.h"

#include "../../../Common/MyInitGuid.h"

#include "../../../Common/CommandLineParser.h"
#include "../../../Common/IntToString.h"
#include "../../../Common/MyException.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/FileDir.h"
#include "../../../Windows/NtCheck.h"
#ifdef _WIN32
#include "../../../Windows/MemoryLock.h"
#endif

#include "../Common/ArchiveCommandLine.h"
#include "../Common/ExitCode.h"

#include "../FileManager/StringUtils.h"
#include "../FileManager/MyWindowsNew.h"

#include "BenchmarkDialog.h"
#include "ExtractGUI.h"
#include "HashGUI.h"
#include "UpdateGUI.h"

#include "ExtractRes.h"

using namespace NWindows;

HINSTANCE g_hInstance;
#ifndef _UNICODE
#endif

#if 0 // #ifndef UNDER_CE

DWORD g_ComCtl32Version;

static DWORD GetDllVersion(LPCTSTR dllName)
{
  DWORD dwVersion = 0;
  HINSTANCE hinstDll = LoadLibrary(dllName);
  if (hinstDll)
  {
    DLLGETVERSIONPROC pDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstDll, "DllGetVersion");
    if (pDllGetVersion)
    {
      DLLVERSIONINFO dvi;
      ZeroMemory(&dvi, sizeof(dvi));
      dvi.cbSize = sizeof(dvi);
      HRESULT hr = (*pDllGetVersion)(&dvi);
      if (SUCCEEDED(hr))
        dwVersion = MAKELONG(dvi.dwMinorVersion, dvi.dwMajorVersion);
    }
    FreeLibrary(hinstDll);
  }
  return dwVersion;
}

#endif

bool g_LVN_ITEMACTIVATE_Support = true;

static void ErrorMessage(LPCWSTR message)
{
  MessageBoxW(NULL, message, L"7-Zip", MB_ICONERROR | MB_OK);
}

static void ErrorLangMessage(UINT resourceID)
{
  ErrorMessage(LangString(resourceID));
}

static const char *kNoFormats = "7-Zip cannot find the code that works with archives.";

static int ShowMemErrorMessage()
{
  ErrorLangMessage(IDS_MEM_ERROR);
  return NExitCode::kMemoryError;
}

static int ShowSysErrorMessage(DWORD errorCode)
{
  if (errorCode == E_OUTOFMEMORY)
    return ShowMemErrorMessage();
  ErrorMessage(HResultToMessage(errorCode));
  return NExitCode::kFatalError;
}

static void ThrowException_if_Error(HRESULT res)
{
  if (res != S_OK)
    throw CSystemException(res);
}

static int Main2(int argc,TCHAR **argv)
{
  UStringVector commandStrings;
#ifdef _WIN32
  NCommandLineParser::SplitCommandLine(GetCommandLineW(), commandStrings);
#else
  extern void mySplitCommandLineW(int numArguments,TCHAR  **arguments,UStringVector &parts);
  mySplitCommandLineW(argc,argv,commandStrings);
#endif
  #ifndef UNDER_CE
  if (commandStrings.Size() > 0)
    commandStrings.Delete(0);
  #endif
  if (commandStrings.Size() == 0)
  {
    MessageBoxW(0, L"Specify command", L"7-Zip", 0);
    return 0;
  }

  CArcCmdLineOptions options;
  CArcCmdLineParser parser;

  parser.Parse1(commandStrings, options);
  parser.Parse2(options);

  #if defined(_WIN32) && !defined(UNDER_CE)
  NSecurity::EnablePrivilege_SymLink();
  #ifdef _7ZIP_LARGE_PAGES
  if (options.LargePages)
    NSecurity::EnablePrivilege_LockMemory();
  #endif
  #endif

  CREATE_CODECS_OBJECT

  codecs->CaseSensitiveChange = options.CaseSensitiveChange;
  codecs->CaseSensitive = options.CaseSensitive;
  ThrowException_if_Error(codecs->Load());
  
  bool isExtractGroupCommand = options.Command.IsFromExtractGroup();
  
  if (codecs->Formats.Size() == 0 &&
        (isExtractGroupCommand
        
        || options.Command.IsFromUpdateGroup()))
  {
    #ifdef EXTERNAL_CODECS
    if (!codecs->MainDll_ErrorPath.IsEmpty())
    {
      UString s = L"7-Zip cannot load module ";
      s += fs2us(codecs->MainDll_ErrorPath);
      throw s;
    }
    #endif
    throw kNoFormats;
  }
  
  CObjectVector<COpenType> formatIndices;
  if (!ParseOpenTypes(*codecs, options.ArcType, formatIndices))
  {
    ErrorLangMessage(IDS_UNSUPPORTED_ARCHIVE_TYPE);
    return NExitCode::kFatalError;
  }

  CIntVector excludedFormatIndices;
  FOR_VECTOR (k, options.ExcludedArcTypes)
  {
    CIntVector tempIndices;
    if (!codecs->FindFormatForArchiveType(options.ExcludedArcTypes[k], tempIndices)
        || tempIndices.Size() != 1)
    {
      ErrorLangMessage(IDS_UNSUPPORTED_ARCHIVE_TYPE);
      return NExitCode::kFatalError;
    }
    excludedFormatIndices.AddToUniqueSorted(tempIndices[0]);
    // excludedFormatIndices.Sort();
  }

  #ifdef EXTERNAL_CODECS
  if (isExtractGroupCommand
      || options.Command.CommandType == NCommandType::kHash
      || options.Command.CommandType == NCommandType::kBenchmark)
    ThrowException_if_Error(__externalCodecs.Load());
  #endif
  
  if (options.Command.CommandType == NCommandType::kBenchmark)
  {
    HRESULT res = Benchmark(EXTERNAL_CODECS_VARS_L options.Properties);
    /*
    if (res == S_FALSE)
    {
      stdStream << "\nDecoding Error\n";
      return NExitCode::kFatalError;
    }
    */
    ThrowException_if_Error(res);
  }
  else if (isExtractGroupCommand)
  {
    UStringVector ArchivePathsSorted;
    UStringVector ArchivePathsFullSorted;

    CExtractCallbackImp *ecs = new CExtractCallbackImp;
    CMyComPtr<IFolderArchiveExtractCallback> extractCallback = ecs;

    #ifndef _NO_CRYPTO
    ecs->PasswordIsDefined = options.PasswordEnabled;
    ecs->Password = options.Password;
    #endif

    ecs->Init();

    CExtractOptions eo;
    (CExtractOptionsBase &)eo = options.ExtractOptions;
    eo.StdInMode = options.StdInMode;
    eo.StdOutMode = options.StdOutMode;
    eo.YesToAll = options.YesToAll;
    eo.TestMode = options.Command.IsTestCommand();

    #ifndef _SFX
    eo.Properties = options.Properties;
    #endif

    bool messageWasDisplayed = false;

    #ifndef _SFX
    CHashBundle hb;
    CHashBundle *hb_ptr = NULL;
    
    if (!options.HashMethods.IsEmpty())
    {
      hb_ptr = &hb;
      ThrowException_if_Error(hb.SetMethods(EXTERNAL_CODECS_VARS_L options.HashMethods));
    }
    #endif

    {
      CDirItemsStat st;
      HRESULT hresultMain = EnumerateDirItemsAndSort(
          options.arcCensor,
          NWildcard::k_RelatPath,
          UString(), // addPathPrefix
          ArchivePathsSorted,
          ArchivePathsFullSorted,
          st,
          NULL // &scan: change it!!!!
          );
      if (hresultMain != S_OK)
      {
        /*
        if (hresultMain != E_ABORT && messageWasDisplayed)
          return NExitCode::kFatalError;
        */
        throw CSystemException(hresultMain);
      }
    }

    ecs->MultiArcMode = (ArchivePathsSorted.Size() > 1);

    HRESULT result = ExtractGUI(codecs,
          formatIndices, excludedFormatIndices,
          ArchivePathsSorted,
          ArchivePathsFullSorted,
          options.Censor.Pairs.Front().Head,
          eo,
          #ifndef _SFX
          hb_ptr,
          #endif
          options.ShowDialog, messageWasDisplayed, ecs);
    if (result != S_OK)
    {
      if (result != E_ABORT && messageWasDisplayed)
        return NExitCode::kFatalError;
      throw CSystemException(result);
    }
    if (!ecs->IsOK())
      return NExitCode::kFatalError;
  }
  else if (options.Command.IsFromUpdateGroup())
  {
    #ifndef _NO_CRYPTO
    bool passwordIsDefined = options.PasswordEnabled && !options.Password.IsEmpty();
    #endif

    CUpdateCallbackGUI callback;
    // callback.EnablePercents = options.EnablePercents;

    #ifndef _NO_CRYPTO
    callback.PasswordIsDefined = passwordIsDefined;
    callback.AskPassword = options.PasswordEnabled && options.Password.IsEmpty();
    callback.Password = options.Password;
    #endif

    // callback.StdOutMode = options.UpdateOptions.StdOutMode;
    callback.Init();

    if (!options.UpdateOptions.InitFormatIndex(codecs, formatIndices, options.ArchiveName) ||
        !options.UpdateOptions.SetArcPath(codecs, options.ArchiveName))
    {
      ErrorLangMessage(IDS_UPDATE_NOT_SUPPORTED);
      return NExitCode::kFatalError;
    }
    bool messageWasDisplayed = false;
    HRESULT result = UpdateGUI(
        codecs, formatIndices,
        options.ArchiveName,
        options.Censor,
        options.UpdateOptions,
        options.ShowDialog,
        messageWasDisplayed,
        &callback);

    if (result != S_OK)
    {
      if (result != E_ABORT && messageWasDisplayed)
        return NExitCode::kFatalError;
      throw CSystemException(result);
    }
    if (callback.FailedFiles.Size() > 0)
    {
      if (!messageWasDisplayed)
        throw CSystemException(E_FAIL);
      return NExitCode::kWarning;
    }
  }
  else if (options.Command.CommandType == NCommandType::kHash)
  {
    bool messageWasDisplayed = false;
    HRESULT result = HashCalcGUI(EXTERNAL_CODECS_VARS_L
        options.Censor, options.HashOptions, messageWasDisplayed);

    if (result != S_OK)
    {
      if (result != E_ABORT && messageWasDisplayed)
        return NExitCode::kFatalError;
      throw CSystemException(result);
    }
    /*
    if (callback.FailedFiles.Size() > 0)
    {
      if (!messageWasDisplayed)
        throw CSystemException(E_FAIL);
      return NExitCode::kWarning;
    }
    */
  }
  else
  {
    throw "Unsupported command";
  }
  return 0;
}

#define NT_CHECK_FAIL_ACTION ErrorMessage(L"Unsupported Windows version"); return NExitCode::kFatalError;

#ifdef _WIN32
int APIENTRY WinMain(HINSTANCE  hInstance, HINSTANCE /* hPrevInstance */,
  #ifdef UNDER_CE
  LPWSTR
  #else
  LPSTR
  #endif
  /* lpCmdLine */, int /* nCmdShow */)
{
  g_hInstance = hInstance;
  #ifdef _WIN32
  NT_CHECK
  SetLargePageSize();
  #endif

  InitCommonControls();

  #ifndef UNDER_CE
  g_ComCtl32Version = ::GetDllVersion(TEXT("comctl32.dll"));
  g_LVN_ITEMACTIVATE_Support = (g_ComCtl32Version >= MAKELONG(71, 4));
  #endif

  // OleInitialize is required for ProgressBar in TaskBar.
  #ifndef UNDER_CE
  OleInitialize(NULL);
  #endif

  LoadLangOneTime();

  // setlocale(LC_COLLATE, ".ACP");
  try
  {
    return Main2();
  }
#else
int Main1(int argc,TCHAR **argv)
{
  LoadLangOneTime();
	
  // under MacOSX, a bundle does not keep the current directory
  // between 7zFM and 7zG ...
  // So, try to use the environment variable P7ZIP_CURRENT_DIR
  const char *p7zip_current_dir = getenv("P7ZIP_CURRENT_DIR");
	
  if (p7zip_current_dir)
  {
    UString currentDir = MultiByteToUnicodeString(p7zip_current_dir);
		
    NWindows::NFile::NDir::SetCurrentDir(currentDir);
  }


  // setlocale(LC_COLLATE, ".ACP");
  try
  {
    return Main2(argc,argv);
  }
#endif
  catch(const CNewException &)
  {
    return ShowMemErrorMessage();
  }
  catch(const CArcCmdLineException &e)
  {
    ErrorMessage(e);
    return NExitCode::kUserError;
  }
  catch(const CSystemException &systemError)
  {
    if (systemError.ErrorCode == E_ABORT)
      return NExitCode::kUserBreak;
    return ShowSysErrorMessage(systemError.ErrorCode);
  }
  catch(const UString &s)
  {
    ErrorMessage(s);
    return NExitCode::kFatalError;
  }
  catch(const AString &s)
  {
    ErrorMessage(GetUnicodeString(s));
    return NExitCode::kFatalError;
  }
  catch(const wchar_t *s)
  {
    ErrorMessage(s);
    return NExitCode::kFatalError;
  }
  catch(const char *s)
  {
    ErrorMessage(GetUnicodeString(s));
    return NExitCode::kFatalError;
  }
  catch(int v)
  {
    wchar_t s[32];
    ConvertUInt32ToString(v, s);
    ErrorMessage(UString(L"Error: ") + s);
    return NExitCode::kFatalError;
  }
  catch(...)
  {
    ErrorMessage(L"Unknown error");
    return NExitCode::kFatalError;
  }
}
// HashGUI.cpp

#include "StdAfx.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/ErrorMsg.h"

#include "../FileManager/FormatUtils.h"
#include "../FileManager/LangUtils.h"
#include "../FileManager/OverwriteDialogRes.h"
#include "../FileManager/ProgressDialog2.h"
#include "../FileManager/ProgressDialog2Res.h"
#include "../FileManager/PropertyNameRes.h"
#include "../FileManager/resourceGui.h"

#include "HashGUI.h"

using namespace NWindows;

class CHashCallbackGUI: public CProgressThreadVirt, public IHashCallbackUI
{
  UInt64 NumFiles;
  bool _curIsFolder;
  UString FirstFileName;

  HRESULT ProcessVirt();

public:
  const NWildcard::CCensor *censor;
  const CHashOptions *options;

  DECL_EXTERNAL_CODECS_LOC_VARS2;

  CHashCallbackGUI() {}
  ~CHashCallbackGUI() { }

  INTERFACE_IHashCallbackUI(;)

  void AddErrorMessage(DWORD systemError, const wchar_t *name)
  {
    ProgressDialog.Sync.AddError_Code_Name(systemError, name);
  }
};

static void AddValuePair(UString &s, UINT resourceID, UInt64 value)
{
  AddLangString(s, resourceID);
  s.AddAscii(": ");
  char sz[32];
  ConvertUInt64ToString(value, sz);
  s.AddAscii(sz);
  s.Add_LF();
}

static void AddSizeValuePair(UString &s, UINT resourceID, UInt64 value)
{
  AddLangString(s, resourceID);
  s.AddAscii(": ");
  wchar_t sz[32];
  ConvertUInt64ToString(value, sz);
  s += MyFormatNew(IDS_FILE_SIZE, sz);
  ConvertUInt64ToString(value >> 20, sz);
  s.AddAscii(" (");
  s += sz;
  s.AddAscii(" MB)");
  s.Add_LF();
}

HRESULT CHashCallbackGUI::StartScanning()
{
  CProgressSync &sync = ProgressDialog.Sync;
  sync.Set_Status(LangString(IDS_SCANNING));
  return CheckBreak();
}

HRESULT CHashCallbackGUI::ScanProgress(const CDirItemsStat &st, const FString &path, bool isDir)
{
  return ProgressDialog.Sync.ScanProgress(st.NumFiles, st.GetTotalBytes(), path, isDir);
}

HRESULT CHashCallbackGUI::ScanError(const FString &path, DWORD systemError)
{
  AddErrorMessage(systemError, fs2us(path));
  return CheckBreak();
}

HRESULT CHashCallbackGUI::FinishScanning(const CDirItemsStat &st)
{
  return ScanProgress(st, FString(), false);
}

HRESULT CHashCallbackGUI::CheckBreak()
{
  return ProgressDialog.Sync.CheckStop();
}

HRESULT CHashCallbackGUI::SetNumFiles(UInt64 numFiles)
{
  CProgressSync &sync = ProgressDialog.Sync;
  sync.Set_NumFilesTotal(numFiles);
  return CheckBreak();
}

HRESULT CHashCallbackGUI::SetTotal(UInt64 size)
{
  CProgressSync &sync = ProgressDialog.Sync;
  sync.Set_NumBytesTotal(size);
  return CheckBreak();
}

HRESULT CHashCallbackGUI::SetCompleted(const UInt64 *completed)
{
  return ProgressDialog.Sync.Set_NumBytesCur(completed);
}

HRESULT CHashCallbackGUI::BeforeFirstFile(const CHashBundle & /* hb */)
{
  return S_OK;
}

HRESULT CHashCallbackGUI::GetStream(const wchar_t *name, bool isFolder)
{
  if (NumFiles == 0)
    FirstFileName = name;
  _curIsFolder = isFolder;
  CProgressSync &sync = ProgressDialog.Sync;
  sync.Set_FilePath(name, isFolder);
  return CheckBreak();
}

HRESULT CHashCallbackGUI::OpenFileError(const FString &path, DWORD systemError)
{
  // if (systemError == ERROR_SHARING_VIOLATION)
  {
    AddErrorMessage(systemError, fs2us(path));
    return S_FALSE;
  }
  // return systemError;
}

HRESULT CHashCallbackGUI::SetOperationResult(UInt64 /* fileSize */, const CHashBundle & /* hb */, bool /* showHash */)
{
  CProgressSync &sync = ProgressDialog.Sync;
  if (!_curIsFolder)
    NumFiles++;
  sync.Set_NumFilesCur(NumFiles);
  return CheckBreak();
}

static void AddHashString(UString &s, const CHasherState &h, unsigned digestIndex, const wchar_t *title)
{
  s += title;
  s.Add_Space();
  char temp[k_HashCalc_DigestSize_Max * 2 + 4];
  AddHashHexToString(temp, h.Digests[digestIndex], h.DigestSize);
  s.AddAscii(temp);
  s.Add_LF();
}

static void AddHashResString(UString &s, const CHasherState &h, unsigned digestIndex, UInt32 resID)
{
  UString s2 = LangString(resID);
  UString name;
  name.SetFromAscii(h.Name);
  s2.Replace(L"CRC", name);
  AddHashString(s, h, digestIndex, s2);
}

void AddHashBundleRes(UString &s, const CHashBundle &hb, const UString &firstFileName)
{
  if (hb.NumErrors != 0)
  {
    AddValuePair(s, IDS_PROP_NUM_ERRORS, hb.NumErrors);
    s.Add_LF();
  }
  
  if (hb.NumFiles == 1 && hb.NumDirs == 0 && !firstFileName.IsEmpty())
  {
    AddLangString(s, IDS_PROP_NAME);
    s.AddAscii(": ");
    s += firstFileName;
    s.Add_LF();
  }
  else
  {
    AddValuePair(s, IDS_PROP_FOLDERS, hb.NumDirs);
    AddValuePair(s, IDS_PROP_FILES, hb.NumFiles);
  }

  AddSizeValuePair(s, IDS_PROP_SIZE, hb.FilesSize);

  if (hb.NumAltStreams != 0)
  {
    s.Add_LF();
    AddValuePair(s, IDS_PROP_NUM_ALT_STREAMS, hb.NumAltStreams);
    AddSizeValuePair(s, IDS_PROP_ALT_STREAMS_SIZE, hb.AltStreamsSize);
  }

  if (hb.NumErrors == 0 && hb.Hashers.IsEmpty())
  {
    s.Add_LF();
    AddLangString(s, IDS_MESSAGE_NO_ERRORS);
  }

  FOR_VECTOR (i, hb.Hashers)
  {
    s.Add_LF();
    const CHasherState &h = hb.Hashers[i];
    if (hb.NumFiles == 1 && hb.NumDirs == 0)
    {
      s.AddAscii(h.Name);
      AddHashString(s, h, k_HashCalc_Index_DataSum, L":");
    }
    else
    {
      AddHashResString(s, h, k_HashCalc_Index_DataSum, IDS_CHECKSUM_CRC_DATA);
      AddHashResString(s, h, k_HashCalc_Index_NamesSum, IDS_CHECKSUM_CRC_DATA_NAMES);
    }
    if (hb.NumAltStreams != 0)
    {
      AddHashResString(s, h, k_HashCalc_Index_StreamsSum, IDS_CHECKSUM_CRC_STREAMS_NAMES);
    }
  }
}

HRESULT CHashCallbackGUI::AfterLastFile(const CHashBundle &hb)
{
  UString s;
  AddHashBundleRes(s, hb, FirstFileName);
  
  CProgressSync &sync = ProgressDialog.Sync;
  sync.Set_NumFilesCur(hb.NumFiles);

  CProgressMessageBoxPair &pair = GetMessagePair(hb.NumErrors != 0);
  pair.Message = s;
  LangString(IDS_CHECKSUM_INFORMATION, pair.Title);

  return S_OK;
}

HRESULT CHashCallbackGUI::ProcessVirt()
{
  NumFiles = 0;

  AString errorInfo;
  HRESULT res = HashCalc(EXTERNAL_CODECS_LOC_VARS
      *censor, *options, errorInfo, this);

  return res;
}

HRESULT HashCalcGUI(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const NWildcard::CCensor &censor,
    const CHashOptions &options,
    bool &messageWasDisplayed)
{
  CHashCallbackGUI t;
  #ifdef EXTERNAL_CODECS
  t.__externalCodecs = __externalCodecs;
  #endif
  t.censor = &censor;
  t.options = &options;

  t.ProgressDialog.ShowCompressionInfo = false;

  const UString title = LangString(IDS_CHECKSUM_CALCULATING);

  t.ProgressDialog.MainTitle = L"7-Zip"; // LangString(IDS_APP_TITLE);
  t.ProgressDialog.MainAddTitle = title;
  t.ProgressDialog.MainAddTitle.Add_Space();

  RINOK(t.Create(title));
  messageWasDisplayed = t.ThreadFinishedOK && t.ProgressDialog.MessagesDisplayed;
  return S_OK;
}
// HashGUI.h

#ifndef __HASH_GUI_H
#define __HASH_GUI_H

#include "../Common/HashCalc.h"

HRESULT HashCalcGUI(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const NWildcard::CCensor &censor,
    const CHashOptions &options,
    bool &messageWasDisplayed);

void AddHashBundleRes(UString &s, const CHashBundle &hb, const UString &firstFileName);

#endif
// UpdateCallbackGUI.cpp

#include "StdAfx.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/PropVariant.h"

#include "../FileManager/FormatUtils.h"
#include "../FileManager/LangUtils.h"

#include "../FileManager/resourceGui.h"

#include "resource2.h"

#include "UpdateCallbackGUI.h"

using namespace NWindows;

// CUpdateCallbackGUI::~CUpdateCallbackGUI() {}

void CUpdateCallbackGUI::Init()
{
  CUpdateCallbackGUI2::Init();
  FailedFiles.Clear();
}

void OpenResult_GUI(UString &s, const CCodecs *codecs, const CArchiveLink &arcLink, const wchar_t *name, HRESULT result);

HRESULT CUpdateCallbackGUI::OpenResult(
    const CCodecs *codecs, const CArchiveLink &arcLink, const wchar_t *name, HRESULT result)
{
  UString s;
  OpenResult_GUI(s, codecs, arcLink, name, result);
  if (!s.IsEmpty())
  {
    ProgressDialog->Sync.AddError_Message(s);
  }

  return S_OK;
}

HRESULT CUpdateCallbackGUI::StartScanning()
{
  CProgressSync &sync = ProgressDialog->Sync;
  sync.Set_Status(LangString(IDS_SCANNING));
  return S_OK;
}

HRESULT CUpdateCallbackGUI::ScanError(const FString &path, DWORD systemError)
{
  FailedFiles.Add(path);
  ProgressDialog->Sync.AddError_Code_Name(systemError, fs2us(path));
  return S_OK;
}

HRESULT CUpdateCallbackGUI::FinishScanning(const CDirItemsStat &st)
{
  CProgressSync &sync = ProgressDialog->Sync;
  RINOK(ProgressDialog->Sync.ScanProgress(st.NumFiles + st.NumAltStreams,
      st.GetTotalBytes(), FString(), true));
  sync.Set_Status(L"");
  return S_OK;
}

HRESULT CUpdateCallbackGUI::StartArchive(const wchar_t *name, bool /* updating */)
{
  CProgressSync &sync = ProgressDialog->Sync;
  sync.Set_Status(LangString(IDS_PROGRESS_COMPRESSING));
  sync.Set_TitleFileName(name);
  return S_OK;
}

HRESULT CUpdateCallbackGUI::FinishArchive(const CFinishArchiveStat & /* st */)
{
  CProgressSync &sync = ProgressDialog->Sync;
  sync.Set_Status(L"");
  return S_OK;
}

HRESULT CUpdateCallbackGUI::CheckBreak()
{
  return ProgressDialog->Sync.CheckStop();
}

HRESULT CUpdateCallbackGUI::ScanProgress(const CDirItemsStat &st, const FString &path, bool isDir)
{
  return ProgressDialog->Sync.ScanProgress(st.NumFiles + st.NumAltStreams,
      st.GetTotalBytes(), path, isDir);
}

/*
HRESULT CUpdateCallbackGUI::Finalize()
{
  return S_OK;
}
*/

HRESULT CUpdateCallbackGUI::SetNumItems(UInt64 numItems)
{
  ProgressDialog->Sync.Set_NumFilesTotal(numItems);
  return S_OK;
}

HRESULT CUpdateCallbackGUI::SetTotal(UInt64 total)
{
  ProgressDialog->Sync.Set_NumBytesTotal(total);
  return S_OK;
}

HRESULT CUpdateCallbackGUI::SetCompleted(const UInt64 *completed)
{
  return ProgressDialog->Sync.Set_NumBytesCur(completed);
}

HRESULT CUpdateCallbackGUI::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)
{
  ProgressDialog->Sync.Set_Ratio(inSize, outSize);
  return CheckBreak();
}

HRESULT CUpdateCallbackGUI::GetStream(const wchar_t *name, bool isDir, bool /* isAnti */, UInt32 mode)
{
  return SetOperation_Base(mode, name, isDir);
}

HRESULT CUpdateCallbackGUI::OpenFileError(const FString &path, DWORD systemError)
{
  FailedFiles.Add(path);
  // if (systemError == ERROR_SHARING_VIOLATION)
  {
    ProgressDialog->Sync.AddError_Code_Name(systemError, fs2us(path));
    return S_FALSE;
  }
  // return systemError;
}

HRESULT CUpdateCallbackGUI::SetOperationResult(Int32 /* operationResult */)
{
  NumFiles++;
  ProgressDialog->Sync.Set_NumFilesCur(NumFiles);
  return S_OK;
}

void SetExtractErrorMessage(Int32 opRes, Int32 encrypted, const wchar_t *fileName, UString &s);

HRESULT CUpdateCallbackGUI::ReportExtractResult(Int32 opRes, Int32 isEncrypted, const wchar_t *name)
{
  if (opRes != NArchive::NExtract::NOperationResult::kOK)
  {
    UString s;
    SetExtractErrorMessage(opRes, isEncrypted, name, s);
    ProgressDialog->Sync.AddError_Message(s);
  }
  return S_OK;
}

HRESULT CUpdateCallbackGUI::ReportUpdateOpeartion(UInt32 op, const wchar_t *name, bool isDir)
{
  return SetOperation_Base(op, name, isDir);
}

HRESULT CUpdateCallbackGUI::CryptoGetTextPassword2(Int32 *passwordIsDefined, BSTR *password)
{
  *password = NULL;
  if (passwordIsDefined)
    *passwordIsDefined = BoolToInt(PasswordIsDefined);
  if (!PasswordIsDefined)
  {
    if (AskPassword)
    {
      RINOK(ShowAskPasswordDialog())
    }
  }
  if (passwordIsDefined)
    *passwordIsDefined = BoolToInt(PasswordIsDefined);
  return StringToBstr(Password, password);
}

HRESULT CUpdateCallbackGUI::CryptoGetTextPassword(BSTR *password)
{
  return CryptoGetTextPassword2(NULL, password);
}

/*
It doesn't work, since main stream waits Dialog
HRESULT CUpdateCallbackGUI::CloseProgress()
{
  ProgressDialog->MyClose();
  return S_OK;
}
*/


HRESULT CUpdateCallbackGUI::Open_CheckBreak()
{
  return ProgressDialog->Sync.CheckStop();
}

HRESULT CUpdateCallbackGUI::Open_SetTotal(const UInt64 * /* numFiles */, const UInt64 * /* numBytes */)
{
  // if (numFiles != NULL) ProgressDialog->Sync.SetNumFilesTotal(*numFiles);
  return S_OK;
}

HRESULT CUpdateCallbackGUI::Open_SetCompleted(const UInt64 * /* numFiles */, const UInt64 * /* numBytes */)
{
  return ProgressDialog->Sync.CheckStop();
}

#ifndef _NO_CRYPTO

HRESULT CUpdateCallbackGUI::Open_CryptoGetTextPassword(BSTR *password)
{
  PasswordWasAsked = true;
  return CryptoGetTextPassword2(NULL, password);
}

/*
HRESULT CUpdateCallbackGUI::Open_GetPasswordIfAny(bool &passwordIsDefined, UString &password)
{
  passwordIsDefined = PasswordIsDefined;
  password = Password;
  return S_OK;
}

bool CUpdateCallbackGUI::Open_WasPasswordAsked()
{
  return PasswordWasAsked;
}

void CUpdateCallbackGUI::Open_Clear_PasswordWasAsked_Flag()
{
  PasswordWasAsked = false;
}
*/

HRESULT CUpdateCallbackGUI::ShowDeleteFile(const wchar_t *name, bool isDir)
{
  return SetOperation_Base(NUpdateNotifyOp::kDelete, name, isDir);
}

HRESULT CUpdateCallbackGUI::FinishDeletingAfterArchiving()
{
  // ClosePercents2();
  return S_OK;
}

HRESULT CUpdateCallbackGUI::DeletingAfterArchiving(const FString &path, bool isDir)
{
  return ProgressDialog->Sync.Set_Status2(_lang_Removing, fs2us(path), isDir);
}

HRESULT CUpdateCallbackGUI::StartOpenArchive(const wchar_t * /* name */)
{
  return S_OK;
}

HRESULT CUpdateCallbackGUI::ReadingFileError(const FString &path, DWORD systemError)
{
  FailedFiles.Add(path);
  ProgressDialog->Sync.AddError_Code_Name(systemError, fs2us(path));
  return S_OK;
}

HRESULT CUpdateCallbackGUI::WriteSfx(const wchar_t * /* name */, UInt64 /* size */)
{
  CProgressSync &sync = ProgressDialog->Sync;
  sync.Set_Status(L"WriteSfx");
  return S_OK;
}

HRESULT CUpdateCallbackGUI::Open_Finished()
{
  // ClosePercents();
  return S_OK;
}

#endif
// UpdateCallbackGUI.h

#ifndef __UPDATE_CALLBACK_GUI_H
#define __UPDATE_CALLBACK_GUI_H

#include "../Common/Update.h"
#include "../Common/ArchiveOpenCallback.h"

#include "UpdateCallbackGUI2.h"

class CUpdateCallbackGUI:
  public IOpenCallbackUI,
  public IUpdateCallbackUI2,
  public CUpdateCallbackGUI2
{
public:
  // CUpdateCallbackGUI();
  // ~CUpdateCallbackGUI();

  bool AskPassword;

  void Init();

  CUpdateCallbackGUI():
      AskPassword(false)
      {}

  INTERFACE_IUpdateCallbackUI2(;)
  INTERFACE_IOpenCallbackUI(;)

  FStringVector FailedFiles;
};

#endif
// UpdateCallbackGUI2.cpp

#include "StdAfx.h"

#include "../FileManager/LangUtils.h"
#include "../FileManager/PasswordDialog.h"

#include "resource2.h"
#include "resource3.h"
#include "ExtractRes.h"

#include "UpdateCallbackGUI.h"

using namespace NWindows;

static const UINT k_UpdNotifyLangs[] =
{
  IDS_PROGRESS_ADD,
  IDS_PROGRESS_UPDATE,
  IDS_PROGRESS_ANALYZE,
  IDS_PROGRESS_REPLICATE,
  IDS_PROGRESS_REPACK,
  IDS_PROGRESS_SKIPPING,
  IDS_PROGRESS_DELETE,
  IDS_PROGRESS_HEADER
};

void CUpdateCallbackGUI2::Init()
{
  NumFiles = 0;

  _lang_Removing = LangString(IDS_PROGRESS_REMOVE);
  _lang_Ops.Clear();
  for (unsigned i = 0; i < ARRAY_SIZE(k_UpdNotifyLangs); i++)
    _lang_Ops.Add(LangString(k_UpdNotifyLangs[i]));
}

HRESULT CUpdateCallbackGUI2::SetOperation_Base(UInt32 notifyOp, const wchar_t *name, bool isDir)
{
  const UString *s = NULL;
  if (notifyOp < _lang_Ops.Size())
    s = &(_lang_Ops[(unsigned)notifyOp]);
  else
    s = &_emptyString;

  return ProgressDialog->Sync.Set_Status2(*s, name, isDir);
}


HRESULT CUpdateCallbackGUI2::ShowAskPasswordDialog()
{
  CPasswordDialog dialog;
  ProgressDialog->WaitCreating();
  if (dialog.Create(*ProgressDialog) != IDOK)
    return E_ABORT;
  Password = dialog.Password;
  PasswordIsDefined = true;
  return S_OK;
}
// UpdateCallbackGUI2.h

#ifndef __UPDATE_CALLBACK_GUI2_H
#define __UPDATE_CALLBACK_GUI2_H

#include "../FileManager/ProgressDialog2.h"

class CUpdateCallbackGUI2
{
  UStringVector _lang_Ops;
  UString _emptyString;
public:
  UString Password;
  bool PasswordIsDefined;
  bool PasswordWasAsked;
  UInt64 NumFiles;

  UString _lang_Removing;

  CUpdateCallbackGUI2():
      PasswordIsDefined(false),
      PasswordWasAsked(false),
      NumFiles(0)
      {}
  
  // ~CUpdateCallbackGUI2();
  void Init();

  CProgressDialog *ProgressDialog;

  HRESULT SetOperation_Base(UInt32 notifyOp, const wchar_t *name, bool isDir);
  HRESULT ShowAskPasswordDialog();
};

#endif
// UpdateGUI.cpp

#include "StdAfx.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/StringToInt.h"

#include "../../../Windows/DLL.h"
#include "../../../Windows/FileDir.h"
#include "../../../Windows/FileName.h"
#include "../../../Windows/Thread.h"

#include "../Common/WorkDir.h"

#include "../Explorer/MyMessages.h"

#include "../FileManager/LangUtils.h"
#include "../FileManager/StringUtils.h"
#include "../FileManager/resourceGui.h"

#include "CompressDialog.h"
#include "UpdateGUI.h"

#include "resource2.h"

using namespace NWindows;
using namespace NFile;
using namespace NDir;

static CFSTR kDefaultSfxModule = FTEXT("7z.sfx");
static const wchar_t *kSFXExtension = L"exe";

extern void AddMessageToString(UString &dest, const UString &src);

UString HResultToMessage(HRESULT errorCode);

class CThreadUpdating: public CProgressThreadVirt
{
  HRESULT ProcessVirt();
public:
  CCodecs *codecs;
  const CObjectVector<COpenType> *formatIndices;
  const UString *cmdArcPath;
  CUpdateCallbackGUI *UpdateCallbackGUI;
  NWildcard::CCensor *WildcardCensor;
  CUpdateOptions *Options;
  bool needSetPath;
};
 
HRESULT CThreadUpdating::ProcessVirt()
{
  CUpdateErrorInfo ei;
  HRESULT res = UpdateArchive(codecs, *formatIndices, *cmdArcPath,
      *WildcardCensor, *Options,
      ei, UpdateCallbackGUI, UpdateCallbackGUI, needSetPath);
  FinalMessage.ErrorMessage.Message.SetFromAscii(ei.Message);
  ErrorPaths = ei.FileNames;
  if (ei.SystemError != S_OK && ei.SystemError != E_FAIL && ei.SystemError != E_ABORT)
    return ei.SystemError;
  return res;
}

static void AddProp(CObjectVector<CProperty> &properties, const UString &name, const UString &value)
{
  CProperty prop;
  prop.Name = name;
  prop.Value = value;
  properties.Add(prop);
}

static void AddProp(CObjectVector<CProperty> &properties, const UString &name, UInt32 value)
{
  wchar_t tmp[32];
  ConvertUInt64ToString(value, tmp);
  AddProp(properties, name, tmp);
}

static void AddProp(CObjectVector<CProperty> &properties, const UString &name, bool value)
{
  AddProp(properties, name, value ? UString(L"on"): UString(L"off"));
}

static bool IsThereMethodOverride(bool is7z, const UString &propertiesString)
{
  UStringVector strings;
  SplitString(propertiesString, strings);
  FOR_VECTOR (i, strings)
  {
    const UString &s = strings[i];
    if (is7z)
    {
      const wchar_t *end;
      UInt64 n = ConvertStringToUInt64(s, &end);
      if (n == 0 && *end == L'=')
        return true;
    }
    else
    {
      if (s.Len() > 0)
        if (s[0] == L'm' && s[1] == L'=')
          return true;
    }
  }
  return false;
}

static void ParseAndAddPropertires(CObjectVector<CProperty> &properties,
    const UString &propertiesString)
{
  UStringVector strings;
  SplitString(propertiesString, strings);
  FOR_VECTOR (i, strings)
  {
    const UString &s = strings[i];
    CProperty property;
    int index = s.Find(L'=');
    if (index < 0)
      property.Name = s;
    else
    {
      property.Name.SetFrom(s, index);
      property.Value = s.Ptr(index + 1);
    }
    properties.Add(property);
  }
}

static UString GetNumInBytesString(UInt64 v)
{
  wchar_t s[32];
  ConvertUInt64ToString(v, s);
  size_t len = wcslen(s);
  s[len++] = L'B';
  s[len] = L'\0';
  return s;
}

static void SetOutProperties(
    CObjectVector<CProperty> &properties,
    bool is7z,
    UInt32 level,
    bool setMethod,
    const UString &method,
    UInt32 dictionary,
    bool orderMode,
    UInt32 order,
    bool solidIsSpecified, UInt64 solidBlockSize,
    bool multiThreadIsAllowed, UInt32 numThreads,
    const UString &encryptionMethod,
    bool encryptHeadersIsAllowed, bool encryptHeaders,
    bool /* sfxMode */)
{
  if (level != (UInt32)(Int32)-1)
    AddProp(properties, L"x", (UInt32)level);
  if (setMethod)
  {
    if (!method.IsEmpty())
      AddProp(properties, is7z ? L"0": L"m", method);
    if (dictionary != (UInt32)(Int32)-1)
    {
      UString name;
      if (is7z)
        name = L"0";
      if (orderMode)
        name += L"mem";
      else
        name += L"d";
      AddProp(properties, name, GetNumInBytesString(dictionary));
    }
    if (order != (UInt32)(Int32)-1)
    {
      UString name;
      if (is7z)
        name = L"0";
      if (orderMode)
        name += L"o";
      else
        name += L"fb";
      AddProp(properties, name, (UInt32)order);
    }
  }
    
  if (!encryptionMethod.IsEmpty())
    AddProp(properties, L"em", encryptionMethod);

  if (encryptHeadersIsAllowed)
    AddProp(properties, L"he", encryptHeaders);
  if (solidIsSpecified)
    AddProp(properties, L"s", GetNumInBytesString(solidBlockSize));
  if (multiThreadIsAllowed)
    AddProp(properties, L"mt", numThreads);
}

struct C_UpdateMode_ToAction_Pair
{
  NCompressDialog::NUpdateMode::EEnum UpdateMode;
  const NUpdateArchive::CActionSet *ActionSet;
};

static const C_UpdateMode_ToAction_Pair g_UpdateMode_Pairs[] =
{
  { NCompressDialog::NUpdateMode::kAdd,    &NUpdateArchive::k_ActionSet_Add },
  { NCompressDialog::NUpdateMode::kUpdate, &NUpdateArchive::k_ActionSet_Update },
  { NCompressDialog::NUpdateMode::kFresh,  &NUpdateArchive::k_ActionSet_Fresh },
  { NCompressDialog::NUpdateMode::kSync,   &NUpdateArchive::k_ActionSet_Sync }
};

static int FindActionSet(const NUpdateArchive::CActionSet &actionSet)
{
  for (unsigned i = 0; i < ARRAY_SIZE(g_UpdateMode_Pairs); i++)
    if (actionSet.IsEqualTo(*g_UpdateMode_Pairs[i].ActionSet))
      return i;
  return -1;
}

static int FindUpdateMode(NCompressDialog::NUpdateMode::EEnum mode)
{
  for (unsigned i = 0; i < ARRAY_SIZE(g_UpdateMode_Pairs); i++)
    if (mode == g_UpdateMode_Pairs[i].UpdateMode)
      return i;
  return -1;
}


static HRESULT ShowDialog(
    CCodecs *codecs,
    const CObjectVector<NWildcard::CCensorPath> &censor,
    CUpdateOptions &options,
    CUpdateCallbackGUI *callback, HWND hwndParent)
{
  if (options.Commands.Size() != 1)
    throw "It must be one command";
  /*
  FString currentDirPrefix;
  #ifndef UNDER_CE
  {
    if (!MyGetCurrentDirectory(currentDirPrefix))
      return E_FAIL;
    NName::NormalizeDirPathPrefix(currentDirPrefix);
  }
  #endif
  */

  bool oneFile = false;
  NFind::CFileInfo fileInfo;
  UString name;
  
  /*
  if (censor.Pairs.Size() > 0)
  {
    const NWildcard::CPair &pair = censor.Pairs[0];
    if (pair.Head.IncludeItems.Size() > 0)
    {
      const NWildcard::CItem &item = pair.Head.IncludeItems[0];
      if (item.ForFile)
      {
        name = pair.Prefix;
        FOR_VECTOR (i, item.PathParts)
        {
          if (i > 0)
            name.Add_PathSepar();
          name += item.PathParts[i];
        }
        if (fileInfo.Find(us2fs(name)))
        {
          if (censor.Pairs.Size() == 1 && pair.Head.IncludeItems.Size() == 1)
            oneFile = !fileInfo.IsDir();
        }
      }
    }
  }
  */
  if (censor.Size() > 0)
  {
    const NWildcard::CCensorPath &cp = censor[0];
    if (cp.Include)
    {
      {
        if (fileInfo.Find(us2fs(cp.Path)))
        {
          if (censor.Size() == 1)
            oneFile = !fileInfo.IsDir();
        }
      }
    }
  }

  
  #if defined(_WIN32) && !defined(UNDER_CE)
  CCurrentDirRestorer curDirRestorer;
  #endif
  CCompressDialog dialog;
  NCompressDialog::CInfo &di = dialog.Info;
  dialog.ArcFormats = &codecs->Formats;

  if (options.MethodMode.Type_Defined)
    di.FormatIndex = options.MethodMode.Type.FormatIndex;
  
  FOR_VECTOR (i, codecs->Formats)
  {
    const CArcInfoEx &ai = codecs->Formats[i];
    if (!ai.UpdateEnabled)
      continue;
    if (!oneFile && ai.Flags_KeepName())
      continue;
    if ((int)i != di.FormatIndex)
      if (ai.Name.IsEqualTo_Ascii_NoCase("swfc"))
        if (!oneFile || name.Len() < 4 || !StringsAreEqualNoCase_Ascii(name.RightPtr(4), ".swf"))
          continue;
    dialog.ArcIndices.Add(i);
  }
  if (dialog.ArcIndices.IsEmpty())
  {
    ShowErrorMessage(L"No Update Engines");
    return E_FAIL;
  }

  // di.ArchiveName = options.ArchivePath.GetFinalPath();
  di.ArcPath = options.ArchivePath.GetPathWithoutExt();
  dialog.OriginalFileName = fs2us(fileInfo.Name);

  di.PathMode = options.PathMode;
    
  // di.CurrentDirPrefix = currentDirPrefix;
  di.SFXMode = options.SfxMode;
  di.OpenShareForWrite = options.OpenShareForWrite;
  di.DeleteAfterCompressing = options.DeleteAfterCompressing;

  di.SymLinks = options.SymLinks;
  di.HardLinks = options.HardLinks;
  di.AltStreams = options.AltStreams;
  di.NtSecurity = options.NtSecurity;
  
  if (callback->PasswordIsDefined)
    di.Password = callback->Password;
    
  di.KeepName = !oneFile;

  NUpdateArchive::CActionSet &actionSet = options.Commands.Front().ActionSet;
 
  {
    int index = FindActionSet(actionSet);
    if (index < 0)
      return E_NOTIMPL;
    di.UpdateMode = g_UpdateMode_Pairs[(unsigned)index].UpdateMode;
  }

  if (dialog.Create(hwndParent) != IDOK)
    return E_ABORT;

  options.DeleteAfterCompressing = di.DeleteAfterCompressing;

  options.SymLinks = di.SymLinks;
  options.HardLinks = di.HardLinks;
  options.AltStreams = di.AltStreams;
  options.NtSecurity = di.NtSecurity;
 
  #if defined(_WIN32) && !defined(UNDER_CE)
  curDirRestorer.NeedRestore = dialog.CurrentDirWasChanged;
  #endif
  
  options.VolumesSizes = di.VolumeSizes;
  /*
  if (di.VolumeSizeIsDefined)
  {
    MyMessageBox(L"Splitting to volumes is not supported");
    return E_FAIL;
  }
  */

 
  {
    int index = FindUpdateMode(di.UpdateMode);
    if (index < 0)
      return E_FAIL;
    actionSet = *g_UpdateMode_Pairs[index].ActionSet;
  }

  options.PathMode = di.PathMode;

  const CArcInfoEx &archiverInfo = codecs->Formats[di.FormatIndex];
  callback->PasswordIsDefined = (!di.Password.IsEmpty());
  if (callback->PasswordIsDefined)
    callback->Password = di.Password;

  options.MethodMode.Properties.Clear();

  bool is7z = archiverInfo.Name.IsEqualTo_Ascii_NoCase("7z");
  bool methodOverride = IsThereMethodOverride(is7z, di.Options);

  SetOutProperties(
      options.MethodMode.Properties,
      is7z,
      di.Level,
      !methodOverride,
      di.Method,
      di.Dictionary,
      di.OrderMode, di.Order,
      di.SolidIsSpecified, di.SolidBlockSize,
      di.MultiThreadIsAllowed, di.NumThreads,
      di.EncryptionMethod,
      di.EncryptHeadersIsAllowed, di.EncryptHeaders,
      di.SFXMode);
  
  options.OpenShareForWrite = di.OpenShareForWrite;
  ParseAndAddPropertires(options.MethodMode.Properties, di.Options);

  if (di.SFXMode)
    options.SfxMode = true;
  options.MethodMode.Type = COpenType();
  options.MethodMode.Type_Defined = true;
  options.MethodMode.Type.FormatIndex = di.FormatIndex;

  options.ArchivePath.VolExtension = archiverInfo.GetMainExt();
  if (di.SFXMode)
    options.ArchivePath.BaseExtension = kSFXExtension;
  else
    options.ArchivePath.BaseExtension = options.ArchivePath.VolExtension;
  options.ArchivePath.ParseFromPath(di.ArcPath, k_ArcNameMode_Smart);

  NWorkDir::CInfo workDirInfo;
  workDirInfo.Load();
  options.WorkingDir.Empty();
  if (workDirInfo.Mode != NWorkDir::NMode::kCurrent)
  {
    FString fullPath;
    MyGetFullPathName(us2fs(di.ArcPath), fullPath);
    FString namePart;
    options.WorkingDir = GetWorkDir(workDirInfo, fullPath, namePart);
    CreateComplexDir(options.WorkingDir);
  }
  return S_OK;
}

HRESULT UpdateGUI(
    CCodecs *codecs,
    const CObjectVector<COpenType> &formatIndices,
    const UString &cmdArcPath,
    NWildcard::CCensor &censor,
    CUpdateOptions &options,
    bool showDialog,
    bool &messageWasDisplayed,
    CUpdateCallbackGUI *callback,
    HWND hwndParent)
{
  messageWasDisplayed = false;
  bool needSetPath  = true;
  if (showDialog)
  {
    RINOK(ShowDialog(codecs, censor.CensorPaths, options, callback, hwndParent));
    needSetPath = false;
  }
  if (options.SfxMode && options.SfxModule.IsEmpty())
  {
    FString folder = NWindows::NDLL::GetModuleDirPrefix();
    options.SfxModule = folder + kDefaultSfxModule;
  }

  CThreadUpdating tu;

  tu.needSetPath = needSetPath;

  tu.codecs = codecs;
  tu.formatIndices = &formatIndices;
  tu.cmdArcPath = &cmdArcPath;

  tu.UpdateCallbackGUI = callback;
  tu.UpdateCallbackGUI->ProgressDialog = &tu.ProgressDialog;
  tu.UpdateCallbackGUI->Init();

  UString title = LangString(IDS_PROGRESS_COMPRESSING);

  /*
  if (hwndParent != 0)
  {
    tu.ProgressDialog.MainWindow = hwndParent;
    // tu.ProgressDialog.MainTitle = fileName;
    tu.ProgressDialog.MainAddTitle = title + L' ';
  }
  */

  tu.WildcardCensor = &censor;
  tu.Options = &options;
  tu.ProgressDialog.IconID = IDI_ICON;

  RINOK(tu.Create(title, hwndParent));

  messageWasDisplayed = tu.ThreadFinishedOK && tu.ProgressDialog.MessagesDisplayed;
  return tu.Result;
}
// GUI/UpdateGUI.h

#ifndef __UPDATE_GUI_H
#define __UPDATE_GUI_H

#include "../Common/Update.h"

#include "UpdateCallbackGUI.h"

/*
  callback->FailedFiles contains names of files for that there were problems.
  RESULT can be S_OK, even if there are such warnings!!!
  
  RESULT = E_ABORT - user break.
  RESULT != E_ABORT:
  {
   messageWasDisplayed = true  - message was displayed already.
   messageWasDisplayed = false - there was some internal error, so you must show error message.
  }
*/

HRESULT UpdateGUI(
    CCodecs *codecs,
    const CObjectVector<COpenType> &formatIndices,
    const UString &cmdArcPath2,
    NWildcard::CCensor &censor,
    CUpdateOptions &options,
    bool showDialog,
    bool &messageWasDisplayed,
    CUpdateCallbackGUI *callback,
    HWND hwndParent = NULL);

#endif

TARGET_FLAGS=`wx-config --unicode=yes --cxxflags`

include ../../../../makefile.crc32
include ../../../../makefile.machine

LIBS=`wx-config --unicode=yes --libs` $(LOCAL_LIBS_DLL)

#

GUI_OBJS = \
 BenchmarkDialog.o \
 BenchmarkDialog_rc.o \
 CompressDialog.o \
 CompressDialog_rc.o \
 ExtractDialog.o \
 ExtractDialog_rc.o \
 GUI.o \
 HashGUI.o \
 ExtractGUI.o \
 UpdateCallbackGUI.o \
 UpdateGUI.o \
 wxGUI.o \

COMMON_OBJS = \
CommandLineParser.o \
CRC.o \
IntToString.o \
NewHandler.o \
Lang.o \
ListFileUtils.o \
MyString.o \
MyVector.o \
StringConvert.o \
StringToInt.o \
UTFConvert.o \
Wildcard.o \

# CommonDialog.o MemoryLock.o ResourceString.o ResourceString.o Shell.o
WIN_OBJS = \
DLL.o \
ErrorMsg.o \
FileDir.o \
FileFind.o \
FileIO.o \
FileName.o \
PropVariant.o \
PropVariantConv.o \
Registry.o \
Synchronization.o \
System.o \
TimeUtils.o \
Window.o \

WIN_CTRL_OBJS = \
Dialog.o \
Controls.o \

7ZIP_COMMON_OBJS = \
CreateCoder.o \
FilePathAutoRename.o \
FileStreams.o \
FilterCoder.o \
LimitedStreams.o \
MethodProps.o \
ProgressUtils.o \
PropId.o \
StreamObjects.o \
StreamUtils.o \
UniqBlocks.o \

UI_COMMON_OBJS = \
ArchiveCommandLine.o \
ArchiveExtractCallback.o \
ArchiveOpenCallback.o \
Bench.o \
DefaultName.o \
EnumDirItems.o \
Extract.o \
ExtractingFilePath.o \
HashCalc.o \
LoadCodecs.o \
OpenArchive.o \
PropIDUtils.o \
SetProperties.o \
SortUtils.o \
TempFiles.o \
Update.o \
UpdateAction.o \
UpdateCallback.o \
UpdatePair.o \
UpdateProduce.o \
WorkDir.o \
ZipRegistry.o \

AR_COMMON_OBJS = \
 OutStreamWithCRC.o

FM_OBJS_OUT = \
MessagesDialog.o \
MessagesDialog_rc.o \

FM_OBJS = \
FormatUtils.o \
ProgramLocation.o \
SplitUtils.o \
StringUtils.o \
ExtractCallback.o \
LangUtils.o \
OverwriteDialog.o \
OverwriteDialog_rc.o \
ProgressDialog2.o \
ProgressDialog2_rc.o \
PasswordDialog.o \
PasswordDialog_rc.o \

C_OBJS = \
  Alloc.o \
  CpuArch.o \
  Threads.o \

OBJS_OUT=\
  $(GUI_OBJS) \
  $(COMMON_OBJS) \
  $(WIN_OBJS) \
  $(WIN_CTRL_OBJS) \
  $(7ZIP_COMMON_OBJS) \
  $(UI_COMMON_OBJS) \
  $(AR_COMMON_OBJS) \
  $(FM_OBJS)\
  MyMessages.o \
  CopyCoder.o \
  $(C_OBJS) \
  MyWindows.o \
  wine_date_and_time.o \
  wine_GetXXXDefaultLangID.o \
  7zCrc.o $(OBJ_CRC32)

include ../../../../makefile.glb



# WARNING : automatically generated by utils/generate.py

PROG=../../../../bin/7zG$(BINSUFFIX)

all: $(PCH_NAME) $(PROG)

LOCAL_FLAGS=$(TARGET_FLAGS) \
  -DLANG \
  -DEXTERNAL_CODECS \
  -D_FILE_OFFSET_BITS=64 \
  -D_LARGEFILE_SOURCE \
  -D_REENTRANT \
  -DENV_UNIX \
  -DUNICODE \
  -D_UNICODE \
  -DUNIX_USE_WIN_FILE \

SRCS=\
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilePathAutoRename.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp \
  ../../../../CPP/7zip/UI/Common/Bench.cpp \
  ../../../../CPP/7zip/UI/Common/DefaultName.cpp \
  ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp \
  ../../../../CPP/7zip/UI/Common/Extract.cpp \
  ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp \
  ../../../../CPP/7zip/UI/Common/HashCalc.cpp \
  ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp \
  ../../../../CPP/7zip/UI/Common/OpenArchive.cpp \
  ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp \
  ../../../../CPP/7zip/UI/Common/SetProperties.cpp \
  ../../../../CPP/7zip/UI/Common/SortUtils.cpp \
  ../../../../CPP/7zip/UI/Common/TempFiles.cpp \
  ../../../../CPP/7zip/UI/Common/Update.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateAction.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp \
  ../../../../CPP/7zip/UI/Common/UpdatePair.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp \
  ../../../../CPP/7zip/UI/Common/WorkDir.cpp \
  ../../../../CPP/7zip/UI/Common/ZipRegistry.cpp \
  ../../../../CPP/7zip/UI/Explorer/MyMessages.cpp \
  ../../../../CPP/7zip/UI/FileManager/ExtractCallback.cpp \
  ../../../../CPP/7zip/UI/FileManager/FormatUtils.cpp \
  ../../../../CPP/7zip/UI/FileManager/LangUtils.cpp \
  ../../../../CPP/7zip/UI/FileManager/OverwriteDialog.cpp \
  ../../../../CPP/7zip/UI/FileManager/OverwriteDialog_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/PasswordDialog.cpp \
  ../../../../CPP/7zip/UI/FileManager/PasswordDialog_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/ProgramLocation.cpp \
  ../../../../CPP/7zip/UI/FileManager/PropertyName.cpp \
  ../../../../CPP/7zip/UI/FileManager/ProgressDialog2.cpp \
  ../../../../CPP/7zip/UI/FileManager/ProgressDialog2_rc.cpp \
  ../../../../CPP/7zip/UI/FileManager/SplitUtils.cpp \
  ../../../../CPP/7zip/UI/FileManager/StringUtils.cpp \
  ../../../../CPP/7zip/UI/GUI/BenchmarkDialog.cpp \
  ../../../../CPP/7zip/UI/GUI/BenchmarkDialog_rc.cpp \
  ../../../../CPP/7zip/UI/GUI/CompressDialog.cpp \
  ../../../../CPP/7zip/UI/GUI/CompressDialog_rc.cpp \
  ../../../../CPP/7zip/UI/GUI/ExtractDialog.cpp \
  ../../../../CPP/7zip/UI/GUI/ExtractDialog_rc.cpp \
  ../../../../CPP/7zip/UI/GUI/ExtractGUI.cpp \
  ../../../../CPP/7zip/UI/GUI/GUI.cpp \
  ../../../../CPP/7zip/UI/GUI/HashGUI.cpp \
  ../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI.cpp \
  ../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI2.cpp \
  ../../../../CPP/7zip/UI/GUI/UpdateGUI.cpp \
  ../../../../CPP/7zip/UI/GUI/wxGUI.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CommandLineParser.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/Lang.cpp \
  ../../../../CPP/Common/ListFileUtils.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/NewHandler.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Windows/Control/Controls.cpp \
  ../../../../CPP/Windows/Control/Dialog.cpp \
  ../../../../CPP/Windows/DLL.cpp \
  ../../../../CPP/Windows/ErrorMsg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantConv.cpp \
  ../../../../CPP/Windows/Registry.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/Windows/Window.cpp \
  ../../../../CPP/myWindows/wine_GetXXXDefaultLangID.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \

SRCS_C=\
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/Alloc.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Threads.c \

StdAfx.h.gch : ../../../myWindows/StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) ../../../myWindows/StdAfx.h -o StdAfx.h.gch
7zCrc.o : ../../../../C/7zCrc.c
	$(CC) $(CFLAGS) ../../../../C/7zCrc.c
7zCrcOpt.o : ../../../../C/7zCrcOpt.c
	$(CC) $(CFLAGS) ../../../../C/7zCrcOpt.c
Alloc.o : ../../../../C/Alloc.c
	$(CC) $(CFLAGS) ../../../../C/Alloc.c
CpuArch.o : ../../../../C/CpuArch.c
	$(CC) $(CFLAGS) ../../../../C/CpuArch.c
Threads.o : ../../../../C/Threads.c
	$(CC) $(CFLAGS) ../../../../C/Threads.c
OutStreamWithCRC.o : ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
CreateCoder.o : ../../../../CPP/7zip/Common/CreateCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CreateCoder.cpp
FilePathAutoRename.o : ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
FileStreams.o : ../../../../CPP/7zip/Common/FileStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FileStreams.cpp
FilterCoder.o : ../../../../CPP/7zip/Common/FilterCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilterCoder.cpp
LimitedStreams.o : ../../../../CPP/7zip/Common/LimitedStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/LimitedStreams.cpp
MethodProps.o : ../../../../CPP/7zip/Common/MethodProps.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MethodProps.cpp
ProgressUtils.o : ../../../../CPP/7zip/Common/ProgressUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/ProgressUtils.cpp
PropId.o : ../../../../CPP/7zip/Common/PropId.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/PropId.cpp
StreamObjects.o : ../../../../CPP/7zip/Common/StreamObjects.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamObjects.cpp
StreamUtils.o : ../../../../CPP/7zip/Common/StreamUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamUtils.cpp
UniqBlocks.o : ../../../../CPP/7zip/Common/UniqBlocks.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/UniqBlocks.cpp
CopyCoder.o : ../../../../CPP/7zip/Compress/CopyCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyCoder.cpp
ArchiveCommandLine.o : ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp
ArchiveExtractCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
ArchiveOpenCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
Bench.o : ../../../../CPP/7zip/UI/Common/Bench.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Bench.cpp
DefaultName.o : ../../../../CPP/7zip/UI/Common/DefaultName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/DefaultName.cpp
EnumDirItems.o : ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp
Extract.o : ../../../../CPP/7zip/UI/Common/Extract.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Extract.cpp
ExtractingFilePath.o : ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
HashCalc.o : ../../../../CPP/7zip/UI/Common/HashCalc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/HashCalc.cpp
LoadCodecs.o : ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
OpenArchive.o : ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
PropIDUtils.o : ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
SetProperties.o : ../../../../CPP/7zip/UI/Common/SetProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/SetProperties.cpp
SortUtils.o : ../../../../CPP/7zip/UI/Common/SortUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/SortUtils.cpp
TempFiles.o : ../../../../CPP/7zip/UI/Common/TempFiles.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/TempFiles.cpp
Update.o : ../../../../CPP/7zip/UI/Common/Update.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Update.cpp
UpdateAction.o : ../../../../CPP/7zip/UI/Common/UpdateAction.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateAction.cpp
UpdateCallback.o : ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp
UpdatePair.o : ../../../../CPP/7zip/UI/Common/UpdatePair.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdatePair.cpp
UpdateProduce.o : ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp
WorkDir.o : ../../../../CPP/7zip/UI/Common/WorkDir.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/WorkDir.cpp
ZipRegistry.o : ../../../../CPP/7zip/UI/Common/ZipRegistry.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ZipRegistry.cpp
MyMessages.o : ../../../../CPP/7zip/UI/Explorer/MyMessages.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Explorer/MyMessages.cpp
ExtractCallback.o : ../../../../CPP/7zip/UI/FileManager/ExtractCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ExtractCallback.cpp
FormatUtils.o : ../../../../CPP/7zip/UI/FileManager/FormatUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/FormatUtils.cpp
LangUtils.o : ../../../../CPP/7zip/UI/FileManager/LangUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/LangUtils.cpp
OverwriteDialog.o : ../../../../CPP/7zip/UI/FileManager/OverwriteDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/OverwriteDialog.cpp
OverwriteDialog_rc.o : ../../../../CPP/7zip/UI/FileManager/OverwriteDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/OverwriteDialog_rc.cpp
PasswordDialog.o : ../../../../CPP/7zip/UI/FileManager/PasswordDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PasswordDialog.cpp
PasswordDialog_rc.o : ../../../../CPP/7zip/UI/FileManager/PasswordDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PasswordDialog_rc.cpp
ProgramLocation.o : ../../../../CPP/7zip/UI/FileManager/ProgramLocation.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ProgramLocation.cpp
PropertyName.o : ../../../../CPP/7zip/UI/FileManager/PropertyName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/PropertyName.cpp
ProgressDialog2.o : ../../../../CPP/7zip/UI/FileManager/ProgressDialog2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ProgressDialog2.cpp
ProgressDialog2_rc.o : ../../../../CPP/7zip/UI/FileManager/ProgressDialog2_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/ProgressDialog2_rc.cpp
SplitUtils.o : ../../../../CPP/7zip/UI/FileManager/SplitUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/SplitUtils.cpp
StringUtils.o : ../../../../CPP/7zip/UI/FileManager/StringUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/FileManager/StringUtils.cpp
BenchmarkDialog.o : ../../../../CPP/7zip/UI/GUI/BenchmarkDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/BenchmarkDialog.cpp
BenchmarkDialog_rc.o : ../../../../CPP/7zip/UI/GUI/BenchmarkDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/BenchmarkDialog_rc.cpp
CompressDialog.o : ../../../../CPP/7zip/UI/GUI/CompressDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/CompressDialog.cpp
CompressDialog_rc.o : ../../../../CPP/7zip/UI/GUI/CompressDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/CompressDialog_rc.cpp
ExtractDialog.o : ../../../../CPP/7zip/UI/GUI/ExtractDialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/ExtractDialog.cpp
ExtractDialog_rc.o : ../../../../CPP/7zip/UI/GUI/ExtractDialog_rc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/ExtractDialog_rc.cpp
ExtractGUI.o : ../../../../CPP/7zip/UI/GUI/ExtractGUI.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/ExtractGUI.cpp
GUI.o : ../../../../CPP/7zip/UI/GUI/GUI.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/GUI.cpp
HashGUI.o : ../../../../CPP/7zip/UI/GUI/HashGUI.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/HashGUI.cpp
UpdateCallbackGUI.o : ../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI.cpp
UpdateCallbackGUI2.o : ../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI2.cpp
UpdateGUI.o : ../../../../CPP/7zip/UI/GUI/UpdateGUI.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/UpdateGUI.cpp
wxGUI.o : ../../../../CPP/7zip/UI/GUI/wxGUI.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/GUI/wxGUI.cpp
CRC.o : ../../../../CPP/Common/CRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CRC.cpp
CommandLineParser.o : ../../../../CPP/Common/CommandLineParser.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CommandLineParser.cpp
IntToString.o : ../../../../CPP/Common/IntToString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/IntToString.cpp
Lang.o : ../../../../CPP/Common/Lang.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Lang.cpp
ListFileUtils.o : ../../../../CPP/Common/ListFileUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/ListFileUtils.cpp
MyString.o : ../../../../CPP/Common/MyString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyString.cpp
MyVector.o : ../../../../CPP/Common/MyVector.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyVector.cpp
MyWindows.o : ../../../../CPP/Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyWindows.cpp
NewHandler.o : ../../../../CPP/Common/NewHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/NewHandler.cpp
StringConvert.o : ../../../../CPP/Common/StringConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringConvert.cpp
StringToInt.o : ../../../../CPP/Common/StringToInt.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringToInt.cpp
UTFConvert.o : ../../../../CPP/Common/UTFConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/UTFConvert.cpp
Wildcard.o : ../../../../CPP/Common/Wildcard.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Wildcard.cpp
Controls.o : ../../../../CPP/Windows/Control/Controls.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Control/Controls.cpp
Dialog.o : ../../../../CPP/Windows/Control/Dialog.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Control/Dialog.cpp
DLL.o : ../../../../CPP/Windows/DLL.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/DLL.cpp
ErrorMsg.o : ../../../../CPP/Windows/ErrorMsg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/ErrorMsg.cpp
FileDir.o : ../../../../CPP/Windows/FileDir.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileDir.cpp
FileFind.o : ../../../../CPP/Windows/FileFind.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileFind.cpp
FileIO.o : ../../../../CPP/Windows/FileIO.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileIO.cpp
FileName.o : ../../../../CPP/Windows/FileName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileName.cpp
PropVariant.o : ../../../../CPP/Windows/PropVariant.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariant.cpp
PropVariantConv.o : ../../../../CPP/Windows/PropVariantConv.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariantConv.cpp
Registry.o : ../../../../CPP/Windows/Registry.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Registry.cpp
Synchronization.o : ../../../../CPP/Windows/Synchronization.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Synchronization.cpp
System.o : ../../../../CPP/Windows/System.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/System.cpp
TimeUtils.o : ../../../../CPP/Windows/TimeUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/TimeUtils.cpp
Window.o : ../../../../CPP/Windows/Window.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Window.cpp
wine_GetXXXDefaultLangID.o : ../../../../CPP/myWindows/wine_GetXXXDefaultLangID.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_GetXXXDefaultLangID.cpp
wine_date_and_time.o : ../../../../CPP/myWindows/wine_date_and_time.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_date_and_time.cpp

OBJS=\
 7zCrc.o \
 $(OBJ_CRC32) \
 Alloc.o \
 CpuArch.o \
 Threads.o \
 OutStreamWithCRC.o \
 CreateCoder.o \
 FilePathAutoRename.o \
 FileStreams.o \
 FilterCoder.o \
 LimitedStreams.o \
 MethodProps.o \
 ProgressUtils.o \
 PropId.o \
 StreamObjects.o \
 StreamUtils.o \
 UniqBlocks.o \
 CopyCoder.o \
 ArchiveCommandLine.o \
 ArchiveExtractCallback.o \
 ArchiveOpenCallback.o \
 Bench.o \
 DefaultName.o \
 EnumDirItems.o \
 Extract.o \
 ExtractingFilePath.o \
 HashCalc.o \
 LoadCodecs.o \
 OpenArchive.o \
 PropIDUtils.o \
 SetProperties.o \
 SortUtils.o \
 TempFiles.o \
 Update.o \
 UpdateAction.o \
 UpdateCallback.o \
 UpdatePair.o \
 UpdateProduce.o \
 WorkDir.o \
 ZipRegistry.o \
 MyMessages.o \
 ExtractCallback.o \
 FormatUtils.o \
 LangUtils.o \
 OverwriteDialog.o \
 OverwriteDialog_rc.o \
 PasswordDialog.o \
 PasswordDialog_rc.o \
 ProgramLocation.o \
 PropertyName.o \
 ProgressDialog2.o \
 ProgressDialog2_rc.o \
 SplitUtils.o \
 StringUtils.o \
 BenchmarkDialog.o \
 BenchmarkDialog_rc.o \
 CompressDialog.o \
 CompressDialog_rc.o \
 ExtractDialog.o \
 ExtractDialog_rc.o \
 ExtractGUI.o \
 GUI.o \
 HashGUI.o \
 UpdateCallbackGUI.o \
 UpdateCallbackGUI2.o \
 UpdateGUI.o \
 wxGUI.o \
 CRC.o \
 CommandLineParser.o \
 IntToString.o \
 Lang.o \
 ListFileUtils.o \
 MyString.o \
 MyVector.o \
 MyWindows.o \
 NewHandler.o \
 StringConvert.o \
 StringToInt.o \
 UTFConvert.o \
 Wildcard.o \
 Controls.o \
 Dialog.o \
 DLL.o \
 ErrorMsg.o \
 FileDir.o \
 FileFind.o \
 FileIO.o \
 FileName.o \
 PropVariant.o \
 PropVariantConv.o \
 Registry.o \
 Synchronization.o \
 System.o \
 TimeUtils.o \
 Window.o \
 wine_GetXXXDefaultLangID.o \
 wine_date_and_time.o \

#define IDS_PROGRESS_COMPRESSING  3301
#define IDS_ARCHIVES_COLON        3907
#define IDS_PROGRESS_REMOVE     3305

#define IDS_PROGRESS_ADD        3320
#define IDS_PROGRESS_UPDATE     3321
#define IDS_PROGRESS_ANALYZE    3322
#define IDS_PROGRESS_REPLICATE  3323
#define IDS_PROGRESS_REPACK     3324

#define IDS_PROGRESS_DELETE     3326
#define IDS_PROGRESS_HEADER     3327
// wxGUI.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#undef _WIN32

#ifdef __WXMAC__

#define UInt32 max_UInt32
#include <ApplicationServices/ApplicationServices.h>
#undef UInt32

#endif

#define static const
#include "../GUI/p7zip_32.xpm"
#undef static

#undef ACTIVATE_DIALOG_TESTS

#ifdef _WIN32
#error 5
#endif

#include "Windows/Window.h"
#include "Windows/Control/DialogImpl.h"

#include "Common/StringConvert.h"

bool GetProgramFolderPath(UString &folder)
{
  const char *p7zip_home_dir = getenv("P7ZIP_HOME_DIR");
  if (p7zip_home_dir == 0) p7zip_home_dir="./";

  folder = MultiByteToUnicodeString(p7zip_home_dir);

  return true;
}


// FIXME

static pthread_t g_main_thread;

bool is_main_thread(void)
{
	return ( g_main_thread == pthread_self() );
}

void verify_main_thread(void)
{
		if ( ! is_main_thread() )
		{
			printf("verify_main_thread-wxGUI\n");
			abort();
		}
}









int Main1(int argc,TCHAR **argv);

#include "Windows/Registry.h"
using namespace NWindows;
using namespace NRegistry;


#include "Common/StringConvert.h"
#include "Windows/FileDir.h"
#include "Windows/Synchronization.h"

#include "ExtractRes.h"
#include "../Explorer/MyMessages.h"

#include "../FileManager/resourceGui.h"
#include "ExtractGUI.h"
#include "UpdateGUI.h"
#include "BenchmarkDialog.h"
#include "../FileManager/RegistryUtils.h"

using namespace NWindows;
using namespace NFile;

#include "../FileManager/ProgramLocation.h"

static LPCWSTR kHelpFileName = L"help/";

void ShowHelpWindow(HWND hwnd, LPCWSTR topicFile)
{
  UString path;
  if (!::GetProgramFolderPath(path))
    return;
  path += kHelpFileName;
  path += topicFile;
  printf("ShowHelpWindow(%p,%ls)=>%ls\n",hwnd,topicFile,(const wchar_t *)path);
  // HtmlHelp(hwnd, GetSystemString(path), HH_DISPLAY_TOPIC, NULL);
  wxString path2(path);
  wxLaunchDefaultBrowser(path2);
}

////////////////////////////// TRIES ///////////////////////////////////

#ifdef ACTIVATE_DIALOG_TESTS
static void ErrorMessage(const wchar_t *message)
{
  MessageBox(0,message, wxT("7-Zip GUI"),wxICON_ERROR);
}

#include "../FileManager/PasswordDialog.h"
#include "../FileManager/MessagesDialog.h"
#include "../FileManager/OverwriteDialog.h"
#include "Windows/Thread.h"

void myErrorMsg(const wchar_t *message)
{
	MessageBox(0,message, wxT("Message"),wxICON_ERROR);
}

void testCMessagesDialog()
{
	UStringVector Messages;

	Messages.Add(L"message 1");
	Messages.Add(L"message 2");
	Messages.Add(L"message 3");
	Messages.Add(L"message 4");
	Messages.Add(L"message 5");
	Messages.Add(L"message 6");
	Messages.Add(L"message 7");
	Messages.Add(L"message 8");
	Messages.Add(L"message 9");

	CMessagesDialog messagesDialog;
    messagesDialog.Messages = &Messages;
   int ret = messagesDialog.Create( 0  ); // ParentWindow

   	if (ret == IDOK) myErrorMsg(wxT("CMessagesDialog => IDOK"));
	else if (ret == IDCANCEL) myErrorMsg(wxT("CMessagesDialog => IDCANCEL"));
	else  myErrorMsg(wxT("CMessagesDialog => ?"));

}

void testCOverwriteDialog()
{
SYSTEMTIME systemTime;
GetSystemTime( &systemTime );


const wchar_t *existName = L"existName";
FILETIME data_existTime;
FILETIME *existTime = &data_existTime ;
UInt64 data_existSize = 1234;
UInt64 *existSize = &data_existSize;
const wchar_t *newName = L"newName";
FILETIME data_newTime;
FILETIME *newTime = &data_newTime;
UInt64 data_newSize = 45678;
UInt64 *newSize = &data_newSize;
Int32 data_answer=0;
Int32 *answer = &data_answer;

SystemTimeToFileTime( &systemTime , &data_existTime);
SystemTimeToFileTime( &systemTime , &data_newTime);

  COverwriteDialog dialog;

  dialog.OldFileInfo.Time = *existTime;
  dialog.OldFileInfo.TimeIsDefined = true; // FIXME : look again at the sample !

  dialog.OldFileInfo.SizeIsDefined = (existSize != NULL);
  if (dialog.OldFileInfo.SizeIsDefined)
    dialog.OldFileInfo.Size = *existSize;
  dialog.OldFileInfo.Name = existName;

  if (newTime == 0)
    dialog.NewFileInfo.TimeIsDefined = false;
  else
  {
    dialog.NewFileInfo.TimeIsDefined = true;
    dialog.NewFileInfo.Time = *newTime;
  }
  
  dialog.NewFileInfo.SizeIsDefined = (newSize != NULL);
  if (dialog.NewFileInfo.SizeIsDefined)
    dialog.NewFileInfo.Size = *newSize;
  dialog.NewFileInfo.Name = newName;
  
  /*
  NOverwriteDialog::NResult::EEnum writeAnswer = 
    NOverwriteDialog::Execute(oldFileInfo, newFileInfo);
  */
  INT_PTR writeAnswer = dialog.Create(NULL); // ParentWindow doesn't work with 7z
  
  switch(writeAnswer)
  {
  case IDCANCEL: myErrorMsg(wxT("COverwriteDialog => IDCANCEL")); break;
  case IDNO:     myErrorMsg(wxT("COverwriteDialog => IDNO")); break;
  case IDC_BUTTON_OVERWRITE_NO_TO_ALL: myErrorMsg(wxT("COverwriteDialog => IDC_BUTTON_OVERWRITE_NO_TO_ALL")); break;
  case IDC_BUTTON_OVERWRITE_YES_TO_ALL:myErrorMsg(wxT("COverwriteDialog => IDC_BUTTON_OVERWRITE_YES_TO_ALL")); break;
  case IDC_BUTTON_OVERWRITE_AUTO_RENAME:myErrorMsg(wxT("COverwriteDialog => IDC_BUTTON_OVERWRITE_AUTO_RENAME")); break;
  case IDYES:  myErrorMsg(wxT("COverwriteDialog => IDYES")); break;
  default:  myErrorMsg(wxT("COverwriteDialog => default")); break;
  }
}

void testCPasswordDialog()
{
    CPasswordDialog dialog;

	int ret = dialog.Create(0);
	if (ret == IDOK) {
    		UString Password = dialog.Password;
		UString msg  = wxT("CPasswordDialog => IDOK password=\"");
		msg += Password;
		msg += wxT("\"");
		myErrorMsg(msg);
	}
	else if (ret == IDCANCEL) myErrorMsg(wxT("CPasswordDialog => IDCANCEL"));
	else  myErrorMsg(wxT("CPasswordDialog => ?"));

}

struct CThreadProgressDialog
{
  CProgressDialog * ProgressDialog;
  static THREAD_FUNC_DECL MyThreadFunction(void *param)
  {
    ((CThreadProgressDialog *)param)->Result = ((CThreadProgressDialog *)param)->Process();
    return 0;
  }
  HRESULT Result;
  HRESULT Process()
  {
	Sleep(1000);
	int total = 1000;

	ProgressDialog->ProgressSynch.SetTitleFileName(L"SetTitleFileName");
	ProgressDialog->ProgressSynch.SetNumFilesTotal(100);
	ProgressDialog->ProgressSynch.SetNumFilesCur(1);
	ProgressDialog->ProgressSynch.SetProgress(total, 0);
	// ProgressDialog.ProgressSynch.SetRatioInfo(inSize, outSize);
	// ProgressDialog.ProgressSynch.SetCurrentFileName(name);

	ProgressDialog->ProgressSynch.SetPos(total/10);
	ProgressDialog->ProgressSynch.SetCurrentFileName(L"File1");
	Sleep(1000);
	ProgressDialog->ProgressSynch.SetPos(total/2);
	ProgressDialog->ProgressSynch.SetCurrentFileName(L"File2");
	Sleep(1000);
	ProgressDialog->ProgressSynch.SetPos(total);
	ProgressDialog->ProgressSynch.SetCurrentFileName(L"File3");
	Sleep(1000);
	ProgressDialog->MyClose();
	return 0;
  }
};

void testCProgressDialog()
{
  CProgressDialog ProgressDialog;

  CThreadProgressDialog benchmarker;
  benchmarker.ProgressDialog = &ProgressDialog;
  NWindows::CThread thread;
  thread.Create(CThreadProgressDialog::MyThreadFunction, &benchmarker);

  //  void StartProgressDialog(const UString &title)
  int ret = ProgressDialog.Create(L"testCProgressDialog", 0);

	if (ret == IDOK) myErrorMsg(wxT("CProgressDialog => IDOK"));
	else if (ret == IDCANCEL) myErrorMsg(wxT("CProgressDialog => IDCANCEL"));
	else  myErrorMsg(wxT("CProgressDialog => ?"));

}

void testDialog(int num)
{
	NWindows::NControl::CModalDialog dialog;

	printf("Generic Dialog(%d)\n",num);
	int ret = dialog.Create(num, 0);
	if (ret == IDOK) myErrorMsg(wxT("Generic Dialog => IDOK"));
	else if (ret == IDCANCEL) myErrorMsg(wxT("Generic Dialog => IDCANCEL"));
	else  myErrorMsg(wxT("Generic Dialog => ?"));
}

void testMessageBox()
{
	int ret = MessageBoxW(0, L"test yes/no/cancel", 
            L"7-Zip", MB_YESNOCANCEL | MB_ICONQUESTION | MB_TASKMODAL);
	if (ret == IDYES) myErrorMsg(wxT("MessageBoxW => IDYES"));
	else if (ret == IDNO) myErrorMsg(wxT("MessageBoxW => IDNO"));
	else if (ret == IDCANCEL) myErrorMsg(wxT("MessageBoxW => IDCANCEL"));
	else  myErrorMsg(wxT("MessageBoxW => ?"));
}

static void testRegistry()
{
	SaveRegLang(L"fr");

	UString langFile;
	ReadRegLang(langFile);

	printf("testRegistry : -%ls-\n",(const wchar_t *)langFile);
}


int Main2(int argc,TCHAR **argv);

int Main3(int argc,wxChar **argv)
{
	testRegistry();

	int num = -1;

	if (argc >=2 )
	{
		num = argv[1][0] - L'0';
	}
	printf("num=%d\n",num);


	switch(num)
	{
		case 0:
		{
			TCHAR **argv2 = (TCHAR **)calloc(argc,sizeof(*argv));

			argv2[0] = argv[0];
			for(int i = 2; i < argc; i++) argv2[i-1] = argv[i];

			return Main2(argc-1,argv2);
		}
	// TODO Benchmark
	// TODO CCompressDialog
	// TODO CExtractDialog ?
		case 1 : testCMessagesDialog();  break;
		case 2 : testCOverwriteDialog(); break;
	 	case 3 : testCPasswordDialog();  break;
		case 4 : testCProgressDialog();  break;
		case 5 : testMessageBox();  break;
		case 9 : 
			if (argc >= 3)
			{
				AString str = GetAnsiString(argv[2]);
				int num = atoi((const char*)str);
				testDialog(num);
			}
			else
			{
				printf("usage : 7zG 9 <windowID>\n");
			}
		      	break;
		default :
			printf("usage : 7zG number\n");

	};

	return 0;
}

#endif // ACTIVATE_DIALOG_TESTS

static const TCHAR *kCUBasePath = TEXT("Software/7-ZIP");
static const WCHAR *kLangValueName = L"Lang";

void SaveRegLang(const UString &langFile)
{
  CKey key;
  key.Create(HKEY_CURRENT_USER, kCUBasePath);
  key.SetValue(kLangValueName, langFile);
}

void ReadRegLang(UString &langFile)
{
  langFile.Empty();
  CKey key;
  if (key.Open(HKEY_CURRENT_USER, kCUBasePath, KEY_READ) == ERROR_SUCCESS)
    key.QueryValue(kLangValueName, langFile);
}


//////////////////////////////////

#define NEED_NAME_WINDOWS_TO_UNIX
#include "myPrivate.h" // global_use_utf16_conversion

void mySplitCommandLineW(int numArguments, TCHAR  **arguments,UStringVector &parts) {

  parts.Clear();
  for(int ind=0;ind < numArguments; ind++) {
      UString tmp = arguments[ind];
      // tmp.Trim(); " " is a valid filename ...
      if (!tmp.IsEmpty()) {
        parts.Add(tmp);
// DEBUG printf("ARG %d : '%ls'\n",ind,(const wchar_t *)tmp);
      }
  }
}

// ----------------------------------------------------------------------------
// private classes
// ----------------------------------------------------------------------------

// Define a new frame type
class MyFrame: public wxFrame
{
public:
    // ctor
    MyFrame(wxFrame *frame, const wxString& title, int x, int y, int w, int h);
    // virtual ~MyFrame();

    // operations
    void WriteText(const wxString& text) { m_txtctrl->WriteText(text); }
    
protected:
    // callbacks
    void OnWorkerEvent(wxCommandEvent& event);
private:
    // just some place to put our messages in
    wxTextCtrl *m_txtctrl;
    DECLARE_EVENT_TABLE()
};

BEGIN_EVENT_TABLE(MyFrame, wxFrame)
    EVT_MENU(WORKER_EVENT, MyFrame::OnWorkerEvent)
    // EVT_IDLE(MyFrame::OnIdle)
END_EVENT_TABLE()

// My frame constructor
MyFrame::MyFrame(wxFrame *frame, const wxString& title,
                 int x, int y, int w, int h)
       : wxFrame(frame, wxID_ANY, title, wxPoint(x, y), wxSize(w, h))
{
	this->SetIcon(wxICON(p7zip_32));
    
#if wxUSE_STATUSBAR
    CreateStatusBar(2);
#endif // wxUSE_STATUSBAR

    m_txtctrl = new wxTextCtrl(this, wxID_ANY, _T(""), wxPoint(0, 0), wxSize(0, 0), wxTE_MULTILINE | wxTE_READONLY);
}

void myCreateHandle(int n);
wxWindow * g_window=0;

void MyFrame::OnWorkerEvent(wxCommandEvent& event)
{
	int n = event.GetInt();
	myCreateHandle(n);
}


// Define a new application type, each program should derive a class from wxApp
class MyApp : public wxApp
{
public:
    // override base class virtuals
    // ----------------------------

    // this one is called on application startup and is a good place for the app
    // initialization (doing it here and not in the ctor allows to have an error
    // return: if OnInit() returns false, the application terminates)
    virtual bool OnInit();
};

// Create a new application object: this macro will allow wxWidgets to create
// the application object during program execution (it's better than using a
// static object for many reasons) and also implements the accessor function
// wxGetApp() which will return the reference of the right type (i.e. MyApp and
// not wxApp)
IMPLEMENT_APP(MyApp)



time_t g_T0 = 0;

/* FIXME : to erase ?
class MyThread : public wxThread
{
	int _argc;
	TCHAR **_argv;
public:
	MyThread(int argc,TCHAR **argv): wxThread(),_argc(argc), _argv(argv) {}

	// thread execution starts here
	virtual void *Entry()
	{
#ifdef ACTIVATE_DIALOG_TESTS
		int ret = Main3(_argc,_argv);
#else
		int ret = Main1(_argc,_argv);
#endif
		exit(ret);
	}
};
*/

// 'Main program' equivalent: the program execution "starts" here
bool MyApp::OnInit()
{
    // don't parse the command-line options !
    // : if ( !wxApp::OnInit() ) return false;

#ifdef __WXMAC__
ProcessSerialNumber PSN;
GetCurrentProcess(&PSN);
TransformProcessType(&PSN,kProcessTransformToForegroundApplication);
#endif
	
	
	g_main_thread = pthread_self();

  { // define P7ZIP_HOME_DIR
    extern void my_windows_split_path(const AString &p_path, AString &dir , AString &base);
    static char p7zip_home_dir[MAX_PATH];

    UString fullPath;
    NDir::MyGetFullPathName(wxApp::argv[0], fullPath);
    AString afullPath = GetAnsiString(fullPath);

    AString dir,name;

    my_windows_split_path(afullPath,dir,name);

    const char *dir2 = nameWindowToUnix((const char *)dir);
    snprintf(p7zip_home_dir,sizeof(p7zip_home_dir),"P7ZIP_HOME_DIR=%s/",dir2);
    p7zip_home_dir[sizeof(p7zip_home_dir)-1] = 0;
    putenv(p7zip_home_dir);
    // DEBUG printf("putenv(%s)\n",p7zip_home_dir);
  }
  global_use_utf16_conversion = 1; // UNICODE !

  g_T0 = time(0);
  // DEBUG printf("MAIN Thread : 0x%lx\n",wxThread::GetCurrentId());

  // Create the main frame window
  MyFrame *frame = new MyFrame((wxFrame *)NULL, _T("7-zip Main Window"), 50, 50, 450, 340);
  // Don't Show the frame !
  // frame->Show(true);

  g_window = frame;

  SetTopWindow(frame);

/* FIXME ?	
    MyThread *thread = new MyThread(wxApp::argc,wxApp::argv);
    thread->Create(); //  != wxTHREAD_NO_ERROR
    thread->Run();

  // success: wxApp::OnRun() will be called which will enter the main message
  // loop and the application will run. If we returned false here, the
  // application would exit immediately.
    return true;
*/
	
	int ret = Main1(wxApp::argc,wxApp::argv);
	
	exit(ret);
	
	return false;
}

//////////////////////////////////////////

#include "resource2.h"
#include "resource3.h"
#include "ExtractRes.h"
// #include "resourceGui.h"
#include "../FileManager/PropertyNameRes.h"


static CStringTable g_stringTable[] =
{
  /* GUI/resource2.rc */	  


    { IDS_PROGRESS_COMPRESSING  ,L"Compressing" },
    { IDS_ARCHIVES_COLON  ,L"Archives:" },

  /* ../FileManager/resourceGui.rc */
  { IDS_MESSAGE_NO_ERRORS     ,L"There are no errors" },

  { IDS_PROGRESS_TESTING      ,L"Testing" },

  { IDS_CHECKSUM_CALCULATING    ,L"Checksum calculating..." },
  { IDS_CHECKSUM_INFORMATION    ,L"Checksum information" },
  { IDS_CHECKSUM_CRC_DATA       ,L"CRC checksum for data:" },
  { IDS_CHECKSUM_CRC_DATA_NAMES ,L"CRC checksum for data and names:" },
  { IDS_CHECKSUM_CRC_STREAMS_NAMES ,L"CRC checksum for streams and names:" },

  { IDS_INCORRECT_VOLUME_SIZE ,L"Incorrect volume size" },

  { IDS_OPENNING  ,L"Opening..." },
  { IDS_SCANNING  ,L"Scanning..." },

  /* ../FileManager/PropertyName.rc */
  { IDS_PROP_PATH         ,L"Path" },
  { IDS_PROP_NAME         ,L"Name" },
  { IDS_PROP_EXTENSION    ,L"Extension" },
  { IDS_PROP_IS_FOLDER    ,L"Folder" },
  { IDS_PROP_SIZE         ,L"Size" },
  { IDS_PROP_PACKED_SIZE  ,L"Packed Size" },
  { IDS_PROP_ATTRIBUTES   ,L"Attributes" },
  { IDS_PROP_CTIME        ,L"Created" },
  { IDS_PROP_ATIME        ,L"Accessed" },
  { IDS_PROP_MTIME        ,L"Modified" },
  { IDS_PROP_SOLID        ,L"Solid" },
  { IDS_PROP_C0MMENTED    ,L"Commented" },
  { IDS_PROP_ENCRYPTED    ,L"Encrypted" },
  { IDS_PROP_SPLIT_BEFORE ,L"Split Before" },
  { IDS_PROP_SPLIT_AFTER  ,L"Split After" },
  { IDS_PROP_DICTIONARY_SIZE ,L"Dictionary" },
  { IDS_PROP_CRC          ,L"CRC" },
  { IDS_PROP_FILE_TYPE    ,L"Type" },
  { IDS_PROP_ANTI         ,L"Anti" },
  { IDS_PROP_METHOD       ,L"Method" },
  { IDS_PROP_HOST_OS      ,L"Host OS" },
  { IDS_PROP_FILE_SYSTEM  ,L"File System" },
  { IDS_PROP_USER         ,L"User" },
  { IDS_PROP_GROUP        ,L"Group" },
  { IDS_PROP_BLOCK        ,L"Block" },
  { IDS_PROP_COMMENT      ,L"Comment" },
  { IDS_PROP_POSITION     ,L"Position" },
  { IDS_PROP_PREFIX       ,L"Path Prefix" },
  { IDS_PROP_FOLDERS      ,L"Folders" },
  { IDS_PROP_FILES        ,L"Files" },
  { IDS_PROP_VERSION      ,L"Version" },
  { IDS_PROP_VOLUME       ,L"Volume" },
  { IDS_PROP_IS_VOLUME    ,L"Multivolume" },
  { IDS_PROP_OFFSET       ,L"Offset" },
  { IDS_PROP_LINKS        ,L"Links" },
  { IDS_PROP_NUM_BLOCKS   ,L"Blocks" },
  { IDS_PROP_NUM_VOLUMES  ,L"Volumes" },

  { IDS_PROP_BIT64        ,L"64-bit" },
  { IDS_PROP_BIG_ENDIAN   ,L"Big-endian" },
  { IDS_PROP_CPU          ,L"CPU" },
  { IDS_PROP_PHY_SIZE     ,L"Physical Size" },
  { IDS_PROP_HEADERS_SIZE ,L"Headers Size" },
  { IDS_PROP_CHECKSUM     ,L"Checksum" },
  { IDS_PROP_CHARACTS     ,L"Characteristics" },
  { IDS_PROP_VA           ,L"Virtual Address" },
  { IDS_PROP_ID           ,L"ID" },
  { IDS_PROP_SHORT_NAME   ,L"Short Name" },
  { IDS_PROP_CREATOR_APP  ,L"Creator Application" },
  { IDS_PROP_SECTOR_SIZE  ,L"Sector Size" },
  { IDS_PROP_POSIX_ATTRIB ,L"Mode" },
  { IDS_PROP_SYM_LINK     ,L"Symbolic Link" },
  { IDS_PROP_ERROR        ,L"Error" },
  { IDS_PROP_TOTAL_SIZE   ,L"Total Size" },
  { IDS_PROP_FREE_SPACE   ,L"Free Space" },
  { IDS_PROP_CLUSTER_SIZE ,L"Cluster Size" },
  { IDS_PROP_VOLUME_NAME  ,L"Label" },
  { IDS_PROP_LOCAL_NAME   ,L"Local Name" },
  { IDS_PROP_PROVIDER     ,L"Provider" },
  { IDS_PROP_NT_SECURITY  ,L"NT Security" },
  { IDS_PROP_ALT_STREAM   ,L"Alternate Stream" },
  { IDS_PROP_AUX          ,L"Aux" },
  { IDS_PROP_DELETED      ,L"Deleted" },
  { IDS_PROP_IS_TREE      ,L"Is Tree" },
  { IDS_PROP_SHA1         ,L"SHA-1" },
  { IDS_PROP_SHA256       ,L"SHA-256" },
  { IDS_PROP_ERROR_TYPE   ,L"Error Type" },
  { IDS_PROP_NUM_ERRORS   ,L"Errors" },
  { IDS_PROP_ERROR_FLAGS  ,L"Errors" },
  { IDS_PROP_WARNING_FLAGS ,L"Warnings" },
  { IDS_PROP_WARNING      ,L"Warning" },
  { IDS_PROP_NUM_STREAMS  ,L"Streams" },
  { IDS_PROP_NUM_ALT_STREAMS ,L"Alternate Streams" },
  { IDS_PROP_ALT_STREAMS_SIZE ,L"Alternate Streams Size" },
  { IDS_PROP_VIRTUAL_SIZE ,L"Virtual Size" },
  { IDS_PROP_UNPACK_SIZE  ,L"Unpack Size" },
  { IDS_PROP_TOTAL_PHY_SIZE ,L"Total Physical Size" },
  { IDS_PROP_VOLUME_INDEX ,L"Volume Index" },
  { IDS_PROP_SUBTYPE      ,L"SubType" },
  { IDS_PROP_SHORT_COMMENT ,L"Short Comment" },
  { IDS_PROP_CODE_PAGE    ,L"Code Page" },
  { IDS_PROP_IS_NOT_ARC_TYPE  ,L"Is not archive type" },
  { IDS_PROP_PHY_SIZE_CANT_BE_DETECTED ,L"Physical Size can't be detected" },
  { IDS_PROP_ZEROS_TAIL_IS_ALLOWED ,L"Zeros Tail Is Allowed" },
  { IDS_PROP_TAIL_SIZE ,L"Tail Size" },
  { IDS_PROP_EMB_STUB_SIZE ,L"Embedded Stub Size" },
  { IDS_PROP_NT_REPARSE   ,L"Link" },
  { IDS_PROP_HARD_LINK    ,L"Hard Link" },
  { IDS_PROP_INODE        ,L"iNode" },
  { IDS_PROP_STREAM_ID    ,L"Stream ID" },



  /* Extract.rc */	  
  /**************/
  { IDS_MEM_ERROR  ,L"The system cannot allocate the required amount of memory" },
  { IDS_CANNOT_CREATE_FOLDER  ,L"Cannot create folder '{0}'" },
  { IDS_UPDATE_NOT_SUPPORTED  ,L"Update operations are not supported for this archive." },
  { IDS_CANT_OPEN_ARCHIVE  ,L"Can not open file '{0}' as archive" },
  { IDS_CANT_OPEN_ENCRYPTED_ARCHIVE  ,L"Can not open encrypted archive '{0}'. Wrong password?" },
  { IDS_UNSUPPORTED_ARCHIVE_TYPE  ,L"Unsupported archive type" },

  { IDS_CANT_OPEN_AS_TYPE   ,L"Can not open the file as {0} archive" },
  { IDS_IS_OPEN_AS_TYPE     ,L"The file is open as {0} archive" },
  { IDS_IS_OPEN_WITH_OFFSET ,L"The archive is open with offset" },

  { IDS_PROGRESS_EXTRACTING ,L"Extracting" },

  { IDS_PROGRESS_SKIPPING ,L"Skipping" },

  { IDS_EXTRACT_SET_FOLDER  ,L"Specify a location for extracted files." },

  { IDS_EXTRACT_PATHS_FULL    ,L"Full pathnames" },
  { IDS_EXTRACT_PATHS_NO      ,L"No pathnames" },
  { IDS_EXTRACT_PATHS_ABS     ,L"Absolute pathnames" },
  { IDS_PATH_MODE_RELAT       ,L"Relative pathnames" },

  { IDS_EXTRACT_OVERWRITE_ASK             ,L"Ask before overwrite" },
  { IDS_EXTRACT_OVERWRITE_WITHOUT_PROMPT  ,L"Overwrite without prompt" },
  { IDS_EXTRACT_OVERWRITE_SKIP_EXISTING   ,L"Skip existing files" },
  { IDS_EXTRACT_OVERWRITE_RENAME          ,L"Auto rename" },
  { IDS_EXTRACT_OVERWRITE_RENAME_EXISTING ,L"Auto rename existing files" },

  { IDS_EXTRACT_MESSAGE_UNSUPPORTED_METHOD   ,L"Unsupported compression method for '{0}'." },
  { IDS_EXTRACT_MESSAGE_DATA_ERROR           ,L"Data error in '{0}'. File is broken" },
  { IDS_EXTRACT_MESSAGE_CRC_ERROR            ,L"CRC failed in '{0}'. File is broken." },
  { IDS_EXTRACT_MESSAGE_DATA_ERROR_ENCRYPTED ,L"Data error in encrypted file '{0}'. Wrong password?" },
  { IDS_EXTRACT_MESSAGE_CRC_ERROR_ENCRYPTED  ,L"CRC failed in encrypted file '{0}'. Wrong password?" },

  { IDS_EXTRACT_MSG_WRONG_PSW_GUESS          ,L"Wrong password?" },
  // { IDS_EXTRACT_MSG_ENCRYPTED            ,L"Encrypted file" },

  { IDS_EXTRACT_MSG_UNSUPPORTED_METHOD   ,L"Unsupported compression method" },
  { IDS_EXTRACT_MSG_DATA_ERROR           ,L"Data error" },
  { IDS_EXTRACT_MSG_CRC_ERROR            ,L"CRC failed" },
  { IDS_EXTRACT_MSG_UNAVAILABLE_DATA     ,L"Unavailable data" },
  { IDS_EXTRACT_MSG_UEXPECTED_END        ,L"Unexpected end of data" },
  { IDS_EXTRACT_MSG_DATA_AFTER_END       ,L"There are some data after the end of the payload data" },
  { IDS_EXTRACT_MSG_IS_NOT_ARC           ,L"Is not archive" },
  { IDS_EXTRACT_MSG_HEADERS_ERROR        ,L"Headers Error" },
  { IDS_EXTRACT_MSG_WRONG_PSW_CLAIM      ,L"Wrong password" },

  { IDS_OPEN_MSG_UNAVAILABLE_START  ,L"Unavailable start of archive" },
  { IDS_OPEN_MSG_UNCONFIRMED_START  ,L"Unconfirmed start of archive" },
  // { IDS_OPEN_MSG_ERROR_FLAGS + 5  ,L"Unexpected end of archive" },
  // { IDS_OPEN_MSG_ERROR_FLAGS + 6  ,L"There are data after the end of archive" },
  { IDS_OPEN_MSG_UNSUPPORTED_FEATURE  ,L"Unsupported feature" },


  // resource3.rc
  { IDS_PROGRESS_REMOVE     ,L"Removing" },

  { IDS_PROGRESS_ADD        ,L"Adding" },
  { IDS_PROGRESS_UPDATE     ,L"Updating" },
  { IDS_PROGRESS_ANALYZE    ,L"Analyzing" },
  { IDS_PROGRESS_REPLICATE  ,L"Replicating" },
  { IDS_PROGRESS_REPACK     ,L"Repacking" },

  { IDS_PROGRESS_DELETE     ,L"Deleting" },
  { IDS_PROGRESS_HEADER     ,L"Header creating" },


	{ 0 , 0 }
};

REGISTER_STRINGTABLE(g_stringTable)



# WARNING : automatically generated by utils/generate.py

PROG=../../../../bin/P7ZIP$(BINSUFFIX)

all: $(PCH_NAME) $(PROG)

LOCAL_FLAGS=$(TARGET_FLAGS) \
  -DLANG \
  -DEXTERNAL_CODECS \
  -D_FILE_OFFSET_BITS=64 \
  -D_LARGEFILE_SOURCE \
  -D_REENTRANT \
  -DENV_UNIX \
  -DBREAK_HANDLER \
  -DUNICODE \
  -D_UNICODE \
  -DUNIX_USE_WIN_FILE \

SRCS=\
  ../../../../CPP/7zip/UI/P7ZIP/wxP7ZIP.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \

SRCS_C=\
  ../../../../C/Threads.c \

StdAfx.h.gch : ../../../myWindows/StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) ../../../myWindows/StdAfx.h -o StdAfx.h.gch
Threads.o : ../../../../C/Threads.c
	$(CC) $(CFLAGS) ../../../../C/Threads.c
wxP7ZIP.o : ../../../../CPP/7zip/UI/P7ZIP/wxP7ZIP.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/P7ZIP/wxP7ZIP.cpp
IntToString.o : ../../../../CPP/Common/IntToString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/IntToString.cpp
MyString.o : ../../../../CPP/Common/MyString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyString.cpp
MyVector.o : ../../../../CPP/Common/MyVector.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyVector.cpp
StringConvert.o : ../../../../CPP/Common/StringConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringConvert.cpp
FileDir.o : ../../../../CPP/Windows/FileDir.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileDir.cpp
FileFind.o : ../../../../CPP/Windows/FileFind.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileFind.cpp
FileIO.o : ../../../../CPP/Windows/FileIO.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileIO.cpp
FileName.o : ../../../../CPP/Windows/FileName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileName.cpp
MyWindows.o : ../../../../CPP/Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyWindows.cpp
wine_date_and_time.o : ../../../../CPP/myWindows/wine_date_and_time.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_date_and_time.cpp

OBJS=\
 Threads.o \
 wxP7ZIP.o \
 IntToString.o \
 MyString.o \
 MyVector.o \
 StringConvert.o \
 FileDir.o \
 FileFind.o \
 FileIO.o \
 FileName.o \
 MyWindows.o \
 wine_date_and_time.o \

// wxFM.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#include "wx/dnd.h"

#undef _WIN32
 
#ifdef __WXMAC__

#define UInt32 max_UInt32
#include <ApplicationServices/ApplicationServices.h>
#undef UInt32

#endif

#include "Common/StringConvert.h"
#include "Windows/FileDir.h"

#define NEED_NAME_WINDOWS_TO_UNIX
#include "myPrivate.h" // global_use_utf16_conversion

using namespace NWindows;
using namespace NFile;

///////////////////////////////////////////

static LPCWSTR kArchiveNoNameSwitch = L" -an";

HRESULT MyCreateProcess(const UString &params,LPCWSTR curDir, bool waitFinish)
{
	printf("MyCreateProcess: waitFinish=%d\n",(unsigned)waitFinish);
	printf("\tparams : %ls\n",(const wchar_t*)params);

	printf("\tcurDir : %ls\n",(const wchar_t*)curDir);
	
	wxString cmd(params);
	wxString memoCurDir = wxGetCwd();
	
	if (curDir) {  // FIXME
		wxSetWorkingDirectory(wxString(curDir));
	}
	
	printf("MyCreateProcess: cmd='%ls'\n",(const wchar_t *)cmd);
	long pid = 0;
	if (waitFinish) pid = wxExecute(cmd, wxEXEC_SYNC); // FIXME process never ends and stays zombie ...
	else            pid = wxExecute(cmd, wxEXEC_ASYNC);
	
	if (curDir) {
		wxSetWorkingDirectory(memoCurDir);
	}
	
	// FIXME if (pid == 0) return E_FAIL;
	
	return S_OK;
}



static HRESULT ExtractGroupCommand(const UStringVector &archivePaths,
								   const UString &params)
{
	UString params2 = params;
//	AddLagePagesSwitch(params2);
	params2 += kArchiveNoNameSwitch;

	
	char tempFile[256];
	static int count = 1000;
	
	sprintf(tempFile,"/tmp/7zExtract_%d_%d.tmp",(int)getpid(),count++);
	
	FILE * file = fopen(tempFile,"w");
	if (file)
	{
		for (int i = 0; i < archivePaths.Size(); i++) {
			fprintf(file,"%ls\n",(const wchar_t *)archivePaths[i]);
			printf(" TMP_%d : '%ls'\n",i,(const wchar_t *)archivePaths[i]);
		}
		
		fclose(file);
	}
	params2 += L" -ai@";
	params2 += GetUnicodeString(tempFile);
	printf("ExtractGroupCommand : -%ls-\n",(const wchar_t *)params2);
	HRESULT res = MyCreateProcess(params2, 0, true);
	printf("ExtractGroupCommand : END\n");
	
	remove(tempFile);
	
	return res;
}


HRESULT TestArchives(const UStringVector &archivePaths)
{
	UString params;
	params = L"/Users/me/P7ZIP/bin/7zG"; // Get7zGuiPath();
	params += L" t";
	return ExtractGroupCommand(archivePaths, params);
}

// Define a new application type, each program should derive a class from wxApp
class MyApp : public wxApp
{
public:
    virtual bool OnInit();
};

// Create a new application object: this macro will allow wxWidgets to create
// the application object during program execution (it's better than using a
// static object for many reasons) and also implements the accessor function
// wxGetApp() which will return the reference of the right type (i.e. MyApp and
// not wxApp)
IMPLEMENT_APP(MyApp)


class DnDFile : public wxFileDropTarget
{
public:
    DnDFile(wxListBox *pOwner) { m_pOwner = pOwner; }
	
    virtual bool OnDropFiles(wxCoord x, wxCoord y,
                             const wxArrayString& filenames);
	
private:
    wxListBox *m_pOwner;
};




bool DnDFile::OnDropFiles(wxCoord, wxCoord, const wxArrayString& filenames)
{
    size_t nFiles = filenames.GetCount();
    wxString str;
    str.Printf( _T("%d files dropped"), (int)nFiles);
    m_pOwner->Append(str);
	
	UStringVector archivePaths;
		
    for ( size_t n = 0; n < nFiles; n++ )
    {
       // m_pOwner->Append(filenames[n]);
/*		
        if (wxFile::Exists(filenames[n]))
            m_pOwner->Append(wxT("  This file exists.") );
        else
            m_pOwner->Append(wxT("  This file doesn't exist.") );
*/
		// cmd = cmd + _T(" \"") + filenames[n] + _T("\"");
		const wchar_t * wx = 	filenames[n].wc_str ();
		archivePaths.Add(wx);
    }
	
	/*
	m_pOwner->Append(cmd);
	

	long pid = 0;
	
	pid = wxExecute(cmd, wxEXEC_ASYNC);
	 */
	
	TestArchives(archivePaths);
	
    return true;
}

//////////////////

class DnDFrame : public wxFrame
{
public:
    DnDFrame(wxFrame *frame, const wxChar *title, int x, int y, int w, int h);
    virtual ~DnDFrame();
	
	 void OnQuit(wxCommandEvent& event);
	
    DECLARE_EVENT_TABLE()
	
// private:
public:
    // GUI controls
    wxListBox  *m_ctrlFile;
	
};

enum
{
    Menu_Quit = 1,
    Menu_Drag,
    Menu_DragMoveDef,
    Menu_DragMoveAllow,
    Menu_NewFrame,
    Menu_About = 101,
    Menu_OpenFile,
    Menu_Help,
    Menu_Clear,
    Menu_Copy,
    Menu_Paste,
    Menu_CopyBitmap,
    Menu_PasteBitmap,
    Menu_PasteMFile,
    Menu_CopyFiles,
    Menu_Shape_New = 500,
    Menu_Shape_Edit,
    Menu_Shape_Clear,
    Menu_ShapeClipboard_Copy,
    Menu_ShapeClipboard_Paste,
    Button_Colour = 1001
};

DnDFrame::DnDFrame(wxFrame *frame, const wxChar *title, int x, int y, int w, int h)
: wxFrame(frame, wxID_ANY, title, wxPoint(x, y), wxSize(w, h))
{
    // frame icon and status bar
    // FIXME SetIcon(wxICON(sample));

	

    // construct menu
    wxMenu *file_menu = new wxMenu;
    file_menu->Append(Menu_Drag, _T("&Test drag..."));
    file_menu->AppendCheckItem(Menu_DragMoveDef, _T("&Move by default"));
    file_menu->AppendCheckItem(Menu_DragMoveAllow, _T("&Allow moving"));
    file_menu->AppendSeparator();
    file_menu->Append(Menu_NewFrame, _T("&New frame\tCtrl-N"));
    file_menu->AppendSeparator();
    file_menu->Append(Menu_OpenFile, _T("&Open file..."));
    file_menu->AppendSeparator();
    file_menu->Append(Menu_Quit, _T("E&xit\tCtrl-Q"));	
	
    wxMenuBar *menu_bar = new wxMenuBar;
    menu_bar->Append(file_menu, _T("&File"));
//#if wxUSE_LOG
//    menu_bar->Append(log_menu,  _T("&Log"));
//#endif // wxUSE_LOG
//    menu_bar->Append(clip_menu, _T("&Clipboard"));
//    menu_bar->Append(help_menu, _T("&Help"));
	
    SetMenuBar(menu_bar);
	
	
    // 
    // wxString strFile(_T("Drop files here!"));
	
	wxString str;
	wxString str2 = wxString::FromUTF8(getenv("P7ZIP_HOME_DIR"));
    str = wxString(_T("P7ZIP_HOME_DIR -")) + str2 + _T("-");
	
	wxString strFile(str);
	
    m_ctrlFile  = new wxListBox(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, 1, &strFile ,
                                wxLB_HSCROLL | wxLB_ALWAYS_SB );
	

    // m_ctrlFile->Append(str);
	
								
	m_ctrlFile->SetDropTarget(new DnDFile(m_ctrlFile));
								
	wxBoxSizer *sizer_top = new wxBoxSizer( wxHORIZONTAL );
	sizer_top->Add(m_ctrlFile, 1, wxEXPAND );
	
   wxBoxSizer *sizer = new wxBoxSizer( wxVERTICAL );
sizer->Add(sizer_top, 2, wxEXPAND );
	
SetSizer(sizer);
sizer->SetSizeHints( this );
								
}

void DnDFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
{
    Close(true);
}

DnDFrame::~DnDFrame()
{
/*	
#if wxUSE_LOG
		if ( m_pLog != NULL ) {
			if ( wxLog::SetActiveTarget(m_pLogPrev) == m_pLog )
				delete m_pLog;
		}
#endif // wxUSE_LOG
 */
}


BEGIN_EVENT_TABLE(DnDFrame, wxFrame)
EVT_MENU(Menu_Quit,       DnDFrame::OnQuit)
END_EVENT_TABLE()

// 'Main program' equivalent: the program execution "starts" here
bool MyApp::OnInit()
{
    // don't parse the command-line options !
    // : if ( !wxApp::OnInit() ) return false;

#ifdef __WXMAC__
ProcessSerialNumber PSN;
GetCurrentProcess(&PSN);
TransformProcessType(&PSN,kProcessTransformToForegroundApplication);
#endif


  { // define P7ZIP_HOME_DIR
    extern void my_windows_split_path(const AString &p_path, AString &dir , AString &base);
    static char p7zip_home_dir[MAX_PATH];

    UString fullPath;
    NDir::MyGetFullPathName(wxApp::argv[0], fullPath);
    AString afullPath = GetAnsiString(fullPath);

    AString dir,name;

    my_windows_split_path(afullPath,dir,name);

    const char *dir2 = nameWindowToUnix((const char *)dir);
    snprintf(p7zip_home_dir,sizeof(p7zip_home_dir),"P7ZIP_HOME_DIR=%s/",dir2);
    p7zip_home_dir[sizeof(p7zip_home_dir)-1] = 0;
    putenv(p7zip_home_dir);
    // DEBUG printf("putenv(%s)\n",p7zip_home_dir);
  }
	global_use_utf16_conversion = 1; // UNICODE !
	

    wxInitAllImageHandlers();

//    Main1(wxApp::argc,wxApp::argv);
	
    // create the main frame window
    DnDFrame *frame = new DnDFrame((wxFrame  *) NULL,
                                   _T("P7ZIP Drag-and-Drop"),
                                   10, 100, 750, 540);

	
	printf("P7ZIP_HOME_DIR : -%s-\n", getenv("P7ZIP_HOME_DIR"));
	

	
    // activate it
    frame->Show(true);
	
    SetTopWindow(frame);
	
	

	

  // success: wxApp::OnRun() will be called which will enter the main message
  // loop and the application will run. If we returned false here, the
  // application would exit immediately.
    return true;
}


all:
	$(MAKE) -C 7za          all
	$(MAKE) -C 7z           all
	$(MAKE) -C 7zr          all
	$(MAKE) -C Format7zFree all
	$(MAKE) -C test_lib     all
	$(MAKE) -C MemLat       all
	$(MAKE) -C PipeLen      all

clean:
	$(MAKE) -C 7za          clean
	$(MAKE) -C 7z           clean
	$(MAKE) -C 7zr          clean
	$(MAKE) -C Format7zFree clean
	$(MAKE) -C test_lib     clean
	$(MAKE) -C MemLat       clean
	$(MAKE) -C PipeLen      clean

install: all
	$(MAKE) -C 7za          install
	$(MAKE) -C 7z           install
	$(MAKE) -C 7zr          install
	$(MAKE) -C Format7zFree install
	$(MAKE) -C test_lib     install
	$(MAKE) -C MemLat       install
	$(MAKE) -C PipeLen      install



# For emulator
# DEVICE_DIR=/data/app

# DEVICE_DIR=/sdcard/P7ZIP  # cannot do "chmod 777"

# For ACER ICONIA A500
# For SAMSUNG S II
# DEVICE_DIR=/data/local/P7ZIP

#For Samsung Galaxy Note 3
DEVICE_DIR=/data/local/tmp/P7ZIP

all: build

build:
	cd jni ; ndk-build NDK_DEBUG=0 V=1

install::
	adb shell mkdir $(DEVICE_DIR)
	adb push ./libs/armeabi/$(TARGET) $(DEVICE_DIR)
	adb shell chmod 777 $(DEVICE_DIR)/$(TARGET)

#	adb push ./libs/armeabi-v7a/$(TARGET) $(DEVICE_DIR)/$(TARGET)-v7a
#	adb shell chmod 777 $(DEVICE_DIR)/$(TARGET)-v7a


mkdir:
	adb shell mkdir $(DEVICE_DIR)

clean:
	rm -fr libs obj


to compile :
--------------
- you need ANDROID NDK


make all     : build all the programs 
make install : install all the programs
make clean   : clean all

to test :

cd 7za
make test

look at the makefile to see other tests




III. Debuggable versus Release builds:
--------------------------------------

In NDK r5, ndk-build has been modified to make it easier to switch between
release and debug builds. This is done by using the NDK_DEBUG variable.
For example:

  $NDK/ndk-build NDK_DEBUG=1  => forces the generation of debug binaries
  $NDK/ndk-build NDK_DEBUG=0  => forces the generation of release binaries

If you don't specify NDK_DEBUG, ndk-build will keep its default behaviour,
which is to inspect the AndroidManifest.xml, if any, and see if its
<application> element has android:debuggable="true".

IMPORTANT: If you use the build tools of SDK r8 (or higher), you
           won't need to touch your AndroidManifest.xml file at all!

           That's because if you build a debug package (e.g. with
           "ant debug" or the corresponding option of the ADT plugin),
           the tool will  automatically pick the native debug files
           generated with NDK_DEBUG=1.

Also, as a convenience, the release and debug object files generated by the
NDK are now stored in different directories (e.g. obj/local/<abi>/objs and
obj/local/<abi>/objs-debug). This avoids having to recompile all your sources
when you switch between these two modes (even when you only modified one or
two source files).


TARGET=7z

include ../makefile.inc

test: install
	adb shell $(DEVICE_DIR)/$(TARGET) b

test_all: install
	adb push ../../../check/test/7za433_7zip_lzma.7z $(DEVICE_DIR)
	adb shell $(DEVICE_DIR)/7za t  $(DEVICE_DIR)/7za433_7zip_lzma.7z

# 
# build 7z for armeabi and armeabi-v7a CPU
#
# WARNING : file generated by generate.py
#


LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := 7z

LOCAL_CFLAGS := -DANDROID_NDK  -fexceptions \
	-DNDEBUG -D_REENTRANT -DENV_UNIX \
	-DEXTERNAL_CODECS \
	-DBREAK_HANDLER \
	-DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE \
	-I../../../Windows \
	-I../../../Common \
	-I../../../../C \
-I../../../myWindows \
-I../../../ \
-I../../../include_windows
LOCAL_SRC_FILES := \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilePathAutoRename.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp \
  ../../../../CPP/7zip/UI/Common/Bench.cpp \
  ../../../../CPP/7zip/UI/Common/DefaultName.cpp \
  ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp \
  ../../../../CPP/7zip/UI/Common/Extract.cpp \
  ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp \
  ../../../../CPP/7zip/UI/Common/HashCalc.cpp \
  ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp \
  ../../../../CPP/7zip/UI/Common/OpenArchive.cpp \
  ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp \
  ../../../../CPP/7zip/UI/Common/SetProperties.cpp \
  ../../../../CPP/7zip/UI/Common/SortUtils.cpp \
  ../../../../CPP/7zip/UI/Common/TempFiles.cpp \
  ../../../../CPP/7zip/UI/Common/Update.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateAction.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp \
  ../../../../CPP/7zip/UI/Common/UpdatePair.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp \
  ../../../../CPP/7zip/UI/Console/BenchCon.cpp \
  ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp \
  ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/HashCon.cpp \
  ../../../../CPP/7zip/UI/Console/List.cpp \
  ../../../../CPP/7zip/UI/Console/Main.cpp \
  ../../../../CPP/7zip/UI/Console/MainAr.cpp \
  ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp \
  ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CommandLineParser.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/ListFileUtils.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/NewHandler.cpp \
  ../../../../CPP/Common/StdInStream.cpp \
  ../../../../CPP/Common/StdOutStream.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Windows/DLL.cpp \
  ../../../../CPP/Windows/ErrorMsg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantConv.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/myWindows/myAddExeFlag.cpp \
  ../../../../CPP/myWindows/mySplitCommandLine.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/Alloc.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Threads.c \

# Needed since ANDROID 5, these programs run on android-16 (Android 4.1+)
LOCAL_CFLAGS += -fPIE
LOCAL_LDFLAGS += -fPIE -pie

include $(BUILD_EXECUTABLE)

# The ARMv7 is significanly faster due to the use of the hardware FPU
APP_ABI := armeabi # armeabi-v7a
#APP_PLATFORM := android-8

TARGET=7za

include ../makefile.inc

test: install
	adb shell $(DEVICE_DIR)/7za b

test_crc: install
	adb shell $(DEVICE_DIR)/7za -mm=crc b

test_complex: install
	adb shell $(DEVICE_DIR)/7za "-mm=*" b

test2:
	adb push ./libs/armeabi-v7a/7za $(DEVICE_DIR)/7za-v7a
	adb shell chmod 777 $(DEVICE_DIR)/7za-v7a
	adb shell $(DEVICE_DIR)/7za-v7a b

test_all: install
	adb push ../../../check/test/7za433_7zip_lzma.7z $(DEVICE_DIR)
	adb shell $(DEVICE_DIR)/7za t  $(DEVICE_DIR)/7za433_7zip_lzma.7z

bench: install test

# FIXME
debug:
	cd jni ; ndk-build NDK_DEBUG=1
	adb push ./libs/armeabi/7za /data/app/
	adb push ./libs/armeabi/gdbserver /data/app/
	adb shell chmod 777 /data/app/7za
	adb shell chmod 777 /data/app/gdbserver
	adb forward tcp:1234: tcp:1234
	adb shell  /data/app/gdbserver :1234 /data/app/7za
	
# 
# build 7za for armeabi and armeabi-v7a CPU
#
# WARNING : file generated by generate.py
#


LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := 7za

LOCAL_CFLAGS := -DANDROID_NDK  -fexceptions \
	-DNDEBUG -D_REENTRANT -DENV_UNIX \
	-DBREAK_HANDLER \
	-DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE \
	-I../../../7zip/Archive \
	-I../../../7zip/Archive/7z \
	-I../../../7zip/Archive/BZip2 \
	-I../../../7zip/Archive/Common \
	-I../../../7zip/Archive/GZip \
	-I../../../7zip/Archive/Cab \
	-I../../../7zip/Archive/Lzma \
	-I../../../7zip/Archive/Tar \
	-I../../../7zip/Archive/Zip \
	-I../../../7zip/Archive/Split \
	-I../../../7zip/Archive/Z \
	-I../../../7zip/Compress \
       	-I../../../7zip/Crypto \
	-I../../../7zip/UI/Console \
	-I../../../7zip/UI/Common \
	-I../../../Windows \
	-I../../../Common \
	-I../../../7zip/Common \
	-I../../../../C \
-I../../../myWindows \
-I../../../ \
-I../../../include_windows

LOCAL_SRC_FILES := \
  ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zDecode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zEncode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zExtract.cpp \
  ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandler.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHeader.cpp \
  ../../../../CPP/7zip/Archive/7z/7zIn.cpp \
  ../../../../CPP/7zip/Archive/7z/7zOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zProperties.cpp \
  ../../../../CPP/7zip/Archive/7z/7zRegister.cpp \
  ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp \
  ../../../../CPP/7zip/Archive/Bz2Handler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHandler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHeader.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabIn.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabRegister.cpp \
  ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp \
  ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp \
  ../../../../CPP/7zip/Archive/Common/FindSignature.cpp \
  ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp \
  ../../../../CPP/7zip/Archive/Common/MultiStream.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp \
  ../../../../CPP/7zip/Archive/DeflateProps.cpp \
  ../../../../CPP/7zip/Archive/GzHandler.cpp \
  ../../../../CPP/7zip/Archive/LzmaHandler.cpp \
  ../../../../CPP/7zip/Archive/PpmdHandler.cpp \
  ../../../../CPP/7zip/Archive/SplitHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHeader.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarIn.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarRegister.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp \
  ../../../../CPP/7zip/Archive/XzHandler.cpp \
  ../../../../CPP/7zip/Archive/ZHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipIn.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipItem.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp \
  ../../../../CPP/7zip/Common/CWrappers.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilePathAutoRename.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/InBuffer.cpp \
  ../../../../CPP/7zip/Common/InOutTempBuffer.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MemBlocks.cpp \
  ../../../../CPP/7zip/Common/MethodId.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/OffsetStream.cpp \
  ../../../../CPP/7zip/Common/OutBuffer.cpp \
  ../../../../CPP/7zip/Common/OutMemStream.cpp \
  ../../../../CPP/7zip/Common/ProgressMt.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamBinder.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Common/VirtThread.cpp \
  ../../../../CPP/7zip/Compress/BZip2Crc.cpp \
  ../../../../CPP/7zip/Compress/BZip2Decoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Encoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Register.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Coder.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Register.cpp \
  ../../../../CPP/7zip/Compress/BcjCoder.cpp \
  ../../../../CPP/7zip/Compress/BcjRegister.cpp \
  ../../../../CPP/7zip/Compress/BitlDecoder.cpp \
  ../../../../CPP/7zip/Compress/BranchMisc.cpp \
  ../../../../CPP/7zip/Compress/BranchRegister.cpp \
  ../../../../CPP/7zip/Compress/ByteSwap.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/Compress/CopyRegister.cpp \
  ../../../../CPP/7zip/Compress/Deflate64Register.cpp \
  ../../../../CPP/7zip/Compress/DeflateDecoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateEncoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateRegister.cpp \
  ../../../../CPP/7zip/Compress/DeltaFilter.cpp \
  ../../../../CPP/7zip/Compress/ImplodeDecoder.cpp \
  ../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzOutWindow.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Register.cpp \
  ../../../../CPP/7zip/Compress/LzmaDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaEncoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaRegister.cpp \
  ../../../../CPP/7zip/Compress/LzxDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdEncoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdRegister.cpp \
  ../../../../CPP/7zip/Compress/PpmdZip.cpp \
  ../../../../CPP/7zip/Compress/QuantumDecoder.cpp \
  ../../../../CPP/7zip/Compress/ShrinkDecoder.cpp \
  ../../../../CPP/7zip/Compress/ZDecoder.cpp \
  ../../../../CPP/7zip/Crypto/7zAes.cpp \
  ../../../../CPP/7zip/Crypto/7zAesRegister.cpp \
  ../../../../CPP/7zip/Crypto/HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/MyAes.cpp \
  ../../../../CPP/7zip/Crypto/MyAesReg.cpp \
  ../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/RandGen.cpp \
  ../../../../CPP/7zip/Crypto/WzAes.cpp \
  ../../../../CPP/7zip/Crypto/ZipCrypto.cpp \
  ../../../../CPP/7zip/Crypto/ZipStrong.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp \
  ../../../../CPP/7zip/UI/Common/Bench.cpp \
  ../../../../CPP/7zip/UI/Common/DefaultName.cpp \
  ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp \
  ../../../../CPP/7zip/UI/Common/Extract.cpp \
  ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp \
  ../../../../CPP/7zip/UI/Common/HashCalc.cpp \
  ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp \
  ../../../../CPP/7zip/UI/Common/OpenArchive.cpp \
  ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp \
  ../../../../CPP/7zip/UI/Common/SetProperties.cpp \
  ../../../../CPP/7zip/UI/Common/SortUtils.cpp \
  ../../../../CPP/7zip/UI/Common/TempFiles.cpp \
  ../../../../CPP/7zip/UI/Common/Update.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateAction.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp \
  ../../../../CPP/7zip/UI/Common/UpdatePair.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp \
  ../../../../CPP/7zip/UI/Console/BenchCon.cpp \
  ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp \
  ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/HashCon.cpp \
  ../../../../CPP/7zip/UI/Console/List.cpp \
  ../../../../CPP/7zip/UI/Console/Main.cpp \
  ../../../../CPP/7zip/UI/Console/MainAr.cpp \
  ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp \
  ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CommandLineParser.cpp \
  ../../../../CPP/Common/CrcReg.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/ListFileUtils.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/Sha1Reg.cpp \
  ../../../../CPP/Common/Sha256Reg.cpp \
  ../../../../CPP/Common/StdInStream.cpp \
  ../../../../CPP/Common/StdOutStream.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Common/XzCrc64Reg.cpp \
  ../../../../CPP/Windows/ErrorMsg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantConv.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/myWindows/myAddExeFlag.cpp \
  ../../../../CPP/myWindows/mySplitCommandLine.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/7zStream.c \
  ../../../../C/Aes.c \
  ../../../../C/Alloc.c \
  ../../../../C/Bcj2.c \
  ../../../../C/Bcj2Enc.c \
  ../../../../C/Bra.c \
  ../../../../C/Bra86.c \
  ../../../../C/BraIA64.c \
  ../../../../C/BwtSort.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Delta.c \
  ../../../../C/HuffEnc.c \
  ../../../../C/LzFind.c \
  ../../../../C/LzFindMt.c \
  ../../../../C/Lzma2Dec.c \
  ../../../../C/Lzma2Enc.c \
  ../../../../C/LzmaDec.c \
  ../../../../C/LzmaEnc.c \
  ../../../../C/MtCoder.c \
  ../../../../C/Ppmd7.c \
  ../../../../C/Ppmd7Dec.c \
  ../../../../C/Ppmd7Enc.c \
  ../../../../C/Ppmd8.c \
  ../../../../C/Ppmd8Dec.c \
  ../../../../C/Ppmd8Enc.c \
  ../../../../C/Sha1.c \
  ../../../../C/Sha256.c \
  ../../../../C/Sort.c \
  ../../../../C/Threads.c \
  ../../../../C/Xz.c \
  ../../../../C/XzCrc64.c \
  ../../../../C/XzCrc64Opt.c \
  ../../../../C/XzDec.c \
  ../../../../C/XzEnc.c \
  ../../../../C/XzIn.c \

# Needed since ANDROID 5, these programs run on android-16 (Android 4.1+)
LOCAL_CFLAGS += -fPIE
LOCAL_LDFLAGS += -fPIE -pie

include $(BUILD_EXECUTABLE)

# The ARMv7 is significanly faster due to the use of the hardware FPU
APP_ABI := armeabi
# p7zip armeabi and armeabi-v7a run at the same speed (p7zip does not use FPU)
# APP_ABI := armeabi armeabi-v7a
#APP_PLATFORM := android-8

TARGET=7zr

include ../makefile.inc

test: install
	adb shell $(DEVICE_DIR)/7zr b

test_crc: install
	adb shell $(DEVICE_DIR)/7zr -mm=crc b

test_complex: install
	adb shell $(DEVICE_DIR)/7zr "-mm=*" b

test2:
	adb push ./libs/armeabi-v7a/7zr $(DEVICE_DIR)/7zr-v7a
	adb shell chmod 777 $(DEVICE_DIR)/7zr-v7a
	adb shell $(DEVICE_DIR)/7zr-v7a b

test_all: install
	adb push ../../../check/test/7zr433_7zip_lzma.7z $(DEVICE_DIR)
	adb shell $(DEVICE_DIR)/7zr t  $(DEVICE_DIR)/7zr433_7zip_lzma.7z

bench: install test

# FIXME
debug:
	cd jni ; ndk-build NDK_DEBUG=1
	adb push ./libs/armeabi/7zr /data/app/
	adb push ./libs/armeabi/gdbserver /data/app/
	adb shell chmod 777 /data/app/7zr
	adb shell chmod 777 /data/app/gdbserver
	adb forward tcp:1234: tcp:1234
	adb shell  /data/app/gdbserver :1234 /data/app/7zr
	
# 
# build 7zr for armeabi and armeabi-v7a CPU
#
# WARNING : file generated by generate.py
#


LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := 7zr

LOCAL_CFLAGS := -DANDROID_NDK  -fexceptions \
	-DNDEBUG -D_REENTRANT -DENV_UNIX \
	-DBREAK_HANDLER -D_NO_CRYPTO \
	-DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE \
	-I../../../7zip/Archive \
	-I../../../7zip/Archive/7z \
	-I../../../7zip/Archive/BZip2 \
	-I../../../7zip/Archive/Common \
	-I../../../7zip/Archive/GZip \
	-I../../../7zip/Archive/Cab \
	-I../../../7zip/Archive/Lzma \
	-I../../../7zip/Archive/Tar \
	-I../../../7zip/Archive/Zip \
	-I../../../7zip/Archive/Split \
	-I../../../7zip/Archive/Z \
	-I../../../7zip/Compress \
       	-I../../../7zip/Crypto \
	-I../../../7zip/UI/Console \
	-I../../../7zip/UI/Common \
	-I../../../Windows \
	-I../../../Common \
	-I../../../7zip/Common \
	-I../../../../C \
-I../../../myWindows \
-I../../../ \
-I../../../include_windows

LOCAL_SRC_FILES := \
  ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zDecode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zEncode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zExtract.cpp \
  ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandler.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHeader.cpp \
  ../../../../CPP/7zip/Archive/7z/7zIn.cpp \
  ../../../../CPP/7zip/Archive/7z/7zOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zProperties.cpp \
  ../../../../CPP/7zip/Archive/7z/7zRegister.cpp \
  ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp \
  ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp \
  ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp \
  ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp \
  ../../../../CPP/7zip/Archive/Common/MultiStream.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp \
  ../../../../CPP/7zip/Archive/LzmaHandler.cpp \
  ../../../../CPP/7zip/Archive/SplitHandler.cpp \
  ../../../../CPP/7zip/Archive/XzHandler.cpp \
  ../../../../CPP/7zip/Common/CWrappers.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilePathAutoRename.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/InBuffer.cpp \
  ../../../../CPP/7zip/Common/InOutTempBuffer.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MethodId.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/OffsetStream.cpp \
  ../../../../CPP/7zip/Common/OutBuffer.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamBinder.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Common/VirtThread.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Coder.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Register.cpp \
  ../../../../CPP/7zip/Compress/BcjCoder.cpp \
  ../../../../CPP/7zip/Compress/BcjRegister.cpp \
  ../../../../CPP/7zip/Compress/BranchMisc.cpp \
  ../../../../CPP/7zip/Compress/BranchRegister.cpp \
  ../../../../CPP/7zip/Compress/ByteSwap.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/Compress/CopyRegister.cpp \
  ../../../../CPP/7zip/Compress/DeltaFilter.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Register.cpp \
  ../../../../CPP/7zip/Compress/LzmaDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaEncoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaRegister.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp \
  ../../../../CPP/7zip/UI/Common/Bench.cpp \
  ../../../../CPP/7zip/UI/Common/DefaultName.cpp \
  ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp \
  ../../../../CPP/7zip/UI/Common/Extract.cpp \
  ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp \
  ../../../../CPP/7zip/UI/Common/HashCalc.cpp \
  ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp \
  ../../../../CPP/7zip/UI/Common/OpenArchive.cpp \
  ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp \
  ../../../../CPP/7zip/UI/Common/SetProperties.cpp \
  ../../../../CPP/7zip/UI/Common/SortUtils.cpp \
  ../../../../CPP/7zip/UI/Common/TempFiles.cpp \
  ../../../../CPP/7zip/UI/Common/Update.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateAction.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp \
  ../../../../CPP/7zip/UI/Common/UpdatePair.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp \
  ../../../../CPP/7zip/UI/Console/BenchCon.cpp \
  ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp \
  ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/HashCon.cpp \
  ../../../../CPP/7zip/UI/Console/List.cpp \
  ../../../../CPP/7zip/UI/Console/Main.cpp \
  ../../../../CPP/7zip/UI/Console/MainAr.cpp \
  ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp \
  ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CommandLineParser.cpp \
  ../../../../CPP/Common/CrcReg.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/ListFileUtils.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/NewHandler.cpp \
  ../../../../CPP/Common/Sha256Reg.cpp \
  ../../../../CPP/Common/StdInStream.cpp \
  ../../../../CPP/Common/StdOutStream.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Common/XzCrc64Reg.cpp \
  ../../../../CPP/Windows/ErrorMsg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantConv.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/myWindows/myAddExeFlag.cpp \
  ../../../../CPP/myWindows/mySplitCommandLine.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/7zStream.c \
  ../../../../C/Alloc.c \
  ../../../../C/Bcj2.c \
  ../../../../C/Bcj2Enc.c \
  ../../../../C/Bra.c \
  ../../../../C/Bra86.c \
  ../../../../C/BraIA64.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Delta.c \
  ../../../../C/LzFind.c \
  ../../../../C/LzFindMt.c \
  ../../../../C/Lzma2Dec.c \
  ../../../../C/Lzma2Enc.c \
  ../../../../C/LzmaDec.c \
  ../../../../C/LzmaEnc.c \
  ../../../../C/MtCoder.c \
  ../../../../C/Sha256.c \
  ../../../../C/Threads.c \
  ../../../../C/Xz.c \
  ../../../../C/XzCrc64.c \
  ../../../../C/XzCrc64Opt.c \
  ../../../../C/XzDec.c \
  ../../../../C/XzEnc.c \
  ../../../../C/XzIn.c \

# Needed since ANDROID 5, these programs run on android-16 (Android 4.1+)
LOCAL_CFLAGS += -fPIE
LOCAL_LDFLAGS += -fPIE -pie

include $(BUILD_EXECUTABLE)


TARGET=lib7z.so

all: build

include ../makefile.inc

install::
	adb shell mv $(DEVICE_DIR)/$(TARGET) $(DEVICE_DIR)/7z.so

# 
# build 7z for armeabi and armeabi-v7a CPU
#
# WARNING : file generated by generate.py
#


LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := 7z

LOCAL_CFLAGS := -DANDROID_NDK  -fexceptions \
	-DNDEBUG -D_REENTRANT -DENV_UNIX \
	-DEXTERNAL_CODECS \
	-DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE \
	-I../../../Windows \
	-I../../../Common \
	-I../../../../C \
	-I../../../myWindows \
	-I../../../ \
	-I../../../include_windows

LOCAL_SRC_FILES := \
  ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zDecode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zEncode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zExtract.cpp \
  ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandler.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHeader.cpp \
  ../../../../CPP/7zip/Archive/7z/7zIn.cpp \
  ../../../../CPP/7zip/Archive/7z/7zOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zProperties.cpp \
  ../../../../CPP/7zip/Archive/7z/7zRegister.cpp \
  ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp \
  ../../../../CPP/7zip/Archive/ApmHandler.cpp \
  ../../../../CPP/7zip/Archive/ArHandler.cpp \
  ../../../../CPP/7zip/Archive/ArchiveExports.cpp \
  ../../../../CPP/7zip/Archive/ArjHandler.cpp \
  ../../../../CPP/7zip/Archive/Bz2Handler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHandler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHeader.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabIn.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabRegister.cpp \
  ../../../../CPP/7zip/Archive/Chm/ChmHandler.cpp \
  ../../../../CPP/7zip/Archive/Chm/ChmIn.cpp \
  ../../../../CPP/7zip/Archive/ComHandler.cpp \
  ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp \
  ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp \
  ../../../../CPP/7zip/Archive/Common/FindSignature.cpp \
  ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp \
  ../../../../CPP/7zip/Archive/Common/MultiStream.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithSha1.cpp \
  ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp \
  ../../../../CPP/7zip/Archive/CpioHandler.cpp \
  ../../../../CPP/7zip/Archive/CramfsHandler.cpp \
  ../../../../CPP/7zip/Archive/DeflateProps.cpp \
  ../../../../CPP/7zip/Archive/DllExports2.cpp \
  ../../../../CPP/7zip/Archive/DmgHandler.cpp \
  ../../../../CPP/7zip/Archive/ElfHandler.cpp \
  ../../../../CPP/7zip/Archive/ExtHandler.cpp \
  ../../../../CPP/7zip/Archive/FatHandler.cpp \
  ../../../../CPP/7zip/Archive/FlvHandler.cpp \
  ../../../../CPP/7zip/Archive/GzHandler.cpp \
  ../../../../CPP/7zip/Archive/GptHandler.cpp \
  ../../../../CPP/7zip/Archive/HandlerCont.cpp \
  ../../../../CPP/7zip/Archive/HfsHandler.cpp \
  ../../../../CPP/7zip/Archive/IhexHandler.cpp \
  ../../../../CPP/7zip/Archive/Iso/IsoHandler.cpp \
  ../../../../CPP/7zip/Archive/Iso/IsoHeader.cpp \
  ../../../../CPP/7zip/Archive/Iso/IsoIn.cpp \
  ../../../../CPP/7zip/Archive/Iso/IsoRegister.cpp \
  ../../../../CPP/7zip/Archive/LzhHandler.cpp \
  ../../../../CPP/7zip/Archive/LzmaHandler.cpp \
  ../../../../CPP/7zip/Archive/MachoHandler.cpp \
  ../../../../CPP/7zip/Archive/MbrHandler.cpp \
  ../../../../CPP/7zip/Archive/MslzHandler.cpp \
  ../../../../CPP/7zip/Archive/MubHandler.cpp \
  ../../../../CPP/7zip/Archive/Nsis/NsisDecode.cpp \
  ../../../../CPP/7zip/Archive/Nsis/NsisHandler.cpp \
  ../../../../CPP/7zip/Archive/Nsis/NsisIn.cpp \
  ../../../../CPP/7zip/Archive/Nsis/NsisRegister.cpp \
  ../../../../CPP/7zip/Archive/NtfsHandler.cpp \
  ../../../../CPP/7zip/Archive/PeHandler.cpp \
  ../../../../CPP/7zip/Archive/PpmdHandler.cpp \
  ../../../../CPP/7zip/Archive/QcowHandler.cpp \
  ../../../../CPP/7zip/Archive/Rar/RarHandler.cpp \
  ../../../../CPP/7zip/Archive/Rar/Rar5Handler.cpp \
  ../../../../CPP/7zip/Archive/RpmHandler.cpp \
  ../../../../CPP/7zip/Archive/SplitHandler.cpp \
  ../../../../CPP/7zip/Archive/SquashfsHandler.cpp \
  ../../../../CPP/7zip/Archive/SwfHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHeader.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarIn.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarRegister.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp \
  ../../../../CPP/7zip/Archive/Udf/UdfHandler.cpp \
  ../../../../CPP/7zip/Archive/Udf/UdfIn.cpp \
  ../../../../CPP/7zip/Archive/UefiHandler.cpp \
  ../../../../CPP/7zip/Archive/VdiHandler.cpp \
  ../../../../CPP/7zip/Archive/VhdHandler.cpp \
  ../../../../CPP/7zip/Archive/VmdkHandler.cpp \
  ../../../../CPP/7zip/Archive/Wim/WimHandler.cpp \
  ../../../../CPP/7zip/Archive/Wim/WimHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Wim/WimIn.cpp \
  ../../../../CPP/7zip/Archive/Wim/WimRegister.cpp \
  ../../../../CPP/7zip/Archive/XarHandler.cpp \
  ../../../../CPP/7zip/Archive/XzHandler.cpp \
  ../../../../CPP/7zip/Archive/ZHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipIn.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipItem.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp \
  ../../../../CPP/7zip/Common/CWrappers.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/InBuffer.cpp \
  ../../../../CPP/7zip/Common/InOutTempBuffer.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MemBlocks.cpp \
  ../../../../CPP/7zip/Common/MethodId.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/OffsetStream.cpp \
  ../../../../CPP/7zip/Common/OutBuffer.cpp \
  ../../../../CPP/7zip/Common/OutMemStream.cpp \
  ../../../../CPP/7zip/Common/ProgressMt.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamBinder.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Common/VirtThread.cpp \
  ../../../../CPP/7zip/Compress/BZip2Crc.cpp \
  ../../../../CPP/7zip/Compress/BZip2Decoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Encoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Register.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Coder.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Register.cpp \
  ../../../../CPP/7zip/Compress/BcjCoder.cpp \
  ../../../../CPP/7zip/Compress/BcjRegister.cpp \
  ../../../../CPP/7zip/Compress/BitlDecoder.cpp \
  ../../../../CPP/7zip/Compress/BranchMisc.cpp \
  ../../../../CPP/7zip/Compress/BranchRegister.cpp \
  ../../../../CPP/7zip/Compress/ByteSwap.cpp \
  ../../../../CPP/7zip/Compress/CodecExports.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/Compress/CopyRegister.cpp \
  ../../../../CPP/7zip/Compress/Deflate64Register.cpp \
  ../../../../CPP/7zip/Compress/DeflateDecoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateEncoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateRegister.cpp \
  ../../../../CPP/7zip/Compress/DeltaFilter.cpp \
  ../../../../CPP/7zip/Compress/ImplodeDecoder.cpp \
  ../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzOutWindow.cpp \
  ../../../../CPP/7zip/Compress/LzhDecoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Register.cpp \
  ../../../../CPP/7zip/Compress/LzmaDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaEncoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaRegister.cpp \
  ../../../../CPP/7zip/Compress/LzmsDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzxDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdEncoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdRegister.cpp \
  ../../../../CPP/7zip/Compress/PpmdZip.cpp \
  ../../../../CPP/7zip/Compress/QuantumDecoder.cpp \
  ../../../../CPP/7zip/Compress/ShrinkDecoder.cpp \
  ../../../../CPP/7zip/Compress/ZDecoder.cpp \
  ../../../../CPP/7zip/Compress/XpressDecoder.cpp \
  ../../../../CPP/7zip/Compress/ZlibDecoder.cpp \
  ../../../../CPP/7zip/Compress/ZlibEncoder.cpp \
  ../../../../CPP/7zip/Crypto/7zAes.cpp \
  ../../../../CPP/7zip/Crypto/7zAesRegister.cpp \
  ../../../../CPP/7zip/Crypto/HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/HmacSha256.cpp \
  ../../../../CPP/7zip/Crypto/MyAes.cpp \
  ../../../../CPP/7zip/Crypto/MyAesReg.cpp \
  ../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/RandGen.cpp \
  ../../../../CPP/7zip/Crypto/Rar20Crypto.cpp \
  ../../../../CPP/7zip/Crypto/Rar5Aes.cpp \
  ../../../../CPP/7zip/Crypto/RarAes.cpp \
  ../../../../CPP/7zip/Crypto/WzAes.cpp \
  ../../../../CPP/7zip/Crypto/ZipCrypto.cpp \
  ../../../../CPP/7zip/Crypto/ZipStrong.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CrcReg.cpp \
  ../../../../CPP/Common/DynLimBuf.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/MyMap.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/MyXml.cpp \
  ../../../../CPP/Common/NewHandler.cpp \
  ../../../../CPP/Common/Sha1Reg.cpp \
  ../../../../CPP/Common/Sha256Reg.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Common/XzCrc64Reg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantUtils.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \
  ../../../../C/7zBuf2.c \
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/7zStream.c \
  ../../../../C/Aes.c \
  ../../../../C/Alloc.c \
  ../../../../C/Bcj2.c \
  ../../../../C/Bcj2Enc.c \
  ../../../../C/Blake2s.c \
  ../../../../C/Bra.c \
  ../../../../C/Bra86.c \
  ../../../../C/BraIA64.c \
  ../../../../C/BwtSort.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Delta.c \
  ../../../../C/HuffEnc.c \
  ../../../../C/LzFind.c \
  ../../../../C/LzFindMt.c \
  ../../../../C/Lzma2Dec.c \
  ../../../../C/Lzma2Enc.c \
  ../../../../C/LzmaDec.c \
  ../../../../C/LzmaEnc.c \
  ../../../../C/MtCoder.c \
  ../../../../C/Ppmd7.c \
  ../../../../C/Ppmd7Dec.c \
  ../../../../C/Ppmd7Enc.c \
  ../../../../C/Ppmd8.c \
  ../../../../C/Ppmd8Dec.c \
  ../../../../C/Ppmd8Enc.c \
  ../../../../C/Sha1.c \
  ../../../../C/Sha256.c \
  ../../../../C/Sort.c \
  ../../../../C/Threads.c \
  ../../../../C/Xz.c \
  ../../../../C/XzCrc64.c \
  ../../../../C/XzCrc64Opt.c \
  ../../../../C/XzDec.c \
  ../../../../C/XzEnc.c \
  ../../../../C/XzIn.c \

include $(BUILD_SHARED_LIBRARY)


TARGET=lzham

all: build

include ../makefile.inc

# 
# build Lzham for armeabi and armeabi-v7a CPU
#
# WARNING : file generated by generate.py
#


LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := Lzham

LOCAL_CFLAGS := -DANDROID_NDK  -fexceptions \
	-DNDEBUG -D_REENTRANT -DENV_UNIX \
	-DEXTERNAL_CODECS \
	-DBREAK_HANDLER \
	-DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE \
	-I../../../Windows \
	-I../../../Common \
	-I../../../../C \
-I../../../myWindows \
-I../../../ \
-I../../../include_windows \
-I../../../../CPP/7zip/Compress/Lzham/include \
-I../../../../CPP/7zip/Compress/Lzham/lzhamcomp \
-I../../../../CPP/7zip/Compress/Lzham/lzhamdecomp

LOCAL_SRC_FILES := \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Compress/CodecExports.cpp \
  ../../../../CPP/7zip/Compress/DllExportsCompress.cpp \
  ../../../../CPP/7zip/Compress/Lzham/LzhamRegister.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzbase.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp_internal.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp_state.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_match_accel.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_pthreads_threading.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_assert.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_checksum.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_huffman_codes.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_lzdecomp.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_lzdecompbase.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_mem.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_platform.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_prefix_coding.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_symbol_codec.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_timer.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_vector.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamlib/lzham_lib.cpp \
  ../../../../C/Alloc.c \

include $(BUILD_SHARED_LIBRARY)

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/obj/local/armeabi/objs/Lzham/__/__/__/__/CPP/7zip/Common/StreamUtils.o: \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/StreamUtils.cpp \
 ../../../myWindows/StdAfx.h ../../../myWindows/config.h \
 ../../../Common/Common.h ../../../Common/../../C/Compiler.h \
 ../../../Common/MyWindows.h ../../../Common/MyGuidDef.h \
 ../../../Common/MyTypes.h ../../../Common/../../C/7zTypes.h \
 ../../../Common/NewHandler.h ../../../Common/MyWindows.h \
 ../../../Common/MyTypes.h ../../../Common/MyString.h \
 ../../../Common/MyVector.h ../../../include_windows/windows.h \
 ../../../include_windows/basetyps.h ../../../include_windows/tchar.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/StreamUtils.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../IStream.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../../Common/MyTypes.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../../Common/MyWindows.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../IDecl.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../../Common/MyUnknown.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../../Common/MyWindows.h

../../../myWindows/StdAfx.h:

../../../myWindows/config.h:

../../../Common/Common.h:

../../../Common/../../C/Compiler.h:

../../../Common/MyWindows.h:

../../../Common/MyGuidDef.h:

../../../Common/MyTypes.h:

../../../Common/../../C/7zTypes.h:

../../../Common/NewHandler.h:

../../../Common/MyWindows.h:

../../../Common/MyTypes.h:

../../../Common/MyString.h:

../../../Common/MyVector.h:

../../../include_windows/windows.h:

../../../include_windows/basetyps.h:

../../../include_windows/tchar.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/StreamUtils.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../IStream.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../../Common/MyTypes.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../../Common/MyWindows.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../IDecl.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../../Common/MyUnknown.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Common/../../Common/MyWindows.h:
/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/obj/local/armeabi/objs/Lzham/__/__/__/__/CPP/7zip/Compress/CodecExports.o: \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/CodecExports.cpp \
 ../../../myWindows/StdAfx.h ../../../myWindows/config.h \
 ../../../Common/Common.h ../../../Common/../../C/Compiler.h \
 ../../../Common/MyWindows.h ../../../Common/MyGuidDef.h \
 ../../../Common/MyTypes.h ../../../Common/../../C/7zTypes.h \
 ../../../Common/NewHandler.h ../../../Common/MyWindows.h \
 ../../../Common/MyTypes.h ../../../Common/MyString.h \
 ../../../Common/MyVector.h ../../../include_windows/windows.h \
 ../../../include_windows/basetyps.h ../../../include_windows/tchar.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../../C/CpuArch.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../../C/7zTypes.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/ComTry.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyWindows.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyCom.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/NewHandler.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Windows/Defs.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Windows/../Common/MyWindows.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../ICoder.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../IStream.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyTypes.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyWindows.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../IDecl.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyUnknown.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/RegisterCodec.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../Common/MethodId.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../Common/../../Common/MyTypes.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../ICoder.h

../../../myWindows/StdAfx.h:

../../../myWindows/config.h:

../../../Common/Common.h:

../../../Common/../../C/Compiler.h:

../../../Common/MyWindows.h:

../../../Common/MyGuidDef.h:

../../../Common/MyTypes.h:

../../../Common/../../C/7zTypes.h:

../../../Common/NewHandler.h:

../../../Common/MyWindows.h:

../../../Common/MyTypes.h:

../../../Common/MyString.h:

../../../Common/MyVector.h:

../../../include_windows/windows.h:

../../../include_windows/basetyps.h:

../../../include_windows/tchar.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../../C/CpuArch.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../../C/7zTypes.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/ComTry.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyWindows.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyCom.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/NewHandler.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Windows/Defs.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Windows/../Common/MyWindows.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../ICoder.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../IStream.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyTypes.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyWindows.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../IDecl.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyUnknown.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/RegisterCodec.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../Common/MethodId.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../Common/../../Common/MyTypes.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../ICoder.h:
/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/obj/local/armeabi/objs/Lzham/__/__/__/__/CPP/7zip/Compress/DllExportsCompress.o: \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/DllExportsCompress.cpp \
 ../../../myWindows/StdAfx.h ../../../myWindows/config.h \
 ../../../Common/Common.h ../../../Common/../../C/Compiler.h \
 ../../../Common/MyWindows.h ../../../Common/MyGuidDef.h \
 ../../../Common/MyTypes.h ../../../Common/../../C/7zTypes.h \
 ../../../Common/NewHandler.h ../../../Common/MyWindows.h \
 ../../../Common/MyTypes.h ../../../Common/MyString.h \
 ../../../Common/MyVector.h ../../../include_windows/windows.h \
 ../../../include_windows/basetyps.h ../../../include_windows/tchar.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyInitGuid.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyGuidDef.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../ICoder.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../IStream.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyTypes.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyWindows.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../IDecl.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyUnknown.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyWindows.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/RegisterCodec.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../Common/MethodId.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../Common/../../Common/MyTypes.h \
 /media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../ICoder.h

../../../myWindows/StdAfx.h:

../../../myWindows/config.h:

../../../Common/Common.h:

../../../Common/../../C/Compiler.h:

../../../Common/MyWindows.h:

../../../Common/MyGuidDef.h:

../../../Common/MyTypes.h:

../../../Common/../../C/7zTypes.h:

../../../Common/NewHandler.h:

../../../Common/MyWindows.h:

../../../Common/MyTypes.h:

../../../Common/MyString.h:

../../../Common/MyVector.h:

../../../include_windows/windows.h:

../../../include_windows/basetyps.h:

../../../include_windows/tchar.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyInitGuid.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyGuidDef.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../ICoder.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../IStream.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyTypes.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyWindows.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../IDecl.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyUnknown.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../../Common/MyWindows.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/RegisterCodec.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../Common/MethodId.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../Common/../../Common/MyTypes.h:

/media/me/DISK_COMPLEMENT/me/P7ZIP/p7zip_15.14_030/CPP/ANDROID/Lzham/jni/../../../../CPP/7zip/Compress/../Common/../ICoder.h:

TARGET=MemLat

all: build

include ../makefile.inc


test: install
	adb shell $(DEVICE_DIR)/$(TARGET) 4 p5 n

# simple memlat test:
# MemLat 4 p5 n

# 
# build MemLat for armeabi and armeabi-v7a CPU
#


LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := MemLat
LOCAL_CFLAGS := -DANDROID_NDK  -fexceptions \
  -DNDEBUG -D_REENTRANT -DENV_UNIX \
  -DNUM_DIRECT_TESTS=6 -DNUM_PAR_TESTS=5 \
  -I../../../../Utils/CPUTest/MemLat


LOCAL_SRC_FILES := \
 ../../../../Utils/CPUTest/MemLat/MemLat.cpp \
 ../../../../Utils/CPUTest/MemLat/Walk.c

include $(BUILD_EXECUTABLE)

TARGET=PipeLen

all: build

include ../makefile.inc


test: install
	adb shell $(DEVICE_DIR)/$(TARGET) r0 n

# One pipelen test:
# pipelen r0 n
# All pipelen tests (too long) :
# pipelen n

# 
# build PipeLen for armeabi and armeabi-v7a CPU
#


LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := PipeLen
LOCAL_CFLAGS := -DANDROID_NDK  -fexceptions \
		-DNDEBUG -D_REENTRANT -DENV_UNIX \
  -DUNICODE \
  -D_UNICODE \
-I../../../../Utils/CPUTest/PipeLen


LOCAL_SRC_FILES := \
 ../../../../Utils/CPUTest/PipeLen/PipeLen.cpp

include $(BUILD_EXECUTABLE)

TARGET=test_lib

all: build

include ../makefile.inc


test: install
	adb shell $(DEVICE_DIR)/$(TARGET)

# 
# build test_lib for armeabi and armeabi-v7a CPU
#


LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := test_lib
LOCAL_CFLAGS := -DANDROID_NDK  -fexceptions \
		-DNDEBUG -D_REENTRANT -DENV_UNIX \
  -DUNICODE \
  -D_UNICODE \
	-I../../../Windows \
	-I../../../Common \
	-I../../../../C \
-I../../../myWindows \
-I../../../ \
-I../../../include_windows


LOCAL_SRC_FILES := \
 ../../../myWindows/wine_date_and_time.cpp \
  ../../../myWindows/wine_GetXXXDefaultLangID.cpp \
 ../../../myWindows/myAddExeFlag.cpp \
 ../../../myWindows/mySplitCommandLine.cpp \
 ../../../myWindows/test_lib.cpp \
  ../../../Common/MyString.cpp \
 ../../../Common/MyWindows.cpp \
 ../../../Common/MyVector.cpp \

# Needed since ANDROID 5, these programs run on android-16 (Android 4.1+)
LOCAL_CFLAGS += -fPIE
LOCAL_LDFLAGS += -fPIE -pie

include $(BUILD_EXECUTABLE)
// Common/AutoPtr.h

#ifndef __COMMON_AUTOPTR_H
#define __COMMON_AUTOPTR_H

template<class T> class CMyAutoPtr
{
  T *_p;
public:
  CMyAutoPtr(T *p = 0) : _p(p) {}
  CMyAutoPtr(CMyAutoPtr<T>& p): _p(p.release()) {}
  CMyAutoPtr<T>& operator=(CMyAutoPtr<T>& p)
  {
    reset(p.release());
    return (*this);
  }
  ~CMyAutoPtr() { delete _p; }
  T& operator*() const { return *_p; }
  // T* operator->() const { return (&**this); }
  T* get() const { return _p; }
  T* release()
  {
    T *tmp = _p;
    _p = 0;
    return tmp;
  }
  void reset(T* p = 0)
  {
    if (p != _p)
      delete _p;
    _p = p;
  }
};

#endif
// Common/CRC.cpp

#include "StdAfx.h"

#include "../../C/7zCrc.h"

struct CCRCTableInit { CCRCTableInit() { CrcGenerateTable(); } } g_CRCTableInit;
// Common/C_FileIO.cpp

#include "C_FileIO.h"

#include <fcntl.h>
#ifdef _WIN32
#include <io.h>
#else
#include <unistd.h>
#endif

namespace NC {
namespace NFile {
namespace NIO {

bool CFileBase::OpenBinary(const char *name, int flags)
{
  #ifdef O_BINARY
  flags |= O_BINARY;
  #endif
  Close();
  _handle = ::open(name, flags, 0666);
  return _handle != -1;
}

bool CFileBase::Close()
{
  if (_handle == -1)
    return true;
  if (close(_handle) != 0)
    return false;
  _handle = -1;
  return true;
}

bool CFileBase::GetLength(UInt64 &length) const
{
  off_t curPos = Seek(0, SEEK_CUR);
  off_t lengthTemp = Seek(0, SEEK_END);
  Seek(curPos, SEEK_SET);
  length = (UInt64)lengthTemp;
  return true;
}

off_t CFileBase::Seek(off_t distanceToMove, int moveMethod) const
{
  return ::lseek(_handle, distanceToMove, moveMethod);
}

/////////////////////////
// CInFile

bool CInFile::Open(const char *name)
{
  return CFileBase::OpenBinary(name, O_RDONLY);
}

bool CInFile::OpenShared(const char *name, bool)
{
  return Open(name);
}

ssize_t CInFile::Read(void *data, size_t size)
{
  return read(_handle, data, size);
}

/////////////////////////
// COutFile

bool COutFile::Create(const char *name, bool createAlways)
{
  if (createAlways)
  {
    Close();
    _handle = ::creat(name, 0666);
    return _handle != -1;
  }
  return OpenBinary(name, O_CREAT | O_EXCL | O_WRONLY);
}

bool COutFile::Open(const char *name, DWORD creationDisposition)
{
  return Create(name, false);
}

ssize_t COutFile::Write(const void *data, size_t size)
{
  return write(_handle, data, size);
}

}}}
// Common/C_FileIO.h

#ifndef __COMMON_C_FILEIO_H
#define __COMMON_C_FILEIO_H

#include <stdio.h>
#include <sys/types.h>

#include "MyTypes.h"
#include "MyWindows.h"

#ifdef _WIN32
#ifdef _MSC_VER
typedef size_t ssize_t;
#endif
#endif

namespace NC {
namespace NFile {
namespace NIO {

class CFileBase
{
protected:
  int _handle;
  bool OpenBinary(const char *name, int flags);
public:
  CFileBase(): _handle(-1) {};
  ~CFileBase() { Close(); }
  bool Close();
  bool GetLength(UInt64 &length) const;
  off_t Seek(off_t distanceToMove, int moveMethod) const;
};

class CInFile: public CFileBase
{
public:
  bool Open(const char *name);
  bool OpenShared(const char *name, bool shareForWrite);
  ssize_t Read(void *data, size_t size);
};

class COutFile: public CFileBase
{
public:
  bool Create(const char *name, bool createAlways);
  bool Open(const char *name, DWORD creationDisposition);
  ssize_t Write(const void *data, size_t size);
};

}}}

#endif
// ComTry.h

#ifndef __COM_TRY_H
#define __COM_TRY_H

#include "MyWindows.h"
// #include "Exception.h"
// #include "NewHandler.h"

#define COM_TRY_BEGIN try {
#define COM_TRY_END } catch(const char * s) { throw s ; } \
		catch(...) { return E_OUTOFMEMORY; }
  
  // catch(const CNewException &) { return E_OUTOFMEMORY; }
  // catch(const CSystemException &e) { return e.ErrorCode; }
  // catch(...) { return E_FAIL; }

#endif
// CommandLineParser.cpp

#include "StdAfx.h"

#include "CommandLineParser.h"

static bool IsString1PrefixedByString2_NoCase(const wchar_t *u, const char *a)
{
  for (;;)
  {
    char c = *a;
    if (c == 0)
      return true;
    if ((unsigned char)MyCharLower_Ascii(c) != MyCharLower_Ascii(*u))
      return false;
    a++;
    u++;
  }
}

namespace NCommandLineParser {

#ifdef _WIN32
bool SplitCommandLine(const UString &src, UString &dest1, UString &dest2)
{
  dest1.Empty();
  dest2.Empty();
  bool quoteMode = false;
  unsigned i;
  for (i = 0; i < src.Len(); i++)
  {
    wchar_t c = src[i];
    if ((c == L' ' || c == L'\t') && !quoteMode)
    {
      dest2 = src.Ptr(i + 1);
      return i != 0;
    }
    if (c == L'\"')
      quoteMode = !quoteMode;
    else
      dest1 += c;
  }
  return i != 0;
}

void SplitCommandLine(const UString &s, UStringVector &parts)
{
  UString sTemp = s;
  sTemp.Trim();
  parts.Clear();
  for (;;)
  {
    UString s1, s2;
    if (SplitCommandLine(sTemp, s1, s2))
      parts.Add(s1);
    if (s2.IsEmpty())
      break;
    sTemp = s2;
  }
}
#endif

static const char *kStopSwitchParsing = "--";

static bool inline IsItSwitchChar(wchar_t c)
{
  return (c == '-');
}

CParser::CParser(unsigned numSwitches):
  _numSwitches(numSwitches),
  _switches(0)
{
  _switches = new CSwitchResult[numSwitches];
}

CParser::~CParser()
{
  delete []_switches;
}


// if (s) contains switch then function updates switch structures
// out: true, if (s) is a switch
bool CParser::ParseString(const UString &s, const CSwitchForm *switchForms)
{
  if (s.IsEmpty() || !IsItSwitchChar(s[0]))
    return false;

  unsigned pos = 1;
  unsigned switchIndex = 0;
  int maxLen = -1;
  
  for (unsigned i = 0; i < _numSwitches; i++)
  {
    const char *key = switchForms[i].Key;
    unsigned switchLen = MyStringLen(key);
    if ((int)switchLen <= maxLen || pos + switchLen > s.Len())
      continue;
    if (IsString1PrefixedByString2_NoCase((const wchar_t *)s + pos, key))
    {
      switchIndex = i;
      maxLen = switchLen;
    }
  }

  if (maxLen < 0)
  {
    ErrorMessage = "Unknown switch:";
    return false;
  }

  pos += maxLen;
  
  CSwitchResult &sw = _switches[switchIndex];
  const CSwitchForm &form = switchForms[switchIndex];
  
  if (!form.Multi && sw.ThereIs)
  {
    ErrorMessage = "Multiple instances for switch:";
    return false;
  }

  sw.ThereIs = true;

  int rem = s.Len() - pos;
  if (rem < form.MinLen)
  {
    ErrorMessage = "Too short switch:";
    return false;
  }
  
  sw.WithMinus = false;
  sw.PostCharIndex = -1;
  
  switch (form.Type)
  {
    case NSwitchType::kMinus:
      if (rem == 1)
      {
        sw.WithMinus = (s[pos] == '-');
        if (sw.WithMinus)
          return true;
        ErrorMessage = "Incorrect switch postfix:";
        return false;
      }
      break;
      
    case NSwitchType::kChar:
      if (rem == 1)
      {
        wchar_t c = s[pos];
        if (c <= 0x7F)
        {
          sw.PostCharIndex = FindCharPosInString(form.PostCharSet, (char)c);
          if (sw.PostCharIndex >= 0)
            return true;
        }
        ErrorMessage = "Incorrect switch postfix:";
        return false;
      }
      break;
      
    case NSwitchType::kString:
      sw.PostStrings.Add((const wchar_t *)s + pos);
      return true;
  }

  if (pos != s.Len())
  {
    ErrorMessage = "Too long switch:";
    return false;
  }
  return true;
}

bool CParser::ParseStrings(const CSwitchForm *switchForms, const UStringVector &commandStrings)
{
  ErrorLine.Empty();
  bool stopSwitch = false;
  FOR_VECTOR (i, commandStrings)
  {
    const UString &s = commandStrings[i];
    if (!stopSwitch)
    {
      if (s.IsEqualTo(kStopSwitchParsing))
      {
        stopSwitch = true;
        continue;
      }
      if (!s.IsEmpty() && IsItSwitchChar(s[0]))
      {
        if (ParseString(s, switchForms))
          continue;
        ErrorLine = s;
        return false;
      }
    }
    NonSwitchStrings.Add(s);
  }
  return true;
}

}
// Common/CommandLineParser.h

#ifndef __COMMON_COMMAND_LINE_PARSER_H
#define __COMMON_COMMAND_LINE_PARSER_H

#include "MyString.h"

namespace NCommandLineParser {

bool SplitCommandLine(const UString &src, UString &dest1, UString &dest2);
void SplitCommandLine(const UString &s, UStringVector &parts);

namespace NSwitchType
{
  enum EEnum
  {
    kSimple,
    kMinus,
    kString,
    kChar
  };
}

struct CSwitchForm
{
  const char *Key;
  Byte Type;
  bool Multi;
  Byte MinLen;
  // int MaxLen;
  const char *PostCharSet;
};

struct CSwitchResult
{
  bool ThereIs;
  bool WithMinus;
  int PostCharIndex;
  UStringVector PostStrings;
  
  CSwitchResult(): ThereIs(false) {};
};
  
class CParser
{
  unsigned _numSwitches;
  CSwitchResult *_switches;

  bool ParseString(const UString &s, const CSwitchForm *switchForms);
public:
  UStringVector NonSwitchStrings;
  AString ErrorMessage;
  UString ErrorLine;
  
  CParser(unsigned numSwitches);
  ~CParser();
  bool ParseStrings(const CSwitchForm *switchForms, const UStringVector &commandStrings);
  const CSwitchResult& operator[](size_t index) const { return _switches[index]; }
};

}

#endif
// Common.h

#ifndef __COMMON_COMMON_H
#define __COMMON_COMMON_H

#include "../../C/Compiler.h"

#include "MyWindows.h"
#include "NewHandler.h"

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[1]))

#endif
// CrcReg.cpp

#include "StdAfx.h"

#include "../../C/7zCrc.h"
#include "../../C/CpuArch.h"

#include "../Common/MyCom.h"

#include "../7zip/Common/RegisterCodec.h"

EXTERN_C_BEGIN

typedef UInt32 (MY_FAST_CALL *CRC_FUNC)(UInt32 v, const void *data, size_t size, const UInt32 *table);

UInt32 MY_FAST_CALL CrcUpdateT1(UInt32 v, const void *data, size_t size, const UInt32 *table);

extern CRC_FUNC g_CrcUpdate;
extern CRC_FUNC g_CrcUpdateT8;
extern CRC_FUNC g_CrcUpdateT4;

EXTERN_C_END

class CCrcHasher:
  public IHasher,
  public ICompressSetCoderProperties,
  public CMyUnknownImp
{
  UInt32 _crc;
  CRC_FUNC _updateFunc;
  Byte mtDummy[1 << 7];
  
  bool SetFunctions(UInt32 tSize);
public:
  CCrcHasher(): _crc(CRC_INIT_VAL) { SetFunctions(0); }

  MY_UNKNOWN_IMP2(IHasher, ICompressSetCoderProperties)
  INTERFACE_IHasher(;)
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
};

bool CCrcHasher::SetFunctions(UInt32 tSize)
{
  _updateFunc = g_CrcUpdate;
  
  if (tSize == 1)
    _updateFunc = CrcUpdateT1;
  else if (tSize == 4)
  {
    if (g_CrcUpdateT4)
      _updateFunc = g_CrcUpdateT4;
    else
      return false;
  }
  else if (tSize == 8)
  {
    if (g_CrcUpdateT8)
      _updateFunc = g_CrcUpdateT8;
    else
      return false;
  }
  
  return true;
}

STDMETHODIMP CCrcHasher::SetCoderProperties(const PROPID *propIDs, const PROPVARIANT *coderProps, UInt32 numProps)
{
  for (UInt32 i = 0; i < numProps; i++)
  {
    const PROPVARIANT &prop = coderProps[i];
    if (propIDs[i] == NCoderPropID::kDefaultProp)
    {
      if (prop.vt != VT_UI4)
        return E_INVALIDARG;
      if (!SetFunctions(prop.ulVal))
        return E_NOTIMPL;
    }
  }
  return S_OK;
}

STDMETHODIMP_(void) CCrcHasher::Init() throw()
{
  _crc = CRC_INIT_VAL;
}

STDMETHODIMP_(void) CCrcHasher::Update(const void *data, UInt32 size) throw()
{
  _crc = _updateFunc(_crc, data, size, g_CrcTable);
}

STDMETHODIMP_(void) CCrcHasher::Final(Byte *digest) throw()
{
  UInt32 val = CRC_GET_DIGEST(_crc);
  SetUi32(digest, val);
}

REGISTER_HASHER(CCrcHasher, 0x1, "CRC32", 4)
// Common/Defs.h

#ifndef __COMMON_DEFS_H
#define __COMMON_DEFS_H

template <class T> inline T MyMin(T a, T b) { return a < b ? a : b; }
template <class T> inline T MyMax(T a, T b) { return a > b ? a : b; }

template <class T> inline int MyCompare(T a, T b)
  { return a == b ? 0 : (a < b ? -1 : 1); }

inline int BoolToInt(bool v) { return (v ? 1 : 0); }
inline bool IntToBool(int v) { return (v != 0); }

#endif
// Common/DynLimBuf.cpp

#include "StdAfx.h"

#include "DynLimBuf.h"
#include "MyString.h"

CDynLimBuf::CDynLimBuf(size_t limit) throw()
{
  _chars = 0;
  _pos = 0;
  _size = 0;
  _sizeLimit = limit;
  _error = true;
  unsigned size = 1 << 4;
  if (size > limit)
    size = (unsigned)limit;
  _chars = (Byte *)MyAlloc(size);
  if (_chars)
  {
    _size = size;
    _error = false;
  }
}

CDynLimBuf & CDynLimBuf::operator+=(char c) throw()
{
  if (_error)
    return *this;
  if (_size == _pos)
  {
    size_t n = _sizeLimit - _size;
    if (n == 0)
    {
      _error = true;
      return *this;
    }
    if (n > _size)
      n = _size;

    n += _pos;

    Byte *newBuf = (Byte *)MyAlloc(n);
    if (!newBuf)
    {
      _error = true;
      return *this;
    }
    memcpy(newBuf, _chars, _pos);
    MyFree(_chars);
    _chars = newBuf;
    _size = n;
  }
  _chars[_pos++] = c;
  return *this;
}

CDynLimBuf &CDynLimBuf::operator+=(const char *s) throw()
{
  if (_error)
    return *this;
  unsigned len = MyStringLen(s);
  size_t rem = _sizeLimit - _pos;
  if (rem < len)
  {
    len = (unsigned)rem;
    _error = true;
  }
  if (_size - _pos < len)
  {
    size_t n = _pos + len;
    if (n - _size < _size)
    {
      n = _sizeLimit;
      if (n - _size > _size)
        n = _size * 2;
    }

    Byte *newBuf = (Byte *)MyAlloc(n);
    if (!newBuf)
    {
      _error = true;
      return *this;
    }
    memcpy(newBuf, _chars, _pos);
    MyFree(_chars);
    _chars = newBuf;
    _size = n;
  }
  memcpy(_chars + _pos, s, len);
  _pos += len;
  return *this;
}
// Common/DynLimBuf.h

#ifndef __COMMON_DYN_LIM_BUF_H
#define __COMMON_DYN_LIM_BUF_H

#include <string.h>

#include "../../C/Alloc.h"

#include "MyString.h"

class CDynLimBuf
{
  Byte *_chars;
  size_t _pos;
  size_t _size;
  size_t _sizeLimit;
  bool _error;

  CDynLimBuf(const CDynLimBuf &s);

  // ---------- forbidden functions ----------
  CDynLimBuf &operator+=(wchar_t c);

public:
  CDynLimBuf(size_t limit) throw();
  ~CDynLimBuf() { MyFree(_chars); }

  size_t Len() const { return _pos; }
  void Empty() { _pos = 0; }

  operator const Byte *() const { return _chars; }
  // const char *Ptr() const { return _chars; }

  CDynLimBuf &operator+=(char c) throw();
  CDynLimBuf &operator+=(const char *s) throw();
};


#endif
// Common/DynamicBuffer.h

#ifndef __COMMON_DYNAMIC_BUFFER_H
#define __COMMON_DYNAMIC_BUFFER_H

template <class T> class CDynamicBuffer
{
  T *_items;
  size_t _size;
  size_t _pos;

  CDynamicBuffer(const CDynamicBuffer &buffer);
  void operator=(const CDynamicBuffer &buffer);

  void Grow(size_t size)
  {
    size_t delta = _size >= 64 ? _size : 64;
    if (delta < size)
      delta = size;
    size_t newCap = _size + delta;
    if (newCap < delta)
    {
      newCap = _size + size;
      if (newCap < size)
        throw 20120116;
    }

    T *newBuffer = new T[newCap];
    if (_pos != 0)
      memcpy(newBuffer, _items, _pos * sizeof(T));
    delete []_items;
    _items = newBuffer;
    _size = newCap;
  }

public:
  CDynamicBuffer(): _items(0), _size(0), _pos(0) {}
  // operator T *() { return _items; }
  operator const T *() const { return _items; }
  ~CDynamicBuffer() { delete []_items; }

  T *GetCurPtrAndGrow(size_t addSize)
  {
    size_t rem = _size - _pos;
    if (rem < addSize)
      Grow(addSize - rem);
    T *res = _items + _pos;
    _pos += addSize;
    return res;
  }

  void AddData(const T *data, size_t size)
  {
    memcpy(GetCurPtrAndGrow(size), data, size * sizeof(T));
  }

  const size_t GetPos() const { return _pos; }

  // void Empty() { _pos = 0; }
};

typedef CDynamicBuffer<unsigned char> CByteDynamicBuffer;

#endif
// Common/IntToString.cpp

#include "StdAfx.h"

#include "IntToString.h"

#define CONVERT_INT_TO_STR(charType, tempSize) \
  unsigned char temp[tempSize]; unsigned i = 0; \
  while (val >= 10) { temp[i++] = (unsigned char)('0' + (unsigned)(val % 10)); val /= 10; } \
  *s++ = (charType)('0' + (unsigned)val); \
  while (i != 0) { i--; *s++ = temp[i]; } \
  *s = 0;

void ConvertUInt32ToString(UInt32 val, char *s) throw()
{
  CONVERT_INT_TO_STR(char, 16);
}

void ConvertUInt64ToString(UInt64 val, char *s) throw()
{
  if (val <= (UInt32)0xFFFFFFFF)
  {
    ConvertUInt32ToString((UInt32)val, s);
    return;
  }
  CONVERT_INT_TO_STR(char, 24);
}

void ConvertUInt64ToOct(UInt64 val, char *s) throw()
{
  UInt64 v = val;
  unsigned i;
  for (i = 1;; i++)
  {
    v >>= 3;
    if (v == 0)
      break;
  }
  s[i] = 0;
  do
  {
    unsigned t = (unsigned)(val & 0x7);
    val >>= 3;
    s[--i] = (char)('0' + t);
  }
  while (i);
}

void ConvertUInt32ToHex(UInt32 val, char *s) throw()
{
  UInt32 v = val;
  unsigned i;
  for (i = 1;; i++)
  {
    v >>= 4;
    if (v == 0)
      break;
  }
  s[i] = 0;
  do
  {
    unsigned t = (unsigned)((val & 0xF));
    val >>= 4;
    s[--i] = (char)((t < 10) ? ('0' + t) : ('A' + (t - 10)));
  }
  while (i);
}

void ConvertUInt64ToHex(UInt64 val, char *s) throw()
{
  UInt64 v = val;
  unsigned i;
  for (i = 1;; i++)
  {
    v >>= 4;
    if (v == 0)
      break;
  }
  s[i] = 0;
  do
  {
    unsigned t = (unsigned)((val & 0xF));
    val >>= 4;
    s[--i] = (char)((t < 10) ? ('0' + t) : ('A' + (t - 10)));
  }
  while (i);
}

void ConvertUInt32ToHex8Digits(UInt32 val, char *s) throw()
{
  s[8] = 0;
  for (int i = 7; i >= 0; i--)
  {
    unsigned t = val & 0xF;
    val >>= 4;
    s[i] = (char)(((t < 10) ? ('0' + t) : ('A' + (t - 10))));
  }
}

/*
void ConvertUInt32ToHex8Digits(UInt32 val, wchar_t *s)
{
  s[8] = 0;
  for (int i = 7; i >= 0; i--)
  {
    unsigned t = val & 0xF;
    val >>= 4;
    s[i] = (wchar_t)(((t < 10) ? ('0' + t) : ('A' + (t - 10))));
  }
}
*/

void ConvertUInt32ToString(UInt32 val, wchar_t *s) throw()
{
  CONVERT_INT_TO_STR(wchar_t, 16);
}

void ConvertUInt64ToString(UInt64 val, wchar_t *s) throw()
{
  if (val <= (UInt32)0xFFFFFFFF)
  {
    ConvertUInt32ToString((UInt32)val, s);
    return;
  }
  CONVERT_INT_TO_STR(wchar_t, 24);
}

void ConvertInt64ToString(Int64 val, char *s) throw()
{
  if (val < 0)
  {
    *s++ = '-';
    val = -val;
  }
  ConvertUInt64ToString(val, s);
}

void ConvertInt64ToString(Int64 val, wchar_t *s) throw()
{
  if (val < 0)
  {
    *s++ = L'-';
    val = -val;
  }
  ConvertUInt64ToString(val, s);
}
// Common/IntToString.h

#ifndef __COMMON_INT_TO_STRING_H
#define __COMMON_INT_TO_STRING_H

#include "MyTypes.h"

void ConvertUInt32ToString(UInt32 value, char *s) throw();
void ConvertUInt64ToString(UInt64 value, char *s) throw();

void ConvertUInt32ToString(UInt32 value, wchar_t *s) throw();
void ConvertUInt64ToString(UInt64 value, wchar_t *s) throw();

void ConvertUInt64ToOct(UInt64 value, char *s) throw();

void ConvertUInt32ToHex(UInt32 value, char *s) throw();
void ConvertUInt64ToHex(UInt64 value, char *s) throw();
void ConvertUInt32ToHex8Digits(UInt32 value, char *s) throw();
// void ConvertUInt32ToHex8Digits(UInt32 value, wchar_t *s) throw();

void ConvertInt64ToString(Int64 value, char *s) throw();
void ConvertInt64ToString(Int64 value, wchar_t *s) throw();

#endif
// Common/Lang.cpp

#include "StdAfx.h"

#include "Lang.h"
#include "StringToInt.h"
#include "UTFConvert.h"

#include "../Windows/FileIO.h"

void CLang::Clear() throw()
{
  delete []_text;
  _text = 0;
  _ids.Clear();
  _offsets.Clear();
}

static const wchar_t *kLangSignature = L";!@Lang2@!UTF-8!";

bool CLang::OpenFromString(const AString &s2)
{
  UString s;
  if (!ConvertUTF8ToUnicode(s2, s))
    return false;
  unsigned i = 0;
  if (s.IsEmpty())
    return false;
  if (s[0] == 0xFEFF)
    i++;

  for (const wchar_t *p = kLangSignature;; i++)
  {
    wchar_t c = *p++;
    if (c == 0)
      break;
    if (s[i] != c)
      return false;
  }

  _text = new wchar_t[s.Len() - i + 1];
  wchar_t *text = _text;

  Int32 id = -100;
  UInt32 pos = 0;

  while (i < s.Len())
  {
    unsigned start = pos;
    do
    {
      wchar_t c = s[i++];
      if (c == '\n')
        break;
      if (c == '\\')
      {
        if (i == s.Len())
          return false;
        c = s[i++];
        switch (c)
        {
          case '\n': return false;
          case 'n': c = '\n'; break;
          case 't': c = '\t'; break;
          case '\\': c = '\\'; break;
          default: text[pos++] = L'\\'; break;
        }
      }
      text[pos++] = c;
    }
    while (i < s.Len());

    {
      unsigned j = start;
      for (; j < pos; j++)
        if (text[j] != ' ')
          break;
      if (j == pos)
      {
        id++;
        continue;
      }
    }
    if (text[start] == ';')
    {
      pos = start;
      id++;
      continue;
    }
    
    text[pos++] = 0;
    const wchar_t *end;
    UInt32 id32 = ConvertStringToUInt32(text + start, &end);
    if (*end == 0)
    {
      if (id32 > ((UInt32)1 << 30) || (Int32)id32 < id)
        return false;
      id = (Int32)id32;
      pos = start;
      continue;
    }

    if (id < 0)
      return false;
    _ids.Add((UInt32)id++);
    _offsets.Add(start);
  }

  return true;
}

bool CLang::Open(CFSTR fileName, const wchar_t *id)
{
  Clear();
  NWindows::NFile::NIO::CInFile file;
  if (!file.Open(fileName))
    return false;
  UInt64 length;
  if (!file.GetLength(length))
    return false;
  if (length > (1 << 20))
    return false;
  
  AString s;
  unsigned len = (unsigned)length;
  char *p = s.GetBuf(len);
  UInt32 processed;
  if (!file.Read(p, len, processed))
    return false;
  file.Close();
  if (len != processed)
    return false;

  char *p2 = p;
  for (unsigned i = 0; i < len; i++)
  {
    char c = p[i];
    if (c == 0)
      break;
    if (c != 0x0D)
      *p2++ = c;
  }
  *p2 = 0;
  s.ReleaseBuf_SetLen((unsigned)(p2 - p));
  
  if (OpenFromString(s))
  {
    const wchar_t *name = Get(0);
    if (name && wcscmp(name, id) == 0)
      return true;
  }
  
  Clear();
  return false;
}

const wchar_t *CLang::Get(UInt32 id) const throw()
{
  int index = _ids.FindInSorted(id);
  if (index < 0)
    return NULL;
  return _text + (size_t)_offsets[index];
}
// Common/Lang.h

#ifndef __COMMON_LANG_H
#define __COMMON_LANG_H

#include "MyString.h"

class CLang
{
  wchar_t *_text;
  CRecordVector<UInt32> _ids;
  CRecordVector<UInt32> _offsets;

  bool OpenFromString(const AString &s);
public:
  CLang(): _text(0) {}
  ~CLang() { Clear(); }
  bool Open(CFSTR fileName, const wchar_t *id);
  void Clear() throw();
  const wchar_t *Get(UInt32 id) const throw();
};

#endif
// Common/ListFileUtils.cpp

#include "StdAfx.h"

#include "../../C/CpuArch.h"

#include "../Windows/FileIO.h"

#include "ListFileUtils.h"
#include "MyBuffer.h"
#include "StringConvert.h"
#include "UTFConvert.h"

static const char kQuoteChar = '\"';

static void AddName(UStringVector &strings, UString &s)
{
  s.Trim();
  if (s.Len() >= 2 && s[0] == kQuoteChar && s.Back() == kQuoteChar)
  {
    s.DeleteBack();
    s.Delete(0);
  }
  if (!s.IsEmpty())
    strings.Add(s);
}

bool ReadNamesFromListFile(CFSTR fileName, UStringVector &strings, UINT codePage)
{
  NWindows::NFile::NIO::CInFile file;
  if (!file.Open(fileName,true))  /* follow the symbolic link */
    return false;
  UInt64 fileSize;
  if (!file.GetLength(fileSize))
    return false;
  if (fileSize >= ((UInt32)1 << 31) - 32)
    return false;
  UString u;
  if (codePage == MY__CP_UTF16 || codePage == MY__CP_UTF16BE)
  {
    if ((fileSize & 1) != 0)
      return false;
    CByteArr buf((size_t)fileSize);
    UInt32 processed;
    if (!file.Read(buf, (UInt32)fileSize, processed))
      return false;
    if (processed != fileSize)
      return false;
    file.Close();
    unsigned num = (unsigned)fileSize / 2;
    wchar_t *p = u.GetBuf(num);
    if (codePage == MY__CP_UTF16)
      for (unsigned i = 0; i < num; i++)
      {
        wchar_t c = GetUi16(buf + i * 2);
        if (c == 0)
          return false;
        p[i] = c;
      }
    else
      for (unsigned i = 0; i < num; i++)
      {
        wchar_t c = (wchar_t)GetBe16(buf + i * 2);
        if (c == 0)
          return false;
        p[i] = c;
      }
    p[num] = 0;
    u.ReleaseBuf_SetLen(num);
  }
  else
  {
    AString s;
    char *p = s.GetBuf((unsigned)fileSize);
    UInt32 processed;
    if (!file.Read(p, (UInt32)fileSize, processed))
      return false;
    if (processed != fileSize)
      return false;
    file.Close();
    s.ReleaseBuf_CalcLen((unsigned)processed);
    if (s.Len() != processed)
      return false;
    
    // #ifdef CP_UTF8
    if (codePage == CP_UTF8)
    {
      if (!ConvertUTF8ToUnicode(s, u))
        return false;
    }
    else
    // #endif
      MultiByteToUnicodeString2(u, s, codePage);
  }

  const wchar_t kGoodBOM = 0xFEFF;
  const wchar_t kBadBOM  = 0xFFFE;
  
  UString s;
  unsigned i = 0;
  for (; i < u.Len() && u[i] == kGoodBOM; i++);
  for (; i < u.Len(); i++)
  {
    wchar_t c = u[i];
    if (c == kGoodBOM || c == kBadBOM)
      return false;
    if (c == L'\n' || c == 0xD)
    {
      AddName(strings, s);
      s.Empty();
    }
    else
      s += c;
  }
  AddName(strings, s);
  return true;
}
// Common/ListFileUtils.h

#ifndef __COMMON_LIST_FILE_UTILS_H
#define __COMMON_LIST_FILE_UTILS_H

#include "MyString.h"
#include "MyTypes.h"

#define MY__CP_UTF16   1200
#define MY__CP_UTF16BE 1201

bool ReadNamesFromListFile(CFSTR fileName, UStringVector &strings, UINT codePage = CP_OEMCP);

#endif
// Common/MyBuffer.h

#ifndef __COMMON_MY_BUFFER_H
#define __COMMON_MY_BUFFER_H

#include "Defs.h"

template <class T> class CBuffer
{
  T *_items;
  size_t _size;

public:
  void Free()
  {
    if (_items)
    {
      delete []_items;
      _items = 0;
    }
    _size = 0;
  }
  
  CBuffer(): _items(0), _size(0) {};
  CBuffer(size_t size): _items(0), _size(0) { _items = new T[size]; _size = size; }
  CBuffer(const CBuffer &buffer): _items(0), _size(0)
  {
    size_t size = buffer._size;
    if (size != 0)
    {
      _items = new T[size];
      memcpy(_items, buffer._items, size * sizeof(T));
      _size = size;
    }
  }

  ~CBuffer() { delete []_items; }

  operator       T *()       { return _items; }
  operator const T *() const { return _items; }
  size_t Size() const { return _size; }

  void Alloc(size_t size)
  {
    if (size != _size)
    {
      Free();
      if (size != 0)
      {
        _items = new T[size];
        _size = size;
      }
    }
  }

  void AllocAtLeast(size_t size)
  {
    if (size > _size)
    {
      Free();
      _items = new T[size];
      _size = size;
    }
  }

  void CopyFrom(const T *data, size_t size)
  {
    Alloc(size);
    if (size != 0)
      memcpy(_items, data, size * sizeof(T));
  }

  void ChangeSize_KeepData(size_t newSize, size_t keepSize)
  {
    if (newSize == _size)
      return;
    T *newBuffer = NULL;
    if (newSize != 0)
    {
      newBuffer = new T[newSize];
      if (keepSize > _size)
        keepSize = _size;
      if (keepSize != 0)
        memcpy(newBuffer, _items, MyMin(keepSize, newSize) * sizeof(T));
    }
    delete []_items;
    _items = newBuffer;
    _size = newSize;
  }

  CBuffer& operator=(const CBuffer &buffer)
  {
    if (&buffer != this)
      CopyFrom(buffer, buffer._size);
    return *this;
  }
};

template <class T>
bool operator==(const CBuffer<T>& b1, const CBuffer<T>& b2)
{
  size_t size1 = b1.Size();
  if (size1 != b2.Size())
    return false;
  if (size1 == 0)
    return true;
  return memcmp(b1, b2, size1 * sizeof(T)) == 0;
}

template <class T>
bool operator!=(const CBuffer<T>& b1, const CBuffer<T>& b2)
{
  size_t size1 = b1.Size();
  if (size1 != b2.Size())
    return true;
  if (size1 == 0)
    return false;
  return memcmp(b1, b2, size1 * sizeof(T)) != 0;
}


typedef CBuffer<char> CCharBuffer;
// typedef CBuffer<wchar_t> CWCharBuffer;
typedef CBuffer<unsigned char> CByteBuffer;


template <class T> class CObjArray
{
protected:
  T *_items;
private:
  // we disable constructors
  CObjArray(const CObjArray &buffer);
  void operator=(const CObjArray &buffer);
public:
  void Free()
  {
    delete []_items;
    _items = 0;
  }
  CObjArray(size_t size): _items(0) { if (size != 0) _items = new T[size]; }
  CObjArray(): _items(0) {};
  ~CObjArray() { delete []_items; }
  
  operator       T *()       { return _items; }
  operator const T *() const { return _items; }
  
  void Alloc(size_t newSize)
  {
    delete []_items;
    _items = 0;
    _items = new T[newSize];
  }
};

typedef CObjArray<unsigned char> CByteArr;
typedef CObjArray<bool> CBoolArr;
typedef CObjArray<int> CIntArr;
typedef CObjArray<unsigned> CUIntArr;


template <class T> class CObjArray2
{
  T *_items;
  unsigned _size;

  CObjArray2(const CObjArray2 &buffer);
  void operator=(const CObjArray2 &buffer);
public:
  
  void Free()
  {
    delete []_items;
    _items = 0;
    _size = 0;
  }
  CObjArray2(): _items(0), _size(0) {};
  /*
  CObjArray2(const CObjArray2 &buffer): _items(0), _size(0)
  {
    size_t newSize = buffer._size;
    if (newSize != 0)
    {
      T *newBuffer = new T[newSize];;
      _items = newBuffer;
      _size = newSize;
      const T *src = buffer;
      for (size_t i = 0; i < newSize; i++)
        newBuffer[i] = src[i];
    }
  }
  */
  /*
  CObjArray2(size_t size): _items(0), _size(0)
  {
    if (size != 0)
    {
      _items = new T[size];
      _size = size;
    }
  }
  */

  ~CObjArray2() { delete []_items; }
  
  operator       T *()       { return _items; }
  operator const T *() const { return _items; }
  
  unsigned Size() const { return (unsigned)_size; }
  bool IsEmpty() const { return _size == 0; }

  // SetSize doesn't keep old items. It allocates new array if size is not equal
  void SetSize(unsigned size)
  {
    if (size == _size)
      return;
    T *newBuffer = NULL;
    if (size != 0)
      newBuffer = new T[size];
    delete []_items;
    _items = newBuffer;
    _size = size;
  }

  /*
  CObjArray2& operator=(const CObjArray2 &buffer)
  {
    Free();
    size_t newSize = buffer._size;
    if (newSize != 0)
    {
      T *newBuffer = new T[newSize];;
      _items = newBuffer;
      _size = newSize;
      const T *src = buffer;
      for (size_t i = 0; i < newSize; i++)
        newBuffer[i] = src[i];
    }
    return *this;
  }
  */
};

#endif
// MyCom.h

#ifndef __MY_COM_H
#define __MY_COM_H

#include "MyWindows.h"
#include "NewHandler.h"

#ifndef RINOK
#define RINOK(x) { HRESULT __result_ = (x); if (__result_ != S_OK) return __result_; }
#endif

template <class T>
class CMyComPtr
{
  T* _p;
public:
  CMyComPtr(): _p(NULL) {}
  CMyComPtr(T* p) throw() { if ((_p = p) != NULL) p->AddRef(); }
  CMyComPtr(const CMyComPtr<T>& lp) throw() { if ((_p = lp._p) != NULL) _p->AddRef(); }
  ~CMyComPtr() { if (_p) _p->Release(); }
  void Release() { if (_p) { _p->Release(); _p = NULL; } }
  operator T*() const {  return (T*)_p;  }
  // T& operator*() const {  return *_p; }
  T** operator&() { return &_p; }
  T* operator->() const { return _p; }
  T* operator=(T* p)
  {
    if (p)
      p->AddRef();
    if (_p)
      _p->Release();
    _p = p;
    return p;
  }
  T* operator=(const CMyComPtr<T>& lp) { return (*this = lp._p); }
  bool operator!() const { return (_p == NULL); }
  // bool operator==(T* pT) const {  return _p == pT; }
  void Attach(T* p2)
  {
    Release();
    _p = p2;
  }
  T* Detach()
  {
    T* pt = _p;
    _p = NULL;
    return pt;
  }
  #ifdef _WIN32
  HRESULT CoCreateInstance(REFCLSID rclsid, REFIID iid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
  {
    return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, iid, (void**)&_p);
  }
  #endif
  /*
  HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
  {
    CLSID clsid;
    HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
    ATLASSERT(_p == NULL);
    if (SUCCEEDED(hr))
      hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&_p);
    return hr;
  }
  */
  template <class Q>
  HRESULT QueryInterface(REFGUID iid, Q** pp) const throw()
  {
    return _p->QueryInterface(iid, (void**)pp);
  }
};

//////////////////////////////////////////////////////////

inline HRESULT StringToBstr(LPCOLESTR src, BSTR *bstr)
{
  *bstr = ::SysAllocString(src);
  return (*bstr) ? S_OK : E_OUTOFMEMORY;
}

class CMyComBSTR
{
  BSTR m_str;

public:
  CMyComBSTR(): m_str(NULL) {}
  ~CMyComBSTR() { ::SysFreeString(m_str); }
  BSTR* operator&() { return &m_str; }
  operator LPCOLESTR() const { return m_str; }
  // operator bool() const { return m_str != NULL; }
  // bool operator!() const { return m_str == NULL; }
private:
  // operator BSTR() const { return m_str; }

  CMyComBSTR(LPCOLESTR src) { m_str = ::SysAllocString(src); }
  // CMyComBSTR(int nSize) { m_str = ::SysAllocStringLen(NULL, nSize); }
  // CMyComBSTR(int nSize, LPCOLESTR sz) { m_str = ::SysAllocStringLen(sz, nSize);  }
  CMyComBSTR(const CMyComBSTR& src) { m_str = src.MyCopy(); }
  
  /*
  CMyComBSTR(REFGUID src)
  {
    LPOLESTR szGuid;
    StringFromCLSID(src, &szGuid);
    m_str = ::SysAllocString(szGuid);
    CoTaskMemFree(szGuid);
  }
  */
  
  CMyComBSTR& operator=(const CMyComBSTR& src)
  {
    if (m_str != src.m_str)
    {
      if (m_str)
        ::SysFreeString(m_str);
      m_str = src.MyCopy();
    }
    return *this;
  }
  
  CMyComBSTR& operator=(LPCOLESTR src)
  {
    ::SysFreeString(m_str);
    m_str = ::SysAllocString(src);
    return *this;
  }
  
  unsigned Len() const { return ::SysStringLen(m_str); }

  BSTR MyCopy() const
  {
    // We don't support Byte BSTRs here
    return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
    /*
    UINT byteLen = ::SysStringByteLen(m_str);
    BSTR res = ::SysAllocStringByteLen(NULL, byteLen);
    if (res && byteLen != 0 && m_str)
      memcpy(res, m_str, byteLen);
    return res;
    */
  }
  
  /*
  void Attach(BSTR src) { m_str = src; }
  BSTR Detach()
  {
    BSTR s = m_str;
    m_str = NULL;
    return s;
  }
  */

  void Empty()
  {
    ::SysFreeString(m_str);
    m_str = NULL;
  }
};

//////////////////////////////////////////////////////////

class CMyUnknownImp
{
public:
  ULONG __m_RefCount;
  CMyUnknownImp(): __m_RefCount(0) {}

  // virtual ~CMyUnknownImp() {};
};

#define MY_QUERYINTERFACE_BEGIN STDMETHOD(QueryInterface) \
(REFGUID iid, void **outObject) throw() { *outObject = NULL;

#define MY_QUERYINTERFACE_ENTRY(i) else if (iid == IID_ ## i) \
    { *outObject = (void *)(i *)this; }

#define MY_QUERYINTERFACE_ENTRY_UNKNOWN(i) if (iid == IID_IUnknown) \
    { *outObject = (void *)(IUnknown *)(i *)this; }

#define MY_QUERYINTERFACE_BEGIN2(i) MY_QUERYINTERFACE_BEGIN \
    MY_QUERYINTERFACE_ENTRY_UNKNOWN(i) \
    MY_QUERYINTERFACE_ENTRY(i)

#define MY_QUERYINTERFACE_END else return E_NOINTERFACE; ++__m_RefCount; /* AddRef(); */ return S_OK; }

#define MY_ADDREF_RELEASE \
STDMETHOD_(ULONG, AddRef)() throw() { return ++__m_RefCount; } \
STDMETHOD_(ULONG, Release)() { if (--__m_RefCount != 0)  \
  return __m_RefCount; delete this; return 0; }

#define MY_UNKNOWN_IMP_SPEC(i) \
  MY_QUERYINTERFACE_BEGIN \
  i \
  MY_QUERYINTERFACE_END \
  MY_ADDREF_RELEASE


#define MY_UNKNOWN_IMP MY_QUERYINTERFACE_BEGIN \
  MY_QUERYINTERFACE_ENTRY_UNKNOWN(IUnknown) \
  MY_QUERYINTERFACE_END \
  MY_ADDREF_RELEASE

#define MY_UNKNOWN_IMP1(i) MY_UNKNOWN_IMP_SPEC( \
  MY_QUERYINTERFACE_ENTRY_UNKNOWN(i) \
  MY_QUERYINTERFACE_ENTRY(i) \
  )

#define MY_UNKNOWN_IMP2(i1, i2) MY_UNKNOWN_IMP_SPEC( \
  MY_QUERYINTERFACE_ENTRY_UNKNOWN(i1) \
  MY_QUERYINTERFACE_ENTRY(i1) \
  MY_QUERYINTERFACE_ENTRY(i2) \
  )

#define MY_UNKNOWN_IMP3(i1, i2, i3) MY_UNKNOWN_IMP_SPEC( \
  MY_QUERYINTERFACE_ENTRY_UNKNOWN(i1) \
  MY_QUERYINTERFACE_ENTRY(i1) \
  MY_QUERYINTERFACE_ENTRY(i2) \
  MY_QUERYINTERFACE_ENTRY(i3) \
  )

#define MY_UNKNOWN_IMP4(i1, i2, i3, i4) MY_UNKNOWN_IMP_SPEC( \
  MY_QUERYINTERFACE_ENTRY_UNKNOWN(i1) \
  MY_QUERYINTERFACE_ENTRY(i1) \
  MY_QUERYINTERFACE_ENTRY(i2) \
  MY_QUERYINTERFACE_ENTRY(i3) \
  MY_QUERYINTERFACE_ENTRY(i4) \
  )

#define MY_UNKNOWN_IMP5(i1, i2, i3, i4, i5) MY_UNKNOWN_IMP_SPEC( \
  MY_QUERYINTERFACE_ENTRY_UNKNOWN(i1) \
  MY_QUERYINTERFACE_ENTRY(i1) \
  MY_QUERYINTERFACE_ENTRY(i2) \
  MY_QUERYINTERFACE_ENTRY(i3) \
  MY_QUERYINTERFACE_ENTRY(i4) \
  MY_QUERYINTERFACE_ENTRY(i5) \
  )

#define MY_UNKNOWN_IMP6(i1, i2, i3, i4, i5, i6) MY_UNKNOWN_IMP_SPEC( \
  MY_QUERYINTERFACE_ENTRY_UNKNOWN(i1) \
  MY_QUERYINTERFACE_ENTRY(i1) \
  MY_QUERYINTERFACE_ENTRY(i2) \
  MY_QUERYINTERFACE_ENTRY(i3) \
  MY_QUERYINTERFACE_ENTRY(i4) \
  MY_QUERYINTERFACE_ENTRY(i5) \
  MY_QUERYINTERFACE_ENTRY(i6) \
  )

#define MY_UNKNOWN_IMP7(i1, i2, i3, i4, i5, i6, i7) MY_UNKNOWN_IMP_SPEC( \
  MY_QUERYINTERFACE_ENTRY_UNKNOWN(i1) \
  MY_QUERYINTERFACE_ENTRY(i1) \
  MY_QUERYINTERFACE_ENTRY(i2) \
  MY_QUERYINTERFACE_ENTRY(i3) \
  MY_QUERYINTERFACE_ENTRY(i4) \
  MY_QUERYINTERFACE_ENTRY(i5) \
  MY_QUERYINTERFACE_ENTRY(i6) \
  MY_QUERYINTERFACE_ENTRY(i7) \
  )

const HRESULT k_My_HRESULT_WritingWasCut = 0x20000010;

#endif
// Common/Exception.h

#ifndef __COMMON_EXCEPTION_H
#define __COMMON_EXCEPTION_H

#include "MyWindows.h"

struct CSystemException
{
  HRESULT ErrorCode;
  CSystemException(HRESULT errorCode): ErrorCode(errorCode) {}
};

#endif
// Common/MyGuidDef.h

#ifndef GUID_DEFINED
#define GUID_DEFINED

#include "MyTypes.h"

typedef struct {
  UInt32 Data1;
  UInt16 Data2;
  UInt16 Data3;
  unsigned char Data4[8];
} GUID;

#ifdef __cplusplus
#define REFGUID const GUID &
#else
#define REFGUID const GUID *
#endif

#define REFCLSID REFGUID
#define REFIID REFGUID

#ifdef __cplusplus
inline int operator==(REFGUID g1, REFGUID g2)
{
  for (int i = 0; i < (int)sizeof(g1); i++)
    if (((unsigned char *)&g1)[i] != ((unsigned char *)&g2)[i])
      return 0;
  return 1;
}
inline int operator!=(REFGUID g1, REFGUID g2) { return !(g1 == g2); }
#endif

#ifdef __cplusplus
  #define MY_EXTERN_C extern "C"
#else
  #define MY_EXTERN_C extern
#endif

#endif


#ifdef DEFINE_GUID
#undef DEFINE_GUID
#endif

#ifdef INITGUID
  #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    MY_EXTERN_C const GUID name = { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }
#else
  #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    MY_EXTERN_C const GUID name
#endif
// Common/MyInitGuid.h

#ifndef __COMMON_MY_INITGUID_H
#define __COMMON_MY_INITGUID_H

/*
This file must be included only to one C++ file in project before
declarations of COM interfaces with DEFINE_GUID macro.

Each GUID must be initialized exactly once in project.
There are two different versions of the DEFINE_GUID macro in guiddef.h (MyGuidDef.h):
  - if INITGUID is not defined:  DEFINE_GUID declares an external reference to the symbol name.
  - if INITGUID is     defined:  DEFINE_GUID initializes the symbol name to the value of the GUID.

Also we need IID_IUnknown that is initialized in some file for linking:
  MSVC:  by default the linker uses some lib file that contains IID_IUnknown
  MinGW: add -luuid switch for linker
  WinCE: we define IID_IUnknown in this file
  Other: we define IID_IUnknown in this file
*/

#ifdef _WIN32

#ifdef UNDER_CE
#include <basetyps.h>
#endif

#include <initguid.h>

#ifdef UNDER_CE
DEFINE_GUID(IID_IUnknown,
0x00000000, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
#endif

#else

#define INITGUID
#include "MyGuidDef.h"
DEFINE_GUID(IID_IUnknown,
0x00000000, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

#endif


#endif
// MyLinux.h

#ifndef __MY_LIN_LINUX_H
#define __MY_LIN_LINUX_H

#define MY_LIN_S_IFMT  00170000
#define MY_LIN_S_IFSOCK 0140000
#define MY_LIN_S_IFLNK  0120000
#define MY_LIN_S_IFREG  0100000
#define MY_LIN_S_IFBLK  0060000
#define MY_LIN_S_IFDIR  0040000
#define MY_LIN_S_IFCHR  0020000
#define MY_LIN_S_IFIFO  0010000

#define MY_LIN_S_ISLNK(m)   (((m) & MY_LIN_S_IFMT) == MY_LIN_S_IFLNK)
#define MY_LIN_S_ISREG(m)   (((m) & MY_LIN_S_IFMT) == MY_LIN_S_IFREG)
#define MY_LIN_S_ISDIR(m)   (((m) & MY_LIN_S_IFMT) == MY_LIN_S_IFDIR)
#define MY_LIN_S_ISCHR(m)   (((m) & MY_LIN_S_IFMT) == MY_LIN_S_IFCHR)
#define MY_LIN_S_ISBLK(m)   (((m) & MY_LIN_S_IFMT) == MY_LIN_S_IFBLK)
#define MY_LIN_S_ISFIFO(m)  (((m) & MY_LIN_S_IFMT) == MY_LIN_S_IFIFO)
#define MY_LIN_S_ISSOCK(m)  (((m) & MY_LIN_S_IFMT) == MY_LIN_S_IFSOCK)

#define MY_LIN_S_ISUID 0004000
#define MY_LIN_S_ISGID 0002000
#define MY_LIN_S_ISVTX 0001000

#define MY_LIN_S_IRWXU 00700
#define MY_LIN_S_IRUSR 00400
#define MY_LIN_S_IWUSR 00200
#define MY_LIN_S_IXUSR 00100

#define MY_LIN_S_IRWXG 00070
#define MY_LIN_S_IRGRP 00040
#define MY_LIN_S_IWGRP 00020
#define MY_LIN_S_IXGRP 00010

#define MY_LIN_S_IRWXO 00007
#define MY_LIN_S_IROTH 00004
#define MY_LIN_S_IWOTH 00002
#define MY_LIN_S_IXOTH 00001

#endif
// MyMap.cpp

#include "StdAfx.h"

#include "MyMap.h"

static const unsigned kNumBitsMax = sizeof(UInt32) * 8;

static UInt32 GetSubBits(UInt32 value, unsigned startPos, unsigned numBits) throw()
{
  if (startPos == sizeof(value) * 8)
    return 0;
  value >>= startPos;
  if (numBits == sizeof(value) * 8)
    return value;
  return value & (((UInt32)1 << numBits) - 1);
}

static inline unsigned GetSubBit(UInt32 v, unsigned n) { return (unsigned)(v >> n) & 1; }

bool CMap32::Find(UInt32 key, UInt32 &valueRes) const throw()
{
  valueRes = (UInt32)(Int32)-1;
  if (Nodes.Size() == 0)
    return false;
  if (Nodes.Size() == 1)
  {
    const CNode &n = Nodes[0];
    if (n.Len == kNumBitsMax)
    {
      valueRes = n.Values[0];
      return (key == n.Key);
    }
  }

  unsigned cur = 0;
  unsigned bitPos = kNumBitsMax;
  for (;;)
  {
    const CNode &n = Nodes[cur];
    bitPos -= n.Len;
    if (GetSubBits(key, bitPos, n.Len) != GetSubBits(n.Key, bitPos, n.Len))
      return false;
    unsigned bit = GetSubBit(key, --bitPos);
    if (n.IsLeaf[bit])
    {
      valueRes = n.Values[bit];
      return (key == n.Keys[bit]);
    }
    cur = (unsigned)n.Keys[bit];
  }
}

bool CMap32::Set(UInt32 key, UInt32 value)
{
  if (Nodes.Size() == 0)
  {
    CNode n;
    n.Key = n.Keys[0] = n.Keys[1] = key;
    n.Values[0] = n.Values[1] = value;
    n.IsLeaf[0] = n.IsLeaf[1] = 1;
    n.Len = kNumBitsMax;
    Nodes.Add(n);
    return false;
  }
  if (Nodes.Size() == 1)
  {
    CNode &n = Nodes[0];
    if (n.Len == kNumBitsMax)
    {
      if (key == n.Key)
      {
        n.Values[0] = n.Values[1] = value;
        return true;
      }
      unsigned i = kNumBitsMax - 1;
      for (; GetSubBit(key, i) == GetSubBit(n.Key, i); i--);
      n.Len = (UInt16)(kNumBitsMax - (1 + i));
      unsigned newBit = GetSubBit(key, i);
      n.Values[newBit] = value;
      n.Keys[newBit] = key;
      return false;
    }
  }

  unsigned cur = 0;
  unsigned bitPos = kNumBitsMax;
  for (;;)
  {
    CNode &n = Nodes[cur];
    bitPos -= n.Len;
    if (GetSubBits(key, bitPos, n.Len) != GetSubBits(n.Key, bitPos, n.Len))
    {
      unsigned i = n.Len - 1;
      for (; GetSubBit(key, bitPos + i) == GetSubBit(n.Key, bitPos + i); i--);
      
      CNode e2(n);
      e2.Len = (UInt16)i;

      n.Len = (UInt16)(n.Len - (1 + i));
      unsigned newBit = GetSubBit(key, bitPos + i);
      n.Values[newBit] = value;
      n.IsLeaf[newBit] = 1;
      n.IsLeaf[1 - newBit] = 0;
      n.Keys[newBit] = key;
      n.Keys[1 - newBit] = Nodes.Size();
      Nodes.Add(e2);
      return false;
    }
    unsigned bit = GetSubBit(key, --bitPos);

    if (n.IsLeaf[bit])
    {
      if (key == n.Keys[bit])
      {
        n.Values[bit] = value;
        return true;
      }
      unsigned i = bitPos - 1;
      for (; GetSubBit(key, i) == GetSubBit(n.Keys[bit], i); i--);
     
      CNode e2;
      
      unsigned newBit = GetSubBit(key, i);
      e2.Values[newBit] = value;
      e2.Values[1 - newBit] = n.Values[bit];
      e2.IsLeaf[newBit] = e2.IsLeaf[1 - newBit] = 1;
      e2.Keys[newBit] = key;
      e2.Keys[1 - newBit] = e2.Key = n.Keys[bit];
      e2.Len = (UInt16)(bitPos - (1 + i));

      n.IsLeaf[bit] = 0;
      n.Keys[bit] = Nodes.Size();

      Nodes.Add(e2);
      return false;
    }
    cur = (unsigned)n.Keys[bit];
  }
}
// MyMap.h

#ifndef __COMMON_MYMAP_H
#define __COMMON_MYMAP_H

#include "MyTypes.h"
#include "MyVector.h"

class CMap32
{
  struct CNode
  {
    UInt32 Key;
    UInt32 Keys[2];
    UInt32 Values[2];
    UInt16 Len;
    Byte IsLeaf[2];
  };
  CRecordVector<CNode> Nodes;

public:

  void Clear() { Nodes.Clear(); }
  bool Find(UInt32 key, UInt32 &valueRes) const throw();
  bool Set(UInt32 key, UInt32 value); // returns true, if there is such key already
};

#endif
// Common/MyString.cpp

#include "StdAfx.h"

#ifdef _WIN32
#include <wchar.h>
#else
#include <ctype.h>
#endif

#if !defined(_UNICODE) || !defined(USE_UNICODE_FSTRING)
#include "StringConvert.h"
#endif

#include "MyString.h"

#define MY_STRING_NEW(_T_, _size_) new _T_[_size_]
// #define MY_STRING_NEW(_T_, _size_) ((_T_ *)my_new((size_t)(_size_) * sizeof(_T_)))

/*
inline const char* MyStringGetNextCharPointer(const char *p) throw()
{
  #if defined(_WIN32) && !defined(UNDER_CE)
  return CharNextA(p);
  #else
  return p + 1;
  #endif
}
*/

int FindCharPosInString(const char *s, char c) throw()
{
  for (const char *p = s;; p++)
  {
    if (*p == c)
      return (int)(p - s);
    if (*p == 0)
      return -1;
    // MyStringGetNextCharPointer(p);
  }
}

int FindCharPosInString(const wchar_t *s, wchar_t c) throw()
{
  for (const wchar_t *p = s;; p++)
  {
    if (*p == c)
      return (int)(p - s);
    if (*p == 0)
      return -1;
  }
}

/*
void MyStringUpper_Ascii(wchar_t *s)
{
  for (;;)
  {
    wchar_t c = *s;
    if (c == 0)
      return;
    *s++ = MyCharUpper_Ascii(c);
  }
}
*/

void MyStringLower_Ascii(char *s) throw()
{
  for (;;)
  {
    char c = *s;
    if (c == 0)
      return;
    *s++ = MyCharLower_Ascii(c);
  }
}

void MyStringLower_Ascii(wchar_t *s) throw()
{
  for (;;)
  {
    wchar_t c = *s;
    if (c == 0)
      return;
    *s++ = MyCharLower_Ascii(c);
  }
}

#ifdef _WIN32

#ifdef _UNICODE

// wchar_t * MyStringUpper(wchar_t *s) { return CharUpperW(s); }
// wchar_t * MyStringLower(wchar_t *s) { return CharLowerW(s); }
// for WinCE - FString - char
// const char *MyStringGetPrevCharPointer(const char * /* base */, const char *p) { return p - 1; }

#else

// const char * MyStringGetPrevCharPointer(const char *base, const char *p) throw() { return CharPrevA(base, p); }
// char * MyStringUpper(char *s) { return CharUpperA(s); }
// char * MyStringLower(char *s) { return CharLowerA(s); }

wchar_t MyCharUpper_WIN(wchar_t c) throw()
{
  wchar_t *res = CharUpperW((LPWSTR)(UINT_PTR)(unsigned)c);
  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
    return (wchar_t)(unsigned)(UINT_PTR)res;
  const int kBufSize = 4;
  char s[kBufSize + 1];
  int numChars = ::WideCharToMultiByte(CP_ACP, 0, &c, 1, s, kBufSize, 0, 0);
  if (numChars == 0 || numChars > kBufSize)
    return c;
  s[numChars] = 0;
  ::CharUpperA(s);
  ::MultiByteToWideChar(CP_ACP, 0, s, numChars, &c, 1);
  return c;
}

/*
wchar_t MyCharLower_WIN(wchar_t c)
{
  wchar_t *res = CharLowerW((LPWSTR)(UINT_PTR)(unsigned)c);
  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
    return (wchar_t)(unsigned)(UINT_PTR)res;
  const int kBufSize = 4;
  char s[kBufSize + 1];
  int numChars = ::WideCharToMultiByte(CP_ACP, 0, &c, 1, s, kBufSize, 0, 0);
  if (numChars == 0 || numChars > kBufSize)
    return c;
  s[numChars] = 0;
  ::CharLowerA(s);
  ::MultiByteToWideChar(CP_ACP, 0, s, numChars, &c, 1);
  return c;
}
*/

/*
wchar_t * MyStringUpper(wchar_t *s)
{
  if (s == 0)
    return 0;
  wchar_t *res = CharUpperW(s);
  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
    return res;
  AString a = UnicodeStringToMultiByte(s);
  a.MakeUpper();
  MyStringCopy(s, (const wchar_t *)MultiByteToUnicodeString(a));
  return s;
}
*/

/*
wchar_t * MyStringLower(wchar_t *s)
{
  if (s == 0)
    return 0;
  wchar_t *res = CharLowerW(s);
  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
    return res;
  AString a = UnicodeStringToMultiByte(s);
  a.MakeLower();
  MyStringCopy(s, (const wchar_t *)MultiByteToUnicodeString(a));
  return s;
}
*/

#endif

#endif

bool IsString1PrefixedByString2(const char *s1, const char *s2) throw()
{
  for (;;)
  {
    unsigned char c2 = (unsigned char)*s2++; if (c2 == 0) return true;
    unsigned char c1 = (unsigned char)*s1++; if (c1 != c2) return false;
  }
}

bool StringsAreEqualNoCase(const wchar_t *s1, const wchar_t *s2) throw()
{
  for (;;)
  {
    wchar_t c1 = *s1++;
    wchar_t c2 = *s2++;
    if (c1 != c2 && MyCharUpper(c1) != MyCharUpper(c2)) return false;
    if (c1 == 0) return true;
  }
}

// ---------- ASCII ----------

bool AString::IsPrefixedBy_Ascii_NoCase(const char *s) const throw()
{
  const char *s1 = _chars;
  for (;;)
  {
    char c2 = *s++;
    if (c2 == 0)
      return true;
    char c1 = *s1++;
    if (MyCharLower_Ascii(c1) !=
        MyCharLower_Ascii(c2))
      return false;
  }
}

bool UString::IsPrefixedBy_Ascii_NoCase(const char *s) const throw()
{
  const wchar_t *s1 = _chars;
  for (;;)
  {
    char c2 = *s++;
    if (c2 == 0)
      return true;
    wchar_t c1 = *s1++;
    if (MyCharLower_Ascii(c1) != (unsigned char)MyCharLower_Ascii(c2))
      return false;
  }
}

bool StringsAreEqual_Ascii(const wchar_t *u, const char *a) throw()
{
  for (;;)
  {
    unsigned char c = *a;
    if (c != *u)
      return false;
    if (c == 0)
      return true;
    a++;
    u++;
  }
}

bool StringsAreEqualNoCase_Ascii(const char *s1, const char *s2) throw()
{
  for (;;)
  {
    char c1 = *s1++;
    char c2 = *s2++;
    if (c1 != c2 && MyCharLower_Ascii(c1) != MyCharLower_Ascii(c2))
      return false;
    if (c1 == 0)
      return true;
  }
}

bool StringsAreEqualNoCase_Ascii(const wchar_t *s1, const wchar_t *s2) throw()
{
  for (;;)
  {
    wchar_t c1 = *s1++;
    wchar_t c2 = *s2++;
    if (c1 != c2 && MyCharLower_Ascii(c1) != MyCharLower_Ascii(c2))
      return false;
    if (c1 == 0)
      return true;
  }
}

bool StringsAreEqualNoCase_Ascii(const wchar_t *s1, const char *s2) throw()
{
  for (;;)
  {
    wchar_t c1 = *s1++;
    char c2 = *s2++;
    if (c1 != (unsigned char)c2 && (c1 > 0x7F || MyCharLower_Ascii(c1) != (unsigned char)MyCharLower_Ascii(c2)))
      return false;
    if (c1 == 0)
      return true;
  }
}

bool IsString1PrefixedByString2(const wchar_t *s1, const wchar_t *s2) throw()
{
  for (;;)
  {
    wchar_t c2 = *s2++; if (c2 == 0) return true;
    wchar_t c1 = *s1++; if (c1 != c2) return false;
  }
}

bool IsString1PrefixedByString2_NoCase(const wchar_t *s1, const wchar_t *s2) throw()
{
  for (;;)
  {
    wchar_t c2 = *s2++; if (c2 == 0) return true;
    wchar_t c1 = *s1++;
    if (c1 != c2 && MyCharUpper(c1) != MyCharUpper(c2))
      return false;
  }
}

// NTFS order: uses upper case
int MyStringCompareNoCase(const wchar_t *s1, const wchar_t *s2) throw()
{
  for (;;)
  {
    wchar_t c1 = *s1++;
    wchar_t c2 = *s2++;
    if (c1 != c2)
    {
      wchar_t u1 = MyCharUpper(c1);
      wchar_t u2 = MyCharUpper(c2);
      if (u1 < u2) return -1;
      if (u1 > u2) return 1;
    }
    if (c1 == 0) return 0;
  }
}

/*
int MyStringCompareNoCase_N(const wchar_t *s1, const wchar_t *s2, unsigned num)
{
  for (; num != 0; num--)
  {
    wchar_t c1 = *s1++;
    wchar_t c2 = *s2++;
    if (c1 != c2)
    {
      wchar_t u1 = MyCharUpper(c1);
      wchar_t u2 = MyCharUpper(c2);
      if (u1 < u2) return -1;
      if (u1 > u2) return 1;
    }
    if (c1 == 0) return 0;
  }
  return 0;
}
*/

// ---------- AString ----------

void AString::InsertSpace(unsigned &index, unsigned size)
{
  Grow(size);
  MoveItems(index + size, index);
}

#define k_Alloc_Len_Limit 0x40000000

void AString::ReAlloc(unsigned newLimit)
{
  if (newLimit < _len || newLimit >= k_Alloc_Len_Limit) throw 20130220;
  // MY_STRING_REALLOC(_chars, char, newLimit + 1, _len + 1);
  char *newBuf = MY_STRING_NEW(char, newLimit + 1);
  memcpy(newBuf, _chars, (size_t)(_len + 1)); \
  MY_STRING_DELETE(_chars);
  _chars = newBuf;
  _limit = newLimit;
}

void AString::ReAlloc2(unsigned newLimit)
{
  if (newLimit >= k_Alloc_Len_Limit) throw 20130220;
  // MY_STRING_REALLOC(_chars, char, newLimit + 1, 0);
  char *newBuf = MY_STRING_NEW(char, newLimit + 1);
  newBuf[0] = 0;
  MY_STRING_DELETE(_chars);
  _chars = newBuf;
  _limit = newLimit;
}

void AString::SetStartLen(unsigned len)
{
  _chars = 0;
  _chars = MY_STRING_NEW(char, len + 1);
  _len = len;
  _limit = len;
}

void AString::Grow_1()
{
  unsigned next = _len;
  next += next / 2;
  next += 16;
  next &= ~(unsigned)15;
  ReAlloc(next - 1);
}

void AString::Grow(unsigned n)
{
  unsigned freeSize = _limit - _len;
  if (n <= freeSize)
    return;
  
  unsigned next = _len + n;
  next += next / 2;
  next += 16;
  next &= ~(unsigned)15;
  ReAlloc(next - 1);
}

/*
AString::AString(unsigned num, const char *s)
{
  unsigned len = MyStringLen(s);
  if (num > len)
    num = len;
  SetStartLen(num);
  memcpy(_chars, s, num);
  _chars[num] = 0;
}
*/

AString::AString(unsigned num, const AString &s)
{
  if (num > s._len)
    num = s._len;
  SetStartLen(num);
  memcpy(_chars, s._chars, num);
  _chars[num] = 0;
}

AString::AString(const AString &s, char c)
{
  SetStartLen(s.Len() + 1);
  char *chars = _chars;
  unsigned len = s.Len();
  memcpy(chars, s, len);
  chars[len] = c;
  chars[len + 1] = 0;
}

AString::AString(const char *s1, unsigned num1, const char *s2, unsigned num2)
{
  SetStartLen(num1 + num2);
  char *chars = _chars;
  memcpy(chars, s1, num1);
  memcpy(chars + num1, s2, num2 + 1);
}

AString operator+(const AString &s1, const AString &s2) { return AString(s1, s1.Len(), s2, s2.Len()); }
AString operator+(const AString &s1, const char    *s2) { return AString(s1, s1.Len(), s2, MyStringLen(s2)); }
AString operator+(const char    *s1, const AString &s2) { return AString(s1, MyStringLen(s1), s2, s2.Len()); }

AString::AString()
{
  _chars = 0;
  _chars = MY_STRING_NEW(char, 4);
  _len = 0;
  _limit = 4 - 1;
  _chars[0] = 0;
}

AString::AString(char c)
{
  SetStartLen(1);
  _chars[0] = c;
  _chars[1] = 0;
}

AString::AString(const char *s)
{
  SetStartLen(MyStringLen(s));
  MyStringCopy(_chars, s);
}

AString::AString(const AString &s)
{
  SetStartLen(s._len);
  MyStringCopy(_chars, s._chars);
}

AString &AString::operator=(char c)
{
  if (1 > _limit)
  {
    char *newBuf = MY_STRING_NEW(char, 1 + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = 1;
  }
  _len = 1;
  _chars[0] = c;
  _chars[1] = 0;
  return *this;
}

AString &AString::operator=(const char *s)
{
  unsigned len = MyStringLen(s);
  if (len > _limit)
  {
    char *newBuf = MY_STRING_NEW(char, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  _len = len;
  MyStringCopy(_chars, s);
  return *this;
}

AString &AString::operator=(const AString &s)
{
  if (&s == this)
    return *this;
  unsigned len = s._len;
  if (len > _limit)
  {
    char *newBuf = MY_STRING_NEW(char, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  _len = len;
  MyStringCopy(_chars, s._chars);
  return *this;
}

void AString::SetFromWStr_if_Ascii(const wchar_t *s)
{
  unsigned len = 0;
  {
    for (;; len++)
    {
      wchar_t c = s[len];
      if (c == 0)
        break;
      if (c >= 0x80)
        return;
    }
  }
  if (len > _limit)
  {
    char *newBuf = MY_STRING_NEW(char, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  _len = len;
  char *dest = _chars;
  unsigned i;
  for (i = 0; i < len; i++)
    dest[i] = (char)s[i];
  dest[i] = 0;
}

/*
void AString::SetFromBstr_if_Ascii(BSTR s)
{
  unsigned len = ::SysStringLen(s);
  {
    for (unsigned i = 0; i < len; i++)
      if (s[i] <= 0 || s[i] >= 0x80)
        return;
  }
  if (len > _limit)
  {
    char *newBuf = MY_STRING_NEW(char, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  _len = len;
  char *dest = _chars;
  unsigned i;
  for (i = 0; i < len; i++)
    dest[i] = (char)s[i];
  dest[i] = 0;
}
*/

void AString::Add_Space() { operator+=(' '); }
void AString::Add_Space_if_NotEmpty() { if (!IsEmpty()) Add_Space(); }
void AString::Add_LF() { operator+=('\n'); }

AString &AString::operator+=(const char *s)
{
  unsigned len = MyStringLen(s);
  Grow(len);
  MyStringCopy(_chars + _len, s);
  _len += len;
  return *this;
}

AString &AString::operator+=(const AString &s)
{
  Grow(s._len);
  MyStringCopy(_chars + _len, s._chars);
  _len += s._len;
  return *this;
}

void AString::SetFrom(const char *s, unsigned len) // no check
{
  if (len > _limit)
  {
    char *newBuf = MY_STRING_NEW(char, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  if (len != 0)
    memcpy(_chars, s, len);
  _chars[len] = 0;
  _len = len;
}

void AString::SetFrom_CalcLen(const char *s, unsigned len) // no check
{
  unsigned i;
  for (i = 0; i < len; i++)
    if (s[i] == 0)
      break;
  SetFrom(s, i);
}

int AString::Find(const char *s, unsigned startIndex) const throw()
{
  const char *fs = strstr(_chars + startIndex, s);
  if (!fs)
    return -1;
  return (int)(fs - _chars);

  /*
  if (s[0] == 0)
    return startIndex;
  unsigned len = MyStringLen(s);
  const char *p = _chars + startIndex;
  for (;; p++)
  {
    const char c = *p;
    if (c != s[0])
    {
      if (c == 0)
        return -1;
      continue;
    }
    unsigned i;
    for (i = 1; i < len; i++)
      if (p[i] != s[i])
        break;
    if (i == len)
      return (int)(p - _chars);
  }
  */
}

int AString::ReverseFind(char c) const throw()
{
  if (_len == 0)
    return -1;
  const char *p = _chars + _len - 1;
  for (;;)
  {
    if (*p == c)
      return (int)(p - _chars);
    if (p == _chars)
      return -1;
    p--; // p = GetPrevCharPointer(_chars, p);
  }
}

int AString::ReverseFind_PathSepar() const throw()
{
  if (_len == 0)
    return -1;
  const char *p = _chars + _len - 1;
  for (;;)
  {
    char c = *p;
    if (IS_PATH_SEPAR(c))
      return (int)(p - _chars);
    if (p == _chars)
      return -1;
    p--;
  }
}

void AString::TrimLeft() throw()
{
  const char *p = _chars;
  for (;; p++)
  {
    char c = *p;
    if (c != ' ' && c != '\n' && c != '\t')
      break;
  }
  unsigned pos = (unsigned)(p - _chars);
  if (pos != 0)
  {
    MoveItems(0, pos);
    _len -= pos;
  }
}

void AString::TrimRight() throw()
{
  const char *p = _chars;
  unsigned i;
  for (i = _len; i != 0; i--)
  {
    char c = p[i - 1];
    if (c != ' ' && c != '\n' && c != '\t')
      break;
  }
  if (i != _len)
  {
    _chars[i] = 0;
    _len = i;
  }
}

void AString::InsertAtFront(char c)
{
  if (_limit == _len)
    Grow_1();
  MoveItems(1, 0);
  _chars[0] = c;
  _len++;
}

/*
void AString::Insert(unsigned index, char c)
{
  InsertSpace(index, 1);
  _chars[index] = c;
  _len++;
}
*/

void AString::Insert(unsigned index, const char *s)
{
  unsigned num = MyStringLen(s);
  if (num != 0)
  {
    InsertSpace(index, num);
    memcpy(_chars + index, s, num);
    _len += num;
  }
}

void AString::Insert(unsigned index, const AString &s)
{
  unsigned num = s.Len();
  if (num != 0)
  {
    InsertSpace(index, num);
    memcpy(_chars + index, s, num);
    _len += num;
  }
}

void AString::RemoveChar(char ch) throw()
{
  char *src = _chars;
  
  for (;;)
  {
    char c = *src++;
    if (c == 0)
      return;
    if (c == ch)
      break;
  }

  char *dest = src - 1;
  
  for (;;)
  {
    char c = *src++;
    if (c == 0)
      break;
    if (c != ch)
      *dest++ = c;
  }
  
  *dest = 0;
  _len = (unsigned)(dest - _chars);
}

// !!!!!!!!!!!!!!! test it if newChar = '\0'
void AString::Replace(char oldChar, char newChar) throw()
{
  if (oldChar == newChar)
    return; // 0;
  // unsigned number = 0;
  int pos = 0;
  while ((unsigned)pos < _len)
  {
    pos = Find(oldChar, pos);
    if (pos < 0)
      break;
    _chars[(unsigned)pos] = newChar;
    pos++;
    // number++;
  }
  return; //  number;
}

void AString::Replace(const AString &oldString, const AString &newString)
{
  if (oldString.IsEmpty())
    return; // 0;
  if (oldString == newString)
    return; // 0;
  unsigned oldLen = oldString.Len();
  unsigned newLen = newString.Len();
  // unsigned number = 0;
  int pos = 0;
  while ((unsigned)pos < _len)
  {
    pos = Find(oldString, pos);
    if (pos < 0)
      break;
    Delete(pos, oldLen);
    Insert(pos, newString);
    pos += newLen;
    // number++;
  }
  // return number;
}

void AString::Delete(unsigned index) throw()
{
  MoveItems(index, index + 1);
  _len--;
}

void AString::Delete(unsigned index, unsigned count) throw()
{
  if (index + count > _len)
    count = _len - index;
  if (count > 0)
  {
    MoveItems(index, index + count);
    _len -= count;
  }
}

void AString::DeleteFrontal(unsigned num) throw()
{
  if (num != 0)
  {
    MoveItems(0, num);
    _len -= num;
  }
}

/*
AString operator+(const AString &s1, const AString &s2)
{
  AString result(s1);
  result += s2;
  return result;
}

AString operator+(const AString &s, const char *chars)
{
  AString result(s);
  result += chars;
  return result;
}

AString operator+(const char *chars, const AString &s)
{
  AString result(chars);
  result += s;
  return result;
}

AString operator+(const AString &s, char c)
{
  AString result(s);
  result += c;
  return result;
}
*/

/*
AString operator+(char c, const AString &s)
{
  AString result(c);
  result += s;
  return result;
}
*/




// ---------- UString ----------

void UString::InsertSpace(unsigned index, unsigned size)
{
  Grow(size);
  MoveItems(index + size, index);
}

void UString::ReAlloc(unsigned newLimit)
{
  if (newLimit < _len || newLimit >= k_Alloc_Len_Limit) throw 20130221;
  // MY_STRING_REALLOC(_chars, wchar_t, newLimit + 1, _len + 1);
  wchar_t *newBuf = MY_STRING_NEW(wchar_t, newLimit + 1);
  wmemcpy(newBuf, _chars, _len + 1);
  MY_STRING_DELETE(_chars);
  _chars = newBuf;
  _limit = newLimit;
}

void UString::ReAlloc2(unsigned newLimit)
{
  if (newLimit >= k_Alloc_Len_Limit) throw 20130221;
  // MY_STRING_REALLOC(_chars, wchar_t, newLimit + 1, 0);
  wchar_t *newBuf = MY_STRING_NEW(wchar_t, newLimit + 1);
  newBuf[0] = 0;
  MY_STRING_DELETE(_chars);
  _chars = newBuf;
  _limit = newLimit;
}

void UString::SetStartLen(unsigned len)
{
  _chars = 0;
  _chars = MY_STRING_NEW(wchar_t, len + 1);
  _len = len;
  _limit = len;
}

void UString::Grow_1()
{
  unsigned next = _len;
  next += next / 2;
  next += 16;
  next &= ~(unsigned)15;
  ReAlloc(next - 1);
}

void UString::Grow(unsigned n)
{
  unsigned freeSize = _limit - _len;
  if (n <= freeSize)
    return;
  
  unsigned next = _len + n;
  next += next / 2;
  next += 16;
  next &= ~(unsigned)15;
  ReAlloc(next - 1);
}


UString::UString(unsigned num, const wchar_t *s)
{
  unsigned len = MyStringLen(s);
  if (num > len)
    num = len;
  SetStartLen(num);
  wmemcpy(_chars, s, num);
  _chars[num] = 0;
}


UString::UString(unsigned num, const UString &s)
{
  if (num > s._len)
    num = s._len;
  SetStartLen(num);
  wmemcpy(_chars, s._chars, num);
  _chars[num] = 0;
}

UString::UString(const UString &s, wchar_t c)
{
  SetStartLen(s.Len() + 1);
  wchar_t *chars = _chars;
  unsigned len = s.Len();
  wmemcpy(chars, s, len);
  chars[len] = c;
  chars[len + 1] = 0;
}

UString::UString(const wchar_t *s1, unsigned num1, const wchar_t *s2, unsigned num2)
{
  SetStartLen(num1 + num2);
  wchar_t *chars = _chars;
  wmemcpy(chars, s1, num1);
  wmemcpy(chars + num1, s2, num2 + 1);
}

UString operator+(const UString &s1, const UString &s2) { return UString(s1, s1.Len(), s2, s2.Len()); }
UString operator+(const UString &s1, const wchar_t *s2) { return UString(s1, s1.Len(), s2, MyStringLen(s2)); }
UString operator+(const wchar_t *s1, const UString &s2) { return UString(s1, MyStringLen(s1), s2, s2.Len()); }

UString::UString()
{
  _chars = 0;
  _chars = MY_STRING_NEW(wchar_t, 4);
  _len = 0;
  _limit = 4 - 1;
  _chars[0] = 0;
}

UString::UString(wchar_t c)
{
  SetStartLen(1);
  _chars[0] = c;
  _chars[1] = 0;
}

UString::UString(const wchar_t *s)
{
  unsigned len = MyStringLen(s);
  SetStartLen(len);
  wmemcpy(_chars, s, len + 1);
}

UString::UString(const UString &s)
{
  SetStartLen(s._len);
  wmemcpy(_chars, s._chars, s._len + 1);
}

UString &UString::operator=(wchar_t c)
{
  if (1 > _limit)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, 1 + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = 1;
  }
  _len = 1;
  _chars[0] = c;
  _chars[1] = 0;
  return *this;
}

UString &UString::operator=(const wchar_t *s)
{
  unsigned len = MyStringLen(s);
  if (len > _limit)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  _len = len;
  wmemcpy(_chars, s, len + 1);
  return *this;
}

UString &UString::operator=(const UString &s)
{
  if (&s == this)
    return *this;
  unsigned len = s._len;
  if (len > _limit)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  _len = len;
  wmemcpy(_chars, s._chars, len + 1);
  return *this;
}

void UString::SetFromBstr(BSTR s)
{
  unsigned len = ::SysStringLen(s);
  if (len > _limit)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  _len = len;
  // if (s)
    wmemcpy(_chars, s, len + 1);
}

void UString::Add_Space() { operator+=(L' '); }
void UString::Add_Space_if_NotEmpty() { if (!IsEmpty()) Add_Space(); }

void UString::Add_LF()
{
  if (_limit == _len)
    Grow_1();
  unsigned len = _len;
  wchar_t *chars = _chars;
  chars[len++] = L'\n';
  chars[len] = 0;
  _len = len;
}

UString &UString::operator+=(const wchar_t *s)
{
  unsigned len = MyStringLen(s);
  Grow(len);
  wmemcpy(_chars + _len, s, len + 1);
  _len += len;
  return *this;
}

UString &UString::operator+=(const UString &s)
{
  Grow(s._len);
  wmemcpy(_chars + _len, s._chars, s._len + 1);
  _len += s._len;
  return *this;
}

void UString::SetFrom(const wchar_t *s, unsigned len) // no check
{
  if (len > _limit)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  if (len != 0)
    wmemcpy(_chars, s, len);
  _chars[len] = 0;
  _len = len;
}

void UString::SetFromAscii(const char *s)
{
  unsigned len = MyStringLen(s);
  if (len > _limit)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, len + 1);
    MY_STRING_DELETE(_chars);
    _chars = newBuf;
    _limit = len;
  }
  wchar_t *chars = _chars;
  for (unsigned i = 0; i < len; i++)
    chars[i] = (unsigned char)s[i];
  chars[len] = 0;
  _len = len;
}

void UString::AddAscii(const char *s)
{
  unsigned len = MyStringLen(s);
  Grow(len);
  wchar_t *chars = _chars + _len;
  for (unsigned i = 0; i < len; i++)
    chars[i] = (unsigned char)s[i];
  chars[len] = 0;
  _len += len;
}



int UString::Find(const wchar_t *s, unsigned startIndex) const throw()
{
  const wchar_t *fs = wcsstr(_chars + startIndex, s);
  if (!fs)
    return -1;
  return (int)(fs - _chars);

  /*
  if (s[0] == 0)
    return startIndex;
  unsigned len = MyStringLen(s);
  const wchar_t *p = _chars + startIndex;
  for (;; p++)
  {
    const wchar_t c = *p;
    if (c != s[0])
    {
      if (c == 0)
        return -1;
      continue;
    }
    unsigned i;
    for (i = 1; i < len; i++)
      if (p[i] != s[i])
        break;
    if (i == len)
      return (int)(p - _chars);
  }
  */
}

int UString::ReverseFind(wchar_t c) const throw()
{
  if (_len == 0)
    return -1;
  const wchar_t *p = _chars + _len - 1;
  for (;;)
  {
    if (*p == c)
      return (int)(p - _chars);
    if (p == _chars)
      return -1;
    p--;
  }
}

int UString::ReverseFind_PathSepar() const throw()
{
  if (_len == 0)
    return -1;
  const wchar_t *p = _chars + _len - 1;
  for (;;)
  {
    wchar_t c = *p;
    if (IS_PATH_SEPAR(c))
      return (int)(p - _chars);
    if (p == _chars)
      return -1;
    p--;
  }
}

void UString::TrimLeft() throw()
{
  const wchar_t *p = _chars;
  for (;; p++)
  {
    wchar_t c = *p;
    if (c != ' ' && c != '\n' && c != '\t')
      break;
  }
  unsigned pos = (unsigned)(p - _chars);
  if (pos != 0)
  {
    MoveItems(0, pos);
    _len -= pos;
  }
}

void UString::TrimRight() throw()
{
  const wchar_t *p = _chars;
  unsigned i;
  for (i = _len; i != 0; i--)
  {
    wchar_t c = p[i - 1];
    if (c != ' ' && c != '\n' && c != '\t')
      break;
  }
  if (i != _len)
  {
    _chars[i] = 0;
    _len = i;
  }
}

void UString::InsertAtFront(wchar_t c)
{
  if (_limit == _len)
    Grow_1();
  MoveItems(1, 0);
  _chars[0] = c;
  _len++;
}

/*
void UString::Insert(unsigned index, wchar_t c)
{
  InsertSpace(index, 1);
  _chars[index] = c;
  _len++;
}
*/

void UString::Insert(unsigned index, const wchar_t *s)
{
  unsigned num = MyStringLen(s);
  if (num != 0)
  {
    InsertSpace(index, num);
    wmemcpy(_chars + index, s, num);
    _len += num;
  }
}

void UString::Insert(unsigned index, const UString &s)
{
  unsigned num = s.Len();
  if (num != 0)
  {
    InsertSpace(index, num);
    wmemcpy(_chars + index, s, num);
    _len += num;
  }
}

void UString::RemoveChar(wchar_t ch) throw()
{
  wchar_t *src = _chars;
  
  for (;;)
  {
    wchar_t c = *src++;
    if (c == 0)
      return;
    if (c == ch)
      break;
  }

  wchar_t *dest = src - 1;
  
  for (;;)
  {
    wchar_t c = *src++;
    if (c == 0)
      break;
    if (c != ch)
      *dest++ = c;
  }
  
  *dest = 0;
  _len = (unsigned)(dest - _chars);
}

// !!!!!!!!!!!!!!! test it if newChar = '\0'
void UString::Replace(wchar_t oldChar, wchar_t newChar) throw()
{
  if (oldChar == newChar)
    return; // 0;
  // unsigned number = 0;
  int pos = 0;
  while ((unsigned)pos < _len)
  {
    pos = Find(oldChar, pos);
    if (pos < 0)
      break;
    _chars[(unsigned)pos] = newChar;
    pos++;
    // number++;
  }
  return; //  number;
}

void UString::Replace(const UString &oldString, const UString &newString)
{
  if (oldString.IsEmpty())
    return; // 0;
  if (oldString == newString)
    return; // 0;
  unsigned oldLen = oldString.Len();
  unsigned newLen = newString.Len();
  // unsigned number = 0;
  int pos = 0;
  while ((unsigned)pos < _len)
  {
    pos = Find(oldString, pos);
    if (pos < 0)
      break;
    Delete(pos, oldLen);
    Insert(pos, newString);
    pos += newLen;
    // number++;
  }
  // return number;
}

void UString::Delete(unsigned index) throw()
{
  MoveItems(index, index + 1);
  _len--;
}

void UString::Delete(unsigned index, unsigned count) throw()
{
  if (index + count > _len)
    count = _len - index;
  if (count > 0)
  {
    MoveItems(index, index + count);
    _len -= count;
  }
}

void UString::DeleteFrontal(unsigned num) throw()
{
  if (num != 0)
  {
    MoveItems(0, num);
    _len -= num;
  }
}


// ---------- UString2 ----------

void UString2::ReAlloc2(unsigned newLimit)
{
  if (newLimit >= k_Alloc_Len_Limit) throw 20130221;
  // MY_STRING_REALLOC(_chars, wchar_t, newLimit + 1, 0);
  _chars = MY_STRING_NEW(wchar_t, newLimit + 1);
}

void UString2::SetStartLen(unsigned len)
{
  _chars = 0;
  _chars = MY_STRING_NEW(wchar_t, len + 1);
  _len = len;
}


/*
UString2::UString2(wchar_t c)
{
  SetStartLen(1);
  _chars[0] = c;
  _chars[1] = 0;
}
*/

UString2::UString2(const wchar_t *s)
{
  unsigned len = MyStringLen(s);
  SetStartLen(len);
  wmemcpy(_chars, s, len + 1);
}

UString2::UString2(const UString2 &s): _chars(NULL), _len(0)
{
  if (s._chars)
  {
    SetStartLen(s._len);
    wmemcpy(_chars, s._chars, s._len + 1);
  }
}

/*
UString2 &UString2::operator=(wchar_t c)
{
  if (1 > _len)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, 1 + 1);
    if (_chars)
      MY_STRING_DELETE(_chars);
    _chars = newBuf;
  }
  _len = 1;
  _chars[0] = c;
  _chars[1] = 0;
  return *this;
}
*/

UString2 &UString2::operator=(const wchar_t *s)
{
  unsigned len = MyStringLen(s);
  if (len > _len)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, len + 1);
    if (_chars)
      MY_STRING_DELETE(_chars);
    _chars = newBuf;
  }
  _len = len;
  MyStringCopy(_chars, s);
  return *this;
}

void UString2::SetFromAscii(const char *s)
{
  unsigned len = MyStringLen(s);
  if (len > _len)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, len + 1);
    if (_chars)
      MY_STRING_DELETE(_chars);
    _chars = newBuf;
  }
  wchar_t *chars = _chars;
  for (unsigned i = 0; i < len; i++)
    chars[i] = (unsigned char)s[i];
  chars[len] = 0;
  _len = len;
}

UString2 &UString2::operator=(const UString2 &s)
{
  if (&s == this)
    return *this;
  unsigned len = s._len;
  if (len > _len)
  {
    wchar_t *newBuf = MY_STRING_NEW(wchar_t, len + 1);
    if (_chars)
      MY_STRING_DELETE(_chars);
    _chars = newBuf;
  }
  _len = len;
  MyStringCopy(_chars, s._chars);
  return *this;
}

bool operator==(const UString2 &s1, const UString2 &s2)
{
  return s1.Len() == s2.Len() && (s1.IsEmpty() || wcscmp(s1.GetRawPtr(), s2.GetRawPtr()) == 0);
}

bool operator==(const UString2 &s1, const wchar_t *s2)
{
  if (s1.IsEmpty())
    return (*s2 == 0);
  return wcscmp(s1.GetRawPtr(), s2) == 0;
}

bool operator==(const wchar_t *s1, const UString2 &s2)
{
  if (s2.IsEmpty())
    return (*s1 == 0);
  return wcscmp(s1, s2.GetRawPtr()) == 0;
}



// ----------------------------------------

/*
int MyStringCompareNoCase(const char *s1, const char *s2)
{
  return MyStringCompareNoCase(MultiByteToUnicodeString(s1), MultiByteToUnicodeString(s2));
}
*/

static inline UINT GetCurrentCodePage()
{
  #if defined(UNDER_CE) || !defined(_WIN32)
  return CP_ACP;
  #else
  return ::AreFileApisANSI() ? CP_ACP : CP_OEMCP;
  #endif
}

#ifdef USE_UNICODE_FSTRING

#ifndef _UNICODE

AString fs2fas(CFSTR s)
{
  return UnicodeStringToMultiByte(s, GetCurrentCodePage());
}

FString fas2fs(const AString &s)
{
  return MultiByteToUnicodeString(s, GetCurrentCodePage());
}

#endif

#else

UString fs2us(const FString &s)
{
  return MultiByteToUnicodeString((AString)s, GetCurrentCodePage());
}

FString us2fs(const wchar_t *s)
{
  return UnicodeStringToMultiByte(s, GetCurrentCodePage());
}

#endif



#ifndef ENV_HAVE_WCTYPE_H
// FIXME

wchar_t *wmemcpy(wchar_t * d, const wchar_t * s, size_t n)
{
	wchar_t *a = d;
	while (n--) *d++ = *s++;
	return a;
}

int wmemcmp(const wchar_t *l, const wchar_t *r, size_t n)
{
	for (; n && *l==*r; n--, l++, r++);
	return n ? (*l-*r) : 0;
}

wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n)
{
	for (; n && *s != c; n--, s++);
	return n ? (wchar_t *)s : 0;
}

int wcscmp(const wchar_t *l, const wchar_t *r)
{
	for (; *l==*r && *l && *r; l++, r++);
	return *l - *r;
}

size_t wcslen(const wchar_t *s)
{
	const wchar_t *a;
	for (a=s; *s; s++);
	return s-a;
}

wchar_t *wcschr(const wchar_t *s, wchar_t c)
{
	if (!c) return (wchar_t *)s + wcslen(s);
	for (; *s && *s != c; s++);
	return *s ? (wchar_t *)s : 0;
}

#undef MAX
#define MAX(a,b) ((a)>(b)?(a):(b))
#undef MIN
#define MIN(a,b) ((a)<(b)?(a):(b))

static wchar_t *twoway_wcsstr(const wchar_t *h, const wchar_t *n)
{
	const wchar_t *z;
	size_t l, ip, jp, k, p, ms, p0, mem, mem0;

	/* Computing length of needle */
	for (l=0; n[l] && h[l]; l++);
	if (n[l]) return 0; /* hit the end of h */

	/* Compute maximal suffix */
	ip = -1; jp = 0; k = p = 1;
	while (jp+k<l) {
		if (n[ip+k] == n[jp+k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else k++;
		} else if (n[ip+k] > n[jp+k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	ms = ip;
	p0 = p;

	/* And with the opposite comparison */
	ip = -1; jp = 0; k = p = 1;
	while (jp+k<l) {
		if (n[ip+k] == n[jp+k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else k++;
		} else if (n[ip+k] < n[jp+k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	if (ip+1 > ms+1) ms = ip;
	else p = p0;

	/* Periodic needle? */
	if (wmemcmp(n, n+p, ms+1)) {
		mem0 = 0;
		p = MAX(ms, l-ms-1) + 1;
	} else mem0 = l-p;
	mem = 0;

	/* Initialize incremental end-of-haystack pointer */
	z = h;

	/* Search loop */
	for (;;) {
		/* Update incremental end-of-haystack pointer */
		if (z-h < l) {
			/* Fast estimate for MIN(l,63) */
			size_t grow = l | 63;
			const wchar_t *z2 = wmemchr(z, 0, grow);
			if (z2) {
				z = z2;
				if (z-h < l) return 0;
			} else z += grow;
		}

		/* Compare right half */
		for (k=MAX(ms+1,mem); n[k] && n[k] == h[k]; k++);
		if (n[k]) {
			h += k-ms;
			mem = 0;
			continue;
		}
		/* Compare left half */
		for (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);
		if (k <= mem) return (wchar_t *)h;
		h += p;
		mem = mem0;
	}
}

wchar_t *wcsstr(const wchar_t * h, const wchar_t * n)
{
	/* Return immediately on empty needle or haystack */
	if (!n[0]) return (wchar_t *)h;
	if (!h[0]) return 0;

	/* Use faster algorithms for short needles */
	h = wcschr(h, *n);
	if (!h || !n[1]) return (wchar_t *)h;
	if (!h[1]) return 0;

	return twoway_wcsstr(h, n);
}

#if defined(__DJGPP__)
wchar_t *wcscpy(wchar_t * d, const wchar_t * s)
{
	wchar_t *a = d;
	while ((*d++ = *s++));
	return a;
}

wchar_t *wcscat(wchar_t *dest, const wchar_t * src)
{
	wcscpy(dest + wcslen(dest), src);
	return dest;
}

#endif

#endif
// Common/String.h

#ifndef __COMMON_STRING_H
#define __COMMON_STRING_H

#include <string.h>

#ifdef ENV_HAVE_WCHAR__H
#include <wchar.h>
#endif

#ifdef ENV_HAVE_WCTYPE_H
#include <wctype.h>
#else
#define towupper(c) (c)  // FIXME
int wcscmp(const wchar_t *s1, const wchar_t *s2);
wchar_t * wmemcpy(wchar_t *dest, const wchar_t *src, size_t num);
wchar_t * wcsstr(const wchar_t *wcs1, const wchar_t *wcs2);
#endif

#include "MyWindows.h"
#include "MyTypes.h"
#include "MyVector.h"

#ifdef _WIN32
#define IS_PATH_SEPAR(c) ((c) == '\\' || (c) == '/')
#else
#define IS_PATH_SEPAR(c) ((c) == CHAR_PATH_SEPARATOR)
#endif

inline bool IsPathSepar(char    c) { return IS_PATH_SEPAR(c); }
inline bool IsPathSepar(wchar_t c) { return IS_PATH_SEPAR(c); }

inline unsigned MyStringLen(const char *s)
{
  unsigned i;
  for (i = 0; s[i] != 0; i++);
  return i;
}

inline void MyStringCopy(char *dest, const char *src)
{
  while ((*dest++ = *src++) != 0);
}

inline char *MyStpCpy(char *dest, const char *src)
{
  for (;;)
  {
    char c = *src;
    *dest = c;
    if (c == 0)
      return dest;
    src++;
    dest++;
  }
}

inline unsigned MyStringLen(const wchar_t *s)
{
  unsigned i;
  for (i = 0; s[i] != 0; i++);
  return i;
}

inline void MyStringCopy(wchar_t *dest, const wchar_t *src)
{
  while ((*dest++ = *src++) != 0);
}

/*
inline wchar_t *MyWcpCpy(wchar_t *dest, const wchar_t *src)
{
  for (;;)
  {
    wchar_t c = *src;
    *dest = c;
    if (c == 0)
      return dest;
    src++;
    dest++;
  }
}
*/

int FindCharPosInString(const char *s, char c) throw();
int FindCharPosInString(const wchar_t *s, wchar_t c) throw();

#ifdef _WIN32
  #ifndef _UNICODE
    #define STRING_UNICODE_THROW
  #endif
#endif

#ifndef STRING_UNICODE_THROW
  #define STRING_UNICODE_THROW throw()
#endif

/*
inline char MyCharUpper_Ascii(char c)
{
  if (c >= 'a' && c <= 'z')
    return (char)(c - 0x20);
  return c;
}
inline wchar_t MyCharUpper_Ascii(wchar_t c)
{
  if (c >= 'a' && c <= 'z')
    return (wchar_t)(c - 0x20);
  return c;
}
*/

inline char MyCharLower_Ascii(char c)
{
  if (c >= 'A' && c <= 'Z')
    return (char)((unsigned char)c + 0x20);
  return c;
}

inline wchar_t MyCharLower_Ascii(wchar_t c)
{
  if (c >= 'A' && c <= 'Z')
    return (wchar_t)(c + 0x20);
  return c;
}

wchar_t MyCharUpper_WIN(wchar_t c) throw();

inline wchar_t MyCharUpper(wchar_t c) throw()
{
  if (c < 'a') return c;
  if (c <= 'z') return (wchar_t)(c - 0x20);
  if (c <= 0x7F) return c;
  #ifdef _WIN32
    #ifdef _UNICODE
      return (wchar_t)(unsigned)(UINT_PTR)CharUpperW((LPWSTR)(UINT_PTR)(unsigned)c);
    #else
      return (wchar_t)MyCharUpper_WIN(c);
    #endif
  #else
    return (wchar_t)towupper(c);
  #endif
}

/*
wchar_t MyCharLower_WIN(wchar_t c) throw();

inline wchar_t MyCharLower(wchar_t c) throw()
{
  if (c < 'A') return c;
  if (c <= 'Z') return (wchar_t)(c + 0x20);
  if (c <= 0x7F) return c;
  #ifdef _WIN32
    #ifdef _UNICODE
      return (wchar_t)(unsigned)(UINT_PTR)CharLowerW((LPWSTR)(UINT_PTR)(unsigned)c);
    #else
      return (wchar_t)MyCharLower_WIN(c);
    #endif
  #else
    return (wchar_t)tolower(c);
  #endif
}
*/

// char *MyStringUpper(char *s) throw();
// char *MyStringLower(char *s) throw();

// void MyStringUpper_Ascii(wchar_t *s) throw();
void MyStringLower_Ascii(char *s) throw();
void MyStringLower_Ascii(wchar_t *s) throw();
// wchar_t *MyStringUpper(wchar_t *s) STRING_UNICODE_THROW;
// wchar_t *MyStringLower(wchar_t *s) STRING_UNICODE_THROW;

bool StringsAreEqualNoCase(const wchar_t *s1, const wchar_t *s2) throw();

bool IsString1PrefixedByString2(const char *s1, const char *s2) throw();
bool IsString1PrefixedByString2(const wchar_t *s1, const wchar_t *s2) throw();
bool IsString1PrefixedByString2_NoCase(const wchar_t *s1, const wchar_t *s2) throw();

int MyStringCompareNoCase(const wchar_t *s1, const wchar_t *s2) throw();
// int MyStringCompareNoCase_N(const wchar_t *s1, const wchar_t *s2, unsigned num) throw();

// ---------- ASCII ----------
// char values in ASCII strings must be less then 128
bool StringsAreEqual_Ascii(const wchar_t *u, const char *a) throw();
bool StringsAreEqualNoCase_Ascii(const char *s1, const char *s2) throw();
bool StringsAreEqualNoCase_Ascii(const wchar_t *s1, const char *s2) throw();
bool StringsAreEqualNoCase_Ascii(const wchar_t *s1, const wchar_t *s2) throw();

#define MY_STRING_DELETE(_p_) delete []_p_;
// #define MY_STRING_DELETE(_p_) my_delete(_p_);

class AString
{
  char *_chars;
  unsigned _len;
  unsigned _limit;

  void MoveItems(unsigned dest, unsigned src)
  {
    memmove(_chars + dest, _chars + src, (size_t)(_len - src + 1) * sizeof(char));
  }
  
  void InsertSpace(unsigned &index, unsigned size);
  
  void ReAlloc(unsigned newLimit);
  void ReAlloc2(unsigned newLimit);
  void SetStartLen(unsigned len);
  void Grow_1();
  void Grow(unsigned n);

  // AString(unsigned num, const char *s);
  AString(unsigned num, const AString &s);
  AString(const AString &s, char c); // it's for String + char
  AString(const char *s1, unsigned num1, const char *s2, unsigned num2);

  friend AString operator+(const AString &s, char c) { return AString(s, c); } ;
  // friend AString operator+(char c, const AString &s); // is not supported

  friend AString operator+(const AString &s1, const AString &s2);
  friend AString operator+(const AString &s1, const char    *s2);
  friend AString operator+(const char    *s1, const AString &s2);

  // ---------- forbidden functions ----------
  AString &operator+=(wchar_t c);
  AString &operator=(wchar_t c);
  AString(wchar_t c);
  void Find(wchar_t c) const;
  void Find(wchar_t c, unsigned startIndex) const;
  void ReverseFind(wchar_t c) const;
  void InsertAtFront(wchar_t c);
  void RemoveChar(wchar_t ch);
  void Replace(wchar_t oldChar, wchar_t newChar);

public:
  AString();
  AString(char c);
  AString(const char *s);
  AString(const AString &s);
  ~AString() { MY_STRING_DELETE(_chars); }

  unsigned Len() const { return _len; }
  bool IsEmpty() const { return _len == 0; }
  void Empty() { _len = 0; _chars[0] = 0; }

  operator const char *() const { return _chars; }
  const char *Ptr() const { return _chars; }
  const char *Ptr(unsigned pos) const { return _chars + pos; }
  const char *RightPtr(unsigned num) const { return _chars + _len - num; }
  char Back() const { return _chars[_len - 1]; }

  void ReplaceOneCharAtPos(unsigned pos, char c) { _chars[pos] = c; }

  /* GetBuf(minLen): provides the buffer that can store
     at least (minLen) characters and additional null terminator.
     9.35: GetBuf doesn't preserve old characters and terminator */
  char *GetBuf(unsigned minLen)
  {
    if (minLen > _limit)
      ReAlloc2(minLen);
    return _chars;
  }
  char *GetBuf_SetEnd(unsigned minLen)
  {
    if (minLen > _limit)
      ReAlloc2(minLen);
    char *chars = _chars;
    chars[minLen] = 0;
    _len = minLen;
    return chars;
  }

  void ReleaseBuf_SetLen(unsigned newLen) { _len = newLen; }
  void ReleaseBuf_SetEnd(unsigned newLen) { _len = newLen; _chars[newLen] = 0; }
  void ReleaseBuf_CalcLen(unsigned maxLen)
  {
    char *chars = _chars;
    chars[maxLen] = 0;
    _len = MyStringLen(chars);
  }

  AString &operator=(char c);
  AString &operator=(const char *s);
  AString &operator=(const AString &s);
  void SetFromWStr_if_Ascii(const wchar_t *s);
  // void SetFromBstr_if_Ascii(BSTR s);

  AString &operator+=(char c)
  {
    if (_limit == _len)
      Grow_1();
    unsigned len = _len;
    char *chars = _chars;
    chars[len++] = c;
    chars[len] = 0;
    _len = len;
    return *this;
  }
  
  void Add_Space();
  void Add_Space_if_NotEmpty();
  void Add_LF();
  void Add_PathSepar() { operator+=(CHAR_PATH_SEPARATOR); }

  AString &operator+=(const char *s);
  AString &operator+=(const AString &s);
  void AddAscii(const char *s) { operator+=(s); }

  void SetFrom(const char *s, unsigned len); // no check
  void SetFrom_CalcLen(const char *s, unsigned len);
  // void SetFromAscii(const char *s) { operator+=(s); }

  AString Mid(unsigned startIndex, unsigned count) const { return AString(count, _chars + startIndex); }
  AString Left(unsigned count) const { return AString(count, *this); }

  // void MakeUpper() { MyStringUpper(_chars); }
  // void MakeLower() { MyStringLower(_chars); }
  void MakeLower_Ascii() { MyStringLower_Ascii(_chars); }


  bool IsEqualTo(const char *s) const { return strcmp(_chars, s) == 0; }
  bool IsEqualTo_Ascii_NoCase(const char *s) const { return StringsAreEqualNoCase_Ascii(_chars, s); }
  // int Compare(const char *s) const { return MyStringCompare(_chars, s); }
  // int Compare(const AString &s) const { return MyStringCompare(_chars, s._chars); }
  // int CompareNoCase(const char *s) const { return MyStringCompareNoCase(_chars, s); }
  // int CompareNoCase(const AString &s) const { return MyStringCompareNoCase(_chars, s._chars); }
  bool IsPrefixedBy(const char *s) const { return IsString1PrefixedByString2(_chars, s); }
  bool IsPrefixedBy_Ascii_NoCase(const char *s) const throw();
 
  bool IsAscii() const
  {
    unsigned len = Len();
    const char *s = _chars;
    for (unsigned i = 0; i < len; i++)
      if ((unsigned char)s[i] >= 0x80)
        return false;
    return true;
  }
  int Find(char c) const { return FindCharPosInString(_chars, c); }
  int Find(char c, unsigned startIndex) const
  {
    int pos = FindCharPosInString(_chars + startIndex, c);
    return pos < 0 ? -1 : (int)startIndex + pos;
  }
  
  int ReverseFind(char c) const throw();
  int ReverseFind_Dot() const throw() { return ReverseFind('.'); }
  int ReverseFind_PathSepar() const throw();

  int Find(const char *s) const { return Find(s, 0); }
  int Find(const char *s, unsigned startIndex) const throw();
  
  void TrimLeft() throw();
  void TrimRight() throw();
  void Trim()
  {
    TrimRight();
    TrimLeft();
  }

  void InsertAtFront(char c);
  // void Insert(unsigned index, char c);
  void Insert(unsigned index, const char *s);
  void Insert(unsigned index, const AString &s);

  void RemoveChar(char ch) throw();
  
  void Replace(char oldChar, char newChar) throw();
  void Replace(const AString &oldString, const AString &newString);

  void Delete(unsigned index) throw();
  void Delete(unsigned index, unsigned count) throw();
  void DeleteFrontal(unsigned num) throw();
  void DeleteBack() { _chars[--_len] = 0; }
  void DeleteFrom(unsigned index)
  {
    if (index < _len)
    {
      _len = index;
      _chars[index] = 0;
    }
  }
};

bool operator<(const AString &s1, const AString &s2);
bool operator>(const AString &s1, const AString &s2);

/*
bool operator==(const AString &s1, const AString &s2);
bool operator==(const AString &s1, const char    *s2);
bool operator==(const char    *s1, const AString &s2);

bool operator!=(const AString &s1, const AString &s2);
bool operator!=(const AString &s1, const char    *s2);
bool operator!=(const char    *s1, const AString &s2);
*/

inline bool operator==(const AString &s1, const AString &s2) { return s1.Len() == s2.Len() && strcmp(s1, s2) == 0; }
inline bool operator==(const AString &s1, const char    *s2) { return strcmp(s1, s2) == 0; }
inline bool operator==(const char    *s1, const AString &s2) { return strcmp(s1, s2) == 0; }

inline bool operator!=(const AString &s1, const AString &s2) { return s1.Len() != s2.Len() || strcmp(s1, s2) != 0; }
inline bool operator!=(const AString &s1, const char    *s2) { return strcmp(s1, s2) != 0; }
inline bool operator!=(const char    *s1, const AString &s2) { return strcmp(s1, s2) != 0; }

// ---------- forbidden functions ----------

void operator==(char c1, const AString &s2);
void operator==(const AString &s1, char c2);

void operator+(char c, const AString &s); // this function can be OK, but we don't use it

void operator+(const AString &s, int c);
void operator+(const AString &s, unsigned c);
void operator+(int c, const AString &s);
void operator+(unsigned c, const AString &s);
void operator-(const AString &s, int c);
void operator-(const AString &s, unsigned c);


class UString
{
  wchar_t *_chars;
  unsigned _len;
  unsigned _limit;

  void MoveItems(unsigned dest, unsigned src)
  {
    memmove(_chars + dest, _chars + src, (size_t)(_len - src + 1) * sizeof(wchar_t));
  }
  
  void InsertSpace(unsigned index, unsigned size);
  
  void ReAlloc(unsigned newLimit);
  void ReAlloc2(unsigned newLimit);
  void SetStartLen(unsigned len);
  void Grow_1();
  void Grow(unsigned n);

  UString(unsigned num, const wchar_t *s); // for Mid
  UString(unsigned num, const UString &s); // for Left
  UString(const UString &s, wchar_t c); // it's for String + char
  UString(const wchar_t *s1, unsigned num1, const wchar_t *s2, unsigned num2);

  friend UString operator+(const UString &s, wchar_t c) { return UString(s, c); } ;
  // friend UString operator+(wchar_t c, const UString &s); // is not supported

  friend UString operator+(const UString &s1, const UString &s2);
  friend UString operator+(const UString &s1, const wchar_t *s2);
  friend UString operator+(const wchar_t *s1, const UString &s2);

  // ---------- forbidden functions ----------
  
  UString &operator+=(char c);
  UString &operator+=(unsigned char c);
  UString &operator=(char c);
  UString &operator=(unsigned char c);
  UString(char c);
  UString(unsigned char c);
  void Find(char c) const;
  void Find(unsigned char c) const;
  void Find(char c, unsigned startIndex) const;
  void Find(unsigned char c, unsigned startIndex) const;
  void ReverseFind(char c) const;
  void ReverseFind(unsigned char c) const;
  void InsertAtFront(char c);
  void InsertAtFront(unsigned char c);
  void RemoveChar(char ch);
  void RemoveChar(unsigned char ch);
  void Replace(char oldChar, char newChar);
  void Replace(unsigned char oldChar, unsigned char newChar);

public:
  UString();
  UString(wchar_t c);
  UString(const wchar_t *s);
  UString(const UString &s);
  ~UString() { MY_STRING_DELETE(_chars); }

  unsigned Len() const { return _len; }
  bool IsEmpty() const { return _len == 0; }
  void Empty() { _len = 0; _chars[0] = 0; }

  operator const wchar_t *() const { return _chars; }
  const wchar_t *Ptr() const { return _chars; }
  const wchar_t *Ptr(unsigned pos) const { return _chars + pos; }
  const wchar_t *RightPtr(unsigned num) const { return _chars + _len - num; }
  wchar_t Back() const { return _chars[_len - 1]; }

  void ReplaceOneCharAtPos(unsigned pos, wchar_t c) { _chars[pos] = c; }

  wchar_t *GetBuf(unsigned minLen)
  {
    if (minLen > _limit)
      ReAlloc2(minLen);
    return _chars;
  }
  wchar_t *GetBuf_SetEnd(unsigned minLen)
  {
    if (minLen > _limit)
      ReAlloc2(minLen);
    wchar_t *chars = _chars;
    chars[minLen] = 0;
    _len = minLen;
    return chars;
  }

  void ReleaseBuf_SetLen(unsigned newLen) { _len = newLen; }
  void ReleaseBuf_SetEnd(unsigned newLen) { _len = newLen; _chars[newLen] = 0; }
  void ReleaseBuf_CalcLen(unsigned maxLen)
  {
    wchar_t *chars = _chars;
    chars[maxLen] = 0;
    _len = MyStringLen(chars);
  }

  UString &operator=(wchar_t c);
  UString &operator=(const wchar_t *s);
  UString &operator=(const UString &s);
  void SetFromBstr(BSTR s);

  UString &operator+=(wchar_t c)
  {
    if (_limit == _len)
      Grow_1();
    unsigned len = _len;
    wchar_t *chars = _chars;
    chars[len++] = c;
    chars[len] = 0;
    _len = len;
    return *this;
  }

  void Add_Space();
  void Add_Space_if_NotEmpty();
  void Add_LF();
  void Add_PathSepar() { operator+=(WCHAR_PATH_SEPARATOR); }

  UString &operator+=(const wchar_t *s);
  UString &operator+=(const UString &s);

  void SetFrom(const wchar_t *s, unsigned len); // no check

  void SetFromAscii(const char *s);
  void AddAscii(const char *s);

  UString Mid(unsigned startIndex, unsigned count) const { return UString(count, _chars + startIndex); }
  UString Left(unsigned count) const { return UString(count, *this); }

  // void MakeUpper() { MyStringUpper(_chars); }
  // void MakeUpper() { MyStringUpper_Ascii(_chars); }
  // void MakeUpper_Ascii() { MyStringUpper_Ascii(_chars); }
  void MakeLower_Ascii() { MyStringLower_Ascii(_chars); }

  bool IsEqualTo(const char *s) const { return StringsAreEqual_Ascii(_chars, s); }
  bool IsEqualTo_NoCase(const wchar_t *s) const { return StringsAreEqualNoCase(_chars, s); }
  bool IsEqualTo_Ascii_NoCase(const char *s) const { return StringsAreEqualNoCase_Ascii(_chars, s); }
  int Compare(const wchar_t *s) const { return wcscmp(_chars, s); }
  // int Compare(const UString &s) const { return MyStringCompare(_chars, s._chars); }
  // int CompareNoCase(const wchar_t *s) const { return MyStringCompareNoCase(_chars, s); }
  // int CompareNoCase(const UString &s) const { return MyStringCompareNoCase(_chars, s._chars); }
  bool IsPrefixedBy(const wchar_t *s) const { return IsString1PrefixedByString2(_chars, s); }
  bool IsPrefixedBy_NoCase(const wchar_t *s) const { return IsString1PrefixedByString2_NoCase(_chars, s); }
  bool IsPrefixedBy_Ascii_NoCase(const char *s) const throw();

  bool IsAscii() const
  {
    unsigned len = Len();
    const wchar_t *s = _chars;
    for (unsigned i = 0; i < len; i++)
      if (s[i] >= 0x80)
        return false;
    return true;
  }
  int Find(wchar_t c) const { return FindCharPosInString(_chars, c); }
  int Find(wchar_t c, unsigned startIndex) const
  {
    int pos = FindCharPosInString(_chars + startIndex, c);
    return pos < 0 ? -1 : (int)startIndex + pos;
  }

  int ReverseFind(wchar_t c) const throw();
  int ReverseFind_Dot() const throw() { return ReverseFind(L'.'); }
  int ReverseFind_PathSepar() const throw();

  int Find(const wchar_t *s) const { return Find(s, 0); }
  int Find(const wchar_t *s, unsigned startIndex) const throw();

  void TrimLeft() throw();
  void TrimRight() throw();
  void Trim()
  {
    TrimRight();
    TrimLeft();
  }

  void InsertAtFront(wchar_t c);
  // void Insert(unsigned index, wchar_t c);
  void Insert(unsigned index, const wchar_t *s);
  void Insert(unsigned index, const UString &s);

  void RemoveChar(wchar_t ch) throw();
  
  void Replace(wchar_t oldChar, wchar_t newChar) throw();
  void Replace(const UString &oldString, const UString &newString);

  void Delete(unsigned index) throw();
  void Delete(unsigned index, unsigned count) throw();
  void DeleteFrontal(unsigned num) throw();
  void DeleteBack() { _chars[--_len] = 0; }
  void DeleteFrom(unsigned index)
  {
    if (index < _len)
    {
      _len = index;
      _chars[index] = 0;
    }
  }
};

bool operator<(const UString &s1, const UString &s2);
bool operator>(const UString &s1, const UString &s2);

inline bool operator==(const UString &s1, const UString &s2) { return s1.Len() == s2.Len() && wcscmp(s1, s2) == 0; }
inline bool operator==(const UString &s1, const wchar_t *s2) { return wcscmp(s1, s2) == 0; }
inline bool operator==(const wchar_t *s1, const UString &s2) { return wcscmp(s1, s2) == 0; }

inline bool operator!=(const UString &s1, const UString &s2) { return s1.Len() != s2.Len() || wcscmp(s1, s2) != 0; }
inline bool operator!=(const UString &s1, const wchar_t *s2) { return wcscmp(s1, s2) != 0; }
inline bool operator!=(const wchar_t *s1, const UString &s2) { return wcscmp(s1, s2) != 0; }


// ---------- forbidden functions ----------

void operator==(wchar_t c1, const UString &s2);
void operator==(const UString &s1, wchar_t c2);

void operator+(wchar_t c, const UString &s); // this function can be OK, but we don't use it

void operator+(const UString &s, char c);
void operator+(const UString &s, unsigned char c);
void operator+(char c, const UString &s);
void operator+(unsigned char c, const UString &s);
void operator-(const UString &s1, wchar_t c);

#ifdef _WIN32
// can we forbid these functions, if wchar_t is 32-bit ?
void operator+(const UString &s, int c);
void operator+(const UString &s, unsigned c);
void operator+(int c, const UString &s);
void operator+(unsigned c, const UString &s);
void operator-(const UString &s1, int c);
void operator-(const UString &s1, unsigned c);
#endif







class UString2
{
  wchar_t *_chars;
  unsigned _len;

  void ReAlloc2(unsigned newLimit);
  void SetStartLen(unsigned len);

  // ---------- forbidden functions ----------
  
  UString2 &operator=(char c);
  UString2 &operator=(unsigned char c);
  UString2 &operator=(wchar_t c);
  UString2(char c);
  UString2(unsigned char c);

public:
  UString2(): _chars(NULL), _len(0) {}
  // UString2(wchar_t c);
  UString2(const wchar_t *s);
  UString2(const UString2 &s);
  ~UString2() { if (_chars) MY_STRING_DELETE(_chars); }

  unsigned Len() const { return _len; }
  bool IsEmpty() const { return _len == 0; }
  // void Empty() { _len = 0; _chars[0] = 0; }

  // operator const wchar_t *() const { return _chars; }
  const wchar_t *GetRawPtr() const { return _chars; }

  wchar_t *GetBuf(unsigned minLen)
  {
    if (!_chars || minLen > _len)
      ReAlloc2(minLen);
    return _chars;
  }
  void ReleaseBuf_SetLen(unsigned newLen) { _len = newLen; }

  UString2 &operator=(const wchar_t *s);
  UString2 &operator=(const UString2 &s);
  void SetFromAscii(const char *s);
};

bool operator==(const UString2 &s1, const UString2 &s2);
bool operator==(const UString2 &s1, const wchar_t *s2);
bool operator==(const wchar_t *s1, const UString2 &s2);

inline bool operator!=(const UString2 &s1, const UString2 &s2) { return !(s1 == s2); }
inline bool operator!=(const UString2 &s1, const wchar_t *s2) { return !(s1 == s2); }
inline bool operator!=(const wchar_t *s1, const UString2 &s2) { return !(s1 == s2); }


// ---------- forbidden functions ----------

void operator==(wchar_t c1, const UString2 &s2);
void operator==(const UString2 &s1, wchar_t c2);
bool operator<(const UString2 &s1, const UString2 &s2);
bool operator>(const UString2 &s1, const UString2 &s2);

void operator+(const UString2 &s1, const UString2 &s2);
void operator+(const UString2 &s1, const wchar_t *s2);
void operator+(const wchar_t *s1, const UString2 &s2);
void operator+(wchar_t c, const UString2 &s);
void operator+(const UString2 &s, wchar_t c);
void operator+(const UString2 &s, char c);
void operator+(const UString2 &s, unsigned char c);
void operator+(char c, const UString2 &s);
void operator+(unsigned char c, const UString2 &s);
void operator-(const UString2 &s1, wchar_t c);






typedef CObjectVector<AString> AStringVector;
typedef CObjectVector<UString> UStringVector;

#ifdef _UNICODE
  typedef UString CSysString;
#else
  typedef AString CSysString;
#endif

typedef CObjectVector<CSysString> CSysStringVector;


// ---------- FString ----------

#ifdef _UNICODE  // FIXME #ifdef _WIN32
  #define USE_UNICODE_FSTRING
#endif

#ifdef USE_UNICODE_FSTRING

  #define __FTEXT(quote) L##quote

  typedef wchar_t FChar;
  typedef UString FString;

  #define fs2us(_x_) (_x_)
  #define us2fs(_x_) (_x_)
  FString fas2fs(const AString &s);
  AString fs2fas(const FChar *s);

#else

  #define __FTEXT(quote) quote

  typedef char FChar;
  typedef AString FString;

  UString fs2us(const FString &s);
  FString us2fs(const wchar_t *s);
  #define fas2fs(_x_) (_x_)
  #define fs2fas(_x_) (_x_)

#endif

#define FTEXT(quote) __FTEXT(quote)

#define FCHAR_PATH_SEPARATOR FTEXT(CHAR_PATH_SEPARATOR)
#define FSTRING_PATH_SEPARATOR FTEXT(STRING_PATH_SEPARATOR)
#define FCHAR_ANY_MASK FTEXT('*')
#define FSTRING_ANY_MASK FTEXT("*")
typedef const FChar *CFSTR;

typedef CObjectVector<FString> FStringVector;

#endif
// Common/MyTypes.h

#ifndef __COMMON_MY_TYPES_H
#define __COMMON_MY_TYPES_H

#include "../../C/7zTypes.h"

typedef int HRes;

#ifdef __cplusplus
struct CBoolPair
{
  bool Val;
  bool Def;

  CBoolPair(): Val(false), Def(false) {}
  
  void Init()
  {
    Val = false;
    Def = false;
  }

  void SetTrueTrue()
  {
    Val = true;
    Def = true;
  }
};

#define CLASS_NO_COPY(cls) \
  private: \
  cls(const cls &); \
  cls &operator=(const cls &);

#endif

#endif
// MyUnknown.h

#ifndef __MY_UNKNOWN_H
#define __MY_UNKNOWN_H

#include "MyWindows.h"

/*
#ifdef _WIN32
#include <basetyps.h>
#include <unknwn.h>
#else
#include "MyWindows.h"
#endif
*/
  
#endif
// Common/MyVector.cpp

#include "StdAfx.h"
// Common/MyVector.h

#ifndef __COMMON_MY_VECTOR_H
#define __COMMON_MY_VECTOR_H

#include <string.h>

template <class T>
class CRecordVector
{
  T *_items;
  unsigned _size;
  unsigned _capacity;
  
  void MoveItems(unsigned destIndex, unsigned srcIndex)
  {
    memmove(_items + destIndex, _items + srcIndex, (size_t)(_size - srcIndex) * sizeof(T));
  }

  void ReserveOnePosition()
  {
    if (_size == _capacity)
    {
      unsigned newCapacity = _capacity + (_capacity >> 2) + 1;
      T *p = new T[newCapacity];
      if (_size != 0)
        memcpy(p, _items, (size_t)_size * sizeof(T));
      delete []_items;
      _items = p;
      _capacity = newCapacity;
    }
  }

public:

  CRecordVector(): _items(0), _size(0), _capacity(0) {}
  
  CRecordVector(const CRecordVector &v): _items(0), _size(0), _capacity(0)
  {
    unsigned size = v.Size();
    if (size != 0)
    {
      _items = new T[size];
      _size = size;
      _capacity = size;
      memcpy(_items, v._items, (size_t)size * sizeof(T));
    }
  }
  
  unsigned Size() const { return _size; }
  bool IsEmpty() const { return _size == 0; }
  
  void ConstructReserve(unsigned size)
  {
    if (size != 0)
    {
      _items = new T[size];
      _capacity = size;
    }
  }

  void Reserve(unsigned newCapacity)
  {
    if (newCapacity > _capacity)
    {
      T *p = new T[newCapacity];
      if (_size != 0)
        memcpy(p, _items, (size_t)_size * sizeof(T));
      delete []_items;
      _items = p;
      _capacity = newCapacity;
    }
  }

  void ClearAndReserve(unsigned newCapacity)
  {
    Clear();
    if (newCapacity > _capacity)
    {
      delete []_items;
      _items = NULL;
      _capacity = 0;
      _items = new T[newCapacity];
      _capacity = newCapacity;
    }
  }

  void ClearAndSetSize(unsigned newSize)
  {
    ClearAndReserve(newSize);
    _size = newSize;
  }

  void ChangeSize_KeepData(unsigned newSize)
  {
    if (newSize > _capacity)
    {
      T *p = new T[newSize];
      if (_size != 0)
        memcpy(p, _items, (size_t)_size * sizeof(T));
      delete []_items;
      _items = p;
      _capacity = newSize;
    }
    _size = newSize;
  }

  void ReserveDown()
  {
    if (_size == _capacity)
      return;
    T *p = NULL;
    if (_size != 0)
    {
      p = new T[_size];
      memcpy(p, _items, (size_t)_size * sizeof(T));
    }
    delete []_items;
    _items = p;
    _capacity = _size;
  }
  
  ~CRecordVector() { delete []_items; }
  
  void ClearAndFree()
  {
    delete []_items;
    _items = NULL;
    _size = 0;
    _capacity = 0;
  }
  
  void Clear() { _size = 0; }

  void DeleteBack() { _size--; }
  
  void DeleteFrom(unsigned index)
  {
    // if (index <= _size)
      _size = index;
  }
  
  void DeleteFrontal(unsigned num)
  {
    if (num != 0)
    {
      MoveItems(0, num);
      _size -= num;
    }
  }

  void Delete(unsigned index)
  {
    MoveItems(index, index + 1);
    _size -= 1;
  }

  /*
  void Delete(unsigned index, unsigned num)
  {
    if (num > 0)
    {
      MoveItems(index, index + num);
      _size -= num;
    }
  }
  */

  CRecordVector& operator=(const CRecordVector &v)
  {
    if (&v == this)
      return *this;
    unsigned size = v.Size();
    if (size > _capacity)
    {
      delete []_items;
      _capacity = 0;
      _size = 0;
      _items = NULL;
      _items = new T[size];
      _capacity = size;
    }
    _size = size;
    if (size != 0)
      memcpy(_items, v._items, (size_t)size * sizeof(T));
    return *this;
  }

  CRecordVector& operator+=(const CRecordVector &v)
  {
    unsigned size = v.Size();
    Reserve(_size + size);
    if (size != 0)
      memcpy(_items + _size, v._items, (size_t)size * sizeof(T));
    _size += size;
    return *this;
  }
  
  unsigned Add(const T item)
  {
    ReserveOnePosition();
    _items[_size] = item;
    return _size++;
  }

  void AddInReserved(const T item)
  {
    _items[_size++] = item;
  }

  void Insert(unsigned index, const T item)
  {
    ReserveOnePosition();
    MoveItems(index + 1, index);
    _items[index] = item;
    _size++;
  }

  void MoveToFront(unsigned index)
  {
    if (index != 0)
    {
      T temp = _items[index];
      memmove(_items + 1, _items, (size_t)index * sizeof(T));
      _items[0] = temp;
    }
  }

  const T& operator[](unsigned index) const { return _items[index]; }
        T& operator[](unsigned index)       { return _items[index]; }
  const T& Front() const { return _items[0]; }
        T& Front()       { return _items[0]; }
  const T& Back() const  { return _items[_size - 1]; }
        T& Back()        { return _items[_size - 1]; }

  /*
  void Swap(unsigned i, unsigned j)
  {
    T temp = _items[i];
    _items[i] = _items[j];
    _items[j] = temp;
  }
  */

  int FindInSorted(const T item, unsigned left, unsigned right) const
  {
    while (left != right)
    {
      unsigned mid = (left + right) / 2;
      const T midVal = (*this)[mid];
      if (item == midVal)
        return mid;
      if (item < midVal)
        right = mid;
      else
        left = mid + 1;
    }
    return -1;
  }

  int FindInSorted2(const T &item, unsigned left, unsigned right) const
  {
    while (left != right)
    {
      unsigned mid = (left + right) / 2;
      const T& midVal = (*this)[mid];
      int comp = item.Compare(midVal);
      if (comp == 0)
        return mid;
      if (comp < 0)
        right = mid;
      else
        left = mid + 1;
    }
    return -1;
  }

  int FindInSorted(const T item) const
  {
    return FindInSorted(item, 0, _size);
  }

  int FindInSorted2(const T &item) const
  {
    return FindInSorted2(item, 0, _size);
  }

  unsigned AddToUniqueSorted(const T item)
  {
    unsigned left = 0, right = _size;
    while (left != right)
    {
      unsigned mid = (left + right) / 2;
      const T midVal = (*this)[mid];
      if (item == midVal)
        return mid;
      if (item < midVal)
        right = mid;
      else
        left = mid + 1;
    }
    Insert(right, item);
    return right;
  }

  unsigned AddToUniqueSorted2(const T &item)
  {
    unsigned left = 0, right = _size;
    while (left != right)
    {
      unsigned mid = (left + right) / 2;
      const T& midVal = (*this)[mid];
      int comp = item.Compare(midVal);
      if (comp == 0)
        return mid;
      if (comp < 0)
        right = mid;
      else
        left = mid + 1;
    }
    Insert(right, item);
    return right;
  }

  static void SortRefDown(T* p, unsigned k, unsigned size, int (*compare)(const T*, const T*, void *), void *param)
  {
    T temp = p[k];
    for (;;)
    {
      unsigned s = (k << 1);
      if (s > size)
        break;
      if (s < size && compare(p + s + 1, p + s, param) > 0)
        s++;
      if (compare(&temp, p + s, param) >= 0)
        break;
      p[k] = p[s];
      k = s;
    }
    p[k] = temp;
  }

  void Sort(int (*compare)(const T*, const T*, void *), void *param)
  {
    unsigned size = _size;
    if (size <= 1)
      return;
    T* p = (&Front()) - 1;
    {
      unsigned i = size >> 1;
      do
        SortRefDown(p, i, size, compare, param);
      while (--i != 0);
    }
    do
    {
      T temp = p[size];
      p[size--] = p[1];
      p[1] = temp;
      SortRefDown(p, 1, size, compare, param);
    }
    while (size > 1);
  }

  static void SortRefDown2(T* p, unsigned k, unsigned size)
  {
    T temp = p[k];
    for (;;)
    {
      unsigned s = (k << 1);
      if (s > size)
        break;
      if (s < size && p[s + 1].Compare(p[s]) > 0)
        s++;
      if (temp.Compare(p[s]) >= 0)
        break;
      p[k] = p[s];
      k = s;
    }
    p[k] = temp;
  }

  void Sort2()
  {
    unsigned size = _size;
    if (size <= 1)
      return;
    T* p = (&Front()) - 1;
    {
      unsigned i = size >> 1;
      do
        SortRefDown2(p, i, size);
      while (--i != 0);
    }
    do
    {
      T temp = p[size];
      p[size--] = p[1];
      p[1] = temp;
      SortRefDown2(p, 1, size);
    }
    while (size > 1);
  }
};

typedef CRecordVector<int> CIntVector;
typedef CRecordVector<unsigned int> CUIntVector;
typedef CRecordVector<bool> CBoolVector;
typedef CRecordVector<unsigned char> CByteVector;
typedef CRecordVector<void *> CPointerVector;

template <class T>
class CObjectVector
{
  CPointerVector _v;
public:
  unsigned Size() const { return _v.Size(); }
  bool IsEmpty() const { return _v.IsEmpty(); }
  void ReserveDown() { _v.ReserveDown(); }
  // void Reserve(unsigned newCapacity) { _v.Reserve(newCapacity); }
  void ClearAndReserve(unsigned newCapacity) { Clear(); _v.ClearAndReserve(newCapacity); }

  CObjectVector() {};
  CObjectVector(const CObjectVector &v)
  {
    unsigned size = v.Size();
    _v.ConstructReserve(size);
    for (unsigned i = 0; i < size; i++)
      _v.AddInReserved(new T(v[i]));
  }
  CObjectVector& operator=(const CObjectVector &v)
  {
    if (&v == this)
      return *this;
    Clear();
    unsigned size = v.Size();
    _v.Reserve(size);
    for (unsigned i = 0; i < size; i++)
      _v.AddInReserved(new T(v[i]));
    return *this;
  }

  CObjectVector& operator+=(const CObjectVector &v)
  {
    unsigned size = v.Size();
    _v.Reserve(Size() + size);
    for (unsigned i = 0; i < size; i++)
      _v.AddInReserved(new T(v[i]));
    return *this;
  }
  
  const T& operator[](unsigned index) const { return *((T *)_v[index]); }
        T& operator[](unsigned index)       { return *((T *)_v[index]); }
  const T& Front() const { return operator[](0); }
        T& Front()       { return operator[](0); }
  const T& Back() const  { return operator[](_v.Size() - 1); }
        T& Back()        { return operator[](_v.Size() - 1); }
  
  void MoveToFront(unsigned index) { _v.MoveToFront(index); }

  unsigned Add(const T& item) { return _v.Add(new T(item)); }
  
  void AddInReserved(const T& item) { _v.AddInReserved(new T(item)); }
  
  T& AddNew()
  {
    T *p = new T;
    _v.Add(p);
    return *p;
  }
  
  T& AddNewInReserved()
  {
    T *p = new T;
    _v.AddInReserved(p);
    return *p;
  }
  
  void Insert(unsigned index, const T& item) { _v.Insert(index, new T(item)); }
  
  T& InsertNew(unsigned index)
  {
    T *p = new T;
    _v.Insert(index, p);
    return *p;
  }

  ~CObjectVector()
  {
    for (unsigned i = _v.Size(); i != 0;)
      delete (T *)_v[--i];
  }
  
  void ClearAndFree()
  {
    Clear();
    _v.ClearAndFree();
  }
  
  void Clear()
  {
    for (unsigned i = _v.Size(); i != 0;)
      delete (T *)_v[--i];
    _v.Clear();
  }
  
  void DeleteFrom(unsigned index)
  {
    unsigned size = _v.Size();
    for (unsigned i = index; i < size; i++)
      delete (T *)_v[i];
    _v.DeleteFrom(index);
  }

  void DeleteFrontal(unsigned num)
  {
    for (unsigned i = 0; i < num; i++)
      delete (T *)_v[i];
    _v.DeleteFrontal(num);
  }

  void DeleteBack()
  {
    delete (T *)_v[_v.Size() - 1];
    _v.DeleteBack();
  }

  void Delete(unsigned index)
  {
    delete (T *)_v[index];
    _v.Delete(index);
  }

  /*
  void Delete(unsigned index, unsigned num)
  {
    for (unsigned i = 0; i < num; i++)
      delete (T *)_v[index + i];
    _v.Delete(index, num);
  }
  */

  /*
  int Find(const T& item) const
  {
    unsigned size = Size();
    for (unsigned i = 0; i < size; i++)
      if (item == (*this)[i])
        return i;
    return -1;
  }
  */
  
  int FindInSorted(const T& item) const
  {
    unsigned left = 0, right = Size();
    while (left != right)
    {
      unsigned mid = (left + right) / 2;
      const T& midVal = (*this)[mid];
      int comp = item.Compare(midVal);
      if (comp == 0)
        return mid;
      if (comp < 0)
        right = mid;
      else
        left = mid + 1;
    }
    return -1;
  }

  unsigned AddToUniqueSorted(const T& item)
  {
    unsigned left = 0, right = Size();
    while (left != right)
    {
      unsigned mid = (left + right) / 2;
      const T& midVal = (*this)[mid];
      int comp = item.Compare(midVal);
      if (comp == 0)
        return mid;
      if (comp < 0)
        right = mid;
      else
        left = mid + 1;
    }
    Insert(right, item);
    return right;
  }

  /*
  unsigned AddToSorted(const T& item)
  {
    unsigned left = 0, right = Size();
    while (left != right)
    {
      unsigned mid = (left + right) / 2;
      const T& midVal = (*this)[mid];
      int comp = item.Compare(midVal);
      if (comp == 0)
      {
        right = mid + 1;
        break;
      }
      if (comp < 0)
        right = mid;
      else
        left = mid + 1;
    }
    Insert(right, item);
    return right;
  }
  */

  void Sort(int (*compare)(void *const *, void *const *, void *), void *param)
    { _v.Sort(compare, param); }

  static int CompareObjectItems(void *const *a1, void *const *a2, void * /* param */)
    { return (*(*((const T **)a1))).Compare(*(*((const T **)a2))); }

  void Sort() { _v.Sort(CompareObjectItems, 0); }
};

#define FOR_VECTOR(_i_, _v_) for (unsigned _i_ = 0; _i_ < (_v_).Size(); _i_++)

#endif
// MyWindows.cpp

#include "StdAfx.h"

#ifndef _WIN32

#include "MyWindows.h"
#include "MyTypes.h"
#include <stdlib.h> /* FIXED <malloc.h> */

static inline void *AllocateForBSTR(size_t cb) { return ::malloc(cb); }
static inline void FreeForBSTR(void *pv) { ::free(pv);}

/* FIXME
static UINT MyStringLen(const wchar_t *s)
{ 
  UINT i;
  for (i = 0; s[i] != '\0'; i++);
  return i;
}
*/

BSTR SysAllocStringByteLen(LPCSTR psz, UINT len)
{
  // FIXED int realLen = len + sizeof(UINT) + 3;
  const int LEN_ADDON = sizeof(wchar_t) - 1;
  int realLen = len + sizeof(UINT) + sizeof(wchar_t) + LEN_ADDON;
  void *p = AllocateForBSTR(realLen);
  if (p == 0)
    return 0;
  *(UINT *)p = len;
  // "void *" instead of "BSTR" to avoid unaligned copy of "wchar_t" because of optimizer on Solaris
  void * bstr = (void *)((UINT *)p + 1);
  if (psz) memmove(bstr, psz, len); // psz does not always have "wchar_t" alignment.
  void *pb = (void *)(((Byte *)bstr) + len);
  memset(pb,0,sizeof(wchar_t) + LEN_ADDON);
  return (BSTR)bstr;
}

BSTR WINAPI SysAllocStringLen(const OLECHAR *sz, unsigned int numChars) // FIXME - code
{
  UINT len = (numChars + 1) * sizeof(OLECHAR);
  void *p = AllocateForBSTR(len + sizeof(UINT));
  if (p == 0)
    return 0;
  memset(p,0,len + sizeof(UINT));
  *(UINT *)p = numChars * sizeof(OLECHAR); // FIXED
  void * bstr = (void *)((UINT *)p + 1);
  if (sz) memmove(bstr, sz, numChars  * sizeof(OLECHAR)); // sz does not always have "wchar_t" alignment.

  return (BSTR)bstr;
}


BSTR SysAllocString(const OLECHAR *sz)
{
  if (sz == 0)
    return 0;
  UINT strLen = MyStringLen(sz);
  UINT len = (strLen + 1) * sizeof(OLECHAR);
  void *p = AllocateForBSTR(len + sizeof(UINT));
  if (p == 0)
    return 0;
  *(UINT *)p = strLen * sizeof(OLECHAR); // FIXED
  void * bstr = (void *)((UINT *)p + 1);
  memmove(bstr, sz, len); // sz does not always have "wchar_t" alignment.
  return (BSTR)bstr;
}

void SysFreeString(BSTR bstr)
{
  if (bstr != 0)
    FreeForBSTR((UINT *)bstr - 1);
}

UINT SysStringByteLen(BSTR bstr)
{
  if (bstr == 0)
    return 0;
  return *((UINT *)bstr - 1);

}

UINT SysStringLen(BSTR bstr)
{
  return SysStringByteLen(bstr) / sizeof(OLECHAR);
}

HRESULT VariantClear(VARIANTARG *prop)
{
  if (prop->vt == VT_BSTR)
    SysFreeString(prop->bstrVal);
  prop->vt = VT_EMPTY;
  return S_OK;
}

HRESULT VariantCopy(VARIANTARG *dest, VARIANTARG *src)
{
  HRESULT res = ::VariantClear(dest);
  if (res != S_OK)
    return res;
  if (src->vt == VT_BSTR)
  {
    dest->bstrVal = SysAllocStringByteLen((LPCSTR)src->bstrVal, 
        SysStringByteLen(src->bstrVal));
    if (dest->bstrVal == 0)
      return E_OUTOFMEMORY;
    dest->vt = VT_BSTR;
  }
  else
    *dest = *src;
  return S_OK;
}

LONG CompareFileTime(const FILETIME* ft1, const FILETIME* ft2)
{
  if(ft1->dwHighDateTime < ft2->dwHighDateTime)
    return -1;
  if(ft1->dwHighDateTime > ft2->dwHighDateTime)
    return 1;
  if(ft1->dwLowDateTime < ft2->dwLowDateTime)
    return -1;
  if(ft1->dwLowDateTime > ft2->dwLowDateTime)
    return 1;
  return 0;
}

#endif
// MyWindows.h

#ifndef __MYWINDOWS_H
#define __MYWINDOWS_H

#ifdef _WIN32

#include <windows.h>

#else

#include <stddef.h> // for wchar_t
#include <string.h>

#include "MyGuidDef.h"

typedef char CHAR;
typedef unsigned char UCHAR;

#undef BYTE
typedef unsigned char BYTE;

typedef short SHORT;
typedef unsigned short USHORT;

#undef WORD
typedef unsigned short WORD;
typedef short VARIANT_BOOL;

typedef int INT;
typedef Int32 INT32;
typedef unsigned int UINT;
typedef UInt32 UINT32;
typedef INT32 LONG;   // LONG, ULONG and DWORD must be 32-bit
typedef UINT32 ULONG;

#undef DWORD
typedef UINT32 DWORD;

typedef Int64 LONGLONG;
typedef UInt64 ULONGLONG;

typedef struct LARGE_INTEGER { LONGLONG QuadPart; }LARGE_INTEGER;
typedef struct _ULARGE_INTEGER { ULONGLONG QuadPart;} ULARGE_INTEGER;

typedef const CHAR *LPCSTR;

typedef wchar_t WCHAR;

#ifdef _UNICODE
typedef WCHAR TCHAR;
#define lstrcpy wcscpy
#define lstrcat wcscat
#define lstrlen wcslen
#else
typedef CHAR TCHAR;
#define lstrcpy strcpy
#define lstrcat strcat
#define lstrlen strlen
#endif
#define _wcsicmp(str1,str2) MyStringCompareNoCase(str1,str2)

typedef const TCHAR *LPCTSTR;
typedef WCHAR OLECHAR;
typedef const WCHAR *LPCWSTR;
typedef OLECHAR *BSTR;
typedef const OLECHAR *LPCOLESTR;
typedef OLECHAR *LPOLESTR;

typedef struct _FILETIME
{
  DWORD dwLowDateTime;
  DWORD dwHighDateTime;
}FILETIME;

#define HRESULT LONG
#define FAILED(Status) ((HRESULT)(Status)<0)
typedef ULONG PROPID;
typedef LONG SCODE;

#define S_OK    ((HRESULT)0x00000000L)
#define S_FALSE ((HRESULT)0x00000001L)
#define E_NOTIMPL ((HRESULT)0x80004001L)
#define E_NOINTERFACE ((HRESULT)0x80004002L)
#define E_ABORT ((HRESULT)0x80004004L)
#define E_FAIL ((HRESULT)0x80004005L)
#define STG_E_INVALIDFUNCTION ((HRESULT)0x80030001L)
#define E_OUTOFMEMORY ((HRESULT)0x8007000EL)
#define E_INVALIDARG ((HRESULT)0x80070057L)

#ifdef _MSC_VER
#define STDMETHODCALLTYPE __stdcall
#else
#define STDMETHODCALLTYPE
#endif

#define STDMETHOD_(t, f) virtual t STDMETHODCALLTYPE f
#define STDMETHOD(f) STDMETHOD_(HRESULT, f)
#define STDMETHODIMP_(type) type STDMETHODCALLTYPE
#define STDMETHODIMP STDMETHODIMP_(HRESULT)

#define PURE = 0

#define MIDL_INTERFACE(x) struct

#ifdef __cplusplus

DEFINE_GUID(IID_IUnknown,
0x00000000, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
struct IUnknown
{
  STDMETHOD(QueryInterface) (REFIID iid, void **outObject) PURE;
  STDMETHOD_(ULONG, AddRef)() PURE;
  STDMETHOD_(ULONG, Release)() PURE;
  #ifndef _WIN32
  virtual ~IUnknown() {}
  #endif
};

typedef IUnknown *LPUNKNOWN;

#endif

#define VARIANT_TRUE ((VARIANT_BOOL)-1)
#define VARIANT_FALSE ((VARIANT_BOOL)0)

enum VARENUM
{
  VT_EMPTY = 0,
  VT_NULL = 1,
  VT_I2 = 2,
  VT_I4 = 3,
  VT_R4 = 4,
  VT_R8 = 5,
  VT_CY = 6,
  VT_DATE = 7,
  VT_BSTR = 8,
  VT_DISPATCH = 9,
  VT_ERROR = 10,
  VT_BOOL = 11,
  VT_VARIANT = 12,
  VT_UNKNOWN = 13,
  VT_DECIMAL = 14,
  VT_I1 = 16,
  VT_UI1 = 17,
  VT_UI2 = 18,
  VT_UI4 = 19,
  VT_I8 = 20,
  VT_UI8 = 21,
  VT_INT = 22,
  VT_UINT = 23,
  VT_VOID = 24,
  VT_HRESULT = 25,
  VT_FILETIME = 64
};

typedef unsigned short VARTYPE;
typedef WORD PROPVAR_PAD1;
typedef WORD PROPVAR_PAD2;
typedef WORD PROPVAR_PAD3;

#ifdef __cplusplus

typedef struct tagPROPVARIANT
{
  VARTYPE vt;
  PROPVAR_PAD1 wReserved1;
  PROPVAR_PAD2 wReserved2;
  PROPVAR_PAD3 wReserved3;
  union
  {
    CHAR cVal;
    UCHAR bVal;
    SHORT iVal;
    USHORT uiVal;
    LONG lVal;
    ULONG ulVal;
    INT intVal;
    UINT uintVal;
    LARGE_INTEGER hVal;
    ULARGE_INTEGER uhVal;
    VARIANT_BOOL boolVal;
    SCODE scode;
    FILETIME filetime;
    BSTR bstrVal;
  };
} PROPVARIANT;

typedef PROPVARIANT tagVARIANT;
typedef tagVARIANT VARIANT;
typedef VARIANT VARIANTARG;

#define MY_EXTERN_C extern "C"

MY_EXTERN_C HRESULT VariantClear(VARIANTARG *prop);
MY_EXTERN_C HRESULT VariantCopy(VARIANTARG *dest, VARIANTARG *src);

#else

#define MY_EXTERN_C extern


#endif

MY_EXTERN_C BSTR SysAllocStringByteLen(LPCSTR psz, UINT len);
MY_EXTERN_C BSTR SysAllocStringLen(const OLECHAR*,UINT);
MY_EXTERN_C BSTR SysAllocString(const OLECHAR *sz);
MY_EXTERN_C void SysFreeString(BSTR bstr);
MY_EXTERN_C UINT SysStringByteLen(BSTR bstr);
MY_EXTERN_C UINT SysStringLen(BSTR bstr);

/* MY_EXTERN_C DWORD GetLastError(); */
MY_EXTERN_C LONG CompareFileTime(const FILETIME* ft1, const FILETIME* ft2);

#define CP_ACP    0
#define CP_OEMCP  1

typedef enum tagSTREAM_SEEK
{
  STREAM_SEEK_SET = 0,
  STREAM_SEEK_CUR = 1,
  STREAM_SEEK_END = 2
} STREAM_SEEK;

#endif
#endif
// MyXml.cpp

#include "StdAfx.h"

#include "MyXml.h"

static bool IsValidChar(char c)
{
  return
    c >= 'a' && c <= 'z' ||
    c >= 'A' && c <= 'Z' ||
    c >= '0' && c <= '9' ||
    c == '-';
}

static bool IsSpaceChar(char c)
{
  return (c == ' ' || c == '\t' || c == 0x0D || c == 0x0A);
}

#define SKIP_SPACES(s) while (IsSpaceChar(*s)) s++;

int CXmlItem::FindProp(const AString &propName) const throw()
{
  FOR_VECTOR (i, Props)
    if (Props[i].Name == propName)
      return i;
  return -1;
}

AString CXmlItem::GetPropVal(const AString &propName) const
{
  int index = FindProp(propName);
  if (index >= 0)
    return Props[index].Value;
  return AString();
}

bool CXmlItem::IsTagged(const AString &tag) const throw()
{
  return (IsTag && Name == tag);
}

int CXmlItem::FindSubTag(const AString &tag) const throw()
{
  FOR_VECTOR (i, SubItems)
    if (SubItems[i].IsTagged(tag))
      return i;
  return -1;
}

AString CXmlItem::GetSubString() const
{
  if (SubItems.Size() == 1)
  {
    const CXmlItem &item = SubItems[0];
    if (!item.IsTag)
      return item.Name;
  }
  return AString();
}

const AString * CXmlItem::GetSubStringPtr() const throw()
{
  if (SubItems.Size() == 1)
  {
    const CXmlItem &item = SubItems[0];
    if (!item.IsTag)
      return &item.Name;
  }
  return NULL;
}

AString CXmlItem::GetSubStringForTag(const AString &tag) const
{
  int index = FindSubTag(tag);
  if (index >= 0)
    return SubItems[index].GetSubString();
  return AString();
}

const char * CXmlItem::ParseItem(const char *s, int numAllowedLevels)
{
  SKIP_SPACES(s);

  const char *beg = s;
  for (;;)
  {
    char c;
    c = *s; if (c == 0 || c == '<') break; s++;
    c = *s; if (c == 0 || c == '<') break; s++;
  }
  if (*s == 0)
    return NULL;
  if (s != beg)
  {
    IsTag = false;
    Name.SetFrom(beg, (unsigned)(s - beg));
    return s;
  }
  
  IsTag = true;

  s++;
  SKIP_SPACES(s);

  beg = s;
  for (;; s++)
    if (!IsValidChar(*s))
      break;
  if (s == beg || *s == 0)
    return NULL;
  Name.SetFrom(beg, (unsigned)(s - beg));

  for (;;)
  {
    beg = s;
    SKIP_SPACES(s);
    if (*s == '/')
    {
      s++;
      // SKIP_SPACES(s);
      if (*s != '>')
        return NULL;
      return s + 1;
    }
    if (*s == '>')
    {
      s++;
      if (numAllowedLevels == 0)
        return NULL;
      SubItems.Clear();
      for (;;)
      {
        SKIP_SPACES(s);
        if (s[0] == '<' && s[1] == '/')
          break;
        CXmlItem &item = SubItems.AddNew();
        s = item.ParseItem(s, numAllowedLevels - 1);
        if (!s)
          return NULL;
      }

      s += 2;
      unsigned len = Name.Len();
      for (unsigned i = 0; i < len; i++)
        if (s[i] != Name[i])
          return NULL;
      s += len;
      if (s[0] != '>')
        return NULL;
      return s + 1;
    }
    if (beg == s)
      return NULL;

    // ReadProperty
    CXmlProp &prop = Props.AddNew();

    beg = s;
    for (;; s++)
    {
      char c = *s;
      if (!IsValidChar(c))
        break;
    }
    if (s == beg)
      return NULL;
    prop.Name.SetFrom(beg, (unsigned)(s - beg));
    
    SKIP_SPACES(s);
    if (*s != '=')
      return NULL;
    s++;
    SKIP_SPACES(s);
    if (*s != '\"')
      return NULL;
    s++;
    
    beg = s;
    for (;;)
    {
      char c = *s;
      if (c == 0)
        return NULL;
      if (c == '\"')
        break;
      s++;
    }
    prop.Value.SetFrom(beg, (unsigned)(s - beg));
    s++;
  }
}

static const char * SkipHeader(const char *s, const char *startString, const char *endString)
{
  SKIP_SPACES(s);
  if (IsString1PrefixedByString2(s, startString))
  {
    s = strstr(s, endString);
    if (!s)
      return NULL;
    s += strlen(endString);
  }
  return s;
}

void CXmlItem::AppendTo(AString &s) const
{
  if (IsTag)
    s += '<';
  s += Name;
  if (IsTag)
  {
    FOR_VECTOR (i, Props)
    {
      const CXmlProp &prop = Props[i];
      s += ' ';
      s += prop.Name;
      s += '=';
      s += '\"';
      s += prop.Value;
      s += '\"';
    }
    s += '>';
  }
  FOR_VECTOR (i, SubItems)
  {
    const CXmlItem &item = SubItems[i];
    if (i != 0 && !SubItems[i - 1].IsTag)
      s += ' ';
    item.AppendTo(s);
  }
  if (IsTag)
  {
    s += '<';
    s += '/';
    s += Name;
    s += '>';
  }
}

bool CXml::Parse(const char *s)
{
  s = SkipHeader(s, "<?xml",    "?>"); if (!s) return false;
  s = SkipHeader(s, "<!DOCTYPE", ">"); if (!s) return false;

  s = Root.ParseItem(s, 1000);
  if (!s || !Root.IsTag)
    return false;
  SKIP_SPACES(s);
  return *s == 0;
}

/*
void CXml::AppendTo(AString &s) const
{
  Root.AppendTo(s);
}
*/
// MyXml.h

#ifndef __MY_XML_H
#define __MY_XML_H

#include "MyString.h"

struct CXmlProp
{
  AString Name;
  AString Value;
};

class CXmlItem
{
public:
  AString Name;
  bool IsTag;
  CObjectVector<CXmlProp> Props;
  CObjectVector<CXmlItem> SubItems;
  
  const char * ParseItem(const char *s, int numAllowedLevels);

  bool IsTagged(const AString &tag) const throw();
  int FindProp(const AString &propName) const throw();
  AString GetPropVal(const AString &propName) const;
  AString GetSubString() const;
  const AString * GetSubStringPtr() const throw();
  int FindSubTag(const AString &tag) const throw();
  AString GetSubStringForTag(const AString &tag) const;

  void AppendTo(AString &s) const;
};

struct CXml
{
  CXmlItem Root;

  bool Parse(const char *s);
  // void AppendTo(AString &s) const;
};

#endif
// NewHandler.cpp
 
#include "StdAfx.h"

#include "../../C/Alloc.h"


#ifdef DONT_REDEFINE_NEW

int g_NewHandler = 0;

#else

/* An overload function for the C++ new */
void * operator new(size_t size)
{
  return MyAlloc(size);
}

/* An overload function for the C++ new[] */
void * operator new[](size_t size)
{
    return MyAlloc(size);
}

/* An overload function for the C++ delete */
void operator delete(void *pnt)
{
    MyFree(pnt);
}

/* An overload function for the C++ delete[] */
void operator delete[](void *pnt)
{
    MyFree(pnt);
}

#endif

// Common/NewHandler.h

#ifndef __COMMON_NEW_HANDLER_H
#define __COMMON_NEW_HANDLER_H

/*
This file must be included before any code that uses operators "delete" or "new".
Also you must compile and link "NewHandler.cpp", if you use MSVC 6.0.
The operator "new" in MSVC 6.0 doesn't throw exception "bad_alloc".
So we define another version of operator "new" that throws "CNewException" on failure.

If you use compiler that throws exception in "new" operator (GCC or new version of MSVC),
you can compile without "NewHandler.cpp". So standard exception "bad_alloc" will be used.

It's still allowed to use redefined version of operator "new" from "NewHandler.cpp"
with any compiler. 7-Zip's code can work with "bad_alloc" and "CNewException" exceptions.
But if you use some additional code (outside of 7-Zip's code), you must check
that redefined version of operator "new" (that throws CNewException) is not
problem for your code.

Also we declare delete(void *p) throw() that creates smaller code.
*/

#include <stddef.h>

class CNewException {};

#ifdef WIN32
// We can compile my_new and my_delete with _fastcall
/*
void * my_new(size_t size);
void my_delete(void *p) throw();
// void * my_Realloc(void *p, size_t newSize, size_t oldSize);
*/
#endif

#ifdef _WIN32

void *
#ifdef _MSC_VER
__cdecl
#endif
operator new(size_t size);

void
#ifdef _MSC_VER
__cdecl
#endif
operator delete(void *p) throw();

#endif

/*
#ifdef _WIN32
void *
#ifdef _MSC_VER
__cdecl
#endif
operator new[](size_t size);

void
#ifdef _MSC_VER
__cdecl
#endif
operator delete[](void *p) throw();
#endif
*/

#endif
// Common/Random.h

#ifndef __COMMON_RANDOM_H
#define __COMMON_RANDOM_H

class CRandom
{
public:
  void Init();
  void Init(unsigned int seed);
  int Generate() const;
};

#endif
// Sha1Reg.cpp

#include "StdAfx.h"

#include "../../C/Sha1.h"

#include "../Common/MyCom.h"

#include "../7zip/Common/RegisterCodec.h"

class CSha1Hasher:
  public IHasher,
  public CMyUnknownImp
{
  CSha1 _sha;
  Byte mtDummy[1 << 7];
  
public:
  CSha1Hasher() { Sha1_Init(&_sha); }

  MY_UNKNOWN_IMP1(IHasher)
  INTERFACE_IHasher(;)
};

STDMETHODIMP_(void) CSha1Hasher::Init() throw()
{
  Sha1_Init(&_sha);
}

STDMETHODIMP_(void) CSha1Hasher::Update(const void *data, UInt32 size) throw()
{
  Sha1_Update(&_sha, (const Byte *)data, size);
}

STDMETHODIMP_(void) CSha1Hasher::Final(Byte *digest) throw()
{
  Sha1_Final(&_sha, digest);
}

REGISTER_HASHER(CSha1Hasher, 0x201, "SHA1", SHA1_DIGEST_SIZE)
// Sha256Reg.cpp

#include "StdAfx.h"

#include "../../C/Sha256.h"

#include "../Common/MyCom.h"

#include "../7zip/Common/RegisterCodec.h"

class CSha256Hasher:
  public IHasher,
  public CMyUnknownImp
{
  CSha256 _sha;
  Byte mtDummy[1 << 7];

public:
  CSha256Hasher() { Sha256_Init(&_sha); }

  MY_UNKNOWN_IMP1(IHasher)
  INTERFACE_IHasher(;)
};

STDMETHODIMP_(void) CSha256Hasher::Init() throw()
{
  Sha256_Init(&_sha);
}

STDMETHODIMP_(void) CSha256Hasher::Update(const void *data, UInt32 size) throw()
{
  Sha256_Update(&_sha, (const Byte *)data, size);
}

STDMETHODIMP_(void) CSha256Hasher::Final(Byte *digest) throw()
{
  Sha256_Final(&_sha, digest);
}

REGISTER_HASHER(CSha256Hasher, 0xA, "SHA256", SHA256_DIGEST_SIZE)
// Common/StdInStream.cpp

#include "StdAfx.h"

#include <tchar.h>

#include "StdInStream.h"
#include "StringConvert.h"
#include "UTFConvert.h"

static const char kNewLineChar = '\n';

static const char *kEOFMessage = "Unexpected end of input stream";
static const char *kReadErrorMessage  ="Error reading input stream";
static const char *kIllegalCharMessage = "Illegal character in input stream";

// static LPCTSTR kFileOpenMode = TEXT("r");

// extern int g_CodePage;

#ifdef _UNICODE
#define NEED_NAME_WINDOWS_TO_UNIX
#include "myPrivate.h"
#endif

CStdInStream g_StdIn(stdin);

bool CStdInStream::Open(LPCTSTR fileName) throw()
{
  Close();
//  _stream = _tfopen(fileName, kFileOpenMode);
#ifdef _UNICODE
  AString aStr = UnicodeStringToMultiByte(fileName, CP_ACP); // FIXME
  const char * name = nameWindowToUnix(aStr);
#else
  const char * name = nameWindowToUnix(fileName);
#endif
  _stream = fopen(name, "r");
  _streamIsOpen = (_stream != 0);
  return _streamIsOpen;
}

bool CStdInStream::Close() throw()
{
  if (!_streamIsOpen)
    return true;
  _streamIsOpen = (fclose(_stream) != 0);
  return !_streamIsOpen;
}

AString CStdInStream::ScanStringUntilNewLine(bool allowEOF)
{
  AString s;
  for (;;)
  {
    int intChar = GetChar();
    if (intChar == EOF)
    {
      if (allowEOF)
        break;
      throw kEOFMessage;
    }
    char c = (char)intChar;
    if (c == 0)
      throw kIllegalCharMessage;
    if (c == kNewLineChar)
      break;
    s += c;
  }
  return s;
}

#ifdef _WIN32
UString CStdInStream::ScanUStringUntilNewLine()
{
  AString s = ScanStringUntilNewLine(true);
  int codePage = g_CodePage;
  if (codePage == -1)
    codePage = CP_OEMCP;
  UString dest;
  if (codePage == CP_UTF8)
    ConvertUTF8ToUnicode(s, dest);
  else
    dest = MultiByteToUnicodeString(s, (UINT)codePage);
  return dest;
}
#else

#ifndef ENV_HAVE_GETPASS
UString CStdInStream::ScanUStringUntilNewLine()
{
  AString s = ScanStringUntilNewLine(true);
  UString dest = MultiByteToUnicodeString(s, (UINT)-1);
  return dest;
}
#endif

#endif

void CStdInStream::ReadToString(AString &resultString)
{
  resultString.Empty();
  int c;
  while ((c = GetChar()) != EOF)
    resultString += (char)c;
}

bool CStdInStream::Eof() throw()
{
  return (feof(_stream) != 0);
}

int CStdInStream::GetChar()
{
  int c = fgetc(_stream); // getc() doesn't work in BeOS?
  if (c == EOF && !Eof())
    throw kReadErrorMessage;
  return c;
}
// Common/StdInStream.h

#ifndef __COMMON_STD_IN_STREAM_H
#define __COMMON_STD_IN_STREAM_H

#include <stdio.h>

#include "MyString.h"
#include "MyTypes.h"

class CStdInStream
{
  FILE *_stream;
  bool _streamIsOpen;
public:
  CStdInStream(): _stream(0), _streamIsOpen(false) {};
  CStdInStream(FILE *stream): _stream(stream), _streamIsOpen(false) {};
  ~CStdInStream() { Close(); }

  bool Open(LPCTSTR fileName) throw();
  bool Close() throw();

  AString ScanStringUntilNewLine(bool allowEOF = false);
  void ReadToString(AString &resultString);
  UString ScanUStringUntilNewLine();

  bool Eof() throw();
  int GetChar();
};

extern CStdInStream g_StdIn;

#endif
// Common/StdOutStream.cpp

#include "StdAfx.h"

#include <tchar.h>

#include "IntToString.h"
#include "StdOutStream.h"
#include "StringConvert.h"
#include "UTFConvert.h"

static const char kNewLineChar =  '\n';

static const char *kFileOpenMode = "wt";

extern int g_CodePage;

CStdOutStream g_StdOut(stdout);
CStdOutStream g_StdErr(stderr);

bool CStdOutStream::Open(const char *fileName) throw()
{
  Close();
  _stream = fopen(fileName, kFileOpenMode);
  _streamIsOpen = (_stream != 0);
  return _streamIsOpen;
}

bool CStdOutStream::Close() throw()
{
  if (!_streamIsOpen)
    return true;
  if (fclose(_stream) != 0)
    return false;
  _stream = 0;
  _streamIsOpen = false;
  return true;
}

bool CStdOutStream::Flush() throw()
{
  return (fflush(_stream) == 0);
}

CStdOutStream & endl(CStdOutStream & outStream) throw()
{
  return outStream << kNewLineChar;
}

CStdOutStream & CStdOutStream::operator<<(const wchar_t *s)
{
  int codePage = g_CodePage;
  if (codePage == -1)
    codePage = CP_OEMCP;
  AString dest;
  if (codePage == CP_UTF8)
    ConvertUnicodeToUTF8(s, dest);
  else
    UnicodeStringToMultiByte2(dest, s, (UINT)codePage);
  return operator<<((const char *)dest);
}

void StdOut_Convert_UString_to_AString(const UString &s, AString &temp)
{
  int codePage = g_CodePage;
  if (codePage == -1)
    codePage = CP_OEMCP;
  if (codePage == CP_UTF8)
    ConvertUnicodeToUTF8(s, temp);
  else
    UnicodeStringToMultiByte2(temp, s, (UINT)codePage);
}

void CStdOutStream::PrintUString(const UString &s, AString &temp)
{
  StdOut_Convert_UString_to_AString(s, temp);
  *this << (const char *)temp;
}

CStdOutStream & CStdOutStream::operator<<(Int32 number) throw()
{
  char s[32];
  ConvertInt64ToString(number, s);
  return operator<<(s);
}

CStdOutStream & CStdOutStream::operator<<(Int64 number) throw()
{
  char s[32];
  ConvertInt64ToString(number, s);
  return operator<<(s);
}

CStdOutStream & CStdOutStream::operator<<(UInt32 number) throw()
{
  char s[16];
  ConvertUInt32ToString(number, s);
  return operator<<(s);
}

CStdOutStream & CStdOutStream::operator<<(UInt64 number) throw()
{
  char s[32];
  ConvertUInt64ToString(number, s);
  return operator<<(s);
}
// Common/StdOutStream.h

#ifndef __COMMON_STD_OUT_STREAM_H
#define __COMMON_STD_OUT_STREAM_H

#include <stdio.h>

#include "MyString.h"
#include "MyTypes.h"

class CStdOutStream
{
  FILE *_stream;
  bool _streamIsOpen;
public:
  CStdOutStream(): _stream(0), _streamIsOpen(false) {};
  CStdOutStream(FILE *stream): _stream(stream), _streamIsOpen(false) {};
  ~CStdOutStream() { Close(); }

  // void AttachStdStream(FILE *stream) { _stream  = stream; _streamIsOpen = false; }
  // bool IsDefined() const { return _stream  != NULL; }

  operator FILE *() { return _stream; }
  bool Open(const char *fileName) throw();
  bool Close() throw();
  bool Flush() throw();
  
  CStdOutStream & operator<<(CStdOutStream & (* func)(CStdOutStream  &))
  {
    (*func)(*this);
    return *this;
  }

  CStdOutStream & operator<<(const char *s) throw()
  {
    fputs(s, _stream);
    return *this;
  }

  CStdOutStream & operator<<(char c) throw()
  {
    fputc((unsigned char)c, _stream);
    return *this;
  }

  CStdOutStream & operator<<(Int32 number) throw();
  CStdOutStream & operator<<(Int64 number) throw();
  CStdOutStream & operator<<(UInt32 number) throw();
  CStdOutStream & operator<<(UInt64 number) throw();

  CStdOutStream & operator<<(const wchar_t *s);
  void PrintUString(const UString &s, AString &temp);
};

CStdOutStream & endl(CStdOutStream & outStream) throw();

extern CStdOutStream g_StdOut;
extern CStdOutStream g_StdErr;

void StdOut_Convert_UString_to_AString(const UString &s, AString &temp);

#endif
// Common/StringConvert.cpp

#include "StdAfx.h"

#include "StringConvert.h"
extern "C"
{
int global_use_utf16_conversion = 0;
}

#ifdef LOCALE_IS_UTF8

#ifdef __APPLE_CC__
#define UInt32  macUIn32
#include <CoreFoundation/CoreFoundation.h>
#undef UInt32

UString MultiByteToUnicodeString(const AString &srcString, UINT codePage)
{
  if (!srcString.IsEmpty())
  {
    UString resultString;
    const char * path = &srcString[0];

// FIXME    size_t n = strlen(path);

    CFStringRef cfpath = CFStringCreateWithCString(NULL,path,kCFStringEncodingUTF8);

    if (cfpath)
    {

       CFMutableStringRef cfpath2 = CFStringCreateMutableCopy(NULL,0,cfpath);
       CFRelease(cfpath);
       CFStringNormalize(cfpath2,kCFStringNormalizationFormC);
    
       size_t n = CFStringGetLength(cfpath2);
       for(size_t i =   0 ; i< n ;i++) {
         UniChar uc = CFStringGetCharacterAtIndex(cfpath2,i);
         resultString += (wchar_t)uc; // FIXME
       }

       CFRelease(cfpath2);  

       return resultString;
    }
  }

  UString resultString;
  for (int i = 0; i < srcString.Len(); i++)
    resultString += wchar_t(srcString[i] & 255);

  return resultString;
}

AString UnicodeStringToMultiByte(const UString &srcString, UINT codePage)
{
  if (!srcString.IsEmpty())
  {
    const wchar_t * wcs = &srcString[0];
    char utf8[4096];
    UniChar unipath[4096];

    size_t n = wcslen(wcs);

    for(size_t i =   0 ; i<= n ;i++) {
      unipath[i] = wcs[i];
    }

    CFStringRef cfpath = CFStringCreateWithCharacters(NULL,unipath,n);

    CFMutableStringRef cfpath2 = CFStringCreateMutableCopy(NULL,0,cfpath);
    CFRelease(cfpath);
    CFStringNormalize(cfpath2,kCFStringNormalizationFormD);
    
    CFStringGetCString(cfpath2,(char *)utf8,4096,kCFStringEncodingUTF8);

    CFRelease(cfpath2);  

    return AString(utf8);
  }

  AString resultString;
  for (int i = 0; i < srcString.Len(); i++)
  {
    if (srcString[i] >= 256) resultString += '?';
    else                     resultString += char(srcString[i]);
  }
  return resultString;
}

#else /* __APPLE_CC__ */


#include "UTFConvert.h"

UString MultiByteToUnicodeString(const AString &srcString, UINT codePage)
{
  if ((global_use_utf16_conversion) && (!srcString.IsEmpty()))
  {
    UString resultString;
    bool bret = ConvertUTF8ToUnicode(srcString,resultString);
    if (bret) return resultString;
  }

  UString resultString;
  for (int i = 0; i < srcString.Len(); i++)
    resultString += wchar_t(srcString[i] & 255);

  return resultString;
}

AString UnicodeStringToMultiByte(const UString &srcString, UINT codePage)
{
  if ((global_use_utf16_conversion) && (!srcString.IsEmpty()))
  {
    AString resultString;
    ConvertUnicodeToUTF8(srcString,resultString);
    return resultString;
  }

  AString resultString;
  for (int i = 0; i < srcString.Len(); i++)
  {
    if (srcString[i] >= 256) resultString += '?';
    else                     resultString += char(srcString[i]);
  }
  return resultString;
}

#endif /* __APPLE_CC__ */

#else /* LOCALE_IS_UTF8 */

UString MultiByteToUnicodeString(const AString &srcString, UINT /* codePage */ )
{
#ifdef ENV_HAVE_MBSTOWCS
  if ((global_use_utf16_conversion) && (!srcString.IsEmpty()))
  {
    UString resultString;
    int numChars = mbstowcs(resultString.GetBuf(srcString.Len()),srcString,srcString.Len()+1);
    if (numChars >= 0) {
        resultString.ReleaseBuf_SetEnd(numChars);

#if WCHAR_MAX > 0xffff
      for (int i = numChars; i >= 0; i--) {
        if (resultString[i] > 0xffff) {
          wchar_t c = resultString[i] - 0x10000;
          resultString.Delete(i);
          wchar_t texts[]= { ((c >> 10) & 0x3ff) + 0xd800,  (c & 0x3ff) + 0xdc00 , 0 };
          resultString.Insert(i, texts);
          numChars++;
        }
      }
#endif

      return resultString;
    }
  }
#endif

  UString resultString;
  for (int i = 0; i < srcString.Len(); i++)
    resultString += wchar_t(srcString[i] & 255);

  return resultString;
}

AString UnicodeStringToMultiByte(const UString &src, UINT /* codePage */ )
{
#ifdef ENV_HAVE_WCSTOMBS
#if WCHAR_MAX > 0xffff
  UString srcString(src);
  for (int i = 0; i < srcString.Len(); i++) {
    if ((0xd800 <= srcString[i] && srcString[i] <= 0xdbff) && ((i + 1) < srcString.Len()) &&
        (0xdc00 <= srcString[i + 1] && srcString[i + 1] < 0xE000)) {
      wchar_t c = (((srcString[i] - 0xd800) << 10) | (srcString[i + 1] - 0xdc00)) + 0x10000;
      srcString.Delete(i, 2);
      srcString.Insert(i, c);
    }
  }
#else
  const UString &srcString = src;
#endif

  if ((global_use_utf16_conversion) && (!srcString.IsEmpty()))
  {
    AString resultString;
    int numRequiredBytes = srcString.Len() * 6+1;
    int numChars = wcstombs(resultString.GetBuf(numRequiredBytes),srcString,numRequiredBytes);
    if (numChars >= 0) {
      resultString.ReleaseBuf_SetEnd(numChars);
      return resultString;
    }
  }
#else
  const UString &srcString = src;
#endif

  AString resultString;
  for (int i = 0; i < srcString.Len(); i++)
  {
    if (srcString[i] >= 256) resultString += '?';
    else                     resultString += char(srcString[i]);
  }
  return resultString;
}

#endif /* LOCALE_IS_UTF8 */


void MultiByteToUnicodeString2(UString &dest, const AString &srcString, UINT codePage)
{
  dest = MultiByteToUnicodeString(srcString,codePage);
}

void UnicodeStringToMultiByte2(AString &dest, const UString &srcString, UINT codePage)
{
  dest = UnicodeStringToMultiByte(srcString,codePage);
}

// Common/StringConvert.h

#ifndef __COMMON_STRING_CONVERT_H
#define __COMMON_STRING_CONVERT_H

#include "MyString.h"
#include "MyWindows.h"

UString MultiByteToUnicodeString(const AString &srcString, UINT codePage = CP_ACP);

// optimized versions that work faster for ASCII strings
void MultiByteToUnicodeString2(UString &dest, const AString &srcString, UINT codePage = CP_ACP);
// void UnicodeStringToMultiByte2(AString &dest, const UString &s, UINT codePage, char defaultChar, bool &defaultCharWasUsed);
void UnicodeStringToMultiByte2(AString &dest, const UString &srcString, UINT codePage);

AString UnicodeStringToMultiByte(const UString &srcString, UINT codePage, char defaultChar, bool &defaultCharWasUsed);
AString UnicodeStringToMultiByte(const UString &srcString, UINT codePage = CP_ACP);

inline const wchar_t* GetUnicodeString(const wchar_t* unicodeString)
  { return unicodeString; }
inline const UString& GetUnicodeString(const UString &unicodeString)
  { return unicodeString; }
inline UString GetUnicodeString(const AString &ansiString)
  { return MultiByteToUnicodeString(ansiString); }
inline UString GetUnicodeString(const AString &multiByteString, UINT codePage)
  { return MultiByteToUnicodeString(multiByteString, codePage); }
inline const wchar_t* GetUnicodeString(const wchar_t* unicodeString, UINT)
  { return unicodeString; }
inline const UString& GetUnicodeString(const UString &unicodeString, UINT)
  { return unicodeString; }

inline const char* GetAnsiString(const char* ansiString)
  { return ansiString; }
inline const AString& GetAnsiString(const AString &ansiString)
  { return ansiString; }
inline AString GetAnsiString(const UString &unicodeString)
  { return UnicodeStringToMultiByte(unicodeString); }

inline const char* GetOemString(const char* oemString)
  { return oemString; }
inline const AString& GetOemString(const AString &oemString)
  { return oemString; }
inline AString GetOemString(const UString &unicodeString)
  { return UnicodeStringToMultiByte(unicodeString, CP_OEMCP); }


#ifdef _UNICODE
  inline const wchar_t* GetSystemString(const wchar_t* unicodeString)
    { return unicodeString;}
  inline const UString& GetSystemString(const UString &unicodeString)
    { return unicodeString;}
  inline const wchar_t* GetSystemString(const wchar_t* unicodeString, UINT /* codePage */)
    { return unicodeString;}
  inline const UString& GetSystemString(const UString &unicodeString, UINT /* codePage */)
    { return unicodeString;}
  inline UString GetSystemString(const AString &multiByteString, UINT codePage)
    { return MultiByteToUnicodeString(multiByteString, codePage);}
  inline UString GetSystemString(const AString &multiByteString)
    { return MultiByteToUnicodeString(multiByteString);}
#else
  inline const char* GetSystemString(const char *ansiString)
    { return ansiString; }
  inline const AString& GetSystemString(const AString &multiByteString, UINT)
    { return multiByteString; }
  inline const char * GetSystemString(const char *multiByteString, UINT)
    { return multiByteString; }
  inline AString GetSystemString(const UString &unicodeString)
    { return UnicodeStringToMultiByte(unicodeString); }
  inline AString GetSystemString(const UString &unicodeString, UINT codePage)
    { return UnicodeStringToMultiByte(unicodeString, codePage); }
#endif

#ifndef UNDER_CE
AString SystemStringToOemString(const CSysString &srcString);
#endif

#endif
// Common/StringToInt.cpp

#include "StdAfx.h"

#include "StringToInt.h"

static const UInt32 k_UInt32_max = 0xFFFFFFFF;
static const UInt64 k_UInt64_max = UINT64_CONST(0xFFFFFFFFFFFFFFFF);
// static const UInt64 k_UInt64_max = (UInt64)(Int64)-1;

#define CONVERT_STRING_TO_UINT_FUNC(uintType, charType, charTypeUnsigned) \
  uintType ConvertStringTo ## uintType(const charType *s, const charType **end) throw() { \
    if (end) *end = s; \
    uintType res = 0; \
    for (;; s++) { \
      charTypeUnsigned c = (charTypeUnsigned)*s; \
      if (c < '0' || c > '9') { if (end) *end = s; return res; } \
      if (res > (k_ ## uintType ## _max) / 10) return 0; \
      res *= 10; \
      unsigned v = (c - '0'); \
      if (res > (k_ ## uintType ## _max) - v) return 0; \
      res += v; }}

CONVERT_STRING_TO_UINT_FUNC(UInt32, char, Byte)
CONVERT_STRING_TO_UINT_FUNC(UInt32, wchar_t, wchar_t)
CONVERT_STRING_TO_UINT_FUNC(UInt64, char, Byte)
CONVERT_STRING_TO_UINT_FUNC(UInt64, wchar_t, wchar_t)

Int32 ConvertStringToInt32(const wchar_t *s, const wchar_t **end) throw()
{
  if (end)
    *end = s;
  const wchar_t *s2 = s;
  if (*s == '-')
    s2++;
  if (*s2 == 0)
    return 0;
  const wchar_t *end2;
  UInt32 res = ConvertStringToUInt32(s2, &end2);
  if (*s == '-')
  {
    if (res > ((UInt32)1 << (32 - 1)))
      return 0;
  }
  else if ((res & ((UInt32)1 << (32 - 1))) != 0)
    return 0;
  if (end)
    *end = end2;
  if (*s == '-')
    return -(Int32)res;
  return (Int32)res;
}

UInt32 ConvertOctStringToUInt32(const char *s, const char **end) throw()
{
  if (end)
    *end = s;
  UInt32 res = 0;
  for (;; s++)
  {
    unsigned c = (unsigned char)*s;
    if (c < '0' || c > '7')
    {
      if (end)
        *end = s;
      return res;
    }
    if ((res & (UInt32)7 << (32 - 3)) != 0)
      return 0;
    res <<= 3;
    res |= (unsigned)(c - '0');
  }
}

UInt64 ConvertOctStringToUInt64(const char *s, const char **end) throw()
{
  if (end)
    *end = s;
  UInt64 res = 0;
  for (;; s++)
  {
    unsigned c = (unsigned char)*s;
    if (c < '0' || c > '7')
    {
      if (end)
        *end = s;
      return res;
    }
    if ((res & (UInt64)7 << (64 - 3)) != 0)
      return 0;
    res <<= 3;
    res |= (unsigned)(c - '0');
  }
}

UInt32 ConvertHexStringToUInt32(const char *s, const char **end) throw()
{
  if (end)
    *end = s;
  UInt32 res = 0;
  for (;; s++)
  {
    unsigned c = (Byte)*s;
    unsigned v;
    if (c >= '0' && c <= '9') v = (c - '0');
    else if (c >= 'A' && c <= 'F') v = 10 + (c - 'A');
    else if (c >= 'a' && c <= 'f') v = 10 + (c - 'a');
    else
    {
      if (end)
        *end = s;
      return res;
    }
    if ((res & (UInt32)0xF << (32 - 4)) != 0)
      return 0;
    res <<= 4;
    res |= v;
  }
}

UInt64 ConvertHexStringToUInt64(const char *s, const char **end) throw()
{
  if (end)
    *end = s;
  UInt64 res = 0;
  for (;; s++)
  {
    unsigned c = (Byte)*s;
    unsigned v;
    if (c >= '0' && c <= '9') v = (c - '0');
    else if (c >= 'A' && c <= 'F') v = 10 + (c - 'A');
    else if (c >= 'a' && c <= 'f') v = 10 + (c - 'a');
    else
    {
      if (end)
        *end = s;
      return res;
    }
    if ((res & (UInt64)0xF << (64 - 4)) != 0)
      return 0;
    res <<= 4;
    res |= v;
  }
}
// Common/StringToInt.h

#ifndef __COMMON_STRING_TO_INT_H
#define __COMMON_STRING_TO_INT_H

#include "MyTypes.h"

UInt32 ConvertStringToUInt32(const char *s, const char **end) throw();
UInt64 ConvertStringToUInt64(const char *s, const char **end) throw();
UInt32 ConvertStringToUInt32(const wchar_t *s, const wchar_t **end) throw();
UInt64 ConvertStringToUInt64(const wchar_t *s, const wchar_t **end) throw();

Int32 ConvertStringToInt32(const wchar_t *s, const wchar_t **end) throw();

UInt32 ConvertOctStringToUInt32(const char *s, const char **end) throw();
UInt64 ConvertOctStringToUInt64(const char *s, const char **end) throw();

UInt32 ConvertHexStringToUInt32(const char *s, const char **end) throw();
UInt64 ConvertHexStringToUInt64(const char *s, const char **end) throw();

#endif
// Common/TextConfig.cpp

#include "StdAfx.h"

#include "TextConfig.h"
#include "UTFConvert.h"

static inline bool IsDelimitChar(char c)
{
  return (c == ' ' || c == 0x0A || c == 0x0D || c == '\0' || c == '\t');
}
    
static AString GetIDString(const char *s, unsigned &finishPos)
{
  AString result;
  for (finishPos = 0; ; finishPos++)
  {
    char c = s[finishPos];
    if (IsDelimitChar(c) || c == '=')
      break;
    result += c;
  }
  return result;
}

static bool WaitNextLine(const AString &s, unsigned &pos)
{
  for (; pos < s.Len(); pos++)
    if (s[pos] == 0x0A)
      return true;
  return false;
}

static bool SkipSpaces(const AString &s, unsigned &pos)
{
  for (; pos < s.Len(); pos++)
  {
    char c = s[pos];
    if (!IsDelimitChar(c))
    {
      if (c != ';')
        return true;
      if (!WaitNextLine(s, pos))
        return false;
    }
  }
  return false;
}

bool GetTextConfig(const AString &s, CObjectVector<CTextConfigPair> &pairs)
{
  pairs.Clear();
  unsigned pos = 0;

  /////////////////////
  // read strings

  for (;;)
  {
    if (!SkipSpaces(s, pos))
      break;
    CTextConfigPair pair;
    unsigned finishPos;
    AString temp = GetIDString(((const char *)s) + pos, finishPos);
    if (!ConvertUTF8ToUnicode(temp, pair.ID))
      return false;
    if (finishPos == 0)
      return false;
    pos += finishPos;
    if (!SkipSpaces(s, pos))
      return false;
    if (s[pos] != '=')
      return false;
    pos++;
    if (!SkipSpaces(s, pos))
      return false;
    if (s[pos] != '\"')
      return false;
    pos++;
    AString message;
    for (;;)
    {
      if (pos >= s.Len())
        return false;
      char c = s[pos++];
      if (c == '\"')
        break;
      if (c == '\\')
      {
        c = s[pos++];
        switch (c)
        {
          case 'n': message += '\n'; break;
          case 't': message += '\t'; break;
          case '\\': message += '\\'; break;
          case '\"': message += '\"'; break;
          default: message += '\\'; message += c; break;
        }
      }
      else
        message += c;
    }
    if (!ConvertUTF8ToUnicode(message, pair.String))
      return false;
    pairs.Add(pair);
  }
  return true;
}

int FindTextConfigItem(const CObjectVector<CTextConfigPair> &pairs, const UString &id) throw()
{
  FOR_VECTOR (i, pairs)
    if (pairs[i].ID == id)
      return i;
  return -1;
}

UString GetTextConfigValue(const CObjectVector<CTextConfigPair> &pairs, const UString &id)
{
  int index = FindTextConfigItem(pairs, id);
  if (index < 0)
    return UString();
  return pairs[index].String;
}
// Common/TextConfig.h

#ifndef __COMMON_TEXT_CONFIG_H
#define __COMMON_TEXT_CONFIG_H

#include "MyString.h"

struct CTextConfigPair
{
  UString ID;
  UString String;
};

bool GetTextConfig(const AString &text, CObjectVector<CTextConfigPair> &pairs);

int FindTextConfigItem(const CObjectVector<CTextConfigPair> &pairs, const UString &id) throw();
UString GetTextConfigValue(const CObjectVector<CTextConfigPair> &pairs, const UString &id);

#endif
// UTFConvert.cpp

#include "StdAfx.h"

#include "MyTypes.h"
#include "UTFConvert.h"

#ifdef _WIN32
#define _WCHART_IS_16BIT 1
#endif

/*
  _UTF8_START(n) - is a base value for start byte (head), if there are (n) additional bytes after start byte
  
  n : _UTF8_START(n) : Bits of code point

  0 : 0x80 :    : unused
  1 : 0xC0 : 11 :
  2 : 0xE0 : 16 : Basic Multilingual Plane
  3 : 0xF0 : 21 : Unicode space
  3 : 0xF8 : 26 :
  5 : 0xFC : 31 : UCS-4
  6 : 0xFE : 36 : We can use it, if we want to encode any 32-bit value
  7 : 0xFF :
*/

#define _UTF8_START(n) (0x100 - (1 << (7 - (n))))

#define _UTF8_HEAD_PARSE2(n) if (c < _UTF8_START((n) + 1)) { numBytes = (n); c -= _UTF8_START(n); }

#define _UTF8_HEAD_PARSE \
         _UTF8_HEAD_PARSE2(1) \
    else _UTF8_HEAD_PARSE2(2) \
    else _UTF8_HEAD_PARSE2(3) \
    else _UTF8_HEAD_PARSE2(4) \
    else _UTF8_HEAD_PARSE2(5) \

    // else _UTF8_HEAD_PARSE2(6)

bool CheckUTF8(const char *src, bool allowReduced) throw()
{
  for (;;)
  {
    Byte c = *src++;
    if (c == 0)
      return true;

    if (c < 0x80)
      continue;
    if (c < 0xC0)   // (c < 0xC0 + 2) // if we support only optimal encoding chars
      return false;
    
    unsigned numBytes;
    _UTF8_HEAD_PARSE
    else
      return false;
    
    UInt32 val = c;

    do
    {
      Byte c2 = *src++;
      if (c2 < 0x80 || c2 >= 0xC0)
        return allowReduced && c2 == 0;
      val <<= 6;
      val |= (c2 - 0x80);
    }
    while (--numBytes);
    
    if (val >= 0x110000)
      return false;
  }
}


#define _ERROR_UTF8 \
  { if (dest) dest[destPos] = (wchar_t)0xFFFD; destPos++; ok = false; continue; }

static bool Utf8_To_Utf16(wchar_t *dest, size_t *destLen, const char *src, const char *srcLim) throw()
{
  size_t destPos = 0;
  bool ok = true;

  for (;;)
  {
    Byte c;
    if (src == srcLim)
    {
      *destLen = destPos;
      return ok;
    }
    c = *src++;

    if (c < 0x80)
    {
      if (dest)
        dest[destPos] = (wchar_t)c;
      destPos++;
      continue;
    }
    if (c < 0xC0)
      _ERROR_UTF8

    unsigned numBytes;
    _UTF8_HEAD_PARSE
    else
      _ERROR_UTF8
    
    UInt32 val = c;

    do
    {
      Byte c2;
      if (src == srcLim)
        break;
      c2 = *src;
      if (c2 < 0x80 || c2 >= 0xC0)
        break;
      src++;
      val <<= 6;
      val |= (c2 - 0x80);
    }
    while (--numBytes);

    if (numBytes != 0)
      _ERROR_UTF8

    if (val < 0x10000)
    {
      if (dest)
        dest[destPos] = (wchar_t)val;
      destPos++;
    }
    else
    {
      val -= 0x10000;
      if (val >= 0x100000)
        _ERROR_UTF8
      if (dest)
      {
        dest[destPos + 0] = (wchar_t)(0xD800 + (val >> 10));
        dest[destPos + 1] = (wchar_t)(0xDC00 + (val & 0x3FF));
      }
      destPos += 2;
    }
  }
}

#define _UTF8_RANGE(n) (((UInt32)1) << ((n) * 5 + 6))

#define _UTF8_HEAD(n, val) ((char)(_UTF8_START(n) + (val >> (6 * (n)))))
#define _UTF8_CHAR(n, val) ((char)(0x80 + (((val) >> (6 * (n))) & 0x3F)))

static size_t Utf16_To_Utf8_Calc(const wchar_t *src, const wchar_t *srcLim)
{
  size_t size = srcLim - src;
  for (;;)
  {
    if (src == srcLim)
      return size;
    
    UInt32 val = *src++;
   
    if (val < 0x80)
      continue;

    if (val < _UTF8_RANGE(1))
    {
      size++;
      continue;
    }

    if (val >= 0xD800 && val < 0xDC00 && src != srcLim)
    {
      UInt32 c2 = *src;
      if (c2 >= 0xDC00 && c2 < 0xE000)
      {
        src++;
        size += 2;
        continue;
      }
    }

    #ifdef _WCHART_IS_16BIT
    
    size += 2;
    
    #else

         if (val < _UTF8_RANGE(2)) size += 2;
    else if (val < _UTF8_RANGE(3)) size += 3;
    else if (val < _UTF8_RANGE(4)) size += 4;
    else if (val < _UTF8_RANGE(5)) size += 5;
    else                           size += 6;
    
    #endif
  }
}

static char *Utf16_To_Utf8(char *dest, const wchar_t *src, const wchar_t *srcLim)
{
  for (;;)
  {
    if (src == srcLim)
      return dest;
    
    UInt32 val = *src++;
    
    if (val < 0x80)
    {
      *dest++ = (char)val;
      continue;
    }

    if (val < _UTF8_RANGE(1))
    {
      dest[0] = _UTF8_HEAD(1, val);
      dest[1] = _UTF8_CHAR(0, val);
      dest += 2;
      continue;
    }

    if (val >= 0xD800 && val < 0xDC00 && src != srcLim)
    {
      UInt