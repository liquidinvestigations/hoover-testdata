32 c2 = *src;
      if (c2 >= 0xDC00 && c2 < 0xE000)
      {
        src++;
        val = (((val - 0xD800) << 10) | (c2 - 0xDC00)) + 0x10000;
        dest[0] = _UTF8_HEAD(3, val);
        dest[1] = _UTF8_CHAR(2, val);
        dest[2] = _UTF8_CHAR(1, val);
        dest[3] = _UTF8_CHAR(0, val);
        dest += 4;
        continue;
      }
    }
    
    #ifndef _WCHART_IS_16BIT
    if (val < _UTF8_RANGE(2))
    #endif
    {
      dest[0] = _UTF8_HEAD(2, val);
      dest[1] = _UTF8_CHAR(1, val);
      dest[2] = _UTF8_CHAR(0, val);
      dest += 3;
      continue;
    }
    
    #ifndef _WCHART_IS_16BIT

    UInt32 b;
    unsigned numBits;
         if (val < _UTF8_RANGE(3)) { numBits = 6 * 3; b = _UTF8_HEAD(3, val); }
    else if (val < _UTF8_RANGE(4)) { numBits = 6 * 4; b = _UTF8_HEAD(4, val); }
    else if (val < _UTF8_RANGE(5)) { numBits = 6 * 5; b = _UTF8_HEAD(5, val); }
    else                           { numBits = 6 * 6; b = _UTF8_START(6); }
    
    *dest++ = (Byte)b;
    
    do
    {
      numBits -= 6;
      *dest++ = (char)(0x80 + ((val >> numBits) & 0x3F));
    }
    while (numBits != 0);

    #endif
  }
}

bool ConvertUTF8ToUnicode(const AString &src, UString &dest)
{
  dest.Empty();
  size_t destLen = 0;
  Utf8_To_Utf16(NULL, &destLen, src, src.Ptr(src.Len()));
  bool res = Utf8_To_Utf16(dest.GetBuf((unsigned)destLen), &destLen, src, src.Ptr(src.Len()));
  dest.ReleaseBuf_SetEnd((unsigned)destLen);
  return res;
}

void ConvertUnicodeToUTF8(const UString &src, AString &dest)
{
  dest.Empty();
  size_t destLen = Utf16_To_Utf8_Calc(src, src.Ptr(src.Len()));
  Utf16_To_Utf8(dest.GetBuf((unsigned)destLen), src, src.Ptr(src.Len()));
  dest.ReleaseBuf_SetEnd((unsigned)destLen);
}
// Common/UTFConvert.h

#ifndef __COMMON_UTF_CONVERT_H
#define __COMMON_UTF_CONVERT_H

#include "MyString.h"

bool CheckUTF8(const char *src, bool allowReduced = false) throw();
bool ConvertUTF8ToUnicode(const AString &utfString, UString &resultString);
void ConvertUnicodeToUTF8(const UString &unicodeString, AString &resultString);

#endif
// Common/Wildcard.cpp

#include "StdAfx.h"

#include "Wildcard.h"

bool g_CaseSensitive =
  #ifdef _WIN32
    false;
  #else
    true;
  #endif


bool IsPath1PrefixedByPath2(const wchar_t *s1, const wchar_t *s2)
{
  if (g_CaseSensitive)
    return IsString1PrefixedByString2(s1, s2);
  return IsString1PrefixedByString2_NoCase(s1, s2);
}

int CompareFileNames(const wchar_t *s1, const wchar_t *s2) STRING_UNICODE_THROW
{
  if (g_CaseSensitive)
    return wcscmp(s1, s2);
  return MyStringCompareNoCase(s1, s2);
}

#ifndef USE_UNICODE_FSTRING
int CompareFileNames(const char *s1, const char *s2)
{
  if (g_CaseSensitive)
    return wcscmp(fs2us(s1), fs2us(s2));
  return MyStringCompareNoCase(fs2us(s1), fs2us(s2));
}
#endif

// -----------------------------------------
// this function compares name with mask
// ? - any char
// * - any char or empty

static bool EnhancedMaskTest(const wchar_t *mask, const wchar_t *name)
{
  for (;;)
  {
    wchar_t m = *mask;
    wchar_t c = *name;
    if (m == 0)
      return (c == 0);
    if (m == '*')
    {
      if (EnhancedMaskTest(mask + 1, name))
        return true;
      if (c == 0)
        return false;
    }
    else
    {
      if (m == '?')
      {
        if (c == 0)
          return false;
      }
      else if (m != c)
        if (g_CaseSensitive || MyCharUpper(m) != MyCharUpper(c))
          return false;
      mask++;
    }
    name++;
  }
}

// --------------------------------------------------
// Splits path to strings

void SplitPathToParts(const UString &path, UStringVector &pathParts)
{
  pathParts.Clear();
  unsigned len = path.Len();
  if (len == 0)
    return;
  UString name;
  unsigned prev = 0;
  for (unsigned i = 0; i < len; i++)
    if (IsPathSepar(path[i]))
    {
      name.SetFrom(path.Ptr(prev), i - prev);
      pathParts.Add(name);
      prev = i + 1;
    }
  name.SetFrom(path.Ptr(prev), len - prev);
  pathParts.Add(name);
}

void SplitPathToParts_2(const UString &path, UString &dirPrefix, UString &name)
{
  const wchar_t *start = path;
  const wchar_t *p = start + path.Len();
  for (; p != start; p--)
    if (IsPathSepar(*(p - 1)))
      break;
  dirPrefix.SetFrom(path, (unsigned)(p - start));
  name = p;
}

void SplitPathToParts_Smart(const UString &path, UString &dirPrefix, UString &name)
{
  const wchar_t *start = path;
  const wchar_t *p = start + path.Len();
  if (p != start)
  {
    if (IsPathSepar(*(p - 1)))
      p--;
    for (; p != start; p--)
      if (IsPathSepar(*(p - 1)))
        break;
  }
  dirPrefix.SetFrom(path, (unsigned)(p - start));
  name = p;
}

UString ExtractDirPrefixFromPath(const UString &path)
{
  const wchar_t *start = path;
  const wchar_t *p = start + path.Len();
  for (; p != start; p--)
    if (IsPathSepar(*(p - 1)))
      break;
  return path.Left((unsigned)(p - start));
}

UString ExtractFileNameFromPath(const UString &path)
{
  const wchar_t *start = path;
  const wchar_t *p = start + path.Len();
  for (; p != start; p--)
    if (IsPathSepar(*(p - 1)))
      break;
  return p;
}


bool DoesWildcardMatchName(const UString &mask, const UString &name)
{
  return EnhancedMaskTest(mask, name);
}

bool DoesNameContainWildcard(const UString &path)
{
  for (unsigned i = 0; i < path.Len(); i++)
  {
    wchar_t c = path[i];
    if (c == '*' || c == '?')
      return true;
  }
  return false;
}


// ----------------------------------------------------------'
// NWildcard

namespace NWildcard {

/*

M = MaskParts.Size();
N = TestNameParts.Size();

                           File                          Dir
ForFile     rec   M<=N  [N-M, N)                          -
!ForDir  nonrec   M=N   [0, M)                            -
 
ForDir      rec   M<N   [0, M) ... [N-M-1, N-1)  same as ForBoth-File
!ForFile nonrec         [0, M)                   same as ForBoth-File

ForFile     rec   m<=N  [0, M) ... [N-M, N)      same as ForBoth-File
ForDir   nonrec         [0, M)                   same as ForBoth-File

*/

bool CItem::AreAllAllowed() const
{
  return ForFile && ForDir && WildcardMatching && PathParts.Size() == 1 && PathParts.Front() == L"*";
}

bool CItem::CheckPath(const UStringVector &pathParts, bool isFile) const
{
  if (!isFile && !ForDir)
    return false;

  /*
  if (PathParts.IsEmpty())
  {
    // PathParts.IsEmpty() means all items (universal wildcard)
    if (!isFile)
      return true;
    if (pathParts.Size() <= 1)
      return ForFile;
    return (ForDir || Recursive && ForFile);
  }
  */

  int delta = (int)pathParts.Size() - (int)PathParts.Size();
  if (delta < 0)
    return false;
  int start = 0;
  int finish = 0;
  
  if (isFile)
  {
    if (!ForDir)
    {
      if (Recursive)
        start = delta;
      else if (delta !=0)
        return false;
    }
    if (!ForFile && delta == 0)
      return false;
  }
  
  if (Recursive)
  {
    finish = delta;
    if (isFile && !ForFile)
      finish = delta - 1;
  }
  
  for (int d = start; d <= finish; d++)
  {
    unsigned i;
    for (i = 0; i < PathParts.Size(); i++)
    {
      if (WildcardMatching)
      {
        if (!DoesWildcardMatchName(PathParts[i], pathParts[i + d]))
          break;
      }
      else
      {
        if (CompareFileNames(PathParts[i], pathParts[i + d]) != 0)
          break;
      }
    }
    if (i == PathParts.Size())
      return true;
  }
  return false;
}

bool CCensorNode::AreAllAllowed() const
{
  if (!Name.IsEmpty() ||
      !SubNodes.IsEmpty() ||
      !ExcludeItems.IsEmpty() ||
      IncludeItems.Size() != 1)
    return false;
  return IncludeItems.Front().AreAllAllowed();
}

int CCensorNode::FindSubNode(const UString &name) const
{
  FOR_VECTOR (i, SubNodes)
    if (CompareFileNames(SubNodes[i].Name, name) == 0)
      return i;
  return -1;
}

void CCensorNode::AddItemSimple(bool include, CItem &item)
{
  if (include)
    IncludeItems.Add(item);
  else
    ExcludeItems.Add(item);
}

void CCensorNode::AddItem(bool include, CItem &item, int ignoreWildcardIndex)
{
  if (item.PathParts.Size() <= 1)
  {
    if (item.PathParts.Size() != 0 && item.WildcardMatching)
    {
      if (!DoesNameContainWildcard(item.PathParts.Front()))
        item.WildcardMatching = false;
    }
    AddItemSimple(include, item);
    return;
  }
  const UString &front = item.PathParts.Front();
  
  // WIN32 doesn't support wildcards in file names
  if (item.WildcardMatching
      && ignoreWildcardIndex != 0
      && DoesNameContainWildcard(front))
  {
    AddItemSimple(include, item);
    return;
  }
  int index = FindSubNode(front);
  if (index < 0)
    index = SubNodes.Add(CCensorNode(front, this));
  item.PathParts.Delete(0);
  SubNodes[index].AddItem(include, item, ignoreWildcardIndex - 1);
}

void CCensorNode::AddItem(bool include, const UString &path, bool recursive, bool forFile, bool forDir, bool wildcardMatching)
{
  CItem item;
  SplitPathToParts(path, item.PathParts);
  item.Recursive = recursive;
  item.ForFile = forFile;
  item.ForDir = forDir;
  item.WildcardMatching = wildcardMatching;
  AddItem(include, item);
}

bool CCensorNode::NeedCheckSubDirs() const
{
  FOR_VECTOR (i, IncludeItems)
  {
    const CItem &item = IncludeItems[i];
    if (item.Recursive || item.PathParts.Size() > 1)
      return true;
  }
  return false;
}

bool CCensorNode::AreThereIncludeItems() const
{
  if (IncludeItems.Size() > 0)
    return true;
  FOR_VECTOR (i, SubNodes)
    if (SubNodes[i].AreThereIncludeItems())
      return true;
  return false;
}

bool CCensorNode::CheckPathCurrent(bool include, const UStringVector &pathParts, bool isFile) const
{
  const CObjectVector<CItem> &items = include ? IncludeItems : ExcludeItems;
  FOR_VECTOR (i, items)
    if (items[i].CheckPath(pathParts, isFile))
      return true;
  return false;
}

bool CCensorNode::CheckPathVect(const UStringVector &pathParts, bool isFile, bool &include) const
{
  if (CheckPathCurrent(false, pathParts, isFile))
  {
    include = false;
    return true;
  }
  include = true;
  bool finded = CheckPathCurrent(true, pathParts, isFile);
  if (pathParts.Size() <= 1)
    return finded;
  int index = FindSubNode(pathParts.Front());
  if (index >= 0)
  {
    UStringVector pathParts2 = pathParts;
    pathParts2.Delete(0);
    if (SubNodes[index].CheckPathVect(pathParts2, isFile, include))
      return true;
  }
  return finded;
}

/*
bool CCensorNode::CheckPath2(bool isAltStream, const UString &path, bool isFile, bool &include) const
{
  UStringVector pathParts;
  SplitPathToParts(path, pathParts);
  if (CheckPathVect(pathParts, isFile, include))
  {
    if (!include || !isAltStream)
      return true;
  }
  if (isAltStream && !pathParts.IsEmpty())
  {
    UString &back = pathParts.Back();
    int pos = back.Find(L':');
    if (pos > 0)
    {
      back.DeleteFrom(pos);
      return CheckPathVect(pathParts, isFile, include);
    }
  }
  return false;
}

bool CCensorNode::CheckPath(bool isAltStream, const UString &path, bool isFile) const
{
  bool include;
  if (CheckPath2(isAltStream, path, isFile, include))
    return include;
  return false;
}
*/

bool CCensorNode::CheckPathToRoot(bool include, UStringVector &pathParts, bool isFile) const
{
  if (CheckPathCurrent(include, pathParts, isFile))
    return true;
  if (Parent == 0)
    return false;
  pathParts.Insert(0, Name);
  return Parent->CheckPathToRoot(include, pathParts, isFile);
}

/*
bool CCensorNode::CheckPathToRoot(bool include, const UString &path, bool isFile) const
{
  UStringVector pathParts;
  SplitPathToParts(path, pathParts);
  return CheckPathToRoot(include, pathParts, isFile);
}
*/

void CCensorNode::AddItem2(bool include, const UString &path, bool recursive, bool wildcardMatching)
{
  if (path.IsEmpty())
    return;
  bool forFile = true;
  bool forFolder = true;
  UString path2 = path;
  if (IsPathSepar(path.Back()))
  {
    path2.DeleteBack();
    forFile = false;
  }
  AddItem(include, path2, recursive, forFile, forFolder, wildcardMatching);
}

void CCensorNode::ExtendExclude(const CCensorNode &fromNodes)
{
  ExcludeItems += fromNodes.ExcludeItems;
  FOR_VECTOR (i, fromNodes.SubNodes)
  {
    const CCensorNode &node = fromNodes.SubNodes[i];
    int subNodeIndex = FindSubNode(node.Name);
    if (subNodeIndex < 0)
      subNodeIndex = SubNodes.Add(CCensorNode(node.Name, this));
    SubNodes[subNodeIndex].ExtendExclude(node);
  }
}

int CCensor::FindPrefix(const UString &prefix) const
{
  FOR_VECTOR (i, Pairs)
    if (CompareFileNames(Pairs[i].Prefix, prefix) == 0)
      return i;
  return -1;
}

#if 1 // #ifdef _WIN32

bool IsDriveColonName(const wchar_t *s)
{
  wchar_t c = s[0];
  return c != 0 && s[1] == ':' && s[2] == 0 && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z');
}

unsigned GetNumPrefixParts_if_DrivePath(UStringVector &pathParts)
{
  if (pathParts.IsEmpty())
    return 0;
  
  unsigned testIndex = 0;
  if (pathParts[0].IsEmpty())
  {
    if (pathParts.Size() < 4
        || !pathParts[1].IsEmpty()
        || pathParts[2] != L"?")
      return 0;
    testIndex = 3;
  }
  if (NWildcard::IsDriveColonName(pathParts[testIndex]))
    return testIndex + 1;
  return 0;
}

#endif

static unsigned GetNumPrefixParts(const UStringVector pathParts)
{
  if (pathParts.IsEmpty())
    return 0;
  
  #ifdef _WIN32
  
  if (IsDriveColonName(pathParts[0]))
    return 1;
  if (!pathParts[0].IsEmpty())
    return 0;

  if (pathParts.Size() == 1)
    return 1;
  if (!pathParts[1].IsEmpty())
    return 1;
  if (pathParts.Size() == 2)
    return 2;
  if (pathParts[2] == L".")
    return 3;

  unsigned networkParts = 2;
  if (pathParts[2] == L"?")
  {
    if (pathParts.Size() == 3)
      return 3;
    if (IsDriveColonName(pathParts[3]))
      return 4;
    if (!pathParts[3].IsEqualTo_Ascii_NoCase("UNC"))
      return 3;
    networkParts = 4;
  }

  networkParts +=
      // 2; // server/share
      1; // server
  if (pathParts.Size() <= networkParts)
    return pathParts.Size();
  return networkParts;

  #else
  
  return pathParts[0].IsEmpty() ? 1 : 0;
 
  #endif
}

void CCensor::AddItem(ECensorPathMode pathMode, bool include, const UString &path, bool recursive, bool wildcardMatching)
{
  if (path.IsEmpty())
    throw "Empty file path";

  UStringVector pathParts;
  SplitPathToParts(path, pathParts);

  bool forFile = true;
  if (pathParts.Back().IsEmpty())
  {
    forFile = false;
    pathParts.DeleteBack();
  }
  
  UString prefix;
  
  int ignoreWildcardIndex = -1;

  // #ifdef _WIN32
  // we ignore "?" wildcard in "\\?\" prefix.
  if (pathParts.Size() >= 3
      && pathParts[0].IsEmpty()
      && pathParts[1].IsEmpty()
      && pathParts[2] == L"?")
    ignoreWildcardIndex = 2;
  // #endif

  if (pathMode != k_AbsPath)
  {
    ignoreWildcardIndex = -1;

    const unsigned numPrefixParts = GetNumPrefixParts(pathParts);
    unsigned numSkipParts = numPrefixParts;

    if (pathMode != k_FullPath)
    {
      if (numPrefixParts != 0 && pathParts.Size() > numPrefixParts)
        numSkipParts = pathParts.Size() - 1;
    }
    {
      int dotsIndex = -1;
      for (unsigned i = numPrefixParts; i < pathParts.Size(); i++)
      {
        const UString &part = pathParts[i];
        if (part == L".." || part == L".")
          dotsIndex = i;
      }

      if (dotsIndex >= 0)
        if (dotsIndex == (int)pathParts.Size() - 1)
          numSkipParts = pathParts.Size();
        else
          numSkipParts = pathParts.Size() - 1;
    }

    for (unsigned i = 0; i < numSkipParts; i++)
    {
      {
        const UString &front = pathParts.Front();
        // WIN32 doesn't support wildcards in file names
        if (wildcardMatching)
          if (i >= numPrefixParts && DoesNameContainWildcard(front))
            break;
        prefix += front;
        prefix.Add_PathSepar();
      }
      pathParts.Delete(0);
    }
  }

  int index = FindPrefix(prefix);
  if (index < 0)
    index = Pairs.Add(CPair(prefix));

  if (pathMode != k_AbsPath)
  {
    if (pathParts.IsEmpty() || pathParts.Size() == 1 && pathParts[0].IsEmpty())
    {
      // we create universal item, if we skip all parts as prefix (like \ or L:\ )
      pathParts.Clear();
      pathParts.Add(L"*");
      forFile = true;
      wildcardMatching = true;
      recursive = false;
    }
  }

  CItem item;
  item.PathParts = pathParts;
  item.ForDir = true;
  item.ForFile = forFile;
  item.Recursive = recursive;
  item.WildcardMatching = wildcardMatching;
  Pairs[index].Head.AddItem(include, item, ignoreWildcardIndex);
}

/*
bool CCensor::CheckPath(bool isAltStream, const UString &path, bool isFile) const
{
  bool finded = false;
  FOR_VECTOR (i, Pairs)
  {
    bool include;
    if (Pairs[i].Head.CheckPath2(isAltStream, path, isFile, include))
    {
      if (!include)
        return false;
      finded = true;
    }
  }
  return finded;
}
*/

void CCensor::ExtendExclude()
{
  unsigned i;
  for (i = 0; i < Pairs.Size(); i++)
    if (Pairs[i].Prefix.IsEmpty())
      break;
  if (i == Pairs.Size())
    return;
  unsigned index = i;
  for (i = 0; i < Pairs.Size(); i++)
    if (index != i)
      Pairs[i].Head.ExtendExclude(Pairs[index].Head);
}

void CCensor::AddPathsToCensor(ECensorPathMode censorPathMode)
{
  FOR_VECTOR(i, CensorPaths)
  {
    const CCensorPath &cp = CensorPaths[i];
    AddItem(censorPathMode, cp.Include, cp.Path, cp.Recursive, cp.WildcardMatching);
  }
  CensorPaths.Clear();
}

void CCensor::AddPreItem(bool include, const UString &path, bool recursive, bool wildcardMatching)
{
  CCensorPath &cp = CensorPaths.AddNew();
  cp.Path = path;
  cp.Include = include;
  cp.Recursive = recursive;
  cp.WildcardMatching = wildcardMatching;
}

}
// Common/Wildcard.h

#ifndef __COMMON_WILDCARD_H
#define __COMMON_WILDCARD_H

#include "MyString.h"

int CompareFileNames(const wchar_t *s1, const wchar_t *s2) STRING_UNICODE_THROW;
#ifndef USE_UNICODE_FSTRING
  int CompareFileNames(const char *s1, const char *s2);
#endif

bool IsPath1PrefixedByPath2(const wchar_t *s1, const wchar_t *s2);

void SplitPathToParts(const UString &path, UStringVector &pathParts);
void SplitPathToParts_2(const UString &path, UString &dirPrefix, UString &name);
void SplitPathToParts_Smart(const UString &path, UString &dirPrefix, UString &name); // ignores dir delimiter at the end of (path)

UString ExtractDirPrefixFromPath(const UString &path);
UString ExtractFileNameFromPath(const UString &path);

bool DoesNameContainWildcard(const UString &path);
bool DoesWildcardMatchName(const UString &mask, const UString &name);

namespace NWildcard {

// FIXME #ifdef _WIN32
// returns true, if name is like "a:", "c:", ...
bool IsDriveColonName(const wchar_t *s);
unsigned GetNumPrefixParts_if_DrivePath(UStringVector &pathParts);
// #endif

struct CItem
{
  UStringVector PathParts;
  bool Recursive;
  bool ForFile;
  bool ForDir;
  bool WildcardMatching;
  
  #ifdef _WIN32
  bool IsDriveItem() const
  {
    return PathParts.Size() == 1 && !ForFile && ForDir && IsDriveColonName(PathParts[0]);
  }
  #endif

  // CItem(): WildcardMatching(true) {}

  bool AreAllAllowed() const;
  bool CheckPath(const UStringVector &pathParts, bool isFile) const;
};

class CCensorNode
{
  CCensorNode *Parent;
  
  bool CheckPathCurrent(bool include, const UStringVector &pathParts, bool isFile) const;
  void AddItemSimple(bool include, CItem &item);
public:
  bool CheckPathVect(const UStringVector &pathParts, bool isFile, bool &include) const;

  CCensorNode(): Parent(0) { };
  CCensorNode(const UString &name, CCensorNode *parent): Name(name), Parent(parent) { };

  UString Name; // WIN32 doesn't support wildcards in file names
  CObjectVector<CCensorNode> SubNodes;
  CObjectVector<CItem> IncludeItems;
  CObjectVector<CItem> ExcludeItems;

  bool AreAllAllowed() const;

  int FindSubNode(const UString &path) const;

  void AddItem(bool include, CItem &item, int ignoreWildcardIndex = -1);
  void AddItem(bool include, const UString &path, bool recursive, bool forFile, bool forDir, bool wildcardMatching);
  void AddItem2(bool include, const UString &path, bool recursive, bool wildcardMatching);

  bool NeedCheckSubDirs() const;
  bool AreThereIncludeItems() const;

  // bool CheckPath2(bool isAltStream, const UString &path, bool isFile, bool &include) const;
  // bool CheckPath(bool isAltStream, const UString &path, bool isFile) const;

  bool CheckPathToRoot(bool include, UStringVector &pathParts, bool isFile) const;
  // bool CheckPathToRoot(const UString &path, bool isFile, bool include) const;
  void ExtendExclude(const CCensorNode &fromNodes);
};

struct CPair
{
  UString Prefix;
  CCensorNode Head;
  
  CPair(const UString &prefix): Prefix(prefix) { };
};

enum ECensorPathMode
{
  k_RelatPath,  // absolute prefix as Prefix, remain path in Tree
  k_FullPath,   // drive prefix as Prefix, remain path in Tree
  k_AbsPath     // full path in Tree
};

struct CCensorPath
{
  UString Path;
  bool Include;
  bool Recursive;
  bool WildcardMatching;

  CCensorPath():
    Include(true),
    Recursive(false),
    WildcardMatching(true)
    {}
};

class CCensor
{
  int FindPrefix(const UString &prefix) const;
public:
  CObjectVector<CPair> Pairs;

  CObjectVector<NWildcard::CCensorPath> CensorPaths;
  
  bool AllAreRelative() const
    { return (Pairs.Size() == 1 && Pairs.Front().Prefix.IsEmpty()); }
  
  void AddItem(ECensorPathMode pathMode, bool include, const UString &path, bool recursive, bool wildcardMatching);
  // bool CheckPath(bool isAltStream, const UString &path, bool isFile) const;
  void ExtendExclude();

  void AddPathsToCensor(NWildcard::ECensorPathMode censorPathMode);
  void AddPreItem(bool include, const UString &path, bool recursive, bool wildcardMatching);
  void AddPreItem(const UString &path)
  {
    AddPreItem(true, path, false, false);
  }
  void AddPreItem_Wildcard()
  {
    AddPreItem(true, L"*", false, true);
  }
};


}

#endif
// XzCrc64Reg.cpp

#include "StdAfx.h"

#include "../../C/CpuArch.h"
#include "../../C/XzCrc64.h"

#include "../Common/MyCom.h"

#include "../7zip/Common/RegisterCodec.h"

class CXzCrc64Hasher:
  public IHasher,
  public CMyUnknownImp
{
  UInt64 _crc;
  Byte mtDummy[1 << 7];

public:
  CXzCrc64Hasher(): _crc(CRC64_INIT_VAL) {}

  MY_UNKNOWN_IMP1(IHasher)
  INTERFACE_IHasher(;)
};

STDMETHODIMP_(void) CXzCrc64Hasher::Init() throw()
{
  _crc = CRC64_INIT_VAL;
}

STDMETHODIMP_(void) CXzCrc64Hasher::Update(const void *data, UInt32 size) throw()
{
  _crc = Crc64Update(_crc, data, size);
}

STDMETHODIMP_(void) CXzCrc64Hasher::Final(Byte *digest) throw()
{
  UInt64 val = CRC64_GET_DIGEST(_crc);
  SetUi64(digest, val);
}

REGISTER_HASHER(CXzCrc64Hasher, 0x4, "CRC64", 8)
// Windows/COM.cpp

#include "StdAfx.h"

/*

#include "COM.h"
#include "../Common/StringConvert.h"

namespace NWindows {
namespace NCOM {

// CoInitialize (NULL); must be called!

UString GUIDToStringW(REFGUID guid)
{
  UString s;
  const unsigned kSize = 48;
  StringFromGUID2(guid, s.GetBuf(kSize), kSize);
  s.ReleaseBuf_CalcLen(kSize);
  return s;
}

AString GUIDToStringA(REFGUID guid)
{
  return UnicodeStringToMultiByte(GUIDToStringW(guid));
}

HRESULT StringToGUIDW(const wchar_t *string, GUID &classID)
{
  return CLSIDFromString((wchar_t *)string, &classID);
}

HRESULT StringToGUIDA(const char *string, GUID &classID)
{
  return StringToGUIDW(MultiByteToUnicodeString(string), classID);
}

}}

*/
// Windows/COM.h

#ifndef __WINDOWS_COM_H
#define __WINDOWS_COM_H

#include "../Common/MyString.h"

namespace NWindows {
namespace NCOM {

#ifdef _WIN32
  
class CComInitializer
{
public:
  CComInitializer()
  {
    #ifdef UNDER_CE
    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    #else
    // it's single thread. Do we need multithread?
    CoInitialize(NULL);
    #endif
  };
  ~CComInitializer() { CoUninitialize(); }
};

class CStgMedium
{
  STGMEDIUM _object;
public:
  bool _mustBeReleased;
  CStgMedium(): _mustBeReleased(false) {}
  ~CStgMedium() { Free(); }
  void Free()
  {
    if (_mustBeReleased)
      ReleaseStgMedium(&_object);
    _mustBeReleased = false;
  }
  const STGMEDIUM* operator->() const { return &_object;}
  STGMEDIUM* operator->() { return &_object;}
  STGMEDIUM* operator&() { return &_object; }
};

#endif

/*
//////////////////////////////////
// GUID <--> String Conversions
UString GUIDToStringW(REFGUID guid);
AString GUIDToStringA(REFGUID guid);
#ifdef UNICODE
  #define GUIDToString GUIDToStringW
#else
  #define GUIDToString GUIDToStringA
#endif

HRESULT StringToGUIDW(const wchar_t *string, GUID &classID);
HRESULT StringToGUIDA(const char *string, GUID &classID);
#ifdef UNICODE
  #define StringToGUID StringToGUIDW
#else
  #define StringToGUID StringToGUIDA
#endif
*/

}}

#endif
// Windows/Clipboard.cpp

#include "StdAfx.h"


#include "Windows/Clipboard.h"
#include "Windows/Defs.h"
#ifdef _WIN32
#include "Windows/Memory.h"
#include "Windows/Shell.h"
#include "Windows/Memory.h"
#else
#include <wx/clipbrd.h>
#include <wx/dataobj.h>
#undef _WIN32
#endif

#include "Common/StringConvert.h"

namespace NWindows {

bool CClipboard::Open(HWND wndNewOwner)
{
#ifdef _WIN32
  m_Open = BOOLToBool(::OpenClipboard(wndNewOwner));
#else
  m_Open = wxTheClipboard->Open();
#endif
  return m_Open;
}

CClipboard::~CClipboard()
{
  Close();
}

bool CClipboard::Close()
{
  if (!m_Open)
    return true;
#ifdef _WIN32
  m_Open = !BOOLToBool(CloseClipboard());
#else
  wxTheClipboard->Close();
  m_Open = false;
#endif
  return !m_Open;
}

#ifdef _WIN32
bool ClipboardIsFormatAvailableHDROP()
{
  return BOOLToBool(IsClipboardFormatAvailable(CF_HDROP));
}
#endif

/*
bool ClipboardGetTextString(AString &s)
{
  s.Empty();
  if (!IsClipboardFormatAvailable(CF_TEXT))
    return false;
  CClipboard clipboard;

  if (!clipboard.Open(NULL))
    return false;

  HGLOBAL h = ::GetClipboardData(CF_TEXT);
  if (h != NULL)
  {
    NMemory::CGlobalLock globalLock(h);
    const char *p = (const char *)globalLock.GetPointer();
    if (p != NULL)
    {
      s = p;
      return true;
    }
  }
  return false;
}
*/

/*
bool ClipboardGetFileNames(UStringVector &names)
{
  names.Clear();
  if (!IsClipboardFormatAvailable(CF_HDROP))
    return false;
  CClipboard clipboard;

  if (!clipboard.Open(NULL))
    return false;

  HGLOBAL h = ::GetClipboardData(CF_HDROP);
  if (h != NULL)
  {
    NMemory::CGlobalLock globalLock(h);
    void *p = (void *)globalLock.GetPointer();
    if (p != NULL)
    {
      NShell::CDrop drop(false);
      drop.Attach((HDROP)p);
      drop.QueryFileNames(names);
      return true;
    }
  }
  return false;
}
*/

#ifdef _WIN32
static bool ClipboardSetData(UINT uFormat, const void *data, size_t size)
{
  NMemory::CGlobal global;
  if (!global.Alloc(GMEM_DDESHARE | GMEM_MOVEABLE, size))
    return false;
  {
    NMemory::CGlobalLock globalLock(global);
    LPVOID p = globalLock.GetPointer();
    if (p == NULL)
      return false;
    memcpy(p, data, size);
  }
  if (::SetClipboardData(uFormat, global) == NULL)
    return false;
  global.Detach();
  return true;
}
#endif

bool ClipboardSetText(HWND owner, const UString &s)
{
  CClipboard clipboard;
  if (!clipboard.Open(owner))
    return false;
#ifdef _WIN32
  if (!::EmptyClipboard())
    return false;

  bool res;
  res = ClipboardSetData(CF_UNICODETEXT, (const wchar_t *)s, (s.Length() + 1) * sizeof(wchar_t));
  #ifndef _UNICODE
  AString a;
  a = UnicodeStringToMultiByte(s, CP_ACP);
  res |=  ClipboardSetData(CF_TEXT, (const char *)a, (a.Length() + 1) * sizeof(char));
  a = UnicodeStringToMultiByte(s, CP_OEMCP);
  res |=  ClipboardSetData(CF_OEMTEXT, (const char *)a, (a.Length() + 1) * sizeof(char));
  #endif
  return res;
#else
  wxTheClipboard->Clear();
  // This data objects are held by the clipboard, 
  // so do not delete them in the app.
  wxString ws(s);
  wxTheClipboard->SetData( new wxTextDataObject(ws) );  
  return true;
#endif
}
 
}
// Windows/Clipboard.h

#ifndef __CLIPBOARD_H
#define __CLIPBOARD_H

#include "Common/MyString.h"

namespace NWindows {

class CClipboard
{
  bool m_Open;
public:
  CClipboard(): m_Open(false) {};
  ~CClipboard();
  bool Open(HWND wndNewOwner);
  bool Close();
};

bool ClipboardIsFormatAvailableHDROP();

// bool ClipboardGetFileNames(UStringVector &names);
// bool ClipboardGetTextString(AString &s);
bool ClipboardSetText(HWND owner, const UString &s);

}

#endif
// Windows/CommonDialog.h

#ifndef __WINDOWS_COMMON_DIALOG_H
#define __WINDOWS_COMMON_DIALOG_H

#include "../Common/MyString.h"

namespace NWindows {

bool MyGetOpenFileName(HWND hwnd, LPCWSTR title,
    LPCWSTR initialDir,  // can be NULL, so dir prefix in filePath will be used
    LPCWSTR filePath,    // full path
    LPCWSTR filterDescription,  // like "All files (*.*)"
    LPCWSTR filter,             // like "*.exe"
    UString &resPath
    #ifdef UNDER_CE
    , bool openFolder = false
    #endif
);

}

#endif
// Windows/DLL.cpp

#include "StdAfx.h"

#ifdef __APPLE_CC__
#include <mach-o/dyld.h>
#elif ENV_BEOS
#include <kernel/image.h>
#include <Path.h>
#else
#define UINT64 DLL_UINT64 // HP-UX , dlfcn.h defines UINT64 but p7zip also defines UINT64
#include <dlfcn.h>  // dlopen ...
#undef UINT64
#endif

#include "DLL.h"
#include "Defs.h"
#ifdef _UNICODE
#include "../Common/StringConvert.h"
#endif

#define NEED_NAME_WINDOWS_TO_UNIX
#include "myPrivate.h"

// #define TRACEN(u) u;
#define TRACEN(u)  /* */

namespace NWindows {
namespace NDLL {

bool CLibrary::Free()
{
TRACEN((printf("CLibrary::Free(this=%p,%p)\n",(void *)this,(void *)_module)))
  if (_module == 0)
    return true;

#ifdef __APPLE_CC__
  int ret = NSUnLinkModule ((NSModule)_module, 0);
#elif ENV_BEOS
  int ret = unload_add_on((image_id)_module);
#else
  int ret = dlclose(_module);
#endif
TRACEN((printf("CLibrary::Free dlclose(%p)=%d\n",(void *)_module,ret)))
  if (ret != 0) return false;
  _module = 0;
  return true;
}

static FARPROC local_GetProcAddress(HMODULE module,LPCSTR lpProcName)
{
  void *ptr = 0;
  TRACEN((printf("local_GetProcAddress(%p,%s)\n",(void *)module,lpProcName)))
  if (module) {
#ifdef __APPLE_CC__
    char name[MAX_PATHNAME_LEN];
    snprintf(name,sizeof(name),"_%s",lpProcName);
    name[sizeof(name)-1] = 0;
    TRACEN((printf("NSLookupSymbolInModule(%p,%s)\n",(void *)module,name)))
    NSSymbol sym;
    sym = NSLookupSymbolInModule((NSModule)module, name);
    if (sym) {
      ptr = NSAddressOfSymbol(sym);
    } else {
      ptr = 0;
    }
#elif ENV_BEOS
    if (get_image_symbol((image_id)module, lpProcName, B_SYMBOL_TYPE_TEXT, &ptr) != B_OK)
      ptr = 0;
#else
    ptr = dlsym (module, lpProcName);
#endif
    TRACEN((printf("CLibrary::GetProc : dlsym(%p,%s)=%p\n",(void *)module,lpProcName,ptr)))
  }
  return (FARPROC)ptr;
}

FARPROC CLibrary::GetProc(LPCSTR lpProcName) const
{
  TRACEN((printf("CLibrary::GetProc(%p,%s)\n",(void *)_module,lpProcName)))
  return local_GetProcAddress(_module,lpProcName);
}

bool CLibrary::Load(LPCTSTR lpLibFileName)
{
  if(!Free())
    return false;

  void *handler = 0;
  char  name[MAX_PATHNAME_LEN+1];
#ifdef _UNICODE
  AString name2 = UnicodeStringToMultiByte(lpLibFileName);
  strcpy(name,nameWindowToUnix((const char *)name2));
#else
  strcpy(name,nameWindowToUnix(lpLibFileName));
#endif

  // replace ".dll" with ".so"
  size_t len = strlen(name);
  if ((len >=4) && (strcmp(name+len-4,".dll") == 0)) {
    strcpy(name+len-4,".so");
  }

  TRACEN((printf("CLibrary::Load(this=%p,%ls) => %s\n",(void *)this,lpLibFileName,name)))

#ifdef __APPLE_CC__
  NSObjectFileImage image;
  NSObjectFileImageReturnCode nsret;

  nsret = NSCreateObjectFileImageFromFile (name, &image);
  if (nsret == NSObjectFileImageSuccess) {
     TRACEN((printf("NSCreateObjectFileImageFromFile(%s) : OK\n",name)))
     handler = (HMODULE)NSLinkModule(image,name,NSLINKMODULE_OPTION_RETURN_ON_ERROR
           | NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_BINDNOW);
  } else {
     TRACEN((printf("NSCreateObjectFileImageFromFile(%s) : ERROR\n",name)))
  }
#elif ENV_BEOS
  // normalize path (remove things like "./", "..", etc..), otherwise it won't work
  BPath p(name, NULL, true);
  status_t err = B_OK;
  image_id image = load_add_on(p.Path());
TRACEN((printf("load_add_on(%s)=%d\n",p.Path(),(int)image)))
  if (image < 0) {
    err = (image_id)handler;
    handler = 0;
  } else {
    err = 0;
    handler = (HMODULE)image;
  }
#else
  int options_dlopen = 0;
#ifdef RTLD_LOCAL
  options_dlopen |= RTLD_LOCAL;
#endif
#ifdef RTLD_NOW
  options_dlopen |= RTLD_NOW;
#endif
#ifdef RTLD_GROUP
  #if ! (defined(hpux) || defined(__hpux))
  options_dlopen |= RTLD_GROUP; // mainly for solaris but not for HPUX
  #endif
#endif
  TRACEN((printf("CLibrary::Load - dlopen(%s,0x%d)\n",name,options_dlopen)))
  handler = dlopen(name,options_dlopen);
#endif // __APPLE_CC__
  TRACEN((printf("CLibrary::Load(%s) => %p\n",name,handler)))
  if (handler) {

    // Call DllMain() like in Windows : useless now

    // Propagate the value of global_use_utf16_conversion into the plugins
    int *tmp = (int *)local_GetProcAddress(handler,"global_use_utf16_conversion");
    if (tmp) *tmp = global_use_utf16_conversion;
#ifdef ENV_HAVE_LSTAT
    tmp = (int *)local_GetProcAddress(handler,"global_use_lstat");
    if (tmp) *tmp = global_use_lstat;
#endif
    // test construtors calls
    void (*fctTest)(void) = (void (*)(void))local_GetProcAddress(handler,"sync_TestConstructor");
    if (fctTest) fctTest();

  } else {
#ifdef __APPLE_CC__
    NSLinkEditErrors c;
    int num_err;
    const char *file,*err;
    NSLinkEditError(&c,&num_err,&file,&err);
    printf("Can't load '%ls' (%s)\n", lpLibFileName,err);
#elif ENV_BEOS
    printf("Can't load '%ls' (%s)\n", lpLibFileName,strerror(err));
#else
    printf("Can't load '%ls' (%s)\n", lpLibFileName,dlerror());
#endif
  }

  _module = handler;
  TRACEN((printf("CLibrary::Load(this=%p,%ls) => _module=%p\n",(void *)this,lpLibFileName,_module)))

  return true;
}


}}

// Windows/DLL.h

#ifndef __WINDOWS_DLL_H
#define __WINDOWS_DLL_H

#include "../Common/MyString.h"

typedef void * HMODULE;
// #define LOAD_LIBRARY_AS_DATAFILE 0
typedef int (*FARPROC)();

namespace NWindows {
namespace NDLL {

class CLibrary
{
  HMODULE _module;
public:
  CLibrary(): _module(NULL) {};
  ~CLibrary() { Free(); }

  operator HMODULE() const { return _module; }
  HMODULE* operator&() { return &_module; }
  bool IsLoaded() const { return (_module != NULL); };

  void Attach(HMODULE m)
  {
    Free();
    _module = m;
  }
  HMODULE Detach()
  {
    HMODULE m = _module;
    _module = NULL;
    return m;
  }

  bool Free();
  // bool LoadEx(CFSTR path, DWORD flags = LOAD_LIBRARY_AS_DATAFILE);
  bool Load(CFSTR path);
  FARPROC GetProc(LPCSTR procName) const; //  { return My_GetProcAddress(_module, procName); }
};

bool MyGetModuleFileName(FString &path);

FString GetModuleDirPrefix();

}}

#endif
// Windows/Defs.h

#ifndef __WINDOWS_DEFS_H
#define __WINDOWS_DEFS_H

#include "../Common/MyWindows.h"

// #ifdef _WIN32
inline bool LRESULTToBool(LRESULT v) { return (v != FALSE); }
inline bool BOOLToBool(BOOL v) { return (v != FALSE); }
inline BOOL BoolToBOOL(bool v) { return (v ? TRUE: FALSE); }
// #endif

inline VARIANT_BOOL BoolToVARIANT_BOOL(bool v) { return (v ? VARIANT_TRUE: VARIANT_FALSE); }
inline bool VARIANT_BOOLToBool(VARIANT_BOOL v) { return (v != VARIANT_FALSE); }

#endif
// Windows/ErrorMsg.h

#include "StdAfx.h"

#include "Windows/ErrorMsg.h"
#include "Common/StringConvert.h"

namespace NWindows {
namespace NError {

UString MyFormatMessage(DWORD errorCode)
{
  const char * txt = 0;
  AString msg;

  switch(errorCode) {
    case ERROR_NO_MORE_FILES   : txt = "No more files"; break ;
    case E_NOTIMPL             : txt = "E_NOTIMPL"; break ;
    case E_NOINTERFACE         : txt = "E_NOINTERFACE"; break ;
    case E_ABORT               : txt = "E_ABORT"; break ;
    case E_FAIL                : txt = "E_FAIL"; break ;
    case STG_E_INVALIDFUNCTION : txt = "STG_E_INVALIDFUNCTION"; break ;
    case E_OUTOFMEMORY         : txt = "E_OUTOFMEMORY"; break ;
    case E_INVALIDARG          : txt = "E_INVALIDARG"; break ;
    case ERROR_DIRECTORY          : txt = "Error Directory"; break ;
    default:
      txt = strerror(errorCode);
  }
  if (txt) {
    msg = txt;
  } else {
    char msgBuf[256];
    snprintf(msgBuf,sizeof(msgBuf),"error #%x",(unsigned)errorCode);
    msgBuf[sizeof(msgBuf)-1] = 0;
    msg = msgBuf;
  }
  return MultiByteToUnicodeString(msg);
}

#if 0
bool MyFormatMessage(DWORD messageID, CSysString &message)
{
  const char * txt = 0;
  AString msg;

  switch(messageID) {
    case ERROR_NO_MORE_FILES   : txt = "No more files"; break ;
    case E_NOTIMPL             : txt = "E_NOTIMPL"; break ;
    case E_NOINTERFACE         : txt = "E_NOINTERFACE"; break ;
    case E_ABORT               : txt = "E_ABORT"; break ;
    case E_FAIL                : txt = "E_FAIL"; break ;
    case STG_E_INVALIDFUNCTION : txt = "STG_E_INVALIDFUNCTION"; break ;
    case E_OUTOFMEMORY         : txt = "E_OUTOFMEMORY"; break ;
    case E_INVALIDARG          : txt = "E_INVALIDARG"; break ;
    default:
      txt = strerror(messageID);
  }
  if (txt) {
    msg = txt;
  } else {
    char msgBuf[256];
    snprintf(msgBuf,sizeof(msgBuf),"error #%x",(unsigned)messageID);
    msgBuf[sizeof(msgBuf)-1] = 0;
    msg = msgBuf;
  }
  
  msg += "                ";

#ifdef _UNICODE
  message = MultiByteToUnicodeString(msg);
#else
  message = msg;
#endif
  return true;
}

#ifndef _UNICODE
bool MyFormatMessage(DWORD messageID, UString &message)
{
    CSysString messageSys;
    bool result = MyFormatMessage(messageID, messageSys);
    message = GetUnicodeString(messageSys);
    return result;
}
#endif

#endif

}}

// Windows/ErrorMsg.h

#ifndef __WINDOWS_ERROR_MSG_H
#define __WINDOWS_ERROR_MSG_H

#include "../Common/MyString.h"

namespace NWindows {
namespace NError {

UString MyFormatMessage(DWORD errorCode);

}}

#endif
// Windows/FileDir.cpp

#include "StdAfx.h"

#ifndef _UNICODE
#include "../Common/StringConvert.h"
#endif

#include "FileDir.h"
#include "FileFind.h"
#include "FileName.h"

using namespace NWindows;
using namespace NFile;
using namespace NName;

#include "../Common/StringConvert.h"
#include "../Common/IntToString.h"

#define NEED_NAME_WINDOWS_TO_UNIX
#include "myPrivate.h"
#include "Windows/Synchronization.h"

#include <unistd.h> // rmdir
#include <errno.h>

#include <sys/stat.h> // mkdir
#include <sys/types.h>
#include <fcntl.h>

#include <utime.h>

// #define TRACEN(u) u;
#define TRACEN(u)  /* */

int g_filedir = 1;

static NWindows::NSynchronization::CCriticalSection g_CountCriticalSection;

class Umask
{
  public:
  mode_t  current_umask;
  mode_t  mask;
  Umask() {
    current_umask = umask (0);  /* get and set the umask */
    umask(current_umask);   /* restore the umask */
    mask = 0777 & (~current_umask);
  }
};

static Umask gbl_umask;
extern BOOLEAN WINAPI RtlTimeToSecondsSince1970( const LARGE_INTEGER *Time, DWORD *Seconds );


#ifdef _UNICODE
AString nameWindowToUnix2(LPCWSTR name) // FIXME : optimization ?
{
   AString astr = UnicodeStringToMultiByte(name);
   return AString(nameWindowToUnix((const char *)astr));
}
#endif

DWORD WINAPI GetFullPathNameW( LPCTSTR name, DWORD len, LPTSTR buffer, LPTSTR *lastpart ) { // FIXME
  if (name == 0) return 0;

  DWORD name_len = lstrlen(name);

  if (name[0] == '/') {
    DWORD ret = name_len+2;
    if (ret >= len) {
      TRACEN((printf("GetFullPathNameA(%ls,%d,)=0000 (case 0)\n",name, (int)len)))
      return 0;
    }
    lstrcpy(buffer,L"c:");
    lstrcat(buffer,name);

    *lastpart=buffer;
    TCHAR *ptr=buffer;
    while (*ptr) {
      if (*ptr == '/')
        *lastpart=ptr+1;
      ptr++;
    }
    TRACEN((printf("GetFullPathNameA(%ls,%d,%ls,%ls)=%d\n",name, (int)len,buffer, *lastpart,(int)ret)))
    return ret;
  }
  if (isascii(name[0]) && (name[1] == ':')) { // FIXME isascii
    DWORD ret = name_len;
    if (ret >= len) {
      TRACEN((printf("GetFullPathNameA(%ls,%d,)=0000 (case 1)\n",name, (int)len)))
      return 0;
    }
    lstrcpy(buffer,name);

    *lastpart=buffer;
    TCHAR *ptr=buffer;
    while (*ptr) {
      if (*ptr == '/')
        *lastpart=ptr+1;
      ptr++;
    }
    TRACEN((printf("GetFullPathNameA(%ls,%d,%ls,%ls)=%d\n",name, (int)len,buffer, *lastpart,(int)ret)))
    return ret;
  }

  // name is a relative pathname.
  //
  if (len < 2) {
    TRACEN((printf("GetFullPathNameA(%ls,%d,)=0000 (case 2)\n",name, (int)len)))
    return 0;
  }

  DWORD ret = 0;
  char begin[MAX_PATHNAME_LEN];
  /* DWORD begin_len = GetCurrentDirectoryA(MAX_PATHNAME_LEN,begin); */
  DWORD begin_len = 0;
  begin[0]='c';
  begin[1]=':';
  char * cret = getcwd(begin+2, MAX_PATHNAME_LEN - 3);
  if (cret) {
    begin_len = strlen(begin);
  }

  if (begin_len >= 1) {
    //    strlen(begin) + strlen("/") + strlen(name)
    ret = begin_len     +    1        + name_len;

    if (ret >= len) {
      TRACEN((printf("GetFullPathNameA(%ls,%d,)=0000 (case 4)\n",name, (int)len)))
      return 0;
    }
    UString wbegin = GetUnicodeString(begin);
    lstrcpy(buffer,wbegin);
    lstrcat(buffer,L"/");
    lstrcat(buffer,name);

    *lastpart=buffer + begin_len + 1;
    TCHAR *ptr=buffer;
    while (*ptr) {
      if (*ptr == '/')
        *lastpart=ptr+1;
      ptr++;
    }
    TRACEN((printf("GetFullPathNameA(%ls,%d,%ls,%ls)=%d\n",name, (int)len,buffer, *lastpart,(int)ret)))
  } else {
    ret = 0;
    TRACEN((printf("GetFullPathNameA(%ls,%d,)=0000 (case 5)\n",name, (int)len)))
  }
  return ret;
}

static int copy_fd(int fin,int fout)
{
  char buffer[16384];
  ssize_t ret_in;
  ssize_t ret_out;

  do {
    ret_out = -1;
    do {
      ret_in = read(fin, buffer,sizeof(buffer));
    } while (ret_in < 0 && (errno == EINTR));
    if (ret_in >= 1) {
      do {
        ret_out = write (fout, buffer, ret_in);
      } while (ret_out < 0 && (errno == EINTR));
    } else if (ret_in == 0) {
      ret_out = 0;
    }
  } while (ret_out >= 1);
  return ret_out;
}

static BOOL CopyFile(const char *src,const char *dst)
{
  int ret = -1;

#ifdef O_BINARY
  int   flags = O_BINARY;
#else
  int   flags = 0;
#endif

#ifdef O_LARGEFILE
  flags |= O_LARGEFILE;
#endif

  // printf("##DBG CopyFile(%s,%s)\n",src,dst);
  int fout = open(dst,O_CREAT | O_WRONLY | O_EXCL | flags, 0600);
  if (fout != -1)
  {
    int fin = open(src,O_RDONLY | flags , 0600);
    if (fin != -1)
    {
      ret = copy_fd(fin,fout);
      if (ret == 0) ret = close(fin);
      else                close(fin);
    }
    if (ret == 0) ret = close(fout);
    else                close(fout);
  }
  if (ret == 0) return TRUE;
  return FALSE;
}


#ifndef _UNICODE
extern bool g_IsNT;
#endif

namespace NWindows {
namespace NFile {

// SetCurrentDirectory doesn't support \\?\ prefix

#ifdef WIN_LONG_PATH
bool GetLongPathBase(CFSTR fileName, UString &res);
bool GetLongPath(CFSTR fileName, UString &res);
#endif

namespace NDir {


#ifdef _WIN32

#ifndef UNDER_CE

bool MyGetWindowsDirectory(FString &path)
{
  UINT needLength;
  #ifndef _UNICODE
  if (!g_IsNT)
  {
    TCHAR s[MAX_PATH + 2];
    s[0] = 0;
    needLength = ::GetWindowsDirectory(s, MAX_PATH + 1);
    path = fas2fs(s);
  }
  else
  #endif
  {
    WCHAR s[MAX_PATH + 2];
    s[0] = 0;
    needLength = ::GetWindowsDirectoryW(s, MAX_PATH + 1);
    path = us2fs(s);
  }
  return (needLength > 0 && needLength <= MAX_PATH);
}


bool MyGetSystemDirectory(FString &path)
{
  UINT needLength;
  #ifndef _UNICODE
  if (!g_IsNT)
  {
    TCHAR s[MAX_PATH + 2];
    s[0] = 0;
    needLength = ::GetSystemDirectory(s, MAX_PATH + 1);
    path = fas2fs(s);
  }
  else
  #endif
  {
    WCHAR s[MAX_PATH + 2];
    s[0] = 0;
    needLength = ::GetSystemDirectoryW(s, MAX_PATH + 1);
    path = us2fs(s);
  }
  return (needLength > 0 && needLength <= MAX_PATH);
}
#endif
#endif // _WIN32

bool SetDirTime(CFSTR fileName, const FILETIME * /* cTime */ , const FILETIME *aTime, const FILETIME *mTime)
{
  AString  cfilename = UnicodeStringToMultiByte(fileName);
  const char * unix_filename = nameWindowToUnix((const char *)cfilename);

  struct utimbuf buf;

  struct stat    oldbuf;
  int ret = stat(unix_filename,&oldbuf);
  if (ret == 0) {
    buf.actime  = oldbuf.st_atime;
    buf.modtime = oldbuf.st_mtime;
  } else {
    time_t current_time = time(0);
    buf.actime  = current_time;
    buf.modtime = current_time;
  }

  if (aTime)
  {
    LARGE_INTEGER  ltime;
    DWORD dw;
    ltime.QuadPart = aTime->dwHighDateTime;
    ltime.QuadPart = (ltime.QuadPart << 32) | aTime->dwLowDateTime;
    RtlTimeToSecondsSince1970( &ltime, &dw );
    buf.actime = dw;
  }

  if (mTime)
  {
    LARGE_INTEGER  ltime;
    DWORD dw;
    ltime.QuadPart = mTime->dwHighDateTime;
    ltime.QuadPart = (ltime.QuadPart << 32) | mTime->dwLowDateTime;
    RtlTimeToSecondsSince1970( &ltime, &dw );
    buf.modtime = dw;
  }

  /* ret = */ utime(unix_filename, &buf);

  return true;
}

#ifdef WIN_LONG_PATH
bool GetLongPaths(CFSTR s1, CFSTR s2, UString &d1, UString &d2)
{
  if (!GetLongPathBase(s1, d1) ||
      !GetLongPathBase(s2, d2))
    return false;
  if (d1.IsEmpty() && d2.IsEmpty())
    return false;
  if (d1.IsEmpty()) d1 = fs2us(s1);
  if (d2.IsEmpty()) d2 = fs2us(s2);
  return true;
}
#endif

static int convert_to_symlink(const char * name) {
  TRACEN(printf("LINK(%s)\n",name))
  FILE *file = fopen(name,"rb");
  if (file) {
    char buf[MAX_PATHNAME_LEN+1];
    char * ret = fgets(buf,sizeof(buf)-1,file);
    fclose(file);
    if (ret) {
      int ir = unlink(name);
      if (ir == 0) {
        ir = symlink(buf,name);
        TRACEN(printf("TO(%s)\n",buf))
      }
      return ir;
    }
  }
  return -1;
}

bool SetFileAttrib(CFSTR fileName, DWORD fileAttributes,CObjectVector<CDelayedSymLink> *delayedSymLinks)
{
  if (!fileName) {
    SetLastError(ERROR_PATH_NOT_FOUND);
    TRACEN((printf("SetFileAttrib(NULL,%d) : false-1\n",fileAttributes)))
    return false;
  }
#ifdef _UNICODE
  AString name = nameWindowToUnix2(fileName);
#else
  const char * name = nameWindowToUnix(fileName);
#endif
  struct stat stat_info;
#ifdef ENV_HAVE_LSTAT
  if (global_use_lstat) {
    if(lstat(name,&stat_info)!=0) {
      TRACEN((printf("SetFileAttrib(%s,%d) : false-2-1\n",(const char *)name,fileAttributes)))
      return false;
    }
  } else
#endif
  {
    if(stat(name,&stat_info)!=0) {
      TRACEN((printf("SetFileAttrib(%s,%d) : false-2-2\n",(const char *)name,fileAttributes)))
      return false;
    }
  }

  if (fileAttributes & FILE_ATTRIBUTE_UNIX_EXTENSION) {
     stat_info.st_mode = fileAttributes >> 16;
#ifdef ENV_HAVE_LSTAT
     if (S_ISLNK(stat_info.st_mode)) {
         if (delayedSymLinks) {
           delayedSymLinks->Add(CDelayedSymLink(name));
         } else if ( convert_to_symlink(name) != 0) {
          TRACEN((printf("SetFileAttrib(%s,%d) : false-3\n",(const char *)name,fileAttributes)))
          return false;
        }
     } else
#endif
     if (S_ISREG(stat_info.st_mode)) {
       TRACEN((printf("##DBG chmod-2(%s,%o)\n",(const char *)name,(unsigned)stat_info.st_mode & gbl_umask.mask)))
       chmod(name,stat_info.st_mode & gbl_umask.mask);
     } else if (S_ISDIR(stat_info.st_mode)) {
       // user/7za must be able to create files in this directory
       stat_info.st_mode |= (S_IRUSR | S_IWUSR | S_IXUSR);
       TRACEN((printf("##DBG chmod-3(%s,%o)\n",(const char *)name,(unsigned)stat_info.st_mode & gbl_umask.mask)))
       chmod(name,stat_info.st_mode & gbl_umask.mask);
     }
#ifdef ENV_HAVE_LSTAT
  } else if (!S_ISLNK(stat_info.st_mode)) {
    // do not use chmod on a link
#else
  } else {
#endif

    /* Only Windows Attributes */
    if( S_ISDIR(stat_info.st_mode)) {
       /* Remark : FILE_ATTRIBUTE_READONLY ignored for directory. */
       TRACEN((printf("##DBG chmod-4(%s,%o)\n",(const char *)name,(unsigned)stat_info.st_mode & gbl_umask.mask)))
       chmod(name,stat_info.st_mode & gbl_umask.mask);
    } else {
       if (fileAttributes & FILE_ATTRIBUTE_READONLY) stat_info.st_mode &= ~0222; /* octal!, clear write permission bits */
       TRACEN((printf("##DBG chmod-5(%s,%o)\n",(const char *)name,(unsigned)stat_info.st_mode & gbl_umask.mask)))
       chmod(name,stat_info.st_mode & gbl_umask.mask);
    }
  }
  TRACEN((printf("SetFileAttrib(%s,%d) : true\n",(const char *)name,fileAttributes)))

  return true;
}

bool RemoveDir(CFSTR path)
{
  if (!path || !*path) {
    SetLastError(ERROR_PATH_NOT_FOUND);
    return FALSE;
  }
  AString name = nameWindowToUnix2(path);
  TRACEN((printf("RemoveDirectoryA(%s)\n",(const char *)name)))

  if (rmdir( (const char *)name ) != 0) {
    return FALSE;
  }
  return TRUE;
}

bool MyMoveFile(CFSTR existFileName, CFSTR newFileName)
{
#ifdef _UNICODE
  AString src = nameWindowToUnix2(existFileName);
  AString dst = nameWindowToUnix2(newFileName);
#else
  const char * src = nameWindowToUnix(existFileName);
  const char * dst = nameWindowToUnix(newFileName);
#endif

  TRACEN((printf("MyMoveFile(%s,%s)\n",(const char *)src,(const char *)dst)))

  int ret = rename(src,dst);
  if (ret != 0)
  {
    if (errno == EXDEV) // FIXED : bug #1112167 (Temporary directory must be on same partition as target)
    {
      BOOL bret = CopyFile(src,dst);
      if (bret == FALSE) return false;

      struct stat info_file;
      ret = stat(src,&info_file);
      if (ret == 0) {
    TRACEN((printf("##DBG chmod-1(%s,%o)\n",(const char *)dst,(unsigned)info_file.st_mode & gbl_umask.mask)))
        ret = chmod(dst,info_file.st_mode & gbl_umask.mask);
      }
      if (ret == 0) {
         ret = unlink(src);
      }
      if (ret == 0) return true;
    }
    return false;
  }
  return true;
}

bool CreateDir(CFSTR path)
{
  if (!path || !*path) {
    SetLastError(ERROR_PATH_NOT_FOUND);
    return false;
  }

#ifdef _UNICODE
  AString name = nameWindowToUnix2(path);
#else
  const char * name = nameWindowToUnix(path);
#endif
  bool bret = false;
  if (mkdir( name, 0700 ) == 0) bret = true;

  TRACEN((printf("CreateDir(%s)=%d\n",(const char *)name,(int)bret)))
  return bret;
}

bool CreateComplexDir(CFSTR _aPathName)
{
  AString name = nameWindowToUnix2(_aPathName);
  TRACEN((printf("CreateComplexDir(%s)\n",(const char *)name)))


  FString pathName = _aPathName;
  int pos = pathName.ReverseFind(FCHAR_PATH_SEPARATOR);
  if (pos > 0 && pos == pathName.Len() - 1)
  {
    if (pathName.Len() == 3 && pathName[1] == L':')
      return true; // Disk folder;
    pathName.Delete(pos);
  }
  FString pathName2 = pathName;
  pos = pathName.Len();
  TRACEN((printf("CreateComplexDir(%s) pathName2=%ls\n",(const char *)name,(CFSTR)pathName2)))
  for (;;)
  {
    if (CreateDir(pathName))
      break;
    TRACEN((printf("CreateComplexDir(%s) GetLastError=%d (ERROR_ALREADY_EXISTS=%d)\n",(const char *)name,::GetLastError(), ERROR_ALREADY_EXISTS)))
    if (::GetLastError() == ERROR_ALREADY_EXISTS)
    {
#ifdef _WIN32 // FIXED for supporting symbolic link instead of a directory
      NFind::CFileInfo fileInfo;
      if (!fileInfo.Find(pathName)) // For network folders
        return true;
      if (!fileInfo.IsDir())
        return false;
#endif
      break;
    }
    pos = pathName.ReverseFind(FCHAR_PATH_SEPARATOR);
    if (pos < 0 || pos == 0)
      return false;
    if (pathName[pos - 1] == L':')
      return false;
    pathName = pathName.Left(pos);
  }
  pathName = pathName2;
  while (pos < pathName.Len())
  {
    pos = pathName.Find(FCHAR_PATH_SEPARATOR, pos + 1);
    if (pos < 0)
      pos = pathName.Len();
    if (!CreateDir(pathName.Left(pos)))
      return false;
  }
  return true;
}

bool DeleteFileAlways(CFSTR name)
{
  if (!name || !*name) {
    SetLastError(ERROR_PATH_NOT_FOUND);
    return false;
  }
#ifdef _UNICODE
   AString unixname = nameWindowToUnix2(name);
#else
   const char * unixname = nameWindowToUnix(name);
#endif
   bool bret = false;
   if (remove(unixname) == 0) bret = true;
   TRACEN((printf("DeleteFileAlways(%s)=%d\n",(const char *)unixname,(int)bret)))
   return bret;
}

bool RemoveDirWithSubItems(const FString &path)
{
  bool needRemoveSubItems = true;
  {
    NFind::CFileInfo fi;
    if (!fi.Find(path))
      return false;
    if (!fi.IsDir())
    {
      ::SetLastError(ERROR_DIRECTORY);
      return false;
    }
    if (fi.HasReparsePoint())
      needRemoveSubItems = false;
  }

  if (needRemoveSubItems)
  {
    FString s = path;
    s += FCHAR_PATH_SEPARATOR;
    unsigned prefixSize = s.Len();
    s += FCHAR_ANY_MASK;
    NFind::CEnumerator enumerator(s);
    NFind::CFileInfo fi;
    while (enumerator.Next(fi))
    {
      s.DeleteFrom(prefixSize);
      s += fi.Name;
      if (fi.IsDir())
      {
        if (!RemoveDirWithSubItems(s))
          return false;
      }
      else if (!DeleteFileAlways(s))
        return false;
    }
  }

  if (!SetFileAttrib(path, 0))
    return false;
  return RemoveDir(path);
}


bool RemoveDirectoryWithSubItems(const FString &path); // FIXME
static bool RemoveDirectorySubItems2(const FString pathPrefix, const NFind::CFileInfo &fileInfo)
{
  if (fileInfo.IsDir())
    return RemoveDirectoryWithSubItems(pathPrefix + fileInfo.Name);
  return DeleteFileAlways(pathPrefix + fileInfo.Name);
}
bool RemoveDirectoryWithSubItems(const FString &path)
{
  NFind::CFileInfo fileInfo;
  FString pathPrefix = path + FCHAR_PATH_SEPARATOR;
  {
    NFind::CEnumerator enumerator(pathPrefix + FCHAR_ANY_MASK);
    while (enumerator.Next(fileInfo))
      if (!RemoveDirectorySubItems2(pathPrefix, fileInfo))
        return false;
  }
  if (!SetFileAttrib(path, 0))
    return false;
  return RemoveDir(path);
}

#ifdef UNDER_CE

bool MyGetFullPathName(CFSTR fileName, FString &resFullPath)
{
  resFullPath = fileName;
  return true;
}

#else

bool MyGetFullPathName(CFSTR path, FString &resFullPath)
{
  return GetFullPath(path, resFullPath);
}

bool SetCurrentDir(CFSTR path)
{
   AString apath = UnicodeStringToMultiByte(path);

   return chdir((const char*)apath) == 0;
}

bool GetCurrentDir(FString &path)
{
  char begin[MAX_PATHNAME_LEN];
  begin[0]='c';
  begin[1]=':';
  char * cret = getcwd(begin+2, MAX_PATHNAME_LEN - 3);
  if (cret)
  {
#ifdef _UNICODE
    path = GetUnicodeString(begin);
#else
    path = begin;
#endif
    return true;
  }
  return false;
}

#endif

bool GetFullPathAndSplit(CFSTR path, FString &resDirPrefix, FString &resFileName)
{
  bool res = MyGetFullPathName(path, resDirPrefix);
  if (!res)
    resDirPrefix = path;
  int pos = resDirPrefix.ReverseFind(FCHAR_PATH_SEPARATOR);
  resFileName = resDirPrefix.Ptr(pos + 1);
  resDirPrefix.DeleteFrom(pos + 1);
  return res;
}

bool GetOnlyDirPrefix(CFSTR path, FString &resDirPrefix)
{
  FString resFileName;
  return GetFullPathAndSplit(path, resDirPrefix, resFileName);
}

bool MyGetTempPath(FString &path)
{
  path = L"c:/tmp/"; // final '/' is needed
  return true;
}

static bool CreateTempFile(CFSTR prefix, bool addRandom, FString &path, NIO::COutFile *outFile)
{
#ifdef _WIN32
  UInt32 d = (GetTickCount() << 12) ^ (GetCurrentThreadId() << 14) ^ GetCurrentProcessId();
#else
  static UInt32 memo_count = 0;
  UInt32 count;

  g_CountCriticalSection.Enter();
  count = memo_count++;
  g_CountCriticalSection.Leave();
  UINT number = (UINT)getpid();

  UInt32 d = (GetTickCount() << 12) ^ (count << 14) ^ number;
#endif
  for (unsigned i = 0; i < 100; i++)
  {
    path = prefix;
    if (addRandom)
    {
      FChar s[16];
      UInt32 value = d;
      unsigned k;
      for (k = 0; k < 8; k++)
      {
        unsigned t = value & 0xF;
        value >>= 4;
        s[k] = (char)((t < 10) ? ('0' + t) : ('A' + (t - 10)));
      }
      s[k] = '\0';
      if (outFile)
        path += FChar('.');
      path += s;
      UInt32 step = GetTickCount() + 2;
      if (step == 0)
        step = 1;
      d += step;
    }
    addRandom = true;
    if (outFile)
      path += FTEXT(".tmp");
    if (NFind::DoesFileOrDirExist(path))
    {
      SetLastError(ERROR_ALREADY_EXISTS);
      continue;
    }
    if (outFile)
    {
      if (outFile->Create(path, false))
        return true;
    }
    else
    {
      if (CreateDir(path))
        return true;
    }
    DWORD error = GetLastError();
    if (error != ERROR_FILE_EXISTS &&
        error != ERROR_ALREADY_EXISTS)
      break;
  }
  path.Empty();
  return false;
}

bool CTempFile::Create(CFSTR prefix, NIO::COutFile *outFile)
{
  if (!Remove())
    return false;
  if (!CreateTempFile(prefix, false, _path, outFile))
    return false;
  _mustBeDeleted = true;
  return true;
}

bool CTempFile::CreateRandomInTempFolder(CFSTR namePrefix, NIO::COutFile *outFile)
{
  if (!Remove())
    return false;
  FString tempPath;
  if (!MyGetTempPath(tempPath))
    return false;
  if (!CreateTempFile(tempPath + namePrefix, true, _path, outFile))
    return false;
  _mustBeDeleted = true;
  return true;
}

bool CTempFile::Remove()
{
  if (!_mustBeDeleted)
    return true;
  _mustBeDeleted = !DeleteFileAlways(_path);
  return !_mustBeDeleted;
}

bool CTempFile::MoveTo(CFSTR name, bool deleteDestBefore)
{
  if (deleteDestBefore)
    if (NFind::DoesFileExist(name))
      if (!DeleteFileAlways(name))
        return false;
  DisableDeleting();
  return MyMoveFile(_path, name);
}

bool CTempDir::Create(CFSTR prefix)
{
  if (!Remove())
    return false;
  FString tempPath;
  if (!MyGetTempPath(tempPath))
    return false;
  if (!CreateTempFile(tempPath + prefix, true, _path, NULL))
    return false;
  _mustBeDeleted = true;
  return true;
}

bool CTempDir::Remove()
{
  if (!_mustBeDeleted)
    return true;
  _mustBeDeleted = !RemoveDirectoryWithSubItems(_path);
  return !_mustBeDeleted;
}

#ifdef ENV_UNIX

CDelayedSymLink::CDelayedSymLink(const char * source)
  : _source(source)
{
  struct stat st;

  if (lstat(_source, &st) == 0) {
    _dev = st.st_dev;
    _ino = st.st_ino;
  } else {
    _dev = 0;
  }
}

bool CDelayedSymLink::Create()
{
  struct stat st;

  if (_dev == 0) {
    errno = EPERM;
    return false;
  }
  if (lstat(_source, &st) != 0)
    return false;
  if (_dev != st.st_dev || _ino != st.st_ino) {
    // Placeholder file has been overwritten or moved by another
    // symbolic link creation
    errno = EPERM;
    return false;
  }

  return convert_to_symlink(_source) == 0;
}

#endif // ENV_UNIX

}}}

#ifndef _SFX

namespace NWindows {
namespace NDLL {

FString GetModuleDirPrefix()
{
  FString s;

  const char *p7zip_home_dir = getenv("P7ZIP_HOME_DIR");
  if (p7zip_home_dir) {
    return MultiByteToUnicodeString(p7zip_home_dir,CP_ACP);
  }

  return FTEXT(".") FSTRING_PATH_SEPARATOR;
}

}}

#endif
// Windows/FileDir.h

#ifndef __WINDOWS_FILE_DIR_H
#define __WINDOWS_FILE_DIR_H

#include "../Common/MyString.h"
#include "../Common/MyVector.h"

#include "FileIO.h"

#ifdef ENV_UNIX
#include <sys/stat.h> // ino_t
#endif

namespace NWindows {
namespace NFile {
namespace NDir {

class CDelayedSymLink;

bool GetWindowsDir(FString &path);
bool GetSystemDir(FString &path);

bool SetDirTime(CFSTR path, const FILETIME *cTime, const FILETIME *aTime, const FILETIME *mTime);
bool SetFileAttrib(CFSTR path, DWORD attrib, CObjectVector<CDelayedSymLink> *delayedSymLinks = 0);
bool MyMoveFile(CFSTR existFileName, CFSTR newFileName);

#ifndef UNDER_CE
bool MyCreateHardLink(CFSTR newFileName, CFSTR existFileName);
#endif

bool RemoveDir(CFSTR path);
bool CreateDir(CFSTR path);

/* CreateComplexDir returns true, if directory can contain files after the call (two cases):
    1) the directory already exists (network shares and drive paths are supported)
    2) the directory was created
  path can be WITH or WITHOUT trailing path separator. */

bool CreateComplexDir(CFSTR path);

bool DeleteFileAlways(CFSTR name);
bool RemoveDirWithSubItems(const FString &path);

bool MyGetFullPathName(CFSTR path, FString &resFullPath);
bool GetFullPathAndSplit(CFSTR path, FString &resDirPrefix, FString &resFileName);
bool GetOnlyDirPrefix(CFSTR path, FString &resDirPrefix);

#ifndef UNDER_CE

bool SetCurrentDir(CFSTR path);
bool GetCurrentDir(FString &resultPath);

#endif

bool MyGetTempPath(FString &resultPath);

class CTempFile
{
  bool _mustBeDeleted;
  FString _path;
  void DisableDeleting() { _mustBeDeleted = false; }
public:
  CTempFile(): _mustBeDeleted(false) {}
  ~CTempFile() { Remove(); }
  const FString &GetPath() const { return _path; }
  bool Create(CFSTR pathPrefix, NIO::COutFile *outFile); // pathPrefix is not folder prefix
  bool CreateRandomInTempFolder(CFSTR namePrefix, NIO::COutFile *outFile);
  bool Remove();
  bool MoveTo(CFSTR name, bool deleteDestBefore);
};

class CTempDir
{
  bool _mustBeDeleted;
  FString _path;
public:
  CTempDir(): _mustBeDeleted(false) {}
  ~CTempDir() { Remove();  }
  const FString &GetPath() const { return _path; }
  void DisableDeleting() { _mustBeDeleted = false; }
  bool Create(CFSTR namePrefix) ;
  bool Remove();
};

// Symbolic links must be created last so that they can't be used to
// create or overwrite files above the extraction directory.
class CDelayedSymLink
{
#ifdef ENV_UNIX
  // Where the symlink should be created.  The target is specified in
  // the placeholder file.
  AString _source;

  // Device and inode of the placeholder file.  Before creating the
  // symlink, we must check that these haven't been changed by creation
  // of another symlink.
  dev_t _dev;
  ino_t _ino;

public:
  explicit CDelayedSymLink(const char * source);
  bool Create();
#else // !ENV_UNIX
public:
  CDelayedSymLink(const char * source) {}
  bool Create() { return true; }
#endif // ENV_UNIX
};


#if !defined(UNDER_CE)
class CCurrentDirRestorer
{
  FString _path;
public:
  bool NeedRestore;

  CCurrentDirRestorer(): NeedRestore(true)
  {
    GetCurrentDir(_path);
  }
  ~CCurrentDirRestorer()
  {
    if (!NeedRestore)
      return;
    FString s;
    if (GetCurrentDir(s))
      if (s != _path)
        SetCurrentDir(_path);
  }
};
#endif

}}}

#endif
// Windows/FileFind.cpp

#include "StdAfx.h"

#include "FileFind.h"
#include "FileIO.h"

#include "../Common/StringConvert.h"


#ifndef _UNICODE
extern bool g_IsNT;
#endif

#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>

#define NEED_NAME_WINDOWS_TO_UNIX
#include "myPrivate.h"

// #define TRACEN(u) u;
#define TRACEN(u)  /* */

void my_windows_split_path(const AString &p_path, AString &dir , AString &base) {
  int pos = p_path.ReverseFind('/');
  if (pos == -1) {
    // no separator
    dir  = ".";
    if (p_path.IsEmpty())
      base = ".";
    else
      base = p_path;
  } else if ((pos+1) < p_path.Len()) {
    // true separator
    base = p_path.Ptr(pos+1);
    while ((pos >= 1) && (p_path[pos-1] == '/'))
      pos--;
    if (pos == 0)
      dir = "/";
    else
      dir = p_path.Left(pos);
  } else {
    // separator at the end of the path
    // pos = p_path.find_last_not_of("/");
    pos = -1;
    int ind = 0;
    while (p_path[ind]) {
      if (p_path[ind] != '/')
        pos = ind;
      ind++;
    }
    if (pos == -1) {
      base = "/";
      dir = "/";
    } else {
      my_windows_split_path(p_path.Left(pos+1),dir,base);
    }
  }
}

static void my_windows_split_path(const UString &p_path, UString &dir , UString &base) {
  int pos = p_path.ReverseFind(L'/');
  if (pos == -1) {
    // no separator
    dir  = L".";
    if (p_path.IsEmpty())
      base = L".";
    else
      base = p_path;
  } else if ((pos+1) < p_path.Len()) {
    // true separator
    base = p_path.Ptr(pos+1);
    while ((pos >= 1) && (p_path[pos-1] == L'/'))
      pos--;
    if (pos == 0)
      dir = L"/";
    else
      dir = p_path.Left(pos);
  } else {
    // separator at the end of the path
    // pos = p_path.find_last_not_of("/");
    pos = -1;
    int ind = 0;
    while (p_path[ind]) {
      if (p_path[ind] != L'/')
        pos = ind;
      ind++;
    }
    if (pos == -1) {
      base = L"/";
      dir = L"/";
    } else {
      my_windows_split_path(p_path.Left(pos+1),dir,base);
    }
  }
}

static int filter_pattern(const char *string , const char *pattern , int flags_nocase) {
  if ((string == 0) || (*string==0)) {
    if (pattern == 0)
      return 1;
    while (*pattern=='*')
      ++pattern;
    return (!*pattern);
  }

  switch (*pattern) {
  case '*':
    if (!filter_pattern(string+1,pattern,flags_nocase))
      return filter_pattern(string,pattern+1,flags_nocase);
    return 1;
  case 0:
    if (*string==0)
      return 1;
    break;
  case '?':
    return filter_pattern(string+1,pattern+1,flags_nocase);
  default:
    if (   ((flags_nocase) && (tolower(*pattern)==tolower(*string)))
           || (*pattern == *string)
       ) {
      return filter_pattern(string+1,pattern+1,flags_nocase);
    }
    break;
  }
  return 0;
}

namespace NWindows {
namespace NFile {

#ifdef SUPPORT_DEVICE_FILE
bool IsDeviceName(CFSTR n);
#endif

#if defined(WIN_LONG_PATH)
bool GetLongPath(CFSTR fileName, UString &res);
#endif

namespace NFind {

bool CFileInfo::IsDots() const throw()
{
  if (!IsDir() || Name.IsEmpty())
    return false;
  if (Name[0] != FTEXT('.'))
    return false;
  return Name.Len() == 1 || (Name.Len() == 2 && Name[1] == FTEXT('.'));
}

#define WIN_FD_TO_MY_FI(fi, fd) \
  fi.Attrib = fd.dwFileAttributes; \
  fi.CTime = fd.ftCreationTime; \
  fi.ATime = fd.ftLastAccessTime; \
  fi.MTime = fd.ftLastWriteTime; \
  fi.Size = (((UInt64)fd.nFileSizeHigh) << 32) + fd.nFileSizeLow; \
  fi.IsDevice = false;

  /*
  #ifdef UNDER_CE
  fi.ObjectID = fd.dwOID;
  #else
  fi.ReparseTag = fd.dwReserved0;
  #endif
  */

#ifndef _UNICODE

static inline UINT GetCurrentCodePage() { return ::AreFileApisANSI() ? CP_ACP : CP_OEMCP; }

static void ConvertWIN32_FIND_DATA_To_FileInfo(const WIN32_FIND_DATA &fd, CFileInfo &fi)
{
  WIN_FD_TO_MY_FI(fi, fd);
  fi.Name = fas2fs(fd.cFileName);
}
#endif
  
////////////////////////////////
// CFindFile

bool CFindFile::Close()
{
  if(_dirp == 0)
    return true;
  int ret = closedir(_dirp);
  if (ret == 0)
  {
    _dirp = 0;
    return true;
  }
  return false;
}


static bool originalFilename(const UString & src, AString & res)
{
  // Try to recover the original filename
  res = "";
  int i=0;
  while (src[i])
  {
    if (src[i] >= 256) {
      return false;
    } else {
      res += char(src[i]);
    }
    i++;
  }
  return true;
}

// Warning this function cannot update "fileInfo.Name"
static int fillin_CFileInfo(CFileInfo &fileInfo,const char *filename,bool ignoreLink) {
  struct stat stat_info;

  int ret;
#ifdef ENV_HAVE_LSTAT
  if ( (global_use_lstat) && (ignoreLink == false)) {
    ret = lstat(filename,&stat_info);
  } else
#endif
  {
     ret = stat(filename,&stat_info);
  }

  // printf("fillin_CFileInfo(%s,%d)=%d  mode=%o\n",filename,(int)ignoreLink,ret,(unsigned)stat_info.st_mode);


  if (ret != 0) return ret;

  /* FIXME : FILE_ATTRIBUTE_HIDDEN ? */
  if (S_ISDIR(stat_info.st_mode)) {
    fileInfo.Attrib = FILE_ATTRIBUTE_DIRECTORY;
  } else {
    fileInfo.Attrib = FILE_ATTRIBUTE_ARCHIVE;
  }

  if (!(stat_info.st_mode & S_IWUSR))
    fileInfo.Attrib |= FILE_ATTRIBUTE_READONLY;

  fileInfo.Attrib |= FILE_ATTRIBUTE_UNIX_EXTENSION + ((stat_info.st_mode & 0xFFFF) << 16);

  RtlSecondsSince1970ToFileTime( stat_info.st_ctime, &fileInfo.CTime );
  RtlSecondsSince1970ToFileTime( stat_info.st_mtime, &fileInfo.MTime );
  RtlSecondsSince1970ToFileTime( stat_info.st_atime, &fileInfo.ATime );

  fileInfo.IsDevice = false;

  if (S_ISDIR(stat_info.st_mode)) {
    fileInfo.Size = 0;
  } else { // file or symbolic link
    fileInfo.Size = stat_info.st_size; // for a symbolic link, size = size of filename
  }
  return 0;
}

static int fillin_CFileInfo(CFileInfo &fi,const char *dir,const char *name,bool ignoreLink) {
  char filename[MAX_PATHNAME_LEN];
  size_t dir_len = strlen(dir);
  size_t name_len = strlen(name);
  size_t total = dir_len + 1 + name_len + 1; // 1 = strlen("/"); + le zero character
  if (total >= MAX_PATHNAME_LEN) throw "fillin_CFileInfo - internal error - MAX_PATHNAME_LEN";
  memcpy(filename,dir,dir_len);
  if (dir_len >= 1)
  {
	if (filename[dir_len-1] == CHAR_PATH_SEPARATOR)
	{ // delete the '/'
		dir_len--;
	}
  }
  filename[dir_len] = CHAR_PATH_SEPARATOR;
  memcpy(filename+(dir_len+1),name,name_len+1); // copy also final '\0'

#ifdef _UNICODE
  fi.Name = GetUnicodeString(name, CP_ACP);
#else
  fi.Name = name;
#endif

  int ret = fillin_CFileInfo(fi,filename,ignoreLink);
  if (ret != 0) {
	AString err_msg = "stat error for ";
        err_msg += filename;
        err_msg += " (";
        err_msg += strerror(errno);
        err_msg += ")";
        throw err_msg;
  }
  return ret;
}

bool CFindFile::FindFirst(CFSTR cfWildcard, CFileInfo &fi, bool ignoreLink)
{
  if (!Close())
    return false;

  AString Awildcard = UnicodeStringToMultiByte(cfWildcard, CP_ACP);
  const char * wildcard = (const char *)Awildcard;


  if ((!wildcard) || (wildcard[0]==0)) {
    SetLastError(ERROR_PATH_NOT_FOUND);
    return false;
  }
 
  my_windows_split_path(nameWindowToUnix(wildcard),_directory,_pattern);
  
  TRACEN((printf("CFindFile::FindFirst : %s (dirname=%s,pattern=%s)\n",wildcard,(const char *)_directory,(const char *)_pattern)))

  _dirp = ::opendir((const char *)_directory);
  TRACEN((printf("CFindFile::FindFirst : opendir=%p\n",_dirp)))

  if ((_dirp == 0) && (global_use_utf16_conversion)) {
    // Try to recover the original filename
    UString ustr = MultiByteToUnicodeString(_directory, 0);
    AString resultString;
    bool is_good = originalFilename(ustr, resultString);
    if (is_good) {
      _dirp = ::opendir((const char *)resultString);
      _directory = resultString;
    }
  }

  if (_dirp == 0) return false;

  struct dirent *dp;
  while ((dp = readdir(_dirp)) != NULL) {
    if (filter_pattern(dp->d_name,(const char *)_pattern,0) == 1) {
      int retf = fillin_CFileInfo(fi,(const char *)_directory,dp->d_name,ignoreLink);
      if (retf)
      {
         TRACEN((printf("CFindFile::FindFirst : closedir-1(dirp=%p)\n",_dirp)))
         closedir(_dirp);
         _dirp = 0;
         SetLastError( ERROR_NO_MORE_FILES );
         return false;
      }
      TRACEN((printf("CFindFile::FindFirst -%s- true\n",dp->d_name)))
      return true;
    }
  }

  TRACEN((printf("CFindFile::FindFirst : closedir-2(dirp=%p)\n",_dirp)))
  closedir(_dirp);
  _dirp = 0;
  SetLastError( ERROR_NO_MORE_FILES );
  return false;

}

bool CFindFile::FindNext(CFileInfo &fi)
{
  if (_dirp == 0)
  {
    SetLastError( ERROR_INVALID_HANDLE );
    return false;
  }

  struct dirent *dp;
  while ((dp = readdir(_dirp)) != NULL) {
      if (filter_pattern(dp->d_name,(const char *)_pattern,0) == 1) {
        int retf = fillin_CFileInfo(fi,(const char *)_directory,dp->d_name,false);
        if (retf)
        {
           TRACEN((printf("FindNextFileA -%s- ret_handle=FALSE (errno=%d)\n",dp->d_name,errno)))
           return false;

        }
        TRACEN((printf("FindNextFileA -%s- true\n",dp->d_name)))
        return true;
      }
    }
  TRACEN((printf("FindNextFileA ret_handle=FALSE (ERROR_NO_MORE_FILES)\n")))
  SetLastError( ERROR_NO_MORE_FILES );
  return false;
}

#define MY_CLEAR_FILETIME(ft) ft.dwLowDateTime = ft.dwHighDateTime = 0;

void CFileInfoBase::ClearBase() throw()
{
  Size = 0;
  MY_CLEAR_FILETIME(CTime);
  MY_CLEAR_FILETIME(ATime);
  MY_CLEAR_FILETIME(MTime);
  Attrib = 0;
  IsAltStream = false;
  IsDevice = false;
}
  
bool CFileInfo::Find(CFSTR wildcard, bool ignoreLink)
{
  #ifdef SUPPORT_DEVICE_FILE
  if (IsDeviceName(wildcard))
  {
    Clear();
    IsDevice = true;
    NIO::CInFile inFile;
    if (!inFile.Open(wildcard))
      return false;
    Name = wildcard + 4;
    if (inFile.LengthDefined)
      Size = inFile.Length;
    return true;
  }
  #endif
  CFindFile finder;
  if (finder.FindFirst(wildcard, *this,ignoreLink))
    return true;
  #ifdef _WIN32
  {
    DWORD lastError = GetLastError();
    if (lastError == ERROR_BAD_NETPATH || lastError == ERROR_FILE_NOT_FOUND)
    {
      int len = MyStringLen(wildcard);
      if (len > 2 && wildcard[0] == '\\' && wildcard[1] == '\\')
      {
        int pos = FindCharPosInString(wildcard + 2, FTEXT('\\'));
        if (pos >= 0)
        {
          pos += 2 + 1;
          len -= pos;
          CFSTR remString = wildcard + pos;
          int pos2 = FindCharPosInString(remString, FTEXT('\\'));
          FString s = wildcard;
          if (pos2 < 0 || pos2 == len - 1)
          {
            FString s = wildcard;
            if (pos2 < 0)
            {
              pos2 = len;
              s += FTEXT('\\');
            }
            s += FCHAR_ANY_MASK;
            if (finder.FindFirst(s, *this))
              if (Name == FTEXT("."))
              {
		Name.SetFrom(s.Ptr(pos), pos2);
                return true;
              }
            ::SetLastError(lastError);
          }
        }
      }
    }
  }
  #endif
  return false;
}

bool DoesFileExist(CFSTR name)
{
  CFileInfo fi;
  return fi.Find(name) && !fi.IsDir();
}

bool DoesDirExist(CFSTR name)
{
  CFileInfo fi;
  return fi.Find(name) && fi.IsDir();
}
bool DoesFileOrDirExist(CFSTR name)
{
  CFileInfo fi;
  return fi.Find(name);
}

bool CEnumerator::NextAny(CFileInfo &fi)
{
  if (_findFile.IsHandleAllocated())
    return _findFile.FindNext(fi);
  else
    return _findFile.FindFirst(_wildcard, fi);
}

bool CEnumerator::Next(CFileInfo &fi)
{
  for (;;)
  {
    if (!NextAny(fi))
      return false;
    if (!fi.IsDots())
      return true;
  }
}

bool CEnumerator::Next(CFileInfo &fi, bool &found)
{
  if (Next(fi))
  {
    found = true;
    return true;
  }
  found = false;
  return (::GetLastError() == ERROR_NO_MORE_FILES);
}

////////////////////////////////
// CFindChangeNotification
// FindFirstChangeNotification can return 0. MSDN doesn't tell about it.

#ifdef _WIN32
bool CFindChangeNotification::Close()
{
  if (!IsHandleAllocated())
    return true;
  if (!::FindCloseChangeNotification(_handle))
    return false;
  _handle = INVALID_HANDLE_VALUE;
  return true;
}
           
HANDLE CFindChangeNotification::FindFirst(CFSTR pathName, bool watchSubtree, DWORD notifyFilter)
{
  #ifndef _UNICODE
  if (!g_IsNT)
    _handle = ::FindFirstChangeNotification(fs2fas(pathName), BoolToBOOL(watchSubtree), notifyFilter);
  else
  #endif
  {
    _handle = ::FindFirstChangeNotificationW(fs2us(pathName), BoolToBOOL(watchSubtree), notifyFilter);
    #ifdef WIN_LONG_PATH
    if (!IsHandleAllocated())
    {
      UString longPath;
      if (GetLongPath(pathName, longPath))
        _handle = ::FindFirstChangeNotificationW(longPath, BoolToBOOL(watchSubtree), notifyFilter);
    }
    #endif
  }
  return _handle;
}

#ifndef UNDER_CE

bool MyGetLogicalDriveStrings(CObjectVector<FString> &driveStrings)
{
  driveStrings.Clear();
  #ifndef _UNICODE
  if (!g_IsNT)
  {
    driveStrings.Clear();
    UINT32 size = GetLogicalDriveStrings(0, NULL);
    if (size == 0)
      return false;
    AString buf;
    UINT32 newSize = GetLogicalDriveStrings(size, buf.GetBuffer(size));
    if (newSize == 0 || newSize > size)
      return false;
    AString s;
    for (UINT32 i = 0; i < newSize; i++)
    {
      char c = buf[i];
      if (c == '\0')
      {
        driveStrings.Add(fas2fs(s));
        s.Empty();
      }
      else
        s += c;
    }
    return s.IsEmpty();
  }
  else
  #endif
  {
    UINT32 size = GetLogicalDriveStringsW(0, NULL);
    if (size == 0)
      return false;
    UString buf;
    UINT32 newSize = GetLogicalDriveStringsW(size, buf.GetBuffer(size));
    if (newSize == 0 || newSize > size)
      return false;
    UString s;
    for (UINT32 i = 0; i < newSize; i++)
    {
      WCHAR c = buf[i];
      if (c == L'\0')
      {
        driveStrings.Add(us2fs(s));
        s.Empty();
      }
      else
        s += c;
    }
    return s.IsEmpty();
  }
}

#endif

#endif // _WIN32

}}}
// Windows/FileFind.h

#ifndef __WINDOWS_FILE_FIND_H
#define __WINDOWS_FILE_FIND_H

#include "../Common/MyString.h"
#include "../Common/MyTypes.h"
#include "Defs.h"

#include <sys/types.h> /* for DIR */
#include <dirent.h>

namespace NWindows {
namespace NFile {
namespace NFind {

namespace NAttributes
{
  inline bool IsReadOnly(DWORD attrib) { return (attrib & FILE_ATTRIBUTE_READONLY) != 0; }
  inline bool IsHidden(DWORD attrib) { return (attrib & FILE_ATTRIBUTE_HIDDEN) != 0; }
  inline bool IsSystem(DWORD attrib) { return (attrib & FILE_ATTRIBUTE_SYSTEM) != 0; }
  inline bool IsDir(DWORD attrib) { return (attrib & FILE_ATTRIBUTE_DIRECTORY) != 0; }
  inline bool IsArchived(DWORD attrib) { return (attrib & FILE_ATTRIBUTE_ARCHIVE) != 0; }
  inline bool IsCompressed(DWORD attrib) { return (attrib & FILE_ATTRIBUTE_COMPRESSED) != 0; }
  inline bool IsEncrypted(DWORD attrib) { return (attrib & FILE_ATTRIBUTE_ENCRYPTED) != 0; }
}

class CFileInfoBase
{
  bool MatchesMask(UINT32 mask) const { return ((Attrib & mask) != 0); }
public:
  UInt64 Size;
  FILETIME CTime;
  FILETIME ATime;
  FILETIME MTime;
  DWORD Attrib;
  bool IsAltStream;
  bool IsDevice;

  /*
  #ifdef UNDER_CE
  DWORD ObjectID;
  #else
  UINT32 ReparseTag;
  #endif
  */

  CFileInfoBase() { ClearBase(); }
  void ClearBase() throw();

  void SetAsDir() { Attrib = FILE_ATTRIBUTE_DIRECTORY; }

  bool IsArchived() const { return MatchesMask(FILE_ATTRIBUTE_ARCHIVE); }
  bool IsCompressed() const { return MatchesMask(FILE_ATTRIBUTE_COMPRESSED); }
  bool IsDir() const { return MatchesMask(FILE_ATTRIBUTE_DIRECTORY); }
  bool IsEncrypted() const { return MatchesMask(FILE_ATTRIBUTE_ENCRYPTED); }
  bool IsHidden() const { return MatchesMask(FILE_ATTRIBUTE_HIDDEN); }
  bool IsNormal() const { return MatchesMask(FILE_ATTRIBUTE_NORMAL); }
  bool IsOffline() const { return MatchesMask(FILE_ATTRIBUTE_OFFLINE); }
  bool IsReadOnly() const { return MatchesMask(FILE_ATTRIBUTE_READONLY); }
  bool HasReparsePoint() const { return MatchesMask(FILE_ATTRIBUTE_REPARSE_POINT); }
  bool IsSparse() const { return MatchesMask(FILE_ATTRIBUTE_SPARSE_FILE); }
  bool IsSystem() const { return MatchesMask(FILE_ATTRIBUTE_SYSTEM); }
  bool IsTemporary() const { return MatchesMask(FILE_ATTRIBUTE_TEMPORARY); }
};

struct CFileInfo: public CFileInfoBase
{
  FString Name;
  #if defined(_WIN32) && !defined(UNDER_CE)
  // FString ShortName;
  #endif

  bool IsDots() const throw();
  bool Find(CFSTR wildcard, bool ignoreLink = false);
};

class CFindFile
{
  friend class CEnumerator;
  DIR *_dirp;
  AString _pattern;
  AString _directory;  
public:
  bool IsHandleAllocated() const { return  (_dirp != 0); }
  CFindFile(): _dirp(0) {}
  ~CFindFile() { Close(); }
  bool FindFirst(CFSTR wildcard, CFileInfo &fileInfo, bool ignoreLink = false);
  bool FindNext(CFileInfo &fileInfo);
  bool Close();
};

bool DoesFileExist(CFSTR name);
bool DoesDirExist(CFSTR name);
bool DoesFileOrDirExist(CFSTR name);

class CEnumerator
{
  CFindFile _findFile;
  FString _wildcard;

  bool NextAny(CFileInfo &fileInfo);
public:
  CEnumerator(const FString &wildcard): _wildcard(wildcard) {}
  bool Next(CFileInfo &fileInfo);
  bool Next(CFileInfo &fileInfo, bool &found);
};

#ifdef _WIN32
class CFindChangeNotification
{
  HANDLE _handle;
public:
  operator HANDLE () { return _handle; }
  bool IsHandleAllocated() const { return _handle != INVALID_HANDLE_VALUE && _handle != 0; }
  CFindChangeNotification(): _handle(INVALID_HANDLE_VALUE) {}
  ~CFindChangeNotification() { Close(); }
  bool Close() throw();
  HANDLE FindFirst(CFSTR pathName, bool watchSubtree, DWORD notifyFilter);
  bool FindNext() { return BOOLToBool(::FindNextChangeNotification(_handle)); }
};
#endif

#ifndef UNDER_CE
bool MyGetLogicalDriveStrings(CObjectVector<FString> &driveStrings);
#endif

}}}

#endif
// Windows/FileIO.cpp

#include "StdAfx.h"

#include "FileIO.h"
#include "Defs.h"
#include "../Common/StringConvert.h"

#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#define NEED_NAME_WINDOWS_TO_UNIX
#include "myPrivate.h"

#include <sys/types.h>
#include <utime.h>

#ifdef ENV_HAVE_LSTAT
#define FD_LINK (-2)
#endif

#define GENERIC_READ	0x80000000
#define GENERIC_WRITE	0x40000000

#ifdef ENV_HAVE_LSTAT
extern "C"
{
int global_use_lstat=1; // default behaviour : p7zip stores symlinks instead of dumping the files they point to
}
#endif

extern BOOLEAN WINAPI RtlTimeToSecondsSince1970( const LARGE_INTEGER *Time, DWORD *Seconds );

namespace NWindows {
namespace NFile {
namespace NIO {

CFileBase::~CFileBase()
{
  Close();
}

bool CFileBase::Create(CFSTR filename, DWORD dwDesiredAccess,
    DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,bool ignoreSymbolicLink)
{
  Close();
  
  int   flags = 0;
#ifdef USE_UNICODE_FSTRING
   AString astr = UnicodeStringToMultiByte(filename);
   const char * name = nameWindowToUnix((const char *)astr);
#else
  const char * name = nameWindowToUnix(filename);
#endif

#ifdef O_BINARY
  flags |= O_BINARY;
#endif

#ifdef O_LARGEFILE
  flags |= O_LARGEFILE;
#endif

  /* now use the umask value */
  int mask = umask(0);
  (void)umask(mask);
  int mode = 0666 & ~(mask & 066); /* keep the R/W for the user */

  if (dwDesiredAccess & GENERIC_WRITE) flags |= O_WRONLY;
  if (dwDesiredAccess & GENERIC_READ)  flags |= O_RDONLY;


  switch (dwCreationDisposition)
  {
    case CREATE_NEW    : flags |= O_CREAT | O_EXCL; break;
    case CREATE_ALWAYS : flags |= O_CREAT;          break;
    case OPEN_EXISTING :                            break;
    case OPEN_ALWAYS   : flags |= O_CREAT;          break;
    // case TRUNCATE_EXISTING : flags |= O_TRUNC;      break;
  }
  // printf("##DBG open(%s,0x%x,%o)##\n",name,flags,(unsigned)mode);

  _fd = -1;
#ifdef ENV_HAVE_LSTAT
   if ((global_use_lstat) && (ignoreSymbolicLink == false))
   {
     _size = readlink(name, _buffer, sizeof(_buffer)-1);
     if (_size > 0) {
       if (dwDesiredAccess & GENERIC_READ) {
         _fd = FD_LINK;
         _offset = 0;
         _buffer[_size]=0;
       } else if (dwDesiredAccess & GENERIC_WRITE) {
         // does not overwrite the file pointed by symbolic link
         if (!unlink(name)) return false;
       }
     }
  }
#endif

  if (_fd == -1) {
    _fd = open(name,flags, mode);
  }

  if ((_fd == -1) && (global_use_utf16_conversion)) {
    // bug #1204993 - Try to recover the original filename
    UString ustr = MultiByteToUnicodeString(AString(name), 0);
    AString resultString;
    int is_good = 1;
    for (int i = 0; i < ustr.Len(); i++)
    {
      if (ustr[i] >= 256) {
        is_good = 0;
        break;
      } else {
        resultString += char(ustr[i]);
      }
    }
    if (is_good) {
      _fd = open((const char *)resultString,flags, mode);
    }
  }

  if (_fd == -1) {
    /* !ENV_HAVE_LSTAT : an invalid symbolic link => errno == ENOENT */
    return false;
  } else {
    _unix_filename = name;
  }

  return true;
}

/* FIXME
bool CFileBase::Create(LPCWSTR fileName, DWORD desiredAccess,
    DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes,bool ignoreSymbolicLink)
{
  Close();
    return Create(UnicodeStringToMultiByte(fileName, CP_ACP), 
      desiredAccess, shareMode, creationDisposition, flagsAndAttributes,ignoreSymbolicLink);
}
*/

bool CFileBase::Close()
{
  struct utimbuf buf;

  buf.actime  = _lastAccessTime;
  buf.modtime = _lastWriteTime;

  _lastAccessTime = _lastWriteTime = (time_t)-1;

  if(_fd == -1)
    return true;

#ifdef ENV_HAVE_LSTAT
  if(_fd == FD_LINK) {
    _fd = -1;
    return true;
  }
#endif

  int ret = ::close(_fd);
  if (ret == 0) {
    _fd = -1;

    /* On some OS (mingwin, MacOSX ...), you must close the file before updating times */
    if ((buf.actime != (time_t)-1) || (buf.modtime != (time_t)-1)) {
      struct stat    oldbuf;
      int ret = stat((const char*)(_unix_filename),&oldbuf);
      if (ret == 0) {
        if (buf.actime  == (time_t)-1) buf.actime  = oldbuf.st_atime;
        if (buf.modtime == (time_t)-1) buf.modtime = oldbuf.st_mtime;
      } else {
        time_t current_time = time(0);
        if (buf.actime  == (time_t)-1) buf.actime  = current_time;
        if (buf.modtime == (time_t)-1) buf.modtime = current_time;
      }
      /* ret = */ utime((const char *)(_unix_filename), &buf);
    }
    return true;
  }
  return false;
}

bool CFileBase::GetLength(UINT64 &length) const
{
  if (_fd == -1)
  {
     SetLastError( ERROR_INVALID_HANDLE );
     return false;
  }

#ifdef ENV_HAVE_LSTAT  
  if (_fd == FD_LINK) {
    length = _size;
    return true;
  }
#endif

  off_t pos_cur = ::lseek(_fd, 0, SEEK_CUR);
  if (pos_cur == (off_t)-1)
    return false;

  off_t pos_end = ::lseek(_fd, 0, SEEK_END);
  if (pos_end == (off_t)-1)
    return false;

  off_t pos_cur2 = ::lseek(_fd, pos_cur, SEEK_SET);
  if (pos_cur2 == (off_t)-1)
    return false;

  length = (UINT64)pos_end;

  return true;
}

bool CFileBase::Seek(INT64 distanceToMove, DWORD moveMethod, UINT64 &newPosition)
{
  if (_fd == -1)
  {
     SetLastError( ERROR_INVALID_HANDLE );
     return false;
  }

#ifdef ENV_HAVE_LSTAT
  if (_fd == FD_LINK) {
    INT64 offset;
    switch (moveMethod) {
    case STREAM_SEEK_SET : offset = distanceToMove; break;
    case STREAM_SEEK_CUR : offset = _offset + distanceToMove; break;
    case STREAM_SEEK_END : offset = _size + distanceToMove; break;
    default :  offset = -1;
    }
    if (offset < 0) {
      SetLastError( EINVAL );
      return false;
    }
    if (offset > _size) offset = _size;
    newPosition = _offset = offset;
    return true;
  }
#endif

  bool ret = true;

  off_t pos = (off_t)distanceToMove;

  off_t newpos = ::lseek(_fd,pos,moveMethod);

  if (newpos == ((off_t)-1)) {
    ret = false;
  } else {
    newPosition = (UINT64)newpos;
  }

  return ret;
}

bool CFileBase::Seek(UINT64 position, UINT64 &newPosition)
{
  return Seek(position, FILE_BEGIN, newPosition);
}

/////////////////////////
// CInFile

bool CInFile::Open(CFSTR fileName, DWORD shareMode, 
    DWORD creationDisposition,  DWORD flagsAndAttributes)
{
  return Create(fileName, GENERIC_READ, shareMode, 
      creationDisposition, flagsAndAttributes);
}

bool CInFile::Open(CFSTR fileName,bool ignoreSymbolicLink)
{
  return Create(fileName, GENERIC_READ , FILE_SHARE_READ, OPEN_EXISTING, 
     FILE_ATTRIBUTE_NORMAL,ignoreSymbolicLink);
}

// ReadFile and WriteFile functions in Windows have BUG:
// If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1) 
// from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES 
// (Insufficient system resources exist to complete the requested service).

// static UINT32 kChunkSizeMax = (1 << 24);

bool CInFile::ReadPart(void *data, UINT32 size, UINT32 &processedSize)
{
  // if (size > kChunkSizeMax)
  //  size = kChunkSizeMax;
  return Read(data,size,processedSize);
}

bool CInFile::Read(void *buffer, UINT32 bytesToRead, UINT32 &bytesRead)
{
  if (_fd == -1)
  {
     SetLastError( ERROR_INVALID_HANDLE );
     return false;
  }

  if (bytesToRead == 0) {
    bytesRead =0;
    return TRUE;
  }

#ifdef ENV_HAVE_LSTAT
  if (_fd == FD_LINK) {
    if (_offset >= _size) {
      bytesRead = 0;
      return TRUE;
    }
    int len = (_size - _offset);
    if (len > bytesToRead) len = bytesToRead;
    memcpy(buffer,_buffer+_offset,len);
    bytesRead = len;
    _offset += len;
    return TRUE;
  }
#endif

  ssize_t  ret;
  do {
    ret = read(_fd,buffer,bytesToRead);
  } while (ret < 0 && (errno == EINTR));

  if (ret != -1) {
    bytesRead = ret;
    return TRUE;
  }
  bytesRead =0;
  return FALSE;
}

/////////////////////////
// COutFile

bool COutFile::Open(CFSTR fileName, DWORD shareMode, 
    DWORD creationDisposition, DWORD flagsAndAttributes)
{
  return CFileBase::Create(fileName, GENERIC_WRITE, shareMode, 
      creationDisposition, flagsAndAttributes);
}

static inline DWORD GetCreationDisposition(bool createAlways)
  {  return createAlways? CREATE_ALWAYS: CREATE_NEW; }

bool COutFile::Open(CFSTR fileName, DWORD creationDisposition)
{
  return Open(fileName, FILE_SHARE_READ, 
      creationDisposition, FILE_ATTRIBUTE_NORMAL);
}

bool COutFile::Create(CFSTR fileName, bool createAlways)
{
  return Open(fileName, GetCreationDisposition(createAlways));
}

bool COutFile::CreateAlways(CFSTR fileName, DWORD /* flagsAndAttributes */ )
{
  return Open(fileName, true); // FIXME
}

bool COutFile::SetTime(const FILETIME *cTime, const FILETIME *aTime, const FILETIME *mTime) throw()
{
  LARGE_INTEGER  ltime;
  DWORD dw;

  if (_fd == -1) {
     SetLastError( ERROR_INVALID_HANDLE );
     return false;
  }

  /* On some OS (cygwin, MacOSX ...), you must close the file before updating times */
  if (aTime) {
     ltime.QuadPart = aTime->dwHighDateTime;
     ltime.QuadPart = (ltime.QuadPart << 32) | aTime->dwLowDateTime;
     RtlTimeToSecondsSince1970( &ltime, &dw );
     _lastAccessTime = dw;
  }
  if (mTime) {
     ltime.QuadPart = mTime->dwHighDateTime;
     ltime.QuadPart = (ltime.QuadPart << 32) | mTime->dwLowDateTime;
     RtlTimeToSecondsSince1970( &ltime, &dw );
     _lastWriteTime = dw;
  }

  return true;
}

bool COutFile::SetMTime(const FILETIME *mTime) throw()
{
  return SetTime(NULL, NULL, mTime);
}

bool COutFile::WritePart(const void *data, UINT32 size, UINT32 &processedSize) throw()
{
//  if (size > kChunkSizeMax)
//    size = kChunkSizeMax;

  return Write(data,size,processedSize);
}

bool COutFile::Write(const void *buffer, UINT32 bytesToWrite, UINT32 &bytesWritten) throw()
{
  if (_fd == -1)
  {
     SetLastError( ERROR_INVALID_HANDLE );
     return false;
  }

  ssize_t  ret;
  do {
    ret = write(_fd,buffer, bytesToWrite);
  } while (ret < 0 && (errno == EINTR));

  if (ret != -1) {
    bytesWritten = ret;
    return TRUE;
  }
  bytesWritten =0;
  return FALSE;
}

bool COutFile::SetEndOfFile() throw()
{
  if (_fd == -1)
  {
     SetLastError( ERROR_INVALID_HANDLE );
     return false;
  }

  bool bret = false;

  off_t pos_cur = lseek(_fd, 0, SEEK_CUR);
  if (pos_cur != (off_t)-1) {
    int iret = ftruncate(_fd, pos_cur);
    if (iret == 0) bret = true;
  }

  return bret;
}

bool COutFile::SetLength(UINT64 length) throw()
{
  UINT64 newPosition;
  if(!Seek(length, newPosition))
    return false;
  if(newPosition != length)
    return false;
  return SetEndOfFile();
}

}}}
// Windows/FileIO.h

#ifndef __WINDOWS_FILEIO_H
#define __WINDOWS_FILEIO_H

#include <Common/MyString.h>

#ifndef _WIN32

#define FILE_SHARE_READ	1
#define FILE_SHARE_WRITE 2

#define FILE_BEGIN	SEEK_SET
#define FILE_CURRENT	SEEK_CUR
#define FILE_END	SEEK_END
#define INVALID_SET_FILE_POINTER	((DWORD)-1)

#endif

#define _my_IO_REPARSE_TAG_MOUNT_POINT  (0xA0000003L)
#define _my_IO_REPARSE_TAG_SYMLINK      (0xA000000CL)

#define _my_SYMLINK_FLAG_RELATIVE 1

namespace NWindows {
namespace NFile {

struct CReparseAttr
{
  UInt32 Tag;
  UInt32 Flags;
  UString SubsName;
  UString PrintName;

  CReparseAttr(): Tag(0), Flags(0) {}
  bool Parse(const Byte *p, size_t size);

  bool IsMountPoint() const { return Tag == _my_IO_REPARSE_TAG_MOUNT_POINT; } // it's Junction
  bool IsSymLink() const { return Tag == _my_IO_REPARSE_TAG_SYMLINK; }
  bool IsRelative() const { return Flags == _my_SYMLINK_FLAG_RELATIVE; }
  // bool IsVolume() const;

  bool IsOkNamePair() const;
  UString GetPath() const;
};

namespace NIO {


class CFileBase
{
protected:
  int     _fd;
  AString _unix_filename;
  time_t   _lastAccessTime;
  time_t   _lastWriteTime;
#ifdef ENV_HAVE_LSTAT
  int     _size;
  char    _buffer[MAX_PATHNAME_LEN+1];
  int     _offset;
#endif

  bool Create(CFSTR fileName, DWORD desiredAccess,
      DWORD shareMode, DWORD creationDisposition,  DWORD flagsAndAttributes,bool ignoreSymbolicLink=false);

public:
  CFileBase(): _fd(-1) {};
  virtual ~CFileBase();

  virtual bool Close();

  bool GetLength(UINT64 &length) const;

  bool Seek(INT64 distanceToMove, DWORD moveMethod, UINT64 &newPosition);
  bool Seek(UINT64 position, UINT64 &newPosition);
};

class CInFile: public CFileBase
{
public:
  bool Open(CFSTR fileName, DWORD shareMode, DWORD creationDisposition,  DWORD flagsAndAttributes);
  bool OpenShared(CFSTR fileName, bool /* shareForWrite */ ,bool ignoreSymbolicLink=false) {
    return Open(fileName,ignoreSymbolicLink);
  }
  bool Open(CFSTR fileName,bool ignoreSymbolicLink=false);
  bool ReadPart(void *data, UINT32 size, UINT32 &processedSize);
  bool Read(void *data, UINT32 size, UINT32 &processedSize);
};

class COutFile: public CFileBase
{
public:
  bool Open(CFSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes);
  bool Open(CFSTR fileName, DWORD creationDisposition);
  bool Create(CFSTR fileName, bool createAlways);
  bool CreateAlways(CFSTR fileName, DWORD flagsAndAttributes);

  bool SetTime(const FILETIME *cTime, const FILETIME *aTime, const FILETIME *mTime) throw();
  bool SetMTime(const FILETIME *mTime) throw();
  bool WritePart(const void *data, UInt32 size, UInt32 &processedSize) throw();
  bool Write(const void *data, UInt32 size, UInt32 &processedSize) throw();
  bool SetEndOfFile() throw();
  bool SetLength(UInt64 length) throw();
};

}}}

#endif
// Windows/FileName.cpp

#include "StdAfx.h"

#include "Windows/FileName.h"
#include "Common/Wildcard.h"

#include "Common/StringConvert.h"

namespace NWindows {
namespace NFile {
namespace NDir {
bool MyGetFullPathName(CFSTR path, FString &resFullPath);
}}}

namespace NWindows {
namespace NFile {
namespace NName {

#define IS_SEPAR(c) IS_PATH_SEPAR(c)

int FindSepar(const wchar_t *s) throw()
{
  for (const wchar_t *p = s;; p++)
  {
    const wchar_t c = *p;
    if (c == 0)
      return -1;
    if (IS_SEPAR(c))
      return (int)(p - s);
  }
}

#ifndef USE_UNICODE_FSTRING
int FindSepar(const FChar *s) throw()
{
  for (const FChar *p = s;; p++)
  {
    const FChar c = *p;
    if (c == 0)
      return -1;
    if (IS_SEPAR(c))
      return (int)(p - s);
  }
}
#endif


#ifndef USE_UNICODE_FSTRING
void NormalizeDirPathPrefix(FString &dirPath)
{
  if (dirPath.IsEmpty())
    return;
  if (dirPath.Back() != FCHAR_PATH_SEPARATOR)
    dirPath += FCHAR_PATH_SEPARATOR;
}
#endif

void NormalizeDirPathPrefix(UString &dirPath)
{
  if (dirPath.IsEmpty())
    return;
  if (dirPath.Back() != WCHAR_PATH_SEPARATOR)
    dirPath += WCHAR_PATH_SEPARATOR;
}


#ifdef _WIN32

const wchar_t *kSuperPathPrefix = L"\\\\?\\";
static const wchar_t *kSuperUncPrefix = L"\\\\?\\UNC\\";

#define IS_DEVICE_PATH(s)  ((s)[0] == '\\' && (s)[1] == '\\' && (s)[2] == '.' && (s)[3] == '\\')
#define IS_SUPER_PREFIX(s) ((s)[0] == '\\' && (s)[1] == '\\' && (s)[2] == '?' && (s)[3] == '\\')
#define IS_SUPER_OR_DEVICE_PATH(s) ((s)[0] == '\\' && (s)[1] == '\\' && ((s)[2] == '?' || (s)[2] == '.') && (s)[3] == '\\')
#define IS_LETTER_CHAR(c) ((c) >= 'a' && (c) <= 'z' || (c) >= 'A' && (c) <= 'Z')

#define IS_UNC_WITH_SLASH(s) ( \
  ((s)[0] == 'U' || (s)[0] == 'u') && \
  ((s)[1] == 'N' || (s)[1] == 'n') && \
  ((s)[2] == 'C' || (s)[2] == 'c') && \
   (s)[3] == '\\')

bool IsDevicePath(CFSTR s) throw()
{
  #ifdef UNDER_CE

  s = s;
  return false;
  /*
  // actually we don't know the way to open device file in WinCE.
  unsigned len = MyStringLen(s);
  if (len < 5 || len > 5 || memcmp(s, FTEXT("DSK"), 3 * sizeof(FChar)) != 0)
    return false;
  if (s[4] != ':')
    return false;
  // for reading use SG_REQ sg; if (DeviceIoControl(dsk, IOCTL_DISK_READ));
  */
  
  #else
  
  if (!IS_DEVICE_PATH(s))
    return false;
  unsigned len = MyStringLen(s);
  if (len == 6 && s[5] == ':')
    return true;
  if (len < 18 || len > 22 || memcmp(s + kDevicePathPrefixSize, FTEXT("PhysicalDrive"), 13 * sizeof(FChar)) != 0)
    return false;
  for (unsigned i = 17; i < len; i++)
    if (s[i] < '0' || s[i] > '9')
      return false;
  return true;
  
  #endif
}

bool IsSuperUncPath(CFSTR s) throw() { return (IS_SUPER_PREFIX(s) && IS_UNC_WITH_SLASH(s + kSuperPathPrefixSize)); }

bool IsDrivePath(const wchar_t *s) throw() { return IS_LETTER_CHAR(s[0]) && s[1] == ':' && s[2] == '\\'; }
bool IsSuperPath(const wchar_t *s) throw() { return IS_SUPER_PREFIX(s); }
bool IsSuperOrDevicePath(const wchar_t *s) throw() { return IS_SUPER_OR_DEVICE_PATH(s); }
// bool IsSuperUncPath(const wchar_t *s) { return (IS_SUPER_PREFIX(s) && IS_UNC_WITH_SLASH(s + kSuperPathPrefixSize)); }

#ifndef USE_UNICODE_FSTRING
bool IsDrivePath(CFSTR s) throw() { return IS_LETTER_CHAR(s[0]) && s[1] == ':' && s[2] == '\\'; }
bool IsSuperPath(CFSTR s) throw() { return IS_SUPER_PREFIX(s); }
bool IsSuperOrDevicePath(CFSTR s) throw() { return IS_SUPER_OR_DEVICE_PATH(s); }
#endif // USE_UNICODE_FSTRING

bool IsAbsolutePath(const wchar_t *s) throw()
{
  return s[0] == WCHAR_PATH_SEPARATOR || IsDrivePath(s);
}

static const unsigned kDrivePrefixSize = 3; /* c:\ */

#ifndef USE_UNICODE_FSTRING

static unsigned GetRootPrefixSize_Of_NetworkPath(CFSTR s) throw()
{
  // Network path: we look "server\path\" as root prefix
  int pos = FindCharPosInString(s, '\\');
  if (pos < 0)
    return 0;
  int pos2 = FindCharPosInString(s + pos + 1, '\\');
  if (pos2 < 0)
    return 0;
  return pos + pos2 + 2;
}

static unsigned GetRootPrefixSize_Of_SimplePath(CFSTR s) throw()
{
  if (IsDrivePath(s))
    return kDrivePrefixSize;
  if (s[0] != '\\' || s[1] != '\\')
    return 0;
  unsigned size = GetRootPrefixSize_Of_NetworkPath(s + 2);
  return (size == 0) ? 0 : 2 + size;
}

static unsigned GetRootPrefixSize_Of_SuperPath(CFSTR s) throw()
{
  if (IS_UNC_WITH_SLASH(s + kSuperPathPrefixSize))
  {
    unsigned size = GetRootPrefixSize_Of_NetworkPath(s + kSuperUncPathPrefixSize);
    return (size == 0) ? 0 : kSuperUncPathPrefixSize + size;
  }
  // we support \\?\c:\ paths and volume GUID paths \\?\Volume{GUID}\"
  int pos = FindCharPosInString(s + kSuperPathPrefixSize, FCHAR_PATH_SEPARATOR);
  if (pos < 0)
    return 0;
  return kSuperPathPrefixSize + pos + 1;
}

unsigned GetRootPrefixSize(CFSTR s) throw()
{
  if (IS_DEVICE_PATH(s))
    return kDevicePathPrefixSize;
  if (IsSuperPath(s))
    return GetRootPrefixSize_Of_SuperPath(s);
  return GetRootPrefixSize_Of_SimplePath(s);
}

#endif // USE_UNICODE_FSTRING

static unsigned GetRootPrefixSize_Of_NetworkPath(const wchar_t *s) throw()
{
  // Network path: we look "server\path\" as root prefix
  int pos = FindCharPosInString(s, L'\\');
  if (pos < 0)
    return 0;
  int pos2 = FindCharPosInString(s + pos + 1, L'\\');
  if (pos2 < 0)
    return 0;
  return pos + pos2 + 2;
}

static unsigned GetRootPrefixSize_Of_SimplePath(const wchar_t *s) throw()
{
  if (IsDrivePath(s))
    return kDrivePrefixSize;
  if (s[0] != '\\' || s[1] != '\\')
    return 0;
  unsigned size = GetRootPrefixSize_Of_NetworkPath(s + 2);
  return (size == 0) ? 0 : 2 + size;
}

static unsigned GetRootPrefixSize_Of_SuperPath(const wchar_t *s) throw()
{
  if (IS_UNC_WITH_SLASH(s + kSuperPathPrefixSize))
  {
    unsigned size = GetRootPrefixSize_Of_NetworkPath(s + kSuperUncPathPrefixSize);
    return (size == 0) ? 0 : kSuperUncPathPrefixSize + size;
  }
  // we support \\?\c:\ paths and volume GUID paths \\?\Volume{GUID}\"
  int pos = FindCharPosInString(s + kSuperPathPrefixSize, L'\\');
  if (pos < 0)
    return 0;
  return kSuperPathPrefixSize + pos + 1;
}

unsigned GetRootPrefixSize(const wchar_t *s) throw()
{
  if (IS_DEVICE_PATH(s))
    return kDevicePathPrefixSize;
  if (IsSuperPath(s))
    return GetRootPrefixSize_Of_SuperPath(s);
  return GetRootPrefixSize_Of_SimplePath(s);
}

#else // _WIN32

static const unsigned kDrivePrefixSize = 3; /* c:\ */
#define IS_LETTER_CHAR(c) ((c) >= 'a' && (c) <= 'z' || (c) >= 'A' && (c) <= 'Z')
bool IsDrivePath(const wchar_t *s) throw() { return IS_LETTER_CHAR(s[0]) && s[1] == ':' && s[2] == WCHAR_PATH_SEPARATOR; }

bool IsAbsolutePath(const wchar_t *s) throw() { return s[0] == WCHAR_PATH_SEPARATOR; }

#ifndef USE_UNICODE_FSTRING
unsigned GetRootPrefixSize(CFSTR s) throw() { return s[0] == CHAR_PATH_SEPARATOR ? 1 : 0; }
#endif
unsigned GetRootPrefixSize(const wchar_t *s) throw() {
  if (IsDrivePath(s))
    return kDrivePrefixSize;

 return s[0] == CHAR_PATH_SEPARATOR ? 1 : 0;
}

#endif // _WIN32


#ifndef UNDER_CE

static bool GetCurDir(UString &path)
{
  path.Empty();
  char begin[MAX_PATHNAME_LEN];
  begin[0]='c';
  begin[1]=':';
  char * cret = getcwd(begin+2, MAX_PATHNAME_LEN - 3);
  if (cret)
  {
#ifdef _UNICODE
    path = GetUnicodeString(begin);
#else
    path = begin;
#endif
    return true;
  }
  return false;
}

static bool ResolveDotsFolders(UString &s)
{
  #ifdef _WIN32
  s.Replace(L'/', WCHAR_PATH_SEPARATOR);
  #endif
  for (int i = 0;;)
  {
    wchar_t c = s[i];
    if (c == 0)
      return true;
    if (c == '.' && (i == 0 || s[i - 1] == WCHAR_PATH_SEPARATOR))
    {
      wchar_t c1 = s[i + 1];
      if (c1 == '.')
      {
        wchar_t c2 = s[i + 2];
        if (c2 == WCHAR_PATH_SEPARATOR || c2 == 0)
        {
          if (i == 0)
            return false;
          int k = i - 2;
          for (; k >= 0; k--)
            if (s[k] == WCHAR_PATH_SEPARATOR)
              break;
          unsigned num;
          if (k >= 0)
          {
            num = i + 2 - k;
            i = k;
          }
          else
          {
            num = (c2 == 0 ? (i + 2) : (i + 3));
            i = 0;
          }
          s.Delete(i, num);
          continue;
        }
      }
      else
      {
        if (c1 == WCHAR_PATH_SEPARATOR || c1 == 0)
        {
          unsigned num = 2;
          if (i != 0)
            i--;
          else if (c1 == 0)
            num = 1;
          s.Delete(i, num);
          continue;
        }
      }
    }
    i++;
  }
}

#endif // UNDER_CE

#define LONG_PATH_DOTS_FOLDERS_PARSING


/*
Windows (at least 64-bit XP) can't resolve "." or ".." in paths that start with SuperPrefix \\?\
To solve that problem we check such path:
   - super path contains        "." or ".." - we use kSuperPathType_UseOnlySuper
   - super path doesn't contain "." or ".." - we use kSuperPathType_UseOnlyMain
*/
#ifdef LONG_PATH_DOTS_FOLDERS_PARSING
#ifndef UNDER_CE
static bool AreThereDotsFolders(CFSTR s)
{
  for (unsigned i = 0;; i++)
  {
    FChar c = s[i];
    if (c == 0)
      return false;
    if (c == '.' && (i == 0 || s[i - 1] == CHAR_PATH_SEPARATOR))
    {
      FChar c1 = s[i + 1];
      if (c1 == 0 || c1 == CHAR_PATH_SEPARATOR ||
          (c1 == '.' && (s[i + 2] == 0 || s[i + 2] == CHAR_PATH_SEPARATOR)))
        return true;
    }
  }
}
#endif
#endif // LONG_PATH_DOTS_FOLDERS_PARSING

#ifdef WIN_LONG_PATH

/*
Most of Windows versions have problems, if some file or dir name
contains '.' or ' ' at the end of name (Bad Path).
To solve that problem, we always use Super Path ("\\?\" prefix and full path)
in such cases. Note that "." and ".." are not bad names.

There are 3 cases:
  1) If the path is already Super Path, we use that path
  2) If the path is not Super Path :
     2.1) Bad Path;  we use only Super Path.
     2.2) Good Path; we use Main Path. If it fails, we use Super Path.

 NeedToUseOriginalPath returns:
    kSuperPathType_UseOnlyMain    : Super already
    kSuperPathType_UseOnlySuper    : not Super, Bad Path
    kSuperPathType_UseMainAndSuper : not Super, Good Path
*/

int GetUseSuperPathType(CFSTR s) throw()
{
  if (IsSuperOrDevicePath(s))
  {
    #ifdef LONG_PATH_DOTS_FOLDERS_PARSING
    if ((s)[2] != '.')
      if (AreThereDotsFolders(s + kSuperPathPrefixSize))
        return kSuperPathType_UseOnlySuper;
    #endif
    return kSuperPathType_UseOnlyMain;
  }

  for (unsigned i = 0;; i++)
  {
    FChar c = s[i];
    if (c == 0)
      return kSuperPathType_UseMainAndSuper;
    if (c == '.' || c == ' ')
    {
      FChar c2 = s[i + 1];
      if (c2 == 0 || c2 == CHAR_PATH_SEPARATOR)
      {
        // if it's "." or "..", it's not bad name.
        if (c == '.')
        {
          if (i == 0 || s[i - 1] == CHAR_PATH_SEPARATOR)
            continue;
          if (s[i - 1] == '.')
          {
            if (i - 1 == 0 || s[i - 2] == CHAR_PATH_SEPARATOR)
              continue;
          }
        }
        return kSuperPathType_UseOnlySuper;
      }
    }
  }
}


/*
   returns false in two cases:
     - if GetCurDir was used, and GetCurDir returned error.
     - if we can't resolve ".." name.
   if path is ".", "..", res is empty.
   if it's Super Path already, res is empty.
   for \**** , and if GetCurDir is not drive (c:\), res is empty
   for absolute paths, returns true, res is Super path.
*/


static bool GetSuperPathBase(CFSTR s, UString &res)
{
  res.Empty();
  
  FChar c = s[0];
  if (c == 0)
    return true;
  if (c == '.' && (s[1] == 0 || (s[1] == '.' && s[2] == 0)))
    return true;
  
  if (IsSuperOrDevicePath(s))
  {
    #ifdef LONG_PATH_DOTS_FOLDERS_PARSING
    
    if ((s)[2] == '.')
      return true;

    // we will return true here, so we will try to use these problem paths.

    if (!AreThereDotsFolders(s + kSuperPathPrefixSize))
      return true;
    
    UString temp = fs2us(s);
    unsigned fixedSize = GetRootPrefixSize_Of_SuperPath(temp);
    if (fixedSize == 0)
      return true;

    UString rem = &temp[fixedSize];
    if (!ResolveDotsFolders(rem))
      return true;

    temp.DeleteFrom(fixedSize);
    res += temp;
    res += rem;
    
    #endif

    return true;
  }

  if (c == CHAR_PATH_SEPARATOR)
  {
    if (s[1] == CHAR_PATH_SEPARATOR)
    {
      UString temp = fs2us(s + 2);
      unsigned fixedSize = GetRootPrefixSize_Of_NetworkPath(temp);
      if (fixedSize == 0) // maybe we must ignore that error to allow short network paths?
        return false;
      UString rem = &temp[fixedSize];
      if (!ResolveDotsFolders(rem))
        return false;
      res += kSuperUncPrefix;
      temp.DeleteFrom(fixedSize);
      res += temp;
      res += rem;
      return true;
    }
  }
  else
  {
    if (IsDrivePath(s))
    {
      UString temp = fs2us(s);
      UString rem = &temp[kDrivePrefixSize];
      if (!ResolveDotsFolders(rem))
        return true;
      res += kSuperPathPrefix;
      temp.DeleteFrom(kDrivePrefixSize);
      res += temp;
      res += rem;
      return true;
    }
  }

  UString curDir;
  if (!GetCurDir(curDir))
    return false;
  if (curDir.Back() != WCHAR_PATH_SEPARATOR)
    curDir += WCHAR_PATH_SEPARATOR;

  unsigned fixedSizeStart = 0;
  unsigned fixedSize = 0;
  const wchar_t *superMarker = NULL;
  if (IsSuperPath(curDir))
  {
    fixedSize = GetRootPrefixSize_Of_SuperPath(curDir);
    if (fixedSize == 0)
      return false;
  }
  else
  {
    if (IsDrivePath(curDir))
    {
      superMarker = kSuperPathPrefix;
      fixedSize = kDrivePrefixSize;
    }
    else
    {
      if (curDir[0] != CHAR_PATH_SEPARATOR || curDir[1] != CHAR_PATH_SEPARATOR)
        return false;
      fixedSizeStart = 2;
      fixedSize = GetRootPrefixSize_Of_NetworkPath(&curDir[2]);
      if (fixedSize == 0)
        return false;
      superMarker = kSuperUncPrefix;
    }
  }
  
  UString temp;
  if (c == CHAR_PATH_SEPARATOR)
  {
    temp = fs2us(s + 1);
  }
  else
  {
    temp += &curDir[fixedSizeStart + fixedSize];
    temp += fs2us(s);
  }
  if (!ResolveDotsFolders(temp))
    return false;
  if (superMarker)
    res += superMarker;
  res += curDir.Mid(fixedSizeStart, fixedSize);
  res += temp;
  return true;
}


/*
  In that case if GetSuperPathBase doesn't return new path, we don't need
  to use same path that was used as main path
                        
  GetSuperPathBase  superPath.IsEmpty() onlyIfNew
     false            *                *          GetCurDir Error
     true            false             *          use Super path
     true            true             true        don't use any path, we already used mainPath
     true            true             false       use main path as Super Path, we don't try mainMath
                                                  That case is possible now if GetCurDir returns unknow
                                                  type of path (not drive and not network)

  We can change that code if we want to try mainPath, if GetSuperPathBase returns error,
  and we didn't try mainPath still.
  If we want to work that way, we don't need to use GetSuperPathBase return code.
*/

bool GetSuperPath(CFSTR path, UString &superPath, bool onlyIfNew)
{
  if (GetSuperPathBase(path, superPath))
  {
    if (superPath.IsEmpty())
    {
      // actually the only possible when onlyIfNew == true and superPath is empty
      // is case when

      if (onlyIfNew)
        return false;
      superPath = fs2us(path);
    }
    return true;
  }
  return false;
}

bool GetSuperPaths(CFSTR s1, CFSTR s2, UString &d1, UString &d2, bool onlyIfNew)
{
  if (!GetSuperPathBase(s1, d1) ||
      !GetSuperPathBase(s2, d2))
    return false;
  if (d1.IsEmpty() && d2.IsEmpty() && onlyIfNew)
    return false;
  if (d1.IsEmpty()) d1 = fs2us(s1);
  if (d2.IsEmpty()) d2 = fs2us(s2);
  return true;
}


/*
// returns true, if we need additional use with New Super path.
bool GetSuperPath(CFSTR path, UString &superPath)
{
  if (GetSuperPathBase(path, superPath))
    return !superPath.IsEmpty();
  return false;
}
*/
#endif // WIN_LONG_PATH

bool GetFullPath(CFSTR dirPrefix, CFSTR s, FString &res)
{
  res = s;

  #ifdef UNDER_CE

  if (s[0] != CHAR_PATH_SEPARATOR)
  {
    if (!dirPrefix)
      return false;
    res = dirPrefix;
    res += s;
  }

  #else

  unsigned prefixSize = GetRootPrefixSize(s);
  if (prefixSize != 0)
  {
    if (!AreThereDotsFolders(s + prefixSize))
      return true;
    
    UString rem = fs2us(s + prefixSize);
    if (!ResolveDotsFolders(rem))
      return true; // maybe false;
    res.DeleteFrom(prefixSize);
    res += us2fs(rem);
    return true;
  }

  /*
  FChar c = s[0];
  if (c == 0)
    return true;
  if (c == '.' && (s[1] == 0 || (s[1] == '.' && s[2] == 0)))
    return true;
  if (c == CHAR_PATH_SEPARATOR && s[1] == CHAR_PATH_SEPARATOR)
    return true;
  if (IsDrivePath(s))
    return true;
  */

  UString curDir;
  if (dirPrefix)
    curDir = fs2us(dirPrefix);
  else
  {
    if (!GetCurDir(curDir))
      return false;
  }
  if (!curDir.IsEmpty() && curDir.Back() != WCHAR_PATH_SEPARATOR)
    curDir += WCHAR_PATH_SEPARATOR;

  unsigned fixedSize = 0;

  #ifdef _WIN32

  if (IsSuperPath(curDir))
  {
    fixedSize = GetRootPrefixSize_Of_SuperPath(curDir);
    if (fixedSize == 0)
      return false;
  }
  else
  {
    if (IsDrivePath(curDir))
      fixedSize = kDrivePrefixSize;
    else
    {
      if (curDir[0] != WCHAR_PATH_SEPARATOR || curDir[1] != WCHAR_PATH_SEPARATOR)
        return false;
      fixedSize = GetRootPrefixSize_Of_NetworkPath(&curDir[2]);
      if (fixedSize == 0)
        return false;
      fixedSize += 2;
    }
  }
  #else
    if (IsDrivePath(curDir))
      fixedSize = kDrivePrefixSize;

  #endif // _WIN32
  
  UString temp;
  if (s[0] == CHAR_PATH_SEPARATOR)
  {
    temp = fs2us(s + 1);
  }
  else
  {
    temp += curDir.Ptr(fixedSize);
    temp += fs2us(s);
  }
  if (!ResolveDotsFolders(temp))
    return false;
  curDir.DeleteFrom(fixedSize);
  res = us2fs(curDir);
  res += us2fs(temp);
  
  #endif // UNDER_CE

  return true;
}

bool GetFullPath(CFSTR path, FString &fullPath)
{
  return GetFullPath(NULL, path, fullPath);
}

}}}
// Windows/FileName.h

#ifndef __WINDOWS_FILENAME_H
#define __WINDOWS_FILENAME_H

#include "../../C/7zTypes.h"

#include "../Common/MyString.h"

namespace NWindows {
namespace NFile {
namespace NName {

int FindSepar(const wchar_t *s) throw();
#ifndef USE_UNICODE_FSTRING
int FindSepar(const FChar *s) throw();
#endif

const TCHAR kDirDelimiter = CHAR_PATH_SEPARATOR;
const TCHAR kAnyStringWildcard = '*';

void NormalizeDirPathPrefix(CSysString &dirPath); // ensures that it ended with '\\'
#ifndef _UNICODE
void NormalizeDirPathPrefix(UString &dirPath); // ensures that it ended with '\\'
#endif

bool IsAbsolutePath(const wchar_t *s) throw();
unsigned GetRootPrefixSize(const wchar_t *s) throw();

bool GetFullPath(CFSTR dirPrefix, CFSTR path, FString &fullPath);
bool GetFullPath(CFSTR path, FString &fullPath);

}}}

#endif

/* TODO */


// Windows/NtCheck.h

#ifndef __WINDOWS_NT_CHECK_H
#define __WINDOWS_NT_CHECK_H

#ifdef _WIN32

#include "../Common/MyWindows.h"

#if !defined(_WIN64) && !defined(UNDER_CE)
static inline bool IsItWindowsNT()
{
  OSVERSIONINFO vi;
  vi.dwOSVersionInfoSize = sizeof(vi);
  return (::GetVersionEx(&vi) && vi.dwPlatformId == VER_PLATFORM_WIN32_NT);
}
#endif

#ifndef _UNICODE
  #if defined(_WIN64) || defined(UNDER_CE)
    bool g_IsNT = true;
    #define SET_IS_NT
  #else
    bool g_IsNT = false;
    #define SET_IS_NT g_IsNT = IsItWindowsNT();
  #endif
  #define NT_CHECK_ACTION
  // #define NT_CHECK_ACTION { NT_CHECK_FAIL_ACTION }
#else
  #if !defined(_WIN64) && !defined(UNDER_CE)
    #define NT_CHECK_ACTION if (!IsItWindowsNT()) { NT_CHECK_FAIL_ACTION }
  #else
    #define NT_CHECK_ACTION
  #endif
  #define SET_IS_NT
#endif

#define NT_CHECK  NT_CHECK_ACTION SET_IS_NT

#else

#define NT_CHECK

#endif

#endif
// Windows/PropVariant.cpp

#include "StdAfx.h"

#include "../Common/Defs.h"

#include "PropVariant.h"

namespace NWindows {
namespace NCOM {

BSTR AllocBstrFromAscii(const char *s) throw()
{
  if (!s)
    return NULL;
  UINT len = (UINT)strlen(s);
  BSTR p = ::SysAllocStringLen(NULL, len);
  if (p)
  {
    for (UINT i = 0; i <= len; i++)
      p[i] = (Byte)s[i];
  }
  return p;
}

HRESULT PropVarEm_Alloc_Bstr(PROPVARIANT *p, unsigned numChars) throw()
{
  p->bstrVal = ::SysAllocStringLen(NULL, numChars);
  if (!p->bstrVal)
  {
    p->vt = VT_ERROR;
    p->scode = E_OUTOFMEMORY;
    return E_OUTOFMEMORY;
  }
  p->vt = VT_BSTR;
  return S_OK;
}

HRESULT PropVarEm_Set_Str(PROPVARIANT *p, const char *s) throw()
{
  p->bstrVal = AllocBstrFromAscii(s);
  if (p->bstrVal)
  {
    p->vt = VT_BSTR;
    return S_OK;
  }
  p->vt = VT_ERROR;
  p->scode = E_OUTOFMEMORY;
  return E_OUTOFMEMORY;
}

CPropVariant::CPropVariant(const PROPVARIANT &varSrc)
{
  vt = VT_EMPTY;
  InternalCopy(&varSrc);
}

CPropVariant::CPropVariant(const CPropVariant &varSrc)
{
  vt = VT_EMPTY;
  InternalCopy(&varSrc);
}

CPropVariant::CPropVariant(BSTR bstrSrc)
{
  vt = VT_EMPTY;
  *this = bstrSrc;
}

CPropVariant::CPropVariant(LPCOLESTR lpszSrc)
{
  vt = VT_EMPTY;
  *this = lpszSrc;
}

CPropVariant& CPropVariant::operator=(const CPropVariant &varSrc)
{
  InternalCopy(&varSrc);
  return *this;
}

CPropVariant& CPropVariant::operator=(const PROPVARIANT &varSrc)
{
  InternalCopy(&varSrc);
  return *this;
}

CPropVariant& CPropVariant::operator=(BSTR bstrSrc)
{
  *this = (LPCOLESTR)bstrSrc;
  return *this;
}

static const char *kMemException = "out of memory";

CPropVariant& CPropVariant::operator=(LPCOLESTR lpszSrc)
{
  InternalClear();
  vt = VT_BSTR;
  wReserved1 = 0;
  bstrVal = ::SysAllocString(lpszSrc);
  if (!bstrVal && lpszSrc)
  {
    throw kMemException;
    // vt = VT_ERROR;
    // scode = E_OUTOFMEMORY;
  }
  return *this;
}

CPropVariant& CPropVariant::operator=(const UString &s)
{
  InternalClear();
  vt = VT_BSTR;
  wReserved1 = 0;
  bstrVal = ::SysAllocStringLen(s, s.Len());
  if (!bstrVal)
    throw kMemException;
  return *this;
}

CPropVariant& CPropVariant::operator=(const UString2 &s)
{
  /*
  if (s.IsEmpty())
    *this = L"";
  else
  */
  {
    InternalClear();
    vt = VT_BSTR;
    wReserved1 = 0;
    bstrVal = ::SysAllocStringLen(s.GetRawPtr(), s.Len());
    if (!bstrVal)
      throw kMemException;
    /* SysAllocStringLen probably appends a null-terminating character for NULL string.
       But it doesn't specified in MSDN.
       But we suppose that it works

    if (!s.GetRawPtr())
    {
      *bstrVal = 0;
    }
    */

    /* MSDN: Windows CE: SysAllocStringLen() : Passing invalid (and under some circumstances NULL)
                         pointers to this function causes  an unexpected termination of the application.
       Is it safe? Maybe we must chamnge the code for that case ? */
  }
  return *this;
}

CPropVariant& CPropVariant::operator=(const char *s)
{
  InternalClear();
  vt = VT_BSTR;
  wReserved1 = 0;
  bstrVal = AllocBstrFromAscii(s);
  if (!bstrVal)
  {
    throw kMemException;
    // vt = VT_ERROR;
    // scode = E_OUTOFMEMORY;
  }
  return *this;
}

CPropVariant& CPropVariant::operator=(bool bSrc) throw()
{
  if (vt != VT_BOOL)
  {
    InternalClear();
    vt = VT_BOOL;
  }
  boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
  return *this;
}

BSTR CPropVariant::AllocBstr(unsigned numChars)
{
  if (vt != VT_EMPTY)
    InternalClear();
  vt = VT_BSTR;
  wReserved1 = 0;
  bstrVal = ::SysAllocStringLen(NULL, numChars);
  if (!bstrVal)
  {
    throw kMemException;
    // vt = VT_ERROR;
    // scode = E_OUTOFMEMORY;
  }
  return bstrVal;
}

#define SET_PROP_FUNC(type, id, dest) \
  CPropVariant& CPropVariant::operator=(type value) throw() \
  { if (vt != id) { InternalClear(); vt = id; } \
    dest = value; return *this; }

SET_PROP_FUNC(Byte, VT_UI1, bVal)
// SET_PROP_FUNC(Int16, VT_I2, iVal)
SET_PROP_FUNC(Int32, VT_I4, lVal)
SET_PROP_FUNC(UInt32, VT_UI4, ulVal)
SET_PROP_FUNC(UInt64, VT_UI8, uhVal.QuadPart)
SET_PROP_FUNC(Int64, VT_I8, hVal.QuadPart)
SET_PROP_FUNC(const FILETIME &, VT_FILETIME, filetime)

HRESULT PropVariant_Clear(PROPVARIANT *prop) throw()
{
  switch (prop->vt)
  {
    case VT_EMPTY:
    case VT_UI1:
    case VT_I1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_FILETIME:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
      prop->vt = VT_EMPTY;
      prop->wReserved1 = 0;
      prop->wReserved2 = 0;
      prop->wReserved3 = 0;
      prop->uhVal.QuadPart = 0;
      return S_OK;
  }
  return ::VariantClear((VARIANTARG *)prop);
  // return ::PropVariantClear(prop);
  // PropVariantClear can clear VT_BLOB.
}

HRESULT CPropVariant::Clear() throw()
{
  if (vt == VT_EMPTY)
    return S_OK;
  return PropVariant_Clear(this);
}

HRESULT CPropVariant::Copy(const PROPVARIANT* pSrc) throw()
{
  ::VariantClear((tagVARIANT *)this);
  switch (pSrc->vt)
  {
    case VT_UI1:
    case VT_I1:
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_FILETIME:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
      memmove((PROPVARIANT*)this, pSrc, sizeof(PROPVARIANT));
      return S_OK;
  }
  return ::VariantCopy((tagVARIANT *)this, (tagVARIANT *)const_cast<PROPVARIANT *>(pSrc));
}


HRESULT CPropVariant::Attach(PROPVARIANT *pSrc) throw()
{
  HRESULT hr = Clear();
  if (FAILED(hr))
    return hr;
  memcpy(this, pSrc, sizeof(PROPVARIANT));
  pSrc->vt = VT_EMPTY;
  return S_OK;
}

HRESULT CPropVariant::Detach(PROPVARIANT *pDest) throw()
{
  if (pDest->vt != VT_EMPTY)
  {
    HRESULT hr = PropVariant_Clear(pDest);
    if (FAILED(hr))
      return hr;
  }
  memcpy(pDest, this, sizeof(PROPVARIANT));
  vt = VT_EMPTY;
  return S_OK;
}

HRESULT CPropVariant::InternalClear() throw()
{
  if (vt == VT_EMPTY)
    return S_OK;
  HRESULT hr = Clear();
  if (FAILED(hr))
  {
    vt = VT_ERROR;
    scode = hr;
  }
  return hr;
}

void CPropVariant::InternalCopy(const PROPVARIANT *pSrc)
{
  HRESULT hr = Copy(pSrc);
  if (FAILED(hr))
  {
    if (hr == E_OUTOFMEMORY)
      throw kMemException;
    vt = VT_ERROR;
    scode = hr;
  }
}

int CPropVariant::Compare(const CPropVariant &a) throw()
{
  if (vt != a.vt)
    return MyCompare(vt, a.vt);
  switch (vt)
  {
    case VT_EMPTY: return 0;
    // case VT_I1: return MyCompare(cVal, a.cVal);
    case VT_UI1: return MyCompare(bVal, a.bVal);
    case VT_I2: return MyCompare(iVal, a.iVal);
    case VT_UI2: return MyCompare(uiVal, a.uiVal);
    case VT_I4: return MyCompare(lVal, a.lVal);
    case VT_UI4: return MyCompare(ulVal, a.ulVal);
    // case VT_UINT: return MyCompare(uintVal, a.uintVal);
    case VT_I8: return MyCompare(hVal.QuadPart, a.hVal.QuadPart);
    case VT_UI8: return MyCompare(uhVal.QuadPart, a.uhVal.QuadPart);
    case VT_BOOL: return -MyCompare(boolVal, a.boolVal);
    case VT_FILETIME: return ::CompareFileTime(&filetime, &a.filetime);
    case VT_BSTR: return 0; // Not implemented
    default: return 0;
  }
}

}}
// Windows/PropVariant.h

#ifndef __WINDOWS_PROP_VARIANT_H
#define __WINDOWS_PROP_VARIANT_H

#include "../Common/MyTypes.h"
#include "../Common/MyWindows.h"
#include "../Common/MyString.h"

namespace NWindows {
namespace NCOM {

BSTR AllocBstrFromAscii(const char *s) throw();

HRESULT PropVariant_Clear(PROPVARIANT *p) throw();

HRESULT PropVarEm_Alloc_Bstr(PROPVARIANT *p, unsigned numChars) throw();
HRESULT PropVarEm_Set_Str(PROPVARIANT *p, const char *s) throw();

inline void PropVarEm_Set_UInt32(PROPVARIANT *p, UInt32 v) throw()
{
  p->vt = VT_UI4;
  p->ulVal = v;
}

inline void PropVarEm_Set_UInt64(PROPVARIANT *p, UInt64 v) throw()
{
  p->vt = VT_UI8;
  p->uhVal.QuadPart = v;
}

inline void PropVarEm_Set_FileTime64(PROPVARIANT *p, UInt64 v) throw()
{
  p->vt = VT_FILETIME;
  p->filetime.dwLowDateTime = (DWORD)v;
  p->filetime.dwHighDateTime = (DWORD)(v >> 32);
}

inline void PropVarEm_Set_Bool(PROPVARIANT *p, bool b) throw()
{
  p->vt = VT_BOOL;
  p->boolVal = (b ? VARIANT_TRUE : VARIANT_FALSE);
}


class CPropVariant : public tagPROPVARIANT
{
public:
  CPropVariant()
  {
    vt = VT_EMPTY;
    wReserved1 = 0;
    // wReserved2 = 0;
    // wReserved3 = 0;
    // uhVal.QuadPart = 0;
    bstrVal = 0;
  }
  ~CPropVariant() throw() { Clear(); }
  CPropVariant(const PROPVARIANT &varSrc);
  CPropVariant(const CPropVariant &varSrc);
  CPropVariant(BSTR bstrSrc);
  CPropVariant(LPCOLESTR lpszSrc);
  CPropVariant(bool bSrc) { vt = VT_BOOL; wReserved1 = 0; boolVal = (bSrc ? VARIANT_TRUE : VARIANT_FALSE); }
  CPropVariant(Byte value) { vt = VT_UI1; wReserved1 = 0; bVal = value; }

private:
  CPropVariant(Int16 value); // { vt = VT_I2; wReserved1 = 0; iVal = value; }
  CPropVariant(Int32 value); // { vt = VT_I4; wReserved1 = 0; lVal = value; }

public:
  CPropVariant(UInt32 value) { vt = VT_UI4; wReserved1 = 0; ulVal = value; }
  CPropVariant(UInt64 value) { vt = VT_UI8; wReserved1 = 0; uhVal.QuadPart = value; }
  CPropVariant(Int64 value) { vt = VT_I8; wReserved1 = 0; hVal.QuadPart = value; }
  CPropVariant(const FILETIME &value) { vt = VT_FILETIME; wReserved1 = 0; filetime = value; }

  CPropVariant& operator=(const CPropVariant &varSrc);
  CPropVariant& operator=(const PROPVARIANT &varSrc);
  CPropVariant& operator=(BSTR bstrSrc);
  CPropVariant& operator=(LPCOLESTR lpszSrc);
  CPropVariant& operator=(const UString &s);
  CPropVariant& operator=(const UString2 &s);
  CPropVariant& operator=(const char *s);
  
  CPropVariant& operator=(bool bSrc) throw();
  CPropVariant& operator=(Byte value) throw();
  
private:
  CPropVariant& operator=(Int16 value) throw();

public:
  CPropVariant& operator=(Int32 value) throw();
  CPropVariant& operator=(UInt32 value) throw();
  CPropVariant& operator=(UInt64 value) throw();
  CPropVariant& operator=(Int64 value) throw();
  CPropVariant& operator=(const FILETIME &value) throw();

  BSTR AllocBstr(unsigned numChars);

  HRESULT Clear() throw();
  HRESULT Copy(const PROPVARIANT *pSrc) throw();
  HRESULT Attach(PROPVARIANT *pSrc) throw();
  HRESULT Detach(PROPVARIANT *pDest) throw();

  HRESULT InternalClear() throw();
  void InternalCopy(const PROPVARIANT *pSrc);

  int Compare(const CPropVariant &a) throw();
};

}}

#endif
// PropVariantConvert.cpp

#include "StdAfx.h"

#include "../Common/IntToString.h"

#include "Defs.h"
#include "PropVariantConv.h"

#define UINT_TO_STR_2(c, val) { s[0] = (c); s[1] = (char)('0' + (val) / 10); s[2] = (char)('0' + (val) % 10); s += 3; }

bool ConvertFileTimeToString(const FILETIME &ft, char *s, bool includeTime, bool includeSeconds) throw()
{
  SYSTEMTIME st;
  if (!BOOLToBool(FileTimeToSystemTime(&ft, &st)))
  {
    *s = 0;
    return false;
  }
  unsigned val = st.wYear;
  if (val >= 10000)
  {
    *s++ = (char)('0' + val / 10000);
    val %= 10000;
  }
  {
    s[3] = (char)('0' + val % 10); val /= 10;
    s[2] = (char)('0' + val % 10); val /= 10;
    s[1] = (char)('0' + val % 10);
    s[0] = (char)('0' + val / 10);
    s += 4;
  }
  UINT_TO_STR_2('-', st.wMonth);
  UINT_TO_STR_2('-', st.wDay);
  if (includeTime)
  {
    UINT_TO_STR_2(' ', st.wHour);
    UINT_TO_STR_2(':', st.wMinute);
    if (includeSeconds)
    {
      UINT_TO_STR_2(':', st.wSecond);
      /*
      *s++ = '.';
      unsigned val = st.wMilliseconds;
      s[2] = (char)('0' + val % 10); val /= 10;
      s[1] = (char)('0' + val % 10);
      s[0] = (char)('0' + val / 10);
      s += 3;
      */
    }
  }
  *s = 0;
  return true;
}

void ConvertFileTimeToString(const FILETIME &ft, wchar_t *dest, bool includeTime, bool includeSeconds) throw()
{
  char s[32];
  ConvertFileTimeToString(ft, s, includeTime, includeSeconds);
  for (unsigned i = 0;; i++)
  {
    unsigned char c = s[i];
    dest[i] = c;
    if (c == 0)
      return;
  }
}

void ConvertPropVariantToShortString(const PROPVARIANT &prop, char *dest) throw()
{
  *dest = 0;
  switch (prop.vt)
  {
    case VT_EMPTY: return;
    case VT_BSTR: dest[0] = '?'; dest[1] = 0; return;
    case VT_UI1: ConvertUInt32ToString(prop.bVal, dest); return;
    case VT_UI2: ConvertUInt32ToString(prop.uiVal, dest); return;
    case VT_UI4: ConvertUInt32ToString(prop.ulVal, dest); return;
    case VT_UI8: ConvertUInt64ToString(prop.uhVal.QuadPart, dest); return;
    case VT_FILETIME: ConvertFileTimeToString(prop.filetime, dest, true, true); return;
    // case VT_I1: return ConvertInt64ToString(prop.cVal, dest); return;
    case VT_I2: ConvertInt64ToString(prop.iVal, dest); return;
    case VT_I4: ConvertInt64ToString(prop.lVal, dest); return;
    case VT_I8: ConvertInt64ToString(prop.hVal.QuadPart, dest); return;
    case VT_BOOL: dest[0] = VARIANT_BOOLToBool(prop.boolVal) ? '+' : '-'; dest[1] = 0; return;
    default: dest[0] = '?'; dest[1] = ':'; ConvertUInt64ToString(prop.vt, dest + 2);
  }
}

void ConvertPropVariantToShortString(const PROPVARIANT &prop, wchar_t *dest) throw()
{
  *dest = 0;
  switch (prop.vt)
  {
    case VT_EMPTY: return;
    case VT_BSTR: dest[0] = '?'; dest[1] = 0; return;
    case VT_UI1: ConvertUInt32ToString(prop.bVal, dest); return;
    case VT_UI2: ConvertUInt32ToString(prop.uiVal, dest); return;
    case VT_UI4: ConvertUInt32ToString(prop.ulVal, dest); return;
    case VT_UI8: ConvertUInt64ToString(prop.uhVal.QuadPart, dest); return;
    case VT_FILETIME: ConvertFileTimeToString(prop.filetime, dest, true, true); return;
    // case VT_I1: return ConvertInt64ToString(prop.cVal, dest); return;
    case VT_I2: ConvertInt64ToString(prop.iVal, dest); return;
    case VT_I4: ConvertInt64ToString(prop.lVal, dest); return;
    case VT_I8: ConvertInt64ToString(prop.hVal.QuadPart, dest); return;
    case VT_BOOL: dest[0] = VARIANT_BOOLToBool(prop.boolVal) ? (wchar_t)'+' : (wchar_t)'-'; dest[1] = 0; return;
    default: dest[0] = '?'; dest[1] = ':'; ConvertUInt32ToString(prop.vt, dest + 2);
  }
}
// Windows/PropVariantConv.h

#ifndef __PROP_VARIANT_CONV_H
#define __PROP_VARIANT_CONV_H

#include "../Common/MyTypes.h"

// provide at least 32 bytes for buffer including zero-end
bool ConvertFileTimeToString(const FILETIME &ft, char *s, bool includeTime = true, bool includeSeconds = true) throw();
void ConvertFileTimeToString(const FILETIME &ft, wchar_t *s, bool includeTime = true, bool includeSeconds = true) throw();

// provide at least 32 bytes for buffer including zero-end
// don't send VT_BSTR to these functions
void ConvertPropVariantToShortString(const PROPVARIANT &prop, char *dest) throw();
void ConvertPropVariantToShortString(const PROPVARIANT &prop, wchar_t *dest) throw();

inline bool ConvertPropVariantToUInt64(const PROPVARIANT &prop, UInt64 &value)
{
  switch (prop.vt)
  {
    case VT_UI8: value = (UInt64)prop.uhVal.QuadPart; return true;
    case VT_UI4: value = prop.ulVal; return true;
    case VT_UI2: value = prop.uiVal; return true;
    case VT_UI1: value = prop.bVal; return true;
    case VT_EMPTY: return false;
    default: throw 151199;
  }
}

#endif
// PropVariantUtils.cpp

#include "StdAfx.h"

#include "../Common/IntToString.h"

#include "PropVariantUtils.h"

using namespace NWindows;

static AString GetHex(UInt32 v)
{
  char sz[16];
  sz[0] = '0';
  sz[1] = 'x';
  ConvertUInt32ToHex(v, sz + 2);
  return sz;
}

AString TypePairToString(const CUInt32PCharPair *pairs, unsigned num, UInt32 value)
{
  AString s;
  for (unsigned i = 0; i < num; i++)
  {
    const CUInt32PCharPair &p = pairs[i];
    if (p.Value == value)
      s = p.Name;
  }
  if (s.IsEmpty())
    s = GetHex(value);
  return s;
}

void PairToProp(const CUInt32PCharPair *pairs, unsigned num, UInt32 value, NCOM::CPropVariant &prop)
{
  prop = TypePairToString(pairs, num, value);
}


AString TypeToString(const char * const table[], unsigned num, UInt32 value)
{
  if (value < num)
    return table[value];
  return GetHex(value);
}

void TypeToProp(const char * const table[], unsigned num, UInt32 value, NCOM::CPropVariant &prop)
{
  prop = TypeToString(table, num, value);
}


AString FlagsToString(const char * const *names, unsigned num, UInt32 flags)
{
  AString s;
  for (unsigned i = 0; i < num; i++)
  {
    UInt32 flag = (UInt32)1 << i;
    if ((flags & flag) != 0)
    {
      const char *name = names[i];
      if (name != 0 && name[0] != 0)
      {
        if (!s.IsEmpty())
          s += ' ';
        s += name;
        flags &= ~flag;
      }
    }
  }
  if (flags != 0)
  {
    if (!s.IsEmpty())
      s += ' ';
    s += GetHex(flags);
  }
  return s;
}

AString FlagsToString(const CUInt32PCharPair *pairs, unsigned num, UInt32 flags)
{
  AString s;
  for (unsigned i = 0; i < num; i++)
  {
    const CUInt32PCharPair &p = pairs[i];
    UInt32 flag = (UInt32)1 << (unsigned)p.Value;
    if ((flags & flag) != 0)
    {
      if (p.Name[0] != 0)
      {
        if (!s.IsEmpty())
          s += ' ';
        s += p.Name;
      }
    }
    flags &= ~flag;
  }
  if (flags != 0)
  {
    if (!s.IsEmpty())
      s += ' ';
    s += GetHex(flags);
  }
  return s;
}

void FlagsToProp(const CUInt32PCharPair *pairs, unsigned num, UInt32 flags, NCOM::CPropVariant &prop)
{
  prop = FlagsToString(pairs, num, flags);
}


AString Flags64ToString(const CUInt32PCharPair *pairs, unsigned num, UInt64 flags)
{
  AString s;
  for (unsigned i = 0; i < num; i++)
  {
    const CUInt32PCharPair &p = pairs[i];
    UInt64 flag = (UInt64)1 << (unsigned)p.Value;
    if ((flags & flag) != 0)
    {
      if (p.Name[0] != 0)
      {
        if (!s.IsEmpty())
          s += ' ';
        s += p.Name;
      }
    }
    flags &= ~flag;
  }
  if (flags != 0)
  {
    if (!s.IsEmpty())
      s += ' ';
    {
      char sz[32];
      sz[0] = '0';
      sz[1] = 'x';
      ConvertUInt64ToHex(flags, sz + 2);
      s += sz;
    }
  }
  return s;
}

void Flags64ToProp(const CUInt32PCharPair *pairs, unsigned num, UInt64 flags, NCOM::CPropVariant &prop)
{
  prop = Flags64ToString(pairs, num, flags);
}
// Windows/PropVariantUtils.h

#ifndef __PROP_VARIANT_UTILS_H
#define __PROP_VARIANT_UTILS_H

#include "../Common/MyString.h"

#include "PropVariant.h"

struct CUInt32PCharPair
{
  UInt32 Value;
  const char *Name;
};

AString TypePairToString(const CUInt32PCharPair *pairs, unsigned num, UInt32 value);
void PairToProp(const CUInt32PCharPair *pairs, unsigned num, UInt32 value, NWindows::NCOM::CPropVariant &prop);

AString FlagsToString(const char * const *names, unsigned num, UInt32 flags);
AString FlagsToString(const CUInt32PCharPair *pairs, unsigned num, UInt32 flags);
void FlagsToProp(const CUInt32PCharPair *pairs, unsigned num, UInt32 flags, NWindows::NCOM::CPropVariant &prop);

AString TypeToString(const char * const table[], unsigned num, UInt32 value);
void TypeToProp(const char * const table[], unsigned num, UInt32 value, NWindows::NCOM::CPropVariant &prop);

#define PAIR_TO_PROP(pairs, value, prop) PairToProp(pairs, ARRAY_SIZE(pairs), value, prop)
#define FLAGS_TO_PROP(pairs, value, prop) FlagsToProp(pairs, ARRAY_SIZE(pairs), value, prop)
#define TYPE_TO_PROP(table, value, prop) TypeToProp(table, ARRAY_SIZE(table), value, prop)

void Flags64ToProp(const CUInt32PCharPair *pairs, unsigned num, UInt64 flags, NWindows::NCOM::CPropVariant &prop);
#define FLAGS64_TO_PROP(pairs, value, prop) Flags64ToProp(pairs, ARRAY_SIZE(pairs), value, prop)

#endif
// Windows/Registry.cpp

#include "StdAfx.h"

#ifndef _UNICODE
#include "Common/StringConvert.h"
#endif
#include "Windows/Registry.h"

#include <wx/config.h>

class HKEY_Impl
{
  public:
	wxString path;
	HKEY_Impl(wxString a) : path(a) {}
};

namespace NWindows {
namespace NRegistry {

#define ERROR_SET_VALUE (E_INVALIDARG) // FIXME
#define ERROR_GET_VALUE (E_INVALIDARG) // FIXME
#define PROGRAM_NAME L"p7zip"

static wxConfig * g_config = 0;
static int        g_config_ref = 0;

static void configAddRef() {
	if (g_config == 0) {
		g_config = new wxConfig(PROGRAM_NAME);
		g_config->Flush(true);
		wxConfigBase::Set(g_config);
	}
	g_config_ref++;
}

static void configSubRef() {
	if (g_config_ref >= 1)
	{
		g_config_ref--;
		if (g_config_ref == 0) {
			delete g_config;
			g_config = 0;
			wxConfigBase::Set(NULL);
		} else {
			g_config->Flush(true);
		}
	}
}

LONG CKey::Close() throw()
{
	if (_object) 
	{
		configSubRef();
		delete _object;
	}
	_object = 0;
	return ERROR_SUCCESS;
}

LONG CKey::Create(HKEY parentKey, LPCTSTR keyName) throw()
{
	Close();

	configAddRef();

	wxString path;

	if (parentKey == HKEY_CURRENT_USER) {
		path=L"/" + wxString(keyName);
	} else {
		path = parentKey->path + L"/" + wxString(keyName);
	}
	_object = new HKEY_Impl(path);
	return ERROR_SUCCESS;
}
LONG CKey::Open(HKEY parentKey, LPCTSTR keyName, REGSAM accessMask) throw()
{
	Close();

	configAddRef();

	wxString path;

	if (parentKey == HKEY_CURRENT_USER) {
		path=L"/" + wxString(keyName);
	} else {
		path = parentKey->path + L"/" + wxString(keyName);
	}
	_object = new HKEY_Impl(path);
	return ERROR_SUCCESS;
}

LONG CKey::RecurseDeleteKey(LPCTSTR subKeyName) throw()
{
	g_config->SetPath(_object->path);
	bool ret = g_config->DeleteGroup(subKeyName);
	if (ret) return ERROR_SUCCESS;
	return ERROR_GET_VALUE;
}

LONG CKey::DeleteValue(LPCTSTR name) throw()
{
	g_config->SetPath(_object->path);
	bool ret = g_config->DeleteEntry(name);
	if (ret) return ERROR_SUCCESS;
	return ERROR_GET_VALUE;
}

LONG CKey::QueryValue(LPCTSTR name, UInt32 &value) throw()
{
	g_config->SetPath(_object->path);
	long val;
	bool ret = g_config->Read(name,&val);
	if (ret) {
		value = (UInt32)val;
		return ERROR_SUCCESS;
	}
	return ERROR_GET_VALUE;
}

LONG CKey::QueryValue(LPCTSTR name, bool &value) throw()
{
	g_config->SetPath(_object->path);
	bool ret = g_config->Read(name,&value);
	if (ret) return ERROR_SUCCESS;
	return ERROR_GET_VALUE;
}

LONG CKey::QueryValue(LPCTSTR name, CSysString &value)
{
	g_config->SetPath(_object->path);
	wxString val;
	bool ret = g_config->Read(name,&val);
	if (ret) {
		value = val;
		return ERROR_SUCCESS;
	}
	return ERROR_GET_VALUE;
}

LONG CKey::GetValue_IfOk(LPCTSTR name, UInt32 &value) throw()
{
  UInt32 newVal;
  LONG res = QueryValue(name, newVal);
  if (res == ERROR_SUCCESS)
    value = newVal;
  return res;
}

LONG CKey::GetValue_IfOk(LPCTSTR name, bool &value) throw()
{
  bool newVal;
  LONG res = QueryValue(name, newVal);
  if (res == ERROR_SUCCESS)
    value = newVal;
  return res;
}

LONG CKey::SetValue(LPCTSTR valueName, UInt32 value) throw()
{
	g_config->SetPath(_object->path);
	bool ret = g_config->Write(valueName,(long)value);
	if (ret == true) return ERROR_SUCCESS;
	return ERROR_SET_VALUE;
}

LONG CKey::SetValue(LPCTSTR valueName, bool value) throw()
{
	g_config->SetPath(_object->path);
	bool ret = g_config->Write(valueName,value);
	if (ret == true) return ERROR_SUCCESS;
	return ERROR_SET_VALUE;
}

LONG CKey::SetValue(LPCTSTR valueName, LPCTSTR value) throw()
{
	g_config->SetPath(_object->path);
	bool ret = g_config->Write(valueName,value);
	if (ret == true) return ERROR_SUCCESS;
	return ERROR_SET_VALUE;
}

LONG CKey::SetValue(LPCTSTR name, const void *value, UInt32 size) throw()
{
	static char hexa[] = "0123456789ABCDEF";
	/* FIXME
	MYASSERT(value != NULL);
	MYASSERT(_object != NULL);
	return RegSetValueEx(_object, name, NULL, REG_BINARY, (const BYTE *)value, size);
	*/
	BYTE *buf = (BYTE *)value;
	wxString str;
	for(UInt32 i=0;i<size;i++)
	{
		str += 	hexa[ (buf[i]>>4) & 0x0f];
		str += 	hexa[ buf[i] & 0x0f];
	}
	return SetValue(name,(LPCTSTR)str);
}

LONG CKey::EnumKeys(CSysStringVector &keyNames)
{
	g_config->SetPath(_object->path);
	keyNames.Clear();
	// enumeration variables
	wxString str;
	long dummy;
	bool bCont = g_config->GetFirstEntry(str, dummy);
	while ( bCont ) {
		keyNames.Add((const TCHAR *)str);
		bCont = g_config->GetNextEntry(str, dummy);
	}

	// now all groups...
	bCont = g_config->GetFirstGroup(str, dummy);
	while ( bCont ) {
		keyNames.Add((const TCHAR *)str);
		bCont = g_config->GetNextGroup(str, dummy);
  	}
	return ERROR_SUCCESS;
}

LONG CKey::QueryValue(LPCTSTR name, void *value, UInt32 &dataSize) throw()
{
	g_config->SetPath(_object->path);
	wxString str;
	bool ret = g_config->Read(name,&str);
	if (ret == false) return ERROR_GET_VALUE;

	size_t l =  str.Len() / 2;
	if (l > dataSize) l = dataSize;
	else              dataSize=l;

	BYTE *buf = (BYTE *)value;
	for(UInt32 i=0;i<dataSize;i++)
	{
		char cval[3];
		cval[0] = (char)str[2*i];
		cval[1] = (char)str[2*i+1];
		cval[2] = 0;
		unsigned uval = 0;
		sscanf(cval,"%x",&uval);
		buf[i]=(BYTE)uval;
	}

	return ERROR_SUCCESS;
}


LONG CKey::QueryValue(LPCTSTR name, CByteBuffer &value, UInt32 &dataSize)
{
	g_config->SetPath(_object->path);
	wxString str;
	bool ret = g_config->Read(name,&str);
	if (ret == false) return ERROR_GET_VALUE;

	dataSize =  str.Len() / 2;
	value.Alloc(dataSize);
	return QueryValue(name, (BYTE *)value, dataSize);
}


LONG CKey::SetValue_Strings(LPCTSTR valueName, const UStringVector &strings) throw()
{
  UInt32 numChars = 0;
  int i;
  for (i = 0; i < strings.Size(); i++)
    numChars += strings[i].Len() + 1;
  CBuffer<wchar_t> buffer(numChars);
  int pos = 0;
  for (i = 0; i < strings.Size(); i++)
  {
    const UString &s = strings[i];
    MyStringCopy((wchar_t *)buffer + pos, (const wchar_t *)s);
    pos += s.Len() + 1;
  }
  return SetValue(valueName, buffer, numChars * sizeof(wchar_t));
}

LONG CKey::GetValue_Strings(LPCTSTR valueName, UStringVector &strings)
{
  strings.Clear();
  CByteBuffer buffer;
  UInt32 dataSize;
  LONG res = QueryValue(valueName, buffer, dataSize);
  if (res != ERROR_SUCCESS)
    return res;
  if (dataSize % sizeof(wchar_t) != 0)
    return E_FAIL;
  const wchar_t *data = (const wchar_t *)(const Byte  *)buffer;
  int numChars = dataSize / sizeof(wchar_t);
  UString s;
  for (int i = 0; i < numChars; i++)
  {
    wchar_t c = data[i];
    if (c == 0)
    {
      strings.Add(s);
      s.Empty();
    }
    else
      s += c;
  }
  return res;
}


}
}

// Windows/Registry.h

#ifndef __WINDOWS_REGISTRY_H
#define __WINDOWS_REGISTRY_H

#include "../Common/MyBuffer.h"
#include "../Common/MyString.h"
#include "../Common/MyTypes.h"

#ifndef _WIN32
class HKEY_Impl;

typedef HKEY_Impl * HKEY;

#define HKEY_CURRENT_USER       ((HKEY) 0x80000001)

typedef DWORD REGSAM;
#define ERROR_SUCCESS (0)
#define KEY_READ	(0x1234) // FIXME
#define KEY_ALL_ACCESS  (~0)     // FIXME

#endif

namespace NWindows {
namespace NRegistry {

LONG SetValue(HKEY parentKey, LPCTSTR keyName, LPCTSTR valueName, LPCTSTR value);

class CKey
{
  HKEY _object;
public:
  CKey(): _object(NULL) {}
  ~CKey() { Close(); }

  operator HKEY() const { return _object; }
#if 0
  void Attach(HKEY key) { _object = key; }
  HKEY Detach()
  {
    HKEY key = _object;
    _object = NULL;
    return key;
  }

  LONG Create(HKEY parentKey, LPCTSTR keyName,
      LPTSTR keyClass = REG_NONE, DWORD options = REG_OPTION_NON_VOLATILE,
      REGSAM accessMask = KEY_ALL_ACCESS,
      LPSECURITY_ATTRIBUTES securityAttributes = NULL,
      LPDWORD disposition = NULL);
#endif // #if 0
  LONG Create(HKEY parentKey, LPCTSTR keyName) throw();
  LONG Open(HKEY parentKey, LPCTSTR keyName, REGSAM accessMask = KEY_ALL_ACCESS) throw();

  LONG Close() throw();

  LONG DeleteSubKey(LPCTSTR subKeyName) throw();
  LONG RecurseDeleteKey(LPCTSTR subKeyName) throw();

  LONG DeleteValue(LPCTSTR name) throw();
  #ifndef _UNICODE
  LONG DeleteValue(LPCWSTR name);
  #endif

  LONG SetValue(LPCTSTR valueName, UInt32 value) throw();
  LONG SetValue(LPCTSTR valueName, bool value) throw();
  LONG SetValue(LPCTSTR valueName, LPCTSTR value) throw();
  // LONG SetValue(LPCTSTR valueName, const CSysString &value);
  #ifndef _UNICODE
  LONG SetValue(LPCWSTR name, LPCWSTR value);
  // LONG SetValue(LPCWSTR name, const UString &value);
  #endif

  LONG SetValue(LPCTSTR name, const void *value, UInt32 size) throw();

  LONG SetValue_Strings(LPCTSTR valueName, const UStringVector &strings) throw();
  LONG GetValue_Strings(LPCTSTR valueName, UStringVector &strings);

  LONG SetKeyValue(LPCTSTR keyName, LPCTSTR valueName, LPCTSTR value) throw();

  LONG QueryValue(LPCTSTR name, UInt32 &value) throw();
  LONG QueryValue(LPCTSTR name, bool &value) throw();
  LONG QueryValue(LPCTSTR name, LPTSTR value, UInt32 &dataSize) throw();
  LONG QueryValue(LPCTSTR name, CSysString &value);

  LONG GetValue_IfOk(LPCTSTR name, UInt32 &value) throw();
  LONG GetValue_IfOk(LPCTSTR name, bool &value) throw();

  #ifndef _UNICODE
  LONG QueryValue(LPCWSTR name, LPWSTR value, UInt32 &dataSize);
  LONG QueryValue(LPCWSTR name, UString &value);
  #endif

  LONG QueryValue(LPCTSTR name, void *value, UInt32 &dataSize) throw();
  LONG QueryValue(LPCTSTR name, CByteBuffer &value, UInt32 &dataSize);

  LONG EnumKeys(CSysStringVector &keyNames);
};

}}

#endif
// Windows/ResourceString.h

#ifndef __WINDOWS_RESOURCE_STRING_H
#define __WINDOWS_RESOURCE_STRING_H

#include "../Common/MyString.h"

namespace NWindows {

UString MyLoadString(UINT resourceID);
void MyLoadString(HINSTANCE hInstance, UINT resourceID, UString &dest);
void MyLoadString(UINT resourceID, UString &dest);

}

#endif
// Windows/Shell.h

#ifndef __WINDOWS_SHELL_H
#define __WINDOWS_SHELL_H

#include <windows.h>
// #include <shlobj.h>

#include "Common/MyString.h"
#include "Windows/Defs.h"


namespace NWindows{
namespace NShell{

bool BrowseForFolder(HWND owner, LPCWSTR title, LPCWSTR initialFolder, UString &resultPath);

}}


#endif
// Windows/Synchronization.cpp

#include "StdAfx.h"

#include "Synchronization.h"

// #define TRACEN(u) u;
#define TRACEN(u)  /* */

#define MAGIC 0x1234CAFE
class CSynchroTest
{
  int _magic;
  public:
  CSynchroTest() {
    _magic = MAGIC;
  }
  void testConstructor() {
    if (_magic != MAGIC) {
      printf("ERROR : no constructors called during loading of plugins (please look at LINK_SHARED in makefile.machine)\n");
      exit(EXIT_FAILURE);
    }
  }
};

static CSynchroTest gbl_synchroTest;

extern "C" void sync_TestConstructor(void) {
	gbl_synchroTest.testConstructor();
}


namespace NWindows {
namespace NSynchronization {


#ifndef ENV_BEOS
#ifdef DEBUG_SYNCHRO
  void CSynchro::dump_error(int ligne,int ret,const char *text,void *param)
  {
    printf("\n##T%d#ERROR2 (l=%d) %s : param=%p ret = %d (%s)##\n",(int)pthread_self(),ligne,text,param,ret,strerror(ret));
    // abort();
  }
  CSynchro::CSynchro() {
    TRACEN((printf("\nT%d : E1-CSynchro(this=%p,m=%p,cond=%p)\n",(int)pthread_self(),(void *)this,(void *)&_object,(void *)&_cond)))
    _isValid = false;
  }

  void CSynchro::Create() {
    TRACEN((printf("\nT%d : E1-CSynchro::Create(this=%p,m=%p,cond=%p)\n",(int)pthread_self(),(void *)this,(void *)&_object,(void *)&_cond)))
    pthread_mutexattr_t mutexattr;
    memset(&mutexattr,0,sizeof(mutexattr));
    int ret = pthread_mutexattr_init(&mutexattr);
    if (ret != 0) {
	dump_error(__LINE__,ret,"pthread_mutexattr_init",&mutexattr);
    }
    ret = pthread_mutexattr_settype(&mutexattr,PTHREAD_MUTEX_ERRORCHECK);
    if (ret != 0) dump_error(__LINE__,ret,"pthread_mutexattr_settype",&mutexattr);
    ret = ::pthread_mutex_init(&_object,&mutexattr);
    if (ret != 0) dump_error(__LINE__,ret,"pthread_mutex_init",&_object);
    ret = ::pthread_cond_init(&_cond,0);
    if (ret != 0) dump_error(__LINE__,ret,"pthread_cond_init",&_cond);
    TRACEN((printf("\nT%d : E2-CSynchro::Create(m=%p,cond=%p)\n",(int)pthread_self(),(void *)&_object,(void *)&_cond)))
  }
  CSynchro::~CSynchro() {
    TRACEN((printf("\nT%d : E1-~CSynchro(this=%p,m=%p,cond=%p)\n",(int)pthread_self(),(void *)this,(void *)&_object,(void *)&_cond)))
    if (_isValid) {
      int ret = ::pthread_mutex_destroy(&_object);
      if (ret != 0) dump_error(__LINE__,ret,"pthread_mutex_destroy",&_object);
      ret = ::pthread_cond_destroy(&_cond);
      if (ret != 0) dump_error(__LINE__,ret,"pthread_cond_destroy",&_cond);
      TRACEN((printf("\nT%d : E2-~CSynchro(m=%p,cond=%p)\n",(int)pthread_self(),(void *)&_object,(void *)&_cond)))
    }
    _isValid = false;
  }
  void CSynchro::Enter() { 
    TRACEN((printf("\nT%d : E1-CSynchro::Enter(%p)\n",(int)pthread_self(),(void *)&_object)))
    int ret = ::pthread_mutex_lock(&_object);
    if (ret != 0) {
      dump_error(__LINE__,ret,"CSynchro::Enter-pthread_mutex_lock",&_object);
    }
    TRACEN((printf("\nT%d : E2-CSynchro::Enter(%p)\n",(int)pthread_self(),(void *)&_object)))
  }
  void CSynchro::Leave() {
    TRACEN((printf("\nT%d : E1-CSynchro::Leave(%p)\n",(int)pthread_self(),(void *)&_object)))
    int ret = ::pthread_mutex_unlock(&_object);
    if (ret != 0) dump_error(__LINE__,ret,"Leave::pthread_mutex_unlock",&_object);
    TRACEN((printf("\nT%d : E2-CSynchro::Leave(%p)\n",(int)pthread_self(),(void *)&_object)))
  }
  void CSynchro::WaitCond() {
    TRACEN((printf("\nT%d : E1-CSynchro::WaitCond(%p,%p)\n",(int)pthread_self(),(void *)&_cond,(void *)&_object)))
    int ret = ::pthread_cond_wait(&_cond, &_object);
    if (ret != 0) dump_error(__LINE__,ret,"pthread_cond_wait",&_cond);
    TRACEN((printf("\nT%d : E2-CSynchro::WaitCond(%p,%p)\n",(int)pthread_self(),(void *)&_cond,(void *)&_object)))
  }
  void CSynchro::LeaveAndSignal() {
    TRACEN((printf("\nT%d : E1-CSynchro::LeaveAndSignal(%p)\n",(int)pthread_self(),(void *)&_cond)))
    int ret = ::pthread_cond_broadcast(&_cond);
    if (ret != 0) dump_error(__LINE__,ret,"pthread_cond_broadcast",&_cond);
    TRACEN((printf("\nT%d : E2-CSynchro::LeaveAndSignal(%p)\n",(int)pthread_self(),(void *)&_object)))
    ret = ::pthread_mutex_unlock(&_object);
    if (ret != 0) dump_error(__LINE__,ret,"LeaveAndSignal::pthread_mutex_unlock",&_object);
    TRACEN((printf("\nT%d : E3-CSynchro::LeaveAndSignal(%p)\n",(int)pthread_self(),(void *)&_cond)))
  }
#endif
#endif

}}

DWORD WINAPI WaitForMultipleObjects( DWORD count, const HANDLE *handles, BOOL wait_all, DWORD timeout )
{
    TRACEN((printf("\nT%d : E1-WaitForMultipleObjects(%d)\n",(int)pthread_self(),(int)count)))
  if (wait_all != FALSE) {
      printf("\n\n INTERNAL ERROR - WaitForMultipleObjects(...) wait_all(%d) != FALSE\n\n",(unsigned)wait_all);
      abort();
  }

  if (timeout != INFINITE) {
      printf("\n\n INTERNAL ERROR - WaitForMultipleObjects(...) timeout(%u) != INFINITE\n\n",(unsigned)timeout);
      abort();
  }

  if (count < 1) {
      printf("\n\n INTERNAL ERROR - WaitForMultipleObjects(...) count(%u) < 1\n\n",(unsigned)count);
      abort();
  }

  NWindows::NSynchronization::CSynchro *synchro = handles[0]->_sync;

  TRACEN((printf("\nT%d : E2-WaitForMultipleObjects(%d)\n",(int)pthread_self(),(int)count)))
  synchro->Enter();
  TRACEN((printf("\nT%d : E3-WaitForMultipleObjects(%d)\n",(int)pthread_self(),(int)count)))

#ifdef DEBUG_SYNCHRO
  for(DWORD i=1;i<count;i++) {
    if (synchro != handles[i]->_sync) {
      printf("\n\n INTERNAL ERROR - WaitForMultipleObjects(...) synchro(%p) != handles[%d]->_sync(%p)\n\n",
              synchro,(unsigned)i,handles[i]->_sync);
      abort();
    }
  }
#endif

  while(1) {
    for(DWORD i=0;i<count;i++) {
      if (handles[i]->IsSignaledAndUpdate()) {
        synchro->Leave();
  TRACEN((printf("\nT%d : E4-WaitForMultipleObjects(%d)\n",(int)pthread_self(),(int)count)))
        return WAIT_OBJECT_0+i;
      }
    }
    synchro->WaitCond();
  }
  synchro->Leave();
  return ETIMEDOUT; // WAIT_TIMEOUT;
}

// Windows/Synchronization.h

#ifndef __WINDOWS_SYNCHRONIZATION_H
#define __WINDOWS_SYNCHRONIZATION_H

#include "Defs.h"

extern "C" 
{ 
#include "../../C/Threads.h"
}

#ifdef _WIN32
#include "Handle.h"
#endif

namespace NWindows {
namespace NSynchronization {

class Uncopyable {
protected: 
  Uncopyable() {} // allow construction
  ~Uncopyable() {} // and destruction of derived objects...
private:
  Uncopyable(const Uncopyable&);             // ...but prevent copying
  Uncopyable& operator=(const Uncopyable&);
};


class CBaseEvent // FIXME : private Uncopyable
{
protected:
  ::CEvent _object;
public:
  bool IsCreated() { return Event_IsCreated(&_object) != 0; }
#ifdef _WIN32
  operator HANDLE() { return _object.handle; }
#endif
  CBaseEvent() { Event_Construct(&_object); }
  ~CBaseEvent() { Close(); }
  WRes Close() { return Event_Close(&_object); }
  #ifdef _WIN32
  WRes Create(bool manualReset, bool initiallyOwn, LPCTSTR name = NULL,
      LPSECURITY_ATTRIBUTES securityAttributes = NULL)
  {
    _object.handle = ::CreateEvent(securityAttributes, BoolToBOOL(manualReset),
        BoolToBOOL(initiallyOwn), name);
    if (_object.handle != 0)
      return 0;
    return ::GetLastError();
  }
  WRes Open(DWORD desiredAccess, bool inheritHandle, LPCTSTR name)
  {
    _object.handle = ::OpenEvent(desiredAccess, BoolToBOOL(inheritHandle), name);
    if (_object.handle != 0)
      return 0;
    return ::GetLastError();
  }
  #endif

  WRes Set() { return Event_Set(&_object); }
  // bool Pulse() { return BOOLToBool(::PulseEvent(_handle)); }
  WRes Reset() { return Event_Reset(&_object); }
  WRes Lock() { return Event_Wait(&_object); }
};

class CManualResetEvent: public CBaseEvent
{
public:
  WRes Create(bool initiallyOwn = false)
  {
    return ManualResetEvent_Create(&_object, initiallyOwn ? 1: 0);
  }
  WRes CreateIfNotCreated()
  {
    if (IsCreated())
      return 0;
    return ManualResetEvent_CreateNotSignaled(&_object);
  }
  #ifdef _WIN32
  WRes CreateWithName(bool initiallyOwn, LPCTSTR name)
  {
    return CBaseEvent::Create(true, initiallyOwn, name);
  }
  #endif
};

class CAutoResetEvent: public CBaseEvent
{
public:
  WRes Create()
  {
    return AutoResetEvent_CreateNotSignaled(&_object);
  }
  WRes CreateIfNotCreated()
  {
    if (IsCreated())
      return 0;
    return AutoResetEvent_CreateNotSignaled(&_object);
  }
};

#ifdef _WIN32
class CObject: public CHandle
{
public:
  WRes Lock(DWORD timeoutInterval = INFINITE)
    { return (::WaitForSingleObject(_handle, timeoutInterval) == WAIT_OBJECT_0 ? 0 : ::GetLastError()); }
};
class CMutex: public CObject
{
public:
  WRes Create(bool initiallyOwn, LPCTSTR name = NULL,
      LPSECURITY_ATTRIBUTES securityAttributes = NULL)
  {
    _handle = ::CreateMutex(securityAttributes, BoolToBOOL(initiallyOwn), name);
    if (_handle != 0)
      return 0;
    return ::GetLastError();
  }
  WRes Open(DWORD desiredAccess, bool inheritHandle, LPCTSTR name)
  {
    _handle = ::OpenMutex(desiredAccess, BoolToBOOL(inheritHandle), name);
    if (_handle != 0)
      return 0;
    return ::GetLastError();
  }
  WRes Release() 
  { 
    return ::ReleaseMutex(_handle) ? 0 : ::GetLastError();
  }
};
class CMutexLock
{
  CMutex *_object;
public:
  CMutexLock(CMutex &object): _object(&object) { _object->Lock(); } 
  ~CMutexLock() { _object->Release(); }
};
#endif

class CSemaphore : private Uncopyable
{
  ::CSemaphore _object;
public:
  CSemaphore() { Semaphore_Construct(&_object); }
  ~CSemaphore() { Close(); }
  WRes Close() {  return Semaphore_Close(&_object); }
#ifdef _WIN32
  operator HANDLE() { return _object.handle; }
#endif
  WRes Create(UInt32 initiallyCount, UInt32 maxCount)
  {
    return Semaphore_Create(&_object, initiallyCount, maxCount);
  }
  WRes Release() { return Semaphore_Release1(&_object); }
  WRes Release(UInt32 releaseCount) { return Semaphore_ReleaseN(&_object, releaseCount); }
  WRes Lock() { return Semaphore_Wait(&_object); }
};

class CCriticalSection : private Uncopyable
{
  ::CCriticalSection _object;
public:
  CCriticalSection() { CriticalSection_Init(&_object); }
  ~CCriticalSection() { CriticalSection_Delete(&_object); }
  void Enter() { CriticalSection_Enter(&_object); }
  void Leave() { CriticalSection_Leave(&_object); }
};

class CCriticalSectionLock : private Uncopyable
{
  CCriticalSection *_object;
  void Unlock()  { _object->Leave(); }
public:
  CCriticalSectionLock(CCriticalSection &object): _object(&object) {_object->Enter(); } 
  ~CCriticalSectionLock() { Unlock(); }
};

}}

#ifndef _WIN32
#include "Synchronization2.h"
#endif

#endif

// Windows/Synchronization.h

#ifdef ENV_BEOS
#include <Locker.h>
#include <kernel/OS.h>
#include <list>
#endif

/* Remark : WFMO = WaitForMultipleObjects */

namespace NWindows { namespace NSynchronization { struct CBaseHandleWFMO; } }

typedef NWindows::NSynchronization::CBaseHandleWFMO *HANDLE;

DWORD WINAPI WaitForMultipleObjects( DWORD count, const HANDLE *handles, BOOL wait_all, DWORD timeout );

namespace NWindows {
namespace NSynchronization {

#ifdef ENV_BEOS
class CSynchro : BLocker, private Uncopyable
{
#define MAX_THREAD 256
  thread_id _waiting[MAX_THREAD]; // std::list<thread_id> _waiting;
  int index_waiting;
public:
  CSynchro() { index_waiting = 0; }
  void Create() { index_waiting = 0; }
  ~CSynchro() {}
  void Enter() { Lock(); }
  void Leave() { Unlock(); }
  void WaitCond() { 
    _waiting[index_waiting++] = find_thread(NULL); // _waiting.push_back(find_thread(NULL));
    thread_id sender;
    Unlock();
    int msg = receive_data(&sender, NULL, 0);
    Lock();
  }
  void LeaveAndSignal() {
    // Unlock();
    // Lock();
    // for (std::list<thread_id>::iterator index = _waiting.begin(); index != _waiting.end(); index++)
    for(int index = 0 ; index < index_waiting ; index++)
    {
       send_data(_waiting[index], '7zCN', NULL, 0);
    }
    index_waiting = 0; // _waiting.clear();
    Unlock();
  }
};
#else // #ifdef ENV_BEOS
#ifdef DEBUG_SYNCHRO
class CSynchro: private Uncopyable
{
  pthread_mutex_t _object;
  pthread_cond_t _cond;
  bool _isValid;
  void dump_error(int ligne,int ret,const char *text,void *param);
public:
  CSynchro();
  ~CSynchro();
  void Create();
  void Enter();
  void Leave();
  void WaitCond();
  void LeaveAndSignal();
};
#else // #ifdef DEBUG_SYNCHRO
class CSynchro : private Uncopyable
{
  pthread_mutex_t _object;
  pthread_cond_t _cond;
  bool _isValid;
public:
  CSynchro() { _isValid = false; }
  ~CSynchro() {
    if (_isValid) {
      ::pthread_mutex_destroy(&_object);
      ::pthread_cond_destroy(&_cond);
    }
    _isValid = false;
  }
  void Create() {
    ::pthread_mutex_init(&_object,0);
    ::pthread_cond_init(&_cond,0);
  }
  void Enter() { 
     ::pthread_mutex_lock(&_object);
  }
  void Leave() {
    ::pthread_mutex_unlock(&_object);
  }
  void WaitCond() { 
    ::pthread_cond_wait(&_cond, &_object);
  }
  void LeaveAndSignal() { 
    ::pthread_cond_broadcast(&_cond);
    ::pthread_mutex_unlock(&_object);
  }
};
#endif // #ifdef DEBUG_SYNCHRO
#endif // #ifdef ENV_BEOS

struct CBaseHandleWFMO // FIXME : private Uncopyable
{
  CSynchro *_sync;

  CBaseHandleWFMO() { }

  operator HANDLE() { return this; }
  virtual bool IsSignaledAndUpdate() = 0;
};

class CBaseEventWFMO : public CBaseHandleWFMO
{
  bool _manual_reset;
  bool _state;

public:

  bool IsCreated()  { return (this->_sync != 0); }
  CBaseEventWFMO()  { this->_sync = 0; } 
  ~CBaseEventWFMO() { Close(); }

  WRes Close() { this->_sync = 0; return S_OK; }

  WRes Create(CSynchro *sync,bool manualReset, bool initiallyOwn)
  {
    this->_sync         = sync;
    this->_manual_reset = manualReset;
    this->_state        = initiallyOwn;
    return S_OK;
  }

  WRes Set() {
    this->_sync->Enter();
    this->_state = true;
    this->_sync->LeaveAndSignal();
    return S_OK;
  }

  WRes Reset() {
    this->_sync->Enter();
    this->_state = false;
    this->_sync->Leave();
    return S_OK;
  }
  virtual bool IsSignaledAndUpdate() {
    if (this->_state == true) {
      if (this->_manual_reset == false) this->_state = false;
      return true;
    }
    return false;
  }
};

class CManualResetEventWFMO: public CBaseEventWFMO
{
public:
  WRes Create(CSynchro *sync,bool initiallyOwn = false) { return CBaseEventWFMO::Create(sync,true, initiallyOwn); }
};

class CAutoResetEventWFMO: public CBaseEventWFMO
{
public:
  WRes Create(CSynchro *sync) { return CBaseEventWFMO::Create(sync,false, false); }
  WRes CreateIfNotCreated(CSynchro *sync)
  {
    if (IsCreated())
      return 0;
    return CBaseEventWFMO::Create(sync,false, false);
  }
};

class CSemaphoreWFMO : public CBaseHandleWFMO
{
  LONG _count;
  LONG _maxCount;

public:
  CSemaphoreWFMO() : _count(0), _maxCount(0) { this->_sync=0;} 
  WRes Create(CSynchro *sync,LONG initiallyCount, LONG maxCount)
  {
    if ((initiallyCount < 0) || (initiallyCount > maxCount) || (maxCount < 1)) return S_FALSE;
    this->_sync     = sync;
    this->_count    = initiallyCount;
    this->_maxCount = maxCount;
    return S_OK;
  }
  WRes Release(LONG releaseCount = 1) {
    if (releaseCount < 1) return S_FALSE;

    this->_sync->Enter();
    LONG newCount = this->_count + releaseCount;
    if (newCount > this->_maxCount)
    {
      this->_sync->Leave();
      return S_FALSE;
    }
    this->_count = newCount;

    this->_sync->LeaveAndSignal();

    return S_OK;
  }
  WRes Close() { this->_sync=0; return S_OK; }

  virtual bool IsSignaledAndUpdate() {
    if (this->_count > 0) {
      this->_count--;
      return true;
    }
    return false;
  }
};

}}

#include <stdio.h>
#include <stdlib.h>

#if defined (__NetBSD__) || defined(__OpenBSD__) || defined (__FreeBSD__) || defined (__FreeBSD_kernel__) || defined (__APPLE__)
#include <sys/param.h>
#include <sys/sysctl.h>
#elif defined(__linux__) || defined(__CYGWIN__) || defined(sun) || defined(__NETWARE__)
#include <unistd.h>
#elif defined(hpux) || defined(__hpux)
#include <sys/param.h>
#include <sys/pstat.h>
#endif

#if defined(__NETWARE__)
#include <sys/sysinfo.h>
#endif

#if defined(ENV_BEOS)
#include <be/kernel/OS.h>
#endif


#include "Common/MyTypes.h"

namespace NWindows
{
	namespace NSystem
	{
		/************************ GetNumberOfProcessors ************************/

		#if defined (__NetBSD__) || defined(__OpenBSD__)
		UInt32 GetNumberOfProcessors() {
			int mib[2], value;
		  	int nbcpu = 1;

		  	mib[0] = CTL_HW;
		  	mib[1] = HW_NCPU;
		  	size_t len = sizeof(size_t);
		  	if (sysctl(mib, 2, &value, &len, NULL, 0) >= 0)
		  		if (value > nbcpu)
					nbcpu = value;
			return nbcpu;
		}
		#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)
		UInt32 GetNumberOfProcessors() {
		  	int nbcpu = 1;
			size_t value;
			size_t len = sizeof(value);
			if (sysctlbyname("hw.ncpu", &value, &len, NULL, 0) == 0)
				nbcpu = value;
			return nbcpu;
		}
		#elif defined (__APPLE__)
		UInt32 GetNumberOfProcessors() {
		  	int nbcpu = 1,value;
			size_t valSize = sizeof(value);
			if (sysctlbyname ("hw.ncpu", &value, &valSize, NULL, 0) == 0)
				nbcpu = value;
			return nbcpu;
		}

		#elif defined(__linux__) || defined(__CYGWIN__) || defined(sun)
		UInt32 GetNumberOfProcessors() {
		  	int nbcpu = sysconf (_SC_NPROCESSORS_CONF);
			if (nbcpu < 1) nbcpu = 1;
			return nbcpu;
		}
		#elif defined(hpux) || defined(__hpux)
		UInt32 GetNumberOfProcessors() {
			struct pst_dynamic psd;
			if (pstat_getdynamic(&psd, sizeof(psd), (size_t)1, 0) != -1)
				return (UInt32)psd.psd_proc_cnt;
			return 1;
		}
		#elif defined(__NETWARE__)
		UInt32 GetNumberOfProcessors() {
			// int nbcpu = get_nprocs_conf();
			int nbcpu = get_nprocs();
			if (nbcpu < 1) nbcpu = 1;
			return nbcpu;
		}
		#elif defined(ENV_BEOS)
		UInt32 GetNumberOfProcessors() {
			system_info info;
			get_system_info(&info);
			int nbcpu = info.cpu_count;
			if (nbcpu < 1) nbcpu = 1;
			return nbcpu;
		}
		#else
		#warning Generic GetNumberOfProcessors
		UInt32 GetNumberOfProcessors() {
			return 1;
		}
		#endif

		/************************ GetRamSize ************************/
	    bool GetRamSize(UInt64 &size) {
			size = (UInt64)(sizeof(size_t)) << 29;
			bool isDefined = true;

#ifdef linux
	 		FILE * f = fopen( "/proc/meminfo", "r" );
	 		if (f)
	 		{
				char buffer[256];
				unsigned long total;

				size = 0;

		  		while (fgets( buffer, sizeof(buffer), f ))
		  		{
		 		/* old style /proc/meminfo ... */
					if (sscanf( buffer, "Mem: %lu", &total))
					{
					 	size += total;
					}

					/* new style /proc/meminfo ... */
					if (sscanf(buffer, "MemTotal: %lu", &total))
					 	size = ((UInt64)total)*1024;
		  		}
		  		fclose( f );
			}
#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__APPLE__) || defined(__OpenBSD__)
#ifdef HW_MEMSIZE
			uint64_t val = 0; // support 2Gb+ RAM
			int mib[2] = { CTL_HW, HW_MEMSIZE };
#elif defined(HW_PHYSMEM64)
			uint64_t val = 0; // support 2Gb+ RAM
			int mib[2] = { CTL_HW, HW_PHYSMEM64 };
#else // HW_MEMSIZE
			unsigned int val = 0; // For old system
			int mib[2] = { CTL_HW, HW_PHYSMEM };
#endif // HW_MEMSIZE
			size_t size_sys = sizeof(val);

			sysctl(mib, 2, &val, &size_sys, NULL, 0);
			if (val) size = val;
#elif defined(__CYGWIN__)
			unsigned long pagesize=sysconf(_SC_PAGESIZE); // returns 65536 => OK
					// see http://readlist.com/lists/cygwin.com/cygwin/0/3313.html
			unsigned long maxpages=sysconf(_SC_PHYS_PAGES);
			size = ((UInt64)pagesize)*maxpages;
#elif defined ( sun ) || defined(__NETWARE__)
			unsigned long pagesize=sysconf(_SC_PAGESIZE);
			unsigned long maxpages=sysconf(_SC_PHYS_PAGES);
			size = ((UInt64)pagesize)*maxpages;
#elif defined(hpux) || defined(__hpux)
			struct pst_static pst;
			union pstun pu;
						
			pu.pst_static = &pst;
			if ( pstat( PSTAT_STATIC, pu, (size_t)sizeof(pst), (size_t)0, 0 ) != -1 ) {
				size = ((UInt64)pst.physical_memory)*pst.page_size;
			}
#elif defined(ENV_BEOS)
			system_info info;
			get_system_info(&info);
			size = info.max_pages;
			size *= 4096;
#else
#warning Generic GetRamSize
			isDefined = false;
#endif
			return isDefined;
		}

	}
}

#include <stdio.h>
#include <stdlib.h>

#if defined (__NetBSD__) || defined(__OpenBSD__) || defined (__FreeBSD__) || defined (__FreeBSD_kernel__) || defined (__APPLE__)
#include <sys/param.h>
#include <sys/sysctl.h>
#elif defined(__linux__) || defined(__CYGWIN__) || defined(sun) || defined(__NETWARE__)
#include <unistd.h>
#elif defined(hpux) || defined(__hpux)
#include <sys/param.h>
#include <sys/pstat.h>
#endif

#if defined(__NETWARE__)
#include <sys/sysinfo.h>
#endif

#if defined(ENV_BEOS)
#include <be/kernel/OS.h>
#endif


#include "Common/MyTypes.h"

namespace NWindows
{
	namespace NSystem
	{
		/************************ GetNumberOfProcessors ************************/

		#if defined (__NetBSD__) || defined(__OpenBSD__)
		UInt32 GetNumberOfProcessors() {
			int mib[2], value;
		  	int nbcpu = 1;

		  	mib[0] = CTL_HW;
		  	mib[1] = HW_NCPU;
		  	size_t len = sizeof(size_t);
		  	if (sysctl(mib, 2, &value, &len, NULL, 0) >= 0)
		  		if (value > nbcpu)
					nbcpu = value;
			return nbcpu;
		}
		#elif defined (__FreeBSD__) || defined (__FreeBSD_kernel__)
		UInt32 GetNumberOfProcessors() {
		  	int nbcpu = 1;
			size_t value;
			size_t len = sizeof(value);
			if (sysctlbyname("hw.ncpu", &value, &len, NULL, 0) == 0)
				nbcpu = value;
			return nbcpu;
		}
		#elif defined (__APPLE__)
		UInt32 GetNumberOfProcessors() {
		  	int nbcpu = 1,value;
			size_t valSize = sizeof(value);
			if (sysctlbyname ("hw.ncpu", &value, &valSize, NULL, 0) == 0)
				nbcpu = value;
			return nbcpu;
		}

		#elif defined(__linux__) || defined(__CYGWIN__) || defined(sun)
		UInt32 GetNumberOfProcessors() {
		  	int nbcpu = sysconf (_SC_NPROCESSORS_CONF);
			if (nbcpu < 1) nbcpu = 1;
			return nbcpu;
		}
		#elif defined(hpux) || defined(__hpux)
		UInt32 GetNumberOfProcessors() {
			struct pst_dynamic psd;
			if (pstat_getdynamic(&psd, sizeof(psd), (size_t)1, 0) != -1)
				return (UInt32)psd.psd_proc_cnt;
			return 1;
		}
		#elif defined(__NETWARE__)
		UInt32 GetNumberOfProcessors() {
			// int nbcpu = get_nprocs_conf();
			int nbcpu = get_nprocs();
			if (nbcpu < 1) nbcpu = 1;
			return nbcpu;
		}
		#elif defined(ENV_BEOS)
		UInt32 GetNumberOfProcessors() {
			system_info info;
			get_system_info(&info);
			int nbcpu = info.cpu_count;
			if (nbcpu < 1) nbcpu = 1;
			return nbcpu;
		}
		#else
		#warning Generic GetNumberOfProcessors
		UInt32 GetNumberOfProcessors() {
			return 1;
		}
		#endif

		/************************ GetRamSize ************************/
	    bool GetRamSize(UInt64 &size) {
			size = (UInt64)(sizeof(size_t)) << 29;
			bool isDefined = true;

#ifdef linux
	 		FILE * f = fopen( "/proc/meminfo", "r" );
	 		if (f)
	 		{
				char buffer[256];
				unsigned long total;

				size = 0;

		  		while (fgets( buffer, sizeof(buffer), f ))
		  		{
		 		/* old style /proc/meminfo ... */
					if (sscanf( buffer, "Mem: %lu", &total))
					{
					 	size += total;
					}

					/* new style /proc/meminfo ... */
					if (sscanf(buffer, "MemTotal: %lu", &total))
					 	size = ((UInt64)total)*1024;
		  		}
		  		fclose( f );
			}
#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__APPLE__)
#ifdef HW_MEMSIZE
			uint64_t val = 0; // support 2Gb+ RAM
			int mib[2] = { CTL_HW, HW_MEMSIZE };
#else // HW_MEMSIZE
			unsigned int val = 0; // For old system
			int mib[2] = { CTL_HW, HW_PHYSMEM };
#endif // HW_MEMSIZE
			size_t size_sys = sizeof(val);

			sysctl(mib, 2, &val, &size_sys, NULL, 0);
			if (val) size = val;
#elif defined(__CYGWIN__)
			unsigned long pagesize=sysconf(_SC_PAGESIZE); // returns 65536 => OK
					// see http://readlist.com/lists/cygwin.com/cygwin/0/3313.html
			unsigned long maxpages=sysconf(_SC_PHYS_PAGES);
			size = ((UInt64)pagesize)*maxpages;
#elif defined ( sun ) || defined(__NETWARE__)
			unsigned long pagesize=sysconf(_SC_PAGESIZE);
			unsigned long maxpages=sysconf(_SC_PHYS_PAGES);
			size = ((UInt64)pagesize)*maxpages;
#elif defined(hpux) || defined(__hpux)
			struct pst_static pst;
			union pstun pu;
						
			pu.pst_static = &pst;
			if ( pstat( PSTAT_STATIC, pu, (size_t)sizeof(pst), (size_t)0, 0 ) != -1 ) {
				size = ((UInt64)pst.physical_memory)*pst.page_size;
			}
#elif defined(ENV_BEOS)
			system_info info;
			get_system_info(&info);
			size = info.max_pages;
			size *= 4096;
#else
#warning Generic GetRamSize
			isDefined = false;
#endif
			return isDefined;
		}

	}
}

// Windows/System.h

#ifndef __WINDOWS_SYSTEM_H
#define __WINDOWS_SYSTEM_H

#include "../Common/MyTypes.h"

namespace NWindows {
namespace NSystem {

UInt32 GetNumberOfProcessors();

bool GetRamSize(UInt64 &size); // returns false, if unknown ram size

}}

#endif
// Windows/Thread.h

#ifndef __WINDOWS_THREAD_H
#define __WINDOWS_THREAD_H

#include "Defs.h"

extern "C"
{
#include "../../C/Threads.h"
}

namespace NWindows {

class CThread
{
  ::CThread thread;
public:
  CThread() { Thread_Construct(&thread); }
  ~CThread() { Close(); }
  bool IsCreated() { return Thread_WasCreated(&thread) != 0; }
  WRes Close()  { return Thread_Close(&thread); }
  WRes Create(THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter)
    { return Thread_Create(&thread, startAddress, parameter); }
  WRes Wait() { return Thread_Wait(&thread); }
  
  #ifdef _WIN32
  operator HANDLE() { return thread; }
  void Attach(HANDLE handle) { thread = handle; }
  HANDLE Detach() { HANDLE h = thread; thread = NULL; return h; }
  DWORD Resume() { return ::ResumeThread(thread); }
  DWORD Suspend() { return ::SuspendThread(thread); }
  bool Terminate(DWORD exitCode) { return BOOLToBool(::TerminateThread(thread, exitCode)); }
  int GetPriority() { return ::GetThreadPriority(thread); }
  bool SetPriority(int priority) { return BOOLToBool(::SetThreadPriority(thread, priority)); }
  #endif
};

}

#endif
// Windows/TimeUtils.cpp

#include "StdAfx.h"

#include "Defs.h"
#include "TimeUtils.h"

namespace NWindows {
namespace NTime {

static const UInt32 kNumTimeQuantumsInSecond = 10000000;
static const UInt32 kFileTimeStartYear = 1601;
static const UInt32 kDosTimeStartYear = 1980;
static const UInt32 kUnixTimeStartYear = 1970;
static const UInt64 kUnixTimeOffset =
    (UInt64)60 * 60 * 24 * (89 + 365 * (kUnixTimeStartYear - kFileTimeStartYear));
static const UInt64 kNumSecondsInFileTime = (UInt64)(Int64)-1 / kNumTimeQuantumsInSecond;

bool DosTimeToFileTime(UInt32 dosTime, FILETIME &ft) throw()
{
  #if defined(_WIN32) && !defined(UNDER_CE)
  return BOOLToBool(::DosDateTimeToFileTime((UInt16)(dosTime >> 16), (UInt16)(dosTime & 0xFFFF), &ft));
  #else
  ft.dwLowDateTime = 0;
  ft.dwHighDateTime = 0;
  UInt64 res;
  if (!GetSecondsSince1601(kDosTimeStartYear + (dosTime >> 25), (dosTime >> 21) & 0xF, (dosTime >> 16) & 0x1F,
      (dosTime >> 11) & 0x1F, (dosTime >> 5) & 0x3F, (dosTime & 0x1F) * 2, res))
    return false;
  res *= kNumTimeQuantumsInSecond;
  ft.dwLowDateTime = (UInt32)res;
  ft.dwHighDateTime = (UInt32)(res >> 32);
  return true;
  #endif
}

static const UInt32 kHighDosTime = 0xFF9FBF7D;
static const UInt32 kLowDosTime = 0x210000;

#define PERIOD_4 (4 * 365 + 1)
#define PERIOD_100 (PERIOD_4 * 25 - 1)
#define PERIOD_400 (PERIOD_100 * 4 + 1)

bool FileTimeToDosTime(const FILETIME &ft, UInt32 &dosTime) throw()
{
  #if defined(_WIN32) && !defined(UNDER_CE)

  WORD datePart, timePart;
  if (!::FileTimeToDosDateTime(&ft, &datePart, &timePart))
  {
    dosTime = (ft.dwHighDateTime >= 0x01C00000) ? kHighDosTime : kLowDosTime;
    return false;
  }
  dosTime = (((UInt32)datePart) << 16) + timePart;

  #else

  unsigned year, mon, day, hour, min, sec;
  UInt64 v64 = ft.dwLowDateTime | ((UInt64)ft.dwHighDateTime << 32);
  Byte ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
  unsigned temp;
  UInt32 v;
  v64 += (kNumTimeQuantumsInSecond * 2 - 1);
  v64 /= kNumTimeQuantumsInSecond;
  sec = (unsigned)(v64 % 60);
  v64 /= 60;
  min = (unsigned)(v64 % 60);
  v64 /= 60;
  hour = (unsigned)(v64 % 24);
  v64 /= 24;

  v = (UInt32)v64;

  year = (unsigned)(kFileTimeStartYear + v / PERIOD_400 * 400);
  v %= PERIOD_400;

  temp = (unsigned)(v / PERIOD_100);
  if (temp == 4)
    temp = 3;
  year += temp * 100;
  v -= temp * PERIOD_100;

  temp = v / PERIOD_4;
  if (temp == 25)
    temp = 24;
  year += temp * 4;
  v -= temp * PERIOD_4;

  temp = v / 365;
  if (temp == 4)
    temp = 3;
  year += temp;
  v -= temp * 365;

  if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))
    ms[1] = 29;
  for (mon = 1; mon <= 12; mon++)
  {
    unsigned s = ms[mon - 1];
    if (v < s)
      break;
    v -= s;
  }
  day = (unsigned)v + 1;

  dosTime = kLowDosTime;
  if (year < kDosTimeStartYear)
    return false;
  year -= kDosTimeStartYear;
  dosTime = kHighDosTime;
  if (year >= 128)
    return false;
  dosTime = (year << 25) | (mon << 21) | (day << 16) | (hour << 11) | (min << 5) | (sec >> 1);
  #endif
  return true;
}

void UnixTimeToFileTime(UInt32 unixTime, FILETIME &ft) throw()
{
  UInt64 v = (kUnixTimeOffset + (UInt64)unixTime) * kNumTimeQuantumsInSecond;
  ft.dwLowDateTime = (DWORD)v;
  ft.dwHighDateTime = (DWORD)(v >> 32);
}

bool UnixTime64ToFileTime(Int64 unixTime, FILETIME &ft) throw()
{
  if (unixTime > kNumSecondsInFileTime - kUnixTimeOffset)
  {
    ft.dwLowDateTime = ft.dwHighDateTime = (UInt32)(Int32)-1;
    return false;
  }
  Int64 v = (Int64)kUnixTimeOffset + unixTime;
  if (v < 0)
  {
    ft.dwLowDateTime = ft.dwHighDateTime = 0;
    return false;
  }
  UInt64 v2 = (UInt64)v * kNumTimeQuantumsInSecond;
  ft.dwLowDateTime = (DWORD)v2;
  ft.dwHighDateTime = (DWORD)(v2 >> 32);
  return true;
}

Int64 FileTimeToUnixTime64(const FILETIME &ft) throw()
{
  UInt64 winTime = (((UInt64)ft.dwHighDateTime) << 32) + ft.dwLowDateTime;
  return (Int64)(winTime / kNumTimeQuantumsInSecond) - kUnixTimeOffset;
}

bool FileTimeToUnixTime(const FILETIME &ft, UInt32 &unixTime) throw()
{
  UInt64 winTime = (((UInt64)ft.dwHighDateTime) << 32) + ft.dwLowDateTime;
  winTime /= kNumTimeQuantumsInSecond;
  if (winTime < kUnixTimeOffset)
  {
    unixTime = 0;
    return false;
  }
  winTime -= kUnixTimeOffset;
  if (winTime > 0xFFFFFFFF)
  {
    unixTime = 0xFFFFFFFF;
    return false;
  }
  unixTime = (UInt32)winTime;
  return true;
}

bool GetSecondsSince1601(unsigned year, unsigned month, unsigned day,
  unsigned hour, unsigned min, unsigned sec, UInt64 &resSeconds) throw()
{
  resSeconds = 0;
  if (year < kFileTimeStartYear || year >= 10000 || month < 1 || month > 12 ||
      day < 1 || day > 31 || hour > 23 || min > 59 || sec > 59)
    return false;
  UInt32 numYears = year - kFileTimeStartYear;
  UInt32 numDays = numYears * 365 + numYears / 4 - numYears / 100 + numYears / 400;
  Byte ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
  if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))
    ms[1] = 29;
  month--;
  for (unsigned i = 0; i < month; i++)
    numDays += ms[i];
  numDays += day - 1;
  resSeconds = ((UInt64)(numDays * 24 + hour) * 60 + min) * 60 + sec;
  return true;
}

void GetCurUtcFileTime(FILETIME &ft) throw()
{
  // Both variants provide same low resolution on WinXP: about 15 ms.
  // But GetSystemTimeAsFileTime is much faster.

  #ifdef UNDER_CE
  SYSTEMTIME st;
  GetSystemTime(&st);
  SystemTimeToFileTime(&st, &ft);
  #else
  GetSystemTimeAsFileTime(&ft);
  #endif
}

}}
// Windows/TimeUtils.h

#ifndef __WINDOWS_TIME_UTILS_H
#define __WINDOWS_TIME_UTILS_H

#include "../Common/MyTypes.h"
#include "../Common/MyWindows.h"

namespace NWindows {
namespace NTime {

bool DosTimeToFileTime(UInt32 dosTime, FILETIME &fileTime) throw();
bool FileTimeToDosTime(const FILETIME &fileTime, UInt32 &dosTime) throw();
void UnixTimeToFileTime(UInt32 unixTime, FILETIME &fileTime) throw();
bool UnixTime64ToFileTime(Int64 unixTime, FILETIME &fileTime) throw();
bool FileTimeToUnixTime(const FILETIME &fileTime, UInt32 &unixTime) throw();
Int64 FileTimeToUnixTime64(const FILETIME &ft) throw();
bool GetSecondsSince1601(unsigned year, unsigned month, unsigned day,
  unsigned hour, unsigned min, unsigned sec, UInt64 &resSeconds) throw();
void GetCurUtcFileTime(FILETIME &ft) throw();

}}

#endif
// Windows/Window.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
 
#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif  

#undef _WIN32
 
#ifndef _UNICODE
#include "Common/StringConvert.h"
#endif
#include "Windows/Window.h"

void verify_main_thread(void);

class LockGUI
{
	bool _IsMain;
	public:
		LockGUI() {
			verify_main_thread();
			
			_IsMain = wxThread::IsMain();
			if (!_IsMain) {
				printf("LockGUI-Windows\n");
				abort(); // FIXME wxMutexGuiEnter();
			}
	       	}
		~LockGUI() { if (!_IsMain) wxMutexGuiLeave(); }
};

namespace NWindows {

HWND GetDlgItem(HWND dialogWindow, int ControlID)
{
	LockGUI lock;
	if (dialogWindow) return dialogWindow->FindWindow(ControlID);
	return 0;
}

void MySetWindowText(HWND wnd, LPCWSTR s)
{ 
	if (wnd == 0) return;

	LockGUI lock;

	wxString str = s;
	/*
	int id = wnd->GetId();
	if (  (id != wxID_OK) && (id != wxID_CANCEL) && (id != wxID_HELP) && (id != wxID_YES) && (id != wxID_NO))
	*/
	{
		wnd->SetLabel(str);
	}
}

	bool CWindow::GetText(CSysString &s)
	{
	  	wxString str;
		{
			LockGUI lock;
	  		str = _window->GetLabel();
		}
	  	s = str;
	  	return true;
	}

	bool CWindow::IsEnabled()
	{
		LockGUI lock;
		return _window->IsEnabled();
	}
}

////////////////////////////////// Windows Compatibility
#include <sys/resource.h>

void Sleep(unsigned millisec)
{
	wxMilliSleep(millisec);
}

t_processID GetCurrentProcess(void)  {
	return getpid();
}

void SetPriorityClass(t_processID pid , int priority) {
	setpriority(PRIO_PROCESS,pid,priority);
}

// Windows/Window.h

#ifndef __WINDOWS_WINDOW_H
#define __WINDOWS_WINDOW_H

#include "Windows/Defs.h"
#include "Common/MyString.h"

namespace NWindows {

HWND GetDlgItem(HWND dialogWindow, int ControlID);
void    MySetWindowText(HWND wnd, LPCWSTR s);

class CWindow
{
private:
   // bool ModifyStyleBase(int styleOffset, DWORD remove, DWORD add, UINT flags);
protected:
  HWND _window;
public:
  CWindow(HWND newWindow = NULL): _window(newWindow){};
  CWindow& operator=(HWND newWindow)
  {
    _window = newWindow;
    return *this;
  }
  operator HWND() const { return _window; }
  void Attach(HWND newWindow) { _window = newWindow; }
  HWND Detach()
  {
    HWND window = _window;
    _window = NULL;
    return window;
  }
  virtual void SetText(LPCWSTR s) { MySetWindowText(_window, s); }
  virtual bool GetText(CSysString &s);
  bool IsEnabled();
};

}

#endif

// Windows/Control/ComboBox.h

#ifndef __WINDOWS_WX_CONTROL_COMBOBOX_H
#define __WINDOWS_WX_CONTROL_COMBOBOX_H

#include "Windows/Window.h"
#include "Windows/Defs.h"


#include "Windows/Control/Window2.h" // NMHDR

#ifndef _WIN32
#define CB_ERR (-1)  // wxNOT_FOUND
#endif

typedef struct
{
	NMHDR hdr;
#define CBENF_ESCAPE 1
#define CBENF_RETURN 2
	int iWhy;
} NMCBEENDEDITW;

typedef NMCBEENDEDITW * PNMCBEENDEDITW;


class wxComboBox;

namespace NWindows {
	namespace NControl {

		class CComboBox // : public CWindow
		{
			wxComboBox* _choice;
		public:
			CComboBox() : _choice(0) {}

			void Attach(wxWindow * newWindow);
			wxWindow * Detach();
			operator HWND() const;

			int AddString(const TCHAR * txt);

			void SetText(LPCTSTR s);

			void GetText(CSysString &s);

			int GetCount() const ;
			void GetLBText(int index, CSysString &s);

			void SetCurSel(int index);
			int GetCurSel();

			void SetItemData(int index, int val);

			LRESULT GetItemData(int index);

			LRESULT GetItemData_of_CurSel() { return GetItemData(GetCurSel()); }

			void Enable(bool state);

			void ResetContent();
		};

		class CComboBoxEx : public CComboBox // : public CWindow
		{
		public:
			/* FIXME
  			LRESULT DeleteItem(int index)
    			{ return SendMessage(CBEM_DELETEITEM, index, 0); }
  			LRESULT InsertItem(COMBOBOXEXITEM *item)
    			{ return SendMessage(CBEM_INSERTITEM, 0, (LPARAM)item); }
  			DWORD SetExtendedStyle(DWORD exMask, DWORD exStyle)
    			{ return (DWORD)SendMessage(CBEM_SETEXTENDEDSTYLE, exMask, exStyle); }
  			HWND GetEditControl()
    			{ return (HWND)SendMessage(CBEM_GETEDITCONTROL, 0, 0); }
			*/
		};


	}
}

#endif // __WINDOWS_WX_CONTROL_COMBOBOX_H
// Dialog.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
    #include "wx/imaglist.h"
    #include "wx/listctrl.h"
#endif

#undef _WIN32

#include "Windows/Control/Dialog.h"

void verify_main_thread(void);

class LockGUI
{
    bool _IsMain;
    public:
        LockGUI() {
            verify_main_thread();
            _IsMain = wxThread::IsMain();
            if (!_IsMain) {
                // DEBUG
                printf("GuiEnter-Controls(0x%lx)\n",wxThread::GetCurrentId());
                abort(); // FIXME wxMutexGuiEnter();
            }
            }
        ~LockGUI() {
            if (!_IsMain) {
                wxMutexGuiLeave();
                // DEBUG printf("GuiLeave(0x%lx)\n",wxThread::GetCurrentId());
            }
            }
};
/////////////////////////

static const wxString CLASS_NAME_wxStaticText = wxT("wxStaticText");
static const wxString CLASS_NAME_wxTextCtrl = wxT("wxTextCtrl");

namespace NWindows {
    namespace NControl {

        void CDialogChildControl::SetText(LPCWSTR s)
        {
            LockGUI lock;
            const wxChar * class_name = _window->GetClassInfo()->GetClassName ();

            if ( CLASS_NAME_wxStaticText == class_name) {
                ((wxStaticText *)_window)->SetLabel(s);
            } else if ( CLASS_NAME_wxTextCtrl == class_name) {
                ((wxTextCtrl *)_window)->SetLabel(s);
            } else {
                // ((wxControl *)_window)->SetValue(s); // FIXME
                printf("INTERNAL ERROR - CDialogChildControl::SetText(class=%ls) not implemented\n",class_name);
                exit(-1);
            }
        }

        bool CDialogChildControl::GetText(CSysString &s)
        {
            wxString str;
            {
                LockGUI lock;
                const wxChar * class_name = _window->GetClassInfo()->GetClassName ();
                if ( CLASS_NAME_wxStaticText == class_name) {
                    str = ((wxStaticText *)_window)->GetLabel();
                } else if ( CLASS_NAME_wxTextCtrl == class_name) {
                    str = ((wxTextCtrl *)_window)->GetLabel();
                } else {
                    // FIXME str = ((wxTextCtrl *)_window)->GetValue();
                    printf("INTERNAL ERROR - CDialogChildControl::GetText(class=%ls) not implemented\n",class_name);
                    exit(-1);
                }
            }
            s = str;
            return true;
        }
    }
}

///////////////////////// Windows/Control/ComboBox.cpp
#include "Windows/Control/ComboBox.h"

namespace NWindows {
    namespace NControl {

        void CComboBox::Attach(wxWindow * newWindow) { _choice = (wxComboBox*)newWindow; }

        wxWindow * CComboBox::Detach()
        {
            wxWindow * window = _choice;
            _choice = NULL;
            return window;
        }

        CComboBox::operator HWND() const { return (HWND)_choice; }


            int CComboBox::AddString(const TCHAR * txt) {
                LockGUI lock;
                wxString item(txt);
                return _choice->Append(item);
            }

            void CComboBox::SetText(LPCTSTR s) {
                LockGUI lock;
                wxString str(s);
                _choice->SetValue(str);
            }

            void CComboBox::GetText(CSysString &s) {
                LockGUI lock;
                wxString str = _choice->GetValue();
                s = str;
            }

            int CComboBox::GetCount() const  {
                LockGUI lock;
                    return _choice->GetCount();
            }

            void CComboBox::GetLBText(int index, CSysString &s) {
                LockGUI lock;
                wxString str = _choice->GetString(index);
                s = str;
            }

            void CComboBox::SetCurSel(int index) {
                LockGUI lock;
                    _choice->SetSelection(index);
            }

            int CComboBox::GetCurSel() {
                LockGUI lock;
                    return _choice->GetSelection();
            }

            void CComboBox::SetItemData(int index, int val) {
                LockGUI lock;
                    _choice->SetClientData( index, (void *)(((char *)0) + val));
                }

            LRESULT CComboBox::GetItemData(int index)
            {
                LockGUI lock;
                void * data = _choice->GetClientData(index);
                LRESULT ret = (LRESULT)(((char *)data) - ((char *)0));
                return ret;
            }

            void CComboBox::Enable(bool state) {
                LockGUI lock;
                    _choice->Enable(state);
            }

            void CComboBox::ResetContent() {
                LockGUI lock;
                   _choice->Clear();
                }
    }
}

///////////////////////// Windows/Control/Edit.cpp
#include "Windows/Control/Edit.h"

namespace NWindows {
    namespace NControl {

        void CEdit::SetPasswordChar(WPARAM c)  // Warning : does not work for wxMSW
        {
                LockGUI lock;
            long style = _window->GetWindowStyle();
            if ( c == 0 ) style &= ~(wxTE_PASSWORD);
            else          style |= wxTE_PASSWORD;
            _window->SetWindowStyle(style);
            _window->Refresh();
        }


        void CEdit::Show(int cmdShow)
        {
                LockGUI lock;
            // FIXME    _window->Show(cmdShow != SW_HIDE);
            _window->Enable(cmdShow != SW_HIDE);
        }

        void CEdit::SetText(LPCWSTR s)
        {
            LockGUI lock;
            ((wxTextCtrl *)_window)->SetValue(s);
        }

        bool CEdit::GetText(CSysString &s)
        {
            wxString str;
            {
                LockGUI lock;
                str = ((wxTextCtrl *)_window)->GetValue();
            }
            s = str;
            return true;
        }

    }
}

///////////////////////// Windows/Control/ProgressBar.cpp
#include "Windows/Control/ProgressBar.h"

namespace NWindows {
    namespace NControl {

        CProgressBar::CProgressBar(wxWindow* newWindow):
                _window((wxGauge *)newWindow) , _minValue(0), _range(0) { }

    void CProgressBar::Attach(wxWindow* newWindow) {
        _window = (wxGauge *)newWindow;
        _minValue = 0;
        _range = 0;
    }

    void CProgressBar::SetRange32(int minValue, int maxValue) {
        int range = maxValue - minValue;
        if (range >= 1)
        {
                LockGUI lock;
            _minValue = minValue;
            _range    = range;
            _window->SetRange(_range);
        }
    }

    void CProgressBar::SetPos(int pos) {
        if (_range >= 1)
        {
                LockGUI lock;
            int value = pos - _minValue;
            if ((value >= 0) && (value <= _range)) _window->SetValue(value);
        }
    }

    }
}

///////////////////////// Windows/Control/StatusBar.cpp
#include "Windows/Control/StatusBar.h"

namespace NWindows {
    namespace NControl {

        void CStatusBar::Attach(wxWindow * newWindow) { _statusBar = (wxStatusBar*)newWindow; }

        wxWindow * CStatusBar::Detach()
        {
            wxWindow * window = _statusBar;
            _statusBar = NULL;
            return window;
        }

        void CStatusBar::SetText(int index, LPCTSTR text)
        {
            _statusBar->SetStatusText(text,index);
        }

    }

}

///////////////////////// Windows/Control/ListView.cpp
#include "Windows/Control/ListView.h"

namespace NWindows {
namespace NControl {

    void CListView::Attach(wxWindow * newWindow) {
        _list = (wxListCtrl *)newWindow;
    }

    CListView::operator HWND() const { return (HWND)_list; }

    int CListView::GetItemCount() const {return  _list->GetItemCount(); }

    int CListView::InsertItem(int index, LPCTSTR text) {
        return _list->InsertItem(index, text);
    }
    int CListView::InsertItem(const LVITEM* item) {
        /*
        int col = item->iSubItem;
        wxString text;
        if (item->mask & LVIF_TEXT) text = item->pszText;

        // printf("%p->InsertItem(id=%d,%ls)\n",_list,item->iItem, (const wchar_t *)text);
        return _list->InsertItem(item->iItem, text);
        */
        wxListItem info;
        long mask = 0;
        info.SetId(item->iItem);
        if (item->mask & LVIF_TEXT)
        {
            info.SetText(item->pszText);
            mask |= wxLIST_MASK_TEXT;
        }
        if (item->mask & LVIF_PARAM)
        {
            info.SetData(item->lParam);
            mask |= wxLIST_MASK_DATA;
        }
        if (item->mask & LVIF_STATE)
        {
            info.SetState(item->state);
            mask |= wxLIST_MASK_STATE;
        }
        // FIXME if (item->mask & LVIF_IMAGE)

        info.SetMask(mask);

        return _list->InsertItem(info);
    }

    void CListView::SetItem(const LVITEM* item)  {
        int col = item->iSubItem;
        wxString text;
        if (item->mask & LVIF_TEXT) text = item->pszText;
        // printf("%p->SetItem(id=%d,col=%d,%ls)\n",_list,item->iItem, col,(const wchar_t *)text);
        _list->SetItem(item->iItem, col, text);
    }

    int CListView::SetSubItem(int index, int subIndex, LPCTSTR text)
    {
        return _list->SetItem(index, subIndex, text);
    }

    void SetUnicodeFormat(bool fUnicode) { return ;  }

    void CListView::_InsertColumn(int columnIndex, LPCTSTR text, int format, int width)
    {
        _list->InsertColumn(columnIndex, text, format, width);
    }

    void CListView::InsertColumn(int columnIndex, LPCTSTR text, int width)
    {
          this->_InsertColumn(columnIndex, text, wxLIST_FORMAT_LEFT, width);
    }

    void CListView::InsertColumn(int columnIndex, const LVCOLUMNW *columnInfo)
    {
          wxString text;
          int format = wxLIST_FORMAT_LEFT;
          int width = -1;
          if (columnInfo->mask & LVCF_FMT)
          {
              if (columnInfo->fmt == LVCFMT_LEFT) format = wxLIST_FORMAT_LEFT;
              if (columnInfo->fmt == LVCFMT_RIGHT) format = wxLIST_FORMAT_RIGHT;
          }
          if (columnInfo->mask & LVCF_TEXT)  text = columnInfo->pszText;
          if (columnInfo->mask & LVCF_WIDTH) width   = columnInfo->cx;
          // FIXME LVCF_SUBITEM
        // printf("%p->InsertColumn(%d,%ls)\n",_list,columnIndex,(const wchar_t *)heading);
          // _list->InsertColumn(columnIndex, text, format, width);
          this->_InsertColumn(columnIndex, text, format, width);
      }

      void CListView::DeleteAllItems() {
          _list->DeleteAllItems();
          printf("%p->DeleteAllItems()\n",_list);
      }

    void CListView::SetRedraw(bool b) {
        if (b) _list->Thaw();
        else   _list->Freeze();
        printf(" %p->SetRedraw()\n",_list);
    }

    void CListView::SetItemCount(int count) {
        // ONLY IF VIRTUAL REPORT -- _list->SetItemCount(count);
        printf(" %p->SetItemCount(%d)\n",_list,count);
    }

      void CListView::InvalidateRect(void *, bool)  {
          printf("FIXME %p->InvalidateRect()\n",_list);/* FIXME */
      }

      int CListView::GetSelectedCount() const {
          int nb = _list->GetSelectedItemCount();
          printf(" %p->GetSelectedCount()=>%d\n",_list,nb);
          return nb;
      }

    void /* bool */ CListView::EnsureVisible(int index, bool partialOK) {

        printf(" %p->EnsureVisible(%d)\n",_list,index);

        if (index == -1) index = 0;
        _list->EnsureVisible(index);

        // return true;
    }

    void CListView::SetItemState(int index, UINT state, UINT mask) {
        // don't work  _list->SetItemState(index, state, mask); !?
        // try SetItem ...
        /*
        wxListItem info;

        info.m_mask   = wxLIST_MASK_STATE;
        info.m_itemId = index;
        info.m_col    = 0;
        info.m_state  = state;
        info.m_mask   = mask;

        _list->SetItem(info);
        */

        printf(" %p->SetItemState(%d,0x%x,0x%x)\n",_list,index,state,mask);

        if (index == -1) return;

        _list->SetItemState(index, state & (LVIS_SELECTED|LVIS_SELECTED), mask & (LVIS_SELECTED|LVIS_SELECTED));

/*
        if (mask & LVIS_FOCUSED) {
            printf(" %p->SetItemState(%d) => FOCUSED\n",_list,index);
            _list->SetItemState(index, state & LVIS_FOCUSED, mask & LVIS_FOCUSED);
        }

        if (mask & LVIS_SELECTED) {
            printf(" %p->SetItemState(%d) => SELECTED\n",_list,index);
            _list->SetItemState(index, state & LVIS_SELECTED, mask & LVIS_SELECTED);
        }
*/
      }

      UINT CListView::GetItemState(int index, UINT mask) const
      {
        UINT state = _list->GetItemState(index, mask);
        printf("FIXME %p->GetItemState(index=%d,mask=0x%x)=0x%x\n",_list,index,(unsigned)mask,(unsigned)state); /* FIXME */

        return state;
      }

      void /* bool */  CListView::Update() {
          printf("FIXME %p->Update()\n",_list); /* FIXME */
      }

      bool CListView::DeleteColumn(int columnIndex) {
          // printf("%p->DeleteColumn()\n",_list);
          if (_list->GetColumnCount() < 1) return false;
          return _list->DeleteColumn(columnIndex); // always return true !?
      }

      bool CListView::GetItemParam(int itemIndex, LPARAM &param) const
      {
        param = _list->GetItemData(itemIndex);

        // printf(" %p->GetItemParam(%d) => %ld\n",_list,itemIndex,(long)param);

        return true;
      }

      int CListView::GetNextItem(int startIndex, UINT flags) const
          {
        int item = _list->GetNextItem(startIndex, wxLIST_NEXT_ALL, flags);
        printf(" %p->GetNextItem(%d) => %d\n",_list,startIndex,item);
        return item;

      }

    int CListView::GetFocusedItem() const
    {
        int item = _list->GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_FOCUSED);
        printf(" %p->GetFocusedItem() => %d\n",_list,item);
        return item;
    }

      void CListView::RedrawAllItems()
      {
        printf("FIXME %p->RedrawAllItems()\n",_list);
      }

      // FIXME added
      int CListView::GetColumnCount()
      {
        return _list->GetColumnCount();
      }

      void CListView::SetFocus() { /* FIXME */ }

      void CListView::RedrawItem(int item) { /* FIXME */ }

    bool CListView::SortItems(PFNLVCOMPARE compareFunction, LPARAM dataParam) {
        printf(" %p->SortItems()\n",_list);
        return _list->SortItems(compareFunction, dataParam);
    }

    bool CListView::GetColumn(int columnIndex, LVCOLUMN* columnInfo)
    {
        columnInfo->cx = _list->GetColumnWidth(columnIndex);// FIXME

        bool ret = false;

        if (columnInfo->cx >= 1) ret = true;

        // printf("CListView::GetColumn(%d) cx=%d\n",columnIndex,(int)columnInfo->cx);

        return ret;
    }

    // HWND EditLabel(int itemIndex)
    void CListView::EditLabel(int itemIndex)
    {
        /* FIXME */
    }


    LRESULT CListView2::OnMessage(UINT message, WPARAM wParam, LPARAM lParam)
    {
        return 0; // FIXME return CallWindowProc(_origWindowProc, *this, message, wParam, lParam);
    }


}}

// Dialog.cpp

#include "StdAfx.h"

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWidgets headers)
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif 

#include  <wx/filename.h>


#undef _WIN32
 
#include "Windows/Control/DialogImpl.h"
#include "Windows/Synchronization.h"

// FIXME
class MyApp : public wxApp
{
public:
    virtual bool OnInit();
};

DECLARE_APP(MyApp)

// #include "../GUI/p7zip_32.xpm"
extern const char * p7zip_32_xpm[];

const TCHAR * nameWindowToUnix(const TCHAR * lpFileName) {
  if ((lpFileName[0] == wxT('c')) && (lpFileName[1] == wxT(':'))) return lpFileName+2;
  return lpFileName;
}


extern time_t g_T0; // FIXME

#define DIALOG_ID_MESSAGEBOX  8100
#define DIALOG_ID_DIR_DIALOG  8101
#define DIALOG_ID_FILE_DIALOG 8102
#define DIALOG_ID_POST_DIALOG 8190
#define DIALOG_ID_END_DIALOG  8199

static struct
{
	bool busy;

	int id;
	wxWindow *parentWindow;

	// CreateDialog
	NWindows::NControl::CModalDialog * dialog;

	// EndModal
	int value;
	NWindows::NControl::CModalDialogImpl * window;

	// MessageBox
	const TCHAR * msg;
	const TCHAR * title;
	int flag;

	// 
	LPCWSTR initialFolderOrFile;

	wxSemaphore * sem;
	int ret;

	UString resultPath;
	
#define MAX_CREATE 16
} g_tabCreate[MAX_CREATE];

static int myCreateHandle2(int n);

static int findFreeInd()
{
static NWindows::NSynchronization::CCriticalSection g_CriticalSection;

	g_CriticalSection.Enter();
	int ind = 0;
	while (ind < MAX_CREATE)
	{
		if (g_tabCreate[ind].busy == false)
		{
			g_tabCreate[ind].busy = true;
			break;
		}
		ind++;
	}
	g_CriticalSection.Leave();

	return ind;
}

static int WaitInd(wxWindow * destWindow, int ind,int id,wxWindow * parent,UString &resultPath)
{
	int ret = 0;

	g_tabCreate[ind].id           = id;
	g_tabCreate[ind].parentWindow = parent;
	g_tabCreate[ind].ret          = 0;
	g_tabCreate[ind].resultPath   = wxEmptyString;

	if (wxThread::IsMain())
	{
		ret = myCreateHandle2(ind);
		resultPath = g_tabCreate[ind].resultPath;
	}
	else
	{
		if (destWindow == 0) {
			extern wxWindow * g_window;
        		if (g_window == 0)
			{
				printf("INTERNAL ERROR : g_window and destWindow == NULL\n"); abort();
			}
			destWindow = g_window;
		}
		g_tabCreate[ind].sem = new wxSemaphore(0);

		// create any type of command event here
		wxCommandEvent event( wxEVT_COMMAND_MENU_SELECTED, WORKER_EVENT );
		event.SetInt( ind );

		// send in a thread-safe way
		// DEBUG printf("T=0x%lx - %d : WaitInd(%d,%p): BEGIN\n", wxThread::GetCurrentId(),time(0)-g_T0,g_tabCreate[ind].id,g_tabCreate[ind].parentWindow);
		wxPostEvent( destWindow, event );

		g_tabCreate[ind].sem->Wait();

		ret = g_tabCreate[ind].ret;
		resultPath = g_tabCreate[ind].resultPath;
		// DEBUG printf("T=0x%lx - %d : WaitInd(%d,%p): ret=%d\n", wxThread::GetCurrentId(),time(0)-g_T0,g_tabCreate[ind].id,g_tabCreate[ind].parentWindow,ret);
		delete g_tabCreate[ind].sem;
		g_tabCreate[ind].sem = 0;
	}

	g_tabCreate[ind].busy = false;

	return ret;
}

static int WaitInd(wxWindow * destWindow,int ind,int id,wxWindow * parent)
{
	UString resultPath;
	return WaitInd(destWindow,ind,id,parent,resultPath);
}

void verify_main_thread(void);

class LockGUI
{
	bool _IsMain;
	public:
		LockGUI() {
			
			verify_main_thread();
			
			_IsMain = wxThread::IsMain();
			if (!_IsMain) {
				// DEBUG
				printf("GuiEnter-Dialog(0x%lx)\n",wxThread::GetCurrentId());
				abort(); // FIXME wxMutexGuiEnter();
			}
	       	}
		~LockGUI() { 
			if (!_IsMain) {
				wxMutexGuiLeave();
				// DEBUG printf("GuiLeave(0x%lx)\n",wxThread::GetCurrentId());
			}
	       	}
};

static const unsigned int kNumDialogsMax = 32;
static unsigned int g_NumDialogs = 0;
static const CDialogInfo *g_Dialogs[kNumDialogsMax]; 

void RegisterDialog(const CDialogInfo *dialogInfo) 
{ 
  // DEBUG printf("RegisterDialog : %d\n",dialogInfo->id);
  if (g_NumDialogs < kNumDialogsMax)
    g_Dialogs[g_NumDialogs++] = dialogInfo; 
}

namespace NWindows {

	UString MyLoadString(UINT resourceID)
	{
		for(unsigned i=0; i < g_NumDialogs; i++) {
			if (g_Dialogs[i]->stringTable) {
				int j = 0;
				while(g_Dialogs[i]->stringTable[j].str) {
					if (resourceID == g_Dialogs[i]->stringTable[j].id) {
						return g_Dialogs[i]->stringTable[j].str;
					}

					j++;
				}
			}
		}
		printf("MyLoadString(resourceID=%u) : NOT FOUND\n",(unsigned)resourceID);
		return L"FIXME-MyLoadStringW-";
	}

	void MyLoadString(UINT resourceID, UString &dest)
	{
		dest = MyLoadString(resourceID);
	}

	namespace NControl {

/////////////////////////////////////////// CModalDialog //////////////////////////////////

			bool CModalDialog::CheckButton(int buttonID, UINT checkState)
			{
				LockGUI lock;
				wxCheckBox* w = (wxCheckBox*)_window->FindWindow(buttonID);
				if (w)
				{
					w->SetValue(checkState == BST_CHECKED);
					return true;
				}
				return false;
			}

			UINT CModalDialog::IsButtonChecked(int buttonID) const
			{ 
				LockGUI lock;
				wxCheckBox* w = (wxCheckBox*)_window->FindWindow(buttonID);
				if (w)
				{
					bool bret = w->GetValue();
					if (bret) return BST_CHECKED;
				}
				return BST_UNCHECKED;
			}

			void CModalDialog::EnableItem(int id, bool state)
			{
				LockGUI lock;
				wxWindow* w = _window->FindWindow(id);
				if (w) w->Enable(state);
			}

			void CModalDialog::SetItemText(int id, const TCHAR *txt)
			{
				LockGUI lock;
				wxWindow* w = _window->FindWindow(id);
				if (w)
				{
					wxString label(txt);
					w->SetLabel(label);
				}
			}

			wxWindow * CModalDialog::GetItem(long id) const
			{
				LockGUI lock;
				wxWindow * w = _window->FindWindow(id);
				if (w == 0) printf("@@WARNING :GetItem(%ld)=NULL\n",id);
				return w;
			}

			void CModalDialog::ShowItem(int itemID, int cmdShow) const
			{
				LockGUI lock;
				// cmdShow = SW_HIDE or SW_SHOW (sometimes false or true !)
				wxWindow* w = _window->FindWindow(itemID);
				if (w)
				{
// FIXME					w->Show(cmdShow != SW_HIDE);
					w->Enable(cmdShow != SW_HIDE);
				}
			}

			UINT_PTR CModalDialog::SetTimer(UINT_PTR idEvent , unsigned milliseconds)
			{
				LockGUI lock;
				return _window->SetTimer(idEvent , milliseconds);
			}

			void CModalDialog::KillTimer(UINT_PTR idEvent)
			{
				LockGUI lock;
				_window->KillTimer(idEvent);
			}

			void CModalDialog::SetText(const TCHAR *_title) {
				LockGUI lock;
			      	_window->SetTitle(_title);
		       	}


			bool CModalDialog::GetText(CSysString &s) {
				wxString str;
				{
					LockGUI lock;
	  				str = _window->GetTitle();
				}
	  			s = str;
	  			return true;
		       	}

			INT_PTR CModalDialog::Create(int id , HWND parentWindow)
			{
				int ind = findFreeInd();

				g_tabCreate[ind].dialog = this;

				return WaitInd(0,  ind,id,parentWindow);
			}

			void CModalDialog::End(int result)
			{ 
				int ind = findFreeInd();

				g_tabCreate[ind].window  = _window;
				g_tabCreate[ind].value   = result;

				WaitInd(this->_window,ind,DIALOG_ID_END_DIALOG,0);
			}

			void CModalDialog::PostMsg(UINT message)
			{
				int ind = findFreeInd();

				g_tabCreate[ind].dialog  = this;
				g_tabCreate[ind].value   = message;

				WaitInd(this->_window,ind,DIALOG_ID_POST_DIALOG,0);
			}

/////////////////////////////////////////// CModalDialogImpl ///////////////////////////////////////

			CModalDialogImpl::CModalDialogImpl(CDialog *dialog, wxWindow* parent, wxWindowID id, 
					 const wxString& title, const wxPoint& pos,
					 const wxSize& size, long style) :
			   		wxDialog(parent, id, title , pos , size, style /* | wxDIALOG_NO_PARENT */ ) ,
				       	_timer(this, TIMER_ID_IMPL), _dialog(dialog)
			{
				// set the frame icon
				this->SetIcon(wxICON(p7zip_32));
			}

			void CModalDialogImpl::OnAnyButton(wxCommandEvent& event)
			{
				int id = event.GetId();
				if (id == wxID_OK)
				{
					if (_dialog) _dialog->OnOK();
					// event.Skip(true);
				}
				else if (id == wxID_CANCEL)
				{
					if (_dialog) _dialog->OnCancel();
					// event.Skip(true);
				}
				else if (id == wxID_HELP)
				{
					if (_dialog) _dialog->OnHelp();
				}
				else
				{
					if (_dialog)
					{
						/* bool bret = */ _dialog->OnButtonClicked(id, FindWindow(id) );
					}
				}
			}

			void CModalDialogImpl::OnAnyChoice(wxCommandEvent &event)
			{
				int itemID =  event.GetId();
				if (_dialog) _dialog->OnCommand(CBN_SELCHANGE, itemID, 0);
			}

			void CModalDialogImpl::OnAnyTimer(wxTimerEvent &event)
			{
				int timerID =  event.GetId();
				if (_dialog) _dialog->OnTimer(timerID , 0);
			}
	}
}

///////////////////////// myCreateHandle


static int myCreateHandle2(int n)
{ 
	unsigned int                           id           = g_tabCreate[n].id;
	wxWindow *                             parentWindow = g_tabCreate[n].parentWindow;
	NWindows::NControl::CModalDialogImpl * window       = 0;

	// DEBUG printf("T=0x%lx - %d : myCreateHandle(%d): BEGIN\n", wxThread::GetCurrentId(),time(0)-g_T0,n);

	if (id == DIALOG_ID_END_DIALOG)
	{
		/* FIXME : the dialog must be shown before ending it ?
		while (!g_tabCreate[n].window->IsShownOnScreen()) Sleep(200);
		Sleep(200);
		*/
		g_tabCreate[n].window->EndModal(g_tabCreate[n].value);
		return 0;
	}

	if (id == DIALOG_ID_POST_DIALOG)
	{
		g_tabCreate[n].dialog->OnMessage(g_tabCreate[n].value, 0, 0);
		return 0;
	}

	if (id == DIALOG_ID_MESSAGEBOX)
	{
		long style = g_tabCreate[n].flag;
		long decorated_style = style;
		if ( ( style & ( wxICON_EXCLAMATION | wxICON_HAND | wxICON_INFORMATION |
				wxICON_QUESTION ) ) == 0 )
		{
			decorated_style |= ( style & wxYES ) ? wxICON_QUESTION : wxICON_INFORMATION ;
		}
		wxMessageDialog dialog(parentWindow, g_tabCreate[n].msg, g_tabCreate[n].title, decorated_style);
		// FIXME dialog.SetIcon(wxICON(p7zip_32));
		int ret = dialog.ShowModal();

		return ret;
	}

	if (id == DIALOG_ID_DIR_DIALOG)
	{
		wxString defaultDir = g_tabCreate[n].initialFolderOrFile;
		wxDirDialog dirDialog(g_tabCreate[n].parentWindow,
			       	g_tabCreate[n].title, defaultDir);
		dirDialog.SetIcon(wxICON(p7zip_32));
		int ret = dirDialog.ShowModal();
		if (ret == wxID_OK) g_tabCreate[n].resultPath = dirDialog.GetPath();
		return ret;
	}

	if (id == DIALOG_ID_FILE_DIALOG)
	{
		wxString defaultFilename = g_tabCreate[n].initialFolderOrFile;
		
		wxFileName filename(defaultFilename);
		
		wxString dir = filename.GetPath();
		wxString name = filename.GetFullName();
		
		
		// printf("DIALOG_ID_FILE_DIALOG = '%ls' => '%ls'  '%ls'\n",&defaultFilename[0],&dir[0],&name[0]);
		
		
		wxFileDialog fileDialog(g_tabCreate[n].parentWindow, g_tabCreate[n].title,
				dir, name, wxT("All Files (*.*)|*.*"), wxFD_SAVE|wxFD_OVERWRITE_PROMPT);
		fileDialog.SetIcon(wxICON(p7zip_32));
		int ret = fileDialog.ShowModal();
		if (ret == wxID_OK) g_tabCreate[n].resultPath = fileDialog.GetPath();
		return ret;
	}

	for(unsigned  i=0; i < g_NumDialogs; i++) {
		if (id == g_Dialogs[i]->id) {
			// DEBUG printf("%d : Create(%d,%p): CreateDialog-1\n",time(0)-g_T0,id,parentWindow);
			window = (g_Dialogs[i]->createDialog)(g_tabCreate[n].dialog,g_tabCreate[n].parentWindow);
			// DEBUG printf("%d : Create(%d,%p): CreateDialog-2\n",time(0)-g_T0,id,parentWindow);
			break;
		}
	}

	if (window) {

		// DEBUG printf("%d : Create(%d,%p): %p->ShowModal()\n",time(0)-g_T0,id,parentWindow,window);

		// window->Show(true);
		// wxGetApp().ProcessPendingEvents();

		INT_PTR ret = window->ShowModal();

		// DEBUG printf("%d : Create(%d,%p): %p->ShowModal() - ret=%d\n",time(0)-g_T0,id,parentWindow,window,ret);
		window->Detach();
		window->Destroy();

		// DEBUG printf("%d : Create(%d,%p): END\n",time(0)-g_T0,id,parentWindow,window);

		return ret;
	}

	// FIXME
	printf("INTERNAL ERROR : cannot find dialog %d\n",id);

	return 0;
}

void myCreateHandle(int n)
{
	int ret = myCreateHandle2(n);
	g_tabCreate[n].ret = ret;
	g_tabCreate[n].sem->Post();
}

int MessageBoxW(wxWindow * parent, const TCHAR * msg, const TCHAR * title,int flag)
{
	int ind = findFreeInd();

	g_tabCreate[ind].msg          = msg;
	g_tabCreate[ind].title        = title;
	g_tabCreate[ind].flag         = flag;
	
	return WaitInd(parent,ind,DIALOG_ID_MESSAGEBOX,parent); // FIXME
}



// FIXME : should be in Windows/Shell.cpp

namespace NWindows{
namespace NShell{

bool BrowseForFolder(HWND owner, LPCWSTR title, LPCWSTR initialFolder, UString &resultPath)
{
	int ind = findFreeInd();

	g_tabCreate[ind].title               = title;
	g_tabCreate[ind].initialFolderOrFile = nameWindowToUnix(initialFolder);
	
	UString resTmp;
	int ret = WaitInd(0,ind,DIALOG_ID_DIR_DIALOG,owner,resTmp); // FIXME
	if(ret == wxID_OK)
	{
		resultPath = resTmp;
		return true;
	}
	return false;
}

}}

/////////////////////////// CPP/Windows/CommonDialog.cpp
namespace NWindows
{

	// OLD bool MyGetOpenFileName(HWND hwnd, LPCWSTR title, LPCWSTR /* FIXME initialDir */ , LPCWSTR fullFileName, LPCWSTR s, UString &resPath)
	bool MyGetOpenFileName(HWND hwnd, LPCWSTR title,
		LPCWSTR /* FIXME initialDir */  ,  // can be NULL, so dir prefix in filePath will be used
		LPCWSTR filePath,    // full path
		LPCWSTR /* FIXME filterDescription */ ,  // like "All files (*.*)"
		LPCWSTR filter,             // like "*.exe"
		UString &resPath
		#ifdef UNDER_CE
		, bool openFolder = false
		#endif
		)
	{
		int ind = findFreeInd();

		g_tabCreate[ind].title               = title;
		g_tabCreate[ind].initialFolderOrFile = nameWindowToUnix(filePath);
	
		UString resTmp;
		int ret = WaitInd(0,ind,DIALOG_ID_FILE_DIALOG,hwnd,resTmp); // FIXME
		if(ret == wxID_OK)
		{
			resPath = resTmp;
			return true;
		}
		return false;
	}
}

// From CPP/7zip/UI/FileManager/BrowseDialog.cpp
bool CorrectFsPath(const UString & /* relBase */, const UString &path, UString &result)
{
  result = path;
  return true;
}

// Windows/Control/Dialog.h

#ifndef __WINDOWS_CONTROL_DIALOG_H
#define __WINDOWS_CONTROL_DIALOG_H

#include "Windows/Window.h"

#ifndef _WIN32

#define WM_SETTEXT (6000) // wxID_HIGHEST + 1
#define WM_USER    (6999) // wxID_HIGHEST + 1000
#define WM_APP     (26999) // wxID_HIGHEST + 22000

#endif

#ifndef _WIN32
#define CBN_SELCHANGE       1
#endif

#define BST_CHECKED 1
#define BST_UNCHECKED 0
// #define BST_INDETERMINATE  0x0002

// FIXME #define wsprintf(a,b,c,d,e) swprintf(a,9999,b,c,d,e)  // FIXME

namespace NWindows {
	namespace NControl {

		class CModalDialogImpl;

		class CDialog
		{
		protected:
			CModalDialogImpl * _window;
		public:
			operator HWND() const { return HWND(_window); }

			bool OnInit(CModalDialogImpl * window) { 
				_window = window;
				return OnInit();
		       	}
			virtual bool OnInit() { return false; }
			virtual void OnOK() {}
			virtual void OnCancel() {}
			virtual void OnHelp() {}
			virtual bool OnButtonClicked(int buttonID, wxWindow * buttonHWND) { return false; }
			virtual bool OnMessage(UINT message, WPARAM wParam, LPARAM lParam) { return false; }
			virtual bool OnCommand(int code, int itemID, LPARAM lParam) { return false; }
			virtual bool OnTimer(WPARAM /* timerID */, LPARAM /* callback */) { return false; }

			void NormalizeSize(bool fullNormalize = false)  { /* FIXME */ }
			void NormalizePosition() { /* FIXME */ }
		};

		class CModalDialog : public CDialog
		{
		public:


			////////////////// COMPATIBILITY

			bool CheckRadioButton(int firstButtonID, int lastButtonID, int checkButtonID)
			{
/*
				for(int id = firstButtonID; id <= lastButtonID; id++)
				{
					CheckButton(id,id == checkButtonID);
				}
*/
				this->CheckButton(checkButtonID,true);

				return true;
			}


			bool CheckButton(int buttonID, UINT checkState);
			bool CheckButton(int buttonID, bool checkState)
			{
				return CheckButton(buttonID, UINT(checkState ? BST_CHECKED : BST_UNCHECKED));
			}


			UINT IsButtonChecked(int buttonID) const;

			bool IsButtonCheckedBool(long buttonID) const
				{ return (IsButtonChecked(buttonID) == BST_CHECKED); }

			void EnableItem(int id, bool state);

			void SetItemText(int id, const TCHAR *txt);

			wxWindow * GetItem(long id) const ;

			void ShowItem(int itemID, int cmdShow) const;

			void ShowItem_Bool(int itemID, bool show) const { ShowItem(itemID, show ? SW_SHOW: SW_HIDE); }


			void HideItem(int itemID) const { ShowItem(itemID, SW_HIDE); }

			void End(int result);

			void SetText(const TCHAR *_title); // {  _dialog->SetTitle(_title); }

			bool GetText(CSysString &s);

			INT_PTR Create(int id , HWND parentWindow);

			void PostMsg(UINT message);

			virtual void OnHelp() {}

			UINT_PTR SetTimer(UINT_PTR idEvent , unsigned milliseconds);

			void KillTimer(UINT_PTR idEvent);

			virtual void OnOK() { End(IDOK); }
			virtual void OnCancel() { End(IDCANCEL); }
		};

class CDialogChildControl : public NWindows::CWindow
{
public:
  CDialogChildControl() {}

  int m_ID;
  void Init(const NWindows::NControl::CModalDialog &parentDialog, int id)
  {
    m_ID = id;
    this->Attach(parentDialog.GetItem(id));
  }
  virtual void SetText(LPCWSTR s);
  virtual bool GetText(CSysString &s);
};

}
}

struct CStringTable
{
	unsigned int id;
	const wchar_t *str;
};

struct CDialogInfo
{
	int id;
	NWindows::NControl::CModalDialogImpl * (*createDialog)(NWindows::NControl::CModalDialog * dialog, HWND parentWindow);
	CStringTable * stringTable;
};

void RegisterDialog(const CDialogInfo *dialogInfo);

#define REGISTER_DIALOG_NAME(x) CRegister ## x

#define REGISTER_DIALOG(id,x,stringTable) \
	static NWindows::NControl::CModalDialogImpl * myCreate##x(NWindows::NControl::CModalDialog * dialog,HWND parentWindow) \
	{ return new x##Impl(dialog,parentWindow,id); } \
	static struct CDialogInfo g_DialogInfo = { id , myCreate##x, stringTable }; \
	struct REGISTER_DIALOG_NAME(x) { \
		REGISTER_DIALOG_NAME(x)() { RegisterDialog(&g_DialogInfo); }}; \
	static REGISTER_DIALOG_NAME(x) g_RegisterDialog;

#define REGISTER_STRINGTABLE(stringTable) \
	static struct CDialogInfo g_DialogInfo = { -1 , 0 , stringTable }; \
	struct REGISTER_DIALOG_NAME(x) { \
		REGISTER_DIALOG_NAME(x)() { RegisterDialog(&g_DialogInfo); }}; \
	static REGISTER_DIALOG_NAME(x) g_RegisterDialog;

#endif

// Windows/Control/DialogImpl.h

#ifndef __WINDOWS_CONTROL_DIALOGIMPL_H
#define __WINDOWS_CONTROL_DIALOGIMPL_H

#include "Windows/Window.h"
#include "Windows/Control/Dialog.h"

void myCreateHandle(int n); // FIXME - duplicate

enum {
    WORKER_EVENT=100    // this one gets sent from the worker thread
};

namespace NWindows {
	namespace NControl {

#define TIMER_ID_IMPL (1234)

		class CModalDialogImpl : public wxDialog
		{
			wxTimer _timer;

			CDialog *_dialog;
		public:
			CModalDialogImpl(CDialog *dialog, wxWindow* parent, wxWindowID id, const wxString& title,
				       	const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize,
				       	long style = wxDEFAULT_DIALOG_STYLE );

			CDialog * Detach()
			{
				CDialog * oldDialog = _dialog;
				_dialog = NULL;
				return oldDialog;
			}

			void OnInit()
			{
				if (_dialog) _dialog->OnInit(this);
			}

			void OnAnyButton(wxCommandEvent& event);
			void OnAnyChoice(wxCommandEvent &event);
			void OnAnyTimer(wxTimerEvent &event);

/* FIXME			virtual void SetLabel(const wxString &title)
			{
				// Why we must do this "alias" ?
				this->SetTitle(title);
			}
*/
			//////////////////
			UINT_PTR SetTimer(UINT_PTR /* FIXME idEvent */, unsigned milliseconds)
			{
				_timer.Start(milliseconds);
				return TIMER_ID_IMPL;
			}
			void KillTimer(UINT_PTR idEvent)
			{
				if (idEvent == TIMER_ID_IMPL) _timer.Stop();
			}
			void OnWorkerEvent(wxCommandEvent& event)
			{
				int n = event.GetInt();
				// printf("CModalDialogImpl::OnWorkerEvent(n=%d)\n",n);
				myCreateHandle(n);
			}
		};
}
}

#endif

// Windows/Control/Edit.h

#ifndef __WINDOWS_CONTROL_EDIT_H
#define __WINDOWS_CONTROL_EDIT_H

#include "Windows/Window.h"
#include "Windows/Defs.h"

namespace NWindows {
namespace NControl {

class CEdit: public CWindow
{
public:
	void SetPasswordChar(WPARAM c);
	void Show(int cmdShow);
	void Show_Bool(bool show) { Show(show ? SW_SHOW: SW_HIDE); }
	virtual void SetText(LPCWSTR s);
	virtual bool GetText(CSysString &s);
};

}}

#endif

// Windows/Control/ListView.h

#ifndef __WINDOWS_CONTROL_LISTVIEW_H
#define __WINDOWS_CONTROL_LISTVIEW_H

#include "Windows/Window.h"
#include "Windows/Defs.h"

/*
#include <commctrl.h>
*/

#ifndef _WIN32

#define LVCF_FMT                0x0001
#define LVCF_WIDTH              0x0002
#define LVCF_TEXT               0x0004
#define LVCF_SUBITEM            0x0008
#define LVCF_IMAGE              0x0010
#define LVCF_ORDER              0x0020

#define LVCFMT_LEFT             0x0000
#define LVCFMT_RIGHT            0x0001
#define LVCFMT_CENTER           0x0002
#define LVCFMT_JUSTIFYMASK      0x0003


// state
#define  LVIS_FOCUSED       0x0002 /* wxLIST_STATE_FOCUSED  */
#define  LVIS_SELECTED      0x0004 /* wxLIST_STATE_SELECTED */

#define  LVNI_SELECTED      0x0004 /* wxLIST_STATE_SELECTED */

typedef INT (CALLBACK *PFNLVCOMPARE)(LPARAM, LPARAM, LPARAM);

typedef struct tagLVCOLUMNW
{
    UINT mask;
    int fmt;
    int cx;
    LPWSTR pszText;
    int cchTextMax;
    int iSubItem;
    // FIXME int iOrder; // not available
} LVCOLUMNW;

#define  LVCOLUMN   LVCOLUMNW
#define LV_COLUMNW  LVCOLUMNW  /* FIXME */



typedef struct tagLVITEMW
{
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
#if (_WIN32_IE >= 0x0300)
    int iIndent;
#endif
#if (_WIN32_WINNT >= 0x501)
    int iGroupId;
    UINT cColumns; // tile view columns
    PUINT puColumns;
#endif
} LVITEMW;

#define LVITEM    LVITEMW

#define LVIF_TEXT   0x0001
// FIXME - mask
#define LVIF_PARAM 2
#define LVIF_IMAGE 4
#define LVIF_STATE 8

#endif

class wxListCtrl;

namespace NWindows {
namespace NControl {

class CListView // : public NWindows::CWindow
{
    wxListCtrl *_list;
public:
    CListView() : _list(0) {}
    void Attach(wxWindow * newWindow);

    operator HWND() const;

        void SetUnicodeFormat() { /* FIXME */ ; }


    int GetItemCount() const;

    int InsertItem(int index, LPCTSTR text);
    int InsertItem(const LVITEM* item);

    void SetItem(const LVITEM* item);

    int SetSubItem(int index, int subIndex, LPCTSTR text);

    void SetUnicodeFormat(bool fUnicode) { return ;  }

    void InsertColumn(int columnIndex, LPCTSTR text, int width);

    void InsertColumn(int columnIndex, const LVCOLUMNW *columnInfo);

    void DeleteAllItems();

    void SetRedraw(bool);

    void SetItemCount(int );

    void InvalidateRect(void *, bool);

    int GetSelectedCount() const;

    void /* bool */ EnsureVisible(int index, bool partialOK);

    void SetItemState(int index, UINT state, UINT mask);

    void SetItemState_FocusedSelected(int index) { SetItemState(index, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED); }

    void SetItemState_Selected(int index, bool select) { SetItemState(index, select ? LVIS_SELECTED : 0, LVIS_SELECTED); }
    void SetItemState_Selected(int index) { SetItemState(index, LVIS_SELECTED, LVIS_SELECTED); }

    UINT GetItemState(int index, UINT mask) const;

    bool IsItemSelected(int index) const { return GetItemState(index, LVIS_SELECTED) == LVIS_SELECTED; }

    void /* bool */  Update();

    bool DeleteColumn(int columnIndex);

    bool GetItemParam(int itemIndex, LPARAM &param) const;

    int GetNextItem(int startIndex, UINT flags) const;

    int GetFocusedItem() const;

    void RedrawAllItems();
      // FIXME added
    int GetColumnCount();

    void SetFocus();

    void RedrawItem(int item);

    bool SortItems(PFNLVCOMPARE compareFunction, LPARAM dataParam);

    bool GetColumn(int columnIndex, LVCOLUMN* columnInfo);

    // HWND EditLabel(int itemIndex)
    void EditLabel(int itemIndex);

    bool SetColumnWidthAuto(int iCol) {
        return true; // FIXME SetColumnWidth(iCol, LVSCW_AUTOSIZE);
    }

private:
    void _InsertColumn(int columnIndex, LPCTSTR text, int format, int width);

};

class CListView2: public CListView
{
// FIXME   WNDPROC _origWindowProc;
public:
  // void SetWindowProc();
  virtual LRESULT OnMessage(UINT message, WPARAM wParam, LPARAM lParam);
};

/*
class CListView3: public CListView2
{
public:
  virtual LRESULT OnMessage(UINT message, WPARAM wParam, LPARAM lParam);
};
*/

}}
#endif

// Windows/Control/ProgressBar.h

#ifndef __WINDOWS_CONTROL_PROGRESSBAR_H
#define __WINDOWS_CONTROL_PROGRESSBAR_H

#include "Windows/Window.h"
#include "Windows/Defs.h"

class wxGauge;

namespace NWindows {
namespace NControl {


class CProgressBar : public CWindow
{
protected:
	wxGauge* _window;
	int _minValue;
	int _range;
public:
	CProgressBar(wxWindow* newWindow = NULL);

	void Attach(wxWindow* newWindow);

	void SetRange32(int minValue, int maxValue);

	void SetPos(int pos);
};

}}

#endif

// Windows/Control/Static.h

#ifndef __WINDOWS_CONTROL_STATIC_H
#define __WINDOWS_CONTROL_STATIC_H

#include "Windows/Window.h"
#include "Windows/Defs.h"

typedef void * HICON;

namespace NWindows {
namespace NControl {

class CStatic : public CWindow
{
public:

	HICON SetIcon(HICON icon) { return 0; } // FIXME
};

}}

#endif
// Windows/Control/StatusBar.h

#ifndef __WINDOWS_CONTROL_STATUSBAR_H
#define __WINDOWS_CONTROL_STATUSBAR_H

#include "Windows/Window.h"
#include "Windows/Defs.h"

class wxStatusBar;

namespace NWindows {
namespace NControl {

class CStatusBar // : public NWindows::CWindow
{
	wxStatusBar * _statusBar;
public:
	CStatusBar() : _statusBar(0) {}

	void Attach(wxWindow * newWindow);
	wxWindow * Detach();

	void SetText(int index, LPCTSTR text);
	
/* FIXME
  bool Create(LONG style, LPCTSTR text, HWND hwndParent, UINT id)
    { return (_window = ::CreateStatusWindow(style, text, hwndParent, id)) != 0; }
  bool SetParts(int numParts, const int *edgePostions)
    { return LRESULTToBool(SendMessage(SB_SETPARTS, numParts, (LPARAM)edgePostions)); }
  bool SetText(LPCTSTR text)
    { return CWindow::SetText(text); }

  bool SetText(int index, LPCTSTR text, UINT type)
    { return LRESULTToBool(SendMessage(SB_SETTEXT, index | type, (LPARAM)text)); }
  bool SetText(int index, LPCTSTR text)
    { return SetText(index, text, 0); }
  void Simple(bool simple)
    { SendMessage(SB_SIMPLE, BoolToBOOL(simple), 0); }

  #ifndef _UNICODE
  bool Create(LONG style, LPCWSTR text, HWND hwndParent, UINT id)
    { return (_window = ::CreateStatusWindowW(style, text, hwndParent, id)) != 0; }
  bool SetText(LPCWSTR text)
    { return CWindow::SetText(text); }
  bool SetText(int index, LPCWSTR text, UINT type)
    { return LRESULTToBool(SendMessage(SB_SETTEXTW, index | type, (LPARAM)text)); }
  bool SetText(int index, LPCWSTR text)
    { return SetText(index, text, 0); }
  #endif
*/  
};

}}

#endif

// Windows/Control/Window2.cpp

#include "StdAfx.h"

#ifndef _UNICODE
#include "Common/StringConvert.h"
#endif
#include "Windows/Control/Window2.h"

// extern HINSTANCE g_hInstance;
#ifndef _UNICODE
extern bool g_IsNT;
#endif

namespace NWindows {

#ifndef _UNICODE
ATOM MyRegisterClass(CONST WNDCLASSW *wndClass);
#endif

namespace NControl {

#ifdef _WIN32
static LRESULT CALLBACK WindowProcedure(HWND aHWND, UINT message,
    WPARAM wParam, LPARAM lParam)
{
  CWindow tempWindow(aHWND);
  if (message == WM_NCCREATE)
    tempWindow.SetUserDataLongPtr(
        LONG_PTR(((LPCREATESTRUCT)lParam)->lpCreateParams));
  CWindow2 *window = (CWindow2*)(tempWindow.GetUserDataLongPtr());
  if (window != NULL && message == WM_NCCREATE)
    window->Attach(aHWND);
  if (window == 0)
  {
    #ifndef _UNICODE
    if (g_IsNT)
      return DefWindowProcW(aHWND, message, wParam, lParam);
    else
    #endif
      return DefWindowProc(aHWND, message, wParam, lParam);
  }
  return window->OnMessage(message, wParam, lParam);
}

bool CWindow2::CreateEx(DWORD exStyle, LPCTSTR className,
      LPCTSTR windowName, DWORD style,
      int x, int y, int width, int height,
      HWND parentWindow, HMENU idOrHMenu,
      HINSTANCE instance)
{
  WNDCLASS windowClass;
  if(!::GetClassInfo(instance, className, &windowClass))
  {
    // windowClass.style          = CS_HREDRAW | CS_VREDRAW;
    windowClass.style          = 0;

    windowClass.lpfnWndProc    = WindowProcedure;
    windowClass.cbClsExtra     = NULL;
    windowClass.cbWndExtra     = NULL;
    windowClass.hInstance      = instance;
    windowClass.hIcon          = NULL;
    windowClass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    windowClass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    windowClass.lpszMenuName   = NULL;
    windowClass.lpszClassName  = className;
    if (::RegisterClass(&windowClass) == 0)
      return false;
  }
  return CWindow::CreateEx(exStyle, className, windowName,
      style, x, y, width, height, parentWindow,
      idOrHMenu, instance, this);
}

#ifndef _UNICODE

bool CWindow2::CreateEx(DWORD exStyle, LPCWSTR className,
      LPCWSTR windowName, DWORD style,
      int x, int y, int width, int height,
      HWND parentWindow, HMENU idOrHMenu,
      HINSTANCE instance)
{
  bool needRegister;
  if(g_IsNT)
  {
    WNDCLASSW windowClass;
    needRegister = ::GetClassInfoW(instance, className, &windowClass) == 0;
  }
  else
  {
    WNDCLASSA windowClassA;
    AString classNameA;
    LPCSTR classNameP;
    if (IS_INTRESOURCE(className))
      classNameP = (LPCSTR)className;
    else
    {
      classNameA = GetSystemString(className);
      classNameP = classNameA;
    }
    needRegister = ::GetClassInfoA(instance, classNameP, &windowClassA) == 0;
  }
  if (needRegister)
  {
    WNDCLASSW windowClass;
    // windowClass.style          = CS_HREDRAW | CS_VREDRAW;
    windowClass.style          = 0;
    windowClass.lpfnWndProc    = WindowProcedure;
    windowClass.cbClsExtra     = NULL;
    windowClass.cbWndExtra     = NULL;
    windowClass.hInstance      = instance;
    windowClass.hIcon          = NULL;
    windowClass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    windowClass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    windowClass.lpszMenuName   = NULL;
    windowClass.lpszClassName  = className;
    if (MyRegisterClass(&windowClass) == 0)
      return false;
  }
  return CWindow::CreateEx(exStyle, className, windowName,
      style, x, y, width, height, parentWindow,
      idOrHMenu, instance, this);

}
#endif

LRESULT CWindow2::DefProc(UINT message, WPARAM wParam, LPARAM lParam)
{
  #ifndef _UNICODE
  if (g_IsNT)
    return DefWindowProcW(_window, message, wParam, lParam);
  else
  #endif
    return DefWindowProc(_window, message, wParam, lParam);
}
#endif

LRESULT CWindow2::OnMessage(UINT message, WPARAM wParam, LPARAM lParam)
{
  LRESULT result;
  switch (message)
  {
    case WM_CREATE:
      if (!OnCreate((CREATESTRUCT *)lParam))
        return -1;
      break;
    case WM_COMMAND:
      if (OnCommand(wParam, lParam, result))
        return result;
      break;
    case WM_NOTIFY:
      if (OnNotify((UINT)wParam, (LPNMHDR) lParam, result))
        return result;
      break;
    case WM_DESTROY:
      OnDestroy();
      break;
    case WM_CLOSE:
      OnClose();
      return 0;
#ifdef _WIN32
    case WM_SIZE:
      if (OnSize(wParam, LOWORD(lParam), HIWORD(lParam)))
        return 0;
#endif
  }
#ifdef _WIN32
  return DefProc(message, wParam, lParam);
#else
  return 0;
#endif
}

bool CWindow2::OnCommand(WPARAM wParam, LPARAM lParam, LRESULT &result)
{
  return OnCommand(HIWORD(wParam), LOWORD(wParam), lParam, result);
}

bool CWindow2::OnCommand(int /* code */, int /* itemID */, LPARAM /* lParam */, LRESULT & /* result */)
{
  return false;
  // return DefProc(message, wParam, lParam);
  /*
  if (code == BN_CLICKED)
    return OnButtonClicked(itemID, (HWND)lParam);
  */
}

/*
bool CDialog::OnButtonClicked(int buttonID, HWND buttonHWND)
{
  switch(aButtonID)
  {
    case IDOK:
      OnOK();
      break;
    case IDCANCEL:
      OnCancel();
      break;
    case IDHELP:
      OnHelp();
      break;
    default:
      return false;
  }
  return true;
}

*/

}}
// Windows/Control/Window2.h

#ifndef __WINDOWS_CONTROL_WINDOW2_H
#define __WINDOWS_CONTROL_WINDOW2_H

#include "Windows/Window.h"
#include "Windows/Defs.h"

namespace NWindows {
namespace NControl {

class CWindow2 // : public CWindow
{
  // LRESULT DefProc(UINT message, WPARAM wParam, LPARAM lParam);
  HWND _window;
public:
  CWindow2(HWND newWindow = NULL): _window(newWindow){};
  CWindow2& operator=(HWND newWindow)
  {
    _window = newWindow;
    return *this;
  }

  virtual ~CWindow2() {}

  operator HWND() const { return 0; } // FIXME { return _window; }


#ifdef _WIN32
  bool CreateEx(DWORD exStyle, LPCTSTR className,
      LPCTSTR windowName, DWORD style,
      int x, int y, int width, int height,
      HWND parentWindow, HMENU idOrHMenu,
      HINSTANCE instance);

  #ifndef _UNICODE
  bool CreateEx(DWORD exStyle, LPCWSTR className,
      LPCWSTR windowName, DWORD style,
      int x, int y, int width, int height,
      HWND parentWindow, HMENU idOrHMenu,
      HINSTANCE instance);
  #endif
#endif

  virtual LRESULT OnMessage(UINT message, WPARAM wParam, LPARAM lParam);
  virtual bool OnCreate(CREATESTRUCT * /* createStruct */) { return true; }
  // virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
  virtual bool OnCommand(WPARAM wParam, LPARAM lParam, LRESULT &result);
  virtual bool OnCommand(int code, int itemID, LPARAM lParam, LRESULT &result);
  virtual bool OnSize(WPARAM /* wParam */, int /* xSize */, int /* ySize */) { return false; }
  virtual bool OnNotify(UINT /* controlID */, LPNMHDR /* lParam */, LRESULT & /* result */) { return false; }
  virtual void OnDestroy() { /* FIXME PostQuitMessage(0); */ }
  virtual void OnClose() { /* FIXME Destroy(); */ }
  /*
  virtual LRESULT  OnHelp(LPHELPINFO helpInfo) { OnHelp(); };
  virtual LRESULT  OnHelp() {};
  virtual bool OnButtonClicked(int buttonID, HWND buttonHWND);
  virtual void OnOK() {};
  virtual void OnCancel() {};
  */

#ifdef _WIN32
  LONG_PTR SetMsgResult(LONG_PTR newLongPtr )
    { return SetLongPtr(DWLP_MSGRESULT, newLongPtr); }
  LONG_PTR GetMsgResult() const
    { return GetLongPtr(DWLP_MSGRESULT); }
#endif
};

}}

#endif

#ifndef _BASETYPS_H
#define _BASETYPS_H

#ifdef ENV_HAVE_GCCVISIBILITYPATCH
  #define DLLEXPORT __attribute__ ((visibility("default")))
#else
  #define DLLEXPORT
#endif

#ifdef __cplusplus
#define STDAPI extern "C" DLLEXPORT HRESULT
#else
#define STDAPI extern DLLEXPORT HRESULT
#endif  /* __cplusplus */ 

typedef GUID IID;
typedef GUID CLSID;
#endif

/* 
 * tchar.h
 *
 * Unicode mapping layer for the standard C library. By including this
 * file and using the 't' names for string functions
 * (eg. _tprintf) you can make code which can be easily adapted to both
 * Unicode and non-unicode environments. In a unicode enabled compile define
 * _UNICODE before including tchar.h, otherwise the standard non-unicode
 * library functions will be used.
 *
 * Note that you still need to include string.h or stdlib.h etc. to define
 * the appropriate functions. Also note that there are several defines
 * included for non-ANSI functions which are commonly available (but using
 * the convention of prepending an underscore to non-ANSI library function
 * names).
 *
 * This file is part of the Mingw32 package.
 *
 * Contributors:
 *  Created by Colin Peters <colin@bird.fu.is.saga-u.ac.jp>
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $Revision: 1.11 $
 * $Author: earnie $
 * $Date: 2003/05/03 13:48:46 $
 *
 */

#ifndef	_TCHAR_H_
#define _TCHAR_H_

/* All the headers include this file. */
#ifndef __int64
#define __int64 long long
#endif

#ifndef __cdecl
#define __cdecl /* */
#endif

/*
 * NOTE: This tests _UNICODE, which is different from the UNICODE define
 *       used to differentiate Win32 API calls.
 */
#ifdef	_UNICODE


/*
 * Use TCHAR instead of char or wchar_t. It will be appropriately translated
 * if _UNICODE is correctly defined (or not).
 */
#ifndef _TCHAR_DEFINED
typedef	wchar_t	TCHAR;
#define _TCHAR_DEFINED
#endif

/*
 * Unicode functions
 */
/*
#define _tfopen     _wfopen
FILE *_wfopen( const wchar_t *filename, const wchar_t *mode );
*/

#else	/* Not _UNICODE */

#define _tfopen     fopen

/*
 * TCHAR, the type you should use instead of char.
 */
#ifndef _TCHAR_DEFINED
typedef char	TCHAR;
#define _TCHAR_DEFINED
#endif

#endif	/* Not _UNICODE */

#endif	/* Not _TCHAR_H_ */

/*
	windows.h - main header file for the Win32 API

	Written by Anders Norlander <anorland@hem2.passagen.se>

	This file is part of a free library for the Win32 API.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/
#ifndef _WINDOWS_H
#define _WINDOWS_H

#include <stdarg.h>

/* BEGIN #include <windef.h> */

#include "Common/MyWindows.h" // FIXED

#ifndef CONST
#define CONST const
#endif

#undef MAX_PATH
#define MAX_PATH 4096  /* Linux : 4096  - Windows : 260 */

#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif

#define WINAPI 

#undef BOOL
typedef int BOOL;


#define CREATE_NEW	  1
#define CREATE_ALWAYS	  2
#define OPEN_EXISTING	  3
#define OPEN_ALWAYS	  4
/* #define TRUNCATE_EXISTING 5 */



/* BEGIN #include <winnt.h> */
/* BEGIN <winerror.h> */
#define NO_ERROR                    0L
#define ERROR_ALREADY_EXISTS        EEXIST
#define ERROR_FILE_EXISTS           EEXIST
#define ERROR_INVALID_HANDLE        EBADF
#define ERROR_PATH_NOT_FOUND        ENOENT
#define ERROR_DISK_FULL             ENOSPC
#define ERROR_NO_MORE_FILES         0x100018 // FIXME
#define ERROR_DIRECTORY             267 // FIXME

// #define ERROR_NEGATIVE_SEEK         0x100131 // FIXME


/* see Common/WyWindows.h
#define S_OK ((HRESULT)0x00000000L)
#define S_FALSE ((HRESULT)0x00000001L)
#define E_INVALIDARG ((HRESULT)0x80070057L)
#define E_NOTIMPL ((HRESULT)0x80004001L)
#define E_NOINTERFACE ((HRESULT)0x80004002L)
#define E_ABORT ((HRESULT)0x80004004L)
#define E_FAIL ((HRESULT)0x80004005L)
#define E_OUTOFMEMORY ((HRESULT)0x8007000EL)
#define STG_E_INVALIDFUNCTION ((HRESULT)0x80030001L)
#define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)
#define FAILED(Status) ((HRESULT)(Status)<0)
*/
#ifndef VOID
#define VOID void
#endif
typedef void *PVOID,*LPVOID;
typedef WCHAR *LPWSTR;
typedef CHAR *LPSTR;
typedef TCHAR *LPTSTR;

#ifdef UNICODE
/*
 * P7ZIP_TEXT is a private macro whose specific use is to force the expansion of a
 * macro passed as an argument to the macro TEXT.  DO NOT use this
 * macro within your programs.  It's name and function could change without
 * notice.
 */
#define P7ZIP_TEXT(q) L##q
#else
#define P7ZIP_TEXT(q) q
#endif
/*
 * UNICODE a constant string when UNICODE is defined, else returns the string
 * unmodified.
 * The corresponding macros  _TEXT() and _T() for mapping _UNICODE strings
 * passed to C runtime functions are defined in mingw/tchar.h
 */
#define TEXT(q) P7ZIP_TEXT(q)    

typedef BYTE BOOLEAN;

/* BEGIN #include <basetsd.h> */
#ifndef __int64
#define __int64 long long
#endif
typedef unsigned __int64 UINT64;
typedef __int64 INT64;
/* END #include <basetsd.h> */

#define FILE_ATTRIBUTE_READONLY             1
#define FILE_ATTRIBUTE_HIDDEN               2
#define FILE_ATTRIBUTE_SYSTEM               4
#define FILE_ATTRIBUTE_DIRECTORY           16
#define FILE_ATTRIBUTE_ARCHIVE             32
#define FILE_ATTRIBUTE_DEVICE              64
#define FILE_ATTRIBUTE_NORMAL             128
#define FILE_ATTRIBUTE_TEMPORARY          256
#define FILE_ATTRIBUTE_SPARSE_FILE        512
#define FILE_ATTRIBUTE_REPARSE_POINT     1024
#define FILE_ATTRIBUTE_COMPRESSED        2048
#define FILE_ATTRIBUTE_OFFLINE          0x1000
#define FILE_ATTRIBUTE_ENCRYPTED        0x4000
#define FILE_ATTRIBUTE_UNIX_EXTENSION   0x8000   /* trick for Unix */

/* END   <winerror.h> */

#include <string.h>
#include <stddef.h>

/* END #include <winnt.h> */

/* END #include <windef.h> */

/* BEGIN #include <winbase.h> */

#define WAIT_OBJECT_0 0
#define INFINITE	0xFFFFFFFF

typedef struct _SYSTEMTIME {
	WORD wYear;
	WORD wMonth;
	WORD wDayOfWeek;
	WORD wDay;
	WORD wHour;
	WORD wMinute;
	WORD wSecond;
	WORD wMilliseconds;
} SYSTEMTIME;

#ifdef __cplusplus
extern "C" {
#endif

BOOL WINAPI DosDateTimeToFileTime(WORD,WORD,FILETIME *);
BOOL WINAPI FileTimeToDosDateTime(CONST FILETIME *,WORD *, WORD *);
BOOL WINAPI FileTimeToLocalFileTime(CONST FILETIME *,FILETIME *);
BOOL WINAPI FileTimeToSystemTime(CONST FILETIME *,SYSTEMTIME *);
BOOL WINAPI LocalFileTimeToFileTime(CONST FILETIME *,FILETIME *);
VOID WINAPI GetSystemTime(SYSTEMTIME *);
BOOL WINAPI SystemTimeToFileTime(const SYSTEMTIME*,FILETIME *);
VOID WINAPI GetSystemTimeAsFileTime(FILETIME * time);

DWORD WINAPI GetTickCount(VOID);

#ifdef __cplusplus
}
#endif
/* END #include <winbase.h> */

/* BEGIN #include <winnls.h> */

#define CP_ACP   0
#define CP_OEMCP 1
#define CP_UTF8  65001

/* #include <unknwn.h> */
#include <basetyps.h>

#ifdef __cplusplus
extern "C" const IID IID_ISequentialStream;
struct ISequentialStream : public IUnknown
{
	STDMETHOD(QueryInterface)(REFIID,PVOID*) PURE;
	STDMETHOD_(ULONG,AddRef)(void) PURE;
	STDMETHOD_(ULONG,Release)(void) PURE;
	STDMETHOD(Read)(void*,ULONG,ULONG*) PURE;
	STDMETHOD(Write)(void const*,ULONG,ULONG*) PURE;
};
#else
extern const IID IID_ISequentialStream;
#endif  /* __cplusplus */


/* END #include <ole2.h> */

#endif

// stdafx.h

#ifndef __STDAFX_H
#define __STDAFX_H


#include "config.h"

#define MAXIMUM_WAIT_OBJECTS 64

#define NO_INLINE /* FIXME */

#ifdef ENV_HAVE_PTHREAD
#include <pthread.h>
#endif

#include "Common/Common.h"
#include "Common/MyWindows.h"
#include "Common/MyTypes.h"
#include "Common/MyString.h" // FIXME

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <tchar.h>
#include <wchar.h>
#include <stddef.h>
#include <ctype.h>
#include <unistd.h>
#include <errno.h>
#include <math.h>

#ifdef __NETWARE__
#include <sys/types.h>
#endif

#undef CS /* fix for Solaris 10 x86 */


#ifdef __cplusplus
# define EXTERN_C    extern "C"
#else
# define EXTERN_C    extern
#endif


/***************************/

#ifndef ENV_HAVE_WCHAR__H

EXTERN_C_BEGIN

size_t	wcslen(const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );

EXTERN_C_END

#endif

/***************************/

#define CLASS_E_CLASSNOTAVAILABLE        ((HRESULT)0x80040111L)

/************************* LastError *************************/
inline DWORD WINAPI GetLastError(void) { return errno; }
inline void WINAPI SetLastError( DWORD err ) { errno = err; }

#define AreFileApisANSI() (1)

void Sleep(unsigned millisleep);

typedef pid_t t_processID;

t_processID GetCurrentProcess(void);

#define  NORMAL_PRIORITY_CLASS (0)
#define  IDLE_PRIORITY_CLASS   (10)
void SetPriorityClass(t_processID , int priority);

#ifdef __cplusplus
class wxWindow;
typedef wxWindow *HWND;

#define MB_ICONERROR (0x00000200) // wxICON_ERROR
#define MB_YESNOCANCEL (0x00000002 | 0x00000008 | 0x00000010) // wxYES | wxNO | wxCANCEL
#define MB_ICONQUESTION (0x00000400) // wxICON_QUESTION
#define MB_TASKMODAL  (0) // FIXME
#define MB_SYSTEMMODAL (0) // FIXME

#define MB_OK (0x00000004) // wxOK
#define MB_ICONSTOP (0x00000200) // wxICON_STOP
#define MB_OKCANCEL (0x00000004 | 0x00000010) // wxOK | wxCANCEL

#define MessageBox MessageBoxW
int MessageBoxW(wxWindow * parent, const TCHAR * mes, const TCHAR * title,int flag);


// FIXME
#define IDCLOSE   (5001) // wxID_CLOSE
#define IDEXIT    (5006) // wxID_EXIT
#define IDOK      (5100) // wxID_OK
#define IDCANCEL  (5101) // wxID_CANCEL
#define IDABORT   (5115) // wxID_ABORT
#define IDYES     (5103) // wxID_YES
#define IDNO      (5104) // wxID_NO
#define IDHELP    (5009) // wxID_HELP

// Show
#define SW_HIDE             0
#define SW_SHOW             5



typedef void *HINSTANCE;

// gcc / clang on Unix  : sizeof(long==sizeof(void*) in 32 or 64 bits)
//typedef          int   INT_PTR;
typedef          long   INT_PTR;
// typedef unsigned int  UINT_PTR;
typedef unsigned long  UINT_PTR;

typedef          long LONG_PTR;
typedef unsigned long DWORD_PTR;

typedef UINT_PTR WPARAM;

/* WARNING
 LPARAM shall be 'long' because of CListView::SortItems and wxListCtrl::SortItems :
*/
typedef LONG_PTR LPARAM;
typedef LONG_PTR LRESULT;


#define LOWORD(l)              ((WORD)((DWORD_PTR)(l) & 0xFFFF))
#define HIWORD(l)              ((WORD)((DWORD_PTR)(l) >> 16))


#define CALLBACK /* */

#define ERROR_NEGATIVE_SEEK         0x100131 // FIXME
#define FACILITY_WIN32                        7 // FIXME
#define __HRESULT_FROM_WIN32(x)   ((HRESULT)(x) > 0 ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : (HRESULT)(x) ) // FIXME

static inline HRESULT HRESULT_FROM_WIN32(unsigned int x)
{
    return (HRESULT)x > 0 ? ((HRESULT) ((x & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : (HRESULT)x;
}

/************ Windows2.h ***********/

typedef void * WNDPROC;
typedef void * CREATESTRUCT;
typedef struct
{
	HWND  hwndFrom;

	UINT  code;
#define NM_DBLCLK       1
#define LVN_ITEMCHANGED 2
#define LVN_COLUMNCLICK 3	
#define CBEN_BEGINEDIT  10
#define CBEN_ENDEDITW   11
	
	
} NMHDR;
typedef NMHDR * LPNMHDR;

typedef struct tagNMLISTVIEW
{
    NMHDR hdr;
    INT iItem;
    INT iSubItem;
    UINT uNewState;
    UINT uOldState;
    // UINT uChanged;
    // POINT ptAction;
    LPARAM  lParam;
} NMLISTVIEW, *LPNMLISTVIEW;

typedef void * LPNMITEMACTIVATE;

#define NM_RCLICK 1234 /* FIXME */

// FIXME
#define WM_CREATE 1
#define WM_COMMAND 2
#define WM_NOTIFY 3
#define WM_DESTROY 4
#define WM_CLOSE 5

#define HIWORD(l)              ((WORD)((DWORD_PTR)(l) >> 16))
#define LOWORD(l)              ((WORD)((DWORD_PTR)(l) & 0xFFFF))


/************ LANG ***********/
typedef WORD            LANGID;

LANGID GetUserDefaultLangID(void);
LANGID GetSystemDefaultLangID(void);

#define PRIMARYLANGID(l)        ((WORD)(l) & 0x3ff)
#define SUBLANGID(l)            ((WORD)(l) >> 10)

#if defined( __x86_64__ )

#define _WIN64 1

#endif

#endif

#endif 


#if !defined(__DJGPP__)

#ifndef __CYGWIN__
  #define FILESYSTEM_IS_CASE_SENSITIVE 1
#endif

  #if !defined(ENV_BEOS)

    /* <wchar.h> */
    /* ENV_HAVE_WCHAR__H and not ENV_HAVE_WCHAR_H to avoid warning with wxWidgets */
    #define ENV_HAVE_WCHAR__H

    /* <wctype.h> */
    #define ENV_HAVE_WCTYPE_H

    /* mbrtowc */
/* #ifndef __hpux */
/*    #define ENV_HAVE_MBRTOWC */
/* #endif */

    /* towupper */
    #define ENV_HAVE_TOWUPPER

  #endif /* !ENV_BEOS */

  #ifdef ENV_HAIKU  /* AFTER !defined(ENV_BEOS) because ENV_HAIKU and ENV_BEOS are defined */
    /* <wchar.h> */
    /* ENV_HAVE_WCHAR__H and not ENV_HAVE_WCHAR_H to avoid warning with wxWidgets */
    #define ENV_HAVE_WCHAR__H

    /* <wctype.h> */
    #define ENV_HAVE_WCTYPE_H

    /* towupper */
    #define ENV_HAVE_TOWUPPER
  #endif
		
  
  
  #if !defined(ENV_BEOS) && !defined(ANDROID_NDK)

    #define ENV_HAVE_GETPASS

    #if !defined(sun)
      #define ENV_HAVE_TIMEGM
    #endif

  #endif

  /* lstat, readlink and S_ISLNK */
  #define ENV_HAVE_LSTAT

  /* <locale.h> */
  #define ENV_HAVE_LOCALE

  /* mbstowcs */
  #define ENV_HAVE_MBSTOWCS

  /* wcstombs */
  #define ENV_HAVE_WCSTOMBS

#endif /* !__DJGPP__ */

#ifndef ENV_BEOS
#define ENV_HAVE_PTHREAD
#endif

/* ANDROID don't have wcstombs or mbstowcs ? */
#if defined(ENV_MACOSX) || defined(ANDROID_NDK)
#define LOCALE_IS_UTF8
#endif

#ifdef LOCALE_IS_UTF8
#undef ENV_HAVE_LOCALE
#undef ENV_HAVE_MBSTOWCS
#undef ENV_HAVE_WCSTOMBS
/* #undef ENV_HAVE_MBRTOWC */
#endif

#define MAX_PATHNAME_LEN   1024

// initguid.h

#include "Common/MyInitGuid.h"

PROG=test_lib

LOCAL_FLAGS=-I. -I.. -I../include_windows -DUNICODE -D_UNICODE

include ../../makefile.crc32
include ../../makefile.machine

TARGET_FLAGS=$(CC_EXE)
LOCAL_LINK=$(LINK_EXE)
LIBS=$(LOCAL_LIBS)

OBJS= \
	wine_date_and_time.o \
	mySplitCommandLine.o \
	myAddExeFlag.o \
	wine_GetXXXDefaultLangID.o \
	test_lib.o \
	MyVector.o \
	MyString.o \
	MyWindows.o \
	CpuArch.o

include ../../makefile.glb


all: $(PCH_NAME) $(PROG)

SRCS= \
 mySplitCommandLine.cpp \
 myAddExeFlag.cpp \
 test_lib.cpp \
 wine_date_and_time.cpp \
 wine_GetXXXDefaultLangID.cpp \
 ../Common/MyVector.cpp \
 ../Common/MyString.cpp \
 ../Common/MyWindows.cpp

StdAfx.h.gch : StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) StdAfx.h -o StdAfx.h.gch

mySplitCommandLine.o : mySplitCommandLine.cpp
	$(CXX) $(CXXFLAGS) mySplitCommandLine.cpp
myAddExeFlag.o : myAddExeFlag.cpp
	$(CXX) $(CXXFLAGS) myAddExeFlag.cpp
test_lib.o : test_lib.cpp
	$(CXX) $(CXXFLAGS) test_lib.cpp
wine_date_and_time.o : wine_date_and_time.cpp
	$(CXX) $(CXXFLAGS) wine_date_and_time.cpp
wine_GetXXXDefaultLangID.o : wine_GetXXXDefaultLangID.cpp
	$(CXX) $(CXXFLAGS) wine_GetXXXDefaultLangID.cpp
MyVector.o : ../Common/MyVector.cpp
	$(CXX) $(CXXFLAGS) ../Common/MyVector.cpp
MyString.o : ../Common/MyString.cpp
	$(CXX) $(CXXFLAGS) ../Common/MyString.cpp
MyWindows.o : ../Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../Common/MyWindows.cpp
CpuArch.o : ../../C/CpuArch.c
	$(CC) $(CFLAGS) ../../C/CpuArch.c

#include "StdAfx.h"

#include <sys/types.h>
#include <sys/stat.h>

#include <windows.h>

#define NEED_NAME_WINDOWS_TO_UNIX
#include "myPrivate.h"

#include "Common/StringConvert.h"

void myAddExeFlag(const UString &u_name)
{
	AString filename = UnicodeStringToMultiByte(u_name, CP_ACP); // FIXME
	const char * name = nameWindowToUnix(filename);
	// printf("myAddExeFlag(%s)\n",name);
	chmod(name,0700);
}


void WINAPI RtlSecondsSince1970ToFileTime( DWORD Seconds, FILETIME * ft );

extern "C" int global_use_utf16_conversion;
#ifdef ENV_HAVE_LSTAT
extern "C" int global_use_lstat;
#endif

const char *my_getlocale(void);

#ifdef NEED_NAME_WINDOWS_TO_UNIX
static inline const char * nameWindowToUnix(const char * lpFileName) {
  if ((lpFileName[0] == 'c') && (lpFileName[1] == ':')) return lpFileName+2;
  return lpFileName;
}



#endif

// From mySplitCommandLine.cpp
void mySplitCommandLine(int numArguments, char *arguments[],UStringVector &parts);
class CStdOutStream;
void showP7zipInfo(CStdOutStream *so);

#include "StdAfx.h"

#include "../Common/StringConvert.h"

#include "myPrivate.h"
#include "Windows/System.h"
#include "7zip/MyVersion.h"
#include "Common/StdOutStream.h"
#include "Common/IntToString.h"
#include "../C/CpuArch.h"

#ifdef ENV_HAVE_LOCALE
#include <locale.h>
#endif

#include <string.h> // memset

extern void my_windows_split_path(const AString &p_path, AString &dir , AString &base);


#if defined(MY_CPU_X86_OR_AMD64) && defined(_7ZIP_ASM)
static void PrintCpuChars(AString &s, UInt32 v)
{
  for (int j = 0; j < 4; j++)
  {
    Byte b = (Byte)(v & 0xFF);
    v >>= 8;
    if (b == 0)
      break;
    s += (char)b;
  }
}

static void x86cpuid_to_String(const Cx86cpuid &c, AString &s)
{
  s.Empty();

  UInt32 maxFunc2 = 0;
  UInt32 t[3];

  MyCPUID(0x80000000, &maxFunc2, &t[0], &t[1], &t[2]);

  bool fullNameIsAvail = (maxFunc2 >= 0x80000004);

  if (!fullNameIsAvail)
  {
    for (int i = 0; i < 3; i++)
      PrintCpuChars(s, c.vendor[i]);
  }
  else
  {
    for (int i = 0; i < 3; i++)
    {
      UInt32 c[4] = { 0 };
      MyCPUID(0x80000002 + i, &c[0], &c[1], &c[2], &c[3]);
      for (int j = 0; j < 4; j++)
        PrintCpuChars(s, c[j]);
    }
  }

  s.Add_Space_if_NotEmpty();
  {
    char temp[32];
    ConvertUInt32ToHex(c.ver, temp);
    s += '(';
    s += temp;
    s += ')';
  }
}
#endif

static void GetCpuName(AString &s)
{
  s.Empty();

  #ifdef MY_CPU_X86_OR_AMD64
  {
    #ifdef _7ZIP_ASM
    Cx86cpuid cpuid;
    if (x86cpuid_CheckAndRead(&cpuid))
    {
      x86cpuid_to_String(cpuid, s);
      return;
    }
    #endif
    #ifdef MY_CPU_AMD64
    s = "x64";
    #else
    s = "x86";
    #endif
  }
  #else

    #ifdef MY_CPU_LE
      s = "LE";
    #elif defined(MY_CPU_BE)
      s = "BE";
    #else
      #error ENDIANNESS
    #endif

  #endif
}

void mySplitCommandLine(int numArguments, char *arguments[],UStringVector &parts) {

  { // define P7ZIP_HOME_DIR
    static char p7zip_home_dir[MAX_PATH];
    AString dir,name;
    my_windows_split_path(arguments[0],dir,name);
    snprintf(p7zip_home_dir,sizeof(p7zip_home_dir),"P7ZIP_HOME_DIR=%s/",(const char *)dir);
    p7zip_home_dir[sizeof(p7zip_home_dir)-1] = 0;
    putenv(p7zip_home_dir);
  }

#ifdef ENV_HAVE_LOCALE
  // set the program's current locale from the user's environment variables
  setlocale(LC_ALL,"");

  // auto-detect which conversion p7zip should use
  char *locale = setlocale(LC_CTYPE,0);
  if (locale) {
    size_t len = strlen(locale);
    char *locale_upper = (char *)malloc(len+1);
    if (locale_upper) {
      strcpy(locale_upper,locale);

      for(size_t i=0;i<len;i++)
        locale_upper[i] = toupper(locale_upper[i] & 255);

      if (    (strcmp(locale_upper,"") != 0)
              && (strcmp(locale_upper,"C") != 0)
              && (strcmp(locale_upper,"POSIX") != 0) ) {
        global_use_utf16_conversion = 1;
      }
      free(locale_upper);
    }
  }
#elif defined(LOCALE_IS_UTF8)
  global_use_utf16_conversion = 1; // assume LC_CTYPE="utf8"
#else
  global_use_utf16_conversion = 0; // assume LC_CTYPE="C"
#endif

  parts.Clear();
  for(int ind=0;ind < numArguments; ind++) {
    if ((ind <= 2) && (strcmp(arguments[ind],"-no-utf16") == 0)) {
      global_use_utf16_conversion = 0;
    } else if ((ind <= 2) && (strcmp(arguments[ind],"-utf16") == 0)) {
      global_use_utf16_conversion = 1;
    } else {
      UString tmp = MultiByteToUnicodeString(arguments[ind]);
      // tmp.Trim(); " " is a valid filename ...
      if (!tmp.IsEmpty()) {
        parts.Add(tmp);
      }
      // try to hide the password
      {
        char * arg = arguments[ind];
    size_t len = strlen(arg);
        if ( (len > 2) && (arg[0] == '-') && ( (arg[1]=='p') || (arg[1]=='P') ) )
        {
          memset(arg+2,'*',len-2);
        }
      }
    }
  }
}

const char *my_getlocale(void) {
#ifdef ENV_HAVE_LOCALE
  const char* ret = setlocale(LC_CTYPE,0);
  if (ret == 0)
    ret ="C";
  return ret;
#elif defined(LOCALE_IS_UTF8)
  return "utf8";
#else
  return "C";
#endif
}

void showP7zipInfo(CStdOutStream *so)
{
  if (!so)
    return;

  AString cpu_name;
  GetCpuName(cpu_name);
  cpu_name.Trim();

  int bits = int(sizeof(void *)) * 8;

  *so << "p7zip Version " << P7ZIP_VERSION << " (locale=" << my_getlocale() <<",Utf16=";
  if (global_use_utf16_conversion) *so << "on";
  else                             *so << "off";
  *so << ",HugeFiles=";
  if (sizeof(off_t) >= 8) *so << "on,";
  else                    *so << "off,";
  *so << bits << " bits,";
  int nbcpu = NWindows::NSystem::GetNumberOfProcessors();
  if (nbcpu > 1) *so << nbcpu << " CPUs ";
  else           *so << nbcpu << " CPU ";
  *so << cpu_name;

#ifdef _7ZIP_ASM
{
  const char * txt =",ASM";
  #ifdef MY_CPU_X86_OR_AMD64
  if (CPU_Is_Aes_Supported()) { txt =",ASM,AES-NI"; }
  #endif
  *so << txt;
}
#endif
    *so << ")\n\n";

}
#undef BIG_ENDIAN
#undef LITTLE_ENDIAN

#include "StdAfx.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>

#ifdef __APPLE_CC__
#define UInt32  macUIn32
#include <CoreFoundation/CoreFoundation.h>
#undef UInt32
#endif

#ifdef ENV_HAVE_WCHAR__H
#include <wchar.h>
#endif
#ifdef ENV_HAVE_LOCALE
#include <locale.h>
#endif

#include <windows.h>

#define NEED_NAME_WINDOWS_TO_UNIX
// #include "myPrivate.h"

#include "Common/StringConvert.h"
#include "Common/StdOutStream.h"

#undef NDEBUG
#include <assert.h>

#include "Common/StringConvert.cpp"
#include "Common/StdOutStream.cpp"
#include "Common/IntToString.cpp"
#include "Common/UTFConvert.cpp"

#include "Windows/Synchronization.cpp"
#include "Windows/FileFind.cpp"
#include "Windows/TimeUtils.cpp"
#include "Windows/System.cpp"
#include "../C/Threads.c"
#include "../../C/Ppmd.h"

int g_CodePage = -1;

int global_use_lstat = 0; // FIXME

/* FIXME */

LPSTR WINAPI CharNextA( LPCSTR ptr ) {
  if (!*ptr)
    return (LPSTR)ptr;
  return (LPSTR)(ptr + 1); // p7zip search only for ASCII characters like '/' so no need to worry about current locale
}


int MyStringCompare(const char *s1, const char *s2)
{
  while (true)
  {
    unsigned char c1 = (unsigned char)*s1++;
    unsigned char c2 = (unsigned char)*s2++;
    if (c1 < c2) return -1;
    if (c1 > c2) return 1;
    if (c1 == 0) return 0;
  }
}

int MyStringCompare(const wchar_t *s1, const wchar_t *s2)
{
  while (true)
  {
    wchar_t c1 = *s1++;
    wchar_t c2 = *s2++;
    if (c1 < c2) return -1;
    if (c1 > c2) return 1;
    if (c1 == 0) return 0;
  }
}



/* FIXME */

using namespace NWindows;

#if  defined(ENV_HAVE_WCHAR__H) && defined(ENV_HAVE_MBSTOWCS) && defined(ENV_HAVE_WCSTOMBS)
void test_mbs(void) {
  wchar_t wstr1[256] = {
                         L'e',
                         0xE8, // latin small letter e with grave
                         0xE9, // latin small letter e with acute
                         L'a',
                         0xE0, // latin small letter a with grave
                         0x20AC, // euro sign
                         L'b',
                         0 };
  wchar_t wstr2[256];
  char    astr[256];

  global_use_utf16_conversion = 1;

  size_t len1 = wcslen(wstr1);

  printf("wstr1 - %d - '%ls'\n",(int)len1,wstr1);

  size_t len0 = wcstombs(astr,wstr1,sizeof(astr));
  printf("astr - %d - '%s'\n",(int)len0,astr);

  size_t len2 = mbstowcs(wstr2,astr,sizeof(wstr2)/sizeof(*wstr2));
  printf("wstr - %d - '%ls'\n",(int)len2,wstr2);

  if (wcscmp(wstr1,wstr2) != 0) {
    printf("ERROR during conversions wcs -> mbs -> wcs\n");
    exit(EXIT_FAILURE);
  }

  char *ptr = astr;
  size_t len = 0;
  while (*ptr) {
    ptr = CharNextA(ptr);
    len += 1;
  }
  if ((len != len1) && (len != 12)) { // 12 = when locale is UTF8 instead of ISO8859-15
    printf("ERROR CharNextA : len=%d, len1=%d\n",(int)len,(int)len1);
    exit(EXIT_FAILURE);
  }

  UString ustr(wstr1);
  assert(ustr.Len() == (int)len1);

  AString  ansistr(astr);
  assert(ansistr.Len() == (int)len0);

  ansistr = UnicodeStringToMultiByte(ustr);
  assert(ansistr.Len() == (int)len0);

  assert(strcmp(ansistr,astr) == 0);
  assert(wcscmp(ustr,wstr1) == 0);

  UString ustr2 = MultiByteToUnicodeString(astr);
  assert(ustr2.Len() == (int)len1);
  assert(wcscmp(ustr2,wstr1) == 0);
}
void test_mbs_2(void) {
  wchar_t wstr1[256] = { 
	0x1F388,  // Ballon
        0 };
  wchar_t wstr1_7zip[256] = { // 7-zip use UTF16 wide string
      0xd83c,
      0xdf88,
        0 };
  char astr1[]= {
    char(0xf0), char(0x9f), char(0x8e), char(0x88), 0

  };
  wchar_t wstr2[256];
  char    astr[256];

  printf("\nTest Ballon character\n");

  global_use_utf16_conversion = 1;

  size_t len1 = wcslen(wstr1);

  printf("wstr1 - %d - '%ls'\n",(int)len1,wstr1);

  size_t len0 = wcstombs(astr,wstr1,sizeof(astr));
  printf("astr - %d - '%s'\n",(int)len0,astr);

  printf("strlen(astr)=%d\n",(int)strlen(astr));
  printf("strlen(astr1)=%d\n",(int)strlen(astr1));
  assert(strlen(astr) == strlen(astr1));

  assert(strcmp(astr,astr1) == 0);

  size_t len2 = mbstowcs(wstr2,astr,sizeof(wstr2)/sizeof(*wstr2));
  printf("wstr - %d - '%ls'\n",(int)len2,wstr2);

  if (wcscmp(wstr1,wstr2) != 0) {
    printf("ERROR during conversions wcs -> mbs -> wcs\n");
    exit(EXIT_FAILURE);
  }

  AString  ansistr(astr);
  assert(ansistr.Len() == (int)len0);

  UString ustr2 = MultiByteToUnicodeString(ansistr);
  assert(ustr2.Len() == wcslen(wstr1_7zip));
  assert(wcscmp(ustr2,wstr1_7zip) == 0);
}
#endif

static void test_astring(int num) {
  AString strResult;

  strResult = "first part : ";
  char number[256];
  sprintf(number,"%d",num);
  strResult += AString(number);

  strResult += " : last part";

  printf("strResult -%s-\n",(const char *)strResult);

}


extern void my_windows_split_path(const AString &p_path, AString &dir , AString &base);

static struct {
  const char *path;
  const char *dir;
  const char *base;
}
tabSplit[]=
  {
    { "",".","." },
    { "/","/","/" },
    { ".",".","." },
    { "//","/","/" },
    { "///","/","/" },
    { "dir",".","dir" },
    { "/dir","/","dir" },
    { "/dir/","/","dir" },
    { "/dir/base","/dir","base" },
    { "/dir//base","/dir","base" },
    { "/dir///base","/dir","base" },
    { "//dir/base","//dir","base" },
    { "///dir/base","///dir","base" },
    { "/dir/base/","/dir","base" },
    { 0,0,0 }
  };

static void test_split_astring() {
  int ind = 0;
  while (tabSplit[ind].path) {
    AString path(tabSplit[ind].path);
    AString dir;
    AString base;

    my_windows_split_path(path,dir,base);

    if ((dir != tabSplit[ind].dir) || (base != tabSplit[ind].base)) {
      printf("ERROR : '%s' '%s' '%s'\n",(const char *)path,(const char *)dir,(const char *)base);
    }
    ind++;
  }
  printf("test_split_astring : done\n");
}

 // Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
#define EPOCH_BIAS  116444736000000000LL
static LARGE_INTEGER UnixTimeToUL(time_t tps_unx)
{
	LARGE_INTEGER ul;
	ul.QuadPart = tps_unx * 10000000LL + EPOCH_BIAS;
	return ul;
}

static LARGE_INTEGER FileTimeToUL(FILETIME fileTime)
{
	LARGE_INTEGER lFileTime;
	lFileTime.QuadPart = fileTime.dwHighDateTime;
	lFileTime.QuadPart = (lFileTime.QuadPart << 32) | fileTime.dwLowDateTime;
	return lFileTime;
}

static void display(const char *txt,SYSTEMTIME systime)
{
	FILETIME fileTime;
	BOOL ret = SystemTimeToFileTime(&systime,&fileTime);
	assert(ret == TRUE);
	LARGE_INTEGER ulFileTime = FileTimeToUL(fileTime);
	
	const char * day="";
	switch (systime.wDayOfWeek)
	{
        	case 0:day = "Sunday";break;
        	case 1:day = "Monday";break;
        	case 2:day = "Tuesday";break;
        	case 3:day = "Wednesday";break;
        	case 4:day = "Thursday";break;
        	case 5:day = "Friday";break;
        	case 6:day = "Saturday";break;
	}
	g_StdOut<< txt << day << " " 
		<< (int)systime.wYear << "/" <<  (int)systime.wMonth << "/" << (int)systime.wDay << " "
		<< (int)systime.wHour << ":" << (int)systime.wMinute << ":" <<  (int)systime.wSecond << ":" 
        	<<     (int)systime.wMilliseconds
		<< " (" << (UInt64)ulFileTime.QuadPart << ")\n";
}

static void test_time()
{
	time_t tps_unx = time(0);

	printf("Test Time (1):\n");
	printf("===========\n");
	SYSTEMTIME systimeGM;
	GetSystemTime(&systimeGM);
	
	LARGE_INTEGER ul = UnixTimeToUL(tps_unx);
	g_StdOut<<"  unix time = " << (UInt64)tps_unx << " (" << (UInt64)ul.QuadPart << ")\n";

	g_StdOut<<"  gmtime    : " << asctime(gmtime(&tps_unx))<<"\n";
	g_StdOut<<"  localtime : " << asctime(localtime(&tps_unx))<<"\n";

	display("  GetSystemTime : ", systimeGM);
}

static void test_time2()
{
        UInt32 dosTime = 0x30d0094C;
        FILETIME utcFileTime;
        FILETIME localFileTime;
        FILETIME localFileTime2;
        UInt32 dosTime2 = 0;

        printf("Test Time (2):\n");
        printf("===========\n");
        NTime::DosTimeToFileTime(dosTime, localFileTime);
        NTime::FileTimeToDosTime(localFileTime, dosTime2);
        assert(dosTime == dosTime2);

        printf("Test Time (3):\n");
	printf("===========\n");
	/* DosTime To utcFileTime */

	if (NTime::DosTimeToFileTime(dosTime, localFileTime)) /* DosDateTimeToFileTime */
	{
		if (!LocalFileTimeToFileTime(&localFileTime, &utcFileTime))
			utcFileTime.dwHighDateTime = utcFileTime.dwLowDateTime = 0;
	}

	printf("  - 0x%x => 0x%x 0x%x => 0x%x 0x%x\n",(unsigned)dosTime,
		(unsigned)localFileTime.dwHighDateTime,(unsigned)localFileTime.dwLowDateTime,
		(unsigned)utcFileTime.dwHighDateTime,(unsigned)utcFileTime.dwLowDateTime);


	/* utcFileTime to DosTime */

        FileTimeToLocalFileTime(&utcFileTime, &localFileTime2);
        NTime::FileTimeToDosTime(localFileTime2, dosTime2);  /* FileTimeToDosDateTime */

	printf("  - 0x%x <= 0x%x 0x%x <= 0x%x 0x%x\n",(unsigned)dosTime2,
		(unsigned)localFileTime2.dwHighDateTime,(unsigned)localFileTime2.dwLowDateTime,
		(unsigned)utcFileTime.dwHighDateTime,(unsigned)utcFileTime.dwLowDateTime);

	assert(dosTime == dosTime2);
	assert(localFileTime.dwHighDateTime == localFileTime2.dwHighDateTime);
	assert(localFileTime.dwLowDateTime  == localFileTime2.dwLowDateTime);
}

static void test_semaphore()
{
	g_StdOut << "\nTEST SEMAPHORE :\n";

	NWindows::NSynchronization::CSynchro sync;
	NWindows::NSynchronization::CSemaphoreWFMO sema;
	bool bres;
	DWORD waitResult;
	int i;

	sync.Create();
	sema.Create(&sync,2,10);

	g_StdOut << "   - Release(1)\n";
	for(i = 0 ;i < 8;i++)
	{
		// g_StdOut << "     - Release(1) : "<< i << "\n";
		bres = sema.Release(1);
		assert(bres == S_OK);
	}
	// g_StdOut << "     - Release(1) : done\n";
	bres = sema.Release(1);
	assert(bres == S_FALSE);

	g_StdOut << "   - WaitForMultipleObjects(INFINITE)\n";
	HANDLE events[1] = { sema };
	for(i=0;i<10;i++)
	{
		waitResult = ::WaitForMultipleObjects(1, events, FALSE, INFINITE);
		assert(waitResult == WAIT_OBJECT_0);
	}

	g_StdOut << "   Done\n";
}


/****************************************************************************************/


static int threads_count = 0;

static THREAD_FUNC_RET_TYPE thread_fct(void *  /* param */ ) {
	threads_count++;
	return 0;
}

#define MAX_THREADS 100000

int test_thread(void) {
	::CThread thread;

	Thread_Construct(&thread);

	threads_count = 0;
	
	printf("test_thread : %d threads\n",MAX_THREADS);

	for(int i=0;i<MAX_THREADS;i++) {
		Thread_Create(&thread, thread_fct, 0); 

		Thread_Wait(&thread);

		Thread_Close(&thread);
	}

	assert(threads_count == MAX_THREADS);

	return 0;
}


void dumpStr(const char *title,const char *txt)
{
  size_t i,len = strlen(txt);

  printf("%s - %d :",title,(int)len);

  for(i  = 0 ; i<len;i++) {
    printf(" 0x%02x",(unsigned)(txt[i] & 255)); 
  }

  printf("\n");
}


void dumpWStr(const char *title,const wchar_t *txt)
{
  size_t i,len = wcslen(txt);

  printf("%s - %d :",title,(int)len);

  for(i  = 0 ; i<len;i++) {
    printf(" 0x%02x",(unsigned)(txt[i])); 
  }

  printf("\n");
}

#ifdef __APPLE_CC__

void  testMaxOSX_stringConvert()
{
/*
                         0xE8, // latin small letter e with grave
                         0xE9, // latin small letter e with acute
                         L'a',
                         0xE0, // latin small letter a with grave
                         0x20AC, // euro sign
*/
   struct
   {
     char astr [256];
     wchar_t ustr [256];
   }
   tab [] =
   {
      {
      //   'a' , 'e with acute'       , 'e with grave'     ,  'a with grave'    ,  'u with grave'    ,  'b' , '.'  ,  't' , 'x'  , 't'  
         { 0x61,  0x65,  0xcc,  0x81  ,  0x65,  0xcc,  0x80,  0x61,  0xcc,  0x80,  0x75,  0xcc,  0x80,  0x62,  0x2e,  0x74,  0x78, 0x74,  0 },
         { 0x61,  0xe9,                  0xe8,                0xe0,                0xf9,                0x62,  0x2e,  0x74,  0x78, 0x74, 0 }
      },
      {
      //   'a' , 'euro sign'        ,  'b' , '.'  ,  't' , 'x'  , 't'  , '\n' 
         { 0x61,  0xe2,  0x82,  0xac,  0x62,  0x2e,  0x74,  0x78,  0x74,  0x0a, 0 },
         { 0x61,  0x20AC,              0x62,  0x2e,  0x74,  0x78,  0x74,  0x0a, 0 }  
      },
      {
         { 0 },
         { 0 }
      }
   };

   int i;

   printf("testMaxOSX_stringConvert : \n");

   i = 0;
   while (tab[i].astr[0])
   {
     printf("  %s\n",tab[i].astr);

     UString ustr = GetUnicodeString(tab[i].astr);

     // dumpWStr("1",&ustr[0]);

     assert(MyStringCompare(&ustr[0],tab[i].ustr) == 0);
     assert(ustr.Len() == wcslen(tab[i].ustr) );


     AString astr = GetAnsiString(ustr);
     assert(MyStringCompare(&astr[0],tab[i].astr) == 0);
     assert(astr.Len() == strlen(tab[i].astr) );

     i++;
   }
}

void  testMacOSX()
{
//  char texte1[]= { 0xc3 , 0xa9  , 0xc3, 0xa0, 0};

  wchar_t wpath1[4096] = {
                         0xE9, // latin small letter e with acute
                         0xE0,
                         0xc7,
                         0x25cc,
                         0x327,
                         0xe4,
                         0xe2,
                         0xc2,
                         0xc3,
                         0x2e,
                         0x74,
                         0x78,
                         0x74,
/*
                         L'e',
                         0xE8, // latin small letter e with grave
                         0xE9, // latin small letter e with acute
                         L'a',
                         0xE0, // latin small letter a with grave
                         0x20AC, // euro sign
                         L'b',
*/
                         0 };

    char utf8[4096];
    wchar_t wpath2[4096];



 // dumpStr("UTF8 standart",texte1);

    dumpWStr("UCS32 standard",wpath1);

// Translate into FS pathname
 {
    const wchar_t * wcs = wpath1;

    UniChar unipath[4096];

    long n = wcslen(wcs);

    for(long i =   0 ; i<= n ;i++) {
      unipath[i] = wcs[i];
    }

    CFStringRef cfpath = CFStringCreateWithCharacters(NULL,unipath,n);

    CFMutableStringRef cfpath2 = CFStringCreateMutableCopy(NULL,0,cfpath);
    CFRelease(cfpath);
    CFStringNormalize(cfpath2,kCFStringNormalizationFormD);
    
    CFStringGetCString(cfpath2,(char *)utf8,4096,kCFStringEncodingUTF8);

    CFRelease(cfpath2);  
  }

  dumpStr("UTF8 MacOSX",utf8);

// Translate from FS pathname
 {
    const char * path = utf8;

    long n = strlen(path);

    CFStringRef cfpath = CFStringCreateWithCString(NULL,path,kCFStringEncodingUTF8);

    if (cfpath)
    {

       CFMutableStringRef cfpath2 = CFStringCreateMutableCopy(NULL,0,cfpath);
       CFRelease(cfpath);
       CFStringNormalize(cfpath2,kCFStringNormalizationFormC);
    
       n = CFStringGetLength(cfpath2);
       for(long i =   0 ; i<= n ;i++) {
         wpath2[i] = CFStringGetCharacterAtIndex(cfpath2,i);
       }
       wpath2[n] = 0;

       CFRelease(cfpath2);  
    }
    else
    {
       wpath2[0] = 0;
    }
  }

  dumpWStr("UCS32 standard (2)",wpath2);

/*
 {
   CFStringRef cfpath;

    cfpath = CFStringCreateWithCString(kCFAllocatorDefault, texte1, kCFStringEncodingUTF8);

    // TODO str = null ?

    CFMutableStringRef cfpath2 = CFStringCreateMutableCopy(NULL,0,cfpaht);
    CFRealease(cfpath);

    

    
  }
*/


}
#endif // __APPLE_CC__


static const TCHAR *kMainDll = TEXT("7z.dll");

static CSysString ConvertUInt32ToString(UInt32 value)
{
  TCHAR buffer[32];
  ConvertUInt32ToString(value, buffer);
  return buffer;
}


void test_csystring(void)
{
	{
		const CSysString baseFolder = TEXT("bin/");
		const CSysString b2 = baseFolder + kMainDll;

		assert(MyStringCompare(&b2[0],TEXT("bin/7z.dll")) == 0);
	}

	{
		LPCTSTR dirPath=TEXT("/tmp/");
		LPCTSTR prefix=TEXT("foo");
		CSysString resultPath;

		UINT   number = 12345;
		UInt32 count  = 6789;
		
/*
		TCHAR * buf = resultPath.GetBuffer(MAX_PATH);
		::swprintf(buf,MAX_PATH,L"%ls%ls#%d@%d.tmp",dirPath,prefix,(unsigned)number,count);
		buf[MAX_PATH-1]=0;
		resultPath.ReleaseBuffer();
*/
		resultPath  = dirPath;
		resultPath += prefix;
		resultPath += TEXT('#');
		resultPath += ConvertUInt32ToString(number);
		resultPath += TEXT('@');
		resultPath += ConvertUInt32ToString(count);
		resultPath += TEXT(".tmp");

		// printf("##%ls##\n",&resultPath[0]);

		assert(MyStringCompare(&resultPath[0],TEXT("/tmp/foo#12345@6789.tmp")) == 0);
	}
	
}

static void  test_AString()
{
   AString a;

   a = "abc";
   assert(MyStringCompare(&a[0],"abc") == 0);
   assert(a.Len() == 3);

   a = GetAnsiString(L"abc");
   assert(MyStringCompare(&a[0],"abc") == 0);
   assert(a.Len() == 3);
}


const TCHAR kAnyStringWildcard = '*';

static void test_UString2(const UString &phyPrefix)
{
  UString tmp = phyPrefix + wchar_t(kAnyStringWildcard);
  printf("Enum(%ls-%ls-%lc)\n",&tmp[0],&phyPrefix[0],wchar_t(kAnyStringWildcard));
}



static void test_UString()
{
  UString us = L"7za433_tar";

   test_UString2(L"7za433_tar");

   UString u1(us);
   test_UString2(u1);
   u1 = L"";
   test_UString2(u1);
   u1 = us;
   test_UString2(u1);

   UString u2 = us;
   test_UString2(u2);
   u2 = L"";
   test_UString2(u2);
   u2 = u1;
   test_UString2(u2);

   u1 = L"abc";
   assert(MyStringCompare(&u1[0],L"abc") == 0);
   assert(u1.Len() == 3);

   u1 = GetUnicodeString("abc");
   assert(MyStringCompare(&u1[0],L"abc") == 0);
   assert(u1.Len() == 3);
}

/****************************************************************************************/
int main() {

  // return test_thread();


#ifdef ENV_HAVE_LOCALE
  setlocale(LC_ALL,"");
#endif

#if defined(BIG_ENDIAN)
  printf("BIG_ENDIAN : %d\n",(int)BIG_ENDIAN);
#endif
#if defined(LITTLE_ENDIAN)
  printf("LITTLE_ENDIAN : %d\n",(int)LITTLE_ENDIAN);
#endif

  printf("sizeof(Byte)   : %d\n",(int)sizeof(Byte));
  printf("sizeof(UInt16) : %d\n",(int)sizeof(UInt16));
  printf("sizeof(UInt32) : %d\n",(int)sizeof(UInt32));
  printf("sizeof(UINT32) : %d\n",(int)sizeof(UINT32));
  printf("sizeof(UInt64) : %d\n",(int)sizeof(UInt64));
  printf("sizeof(UINT64) : %d\n",(int)sizeof(UINT64));
  printf("sizeof(void *) : %d\n",(int)sizeof(void *));
  printf("sizeof(size_t) : %d\n",(int)sizeof(size_t));
  printf("sizeof(ptrdiff_t) : %d\n",(int)sizeof(ptrdiff_t));
  printf("sizeof(off_t) : %d\n",(int)sizeof(off_t));
  printf("sizeof(wchar_t) : %d\n",(int)sizeof(wchar_t));
#ifdef __APPLE_CC__
  printf("sizeof(UniChar) : %d\n",(int)sizeof(UniChar));
#endif
  printf("sizeof(CPpmd_See) : %d\n",(int)sizeof(CPpmd_See));
  printf("sizeof(CPpmd_State) : %d\n",(int)sizeof(CPpmd_State));

  // size tests
  assert(sizeof(Byte)==1);
  assert(sizeof(UInt16)==2);
  assert(sizeof(UInt32)==4);
  assert(sizeof(UINT32)==4);
  assert(sizeof(UInt64)==8);
  assert(sizeof(UINT64)==8);

  // alignement tests
  assert(sizeof(CPpmd_See)==4);
  assert(sizeof(CPpmd_State)==6);

  union {
	Byte b[2];
	UInt16 s;
  } u;
  u.s = 0x1234;

  if ((u.b[0] == 0x12) && (u.b[1] == 0x34)) {
    printf("CPU : big endian\n");
  } else if ((u.b[0] == 0x34) && (u.b[1] == 0x12)) {
    printf("CPU : little endian\n");
  } else {
    printf("CPU : unknown endianess\n");
  }

#if  defined(ENV_HAVE_WCHAR__H) && defined(ENV_HAVE_MBSTOWCS) && defined(ENV_HAVE_WCSTOMBS)
  test_mbs();
  test_mbs_2();
#endif

  test_astring(12345);
  test_split_astring();

  test_csystring();
  test_AString();
  test_UString();

  test_time();

  test_time2();

  test_semaphore();

#ifdef __APPLE_CC__
  testMacOSX();
  testMaxOSX_stringConvert();
#endif


{
	LANGID langID;
	WORD primLang;
	WORD subLang;

	langID = GetUserDefaultLangID();
	printf("langID=0x%x\n",langID);

	primLang = (WORD)(PRIMARYLANGID(langID));
	subLang = (WORD)(SUBLANGID(langID));

	printf("primLang=%d subLang=%d\n",(unsigned)primLang,(unsigned)subLang);  
}

  printf("\n### All Done ###\n\n");

  return 0;
}


#include "StdAfx.h"

#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <wchar.h>
#include <ctype.h>
#include <string.h>

#ifdef __APPLE__
#define  UInt32 mac_UInt32
#include <CoreFoundation/CoreFoundation.h>
#undef  UInt32
#endif // __APPLE__


// #define TRACE printf

typedef DWORD LCID;
typedef void * ULONG_PTR; /* typedef unsigned long ULONG_PTR; */

#define SORT_DEFAULT        0x0

#define LANG_NEUTRAL        0x00
#define LANG_ENGLISH        0x09

#define SUBLANG_DEFAULT     0x01    /* user default */

#define MAKELCID(l, s)       ( (l & 0xFFFF) | ((s & 0xFFFF)<<16))
#define MAKELANGID(p, s)     ((((WORD)(s))<<10) | (WORD)(p))

#define LANGIDFROMLCID(lcid) ((WORD)(lcid))

static LCID lcid_LC_MESSAGES = 0;
static LCID lcid_LC_CTYPE = 0;

struct locale_name
{
    WCHAR  win_name[128];   /* Windows name ("en-US") */
    WCHAR  lang[128];       /* language ("en") (note: buffer contains the other strings too) */
    WCHAR *country;         /* country ("US") */
    WCHAR *charset;         /* charset ("UTF-8") for Unix format only */
    WCHAR *script;          /* script ("Latn") for Windows format only */
    WCHAR *modifier;        /* modifier or sort order */
    LCID   lcid;            /* corresponding LCID */
    int    matches;         /* number of elements matching LCID (0..4) */
    UINT   codepage;        /* codepage corresponding to charset */
};
#define WINE_UNICODE_INLINE static

/***********************************************************/
typedef struct {
	const WCHAR * LOCALE_SNAME;
	const WCHAR * LOCALE_SISO639LANGNAME;
	const WCHAR * LOCALE_SISO3166CTRYNAME;
	unsigned int  LOCALE_IDEFAULTUNIXCODEPAGE;
	unsigned int  LOCALE_ILANGUAGE;
} t_info;

static t_info g_langInfo[] = {
	{ L"af-ZA" , L"af" , L"ZA" , 28591 , 0x0436 },  /* afk.nls */
	{ L"ar-SA" , L"ar" , L"SA" , 28596 , 0x0401 },  /* ara.nls */
	{ L"ar-LB" , L"ar" , L"LB" , 28596 , 0x3001 },  /* arb.nls */
	{ L"ar-EG" , L"ar" , L"EG" , 28596 , 0x0c01 },  /* are.nls */
	{ L"ar-DZ" , L"ar" , L"DZ" , 28596 , 0x1401 },  /* arg.nls */
	{ L"ar-BH" , L"ar" , L"BH" , 28596 , 0x3c01 },  /* arh.nls */
	{ L"ar-IQ" , L"ar" , L"IQ" , 28596 , 0x0801 },  /* ari.nls */
	{ L"ar-JO" , L"ar" , L"JO" , 28596 , 0x2c01 },  /* arj.nls */
	{ L"ar-KW" , L"ar" , L"KW" , 28596 , 0x3401 },  /* ark.nls */
	{ L"ar-LY" , L"ar" , L"LY" , 28596 , 0x1001 },  /* arl.nls */
	{ L"ar-MA" , L"ar" , L"MA" , 28596 , 0x1801 },  /* arm.nls */
	{ L"ar-OM" , L"ar" , L"OM" , 28596 , 0x2001 },  /* aro.nls */
	{ L"ar-QA" , L"ar" , L"QA" , 28596 , 0x4001 },  /* arq.nls */
	{ L"ar-SY" , L"ar" , L"SY" , 28596 , 0x2801 },  /* ars.nls */
	{ L"ar-TN" , L"ar" , L"TN" , 28596 , 0x1c01 },  /* art.nls */
	{ L"ar-AE" , L"ar" , L"AE" , 28596 , 0x3801 },  /* aru.nls */
	{ L"ar-YE" , L"ar" , L"YE" , 28596 , 0x2401 },  /* ary.nls */
	{ L"az-AZ" , L"az" , L"AZ" , 28595 , 0x082c },  /* aze.nls */
	{ L"az-Latn-AZ" , L"az" , L"AZ" , 28599 , 0x042c },  /* azl.nls */
	{ L"be-BY" , L"be" , L"BY" , 1251 , 0x0423 },  /* bel.nls */
	{ L"bg-BG" , L"bg" , L"BG" , 1251 , 0x0402 },  /* bgr.nls */
	{ L"br-FR" , L"br" , L"FR" , 28605 , 0x0493 },  /* brf.nls */
	{ L"ca-ES" , L"ca" , L"ES" , 28605 , 0x0403 },  /* cat.nls */
	{ L"zh-CN" , L"zh" , L"CN" , 936 , 0x0804 },  /* chs.nls */
	{ L"zh-TW" , L"zh" , L"TW" , 950 , 0x0404 },  /* cht.nls */
	{ L"kw-GB" , L"kw" , L"GB" , 28605 , 0x04891 },  /* cor.nls */
	{ L"cs-CZ" , L"cs" , L"CZ" , 28592 , 0x0405 },  /* csy.nls */
	{ L"cy-GB" , L"cy" , L"GB" , 28604 , 0x0492 },  /* cym.nls */
	{ L"da-DK" , L"da" , L"DK" , 28605 , 0x0406 },  /* dan.nls */
	{ L"de-AT" , L"de" , L"AT" , 28605 , 0x0c07 },  /* dea.nls */
	{ L"de-LI" , L"de" , L"LI" , 28605 , 0x1407 },  /* dec.nls */
	{ L"de-LU" , L"de" , L"LU" , 28605 , 0x1007 },  /* del.nls */
	{ L"de-CH" , L"de" , L"CH" , 28605 , 0x0807 },  /* des.nls */
	{ L"de-DE" , L"de" , L"DE" , 28605 , 0x0407 },  /* deu.nls */
	{ L"dv-MV" , L"dv" , L"MV" , 65001 , 0x0465 },  /* div.nls */
	{ L"el-GR" , L"el" , L"GR" , 28597 , 0x0408 },  /* ell.nls */
	{ L"en-AU" , L"en" , L"AU" , 28591 , 0x0c09 },  /* ena.nls */
	{ L"en-CB" , L"en" , L"CB" , 28591 , 0x2409 },  /* enb.nls */
	{ L"en-CA" , L"en" , L"CA" , 28591 , 0x1009 },  /* enc.nls */
	{ L"en-GB" , L"en" , L"GB" , 28605 , 0x0809 },  /* eng.nls */
	{ L"en-IE" , L"en" , L"IE" , 28605 , 0x1809 },  /* eni.nls */
	{ L"en-JM" , L"en" , L"JM" , 28591 , 0x2009 },  /* enj.nls */
	{ L"en-BZ" , L"en" , L"BZ" , 28591 , 0x2809 },  /* enl.nls */
	{ L"en-PH" , L"en" , L"PH" , 28591 , 0x3409 },  /* enp.nls */
	{ L"en-ZA" , L"en" , L"ZA" , 28591 , 0x1c09 },  /* ens.nls */
	{ L"en-TT" , L"en" , L"TT" , 28591 , 0x2c09 },  /* ent.nls */
	{ L"en-US" , L"en" , L"US" , 28591 , 0x0409 },  /* enu.nls */
	{ L"en-ZW" , L"en" , L"ZW" , 28591 , 0x3009 },  /* enw.nls */
	{ L"en-NZ" , L"en" , L"NZ" , 28591 , 0x1409 },  /* enz.nls */
	{ L"eo" , L"eo" , L"" , 65001 , 0x048f },  /* eox.nls */
	{ L"es-PA" , L"es" , L"PA" , 28591 , 0x180a },  /* esa.nls */
	{ L"es-BO" , L"es" , L"BO" , 28591 , 0x400a },  /* esb.nls */
	{ L"es-CR" , L"es" , L"CR" , 28591 , 0x140a },  /* esc.nls */
	{ L"es-DO" , L"es" , L"DO" , 28591 , 0x1c0a },  /* esd.nls */
	{ L"es-SV" , L"es" , L"SV" , 28591 , 0x440a },  /* ese.nls */
	{ L"es-EC" , L"es" , L"EC" , 28591 , 0x300a },  /* esf.nls */
	{ L"es-GT" , L"es" , L"GT" , 28591 , 0x100a },  /* esg.nls */
	{ L"es-HN" , L"es" , L"HN" , 28591 , 0x480a },  /* esh.nls */
	{ L"es-NI" , L"es" , L"NI" , 28591 , 0x4c0a },  /* esi.nls */
	{ L"es-C" , L"es" , L"C" , 28591 , 0x340a },  /* esl.nls */
	{ L"es-MX" , L"es" , L"MX" , 28591 , 0x080a },  /* esm.nls */
	{ L"es-ES_modern" , L"es" , L"ES" , 28605 , 0x0c0a },  /* esn.nls */
	{ L"es-CO" , L"es" , L"CO" , 28591 , 0x240a },  /* eso.nls */
	{ L"es-ES" , L"es" , L"ES" , 28605 , 0x040a },  /* esp.nls */
	{ L"es-PE" , L"es" , L"PE" , 28591 , 0x280a },  /* esr.nls */
	{ L"es-AR" , L"es" , L"AR" , 28591 , 0x2c0a },  /* ess.nls */
	{ L"es-PR" , L"es" , L"PR" , 28591 , 0x500a },  /* esu.nls */
	{ L"es-VE" , L"es" , L"VE" , 28591 , 0x200a },  /* esv.nls */
	{ L"es-UY" , L"es" , L"UY" , 28591 , 0x380a },  /* esy.nls */
	{ L"es-PY" , L"es" , L"PY" , 28591 , 0x3c0a },  /* esz.nls */
	{ L"et-EE" , L"et" , L"EE" , 28605 , 0x0425 },  /* eti.nls */
	{ L"eu-ES" , L"eu" , L"ES" , 28605 , 0x042d },  /* euq.nls */
	{ L"fa-IR" , L"fa" , L"IR" , 65001 , 0x0429 },  /* far.nls */
	{ L"fi-FI" , L"fi" , L"FI" , 28605 , 0x040b },  /* fin.nls */
	{ L"fo-FO" , L"fo" , L"FO" , 28605 , 0x0438 },  /* fos.nls */
	{ L"fr-FR" , L"fr" , L"FR" , 28605 , 0x040c },  /* fra.nls */
	{ L"fr-BE" , L"fr" , L"BE" , 28605 , 0x080c },  /* frb.nls */
	{ L"fr-CA" , L"fr" , L"CA" , 28591 , 0x0c0c },  /* frc.nls */
	{ L"fr-LU" , L"fr" , L"LU" , 28605 , 0x140c },  /* frl.nls */
	{ L"fr-MC" , L"fr" , L"MC" , 28605 , 0x180c },  /* frm.nls */
	{ L"fr-CH" , L"fr" , L"CH" , 28605 , 0x100c },  /* frs.nls */
	{ L"ga-IE" , L"ga" , L"IE" , 28605 , 0x043c },  /* gae.nls */
	{ L"gd-GB" , L"gd" , L"GB" , 28605 , 0x083c },  /* gdh.nls */
	{ L"gv-GB" , L"gv" , L"GB" , 28605 , 0x0c3c },  /* gdv.nls */
	{ L"gl-ES" , L"gl" , L"ES" , 28605 , 0x0456 },  /* glc.nls */
	{ L"gu-IN" , L"gu" , L"IN" , 65001 , 0x0447 },  /* guj.nls */
	{ L"he-I" , L"he" , L"I" , 28598 , 0x040d },  /* heb.nls */
	{ L"hi-IN" , L"hi" , L"IN" , 65001 , 0x0439 },  /* hin.nls */
	{ L"hr-HR" , L"hr" , L"HR" , 28592 , 0x041a },  /* hrv.nls */
	{ L"hu-HU" , L"hu" , L"HU" , 28592 , 0x040e },  /* hun.nls */
	{ L"hy-AM" , L"hy" , L"AM" , 65001 , 0x042b },  /* hye.nls */
	{ L"id-ID" , L"id" , L"ID" , 28591 , 0x0421 },  /* ind.nls */
	{ L"is-IS" , L"is" , L"IS" , 28605 , 0x040f },  /* isl.nls */
	{ L"it-IT" , L"it" , L"IT" , 28605 , 0x0410 },  /* ita.nls */
	{ L"it-CH" , L"it" , L"CH" , 28605 , 0x0810 },  /* its.nls */
	{ L"ja-JP" , L"ja" , L"JP" , 20932 , 0x0411 },  /* jpn.nls */
	{ L"kn-IN" , L"kn" , L"IN" , 65001 , 0x044b },  /* kan.nls */
	{ L"ka-GE" , L"ka" , L"GE" , 65001 , 0x0437 },  /* kat.nls */
	{ L"kk-KZ" , L"kk" , L"KZ" , 28595 , 0x043f },  /* kkz.nls */
	{ L"kok-IN" , L"kok" , L"IN" , 65001 , 0x0457 },  /* knk.nls */
	{ L"ko-KR" , L"ko" , L"KR" , 949 , 0x0412 },  /* kor.nls */
	{ L"ky-KG" , L"ky" , L"KG" , 28595 , 0x0440 },  /* kyr.nls */
	{ L"lt-LT" , L"lt" , L"LT" , 28603 , 0x0427 },  /* lth.nls */
	{ L"lv-LV" , L"lv" , L"LV" , 28603 , 0x0426 },  /* lvi.nls */
	{ L"mr-IN" , L"mr" , L"IN" , 65001 , 0x044e },  /* mar.nls */
	{ L"mk-MK" , L"mk" , L"MK" , 28595 , 0x042f },  /* mki.nls */
	{ L"mn-MN" , L"mn" , L"MN" , 28595 , 0x0450 },  /* mon.nls */
	{ L"ms-BN" , L"ms" , L"BN" , 28591 , 0x083e },  /* msb.nls */
	{ L"ms-MY" , L"ms" , L"MY" , 28591 , 0x043e },  /* msl.nls */
	{ L"nl-BE" , L"nl" , L"BE" , 28605 , 0x0813 },  /* nlb.nls */
	{ L"nl-N" , L"nl" , L"N" , 28605 , 0x0413 },  /* nld.nls */
	{ L"nl-SR" , L"nl" , L"SR" , 28605 , 0x0c13 },  /* nls.nls */
	{ L"nn-NO" , L"nn" , L"NO" , 28605 , 0x0814 },  /* non.nls */
	{ L"nb-NO" , L"nb" , L"NO" , 28605 , 0x0414 },  /* nor.nls */
	{ L"pa-IN" , L"pa" , L"IN" , 65001 , 0x0446 },  /* pan.nls */
	{ L"pl-P" , L"pl" , L"P" , 28592 , 0x0415 },  /* plk.nls */
	{ L"pt-BR" , L"pt" , L"BR" , 28591 , 0x0416 },  /* ptb.nls */
	{ L"pt-PT" , L"pt" , L"PT" , 28605 , 0x0816 },  /* ptg.nls */
	{ L"rm-CH" , L"rm" , L"CH" , 28605 , 0x0417 },  /* rmc.nls */
	{ L"ro-RO" , L"ro" , L"RO" , 28592 , 0x0418 },  /* rom.nls */
	{ L"ru-RU" , L"ru" , L"RU" , 20866 , 0x0419 },  /* rus.nls */
	{ L"sa-IN" , L"sa" , L"IN" , 65001 , 0x044f },  /* san.nls */
	{ L"sk-SK" , L"sk" , L"SK" , 28592 , 0x041b },  /* sky.nls */
	{ L"sl-SI" , L"sl" , L"SI" , 28592 , 0x0424 },  /* slv.nls */
	{ L"sq-A" , L"sq" , L"A" , 28592 , 0x041c },  /* sqi.nls */
	{ L"sr-SP" , L"sr" , L"SP" , 28595 , 0x0c1a },  /* srb.nls */
	{ L"sr-Latn-SP" , L"sr" , L"SP" , 28592 , 0x081a },  /* srl.nls */
	{ L"sv-SE" , L"sv" , L"SE" , 28605 , 0x041d },  /* sve.nls */
	{ L"sv-FI" , L"sv" , L"FI" , 28605 , 0x081d },  /* svf.nls */
	{ L"sw-KE" , L"sw" , L"KE" , 28591 , 0x0441 },  /* swk.nls */
	{ L"syr-SY" , L"syr" , L"SY" , 65001 , 0x045a },  /* syr.nls */
	{ L"ta-IN" , L"ta" , L"IN" , 65001 , 0x0449 },  /* tam.nls */
	{ L"te-IN" , L"te" , L"IN" , 65001 , 0x044a },  /* tel.nls */
	{ L"th-TH" , L"th" , L"TH" , 874 , 0x041e },  /* tha.nls */
	{ L"tr-TR" , L"tr" , L"TR" , 28599 , 0x041f },  /* trk.nls */
	{ L"tt-TA" , L"tt" , L"TA" , 28595 , 0x0444 },  /* ttt.nls */
	{ L"uk-UA" , L"uk" , L"UA" , 21866 , 0x0422 },  /* ukr.nls */
	{ L"ur-PK" , L"ur" , L"PK" , 1256 , 0x0420 },  /* urd.nls */
	{ L"uz-UZ" , L"uz" , L"UZ" , 28595 , 0x0843 },  /* uzb.nls */
	{ L"uz-Latn-UZ" , L"uz" , L"UZ" , 28605 , 0x0443 },  /* uzl.nls */
	{ L"vi-VN" , L"vi" , L"VN" , 1258 , 0x042a },  /* vit.nls */
	{ L"wa-BE" , L"wa" , L"BE" , 28605 , 0x0490 },  /* wal.nls */
	{ L"zh-HK" , L"zh" , L"HK" , 950 , 0x0c04 },  /* zhh.nls */
	{ L"zh-SG" , L"zh" , L"SG" , 936 , 0x1004 },  /* zhi.nls */
	{ L"zh-MO" , L"zh" , L"MO" , 950 , 0x1404 },  /* zhm.nls */
	{ 0 , 0 , 0 , 0, 0 }
};

/***********************************************************/
WINE_UNICODE_INLINE WCHAR *strchrW( const WCHAR *str, WCHAR ch )
{
    do { if (*str == ch) return (WCHAR *)(ULONG_PTR)str; } while (*str++);
    return NULL;
}

WINE_UNICODE_INLINE WCHAR *strpbrkW( const WCHAR *str, const WCHAR *accept )
{
    for ( ; *str; str++) if (strchrW( accept, *str )) return (WCHAR *)(ULONG_PTR)str;
    return NULL;
}


/***********************************************************/

WINE_UNICODE_INLINE unsigned int strlenW( const WCHAR *str )
{
    const WCHAR *s = str;
    while (*s) s++;
    return s - str;
}

WINE_UNICODE_INLINE WCHAR *strcpyW( WCHAR *dst, const WCHAR *src )
{
    WCHAR *p = dst;
    while ((*p++ = *src++));
    return dst;
}

WINE_UNICODE_INLINE WCHAR *strcatW( WCHAR *dst, const WCHAR *src )
{
    strcpyW( dst + strlenW(dst), src );
    return dst;
}

WINE_UNICODE_INLINE int strcmpW( const WCHAR *str1, const WCHAR *str2 )
{
    while (*str1 && (*str1 == *str2)) { str1++; str2++; }
    return *str1 - *str2;
}


WINE_UNICODE_INLINE LPWSTR lstrcpynW( LPWSTR dst, LPCWSTR src, int n )
{
    {
        LPWSTR d = dst;
        LPCWSTR s = src;
        UINT count = n;

        while ((count > 1) && *s)
        {
            count--;
            *d++ = *s++;
        }
        if (count) *d = 0;
    }
    return dst;
}

/* Copy Ascii string to Unicode without using codepages */
static inline void strcpynAtoW( WCHAR *dst, const char *src, size_t n )
{
    while (n > 1 && *src)
    {
        *dst++ = (unsigned char)*src++;
        n--;
    }
    if (n) *dst = 0;
}

/*******************************************************/

/* Charset to codepage map, sorted by name. */
static const struct charset_entry
{
    const char *charset_name;
    UINT        codepage;
} charset_names[] =
{
    { "BIG5", 950 },
    { "CP1250", 1250 },
    { "CP1251", 1251 },
    { "CP1252", 1252 },
    { "CP1253", 1253 },
    { "CP1254", 1254 },
    { "CP1255", 1255 },
    { "CP1256", 1256 },
    { "CP1257", 1257 },
    { "CP1258", 1258 },
    { "CP932", 932 },
    { "CP936", 936 },
    { "CP949", 949 },
    { "CP950", 950 },
    { "EUCJP", 20932 },
    { "GB2312", 936 },
    { "IBM037", 37 },
    { "IBM1026", 1026 },
    { "IBM424", 424 },
    { "IBM437", 437 },
    { "IBM500", 500 },
    { "IBM850", 850 },
    { "IBM852", 852 },
    { "IBM855", 855 },
    { "IBM857", 857 },
    { "IBM860", 860 },
    { "IBM861", 861 },
    { "IBM862", 862 },
    { "IBM863", 863 },
    { "IBM864", 864 },
    { "IBM865", 865 },
    { "IBM866", 866 },
    { "IBM869", 869 },
    { "IBM874", 874 },
    { "IBM875", 875 },
    { "ISO88591", 28591 },
    { "ISO885910", 28600 },
    { "ISO885913", 28603 },
    { "ISO885914", 28604 },
    { "ISO885915", 28605 },
    { "ISO885916", 28606 },
    { "ISO88592", 28592 },
    { "ISO88593", 28593 },
    { "ISO88594", 28594 },
    { "ISO88595", 28595 },
    { "ISO88596", 28596 },
    { "ISO88597", 28597 },
    { "ISO88598", 28598 },
    { "ISO88599", 28599 },
    { "KOI8R", 20866 },
    { "KOI8U", 21866 },
    { "UTF8", CP_UTF8 }
};

static int charset_cmp( const void *name, const void *entry )
{
    const struct charset_entry *charset = (const struct charset_entry *)entry;
    return strcasecmp( (const char *)name, charset->charset_name );
}

static UINT find_charset( const WCHAR *name )
{
    const struct charset_entry *entry;
    char charset_name[16];
    size_t i, j;

    /* remove punctuation characters from charset name */
    for (i = j = 0; name[i] && j < sizeof(charset_name)-1; i++)
        if (isalnum((unsigned char)name[i])) charset_name[j++] = name[i];
    charset_name[j] = 0;

    entry = (const struct charset_entry *)bsearch( charset_name, charset_names,
                     sizeof(charset_names)/sizeof(charset_names[0]),
                     sizeof(charset_names[0]), charset_cmp );
    if (entry) return entry->codepage;

    return 0;
}
/*******************************************************/

static BOOL find_locale_id_callback(/* LPCWSTR name, ? */ const t_info * tab,  struct locale_name *data)
{
    // WCHAR buffer[128];
    int matches = 0;
    WORD LangID = tab->LOCALE_ILANGUAGE & 0xFFFF; /* FIXME */
    LCID lcid = MAKELCID( LangID, SORT_DEFAULT );  /* FIXME: handle sort order */

    if (PRIMARYLANGID(LangID) == LANG_NEUTRAL) return TRUE; /* continue search */

    /* first check exact name */
    if (data->win_name[0] && tab->LOCALE_SNAME[0])
        /* GetLocaleInfoW( lcid, LOCALE_SNAME | LOCALE_NOUSEROVERRIDE,
                        buffer, sizeof(buffer)/sizeof(WCHAR) )) */
    {
        if (!strcmpW( data->win_name, tab->LOCALE_SNAME ))
        {
            matches = 4;  /* everything matches */
            goto done;
        }
    }

    /*if (!GetLocaleInfoW( lcid, LOCALE_SISO639LANGNAME | LOCALE_NOUSEROVERRIDE,
                         buffer, sizeof(buffer)/sizeof(WCHAR) )) */
    if (tab->LOCALE_SISO639LANGNAME[0] == 0)
        return TRUE;

    if (strcmpW( tab->LOCALE_SISO639LANGNAME , data->lang )) return TRUE;
    matches++;  /* language name matched */

    if (data->country)
    {
         /* if (GetLocaleInfoW( lcid, LOCALE_SISO3166CTRYNAME|LOCALE_NOUSEROVERRIDE,
                            buffer, sizeof(buffer)/sizeof(WCHAR) )) */
        if (tab->LOCALE_SISO3166CTRYNAME[0])
        {
            if (strcmpW(tab->LOCALE_SISO3166CTRYNAME , data->country )) goto done;
            matches++;  /* country name matched */
        }
    }
    else  /* match default language */
    {
        if (SUBLANGID(LangID) == SUBLANG_DEFAULT) matches++;
    }

    if (data->codepage)
    {
        UINT unix_cp;
        /* if (GetLocaleInfoW( lcid, LOCALE_IDEFAULTUNIXCODEPAGE | LOCALE_RETURN_NUMBER,
                            (LPWSTR)&unix_cp, sizeof(unix_cp)/sizeof(WCHAR) )) */
	unix_cp = tab->LOCALE_IDEFAULTUNIXCODEPAGE;
        {
            if (unix_cp == data->codepage) matches++;
        }
    }

    /* FIXME: check sort order */

done:
    if (matches > data->matches)
    {
        data->lcid = lcid;
        data->matches = matches;
    }
    return (data->matches < 4);  /* no need to continue for perfect match */
}


/***********************************************************************
 *		parse_locale_name
 *
 * Parse a locale name into a struct locale_name, handling both Windows and Unix formats.
 * Unix format is: lang[_country][.charset][@modifier]
 * Windows format is: lang[-script][-country][_modifier]
 */
static void parse_locale_name( const WCHAR *str, struct locale_name *name )
{
    static const WCHAR sepW[] = {'-','_','.','@',0};
    static const WCHAR winsepW[] = {'-','_',0};
    static const WCHAR posixW[] = {'P','O','S','I','X',0};
    static const WCHAR cW[] = {'C',0};
    static const WCHAR latinW[] = {'l','a','t','i','n',0};
    static const WCHAR latnW[] = {'-','L','a','t','n',0};
    WCHAR *p;
    int ind;

    // TRACE("%s\n", debugstr_w(str));

    name->country = name->charset = name->script = name->modifier = NULL;
    name->lcid = MAKELCID( MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), SORT_DEFAULT );
    name->matches = 0;
    name->codepage = 0;
    name->win_name[0] = 0;
    lstrcpynW( name->lang, str, sizeof(name->lang)/sizeof(WCHAR) );

    if (!(p = strpbrkW( name->lang, sepW )))
    {
        if (!strcmpW( name->lang, posixW ) || !strcmpW( name->lang, cW ))
        {
            name->matches = 4;  /* perfect match for default English lcid */
            return;
        }
        strcpyW( name->win_name, name->lang );
    }
    else if (*p == '-')  /* Windows format */
    {
        strcpyW( name->win_name, name->lang );
        *p++ = 0;
        name->country = p;
        if (!(p = strpbrkW( p, winsepW ))) goto done;
        if (*p == '-')
        {
            *p++ = 0;
            name->script = name->country;
            name->country = p;
            if (!(p = strpbrkW( p, winsepW ))) goto done;
        }
        *p++ = 0;
        name->modifier = p;
    }
    else  /* Unix format */
    {
        if (*p == '_')
        {
            *p++ = 0;
            name->country = p;
            p = strpbrkW( p, sepW + 2 );
        }
        if (p && *p == '.')
        {
            *p++ = 0;
            name->charset = p;
            p = strchrW( p, '@' );
        }
        if (p)
        {
            *p++ = 0;
            name->modifier = p;
        }

        if (name->charset)
            name->codepage = find_charset( name->charset );

        /* rebuild a Windows name if possible */

        if (name->charset) goto done;  /* can't specify charset in Windows format */
        if (name->modifier && strcmpW( name->modifier, latinW ))
            goto done;  /* only Latn script supported for now */
        strcpyW( name->win_name, name->lang );
        if (name->modifier) strcatW( name->win_name, latnW );
        if (name->country)
        {
            p = name->win_name + strlenW(name->win_name);
            *p++ = '-';
            strcpyW( p, name->country );
        }
    }
done:
    ;

/* DEBUG
    printf("EnumResourceLanguagesW(...):\n");
    printf("  name->win_name=%ls\n", name->win_name);
    printf("  name->lang=%ls\n", name->lang);
    printf("  name->country=%ls\n", name->country);
    printf("  name->codepage=%d\n", name->codepage);
*/
//    EnumResourceLanguagesW( kernel32_handle, (LPCWSTR)RT_STRING, (LPCWSTR)LOCALE_ILANGUAGE,
//                            find_locale_id_callback, (LPARAM)name );

    ind = 0;
    while (g_langInfo[ind].LOCALE_SNAME)
    {
	    BOOL ret = find_locale_id_callback(&g_langInfo[ind],name);
	    if (ret == FALSE) 
		    break;

	    ind++;
    }
}




/********************************/

static UINT setup_unix_locales(void)
{
    struct locale_name locale_name;
    // WCHAR buffer[128];
    WCHAR ctype_buff[128];
    char *locale;
    UINT unix_cp = 0;

    if ((locale = setlocale( LC_CTYPE, NULL )))
    {
        strcpynAtoW( ctype_buff, locale, sizeof(ctype_buff)/sizeof(WCHAR) );
        parse_locale_name( ctype_buff, &locale_name );
        lcid_LC_CTYPE = locale_name.lcid;
        unix_cp = locale_name.codepage;
    }
    if (!lcid_LC_CTYPE)  /* this one needs a default value */
        lcid_LC_CTYPE = MAKELCID( MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), SORT_DEFAULT );

#if 0
    TRACE( "got lcid %04x (%d matches) for LC_CTYPE=%s\n",
           locale_name.lcid, locale_name.matches, debugstr_a(locale) );

#define GET_UNIX_LOCALE(cat) do \
    if ((locale = setlocale( cat, NULL ))) \
    { \
        strcpynAtoW( buffer, locale, sizeof(buffer)/sizeof(WCHAR) ); \
        if (!strcmpW( buffer, ctype_buff )) lcid_##cat = lcid_LC_CTYPE; \
        else { \
            parse_locale_name( buffer, &locale_name );  \
            lcid_##cat = locale_name.lcid; \
            TRACE( "got lcid %04x (%d matches) for " #cat "=%s\n",        \
                   locale_name.lcid, locale_name.matches, debugstr_a(locale) ); \
        } \
    } while (0)

    GET_UNIX_LOCALE( LC_COLLATE );
    GET_UNIX_LOCALE( LC_MESSAGES );
    GET_UNIX_LOCALE( LC_MONETARY );
    GET_UNIX_LOCALE( LC_NUMERIC );
    GET_UNIX_LOCALE( LC_TIME );
#ifdef LC_PAPER
    GET_UNIX_LOCALE( LC_PAPER );
#endif
#ifdef LC_MEASUREMENT
    GET_UNIX_LOCALE( LC_MEASUREMENT );
#endif
#ifdef LC_TELEPHONE
    GET_UNIX_LOCALE( LC_TELEPHONE );
#endif

#undef GET_UNIX_LOCALE

#endif // #if 0

    return unix_cp;
}

/********************************/

static void LOCALE_Init(void)
{
	/*
    extern void __wine_init_codepages( const union cptable *ansi_cp, const union cptable *oem_cp,
                                       const union cptable *unix_cp );
				       */

    // UINT ansi_cp = 1252, oem_cp = 437, mac_cp = 10000, unix_cp;
    UINT unix_cp = 0;

#ifdef __APPLE__
    /* MacOS doesn't set the locale environment variables so we have to do it ourselves */
    CFArrayRef preferred_locales, all_locales;
    CFStringRef user_language_string_ref = NULL;
    char user_locale[50];

    CFLocaleRef user_locale_ref = CFLocaleCopyCurrent();
    CFStringRef user_locale_string_ref = CFLocaleGetIdentifier( user_locale_ref );

    CFStringGetCString( user_locale_string_ref, user_locale, sizeof(user_locale), kCFStringEncodingUTF8 );
    CFRelease( user_locale_ref );
    if (!strchr( user_locale, '.' )) strcat( user_locale, ".UTF-8" );
    unix_cp = CP_UTF8;  /* default to utf-8 even if we don't get a valid locale */
    setenv( "LANG", user_locale, 0 );
    // TRACE( "setting locale to '%s'\n", user_locale );

    /* We still want to set the retrieve the preferred language as chosen in
       System Preferences.app, because it can differ from CFLocaleCopyCurrent().
    */
    all_locales = CFLocaleCopyAvailableLocaleIdentifiers();
    preferred_locales = CFBundleCopyLocalizationsForPreferences( all_locales, NULL );
    if (preferred_locales && CFArrayGetCount( preferred_locales ))
        user_language_string_ref = (CFStringRef)CFArrayGetValueAtIndex( preferred_locales, 0 ); // FIXME
    CFRelease( all_locales );
#endif /* __APPLE__ */

    // FIXME setlocale( LC_ALL, "" );

    unix_cp = setup_unix_locales();
    if (!lcid_LC_MESSAGES) lcid_LC_MESSAGES = lcid_LC_CTYPE;

#ifdef __APPLE__
    /* Override lcid_LC_MESSAGES with user_language if LC_MESSAGES is set to default */
    if (lcid_LC_MESSAGES == lcid_LC_CTYPE && user_language_string_ref)
    {
        struct locale_name locale_name;
        WCHAR buffer[128];
        CFStringGetCString( user_language_string_ref, user_locale, sizeof(user_locale), kCFStringEncodingUTF8 );
        strcpynAtoW( buffer, user_locale, sizeof(buffer)/sizeof(WCHAR) );
        parse_locale_name( buffer, &locale_name );
        lcid_LC_MESSAGES = locale_name.lcid;
        // TRACE( "setting lcid_LC_MESSAGES to '%s'\n", user_locale );
    }
    if (preferred_locales)
        CFRelease( preferred_locales );
#endif

#if 0 // FIXME	
    NtSetDefaultUILanguage( LANGIDFROMLCID(lcid_LC_MESSAGES) );
    NtSetDefaultLocale( TRUE, lcid_LC_MESSAGES );
    NtSetDefaultLocale( FALSE, lcid_LC_CTYPE );

    ansi_cp = get_lcid_codepage( LOCALE_USER_DEFAULT );
    GetLocaleInfoW( LOCALE_USER_DEFAULT, LOCALE_IDEFAULTMACCODEPAGE | LOCALE_RETURN_NUMBER,
                    (LPWSTR)&mac_cp, sizeof(mac_cp)/sizeof(WCHAR) );
    GetLocaleInfoW( LOCALE_USER_DEFAULT, LOCALE_IDEFAULTCODEPAGE | LOCALE_RETURN_NUMBER,
                    (LPWSTR)&oem_cp, sizeof(oem_cp)/sizeof(WCHAR) );
    if (!unix_cp)
        GetLocaleInfoW( LOCALE_USER_DEFAULT, LOCALE_IDEFAULTUNIXCODEPAGE | LOCALE_RETURN_NUMBER,
                        (LPWSTR)&unix_cp, sizeof(unix_cp)/sizeof(WCHAR) );

    if (!(ansi_cptable = wine_cp_get_table( ansi_cp )))
        ansi_cptable = wine_cp_get_table( 1252 );
    if (!(oem_cptable = wine_cp_get_table( oem_cp )))
        oem_cptable  = wine_cp_get_table( 437 );
    if (!(mac_cptable = wine_cp_get_table( mac_cp )))
        mac_cptable  = wine_cp_get_table( 10000 );
    if (unix_cp != CP_UTF8)
    {
        if (!(unix_cptable = wine_cp_get_table( unix_cp )))
            unix_cptable  = wine_cp_get_table( 28591 );
    }

    __wine_init_codepages( ansi_cptable, oem_cptable, unix_cptable );

    TRACE( "ansi=%03d oem=%03d mac=%03d unix=%03d\n",
           ansi_cptable->info.codepage, oem_cptable->info.codepage,
           mac_cptable->info.codepage, unix_cp );

    setlocale(LC_NUMERIC, "C");  /* FIXME: oleaut32 depends on this */
#endif
}

LANGID GetUserDefaultLangID(void)
{
    // return LANGIDFROMLCID(GetUserDefaultLCID());
    if (lcid_LC_MESSAGES == 0) LOCALE_Init();
    return LANGIDFROMLCID(lcid_LC_MESSAGES);
}

LANGID GetSystemDefaultLangID(void)
{
    // return LANGIDFROMLCID(GetSystemDefaultLCID());
    if (lcid_LC_MESSAGES == 0) LOCALE_Init();
    return LANGIDFROMLCID(lcid_LC_MESSAGES);
}

#ifdef TEST
int main()
{
	LANGID langID;
	WORD primLang;
	WORD subLang;

	setlocale( LC_ALL, "" );

	langID = GetUserDefaultLangID();
	printf("langID=0x%x\n",langID);

	primLang = (WORD)(PRIMARYLANGID(langID));
	subLang = (WORD)(SUBLANGID(langID));

	printf("primLang=%d subLang=%d\n",(unsigned)primLang,(unsigned)subLang);

	return 0;
}
#endif

/*
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */
#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h> /* gettimeofday */
#include <dirent.h>
#include <unistd.h>
#include <time.h>

#include <windows.h>

// #define TRACEN(u) u;
#define TRACEN(u)  /* */

typedef LONG NTSTATUS;
#define STATUS_SUCCESS                   0x00000000

#define TICKSPERSEC        10000000
#define TICKSPERMSEC       10000
#define SECSPERDAY         86400
#define SECSPERHOUR        3600
#define SECSPERMIN         60
#define MINSPERHOUR        60
#define HOURSPERDAY        24
#define EPOCHWEEKDAY       1  /* Jan 1, 1601 was Monday */
#define DAYSPERWEEK        7
#define EPOCHYEAR          1601
#define DAYSPERNORMALYEAR  365
#define DAYSPERLEAPYEAR    366
#define MONSPERYEAR        12
#define DAYSPERQUADRICENTENNIUM (365 * 400 + 97)
#define DAYSPERNORMALCENTURY (365 * 100 + 24)
#define DAYSPERNORMALQUADRENNIUM (365 * 4 + 1)

/* 1601 to 1970 is 369 years plus 89 leap days */
#define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)SECSPERDAY)
#define TICKS_1601_TO_1970 (SECS_1601_TO_1970 * TICKSPERSEC)
/* 1601 to 1980 is 379 years plus 91 leap days */
#define SECS_1601_TO_1980  ((379 * 365 + 91) * (ULONGLONG)SECSPERDAY)
#define TICKS_1601_TO_1980 (SECS_1601_TO_1980 * TICKSPERSEC)
typedef short CSHORT;

static LONG TIME_GetBias() {
  time_t utc = time(NULL);
  struct tm *ptm = localtime(&utc);
  int localdaylight = ptm->tm_isdst; /* daylight for local timezone */
  ptm = gmtime(&utc);
  ptm->tm_isdst = localdaylight; /* use local daylight, not that of Greenwich */
  LONG bias = (int)(mktime(ptm)-utc);
  TRACEN((printf("TIME_GetBias %ld\n",(long)bias)))
  return bias;
}

static inline void RtlSystemTimeToLocalTime( const LARGE_INTEGER *SystemTime,
                                      LARGE_INTEGER *LocalTime ) {
  LONG bias = TIME_GetBias();
  LocalTime->QuadPart = SystemTime->QuadPart - bias * (LONGLONG)TICKSPERSEC;
}

void WINAPI RtlSecondsSince1970ToFileTime( DWORD Seconds, FILETIME * ft ) {
  ULONGLONG secs = Seconds * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
  ft->dwLowDateTime  = (DWORD)secs;
  ft->dwHighDateTime = (DWORD)(secs >> 32);
  TRACEN((printf("RtlSecondsSince1970ToFileTime %lx => %lx %lx\n",(long)Seconds,(long)ft->dwHighDateTime,(long)ft->dwLowDateTime)))
}

/*
void WINAPI RtlSecondsSince1970ToTime( DWORD Seconds, LARGE_INTEGER *Time )
{
    ULONGLONG secs = Seconds * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
    // Time->u.LowPart  = (DWORD)secs; Time->u.HighPart = (DWORD)(secs >> 32);
    Time->QuadPart = secs;
}
 */

BOOL WINAPI DosDateTimeToFileTime( WORD fatdate, WORD fattime, FILETIME * ft)
{
    struct tm newtm;
#ifndef ENV_HAVE_TIMEGM
    struct tm *gtm;
    time_t time1, time2;
#endif

    TRACEN((printf("DosDateTimeToFileTime\n")))

    newtm.tm_sec  = (fattime & 0x1f) * 2;
    newtm.tm_min  = (fattime >> 5) & 0x3f;
    newtm.tm_hour = (fattime >> 11);
    newtm.tm_mday = (fatdate & 0x1f);
    newtm.tm_mon  = ((fatdate >> 5) & 0x0f) - 1;
    newtm.tm_year = (fatdate >> 9) + 80;
    newtm.tm_isdst = -1;
#ifdef ENV_HAVE_TIMEGM
    RtlSecondsSince1970ToFileTime( timegm(&newtm), ft );
#else
    newtm.tm_isdst = 0;
    time1 = mktime(&newtm);
    gtm = gmtime(&time1);
    time2 = mktime(gtm);
    RtlSecondsSince1970ToFileTime( 2*time1-time2, ft );
#endif
    TRACEN((printf("DosDateTimeToFileTime(%ld,%ld) => %lx %lx\n",
          (long)fatdate,(long)fattime,
          (long)ft->dwHighDateTime,(long)ft->dwLowDateTime)))

    return TRUE;
}

/*
BOOL WINAPI DosDateTimeToFileTime( WORD fatdate, WORD fattime, FILETIME * ft) {
  struct tm newtm;

  TRACEN((printf("DosDateTimeToFileTime\n")))

  memset(&newtm,0,sizeof(newtm));
  newtm.tm_sec  = (fattime & 0x1f) * 2;
  newtm.tm_min  = (fattime >> 5) & 0x3f;
  newtm.tm_hour = (fattime >> 11);
  newtm.tm_mday = (fatdate & 0x1f);
  newtm.tm_mon  = ((fatdate >> 5) & 0x0f) - 1;
  newtm.tm_year = (fatdate >> 9) + 80;
  newtm.tm_isdst = -1;

  time_t time1 = mktime(&newtm);
  LONG   bias  = TIME_GetBias();
  RtlSecondsSince1970ToFileTime( time1 - bias, ft );


  TRACEN((printf("DosDateTimeToFileTime(%ld,%ld) t1=%ld => %lx %lx\n",
        (long)fatdate,(long)fattime,(long)time1,
	(long)ft->dwHighDateTime,(long)ft->dwLowDateTime)))

  return TRUE;
}
*/

BOOLEAN WINAPI RtlTimeToSecondsSince1970( const LARGE_INTEGER *Time, DWORD *Seconds ) {
  ULONGLONG tmp = Time->QuadPart;
  TRACEN((printf("RtlTimeToSecondsSince1970-1 %llx\n",tmp)))
  tmp /= TICKSPERSEC;
  tmp -= SECS_1601_TO_1970;
  TRACEN((printf("RtlTimeToSecondsSince1970-2 %llx\n",tmp)))
  if (tmp > 0xffffffff) return FALSE;
  *Seconds = (DWORD)tmp;
  return TRUE;
}

BOOL WINAPI FileTimeToDosDateTime( const FILETIME *ft, WORD *fatdate, WORD *fattime ) {
  LARGE_INTEGER       li;
  ULONG               t;
  time_t              unixtime;
  struct tm*          tm;
  WORD fat_d,fat_t;

  TRACEN((printf("FileTimeToDosDateTime\n")))
  li.QuadPart = ft->dwHighDateTime;
  li.QuadPart = (li.QuadPart << 32) | ft->dwLowDateTime;
  RtlTimeToSecondsSince1970( &li, &t );
  unixtime = t; /* unixtime = t; * FIXME unixtime = t - TIME_GetBias(); */

  tm = gmtime( &unixtime );

  fat_t = (tm->tm_hour << 11) + (tm->tm_min << 5) + (tm->tm_sec / 2);
  fat_d = ((tm->tm_year - 80) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday;
  if (fattime)
    *fattime = fat_t;
  if (fatdate)
    *fatdate = fat_d;

  TRACEN((printf("FileTimeToDosDateTime : %lx %lx => %d %d\n",
	(long)ft->dwHighDateTime,(long)ft->dwLowDateTime,(unsigned)fat_d,(unsigned)fat_t)))

  return TRUE;
}

BOOL WINAPI FileTimeToLocalFileTime( const FILETIME *utcft, FILETIME * localft ) {
  LARGE_INTEGER local, utc;

  TRACEN((printf("FileTimeToLocalFileTime\n")))
  utc.QuadPart = utcft->dwHighDateTime;
  utc.QuadPart = (utc.QuadPart << 32) | utcft->dwLowDateTime;
  RtlSystemTimeToLocalTime( &utc, &local );
  localft->dwLowDateTime = (DWORD)local.QuadPart;
  localft->dwHighDateTime = (DWORD)(local.QuadPart >> 32);

  return TRUE;
}

typedef struct _TIME_FIELDS {
  CSHORT Year;
  CSHORT Month;
  CSHORT Day;
  CSHORT Hour;
  CSHORT Minute;
  CSHORT Second;
  CSHORT Milliseconds;
  CSHORT Weekday;
} TIME_FIELDS;

static const int MonthLengths[2][MONSPERYEAR] =
{
   { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
   { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
};

static inline int IsLeapYear(int Year) {
  return Year % 4 == 0 && (Year % 100 != 0 || Year % 400 == 0) ? 1 : 0;
}

static inline VOID WINAPI RtlTimeToTimeFields(
  const LARGE_INTEGER *liTime,
  TIME_FIELDS * TimeFields) {
	int SecondsInDay;
        long int cleaps, years, yearday, months;
	long int Days;
	LONGLONG Time;

	/* Extract millisecond from time and convert time into seconds */
	TimeFields->Milliseconds =
            (CSHORT) (( liTime->QuadPart % TICKSPERSEC) / TICKSPERMSEC);
	Time = liTime->QuadPart / TICKSPERSEC;

	/* The native version of RtlTimeToTimeFields does not take leap seconds
	 * into account */

	/* Split the time into days and seconds within the day */
	Days = Time / SECSPERDAY;
	SecondsInDay = Time % SECSPERDAY;

	/* compute time of day */
	TimeFields->Hour = (CSHORT) (SecondsInDay / SECSPERHOUR);
	SecondsInDay = SecondsInDay % SECSPERHOUR;
	TimeFields->Minute = (CSHORT) (SecondsInDay / SECSPERMIN);
	TimeFields->Second = (CSHORT) (SecondsInDay % SECSPERMIN);

	/* compute day of week */
	TimeFields->Weekday = (CSHORT) ((EPOCHWEEKDAY + Days) % DAYSPERWEEK);

        /* compute year, month and day of month. */
        cleaps=( 3 * ((4 * Days + 1227) / DAYSPERQUADRICENTENNIUM) + 3 ) / 4;
        Days += 28188 + cleaps;
        years = (20 * Days - 2442) / (5 * DAYSPERNORMALQUADRENNIUM);
        yearday = Days - (years * DAYSPERNORMALQUADRENNIUM)/4;
        months = (64 * yearday) / 1959;
        /* the result is based on a year starting on March.
         * To convert take 12 from Januari and Februari and
         * increase the year by one. */
        if( months < 14 ) {
            TimeFields->Month = months - 1;
            TimeFields->Year = years + 1524;
        } else {
            TimeFields->Month = months - 13;
            TimeFields->Year = years + 1525;
        }
        /* calculation of day of month is based on the wonderful
         * sequence of INT( n * 30.6): it reproduces the 
         * 31-30-31-30-31-31 month lengths exactly for small n's */
        TimeFields->Day = yearday - (1959 * months) / 64 ;
}


BOOL WINAPI FileTimeToSystemTime( const FILETIME *ft, SYSTEMTIME * syst ) {
  TIME_FIELDS tf;
  LARGE_INTEGER t;

  TRACEN((printf("FileTimeToSystemTime\n")))
  t.QuadPart = ft->dwHighDateTime;
  t.QuadPart = (t.QuadPart << 32) | ft->dwLowDateTime;
  RtlTimeToTimeFields(&t, &tf);

  syst->wYear = tf.Year;
  syst->wMonth = tf.Month;
  syst->wDay = tf.Day;
  syst->wHour = tf.Hour;
  syst->wMinute = tf.Minute;
  syst->wSecond = tf.Second;
  syst->wMilliseconds = tf.Milliseconds;
  syst->wDayOfWeek = tf.Weekday;
  return TRUE;
}


static inline NTSTATUS WINAPI RtlLocalTimeToSystemTime( const LARGE_INTEGER *LocalTime,
    LARGE_INTEGER *SystemTime) {

  TRACEN((printf("RtlLocalTimeToSystemTime\n")))
  LONG bias = TIME_GetBias();
  SystemTime->QuadPart = LocalTime->QuadPart + bias * (LONGLONG)TICKSPERSEC;
  return STATUS_SUCCESS;
}

BOOL WINAPI LocalFileTimeToFileTime( const FILETIME *localft, FILETIME * utcft ) {
  LARGE_INTEGER local, utc;

  TRACEN((printf("LocalFileTimeToFileTime\n")))
  local.QuadPart = localft->dwHighDateTime;
  local.QuadPart = (local.QuadPart << 32) | localft->dwLowDateTime;
  RtlLocalTimeToSystemTime( &local, &utc );
  utcft->dwLowDateTime = (DWORD)utc.QuadPart;
  utcft->dwHighDateTime = (DWORD)(utc.QuadPart >> 32);

  return TRUE;
}

/*********************************************************************
 *      GetSystemTime                                   (KERNEL32.@)
 *
 * Get the current system time.
 *
 * RETURNS
 *  Nothing.
 */
VOID WINAPI GetSystemTime(SYSTEMTIME * systime) /* [O] Destination for current time */
{
  FILETIME ft;
  LARGE_INTEGER t;

  TRACEN((printf("GetSystemTime\n")))

  struct timeval now;
  gettimeofday( &now, 0 );
  t.QuadPart  = now.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
  t.QuadPart += now.tv_usec * 10;

  ft.dwLowDateTime  = (DWORD)(t.QuadPart);
  ft.dwHighDateTime = (DWORD)(t.QuadPart >> 32);
  FileTimeToSystemTime(&ft, systime);
}

/******************************************************************************
 *       RtlTimeFieldsToTime [NTDLL.@]
 *
 * Convert a TIME_FIELDS structure into a time.
 *
 * PARAMS
 *   ftTimeFields [I] TIME_FIELDS structure to convert.
 *   Time         [O] Destination for the converted time.
 *
 * RETURNS
 *   Success: TRUE.
 *   Failure: FALSE.
 */
static BOOLEAN WINAPI RtlTimeFieldsToTime(
  TIME_FIELDS * tfTimeFields,
  LARGE_INTEGER *Time)
{
  int month, year, cleaps, day;

  TRACEN((printf("RtlTimeFieldsToTime\n")))

	/* FIXME: normalize the TIME_FIELDS structure here */
        /* No, native just returns 0 (error) if the fields are not */
        if( tfTimeFields->Milliseconds< 0 || tfTimeFields->Milliseconds > 999 ||
                tfTimeFields->Second < 0 || tfTimeFields->Second > 59 ||
                tfTimeFields->Minute < 0 || tfTimeFields->Minute > 59 ||
                tfTimeFields->Hour < 0 || tfTimeFields->Hour > 23 ||
                tfTimeFields->Month < 1 || tfTimeFields->Month > 12 ||
                tfTimeFields->Day < 1 ||
                tfTimeFields->Day > MonthLengths
                    [ tfTimeFields->Month ==2 || IsLeapYear(tfTimeFields->Year)]
                    [ tfTimeFields->Month - 1] ||
                tfTimeFields->Year < 1601 )
            return FALSE;

        /* now calculate a day count from the date
         * First start counting years from March. This way the leap days
         * are added at the end of the year, not somewhere in the middle.
         * Formula's become so much less complicate that way.
         * To convert: add 12 to the month numbers of Jan and Feb, and 
         * take 1 from the year */
        if(tfTimeFields->Month < 3) {
            month = tfTimeFields->Month + 13;
            year = tfTimeFields->Year - 1;
        } else {
            month = tfTimeFields->Month + 1;
            year = tfTimeFields->Year;
        }
        cleaps = (3 * (year / 100) + 3) / 4;   /* nr of "century leap years"*/
        day =  (36525 * year) / 100 - cleaps + /* year * dayperyr, corrected */
                 (1959 * month) / 64 +         /* months * daypermonth */
                 tfTimeFields->Day -          /* day of the month */
                 584817 ;                      /* zero that on 1601-01-01 */
        /* done */
        
        Time->QuadPart = (((((LONGLONG) day * HOURSPERDAY +
            tfTimeFields->Hour) * MINSPERHOUR +
            tfTimeFields->Minute) * SECSPERMIN +
            tfTimeFields->Second ) * 1000 +
            tfTimeFields->Milliseconds ) * TICKSPERMSEC;

        return TRUE;
}

/*********************************************************************
 *      SystemTimeToFileTime                            (KERNEL32.@)
 */
BOOL WINAPI SystemTimeToFileTime( const SYSTEMTIME *syst, FILETIME * ft ) {
  TIME_FIELDS tf;
  LARGE_INTEGER t;

  TRACEN((printf("SystemTimeToFileTime\n")))

  tf.Year = syst->wYear;
  tf.Month = syst->wMonth;
  tf.Day = syst->wDay;
  tf.Hour = syst->wHour;
  tf.Minute = syst->wMinute;
  tf.Second = syst->wSecond;
  tf.Milliseconds = syst->wMilliseconds;

  RtlTimeFieldsToTime(&tf, &t);
  ft->dwLowDateTime = (DWORD)t.QuadPart;
  ft->dwHighDateTime = (DWORD)(t.QuadPart>>32);
  return TRUE;
}

/***********************************************************************
 *              GetSystemTimeAsFileTime  (KERNEL32.@)
 *
 *  Get the current time in utc format.
 *
 *  RETURNS
 *   Nothing.
 */
VOID WINAPI GetSystemTimeAsFileTime(
    FILETIME * time) /* [out] Destination for the current utc time */
{
    LARGE_INTEGER t;
/*
    NtQuerySystemTime( &t );
*/
    struct timeval now;

    gettimeofday( &now, 0 );
    t.QuadPart  = now.tv_sec * (ULONGLONG)TICKSPERSEC + TICKS_1601_TO_1970;
    t.QuadPart += now.tv_usec * 10;

    time->dwLowDateTime  = (DWORD)(t.QuadPart);
    time->dwHighDateTime = (DWORD)(t.QuadPart >> 32);
}

DWORD WINAPI GetTickCount(VOID) { // Retrieves the number of milliseconds
  timeval v;
  if (gettimeofday(&v, 0) == 0)
  {
    return (DWORD)(v.tv_sec * (UInt64)1000 + v.tv_usec / 1000);
  }  
  return (DWORD)time(0)*1000; 
}

7z ANSI-C Decoder 9.35
----------------------

7z ANSI-C provides 7z/LZMA decoding.
7z ANSI-C version is simplified version ported from C++ code.

LZMA is default and general compression method of 7z format
in 7-Zip compression program (www.7-zip.org). LZMA provides high 
compression ratio and very fast decompression.


LICENSE
-------

7z ANSI-C Decoder is part of the LZMA SDK.
LZMA SDK is written and placed in the public domain by Igor Pavlov.

Files
---------------------

7zDecode.*   - Low level 7z decoding
7zExtract.*  - High level 7z decoding
7zHeader.*   - .7z format constants
7zIn.*       - .7z archive opening
7zItem.*     - .7z structures
7zMain.c     - Test application


How To Use
----------

You can create .7z archive with 7z.exe, 7za.exe or 7zr.exe:

  7z.exe a archive.7z *.htm -r -mx -m0fb=255

If you have big number of files in archive, and you need fast extracting, 
you can use partly-solid archives:
  
  7za.exe a archive.7z *.htm -ms=512K -r -mx -m0fb=255 -m0d=512K

In that example 7-Zip will use 512KB solid blocks. So it needs to decompress only 
512KB for extracting one file from such archive.


Limitations of current version of 7z ANSI-C Decoder
---------------------------------------------------

 - It reads only "FileName", "Size", "LastWriteTime" and "CRC" information for each file in archive.
 - It supports only LZMA and Copy (no compression) methods with BCJ or BCJ2 filters.
 - It converts original UTF-16 Unicode file names to UTF-8 Unicode file names.
 
These limitations will be fixed in future versions.


Using 7z ANSI-C Decoder Test application:
-----------------------------------------

Usage: 7zDec <command> <archive_name>

<Command>:
  e: Extract files from archive
  l: List contents of archive
  t: Test integrity of archive

Example: 

  7zDec l archive.7z

lists contents of archive.7z

  7zDec e archive.7z

extracts files from archive.7z to current folder.


How to use .7z Decoder
----------------------

Memory allocation
~~~~~~~~~~~~~~~~~

7z Decoder uses two memory pools:
1) Temporary pool
2) Main pool
Such scheme can allow you to avoid fragmentation of allocated blocks.


Steps for using 7z decoder
--------------------------

Use code at 7zMain.c as example.

1) Declare variables:
  inStream                 /* implements ILookInStream interface */
  CSzArEx db;              /* 7z archive database structure */
  ISzAlloc allocImp;       /* memory functions for main pool */
  ISzAlloc allocTempImp;   /* memory functions for temporary pool */

2) call CrcGenerateTable(); function to initialize CRC structures.

3) call SzArEx_Init(&db); function to initialize db structures.

4) call SzArEx_Open(&db, inStream, &allocMain, &allocTemp) to open archive

This function opens archive "inStream" and reads headers to "db".
All items in "db" will be allocated with "allocMain" functions.
SzArEx_Open function allocates and frees temporary structures by "allocTemp" functions.

5) List items or Extract items

  Listing code:
  ~~~~~~~~~~~~~

    Use SzArEx_GetFileNameUtf16 function. Look example code in C\Util\7z\7zMain.c file. 
    

  Extracting code:
  ~~~~~~~~~~~~~~~~

  SZ_RESULT SzAr_Extract(
    CArchiveDatabaseEx *db,
    ILookInStream *inStream, 
    UInt32 fileIndex,         /* index of file */
    UInt32 *blockIndex,       /* index of solid block */
    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
    size_t *outBufferSize,    /* buffer size for output buffer */
    size_t *offset,           /* offset of stream for required file in *outBuffer */
    size_t *outSizeProcessed, /* size of file in *outBuffer */
    ISzAlloc *allocMain,
    ISzAlloc *allocTemp);

  If you need to decompress more than one file, you can send these values from previous call:
    blockIndex, 
    outBuffer, 
    outBufferSize,
  You can consider "outBuffer" as cache of solid block. If your archive is solid, 
  it will increase decompression speed.

  After decompressing you must free "outBuffer":
  allocImp.Free(outBuffer);

6) call SzArEx_Free(&db, allocImp.Free) to free allocated items in "db".




Memory requirements for .7z decoding 
------------------------------------

Memory usage for Archive opening:
  - Temporary pool:
     - Memory for uncompressed .7z headers
     - some other temporary blocks
  - Main pool:
     - Memory for database: 
       Estimated size of one file structures in solid archive:
         - Size (4 or 8 Bytes)
         - CRC32 (4 bytes)
         - LastWriteTime (8 bytes)
         - Some file information (4 bytes)
         - File Name (variable length) + pointer + allocation structures

Memory usage for archive Decompressing:
  - Temporary pool:
     - Memory for LZMA decompressing structures
  - Main pool:
     - Memory for decompressed solid block
     - Memory for temprorary buffers, if BCJ2 fileter is used. Usually these 
       temprorary buffers can be about 15% of solid block size. 
  

7z Decoder doesn't allocate memory for compressed blocks. 
Instead of this, you must allocate buffer with desired 
size before calling 7z Decoder. Use 7zMain.c as example.


Defines
-------

_SZ_ALLOC_DEBUG   - define it if you want to debug alloc/free operations to stderr.


---

http://www.7-zip.org
http://www.7-zip.org/sdk.html
http://www.7-zip.org/support.html
7z Format description (4.59)
----------------------------

This file contains description of 7z archive format. 
7z archive can contain files compressed with any method.
See "Methods.txt" for description for defined compressing methods.


Format structure Overview
-------------------------

Some fields can be optional.

Archive structure
~~~~~~~~~~~~~~~~~  
SignatureHeader
[PackedStreams]
[PackedStreamsForHeaders]
[
  Header 
  or 
  {
    Packed Header
    HeaderInfo
  }
]



Header structure
~~~~~~~~~~~~~~~~  
{
  ArchiveProperties
  AdditionalStreams
  {
    PackInfo
    {
      PackPos
      NumPackStreams
      Sizes[NumPackStreams]
      CRCs[NumPackStreams]
    }
    CodersInfo
    {
      NumFolders
      Folders[NumFolders]
      {
        NumCoders
        CodersInfo[NumCoders]
        {
          ID
          NumInStreams;
          NumOutStreams;
          PropertiesSize
          Properties[PropertiesSize]
        }
        NumBindPairs
        BindPairsInfo[NumBindPairs]
        {
          InIndex;
          OutIndex;
        }
        PackedIndices
      }
      UnPackSize[Folders][Folders.NumOutstreams]
      CRCs[NumFolders]
    }
    SubStreamsInfo
    {
      NumUnPackStreamsInFolders[NumFolders];
      UnPackSizes[]
      CRCs[]
    }
  }
  MainStreamsInfo
  {
    (Same as in AdditionalStreams)
  }
  FilesInfo
  {
    NumFiles
    Properties[]
    {
      ID
      Size
      Data
    }
  }
}

HeaderInfo structure
~~~~~~~~~~~~~~~~~~~~
{
  (Same as in AdditionalStreams)
}



Notes about Notation and encoding
---------------------------------

7z uses little endian encoding.

7z archive format has optional headers that are marked as
[]
Header
[]

REAL_UINT64 means real UINT64.

UINT64 means real UINT64 encoded with the following scheme:

  Size of encoding sequence depends from first byte:
  First_Byte  Extra_Bytes        Value
  (binary)   
  0xxxxxxx               : ( xxxxxxx           )
  10xxxxxx    BYTE y[1]  : (  xxxxxx << (8 * 1)) + y
  110xxxxx    BYTE y[2]  : (   xxxxx << (8 * 2)) + y
  ...
  1111110x    BYTE y[6]  : (       x << (8 * 6)) + y
  11111110    BYTE y[7]  :                         y
  11111111    BYTE y[8]  :                         y



Property IDs
------------

0x00 = kEnd

0x01 = kHeader

0x02 = kArchiveProperties
    
0x03 = kAdditionalStreamsInfo
0x04 = kMainStreamsInfo
0x05 = kFilesInfo
    
0x06 = kPackInfo
0x07 = kUnPackInfo
0x08 = kSubStreamsInfo

0x09 = kSize
0x0A = kCRC

0x0B = kFolder

0x0C = kCodersUnPackSize
0x0D = kNumUnPackStream

0x0E = kEmptyStream
0x0F = kEmptyFile
0x10 = kAnti

0x11 = kName
0x12 = kCTime
0x13 = kATime
0x14 = kMTime
0x15 = kWinAttributes
0x16 = kComment

0x17 = kEncodedHeader

0x18 = kStartPos
0x19 = kDummy


7z format headers
-----------------

SignatureHeader
~~~~~~~~~~~~~~~
  BYTE kSignature[6] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};

  ArchiveVersion
  {
    BYTE Major;   // now = 0
    BYTE Minor;   // now = 2
  };

  UINT32 StartHeaderCRC;

  StartHeader
  {
    REAL_UINT64 NextHeaderOffset
    REAL_UINT64 NextHeaderSize
    UINT32 NextHeaderCRC
  }


...........................


ArchiveProperties
~~~~~~~~~~~~~~~~~
BYTE NID::kArchiveProperties (0x02)
for (;;)
{
  BYTE PropertyType;
  if (aType == 0)
    break;
  UINT64 PropertySize;
  BYTE PropertyData[PropertySize];
}


Digests (NumStreams)
~~~~~~~~~~~~~~~~~~~~~
  BYTE AllAreDefined
  if (AllAreDefined == 0)
  {
    for(NumStreams)
      BIT Defined
  }
  UINT32 CRCs[NumDefined]


PackInfo
~~~~~~~~~~~~
  BYTE NID::kPackInfo  (0x06)
  UINT64 PackPos
  UINT64 NumPackStreams

  []
  BYTE NID::kSize    (0x09)
  UINT64 PackSizes[NumPackStreams]
  []

  []
  BYTE NID::kCRC      (0x0A)
  PackStreamDigests[NumPackStreams]
  []

  BYTE NID::kEnd


Folder
~~~~~~
  UINT64 NumCoders;
  for (NumCoders)
  {
    BYTE 
    {
      0:3 CodecIdSize
      4:  Is Complex Coder
      5:  There Are Attributes
      6:  Reserved
      7:  There are more alternative methods. (Not used anymore, must be 0).
    } 
    BYTE CodecId[CodecIdSize]
    if (Is Complex Coder)
    {
      UINT64 NumInStreams;
      UINT64 NumOutStreams;
    }
    if (There Are Attributes)
    {
      UINT64 PropertiesSize
      BYTE Properties[PropertiesSize]
    }
  }
    
  NumBindPairs = NumOutStreamsTotal - 1;

  for (NumBindPairs)
  {
    UINT64 InIndex;
    UINT64 OutIndex;
  }

  NumPackedStreams = NumInStreamsTotal - NumBindPairs;
  if (NumPackedStreams > 1)
    for(NumPackedStreams)
    {
      UINT64 Index;
    };




Coders Info
~~~~~~~~~~~

  BYTE NID::kUnPackInfo  (0x07)


  BYTE NID::kFolder  (0x0B)
  UINT64 NumFolders
  BYTE External
  switch(External)
  {
    case 0:
      Folders[NumFolders]
    case 1:
      UINT64 DataStreamIndex
  }


  BYTE ID::kCodersUnPackSize  (0x0C)
  for(Folders)
    for(Folder.NumOutStreams)
     UINT64 UnPackSize;


  []
  BYTE NID::kCRC   (0x0A)
  UnPackDigests[NumFolders]
  []

  

  BYTE NID::kEnd



SubStreams Info
~~~~~~~~~~~~~~
  BYTE NID::kSubStreamsInfo; (0x08)

  []
  BYTE NID::kNumUnPackStream; (0x0D)
  UINT64 NumUnPackStreamsInFolders[NumFolders];
  []


  []
  BYTE NID::kSize  (0x09)
  UINT64 UnPackSizes[]
  []


  []
  BYTE NID::kCRC  (0x0A)
  Digests[Number of streams with unknown CRC]
  []

  
  BYTE NID::kEnd


Streams Info
~~~~~~~~~~~~

  []
  PackInfo
  []


  []
  CodersInfo
  []


  []
  SubStreamsInfo
  []

  BYTE NID::kEnd


FilesInfo
~~~~~~~~~
  BYTE NID::kFilesInfo;  (0x05)
  UINT64 NumFiles

  for (;;)
  {
    BYTE PropertyType;
    if (aType == 0)
      break;

    UINT64 Size;

    switch(PropertyType)
    {
      kEmptyStream:   (0x0E)
        for(NumFiles)
          BIT IsEmptyStream

      kEmptyFile:     (0x0F)
        for(EmptyStreams)
          BIT IsEmptyFile

      kAnti:          (0x10)
        for(EmptyStreams)
          BIT IsAntiFile
      
      case kCTime: (0x12)
      case kATime: (0x13)
      case kMTime: (0x14)
        BYTE AllAreDefined
        if (AllAreDefined == 0)
        {
          for(NumFiles)
            BIT TimeDefined
        }
        BYTE External;
        if(External != 0)
          UINT64 DataIndex
        []
        for(Definded Items)
          UINT64 Time
        []
      
      kNames:     (0x11)
        BYTE External;
        if(External != 0)
          UINT64 DataIndex
        []
        for(Files)
        {
          wchar_t Names[NameSize];
          wchar_t 0;
        }
        []

      kAttributes:  (0x15)
        BYTE AllAreDefined
        if (AllAreDefined == 0)
        {
          for(NumFiles)
            BIT AttributesAreDefined
        }
        BYTE External;
        if(External != 0)
          UINT64 DataIndex
        []
        for(Definded Attributes)
          UINT32 Attributes
        []
    }
  }


Header
~~~~~~
  BYTE NID::kHeader (0x01)

  []
  ArchiveProperties
  []

  []
  BYTE NID::kAdditionalStreamsInfo; (0x03)
  StreamsInfo
  []

  []
  BYTE NID::kMainStreamsInfo;    (0x04)
  StreamsInfo
  []

  []
  FilesInfo
  []

  BYTE NID::kEnd


HeaderInfo
~~~~~~~~~~
  []
  BYTE NID::kEncodedHeader; (0x17)
  StreamsInfo for Encoded Header
  []


---
End of document
  7-Zip source code
  ~~~~~~~~~~~~~~~~~
  License for use and distribution
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  7-Zip Copyright (C) 1999-2016 Igor Pavlov.

  Licenses for files are:

    1) CPP/7zip/Compress/Rar* files:  GNU LGPL + unRAR restriction
    2) All other files:  GNU LGPL

  The GNU LGPL + unRAR restriction means that you must follow both 
  GNU LGPL rules and unRAR restriction rules.


  GNU LGPL information
  --------------------

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
    USA


  unRAR restriction
  -----------------

    The decompression engine for RAR archives was developed using source 
    code of unRAR program.
    All copyrights to original unRAR code are owned by Alexander Roshal.

    The license for original unRAR code has the following restriction:

    The unRAR sources cannot be used to re-create the RAR compression algorithm, 
    which is proprietary. Distribution of modified unRAR sources in separate form 
    or as a part of other software is permitted, provided that it is clearly
    stated in the documentation and source comments that the code may
    not be used to develop a RAR (WinRAR) compatible archiver.


  --
  Igor Pavlov
7-Zip method IDs for 7z and xz archives
---------------------------------------

Version: 15.06
Date: 2015-06-23

Each compression or crypto method in 7z is associated with unique binary value (ID).
The length of ID in bytes is arbitrary but it can not exceed 63 bits (8 bytes).

xz and 7z formats use same ID map.

If you want to add some new ID, you have two ways:
  1) Write request for allocating IDs to 7-Zip developers.
  2) Generate 8-bytes ID:

    3F ZZ ZZ ZZ ZZ ZZ MM MM 

    3F              - Prefix for random IDs (1 byte)
    ZZ ZZ ZZ ZZ ZZ  - Developer ID (5 bytes). Use real random bytes. 
                      
    MM MM           - Method ID (2 bytes)

    You can notify 7-Zip developers about your Developer ID / Method ID.

    Note: Use new ID, if old codec can not decode data encoded with new version.


List of defined IDs
-------------------
      
00 - Copy

03 - Delta
04 - BCJ (x86)
05 - PPC (big-endian)
06 - IA64
07 - ARM (little-endian)
08 - ARMT (little-endian)
09 - SPARC

21 - LZMA2
          
02.. - Common
   03 [Swap]
      - 2 Swap2
      - 4 Swap4

03.. - 7z
   01 - 
      01 - LZMA
  
   03 - [Branch Codecs]
      01 - [x86 Codecs]
         03  - BCJ
         1B  - BCJ2 (4 packed streams)
      02 - 
         05 - PPC (big-endian)
      03 - 
         01 - Alpha
      04 - 
         01 - IA64
      05 - 
         01 - ARM (little-endian)
      06 - 
         05 - M68 (big-endian)
      07 - 
         01 - ARMT (little-endian)
      08 - 
         05 - SPARC

   04 - 
      01 - PPMD

   7F -
      01 - experimental method.


04.. - Misc codecs

   00 - Reserved

   01 - [Zip]
      00 - Copy (not used. Use {00} instead)
      01 - Shrink
      06 - Implode
      08 - Deflate
      09 - Deflate64
      0A - Imploding
      0C - BZip2 (not used. Use {040202} instead)
      0E - LZMA (LZMA-zip)
      5F - xz
      60 - Jpeg
      61 - WavPack
      62 - PPMd (PPMd-zip)
      63 - wzAES

   02 - 
      02 - BZip2

   03 - [Rar]
      01 - Rar1
      02 - Rar2
      03 - Rar3
      05 - Rar5

   04 - [Arj]
      01 - Arj(1,2,3)
      02 - Arj4

   05 - [Z]

   06 - [Lzh]

   07 - Reserved for 7z

   08 - [Cab]

   09 - [NSIS]
      01 - DeflateNSIS
      02 - BZip2NSIS

   F7 - External codecs (that are not included to 7-Zip)

      0x xx - reserved
      10 xx - reserved


06.. - Crypto 

   F0 - Ciphers without hashing algo

      01 - [AES]
         0x - AES-128
         4x - AES-192
         8x - AES-256
         Cx - AES

         x0 - ECB
         x1 - CBC
         x2 - CFB
         x3 - OFB
         x4 - CTR

   F1 - Combine Ciphers

      01 - [Zip]
         01 - ZipCrypto (Main Zip crypto algo)

      03 - [RAR]
         02 - 
         03 - Rar29AES (AES-128 + modified SHA-1)

      07 - [7z]
         01 - 7zAES (AES-256 + SHA-256)


---
End of document
                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!
LZMA compression
----------------
Version: 9.35

This file describes LZMA encoding and decoding functions written in C language.

LZMA is an improved version of famous LZ77 compression algorithm. 
It was improved in way of maximum increasing of compression ratio,
keeping high decompression speed and low memory requirements for 
decompressing.

Note: you can read also LZMA Specification (lzma-specification.txt from LZMA SDK)

Also you can look source code for LZMA encoding and decoding:
  C/Util/Lzma/LzmaUtil.c


LZMA compressed file format
---------------------------
Offset Size Description
  0     1   Special LZMA properties (lc,lp, pb in encoded form)
  1     4   Dictionary size (little endian)
  5     8   Uncompressed size (little endian). -1 means unknown size
 13         Compressed data



ANSI-C LZMA Decoder
~~~~~~~~~~~~~~~~~~~

Please note that interfaces for ANSI-C code were changed in LZMA SDK 4.58.
If you want to use old interfaces you can download previous version of LZMA SDK
from sourceforge.net site.

To use ANSI-C LZMA Decoder you need the following files:
1) LzmaDec.h + LzmaDec.c + Types.h

Look example code:
  C/Util/Lzma/LzmaUtil.c


Memory requirements for LZMA decoding
-------------------------------------

Stack usage of LZMA decoding function for local variables is not 
larger than 200-400 bytes.

LZMA Decoder uses dictionary buffer and internal state structure.
Internal state structure consumes
  state_size = (4 + (1.5 << (lc + lp))) KB
by default (lc=3, lp=0), state_size = 16 KB.


How To decompress data
----------------------

LZMA Decoder (ANSI-C version) now supports 2 interfaces:
1) Single-call Decompressing
2) Multi-call State Decompressing (zlib-like interface)

You must use external allocator:
Example:
void *SzAlloc(void *p, size_t size) { p = p; return malloc(size); }
void SzFree(void *p, void *address) { p = p; free(address); }
ISzAlloc alloc = { SzAlloc, SzFree };

You can use p = p; operator to disable compiler warnings.


Single-call Decompressing
-------------------------
When to use: RAM->RAM decompressing
Compile files: LzmaDec.h + LzmaDec.c + Types.h
Compile defines: no defines
Memory Requirements:
  - Input buffer: compressed size
  - Output buffer: uncompressed size
  - LZMA Internal Structures: state_size (16 KB for default settings) 

Interface:
  int LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
      const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode, 
      ELzmaStatus *status, ISzAlloc *alloc);
  In: 
    dest     - output data
    destLen  - output data size
    src      - input data
    srcLen   - input data size
    propData - LZMA properties  (5 bytes)
    propSize - size of propData buffer (5 bytes)
    finishMode - It has meaning only if the decoding reaches output limit (*destLen).
         LZMA_FINISH_ANY - Decode just destLen bytes.
         LZMA_FINISH_END - Stream must be finished after (*destLen).
                           You can use LZMA_FINISH_END, when you know that 
                           current output buffer covers last bytes of stream. 
    alloc    - Memory allocator.

  Out: 
    destLen  - processed output size 
    srcLen   - processed input size 

  Output:
    SZ_OK
      status:
        LZMA_STATUS_FINISHED_WITH_MARK
        LZMA_STATUS_NOT_FINISHED 
        LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
    SZ_ERROR_DATA - Data error
    SZ_ERROR_MEM  - Memory allocation error
    SZ_ERROR_UNSUPPORTED - Unsupported properties
    SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).

  If LZMA decoder sees end_marker before reaching output limit, it returns OK result,
  and output value of destLen will be less than output buffer size limit.

  You can use multiple checks to test data integrity after full decompression:
    1) Check Result and "status" variable.
    2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
    3) Check that output(srcLen) = compressedSize, if you know real compressedSize. 
       You must use correct finish mode in that case. */ 


Multi-call State Decompressing (zlib-like interface)
----------------------------------------------------

When to use: file->file decompressing 
Compile files: LzmaDec.h + LzmaDec.c + Types.h

Memory Requirements:
 - Buffer for input stream: any size (for example, 16 KB)
 - Buffer for output stream: any size (for example, 16 KB)
 - LZMA Internal Structures: state_size (16 KB for default settings) 
 - LZMA dictionary (dictionary size is encoded in LZMA properties header)

1) read LZMA properties (5 bytes) and uncompressed size (8 bytes, little-endian) to header:
   unsigned char header[LZMA_PROPS_SIZE + 8];
   ReadFile(inFile, header, sizeof(header)

2) Allocate CLzmaDec structures (state + dictionary) using LZMA properties

  CLzmaDec state;
  LzmaDec_Constr(&state);
  res = LzmaDec_Allocate(&state, header, LZMA_PROPS_SIZE, &g_Alloc);
  if (res != SZ_OK)
    return res;

3) Init LzmaDec structure before any new LZMA stream. And call LzmaDec_DecodeToBuf in loop

  LzmaDec_Init(&state);
  for (;;)
  {
    ... 
    int res = LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, 
        const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode);
    ...
  }


4) Free all allocated structures
  LzmaDec_Free(&state, &g_Alloc);

Look example code:
  C/Util/Lzma/LzmaUtil.c


How To compress data
--------------------

Compile files: 
  Types.h
  Threads.h	
  LzmaEnc.h
  LzmaEnc.c
  LzFind.h
  LzFind.c
  LzFindMt.h
  LzFindMt.c
  LzHash.h

Memory Requirements:
  - (dictSize * 11.5 + 6 MB) + state_size

Lzma Encoder can use two memory allocators:
1) alloc - for small arrays.
2) allocBig - for big arrays.

For example, you can use Large RAM Pages (2 MB) in allocBig allocator for 
better compression speed. Note that Windows has bad implementation for 
Large RAM Pages. 
It's OK to use same allocator for alloc and allocBig.


Single-call Compression with callbacks
--------------------------------------

Look example code:
  C/Util/Lzma/LzmaUtil.c

When to use: file->file compressing 

1) you must implement callback structures for interfaces:
ISeqInStream
ISeqOutStream
ICompressProgress
ISzAlloc

static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
static void SzFree(void *p, void *address) {  p = p; MyFree(address); }
static ISzAlloc g_Alloc = { SzAlloc, SzFree };

  CFileSeqInStream inStream;
  CFileSeqOutStream outStream;

  inStream.funcTable.Read = MyRead;
  inStream.file = inFile;
  outStream.funcTable.Write = MyWrite;
  outStream.file = outFile;


2) Create CLzmaEncHandle object;

  CLzmaEncHandle enc;

  enc = LzmaEnc_Create(&g_Alloc);
  if (enc == 0)
    return SZ_ERROR_MEM;


3) initialize CLzmaEncProps properties;

  LzmaEncProps_Init(&props);

  Then you can change some properties in that structure.

4) Send LZMA properties to LZMA Encoder

  res = LzmaEnc_SetProps(enc, &props);

5) Write encoded properties to header

    Byte header[LZMA_PROPS_SIZE + 8];
    size_t headerSize = LZMA_PROPS_SIZE;
    UInt64 fileSize;
    int i;

    res = LzmaEnc_WriteProperties(enc, header, &headerSize);
    fileSize = MyGetFileLength(inFile);
    for (i = 0; i < 8; i++)
      header[headerSize++] = (Byte)(fileSize >> (8 * i));
    MyWriteFileAndCheck(outFile, header, headerSize)

6) Call encoding function:
      res = LzmaEnc_Encode(enc, &outStream.funcTable, &inStream.funcTable, 
        NULL, &g_Alloc, &g_Alloc);

7) Destroy LZMA Encoder Object
  LzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);


If callback function return some error code, LzmaEnc_Encode also returns that code
or it can return the code like SZ_ERROR_READ, SZ_ERROR_WRITE or SZ_ERROR_PROGRESS.


Single-call RAM->RAM Compression
--------------------------------

Single-call RAM->RAM Compression is similar to Compression with callbacks,
but you provide pointers to buffers instead of pointers to stream callbacks:

SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark, 
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);

Return code:
  SZ_OK               - OK
  SZ_ERROR_MEM        - Memory allocation error 
  SZ_ERROR_PARAM      - Incorrect paramater
  SZ_ERROR_OUTPUT_EOF - output buffer overflow
  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)



Defines
-------

_LZMA_SIZE_OPT - Enable some optimizations in LZMA Decoder to get smaller executable code.

_LZMA_PROB32   - It can increase the speed on some 32-bit CPUs, but memory usage for 
                 some structures will be doubled in that case.

_LZMA_UINT32_IS_ULONG  - Define it if int is 16-bit on your compiler and long is 32-bit.

_LZMA_NO_SYSTEM_SIZE_T  - Define it if you don't want to use size_t type.


_7ZIP_PPMD_SUPPPORT - Define it if you don't want to support PPMD method in AMSI-C .7z decoder.


C++ LZMA Encoder/Decoder 
~~~~~~~~~~~~~~~~~~~~~~~~
C++ LZMA code use COM-like interfaces. So if you want to use it, 
you can study basics of COM/OLE.
C++ LZMA code is just wrapper over ANSI-C code.


C++ Notes
~~~~~~~~~~~~~~~~~~~~~~~~
If you use some C++ code folders in 7-Zip (for example, C++ code for .7z handling),
you must check that you correctly work with "new" operator.
7-Zip can be compiled with MSVC 6.0 that doesn't throw "exception" from "new" operator.
So 7-Zip uses "CPP\Common\NewHandler.cpp" that redefines "new" operator:
operator new(size_t size)
{
  void *p = ::malloc(size);
  if (p == 0)
    throw CNewException();
  return p;
}
If you use MSCV that throws exception for "new" operator, you can compile without 
"NewHandler.cpp". So standard exception will be used. Actually some code of 
7-Zip catches any exception in internal code and converts it to HRESULT code.
So you don't need to catch CNewException, if you call COM interfaces of 7-Zip.

---

http://www.7-zip.org
http://www.7-zip.org/sdk.html
http://www.7-zip.org/support.html
7-Zip 16.02 Sources
-------------------

7-Zip is a file archiver for Windows. 

7-Zip Copyright (C) 1999-2016 Igor Pavlov.


License Info
------------

7-Zip is free software distributed under the GNU LGPL 
(except for unRar code).
read License.txt for more infomation about license.

Notes about unRAR license:

Please check main restriction from unRar license:

   2. The unRAR sources may be used in any software to handle RAR
      archives without limitations free of charge, but cannot be used
      to re-create the RAR compression algorithm, which is proprietary.
      Distribution of modified unRAR sources in separate form or as a
      part of other software is permitted, provided that it is clearly
      stated in the documentation and source comments that the code may
      not be used to develop a RAR (WinRAR) compatible archiver.

In brief it means:
1) You can compile and use compiled files under GNU LGPL rules, since 
   unRAR license almost has no restrictions for compiled files.
   You can link these compiled files to LGPL programs.
2) You can fix bugs in source code and use compiled fixed version.
3) You can not use unRAR sources to re-create the RAR compression algorithm.


LZMA SDK
--------

This package also contains some files from LZMA SDK
You can download LZMA SDK from:
  http://www.7-zip.org/sdk.html
LZMA SDK is written and placed in the public domain by Igor Pavlov.


How to compile
--------------
To compile sources you need Visual C++ 6.0.
For compiling some files you also need 
new Platform SDK from Microsoft' Site:
http://www.microsoft.com/msdownload/platformsdk/sdkupdate/psdk-full.htm
or
http://www.microsoft.com/msdownload/platformsdk/sdkupdate/XPSP2FULLInstall.htm
or
http://www.microsoft.com/msdownload/platformsdk/sdkupdate/

If you use MSVC6, specify SDK directories at top of directories lists:
Tools / Options / Directories
  - Include files
  - Library files


To compile 7-Zip for AMD64 and IA64 you need:
  Windows Server 2003 SP1 Platform SDK from microsoft.com

Also you need Microsoft Macro Assembler:
  - ml.exe for x86 
  - ml64.exe for AMD64
You can use ml.exe from Windows SDK for Windows Vista or some other version.


Compiling under Unix/Linux
--------------------------
Check this site for Posix/Linux version:
http://sourceforge.net/projects/p7zip/


Notes:
------
7-Zip consists of COM modules (DLL files).
But 7-Zip doesn't use standard COM interfaces for creating objects.
Look at
7zip\UI\Client7z folder for example of using DLL files of 7-Zip. 
Some DLL files can use other DLL files from 7-Zip.
If you don't like it, you must use standalone version of DLL.
To compile standalone version of DLL you must include all used parts
to project and define some defs. 
For example, 7zip\Bundles\Format7z is a standalone version  of 7z.dll 
that works with 7z format. So you can use such DLL in your project 
without additional DLL files.


Description of 7-Zip sources package
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DOC                Documentation
---
  7zFormat.txt   - 7z format description
  copying.txt    - GNU LGPL license
  unRarLicense.txt - License for unRAR part of source code
  src-history.txt  - Sources history
  Methods.txt    - Compression method IDs
  readme.txt     - Readme file
  lzma.txt       - LZMA compression description
  7zip.nsi       - installer script for NSIS
  7zip.wix       - installer script for WIX


Asm - Source code in Assembler (optimized code for CRC calculation and Intel-AES encryption)

C   - Source code in C

CPP - Source code in C++

Common            common files for C++ projects

Windows           common files for Windows related code

7zip

  Common          Common modules for 7-zip

  Archive         files related to archiving

  Bundle          Modules that are bundles of other modules (files)

    Alone         7za.exe: Standalone version of 7-Zip console that supports only 7z/xz/cab/zip/gzip/bzip2/tar.
    Alone7z       7zr.exe: Standalone version of 7-Zip console that supports only 7z (reduced version)
    Fm            Standalone version of 7-Zip File Manager
    Format7z            7za.dll:  .7z support
    Format7zExtract     7zxa.dll: .7z support, extracting only
    Format7zR           7zr.dll:  .7z support, reduced version
    Format7zExtractR    7zxr.dll: .7z support, reduced version, extracting only
    Format7zF           7z.dll:   all formats
    LzmaCon       lzma.exe: LZMA compression/decompression
    SFXCon        7zCon.sfx: Console 7z SFX module
    SFXWin        7z.sfx: Windows 7z SFX module
    SFXSetup      7zS.sfx: Windows 7z SFX module for Installers

  Compress        files for compression/decompression

  Crypto          files for encryption / decompression

  UI

    Agent         Intermediary modules for FAR plugin and Explorer plugin
    Client7z      Test application for 7za.dll 
    Common        Common UI files
    Console       7z.exe : Console version
    Explorer      7-zip.dll: 7-Zip Shell extension
    Far           plugin for Far Manager
    FileManager   7zFM.exe: 7-Zip File Manager
    GUI           7zG.exe: 7-Zip GUI version



---
Igor Pavlov
http://www.7-zip.org
HISTORY of the 7-Zip source code
--------------------------------

16.02          2016-05-21
-------------------------
- The BUG in 16.00 - 16.01 was fixed:
  Split Handler (SplitHandler.cpp) returned incorrect 
  total size value (kpidSize) for split archives.


16.01          2016-05-19
-------------------------	
- Some bugs were fixed,
- Some internal changes to reduce the number of compiler warnings.


16.00          2016-05-10
-------------------------	
- 7-Zip now can extract multivolume ZIP archives (z01, z02, ... , zip).
- Some bugs were fixed,


15.12          2015-11-19
-------------------------	
- The BUG in C version of 7z decoder was fixed:
  7zDec.c : SzDecodeLzma2()
  7z decoder could mistakenly report about decoding error for some 7z archives
  that use LZMA2 compression method.
  The probability to get that mistaken decoding error report was about 
  one error per 16384 solid blocks for solid blocks larger than 16 KB (compressed size). 
- The BUG (in 9.26-15.11) in C version of 7z decoder was fixed:
  7zArcIn.c : SzReadHeader2()
  7z decoder worked incorrectly for 7z archives that contain 
  empty solid blocks, that can be placed to 7z archive, if some file is 
  unavailable for reading during archive creation.


15.09 beta     2015-10-16
-------------------------	
- The BUG in LZMA / LZMA2 encoding code was fixed.
  The BUG in LzFind.c::MatchFinder_ReadBlock() function.
  If input data size is larger than (4 GiB - dictionary_size),
  the following code worked incorrectly:
  -  LZMA : LzmaEnc_MemEncode(), LzmaEncode() : LZMA encoding functions 
     for compressing from memory to memory. 
     That BUG is not related to LZMA encoder version that works via streams.
  -  LZMA2 : multi-threaded version of LZMA2 encoder worked incorrectly, if 
     default value of chunk size (CLzma2EncProps::blockSize) is changed 
     to value larger than (4 GiB - dictionary_size).


9.38 beta      2015-01-03
-------------------------	
- The BUG in 9.31-9.37 was fixed:
  IArchiveGetRawProps interface was disabled for 7z archives.
- The BUG in 9.26-9.36 was fixed:
  Some code in CPP\7zip\Archive\7z\ worked correctly only under Windows.


9.36 beta      2014-12-26
-------------------------	
- The BUG in command line version was fixed:
  7-Zip created temporary archive in current folder during update archive
  operation, if -w{Path} switch was not specified. 
  The fixed 7-Zip creates temporary archive in folder that contains updated archive.
- The BUG in 9.33-9.35 was fixed:
  7-Zip silently ignored file reading errors during 7z or gz archive creation,
  and the created archive contained only part of file that was read before error.
  The fixed 7-Zip stops archive creation and it reports about error.


9.31           2012-10-31
-------------------------
- InBuffer.h : CInBuffer  uses ISequentialInStream  *_stream; instead of CMyComPtr<ISequentialInStream> 
  OutBuffer.h: COutBuffer uses ISequentialOutStream *_stream; instead of CMyComPtr<ISequentialOutStream> 
	

9.26           2011-04-11
-------------------------
- The BUG was fixed: multi-threaded ZIP stored file size that was at scan stage,
  So if the file was changed after scan, the Unpack Size field was incorrect
	

9.21           2011-04-11
-------------------------	
- New class FString for file names at file systems.
- Speed optimization in CRC code for big-endian CPUs.


9.18           2010-11-02
-------------------------	
- New small SFX module for installers (C/Util/SfxSetup).


9.17           2010-10-04
-------------------------
- IStream.h::IOutStream::
    STDMETHOD(SetSize)(Int64 newSize) PURE;
  was changed to
    STDMETHOD(SetSize)(UInt64 newSize) PURE;


9.09           2009-12-12
-------------------------
- The bug was fixed:
   Utf16_To_Utf8 funstions in UTFConvert.cpp and 7zMain.c
   incorrectly converted surrogate characters (the code >= 0x10000) to UTF-8.


9.05           2009-07-05
-------------------------
- FileMapping.h::CFileMapping now returns WRes


9.04           2009-05-30
-------------------------
- ICoder.h: NCoderPropID::EEnum values were changed


9.02           2009-04-23
-------------------------
- Bug was fixed: if swap2 filter was requests at compression,
  7-zip used swap4 filter instead (but id was swap2), so archives were incorrect.
  
4.61           2008-11-23
-------------------------
- Bug in ver. 4.58+ was fixed:
   7-Zip didn't use any -m* switch after -mtc, -mcl or -mcu for .zip archives. 
- Bug in .CAB code was fixed. 7-Zip didn't show some empty files,
  if .CAB archive contains more than one empty file.
   

4.59           2008-07-27
-------------------------
- Bug was fixed:
   LZMA Encoder in fast compression mode could access memory outside of 
   allocated range in some rare cases.
   

4.59 alpha     2008-05-30
-------------------------
- BUGS was fixed: 
    7zOut.cpp: 7-Zip incorrectly wrote size of property records in some cases.
    7zIn.cpp:  7-Zip incorrectly work with archive, containg archive properties.

4.58 alpha 9   2008-04-29
-------------------------
- BUG was fixed: 7-Zip showed incorrect timestamps in ISO files.


4.58 alpha 8   2008-04-15
-------------------------
- BUG in 4.58 alpha 5/6/7 was fixed:
    LZMA encoder worked incorrectly, if lp != 0.
- Unicode (UTF-8) support for filenames in .ZIP archives. Now there are 3 modes:
    1) Default mode: 7-Zip uses UTF-8, if the local code page doesn't contain required symbols.
    2) -mcu switch:  7-Zip uses UTF-8, if there are non-ASCII symbols.
    3) -mcl switch:  7-Zip uses local code page.
- Now it's possible to use -mSW- and -mSW+ switches instead of -mSW=off and -mSW=on  


4.58 alpha 7   2008-04-08
-------------------------
- BUG was fixed: BZip2Encoder and BZip2Decoder used CEvent objects without 
  creating, when BZip2 code was called with one thread (with -mmt1 switch or with 
  default switches on single thread CPU).
- .lzma support.
- RPM and NSIS support was improved.
- LZMA now stores only (2 << n) or (3 << n) dictionary size value to LZMA properties.


4.58 alpha 6   2008-03-27
-------------------------
- NTFS time extra in ZIP.
- New item property - kpidTimeType - VT_UI4 (0 - NTFS, 1 - Unix, 2 - DOS).
- Static CRC table is not required now for Lzma Encoder (in Lz MatchFinder).


4.58 alpha 5   2008-03-19
-------------------------
- Creation time (-mtc switch) for .7z archives
- LZMA encoder was converted to ANSI-C


4.58 alpha 3   2008-02-25
-------------------------
- Speed optimizations for LZMA decoding. Now it uses C code instead of C++.
- 7-Zip now has 128 MB dictionary limit for 32-bit version:
  It's for speed optimization: kNumLogBits = 9 + sizeof(size_t) / 2;
- TAR: 'D' link flag support.
- 7-Zip now can unpack multivolume RAR archives created with 
  "old style volume names" scheme (-vn switch) and names *.001, *.002, ...
- Fixed bugs:
  - 7-Zip FM could not copy / move files to root network folders like \\COMPNAME\FOLDERNAME\
    In case of move it removed original files.
  - SFX-WIN: if there are errors, it still could return 0.
  - ZIP (.XPS file) isZip64 && thisDiskNumber16 == 0xFFFF.
  - ZIP name updating:
      If zip file contains extra field and you try to change properties of files,
      7-zip tries to delete all extra fileds (except for WzAES).
      And that code could hang.
  -  7-Zip GUI didn't suggest BZip2 dictionary size used in previous run.
  -  If creation time stamp was included in .RAR archive, 7-zip used creation time stamp 
     as modification time stamp.

4.58 alpha 2   2007-12-31
-------------------------
- Small changes in Deflate and LZMA compression.
- Some speed optimizations.


4.57
----
- Bug was fixed:
  Anti item is created for wrong file:
  http://sourceforge.net/forum/forum.php?thread_id=1880366&forum_id=45798


4.52 beta      2007-07-32
-------------------------
- 7-Zip could not decompress some cab files
- "." dir creating at FAT was fixed / long names


4.50 beta      2007-07-24
-------------------------
- 7-Zip now replaces unsupported filenames (like "nul", "com1") during extracting.
- New switch for command line version:
    -ssc[-] enables/disables case-sensitive mode.
- 7z.exe l shows archive comment for zip archives
- Some bugs were fixed: long paths names shorter than 4.
- Speed optimizations for AES encryption.



4.56 beta      2007-09-13
-------------------------
- some fixes in LZ encoder (LZMA and Deflate) code.
 size_t was replaces to ptrdiff_t.
 size_t version worked incorrectly with some compilers.

 
4.46 beta      2007-05-25
-------------------------
- CPP Synchronization objects now return HRes (error code) instead of bool.


4.45 beta      2007-04-16
-------------------------
- 7-Zip now uses C version of CRC, so you must call CrcGenerateTable at 
  stratup code, or you must add CPP/Common/CRC.cpp to your project.
- Method ID in .7z now is 63-bit integer (UInt64).
- Open error messages
- unRar 1.5 fixed
- unShrink fixed
- BUG of 4.43 beta and 4.44 beta was fixed.
  7-Zip compressing to .zip in multi-threading mode didn't work in some cases.


4.44 beta      2007-01-20
-------------------------

- Bug was fixed: LZMAEncoder.cpp::CEncoder::GetOptimumFast
  it was:
    data++
  fixed version:
    data = _matchFinder.GetPointerToCurrentPos(_matchFinderObj) - 1;
  It could lead to very small cpmpression ratio decreasing when block needs move.


4.30 beta      2005-11-18
-------------------------
- Security.h::AddLockMemoryPrivilege       - installs "Large pages" feature
- MemoryLock.h::EnableLockMemoryPrivilege  - enables "Large pages" feature
- Alloc.h::SetLargePageSize                - sets optimal LargePageSize size


4.27           2005-09-21
-------------------------
- Some GUIDs/interfaces were changed.
 IStream.h:
   ISequentialInStream::Read now works as old ReadPart
   ISequentialOutStream::Write now works as old WritePart


4.26 beta      2005-08-05
-------------------------
-  MyAlloc(0)/BigAlloc(0) now return 0


4.25 beta      2005-07-31
-------------------------
-  More 64-bit compatibilty


4.24 beta      2005-07-06
-------------------------
-  Common\NewHandler.h: using throw() for code size optimization.


4.23           2005-06-29
-------------------------
-  Bug was fixed: memory leak in Cab decoder.


4.19 beta      2005-05-21
-------------------------
-  BZip2 code was rewritten. Now 7-Zip doesn't use original BZip2 code.
  Old (original) version was moved to folder 7zip/Compress/BZip2Original/


4.14 beta      2005-01-11
-------------------------
-  STL using was reduced
-  7za now supports Split(001) archves


4.10 beta      2004-10-21
-------------------------
-  Codecs now use new interface: ICompressSetDecoderProperties2


4.07 beta      2004-10-03
-------------------------
-  some interfaces were changed slightly to support 
  -stdin -stdout mode.
-  FilterCoder for simple filters
-  Wildcard censor class was changed.
-  Bug was fixed: when encrypted stream was multiple 16,
  it used additional 16 empty bytes.


3.11           2003-10-06
-------------------------
  File functions support unicode strings even
  on Windows 95/98/ME.


3.08.02        2003-09-20
-------------------------
  More compatible with GCC.


3.08.02 beta   2003-08-20
-------------------------
  Extracting bug in 7zExtract.cpp was fixed.
 

3.08 beta      2003-08-19
-------------------------
  Big source code reconstruction.
 

2.30 Beta 32   2003-05-15
-------------------------
  Small changes in Deflate decoder.
 

2.30 Beta 31   2003-04-29
-------------------------
  Common/NewHandler.cpp
    HeapAlloc in (included to beta 30) was changed to malloc.
    HeapAlloc worked slower in Win95/98/Me.
 

2.30 Beta 30   2003-04-21
-------------------------
  new file: Common/String.cpp
  Common/NewHandler.*  were changed


2.30 Beta 29   2003-04-07
-------------------------
  Small changes in LZMA code.


2.30 Beta 28   2003-02-16
-------------------------
  Processing anti-files was corrected.


2.30 Beta 27   2003-01-24
-------------------------
  Project/Archiver/Format/Common/ArchiveInterface.h:
    new IArchiveOpenVolumeCallback interface.


2.30 Beta 26   2003-01-12
-------------------------
  SDK/Interface/PropID.h:
    kpidComment now is kpidCommented


2.30 Beta 25   2003-01-02
-------------------------
  Main archive interfaces were changed.


2.30 Beta 24   2002-11-01
-------------------------
  SDK/Windows/Synchronization.h 
  SDK/Windows/Synchronization.cpp
    - some changes.


2.30 Beta 23   2002-09-07
-------------------------
  Project/FileManager folder was added.
  Notation of some source files was changed.


2.30 Beta 22   2002-08-28
-------------------------
  Project/FileManager folder was added.
  Notation of some source files was changed.



2.30 Beta 21   2002-07-08
-------------------------
  Project/Compress/LZ/MatchFinder/BinTree/BinTree.h
  Project/Compress/LZ/MatchFinder/BinTree/BinTreeMain.h
  Project/Compress/LZ/MatchFinder/BinTree/HC.h
  Project/Compress/LZ/MatchFinder/BinTree/HCMain.h
    - RAM requirements for LZMA (7z) compression were reduced.


2.30 Beta 20   2002-07-01
-------------------------
- SDK/Stream/WindowOut.h 
    now it uses only required memory (dictionary size).
- Project/Archiver/Resource 
    contains common resurces


2.30 Beta 19   2002-04-11
-------------------------
- SDK/Archive/Rar/Handler.cpp
    supporting RAR29

2.30 Beta 18   2002-03-25
-------------------------
- SDK/Archive/Cab/MSZipDecoder.cpp
  SDK/Archive/Cab/LZXDecoder.cpp:
    bug with corrupted archives was fixed
- Project/Compress/LZ/MatchFinder/BinTree/BinTree.h 
- Project/Compress/LZ/MatchFinder/BinTree/BinTreeMain.h 
    some speed optimization (using prefetching)


2.30 Beta 17   2002-03-03
-------------------------
- ARJ suppport.


2.30 Beta 16   2002-02-24
-------------------------
- Project/Compress/LZ/LZMA/Decoder.cpp:
    Bug was fixed: LZMA could not extract more than 4 GB.
- RPM and CPIO formats.
- Project/Compress/LZ/LZMA/Encoder.*
  Project/Archiver/Format/7z/OutHandler.cpp 
    New fast compression mode for LZMA: -m0a=0.
- New match finders for LZMA: bt4b, hc3, hc4.


2.30 Beta 15   2002-02-17
-------------------------
- Compression ratio in LZMA was slightly improved:
    Project/Compress/LZ/LZMA/Encoder.*
    Project/Archiver/Format/7z/OutHandler.cpp 


2.30 Beta 14   2002-02-10
-------------------------
- Supporting multithreading for LZMA:
    Project/Compress/LZ/MatchFinder/MT 
- Common/String.h:
    CStringBase::Replace function was fixed.


2.30 Beta 13   2002-01-27
-------------------------
- Compress/LZ/MatchFinder/BinTree3.h: 
   method
- Compress/LZ/MatchFinder/BinTreemain.h: 
    - one VirtualAlloc array was splitted to 
      the for 3 arrays.
    - Hash-functions were changed.



2.30 Beta 12   2002-01-16
-------------------------
- Compress/LZ/MatchFinder/BinTreemain.h: 
  Compress/LZ/MatchFinder/Patricia.h: 
  Compress/PPM/PPMd/SubAlloc.h: 
    Beta 11 bugs were fixed:
      - VirtualFree was used incorrectly
      - checking WIN32 instead _WINDOWS.
  Compress/LZ/MatchFinder/Patricia.h: 
    Beta 11 bug with deleting m_Hash2Descendants was fixed.


2.30 Beta 11   2002-01-15
-------------------------
- Compress/LZ/MatchFinder/BinTreemain.h: 
  Compress/LZ/MatchFinder/Patricia.h: 
  Compress/PPM/PPMd/SubAlloc.h: 
    using VirtualAlloc for memory allocating
- Exlorer/ContextMenu.cpp: 
    Testing supporting.
    CreateProcess instead WinExec
- Format/Common/IArchiveHandler.h:
  Exlorer/ProxyHandler.cpp:
  FAR/Plugin.cpp:
    New properties names: Method, HostOS.
- Exlorer/OverwriteDialog.cpp:
  FAR/OverwriteDialog.cpp:
  Windows/PropVariantConversions.h
    Using National time format was eliminated.



2.30 Beta 10   2002-01-11
-------------------------
- Exlorer/ContextMenu.cpp: bug with context menu on 
  Windows NT4 in Unicode version was fixed.
- Format/7z/UpdateArchiveEngine.cpp: bug was fixed - 
  Updating in Beta 8 and 9 didn't work.
- Exlorer/CCompressDialog.cpp: history growing bug was fixed.


2.30 Beta 9    2002-01-08
-------------------------
- SDK/Common/Vector.h: sopporting sorted object vectors .
- Lang features.
- Two new match finders: pat3h and pat4h.
- SDK/Archive/Zip/InEngine.cpp: bug was fixed.
- SDK/Windows/FileDir.cpp: function CreateComplexDirectory
  was changed.

 ******    *****   ******   unRAR - free utility for RAR archives
 **   **  **   **  **   **  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ******   *******  ******    License for use and distribution of
 **   **  **   **  **   **   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 **   **  **   **  **   **         FREE portable version
                                   ~~~~~~~~~~~~~~~~~~~~~

      The source code of unRAR utility is freeware. This means:

   1. All copyrights to RAR and the utility unRAR are exclusively
      owned by the author - Alexander Roshal.

   2. The unRAR sources may be used in any software to handle RAR
      archives without limitations free of charge, but cannot be used
      to re-create the RAR compression algorithm, which is proprietary.
      Distribution of modified unRAR sources in separate form or as a
      part of other software is permitted, provided that it is clearly
      stated in the documentation and source comments that the code may
      not be used to develop a RAR (WinRAR) compatible archiver.

   3. The unRAR utility may be freely distributed. No person or company 
      may charge a fee for the distribution of unRAR without written
      permission from the copyright holder.

   4. THE RAR ARCHIVER AND THE UNRAR UTILITY ARE DISTRIBUTED "AS IS".
      NO WARRANTY OF ANY KIND IS EXPRESSED OR IMPLIED.  YOU USE AT 
      YOUR OWN RISK. THE AUTHOR WILL NOT BE LIABLE FOR DATA LOSS, 
      DAMAGES, LOSS OF PROFITS OR ANY OTHER KIND OF LOSS WHILE USING
      OR MISUSING THIS SOFTWARE.

   5. Installing and using the unRAR utility signifies acceptance of
      these terms and conditions of the license.

   6. If you don't agree with terms of the license you must remove
      unRAR files from your storage devices and cease to use the
      utility.

      Thank you for your interest in RAR and unRAR.


                                            Alexander L. Roshal<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>7-Zip Start Page</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>7-Zip</H1>

<P><B>Welcome to 7-Zip 16.02</B></P> 
<P>7-Zip is a file archiver with a high compression ratio.</P>

<H4>The documentation for 7-Zip includes:</H4>

<UL>
  <LI><A href = "general/index.htm">General information about 7-Zip</A></LI>
  <LI><A href = "fm/index.htm">User's Guide for 7-Zip File Manager</A></LI>
  <LI><A href = "cmdline/index.htm">User's Guide for command line version</A></LI>
</UL>

<H4>See Also</H4>

<UL>
  <LI><A href = "general/faq.htm">Frequently Asked Questions (FAQ)</A></LI>
  <!-- <LI><A href = "general/license.htm">License for use and distribution</A></LI> -->
</UL>

<HR>

<P>Copyright (c) 1999-2016 Igor Pavlov</P>
<P><B>Web site:</B> <A href="http://www.7-zip.org" target="_blank">www.7-zip.org</A></P>
<P><B>Support:</B> <A href="http://www.7-zip.org/support.html" target="_blank">www.7-zip.org/support.html</A></P>

</BODY>
</HTML>
body
  {
  padding: 0px 0px 0px 26px;
  background: #ffffff; 
  color: #000000;
  font-family: Verdana, Arial, Helvetica, sans-serif;
  font-size: 80%;
  }

div
  {
  width: 90%;
  border: 2px solid #999999;
  padding: 4px 8px;
  background: #cccccc;
  }
  
h1, h2, h3, h4
  {
  font-family: Verdana, Arial, Helvetica, sans-serif;
  margin-left: -26px;
  }
  
h1
  {
  font-size: 145%;
  margin-top: .5em;
  margin-bottom: 1em; 
  }
  
h2
  {
  font-size: 130%;
  margin-top: 1.5em;
  margin-bottom: .6em; 
  }
  
h3
  {
  font-size: 115%;
  margin-top: 1.5em;
  margin-bottom: .6em;
  }
  
h4
  {
  font-size: 100%;
  margin-top: 1.5em;
  margin-bottom: .6em; 
  }

ul p, ol p, dl p
  {
  margin-left: 0em;
  }

p
  {
  margin-top: .6em;
  margin-bottom: .6em;
  }

dl
  {
  /*margin-top: 0em; */
  }

dt
  {
  margin-top: .76em;
  margin-bottom: .5em;
  font-weight: bold;
  }

dd
  {
  margin-top: .5em;
  margin-bottom: .5em;  
  margin-left: 1.9em; 
  }


ul, ol
  {
  margin-top: .6em;   
  margin-bottom: 0em;
  }
  
ol
  {
  margin-left: 3.6em; 
  } 
  
ul
  {
  list-style-type: disc; 
  margin-left: 1.9em; 
  }

li
  {
  margin-bottom: .6em;
  }

ul ol, ol ol
  {
  list-style-type: lower-alpha;
  {

  /*
pre
  {
  margin-top: .6em;
  margin-bottom: .6em; 
  }
  */

pre,code
  {
  font: 100% Courier New, Courier, mono; 
  color: #000000;
  cursor: text;
  }

pre.syntax
  {
  background: #dddddd;
  padding: 2pt,4pt
  }

pre.syntax
  {
  color: #000000;
  }

pre.example
  {
  margin-left: 2.0em;
  /*margin-top: 12.0em;*/
  /*margin-bottom: 1.0em;*/
  color: #C00000;
  /*padding: 10pt,20pt*/
  }

table
  {
  /* width: 90%; */
  background: #999999;
  margin-top: .6em;
  margin-bottom: .3em;
  }
    
th
  { 
  padding: 4px 8px;
  background: #cccccc;
  text-align: left;
  font-size: 80%;
  vertical-align: bottom;
  }

th.cc
  { 
  text-align: center;
  vertical-align: middle;
  }

td
  { 
  padding: 4px 8px;
  background: #ffffff;
  vertical-align: top;
  font-size: 80%;
  }

td.cc
  { 
  text-align: center;
  vertical-align: middle;
  }


blockquote
  {
  margin-left: 3.8em;
  margin-right: 3.8em;
  margin-top: .6em;
  margin-bottom: .6em;
  }

a:link
  {
  color: #0066ff;
  }
  
a:visited
  {
  color: #996600; 
  }
  
a:hover
  {
  color: #cc9900;
  }
  
a.parameter:link
  {
  color: #0066ff;
  text-decoration:none;
  }

a.parameter:visited
  {
  text-decoration:none;
  }

div.footer
  {
  width: 100%;
  border: none;
  background: #ffffff;
  margin-top: 18pt;
  padding-bottom: 12pt;
  color: #228B22;
  text-align: center;
  font-size: 70%;
  }

span.filename
{
  color: #F00000;
}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Exit Codes from 7-Zip</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Exit Codes from 7-Zip</H1>

<P>7-Zip returns the following exit codes:</P>

<TABLE>
  <TR><TH>Code</TH><TH>Meaning</TH></TR>
  <TR><TD>0</TH><TD>No error</TD></TR>
  <TR><TD>1</TH><TD>Warning (Non fatal error(s)). For example, one or more files were
  locked by some other application, so they were not compressed.</TD></TR>
  <TR><TD>2</TH><TD>Fatal error</TD></TR>
  <TR><TD>7</TH><TD>Command line error</TD></TR>
  <TR><TD>8</TH><TD>Not enough memory for operation</TD></TR>
  <TR><TD>255</TH><TD>User stopped the process</TD></TR>
</TABLE>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Command Line Version User's Guide</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Command Line Version User's Guide</H1>


<P>7z.exe is the command line version of 7-Zip. 7z.exe uses 7z.dll
from the 7-Zip package. 7z.dll is used by the 7-Zip File Manager also.</LI>

<P>7za.exe (a = alone) is a standalone version of 7-Zip.
7za.exe supports only 7z, lzma, cab, zip, gzip, bzip2, Z and tar formats.
7za.exe doesn't use external modules.</LI>

<UL>
  <LI><A href = "syntax.htm">Command Line syntax</A></LI>
  <LI><A href = "exit_codes.htm">Exit Codes</A></LI>
  <LI><A href = "commands/index.htm">Commands</A></LI>
  <LI><A href = "switches/index.htm">Switches</A></LI>
</UL>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Command Line Syntax</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Command Line Syntax</H1>

<PRE class = "syntax">
7z <A href = "commands/index.htm">&lt;command></A> [<A href = "switches/index.htm">&lt;switch></A>...] &lt;base_archive_name> [&lt;arguments>...]
</PRE>
<PRE class = "syntax">
&lt;arguments> ::= <A href = "switches/index.htm">&lt;switch></A> | &lt;wildcard> | &lt;filename> | &lt;list_file>
<A href = "switches/index.htm">&lt;switch></A>::= &lt;switch_symbol>&lt;switch_characters>[&lt;option>]
&lt;switch_symbol> ::= '/' | '-' 
&lt;list_file> ::= @{filename}
</PRE>


<P>Expressions in square brackets (between '[' and ']') are optional.</P>

<P>Expressions in curly braces ('{' and '}') mean that instead of that 
Expression (including braces), the user must substitute some string.</P>

<P>Expression</P>

<PRE class = "syntax">
expression1 | expression2 | ... | expressionN</DT>
</PRE>

<P>
means that any (but only one) from these expressions must be specified.

<P><A href = "commands/index.htm">Commands</A> and
<A href = "switches/index.htm">switches</A> can be entered in upper or lower case.</P>

<P>Command is the first non-switch argument.</P>

<P>The "base_archive_name" must be the first filename on the command line
after the command.</P>

<P>The switches and other filenames can be in any order.</P>

<P>Wildcards or filenames with spaces must be quoted:</P>

<PRE>
    "Dir\Program files\*"
    Dir\"Program files"\*
</PRE>

<P>Switch options can be combined to save command line length. However, some
switch options take optional string arguments and therefore, must be the
last option in a combined argument token string because 7-Zip accepts the
rest of the argument token as the optional argument.</P>

<P>7-Zip uses wild name matching similar to Windows 95:</P>
<UL>
  <LI><B>'*'</B> means a sequence of arbitrary characters.</LI>
  <LI><B>'?'</B> means any character.</LI>
</UL>

<P><B>
7-Zip doesn't use the system wildcard parser.   7-Zip doesn't
follow the archaic rule by which *.* means any file. 7-Zip treats
*.* as matching the name of any file that has an extension. To process all files, you must
use a * wildcard.</B></P>

<P>Examples:</P>
<TABLE border = "0">
  <TR><TD>*.txt</TD><TD>means all files with an extension of ".txt"</TD></TR>
  <TR><TD>?a*</TD><TD>means all files with a second character of "a"</TD></TR>
  <TR><TD>*1*</TD><TD>means all names that contains character "1"</TD></TR>
  <TR><TD>*.*.*</TD><TD>means all names that contain two at least "." characters</TD></TR>
</TABLE>


<P>The default wildcard "*" will be used if there is no filename/wildcard in the
command line.</P>

<P>Slash ('\') at the end of a path means a directory. Without a Slash ('\') at
the end of the path, the path can refer either to a file or a directory.


<H2><A name = "ListFile"></A>List file</H2>

<P>You can supply one or more filenames or wildcards for special list files
(files containing lists of files). The filenames in such list file must be
separated by new line symbol(s).</P>

<P>For list files, 7-Zip uses UTF-8 encoding by default. You can change encoding
using <A href = "switches/charset.htm">-scs</A> switch.</P>

<P>Multiple list files are supported.</P>

<P>For example, if the file "listfile.txt" contains the following:</P>

<PRE>
    My programs\*.cpp
    Src\*.cpp
</PRE>
<P>then the command</P>

<PRE>
    7z a -tzip archive.zip @listfile.txt
</PRE>

<P>adds to the archive "archive.zip" all "*.cpp" files from directories "My
programs" and "Src".</P>

<H2><A name = "ListFile"></A>Short and Long File Names</H2>

<P>7-Zip supports short file names  (like FILENA~1.TXT) in some cases. 
However, it's strongly recommended to use only the real (long) file names.</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>a (Add) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>a (Add) command</H1>

<P>Adds files to archive.</P>

<H4>Examples</H4>

<PRE class="example">
7z a archive1.zip subdir\
</PRE>

<P>adds all files and subfolders from folder <SPAN class="filename">subdir</SPAN> to archive
  <SPAN class="filename">archive1.zip</SPAN>. 
  The filenames in archive will contain <SPAN class="filename">subdir\</SPAN> prefix.</P>

<PRE class="example">
7z a archive2.zip .\subdir\*
</PRE>

<P>adds all files and subfolders from folder <SPAN class="filename">subdir</SPAN> to archive
  <SPAN class="filename">archive2.zip</SPAN>.
  The filenames in archive will not contain <SPAN class="filename">subdir\</SPAN> prefix.</P>


<PRE class="example">
cd /D c:\dir1\
7z a c:\archive3.zip dir2\dir3\ 
</PRE>

The filenames in archive <SPAN class="filename">c:\archive3.zip</SPAN> 
will contain <SPAN class="filename">dir2\dir3\</SPAN> prefix, 
but they will not contain <SPAN class="filename">c:\dir1\</SPAN> prefix.

<PRE class="example">
7z a Files.7z *.txt -r
</PRE>

<P>adds all *.txt files from current folder and its subfolders to archive
    <SPAN class="filename">Files.7z</SPAN>.</P>


<H4>Notes</H4>

<P>7-Zip doesn't use the system wildcard parser. 7-Zip doesn't
follow the archaic rule by which *.* means any file. 7-Zip treats
*.* as matching the name of any file that has an extension. To process 
all files, you must use a * wildcard.</P>


<H4>Switches that can be used with this command</H4>

<P>
  <A href="../switches/include.htm">-i (Include)</A><BR>
  <A href="../switches/method.htm">-m (Method)</A><BR>
  <A href="../switches/password.htm">-p (Set Password)</A><BR>
  <A href="../switches/recurse.htm">-r (Recurse)</A><BR>
  <A href="../switches/sdel.htm">-sdel (Delete files after including to archive)</A><BR>
  <A href="../switches/sfx.htm">-sfx (create SFX)</A><BR>
  <A href="../switches/stdin.htm">-si (use StdIn)</A><BR>
  <A href="../switches/sni.htm">-sni (Store NT security information)</A><BR>
  <A href="../switches/sns.htm">-sns (Store NTFS alternate Streams)</A><BR>
  <A href="../switches/stdout.htm">-so (use StdOut)</A><BR>
  <A href="../switches/spf.htm">-spf (Use fully qualified file paths)</A><BR>
  <A href="../switches/shared.htm">-ssw (Compress shared files)</A><BR>
  <A href="../switches/stl.htm">-stl (Set archive timestamp from the most recently modified file)</A><BR>
  <A href="../switches/type.htm">-t (Type of archive)</A><BR>
  <A href="../switches/update.htm">-u (Update)</A><BR>
  <A href="../switches/volume.htm">-v (Volumes)</A><BR>
  <A href="../switches/working_dir.htm">-w (Working Dir)</A><BR>
  <A href="../switches/exclude.htm">-x (Exclude)</A><BR>
</P>

<H4>See also</H4>

<P>
  <B>Commands:</B>
    <A href="delete.htm">d (Delete)</A>,
    <A href="update.htm">u (Update)</A><BR>
  <B>Switches:</B>
    <A href="../switches/update.htm">-u (Update)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>b (Benchmark) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>b (Benchmark) command</H1>

<P>Measures speed of the CPU and checks RAM for errors.</P>

<H4>Syntax</H4>

<PRE class="syntax">
b [number_of_iterations] [-mmt{N}] [-md{N}] [-mm={Method}]
</PRE>

<P>There are two tests:<P>
<OL>
  <LI>Compressing with LZMA method
  <LI>Decompressing with LZMA method
</OL>

<P>The benchmark shows a rating in MIPS (million instructions per second).
The rating value is calculated from the measured CPU speed and it
is normalized with results of Intel Core 2 CPU with multi-threading option 
switched off. So if you have Intel Core 2 Duo, 
rating values must be close to real CPU frequency.</P>

<P>You can change the upper dictionary size to increase memory usage by -md{N} switch.
Also, you can change the number of threads by -mmt{N} switch.</P>

<P>The <B>Dict</B> column shows dictionary size. For example, 21 means 2^21 = 2 MB.</P>

<P>The <B>Usage</B> column shows the percentage of time the processor is working.
It's normalized for a one-thread load. For example, 180% CPU Usage for 2 threads
can mean that average CPU usage is about 90% for each thread.</P>

<P>The <B>R / U</B> column shows the rating normalized for 100% of CPU usage.
That column shows the performance of one average CPU thread.</P>

<P><B>Avr</B> shows averages for different dictionary sizes.</P>
<P><B>Tot</B> shows averages of the compression and decompression ratings.</P>

<P>Compression speed and rating strongly depend on memory (RAM) latency.

<P>Decompression speed and rating strongly depend on the integer performance of the CPU.
For example, the Intel Pentium 4 has big branch
misprediction penalty (which is an effect of its long pipeline) and pretty slow
multiply and shift operations. So, the Pentium 4 has pretty low decompressing ratings.</P>

<P>You can run a CRC calculation benchmark by specifying -mm=crc.
That test shows the speed of CRC calculation in MB/s. The first column shows the size of the block.
The next column shows the speed of CRC calculation for one thread. The other columns are results
for multi-threaded CRC calculation.</P> 

<P>With -mm=* switch you can run a complex benchmark. It tests hash calculation methods, 
compression and encryption codecs of 7-Zip.
Note that the tests of LZMA have big weight in "total" results.
And the results are normilized with AMD K8 cpu in complex benchmark.</P> 
                                                       
<H4>Examples</H4>

<PRE class="example">
7z b
</PRE>
runs benchmarking.

<PRE class="example">
7z b -mmt1 -md26
</PRE>
runs benchmarking with one thread and 64 MB dictionary.

<PRE class="example">
7z b 30
</PRE>
<P>runs benchmarking with default settings for 30 iterations.</P>

<PRE class="example">
7z b -mm=*
</PRE>
<P>runs complex 7-Zip benchmark.</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>d (Delete) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>d (Delete) command</H1>

<P>Deletes files from archive.</P>

<H4>Example</H4>

<PRE class="example">
7z d archive.zip *.bak -r
</PRE>

<P>deletes <SPAN class="filename">*.bak</SPAN> files from archive
    <SPAN class="filename">archive.zip</SPAN>.</P>


<H4>Notes</H4>

<P>7-Zip doesn't use the system wildcard parser. 7-Zip doesn't
follow the archaic rule by which *.* means any file. 7-Zip treats
*.* as matching the name of any file that has an extension. To process 
all files, you must use a * wildcard.</P>


<H4>Switches that can be used with this command</H4>

<P>
  <A href="../switches/include.htm">-i (Include)</A><BR>
  <A href="../switches/method.htm">-m (Method)</A><BR>
  <A href="../switches/password.htm">-p (Set Password)</A><BR>
  <A href="../switches/recurse.htm">-r (Recurse)</A><BR>
  <A href="../switches/sns.htm">-sns (Store NTFS alternate Streams)</A><BR>
  <A href="../switches/update.htm">-u (Update)</A><BR>
  <A href="../switches/working_dir.htm">-w (Working Dir)</A><BR>
  <A href="../switches/exclude.htm">-x (Exclude)</A>
</P>

<H4>See also</H4>

<P>
  <B>Commands:</B> 
  <A href="add.htm">a (Add)</A>,
  <A href="update.htm">u (Update)</A>
</P>

<P>
  <B>Switches:</B>
  <A href="../switches/spf.htm">-spf (Use fully qualified file paths)</A><BR>
  <A href="../switches/stl.htm">-stl (Set archive timestamp from the most recently modified file)</A><BR>
  <A href="../switches/update.htm">-u (Update)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>e (Extract) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>e (Extract) command</H1>

<P>Extracts files from an archive to the current
directory or to the output directory. The output directory can be specified by
<A href="../switches/output_dir.htm">-o (Set Output Directory)</A> switch.</P>

<P>This command copies all extracted files to one directory.
If you want extract files with full paths, you must use
<A href="extract_full.htm">x (Extract with full paths)</A> command.

<P>7-Zip will prompt the user before overwriting existing files unless
the user specifies the <A href="../switches/yes.htm">-y (Assume Yes on all queries)</A>
switch. If the user gives a <B>no</B> answer, 7-Zip will prompt for the file to be
extracted to a new filename. Then a <B>no</B> answer skips that file; or, <B>yes</B>
prompts for new filename.</P>

<P>7-Zip accepts the following responses:</P>

<TABLE>
  <TR> <TH>Answer</TH> <TH>Abbr.</TH> <TH>Action</TH> </TR>
  <TR> <TD>Yes</TD> <TD>y</TD> <TD>&nbsp;</TD> </TR>
  <TR> <TD>No</TD> <TD>n</TD> <TD>&nbsp;</TD> </TR>
  <TR> <TD>Always</TD> <TD>a</TD> <TD>Assume YES for ALL subsequent queries of the same class</TD> </TR>
  <TR> <TD>Skip</TD> <TD>s</TD> <TD>Assume NO for ALL subsequent queries of the same class</TD> </TR>
  <TR> <TD>Quit</TD> <TD>q</TD> <TD>Quit the program</TD> </TR>

</TABLE>

<P>Abbreviated responses are allowed.</P>

<H4>Examples</H4>

<PRE class="example">
7z e archive.zip
</PRE>

<P>extracts all files from archive
    <SPAN class="filename">archive.zip</SPAN> to the current directory.</P>

<PRE class="example">
7z e archive.zip -oc:\soft *.cpp -r
</PRE>

<P>extracts all <SPAN class="filename">*.cpp</SPAN> files from archive
    <SPAN class="filename">archive.zip</SPAN> to <SPAN class="filename">c:\soft</SPAN> folder.</P>


<H4>Notes</H4>

<P>7-Zip doesn't use the system wildcard parser. 7-Zip doesn't
follow the archaic rule by which *.* means any file. 7-Zip treats
*.* as matching the name of any file that has an extension. To process 
all files, you must use a * wildcard.</P>


<H4>Switches that can be used with this command</H4>

<P>
  <A href="../switches/ar_include.htm">-ai (Include archives)</A><BR>
  <A href="../switches/ar_no.htm">-an (Disable parsing of archive_name)</A><BR>
  <A href="../switches/overwrite.htm">-ao (Overwrite mode)</A><BR>
  <A href="../switches/ar_exclude.htm">-ax (Exclude archives)</A><BR>
  <A href="../switches/include.htm">-i (Include)</A><BR>
  <A href="../switches/method.htm">-m (Method)</A><BR>
  <A href="../switches/output_dir.htm">-o (Set Output Directory)</A><BR>
  <A href="../switches/password.htm">-p (Set Password)</A><BR>
  <A href="../switches/recurse.htm">-r (Recurse)</A><BR>
  <A href="../switches/stdin.htm">-si (use StdIn)</A><BR>
  <A href="../switches/sni.htm">-sni (Store NT security information)</A><BR>
  <A href="../switches/sns.htm">-sns (Store NTFS alternate Streams)</A><BR>
  <A href="../switches/stdout.htm">-so (use StdOut)</A><BR>
  <A href="../switches/spf.htm">-spf (Use fully qualified file paths)</A><BR>
  <A href="../switches/type.htm">-t (Type of archive)</A><BR>
  <A href="../switches/exclude.htm">-x (Exclude)</A><BR>
  <A href="../switches/yes.htm">-y (Assume Yes on all queries)</A>
</P>

<H4>See also</H4>

<P>
  <B>Commands:</B> 
  <A href="extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>x (Extract with full paths) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>x (Extract with full paths) command</H1>

<P>Extracts files from an archive with their full
paths in the current directory, or in an output directory if specified.</P>

<P>See the <A href="extract.htm">e (Extract)</A> command description for more details.</P>

<H4>Examples</H4>

<PRE class="example">
7z x archive.zip
</PRE>

<P>extracts all files from the archive
    <SPAN class="filename">archive.zip</SPAN> to the current directory.</P>

<PRE class="example">
7z x archive.zip -oc:\soft *.cpp -r
</PRE>

<P>extracts all <SPAN class="filename">*.cpp</SPAN> files from the archive
    <SPAN class="filename">archive.zip</SPAN> to <SPAN class="filename">c:\soft</SPAN> folder.</P>


<H4>Notes</H4>

<P>7-Zip doesn't use the system wildcard parser. 7-Zip doesn't
follow the archaic rule by which *.* means any file. 7-Zip treats
*.* as matching the name of any file that has an extension. To process 
all files, you must use a * wildcard.</P>


<H4>Switches that can be used with this command</H4>

<P>
  <A href="../switches/ar_include.htm">-ai (Include archives)</A><BR>
  <A href="../switches/ar_no.htm">-an (Disable parsing of archive_name)</A><BR>
  <A href="../switches/overwrite.htm">-ao (Overwrite mode)</A><BR>
  <A href="../switches/ar_exclude.htm">-ax (Exclude archives)</A><BR>
  <A href="../switches/include.htm">-i (Include)</A><BR>
  <A href="../switches/method.htm">-m (Method)</A><BR>
  <A href="../switches/output_dir.htm">-o (Set Output Directory)</A><BR>
  <A href="../switches/password.htm">-p (Set Password)</A><BR>
  <A href="../switches/recurse.htm">-r (Recurse)</A><BR>
  <A href="../switches/stdin.htm">-si (use StdIn)</A><BR>
  <A href="../switches/sni.htm">-sni (Store NT security information)</A><BR>
  <A href="../switches/sns.htm">-sns (Store NTFS alternate Streams)</A><BR>
  <A href="../switches/stdout.htm">-so (use StdOut)</A><BR>
  <A href="../switches/spf.htm">-spf (Use fully qualified file paths)</A><BR>
  <A href="../switches/type.htm">-t (Type of archive)</A><BR>
  <A href="../switches/exclude.htm">-x (Exclude)</A><BR>
  <A href="../switches/yes.htm">-y (Assume Yes on all queries)</A>
</P>

<H4>See also</H4>

<P>
  <B>Commands:</B> 
  <A href="extract.htm">e (Extract)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>h (Hash) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>h (Hash) command</H1>

<P>Calculate hash values for files.</P>

<H4>Syntax</H4>

<PRE class="syntax">
h [-scrc{Method}] [files]
</PRE>

<P>Supported methods: CRC32, CRC64, SHA1, SHA256, BLAKE2sp. Default method is CRC32.</P>

<H4>Examples</H4>

<PRE class="example">
7z h a.txt
</PRE>

<P>calculates CRC32 for <SPAN class="filename">a.txt</SPAN>.</P>

<PRE class="example">
7z h -scrcsha256 a.iso
</PRE>

<P>calculates SHA256 for <SPAN class="filename">a.iso</SPAN>.</P>

<PRE class="example">
7z h *
</PRE>

<P>calculates CRC32 for all files in current folder and all subfolders.</P>

<H4>Notes</H4>

<P>7-Zip shows hash values for each file, the sum of hash values and 
the sum that includes all hash values of data and all hash values for filenames.</P>

<P>7-Zip represents hash values for CRC32 and CRC64 as integer numbers in hex.</P> 
<P>7-Zip represents hash values For SHA1, SHA256 and BLAKE2sp as sequence of bytes in hex.</P>

<H4>Switches that can be used with this command</H4>

<P>
  <A href="../switches/include.htm">-i (Include)</A><BR>
  <A href="../switches/method.htm">-m (Method)</A><BR>
  <A href="../switches/recurse.htm">-r (Recurse)</A><BR>
  <A href="../switches/scrc.htm">-scrc (Set hash method)</A><BR>
  <A href="../switches/stdin.htm">-si (use StdIn)</A><BR>
  <A href="../switches/sns.htm">-sns (Store NTFS alternate Streams)</A><BR>
  <A href="../switches/shared.htm">-ssw (Compress shared files)</A><BR>
  <A href="../switches/exclude.htm">-x (Exclude)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Command Line Commands</TITLE>
  <LINK href="style.css" rel=stylesheet type="text/css">
</HEAD>

<BODY>

<H1>Command Line Commands</H1>

<P>The command is the first non-switch argument on the command line.</P>
<P>Command names are not case sensitive.</P>
<P>See also <A href ="../syntax.htm">Command Line Syntax</A> for more details about using the command line.</P>

<H2>Commands quick reference</H2>

<TABLE border="1" cellpadding="3" cellspacing="0">
<TR><TH>Command</TH><TH>Description</TH></TR>
<TR> <TD><A href="add.htm">a</A></TD> <TD><A href="add.htm">Add</A></TD></TR>
<TR> <TD><A href="bench.htm">b</A></TD> <TD><A href="bench.htm">Benchmark</A></TD></TR>
<TR> <TD><A href="delete.htm">d</A></TD> <TD><A href="delete.htm">Delete</A></TD></TR>
<TR> <TD><A href="extract.htm">e</A></TD> <TD><A href="extract.htm">Extract</A></TD></TR>
<TR> <TD><A href="hash.htm">h</A></TD> <TD><A href="hash.htm">Hash</A></TD></TR>
<TR> <TD>i</A></TD> <TD>Show information about supported formats</TD></TR>
<TR> <TD><A href="list.htm">l</A></TD> <TD><A href="list.htm">List</A></TD></TR>
<TR> <TD><A href="rename.htm">rn</A></TD> <TD><A href="rename.htm">Rename</A></TD></TR>
<TR> <TD><A href="test.htm">t</A></TD> <TD><A href="test.htm">Test</A></TD></TR>
<TR> <TD><A href="update.htm">u</A></TD> <TD><A href="update.htm">Update</A></TD></TR>
<TR> <TD><A href="extract_full.htm">x</A></TD> <TD><A href="extract_full.htm">eXtract with full paths</A></TD></TR>
</TABLE>


</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>l (List contents of archive) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>l (List contents of archive) command</H1>



<!--
<H4>Syntax</H4>
<P><PRE class="syntax">
l[a | t][f]
</PRE></P>

-->

<P>Lists contents of archive.</P>

<!-- 
<P>The following options can be used:</P>
<TABLE>
<TR> <TH>Option</TH> <TH>Description</TH> </TR>
<TR> <TD>a</TD> <TD>List with Additional fields</TD> </TR>
<TR> <TD>t</TD> <TD>List with all fields, including Technical</TD> </TR>
<TR> <TD>f</TD> <TD>List with Full pathnames</TD> </TR>
</TABLE>
-->


<H4>Examples</H4>

<PRE class="example">
7z l archive.zip
</PRE>

<P>lists all files from archive <SPAN class="filename">archive.zip</SPAN>.</P>

<!--
<PRE class="example">
7z lf archive.zip *.txt
</PRE>

<P>lists <SPAN class="filename">*.txt</SPAN> files from archive
    <SPAN class="filename">archive.zip</SPAN> with full pathnames.</P>
-->


<H4>Notes</H4>

<P>7-Zip doesn't use the system wildcard parser. 7-Zip doesn't
follow the archaic rule by which *.* means any file. 7-Zip treats
*.* as matching the name of any file that has an extension. To process 
all files, you must use a * wildcard.</P>


<H4>Switches that can be used with this command</H4>

<P>
  <A href="../switches/ar_include.htm">-ai (Include archives)</A><BR>
  <A href="../switches/ar_no.htm">-an (Disable parsing of archive_name)</A><BR>
  <A href="../switches/ar_exclude.htm">-ax (Exclude archives)</A><BR>
  <A href="../switches/include.htm">-i (Include)</A><BR>
  <A href="../switches/list_tech.htm">-slt (Show technical information)</A><BR>
  <A href="../switches/sns.htm">-sns (Store NTFS alternate Streams)</A><BR>
  <A href="../switches/password.htm">-p (Set Password)</A><BR>
  <A href="../switches/recurse.htm">-r (Recurse)</A><BR>
  <A href="../switches/type.htm">-t (Type of archive)</A><BR>
  <A href="../switches/exclude.htm">-x (Exclude)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>rn (Rename) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>rn (Rename) command</H1>

<P>Renames files in archive.</P>

<H4>Syntax</H4>

<PRE class="syntax">
rn &lt;archive_name> &lt;src_file_1> &lt;dest_file_1> [ &lt;src_file_2> &lt;dest_file_2> ... ]
</PRE>

<H4>Example</H4>

<PRE class="example">
7z rn a.7z old.txt new.txt 2.txt folder\2new.txt 
</PRE>

<P>renames <SPAN class="filename">old.txt</SPAN> to <SPAN class="filename">new.txt</SPAN> 
and <SPAN class="filename">2.txt</SPAN> to <SPAN class="filename">folder\2new.txt </SPAN> 
.</P>


<H4>Notes</H4>

<H4>Switches that can be used with this command</H4>

<P>
  <A href="../switches/include.htm">-i (Include)</A><BR>
  <A href="../switches/method.htm">-m (Method)</A><BR>
  <A href="../switches/password.htm">-p (Set Password)</A><BR>
  <A href="../switches/recurse.htm">-r (Recurse)</A><BR>
  <A href="../switches/stl.htm">-stl (Set archive timestamp from the most recently modified file)</A><BR>
  <A href="../switches/update.htm">-u (Update)</A><BR>
  <A href="../switches/working_dir.htm">-w (Working Dir)</A><BR>
  <A href="../switches/exclude.htm">-x (Exclude)</A>
</P>

<P>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>t (Test integrity of archive) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>t (Test integrity of archive) command</H1>

<P>Tests archive files.</P>

<H4>Example</H4>

<PRE class="example">
7z t archive.zip *.doc -r
</PRE>

<P>tests <SPAN class="filename">*.doc</SPAN> files in archive
    <SPAN class="filename">archive.zip</SPAN>.</P>


<H4>Notes</H4>

<P>7-Zip doesn't use the system wildcard parser. 7-Zip doesn't
follow the archaic rule by which *.* means any file. 7-Zip treats
*.* as matching the name of any file that has an extension. To process 
all files, you must use a * wildcard.</P>


<H4>Switches that can be used with this command</H4>

<P>
  <A href="../switches/ar_include.htm">-ai (Include archives)</A><BR>
  <A href="../switches/ar_no.htm">-an (Disable parsing of archive_name)</A><BR>
  <A href="../switches/ar_exclude.htm">-ax (Exclude archives)</A><BR>
  <A href="../switches/include.htm">-i (Include)</A><BR>
  <A href="../switches/password.htm">-p (Set Password)</A><BR>
  <A href="../switches/recurse.htm">-r (Recurse)</A><BR>
  <A href="../switches/sns.htm">-sns (Store NTFS alternate Streams)</A><BR>
  <A href="../switches/exclude.htm">-x (Exclude)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>u (Update) command</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>u (Update) command</H1>

<P>Update older files in the archive and add files that are not already in the archive.</P>

<P>Note: the updating of solid .7z archives can be slow, since it 
can require some recompression.</P>

<H4>Example</H4>

<PRE class="example">
7z u archive.zip *.doc
</PRE>

<P>updates <SPAN class="filename">*.doc</SPAN> files to archive
    <SPAN class="filename">archive.zip</SPAN>.</P>


<H4>Notes</H4>

<P>7-Zip doesn't use the system wildcard parser. 7-Zip doesn't
follow the archaic rule by which *.* means any file. 7-Zip treats
*.* as matching the name of any file that has an extension. To process 
all files, you must use a * wildcard.</P>


<H4>Switches that can be used with this command</H4>

<P>
  <A href="../switches/include.htm">-i (Include)</A><BR>
  <A href="../switches/method.htm">-m (Method)</A><BR>
  <A href="../switches/password.htm">-p (Set Password)</A><BR>
  <A href="../switches/recurse.htm">-r (Recurse)</A><BR>
  <A href="../switches/sfx.htm">-sfx (create SFX)</A><BR>
  <A href="../switches/stdin.htm">-si (use StdIn)</A><BR>
  <A href="../switches/stdout.htm">-so (use StdOut)</A><BR>
  <A href="../switches/sni.htm">-sni (Store NT security information)</A><BR>
  <A href="../switches/sns.htm">-sns (Store NTFS alternate Streams)</A><BR>
  <A href="../switches/shared.htm">-ssw (Compress shared files)</A><BR>
  <A href="../switches/spf.htm">-spf (Use fully qualified file paths)</A><BR>
  <A href="../switches/stl.htm">-stl (Set archive timestamp from the most recently modified file)</A><BR>
  <A href="../switches/type.htm">-t (Type of archive)</A><BR>
  <A href="../switches/update.htm">-u (Update)</A><BR>
  <A href="../switches/working_dir.htm">-w (Working Dir)</A><BR>
  <A href="../switches/exclude.htm">-x (Exclude)</A>
</P>

<H4>See also</H4>

<P>
  <B>Commands:</B> 
  <A href="add.htm">a (Add)</A>,
  <A href="delete.htm">d (Delete)</A>,
</P>

<P>
  <B>Switches:</B>
  <A href="../switches/update.htm">-u (Update)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-ax (Exclude archive filenames) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-ax (Exclude archive filenames) switch</H1>

<P>Specifies archives to be excluded from the operation.</P>
<P>Multiple exclude archive switches are supported.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-ax[&lt;recurse_type>]&lt;file_ref>

&lt;recurse_type> ::= r[- | 0]
&lt;file_ref> ::= @{listfile} | !{wildcard}
</PRE>

<P>See <A href="include.htm">-xi (Include archive filenames)</A> switch description 
for information about option parameters.</P>


<H4>Examples</H4>

<PRE class="example">
7z t -an -ai!*.7z -ax!a*.7z
</PRE>

<P>tests all <SPAN class="filename">*.7z</SPAN> archives,
  except <SPAN class="filename">a*.7z</SPAN> archives.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
  <A href="include.htm">-ai (Include archives)</A>
  <A href="ar_no.htm">-an (Disable parsing of archive_name)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-ai (Include archive filenames) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-ai (Include archive filenames) switch</H1>

<P>Specifies additional include archive filenames and wildcards.</P>
<P>Multiple include switches are supported.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-ai[<A class="parameter" href="#recurse_type">&lt;recurse_type></A>]<A class="parameter" href="#file_ref">&lt;file_ref></A>

<A class="parameter" href="#recurse_type">&lt;recurse_type></A> ::= r[- | 0]
<A class="parameter" href="#file_ref">&lt;file_ref></A> ::= @{listfile} | !{wildcard}
</PRE>

<H4>Parameters</H4>

<DL>
  <DT><A name="recurse_type"></A>&lt;recurse_type></DT>
  <DD><P>Specifies how wildcards and file names in this switch must
         be used.  If this option is not given, recursion will be not used.
         For more details see specification of the
         <A href="recurse.htm">-r (Recurse)</A> switch.</P>
<PRE class="syntax">
&lt;recurse_type> ::= r[- | 0]
</PRE>

 </DD>
 <DT><A name="file_ref"></A>&lt;file_ref></DT>
 <DD>
   <P>Specifies filenames and wildcards or list file that specify processed files.</P>
<PRE class="syntax">
&lt;file_ref> ::= @{listfile} | !{wildcard}
</PRE>
   <TABLE>
     <TR> <TH width="120">Option</TH> <TH>Description</TH> </TR>
     <TR> <TD>{listfile}</TD> <TD>Specifies name of list file. See
                  <A href = ../syntax.htm#ListFile>List file</A> description.</TD> </TR>
     <TR> <TD>{wildcard}</TD> <TD>Specifies wildcard or filename.</TD> </TR>
   </TABLE>
 </DD>
</DL>

<H4>Examples</H4>

<PRE class="example">
7z t -an -air!*.7z
</PRE>

<P>tests <SPAN class="filename">*.7z</SPAN> archives in current directory and all it's 
subdirectories.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
  <A href="ar_exclude.htm">-ax (Exclude archives)</A>
  <A href="ar_no.htm">-an (Disable parsing of archive_name)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-an (Disable parsing of archive_name) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-an (Disable parsing of archive_name) switch</H1>

<P>Disables parsing of the archive_name field on the command line.
This switch must be used with the
<A href="ar_include.htm">-ai (Include archives) switch</A>.
If you use a file list for your archives, you specify it with the -ai switch,
so you need to disable parsing of archive_name field from command line.

<H4>Syntax</H4>

<PRE class="syntax">
-an
</PRE>

<H4>Examples</H4>

<PRE class="example">
7z t -an -ai!*.7z -ax!a*.7z
</PRE>

<P>tests all <SPAN class="filename">*.7z</SPAN> archives,
  except <SPAN class="filename">a*.7z</SPAN> archives.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
  <A href="include.htm">-ai (Include archives)</A>
  <A href="exclude.htm">-ax (Exclude archives)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-bb (Set output log level) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-bb (Set output log level) switch</H1>

<P>The switch sets output log level for Delete/Add/Update/Extract operations.</P> 

<H4>Syntax</H4>

<PRE class="syntax">
-bb[0-3]
</PRE>

<TABLE>
  <TR> <TH width="90">Log level</TH> <TH>Description</TH> </TR>
  <TR> <TD>-bb0</TD> <TD>disable log (default).</TD> </TR>
  <TR> <TD>-bb1 or -bb</TD> <TD>show names of processed files in log.</TD> </TR>
  <TR> <TD>-bb2</TD> <TD>show names of additional files that were processed internally in
                     solid archives:
                     skipped files for "Extract" operation,
                     repacked files for "Add" / "Update" operations.</TD> </TR>
  <TR> <TD>-bb3</TD> <TD>show information about additional operations 
                      (Analyze, Replicate) for "Add" / "Update" operations.</TD> </TR>
</TABLE>

<H4>Examples</H4>

<PRE class="example">
7z a a.7z *.txt -bb
</PRE>

<P>adds <SPAN class="filename">*.txt</SPAN> files to <SPAN class="filename">a.7z</SPAN> archive 
and shows all files that were processed.</P>

<PRE class="example">
7z u a.7z *.txt -bb3
</PRE>

<P>updates <SPAN class="filename">*.txt</SPAN> files in <SPAN class="filename">a.7z</SPAN> archive 
and shows information about additional operations.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-spf (Use fully qualified file paths) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-bs (Set output stream for output/error/progress line) switch</H1>

<H4>Syntax</H4>

<PRE class="syntax">
-bs{o|e|p}{0|1|2}
</PRE>

<TABLE>
  <TR> <TH width="30">{id}</TH> <TH>Stream Type</TH> </TR>
  <TR> <TD>o</TD> <TD>standard output messages</TD> </TR>
  <TR> <TD>e</TD> <TD>error messages</TD> </TR>
  <TR> <TD>p</TD> <TD>progress information</TD> </TR>
</TABLE>

<TABLE>
  <TR> <TH width="30">{N}</TH> <TH>Stream Destination</TH> </TR>
  <TR> <TD>0</TD> <TD>disable stream</TD> </TR>
  <TR> <TD>1</TD> <TD>redirect to stdout stream</TD> </TR>
  <TR> <TD>2</TD> <TD>redirect to stderr stream</TD> </TR>
</TABLE>

<P>Default values: o1, e2, p1.</P>


<H4>Examples</H4>

<PRE class="example">
7z t a.7z -bse1 > messages.txt
</PRE>

<P>tests <SPAN class="filename">a.7z</SPAN> archive and sends error 
messages to stdout that is redirected to <SPAN class="filename">messages.txt</SPAN></P>


<PRE class="example">
7z a -si -so -bsp2 -txz -an < file.tar > file.tar.xz
</PRE>

<P>compresses <SPAN class="filename">file.tar</SPAN> (from stdin) to <SPAN class="filename">file.tar.xz</SPAN> 
(stdout stream) and shows progress information in stderr stream that can be seen at console window.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/hash.htm">h (Hash)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-scs (Set charset for list files) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-scs (Set charset for list files) switch</H1>

<P>Sets charset for list files.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-scs{UTF-8 | UTF-16LE | UTF-16BE | WIN | DOS | {id} }
</PRE>

<P>Default charset is UTF-8.</P>

<TABLE>
  <TR><TH> Value </TH> <TH> Description </TH></TR>
  <TR><TD> UTF-8    </TD> <TD> Unicode UTF-8 character set. </TD></TR>
  <TR><TD> UTF-16LE </TD> <TD> Unicode UTF-16 little-endian character set. </TD></TR>
  <TR><TD> UTF-16BE </TD> <TD> Unicode UTF-16 big-endian character set. </TD></TR>
  <TR><TD> WIN      </TD> <TD> Default character set of Windows. </TD></TR>
  <TR><TD> DOS      </TD> <TD> Default DOS (OEM) character set of Windows. </TD></TR>
  <TR><TD> {id}     </TD> <TD> The code page number (as specified in Microsoft Windows). </TD></TR>
</TABLE>

<P>Notes: The list file in Unicode charset can start with the BOM (byte order mark) character (U+FEFF).
   In that case 7-Zip checks that encoding of BOM corresponds to encoding
   specified with this switch (for UTF-16LE and UTF-16BE).</P>

<H4>Examples</H4>

<PRE class="example">
7z a archive.7z @listfile.txt -scsWIN
</PRE>

<P>compresses files from <SPAN class="filename">listfile.txt</SPAN> list, that contains 
list of files in default character set of Windows.</P>

<PRE class="example">
7z a archive.7z @listfile.txt -scs1251
</PRE>

<P>compresses files from <SPAN class="filename">listfile.txt</SPAN> list, that contains 
list of files in 1251 (Cyrillic Windows) codepage.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/update.htm">u (Update)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-x (Exclude filenames) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-x (Exclude filenames) switch</H1>

<P>Specifies which filenames or wildcarded names must be excluded from the operation.</P>
<P>Multiple exclude switches are supported.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-x[&lt;recurse_type>]&lt;file_ref>

&lt;recurse_type> ::= r[- | 0]
&lt;file_ref> ::= @{listfile} | !{wildcard}
</PRE>

<P>See <A href="include.htm">-i (Include)</A> switch description for information about
    option parameters.</P>


<H4>Examples</H4>

<PRE class="example">
7z a -tzip archive.zip *.txt -x!temp.*
</PRE>

<P>adds to the <SPAN class="filename">archive.zip</SPAN> all
  <SPAN class="filename">*.txt</SPAN> files,
  except <SPAN class="filename">temp.*</SPAN> files.</P>


<PRE class="example">
7z a archive.7z Folder1\ -xr!*.png
</PRE>

<P>adds to the <SPAN class="filename">archive.7z</SPAN> all
  files from <SPAN class="filename">Folder1</SPAN> and its subfolders,
  except <SPAN class="filename">*.png</SPAN> files.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/hash.htm">h (Hash)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/rename.htm">rn (Rename)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
  <A href="recurse.htm">-r (Recurse)</A>,
  <A href="include.htm">-i (Include)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-i (Include filenames) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-i (Include filenames) switch</H1>

<P>Specifies additional include filenames and wildcards.</P>
<P>Multiple include switches are supported.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-i[<A class="parameter" href="#recurse_type">&lt;recurse_type></A>]<A class="parameter" href="#file_ref">&lt;file_ref></A>

<A class="parameter" href="#recurse_type">&lt;recurse_type></A> ::= r[- | 0]
<A class="parameter" href="#file_ref">&lt;file_ref></A> ::= @{listfile} | !{wildcard}
</PRE>

<H4>Parameters</H4>

<DL>
  <DT><A name="recurse_type"></A>&lt;recurse_type></DT>
  <DD><P>Specifies how wildcards and file names in this switch must
         be used. If this option is not given, then the global value, assigned
         by the <A href="recurse.htm">-r (Recurse)</A> switch will be used. For
         more details see specification of the
         <A href="recurse.htm">-r (Recurse)</A> switch.</P>
<PRE class="syntax">
&lt;recurse_type> ::= r[- | 0]
</PRE>

 </DD>
 <DT><A name="file_ref"></A>&lt;file_ref></DT>
 <DD>
   <P>Specifies filenames and wildcards, or a list file, for files to be processed.</P>
<PRE class="syntax">
&lt;file_ref> ::= @{listfile} | !{wildcard}
</PRE>
   <TABLE>
     <TR> <TH width="120">Option</TH> <TH>Description</TH> </TR>
     <TR> <TD>{listfile}</TD> <TD>Specifies name of list file. See
                  <A href = ../syntax.htm#ListFile>List file</A> description.</TD> </TR>
     <TR> <TD>{wildcard}</TD> <TD>Specifies wildcard or filename.</TD> </TR>
   </TABLE>
 </DD>
</DL>

<H4>Examples</H4>

<PRE class="example">
7z a -tzip src.zip *.txt -ir!DIR1\*.cpp
</PRE>

<P>adds to <SPAN class="filename">src.zip</SPAN> archive all
  <SPAN class="filename">*.txt</SPAN> files from current directory
  and all <SPAN class="filename">*.cpp</SPAN>
  files from directory <SPAN class="filename">DIR1</SPAN>
  and from all it's subdirectories.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/hash.htm">h (Hash)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/rename.htm">rn (Rename)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
  <A href="recurse.htm">-r (Recurse)</A>,
  <A href="exclude.htm">-x (Exclude)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Command Line Switches</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Command Line Switches</H1>

<H4>Syntax</H4>

<PRE class="syntax">
&ltswitch>::= &lt;switch_symbol>&lt;switch_characters>[&lt;option>]
&lt;switch_symbol> ::= '/' | '-' 

</PRE>
<P>On the command line, a switch consists of a switch specifier,
either a dash (-) or a forward slash (/), followed by the name of
the switch. Switch names cannot be abbreviated.</P>

<P>Some switches take an argument after the switch name.
No spaces or tabs are allowed within a switch specification.
Switch names are not case sensitive, but arguments can be case sensitive.
</P>

<P>Switch can be used in any place in command line.</B>

<P>See also <A href ="../syntax.htm">Command Line Syntax</A> for more details
   about using the command line.</P>

<H2>Switch quick reference</H2>

<TABLE border="1" cellpadding="3" cellspacing="0">
<TR><TH>Switch</TH><TH>Description</TH></TR>

<TR> <TD><A href="stop_switch.htm">--</A></TD> <TD><A href="stop_switch.htm">Stop switches parsing</A></TD></TR>
<TR> <TD>-ad</A></TD> <TD>Show dialog box in GUI version (7zg)</TD></TR>
<TR> <TD><A href="ar_include.htm">-ai</A></TD> <TD><A href="ar_include.htm">Include archive filenames</A></TD></TR>
<TR> <TD><A href="ar_no.htm">-an</A></TD> <TD><A href="ar_no.htm">Disable parsing of archive_name</A></TD></TR>
<TR> <TD><A href="overwrite.htm">-ao</A></TD> <TD><A href="overwrite.htm">Overwrite mode</A></TD></TR>
<TR> <TD><A href="ar_exclude.htm">-ax</A></TD> <TD><A href="ar_exclude.htm">Exclude archive filenames</A></TD></TR>

<TR> <TD><A href="bb.htm"> -bb[0-3] </A></TD> <TD> Set output log level</TD></TR>
<TR> <TD>-bd</TD> <TD> Disable progress indicator</TD></TR>
<TR> <TD><A href="bs.htm"> -bs{o|e|p}{0|1|2} </A></TD> <TD> Set output stream for output/error/progress</TD></TR>
<TR> <TD>-bt</TD> <TD> Show execution time statistics</TD></TR>

<TR> <TD><A href="include.htm">-i</A></TD> <TD><A href="include.htm">Include filenames</A></TD></TR>
<TR> <TD><A href="method.htm">-m</A></TD> <TD><A href="method.htm">Set Compression Method</A></TD></TR>
<TR> <TD><A href="output_dir.htm">-o</A></TD> <TD><A href="output_dir.htm">Set Output directory</A></TD></TR>
<TR> <TD><A href="password.htm">-p</A></TD> <TD><A href="password.htm">Set Password</A></TD></TR>
<TR> <TD><A href="recurse.htm">-r</A></TD> <TD><A href="recurse.htm">Recurse subdirectories</A></TD></TR>

<TR> <TD><A href="sa.htm">  -sa  </A></TD> <TD><A href="sa.htm"> Set Archive name mode </A></TD></TR>
<TR> <TD><A href="scc.htm"> -scc </A></TD> <TD><A href="charset.htm"> Set charset for for console input/output </A></TD></TR>
<TR> <TD><A href="scrc.htm">-scrc</A></TD> <TD><A href="scrc.htm">Set hash function</A></TD></TR>
<TR> <TD><A href="charset.htm">-scs</A></TD> <TD><A href="charset.htm">Set charset for list files</A></TD></TR>
<TR> <TD><A href="sdel.htm"> -sdel </A></TD> <TD><A href="sdel.htm"> Delete files after including to archive </A></TD></TR>
<TR> <TD><A href="sfx.htm">-sfx</A></TD> <TD><A href="sfx.htm">Create SFX archive</A></TD></TR>
<TR> <TD><A href="stdin.htm">-si</A></TD> <TD><A href="stdin.htm">Read data from StdIn</A></TD></TR>
<TR> <TD><A href="large_pages.htm">-slp</A></TD> <TD><A href="large_pages.htm">Set Large Pages mode</A></TD></TR>
<TR> <TD><A href="list_tech.htm">-slt</A></TD> <TD><A href="list_tech.htm">Show technical information</A></TD></TR>
<TR> <TD><A href="sni.htm"> -sni </A></TD> <TD><A href="sni.htm"> Store NT security information </A></TD></TR>
<TR> <TD><A href="sns.htm"> -sns </A></TD> <TD><A href="sns.htm"> Store NTFS alternate Streams </A></TD></TR>

<TR> <TD>-snc</TD> <TD> Extract file as alternate stream, if there is ':' character in name </TD></TR>
<TR> <TD>-snr</TD> <TD> Replace ':' character to '_' character in paths of alternate streams </TD></TR>

<TR> <TD>-snh</TD> <TD> Store hard links as links (WIM and TAR formats only) </TD></TR>
<TR> <TD>-snl</TD> <TD> Store symbolic links as links (WIM and TAR formats only) </TD></TR>

<TR> <TD><A href="stdout.htm">-so</A></TD> <TD><A href="stdout.htm">Write data to StdOut</A></TD></TR>
<TR> <TD>-spd</TD> <TD> Disable wildcard matching for file names</TD></TR>
<TR> <TD>-spe</TD> <TD> Eliminate duplication of root folder for extract archive command</TD></TR>
<TR> <TD><A href="spf.htm"> -spf </A></TD> <TD><A href="spf.htm"> Use fully qualified file paths </A></TD></TR>
<TR> <TD><A href="ssc.htm">-ssc</A></TD> <TD><A href="ssc.htm">Set Sensitive Case mode</A></TD></TR>
<TR> <TD><A href="shared.htm">-ssw</A></TD> <TD><A href="shared.htm">Compress files open for writing</A></TD></TR>
<TR> <TD><A href="stl.htm">-stl</A></TD> <TD><A href="stl.htm">Set archive timestamp from the most recently modified file</A></TD></TR>
<TR> <TD>-stm{HexMask}</TD> <TD> Set CPU thread affinity mask (hexadecimal number).</TD></TR>
<TR> <TD><A href="stx.htm">-stx{Type}</A></TD> <TD> Exclude archive type </TD></TR>

<TR> <TD><A href="type.htm">-t</A></TD> <TD><A href="type.htm">Type of archive</A></TD></TR>
<TR> <TD><A href="update.htm">-u</A></TD> <TD><A href="update.htm">Update options</A></TD></TR>
<TR> <TD><A href="volume.htm">-v</A></TD> <TD><A href="volume.htm">Create Volumes</A></TD></TR>
<TR> <TD><A href="working_dir.htm">-w</A></TD> <TD><A href="working_dir.htm">Set Working directory</A></TD></TR>
<TR> <TD><A href="exclude.htm">-x</A></TD> <TD><A href="exclude.htm">Exclude filenames</A></TD></TR>
<TR> <TD><A href="yes.htm">-y</A></TD> <TD><A href="yes.htm">Assume Yes on all queries</A></TD></TR>

</TABLE>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-slp (Set Large Pages mode) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-slp (Set Large Pages mode) switch</H1>

<P>Sets Large Pages mode.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-slp[-]
</PRE>


<TABLE>
  <TR><TH width="80">Switch</TH> <TH>Description</TH></TR>
  <TR><TD>-slp</TD> <TD>Enables Large Pages mode.</TD></TR>
  <TR><TD>-slp-</TD> <TD>Disables Large Pages mode. This option is default for all commands.</TD></TR>
</TABLE>

<P> Large Pages mode increases the speed of compression.
However, there is a pause at the start of compression while 7-Zip allocates the large pages in memory.
If 7-Zip can't allocate large pages, it allocates usual small pages.
Also, the Windows Task Manager doesn't show the real memory usage of the program, if 7-Zip uses large pages.
This feature works only on Windows 2003 / XP x64. 
Also, it requires administrator's rights for your system.
The recommended size of RAM for this feature is 3 GB or more.
To install this feature, you must run the 7-Zip File Manager at least once, 
close it, and then reboot the system. </P>

<P> <B>Notes: if you use -slp mode, your Windows system can hang for several 
    seconds when 7-zip allocates memory blocks</B>. 

When Windows tries to allocate large pages from RAM for 7-Zip, Windows can hang other tasks for that time. 
It can look like full system hang, but then it resumes, and if allocation is successful, 7-Zip works faster.
Don't use -slp mode, if you don't want other tasks be hanged for several seconds.
Also it's senseless to use -slp mode to compress small data sets (less than 100 MB).
But if you compress big data sets (300 MB or more) with LZMA method with large dictionary,
you can get 5%-10% speed improvement with -slp mode.</P>



<H4>Example</H4>

<PRE class="example">
7z a archive.7z -slp a.iso
</PRE>

<P>compresses <SPAN class="filename">a.iso</SPAN> file with Large Pages mode switched on.</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-slt (Show technical information) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-slt (Show technical information) switch</H1>

<P>Sets technical mode for <A href="../commands/list.htm">l (List)</A> command.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-slt
</PRE>

<H4>Example</H4>

<PRE class="example">
7z l -slt archive.7z
</PRE>

<P>shows detailed technical information for the files in <SPAN class="filename">archive.7z</SPAN>.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/list.htm">l (List)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-m (Set compression Method) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-m (Set compression Method) switch</H1>

<P>Specifies the compression method.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-m&lt;method_parameters>

</PRE>

<P>The format for this switch depends on the archive type.</P>

<UL>
<LI><TD><A class="parameter" href="#Zip">Zip</A></TD> 
<LI><TD><A class="parameter" href="#GZ">GZip</A></TD> 
<LI><TD><A class="parameter" href="#BZ2">BZip2</A></TD> 
<LI><TD><A class="parameter" href="#7Z">7z</A></TD> 
<LI><TD><A class="parameter" href="#XZ">XZ</A></TD> 
<LI><TD><A class="parameter" href="#WIM">WIM</A></TD> 
</UL>

<P>-m switch also can specify hash method for 
<A href="../commands/hash.htm">h (Hash)</A> command,</P>

<P><B>Notes:</B> "Default value" in switches descriptions means the value that 
will be used if switch is not specified.</P>

<P>It's allowed to use reduced forms for boolean switches: <B>sw+</B> or <B>sw</B> instead 
<B>sw=on</B>, and <B>sw-</B> instead of <B>sw=off</B>.</P>

<H2><A name="Zip"></A>Zip</H2>
<TABLE>
  <TR> 
    <TH width="160">Parameter</TH> 
    <TH align="center">Default</TH> 
    <TH>Description</TH> </TR>
  <TR> 
    <TD><A class="parameter" href="#ZipX">x=[0 | 1 | 3 | 5 | 7 | 9 ]</A></TD> 
    <TD align="center">5</TD>
    <TD>Sets level of compression.</TD> </TR>
  <TR> 
    <TD>m={MethodID}</TD> 
    <TD align="center">Deflate</TD> 
    <TD>Sets a method: Copy, Deflate, Deflate64, BZip2, LZMA, PPMd.</TD> </TR>
  <TR> 
    <TD><A class="parameter" href="#Deflate_FastBytes">fb={NumFastBytes}</A></TD>
    <TD align="center">32</TD>
    <TD>Sets number of Fast Bytes for Deflate encoder.</TD> </TR>
  <TR> 
    <TD><A class="parameter" href="#Zip_Pass">pass={NumPasses}</A></TD>
    <TD align="center">1</TD>
    <TD>Sets number of Passes for Deflate encoder.</TD></TR>
  <TR> 
    <TD><A class="parameter" href="#ZipDictionarySize">d={Size}[b|k|m]</A></TD> 
    <TD align="center">900000</TD>  
    <TD>Sets Dictionary size for BZip2</TD></TR>
  <TR> 
    <TD><A class="parameter" href="#ZipMemorySize">mem={Size}[b|k|m]</A></TD> 
    <TD align="center">24</TD>  <TD>Sets size of used memory for PPMd.</TD></TR>
  <TR> 
    <TD><A class="parameter" href="#ZipOrder">o={Size}</A></TD> 
    <TD align="center">8</TD>  <TD>Sets model order for PPMd.</TD></TR>
  <TR> 
    <TD><A class="parameter" href="#ZipMultiThread">mt=[off | on | {N}]</A></TD> 
    <TD align="center">on</TD>  
    <TD>Sets multithreading mode.</TD></TR>
  <TR> 
    <TD>em={EncryptionMethodID}</TD> 
    <TD align="center">ZipCrypto</TD> 
    <TD>Sets a encryption method: ZipCrypto, AES128, AES192, AES256</TD> </TR>
  <TR> <TD><A class="parameter">tc=[off | on]</A></TD> 
     <TD align="center">on</TD>  <TD>Stores NTFS timestamps for files: Modification time, Creation time, Last access time.</TD> </TR>
  <TR> <TD><A class="parameter">cl=[off | on]</A></TD> 
     <TD align="center">off</TD>  <TD>7-Zip always uses local code page for file names.</TD> </TR>
  <TR> <TD><A class="parameter">cu=[off | on]</A></TD> 
     <TD align="center">off</TD>  <TD>7-Zip uses UTF-8 for file names that contain non-ASCII symbols.</TD> </TR>
  <TR> <TD><A class="parameter">cp={CodePage}</A></TD> 
     <TD align="center">off</TD>  <TD>Sets code page</TD> </TR>
</TABLE>

<P>By default (if <B>cl</B> and <B>cu</B> switches are not specified), 7-Zip uses UTF-8 encoding
only for file names that contain symbols unsupported by local code page.</P>

<DL>
  <DT><A name="ZipX"></A>x=[0 | 1 | 3 | 5 | 7 | 9 ]</DT>
  <DD>
    <P>Sets level of compression. x=0 means Copy mode (no compression).</P>
    <P>Deflate / Deflate64 settings:</P>
    <TABLE>
      <TR> <TH>Level</TH> <TH>NumFastBytes</TH> <TH>NumPasses</TH> <TH>Description</TH> </TR>
      <TR> <TD class="cc">1</TD> <TD class="cc" rowspan=3>32</TD> <TD class="cc" rowspan=3>1</TD> <TD>Fastest</TD> </TR>
      <TR> <TD class="cc">3</TD> <TD>Fast</TR>
      <TR> <TD class="cc">5</TD> <TD>Normal</TR>
      <TR> <TD class="cc">7</TD> <TD class="cc">64</TD> <TD class="cc">3</TD> <TD>Maximum</TD> </TR>
      <TR> <TD class="cc">9</TD> <TD class="cc">128</TD> <TD class="cc">10</TD> <TD>Ultra</TD> </TR>
    </TABLE>

    <P>x=1 and x=3 with Deflate method set fast mode for compression.</P>

    <P>BZip2 settings:</P>
    <TABLE>
      <TR> <TH>Level</TH> <TH>Dictionary</TH> <TH>NumPasses</TH> <TH>Description</TH> </TR>
      <TR> <TD class="cc">1</TD> <TD class="cc">100000</TD> <TD class="cc" rowspan=3>1</TD> <TD>Fastest</TD> </TR>
      <TR> <TD class="cc">3</TD> <TD class="cc">500000</TD>  <TD>Fast</TD> </TR>
      <TR> <TD class="cc">5</TD> <TD class="cc" rowspan=3>900000</TD> <TD>Normal</TD> </TR>
      <TR> <TD class="cc">7</TD> <TD align="center">2</TD> <TD>Maximum</TD> </TR>
      <TR> <TD class="cc">9</TD> <TD align="center">7</TD> <TD>Ultra</TD> </TR>
    </TABLE>
  </DD>

  <DT><A name="Deflate_FastBytes"></A>fb={NumFastBytes}</DT>
  <DD>
    <P>Sets the number of fast bytes for the Deflate/Deflate64 encoder.
       It can be in the range from 3 to 258 (257 for Deflate64).
       Usually, a big number gives a little bit better
       compression ratio and a slower compression process.
       A large fast bytes parameter can significantly increase the compression ratio
       for files which contain long identical sequences of bytes.</P>
  </DD>
  <DT><A name="Zip_Pass"></A>pass={NumPasses}</DT>
  <DD>
    <P>Sets number of passes for Deflate encoder. It can be in the range from 1 to 15 for Deflate and
       from 1 to 10 for BZip2. Usually, a big number gives a little bit better
       compression ratio and a slower compression process.
    </P>
  </DD>
  <DT><A name="ZipDictionarySize"></A>d={Size}[b|k|m]</DT>
  <DD>
    <P> Sets the Dictionary size for BZip2. You must specify the size in bytes, kilobytes, or megabytes.
       The maximum value for the Dictionary size is 900000b. If you do not specify any symbol 
       from set [b|k|m], dictionary size will be calculated as DictionarySize = 2^Size bytes.</P>
  </DD>

  <DT><A name="ZipMemorySize"></A>mem={Size}[b|k|m]</DT>
  <DD>
    <P> Sets the size of memory used for PPMd. You must specify the size in bytes, kilobytes, or megabytes.
       The maximum value is 256 MB = 2^28 bytes. The default value
       is 24 (16MB). If you do not specify any symbol from the set [b|k|m], the
       memory size will be calculated as (2^Size) bytes. PPMd uses the same 
       amount of memory for compression and decompression.</P>
  </DD>
  
  <DT><A name="ZipOrder"></A>o={Size}</DT>
  <DD>
    <P>Sets the model order for PPMd. The size must be in the range [2,16]. The default value is 8.</P>
  </DD>
  
  <DT><A name="ZipMultiThread"></A>mt=[off | on | {N}]</DT>
  <DD>
    <P>Sets multithread mode. If you have a multiprocessor or multicore system, 
       you can get a speed increase with
       this switch. This option affects only compression (with any method) and 
       decompression of BZip2 streams. 
       Each thread in the multithread mode uses 32 MB of RAM for buffering.
       If you specify {N}, 7-Zip tries to use N threads.</P>
  </DD>
</DL>

<H2><A name="GZ"></A>GZip</H2>
GZip uses the same parameters as Zip, but GZip compresses only with Deflate method.
So GZip supports only the following parameters: x, fb, pass.
                                                
<H2><A name="BZ2"></A>BZip2</H2>
<TABLE>
  <TR> 
    <TH width="160">Parameter</TH> 
    <TH align="center">Default</TH> 
    <TH>Description</TH> </TR>
  <TR> 
    <TD><A class="parameter" href="#BZip2X">x=[1 | 3 | 5 | 7 | 9 ]</A></TD> 
    <TD align="center">5</TD>
    <TD>Sets level of compression.</TD> </TR>
  <TR> 
    <TD><A class="parameter" href="#BZip2Pass">pass={NumPasses}</A></TD>
    <TD align="center">1</TD>
    <TD>Sets number of Passes for Bzip2 encoder.</TD></TR>
  <TR> 
    <TD><A class="parameter" href="#BZip2DictionarySize">d={Size}[b|k|m]</A></TD> 
    <TD align="center">900000</TD>  
    <TD>Sets Dictionary size for BZip2</TD></TR>
  <TR> 
    <TD><A class="parameter" href="#BZip2MultiThread">mt=[off | on | {N}]</A></TD> 
    <TD align="center">on</TD>  
    <TD>Sets multithreading mode.</TD></TR>
</TABLE>

<DL>
  <DT><A name="BZip2"></A>x=[1 | 3 | 5 | 7 | 9 ]</DT>
  <DD>
    <P>Sets level of compression</P>
    <TABLE>
      <TR> <TH>Level</TH> <TH>Dictionary</TH> <TH>NumPasses</TH> <TH>Description</TH> </TR>
      <TR> <TD class="cc">1</TD> <TD class="cc">100000</TD> <TD class="cc" rowspan=3>1</TD> <TD>Fastest</TD> </TR>
      <TR> <TD class="cc">3</TD> <TD class="cc">500000</TD>  <TD>Fast</TD> </TR>
      <TR> <TD class="cc">5</TD> <TD class="cc" rowspan=3>900000</TD> <TD>Normal</TD> </TR>
      <TR> <TD class="cc">7</TD> <TD align="center">2</TD> <TD>Maximum</TD> </TR>
      <TR> <TD class="cc">9</TD> <TD align="center">7</TD> <TD>Ultra</TD> </TR>
    </TABLE>
  </DD>

  <DT><A name="BZip2DictionarySize"></A>d={Size}[b|k|m]</DT>
  <DD>
    <P> Sets the Dictionary size for BZip2. You must specify the size in bytes, kilobytes, or megabytes.
       The maximum value for the Dictionary size is 900000b. If you do not specify any symbol 
       from set [b|k|m], dictionary size will be calculated as DictionarySize = 2^Size bytes.</P>
  </DD>

  <DT><A name="#BZip2Pass"></A>pass={NumPasses}</DT>
  <DD>
    <P>Sets the number of passes. It can be in the range from 1 to 10.
       The default value is 1 for normal mode, 2 for maximum mode and 7 for ultra mode.
       A bigger number can give a little bit better compression ratio and a slower compression process.
    </P>
  </DD>
  <DT><A name="BZip2MultiThread"></A>mt=[off | on | {N}]</DT>
  <DD>
    <P>Sets multithread mode. If you have a multiprocessor or multicore system, 
       you can get a speed increase with
       this switch. If you specify {N}, for example mt=4, 7-Zip tries to use 4 threads.</P>
  </DD>
</DL>

<H2><A name="7Z"></A>7z</H2>
<TABLE>
  <TR> 
    <TH width="80"> Parameter </TH> 
    <TH align="center"> Default </TH> 
    <TH> Description </TH> 
  </TR>
  <TR> <TD> <A class="parameter" href="#SevenZipX"> x=[0 | 1 | 3 | 5 | 7 | 9 ] </A> </TD> <TD align="center"> 5 </TD> <TD> Sets level of compression. </TD> </TR> 
  <TR> <TD> <A class="parameter" href="#SevenZipYX"> yx=[0 | 1 | 3 | 5 | 7 | 9 ] </A> </TD> <TD align="center"> 5 </TD> <TD> Sets level of file analysis. </TD> </TR> 
  <TR> <TD> <A class="parameter" href="#Solid"> s=[off | on | [e] [{N}f] [{N}b | {N}k | {N}m | {N}g] </A> </TD>        <TD align="center"> on </TD> <TD> Sets solid mode. </TD> </TR>
  <TR> <TD> <A class="parameter"> qs=[off | on] </A> </TD>        <TD align="center"> off </TD> <TD> Sort files by type in solid archives. </TD> </TR>
  <TR> <TD> <A class="parameter" href="#Filter"> f=[off | on | FilterID] </A> </TD> <TD align="center"> on </TD>  <TD>Enables or disables filters. FilterID: Delta:{N}, BCJ, BCJ2, ARM, ARMT, IA64, PPC, SPARC. </TD> </TR>
  <TR> <TD> <A class="parameter" href="#HeaderCompress"> hc=[off | on] </A> </TD> <TD align="center">on</TD>  <TD>Enables or disables archive header compressing. </TD> </TR>
  <TR> <TD> <A class="parameter" href="#HeaderEncrypt"> he=[off | on] </A> </TD> <TD align="center">off</TD>  <TD>Enables or disables archive header encryption. </TD> </TR>
  <TR> <TD> <A class="parameter" href="#Bind">b{C1}[s{S1}]:{C2}[s{S2}] </A> </TD> <TD align="center"> </TD>  <TD>Sets binding between coders.</TD> </TR>
  <TR> <TD> <A class="parameter" href="#MethodID">{N}={MethodID}[:param1][:param2][..]</A></TD> <TD align="center">LZMA2</TD>  <TD>Sets a method: LZMA, LZMA2, PPMd, BZip2, Deflate, Delta, BCJ, BCJ2, Copy. </TD> </TR>
  <TR> <TD> <A class="parameter" href="#MultiThread"> mt=[off | on | {N}] </A> </TD> <TD align="center">on</TD> <TD> Sets multithreading mode. </TD> </TR>
  <TR> <TD> <A class="parameter"> mtf=[off | on] </A> </TD> <TD align="center"> on </TD> <TD> Set multithreading mode for filters. </TD> </TR>
  <TR> <TD> <A class="parameter"> tm=[off | on] </A> </TD> <TD align="center"> on  </TD> <TD> Stores last Modified timestamps for files. </TD> </TR>
  <TR> <TD> <A class="parameter"> tc=[off | on] </A> </TD> <TD align="center"> off </TD> <TD> Stores Creation timestamps for files. </TD> </TR>
  <TR> <TD> <A class="parameter"> ta=[off | on] </A> </TD> <TD align="center"> off </TD> <TD> Stores last Access timestamps for files. </TD> </TR>
</TABLE>

<DL>
  <DT><A name="SevenZipX"></A>x=[0 | 1 | 3 | 5 | 7 | 9 ]</DT>
  <DD>
    <P>Sets level of compression</P>
    <TABLE>
      <TR> <TH>Level</TH> <TH>Method</TH> <TH>Dictionary</TH> <TH>FastBytes</TH> <TH>MatchFinder</TH> <TH>Filter</TH> <TH>Description</TH> </TR>
      <TR> <TD align="center">0</TD> <TD align="center">Copy</TD> <TD align="center"></TD> <TD align="center"></TD> <TD align="center"></TD> <TD align="center"></TD> <TD>No compression.</TD> </TR>
      <TR> <TD align="center">1</TD> <TD align="center">LZMA2</TD> <TD align="center">64 KB</TD> <TD align="center">32</TD> <TD align="center">HC4</TD> <TD align="center">BCJ</TD> <TD>Fastest compressing</TD> </TR>
      <TR> <TD align="center">3</TD> <TD align="center">LZMA2</TD> <TD align="center">1 MB</TD>  <TD align="center">32</TD> <TD align="center">HC4</TD> <TD align="center">BCJ</TD> <TD>Fast compressing</TD> </TR>
      <TR> <TD align="center">5</TD> <TD align="center">LZMA2</TD> <TD align="center">16 MB</TD>  <TD align="center">32</TD> <TD align="center">BT4</TD> <TD align="center">BCJ</TD> <TD>Normal compressing</TD> </TR>
      <TR> <TD align="center">7</TD> <TD align="center">LZMA2</TD> <TD align="center">32 MB</TD> <TD align="center">64</TD> <TD align="center">BT4</TD> <TD align="center">BCJ</TD> <TD>Maximum compressing</TD> </TR>
      <TR> <TD align="center">9</TD> <TD align="center">LZMA2</TD> <TD align="center">64 MB</TD> <TD align="center">64</TD> <TD align="center">BT4</TD> <TD align="center">BCJ2</TD><TD>Ultra compressing</TD> </TR>
    </TABLE>
    <P>Note: "x" works as "x=9".</P>
  </DD>

  <DT><A name="SevenZipYX"></A>yx=[0 | 1 | 3 | 5 | 7 | 9 ]</DT>
  <DD>
    <P>Sets level of file analysis</P>
    <TABLE>
      <TR> <TH>Level</TH> <TH>Description</TH> </TR>
      <TR> <TD align="center">0</TD> <TD>No analysis.</TD> </TR>
      <TR> <TD align="center">1 or more</TD> <TD>WAV file analysis (for Delta filter).</TD> </TR>
      <TR> <TD align="center">7 or more</TD> <TD>EXE file analysis (for Executable filters).</TD> </TR>
      <TR> <TD align="center">9 or more</TD> <TD>analysis of all files (Delta and executable filters).</TD> </TR>
    </TABLE>
    <P>Default level is 5: "yx=5".</P>
    <P>"yx" works as "yx=9".</P>

    <P>If the level of analysis is smaller than 9, 7-Zip analyses only files 
       that have some file name extensions: EXE, DLL, WAV.
       7-Zip reads small data block at the beginning of file and tries to parse 
       the header. It supports only some formats: WAV, PE, ELF, Mach-O.
       Then it can select filter that can increase compression ratio for that file.</P>
        
    <P>By default 7-Zip uses x86 filters (BCJ or BCJ2) for PE files (EXE, DLL).
       7-Zip doesn't use analysis in default (yx=5) mode.
       If (yx=7), then analysis is used for PE files, and it can increase compression 
       ratio for files for non-x86 platforms like ARM.</P>

  </DD>

  <DT><A name="Solid"></A>s=[off | on | [e] [{N}f] [{N}b | {N}k | {N}m | {N}g)]</DT>
  <DD>
    <P> Enables or disables solid mode. The default mode is s=on. 
        In solid mode, files are grouped together. Usually, compressing in  
        solid mode improves the compression ratio.</P>

    <TABLE>
      <TR> <TD>e</TD> <TD>Use a separate solid block for each new file extension</TD> </TR>
      <TR> <TD>{N}f</TD> <TD>Set the limit for number of files in one solid block</TD> </TR>
      <TR> <TD>{N}b | {N}k | {N}m | {N}g</TD> <TD>Set a limit for the total size of a solid block in bytes</TD> </TR>
    </TABLE>

    <P>These are the default limits for the solid block size:</P>

    <TABLE>
      <TR> <TH width="150">Compression Level</TH> <TH>Solid block size</TH> </TR>
      <TR> <TD>Store</TD> <TD>0 B</TD> </TR>
      <TR> <TD>Fastest</TD> <TD>16 MB</TD> </TR>
      <TR> <TD>Fast</TD> <TD>128 MB</TD> </TR>
      <TR> <TD>Normal</TD> <TD>2 GB</TD> </TR>
      <TR> <TD>Maximum</TD> <TD>4 GB</TD> </TR>
      <TR> <TD>Ultra</TD> <TD>4 GB</TD> </TR>
    </TABLE>


    <P>Limitation of the solid block size usually decreases compression ratio but gives the following advantages:</P>
    <UL>
      <LI>Decreases losses in case of future archive damage.
      <LI>Decreases extraction time of a group of files (or just one
     file), so long as the group doesn't contain the entire archive.</LI></LI>
    </UL>
    <P>The updating of solid .7z archives can be slow, since it 
	can require some recompression.</P>

    <P>Example:</P>
      <PRE class="example">
        s=100f10m
      </PRE>
    <P>set solid mode with 100 files & 10 MB limits per one solid block.</P>

  <DT><A name="Filter"></A>f=[off | on | FilterID]</DT>
  <DD>
    <P>Enables or disables compression filters.
     The default mode is f=on, when 7-zip uses filter only for executable files:
     dll, exe, ocx, sfx, sys. It uses BCJ2 filter in Ultra mode and BCJ filter in other modes.
     If f=FilterID if specified, 7-zip uses specified filter for all files.
     FilterID can be: Delta:{N}, BCJ, BCJ2, ARM, ARMT, IA64, PPC, SPARC.
    </P>
  <DT><A name="HeaderCompress"></A>hc=[off | on]</DT>
  <DD>
    <P> Enables or disables archive header compressing. The default mode is hc=on. 
        If archive header compressing is enabled, the archive header will 
        be compressed with LZMA method.
    </P>
  <DT><A name="HeaderEncrypt"></A>he=[off | on]</DT>
  <DD>
    <P> Enables or disables archive header encryption. The default mode is he=off. 
    </P>

  <DT><A name="Bind"></A>b{C1}[s{S1}]:{C2}[s{S2}]</DT>
  <DD>
    <P> Binds output stream S1 in coder C1 with input stream S2 in coder C2.
        If stream number is not specified, stream with number 0 will be used.
        </P>
    <P> Usally coder has one input stream and 
    one output stream. In 7z some coders can have multiple input and output streams.</P>

    <P>For example, <A class="parameter" href="#BCJ2">BCJ2</A> encoder has one 
     input stream and four output streams.</P>
  </DD>

  <DT><A name="MultiThread"></A>mt=[off | on | {N}]</DT>
  <DD>
    <P>Sets multithread mode. If you have a multiprocessor or multicore system, 
       you can get a increase with this switch.
       7-Zip supports multithread mode only for LZMA / LZMA2 compression and 
       BZip2 compression / decompression. If you specify {N}, for example mt=4, 
       7-Zip tries to use 4 threads. LZMA compression uses only 2 threads.
    </P>
  </DD>
  
  <DT><A name="MethodID"></A>{N}={MethodID}[:param1][:param2] ... [:paramN]</DT>
  <DD>
    <P>Sets compression method. You can use any number of methods. 
       The default method is LZMA2.</P>

    <P>{N} sets the index number of method in methods chain.
       Numbers must begin from 0. Methods that have smaller numbers will be used
       before others.</P>


    <P>Parameters must be in one of the following forms:</P>
    <UL>
      <LI>{ParamName}={ParamValue}.
      <LI>{ParamName}{ParamValue}, if {ParamValue} 
        is number and {ParamName} doesn't contain numbers.
    </UL>
        
    <P>Supported methods:</P>
    <TABLE>
      <TR> <TH width="60">MethodID</TH> <TH>Description</TH> </TR>
      <TR> <TD><A class="parameter" href="#LZMA">LZMA</A></TD> <TD>LZ-based algorithm</TD> </TR>
      <TR> <TD><A class="parameter" href="#LZMA2">LZMA2</A></TD> <TD>LZMA-based algorithm</TD> </TR>
      <TR> <TD><A class="parameter" href="#PPMd">PPMd</A></TD> <TD>Dmitry Shkarin's PPMdH with small changes</TD> </TR>
      <TR> <TD>BZip2</TD> <TD>BWT algorithm</TD> </TR>
      <TR> <TD>Deflate</TD> <TD>LZ+Huffman</TD> </TR>
      <TR> <TD>Copy</TD> <TD>No compression</TD> </TR>
    </TABLE>

    <P>Supported filters:</P>
    <TABLE>
      <TR> <TH width="60">MethodID</TH> <TH>Description</TH> </TR>
      <TR> <TD><A class="parameter" href="#Delta">Delta</A></TD> <TD>Delta filter</TD> </TR>
      <TR> <TD>BCJ</TD> <TD>converter for x86 executables</TD> </TR>
      <TR> <TD><A class="parameter" href="#BCJ2">BCJ2</A></TD> <TD>converter for x86 executables (version 2)</TD> </TR>
      <TR> <TD>ARM</TD> <TD>converter for ARM (little endian) executables</TD> </TR>
      <TR> <TD>ARMT</TD> <TD>converter for ARM Thumb (little endian) executables</TD> </TR>
      <TR> <TD>IA64</TD> <TD>converter for IA-64 executables</TD> </TR>
      <TR> <TD>PPC</TD> <TD>converter for PowerPC (big endian) executables</TD> </TR>
      <TR> <TD>SPARC</TD> <TD>converter for SPARC executables</TD> </TR>
    </TABLE>
    <P>Filters increase the compression ratio for some types of files. Filters
       must be used with one of the compression method (for example, BCJ + LZMA).</P>
  </DD>

 <H4><A name="LZMA"></A>LZMA</H4>
 <P> LZMA is an algorithm based on Lempel-Ziv algorithm.
   It provides very fast decompression (about 10-20 times faster than compression). 
   Memory requirements for compression and decompression also are different (see
   <A class="parameter" href="#DictionarySize">d={Size}[b|k|m|g]</A> switch for details).</P>

 <TABLE>
   <TR> <TH width="80">Parameter</TH> <TH align="center">Default</TH> <TH>Description</TH> </TR>

   <TR> <TD><A class="parameter" href="#LZMAMode">a=[0|1]</A></TD> 
        <TD align="center">1</TD>  <TD>Sets compressing mode</TD> </TR>
   <TR> <TD><A class="parameter" href="#DictionarySize">d={Size}[b|k|m|g]</A></TD> 
        <TD align="center">24</TD>  <TD>Sets Dictionary size</TD> </TR>
   <TR> <TD><A class="parameter" href="#MatchFinder">mf={MF_ID}</A></TD> 
        <TD align="center">bt4</TD>  <TD>Sets Match Finder</TD> </TR>
   <TR> <TD><A class="parameter" href="#FastBytes">fb={N}</A></TD> 
        <TD align="center">32</TD>  <TD>Sets number of Fast Bytes</TD></TR>
   <TR> <TD><A class="parameter" href="#MatchFinderCycles">mc={N}</A></TD> 
        <TD align="center">32</TD><TD>Sets Number of Cycles for Match Finder</TD> </TR>
   <TR> <TD><A class="parameter" href="#LitContext">lc={N}</A></TD> 
        <TD align="center">3</TD>  <TD>Sets number of Literal Context bits - [0, 8]</TD></TR>
   <TR> <TD><A class="parameter" href="#LitPos">lp={N}</A></TD> 
        <TD align="center">0</TD>  <TD>Sets number of Literal Pos bits - [0, 4]</TD></TR>
   <TR> <TD><A class="parameter" href="#PosBits">pb={N}</A></TD> 
        <TD align="center">2</TD>  <TD>Set number of Pos Bits - [0, 4]</TD></TR>
 </TABLE>


 <DL>
  <DT><A name="#LZMAMode"></A>a=[0|1]</DT>
  <DD>
    <P> Sets compression mode: 0 = fast, 1 = normal.
      Default value is 1.</P>
  </DD>
  <DT><A name="DictionarySize"></A>d={Size}[b|k|m|g]</DT>
  <DD>
    <P> Sets Dictionary size for LZMA. You must specify the size in bytes, kilobytes, or megabytes.
       The maximum value for dictionary size is 1536 MB, but 32-bit version of 7-Zip allows 
       to specify up to 128 MB dictionary.
       Default values for LZMA
       are 24 (16 MB) in normal mode, 25 (32 MB) in maximum mode (-mx=7) 
       and 26 (64 MB) in ultra mode (-mx=9). 
       If you do not specify any symbol from the set [b|k|m|g], the
       dictionary size will be calculated as DictionarySize = 2^Size bytes.
       For decompressing a file compressed by LZMA method with dictionary size N, you need
       about N bytes of memory (RAM) available.
       </P>
  </DD>
  <DT><A name="MatchFinder"></A>mf={MF_ID}</DT>
  <DD>
    <P> Sets Match Finder for LZMA. Default method is bt4. 
       Algorithms from hc* group don't provide a good compression ratio,
       but they often work pretty fast in combination with fast mode (a=0).
       Memory requirements depend on dictionary size (parameter "d" in table below).
    </P>
    <TABLE>
      <TR> <TH>MF_ID</TH> <TH class="cc">Dictionary</TH> <TH class="cc" colspan = 2>Memory Usage</TH> <TH class="cc" colspan = 2>Description</TH> </TR>
      <TR> <TD class="cc">bt2</TD>           <TD></TD>                             <TD align="right"> 9.5 * d</TD> <TD class="cc" rowspan=6> + 4 MB</TD> <TD class="cc" rowspan=4>Binary Tree</TD> <TD>2 bytes hashing</TD> </TR>
      <TR> <TD class="cc">bt3</TD>           <TD></TD>                             <TD align="right">11.5 * d</TD> <TD>3 bytes hashing</TD> </TR>
      <TR> <TD class="cc" rowspan=2>bt4</TD> <TD class="cc">64 KB ...   48 MB</TD> <TD align="right">11.5 * d</TD> <TD class="cc" rowspan=6>4 bytes hashing</TD> </TR>
      <TR>                                   <TD class="cc">64 MB ... 1024 MB</TD> <TD align="right">10.5 * d</TD> </TR>
      <TR> <TD class="cc" rowspan=2>hc4</TD> <TD class="cc">64 KB ...   48 MB</TD> <TD align="right"> 7.5 * d</TD> <TD class="cc" rowspan=2>Hash Chain </TD></TR>
      <TR>                                   <TD class="cc">64 MB ... 1024 MB</TD> <TD align="right"> 6.5 * d</TD> </TR>
    </TABLE>
    <P>Note: Your operation system also needs some amount of physical memory for internal purposes. 
      So keep at least 32MB of physical memory unused.</P>
  </DD>
  
  <DT><A name="FastBytes"></A>fb={N}</DT>
  <DD>
    <P>Sets number of fast bytes for LZMA. It can be in the range from 5 to 273.
       The default value is 32 for normal mode and 64 for maximum and ultra modes.
       Usually, a big number gives a little bit better
       compression ratio and slower compression process.
       </P>
  </DD>
  <DT><A name="MatchFinderCycles"></A>mc={N}</DT>
  <DD>
    <P>Sets number of cycles (passes) for match finder. It can be in range from 0 to 1000000000.
       Default value is (16 + number_of_fast_bytes / 2) for BT* match finders and 
       (8 + number_of_fast_bytes / 4) for HC4 match finder. 
       If you specify mc=0, LZMA will use default value.
       Usually, a big number gives a little bit better compression ratio and slower
       compression process. For example, mf=HC4 and mc=10000 can provide almost the same
       compression ratio as mf=BT4.</P>
  </DD>
  <DT><A name="LitContext"></A>lc={N}</DT>
  <DD>
    <P>Sets the number of literal context bits (high bits of previous literal).
       It can be in range from 0 to 8.
       Default value is 3. Sometimes lc=4 gives gain for big files.</P>
  </DD>
  <DT><A name="LitPos"></A>lp={N}</DT>
  <DD>
    <P>Sets the number of literal pos bits (low bits of current position for literals).
       It can be in the range from 0 to 4.
       The default value is 0. The lp switch is intended for periodical data when the 
       period is equal to 2^value (where lp=value). For example, for 32-bit (4 bytes)
       periodical data you can use lp=2. Often it's better to set lc=0, 
       if you change lp switch.</P>
  </DD>
  <DT><A name="PosBits"></A>pb={N}</DT>
  <DD>
    <P>Sets the number of pos bits (low bits of current position).
       It can be in the range from 0 to 4.
       The default value is 2. The pb switch is intended for periodical data when the
       period is equal 2^value (where lp=value). </P>
  </DD>
  
 </DL>
  
 <H4><A name="LZMA2"></A>LZMA2</H4>
 <P>LZMA2 is modified version of LZMA. it provides the following advantages over LZMA:</P>
 <UL>
   <LI>Better compression ratio for data than can't be compressed.  LZMA2 can store such 
       blocks of data in uncompressed form. Also it decompresses such data faster. 
   <LI>Better multithreading support. If you compress big file, LZMA2 can split  
	that file to chunks and compress these chunks in multiple threads.
 </UL>

 <TABLE>
   <TR> <TH width="80">Parameter</TH> <TH align="center">Default</TH> <TH>Description</TH> </TR>

   <TR> <TD><A class="parameter" href="#ChunkSize">c={Size}[b|k|m|g]</A></TD> 
        <TD align="center">dictSize * 4</TD>  <TD>Sets Chunk size</TD> </TR>
 </TABLE>

 <P>If you don't specify ChunkSize, LZMA2 sets it to max(DictionarySize, min(256M, max(1M, DictionarySize * 4))).</P>

 <P>LZMA2 also supports all LZMA parameters, but lp+lc cannot be larger than 4.</P>
 
  <P>LZMA2 uses: 1 thread for each chunk in x1 and x3 modes; and 
   2 threads for each chunk in x5, x7 and x9 modes. 
   If LZMA2 is set to use only such number of threads required for one chunk,  
   it doesn't split stream to chunks. So you can get different compression  
   ratio for different number of threads. You can get the best compression 
   ratio, when you use 1 or 2 threads.</P>  

 <H4><A name="PPMd"></A>PPMd</H4>
 <P> PPMd is a PPM-based algorithm. This algorithm is mostly based 
 on Dmitry Shkarin's PPMdH source code. PPMd provides very good compression ratio for 
 plain text files. There is no difference between compression speed and
 decompression speed. Memory requirements for compression and decompression
 also are the same.</P>
 <TABLE>
   <TR> <TH width="80">Parameter</TH> <TH align="center">Default</TH> <TH>Description</TH> </TR>
   <TR> <TD><A class="parameter" href="#MemorySize">mem={Size}[b|k|m|g]</A></TD> 
        <TD align="center">24</TD>  <TD>Sets size of used memory for PPMd.</TD> </TR>
   <TR> <TD><A class="parameter" href="#Order">o={Size}</A></TD> 
        <TD align="center">6</TD>  <TD>Sets model order for PPMd.</TD> </TR>
 </TABLE>
 <DL>
  <DT><A name="MemorySize"></A>mem={Size}[b|k|m|g]</DT>
  <DD>
    <P> Sets the size of memory used for PPMd. You must specify the size in bytes, kilobytes, or megabytes.
       The maximum value is 2GB = 2^31 bytes. The default value
       is 24 (16MB). If you do not specify any symbol from the set [b|k|m|g], the
       memory size will be calculated as (2^Size) bytes. PPMd uses the same 
       amount of memory for compression and decompression.</P>
  </DD>
  
  <DT><A name="Order"></A>o={Size}</DT>
  <DD>
    <P>Sets the model order for PPMd. The size must be in the range [2,32]. The default value is 6.</P>
  </DD>
 </DL>

 <H4><A name="BCJ2"></A>BCJ2</H4>
 <P>BCJ2 is a Branch converter for 32-bit x86 executables (version 2). 
 It converts some branch instructions for increasing further compression.</P>
 <P>A BCJ2 encoder has one input stream and four output streams:</P>
 <UL>
   <LI>s0: main stream. It requires further compression.</LI> 
   <LI>s1: stream for converted CALL values. It requires further compression.</LI>  
   <LI>s2: stream for converted JUMP values. It requires further compression.</LI>  
   <LI>s3: service stream. It is already compressed.</LI>  
 </UL>
 <P>If LZMA is used, the size of the dictionary for streams
    s1 and s2 can be much smaller (512 KB is enough for most cases) 
    than the dictionary size for stream s0.</P>

 <P><B>Parameters:</B><P>
 <DL>
  <DT></A>d={Size}[b|k|m|g]</DT>
  <DD>
    <P> Sets section size for BCJ2 filter. Default section size is 64 MB.
       If you do not specify any symbol from the set [b|k|m|g], the
       section size will be calculated as SectionSize = 2^Size bytes.
       This parameter doesn't affect memory consumption.
       Compression ratio is better, if the section size is equal
       or slightly larger than size of largest execution section in file.
       Example: f=BCJ2:d9M, if largest executable section in files is smaller than 9 MB. 
    </P>
  </DD>
 </DL>


 <H4><A name="Delta"></A>Delta</H4>
 <P>It's possible to set delta offset in bytes. For example, to compress 16-bit stereo 
   WAV files, you can set "0=Delta:4". Default delta offset is 1.</P>
</DL>

<H2><A name="XZ"></A>XZ</H2>

<P>XZ supports only LZMA2 codec now. The switches are similar to switches for 7z format.</P>

<TABLE>
  <TR> 
    <TH width="80"> Parameter </TH> 
    <TH align="center"> Default </TH> 
    <TH> Description </TH> 
  </TR>
  <TR> <TD> <A class="parameter" > x=[0 | 1 | 3 | 5 | 7 | 9 ] </A> </TD> <TD align="center"> 5 </TD> <TD> Sets level of compression </TD> </TR> 
  <TR> <TD> <A class="parameter" > f=FilterID </A> </TD> <TD align="center"> </TD>  <TD> Sets compression filter. FilterID: Delta:{N}, BCJ, ARM, ARMT, IA64, PPC, SPARC </TD> </TR>
  <TR> <TD> <A class="parameter" > {N}={MethodID}[:param1][:param2][..]</A></TD> <TD align="center"> LZMA2 </TD> <TD> Sets compression method: LZMA2:[param1]:[param2]:[...] </TD> </TR>
  <TR> <TD> <A class="parameter" > mt=[off | on | {N}] </A> </TD> <TD align="center"> on </TD> <TD> Sets multithreading mode </TD> </TR>
</TABLE>

<H2><A name="WIM"></A>WIM</H2>

<TABLE>
  <TR> 
    <TH width="160">Parameter</TH> 
    <TH align="center">Default</TH> 
    <TH>Description</TH> </TR>
  <TR> 
    <TD><A class="parameter" href="#mim">im={ImageNumber}</A></TD> 
    <TD align="center"></TD>
    <TD>Sets image number.</TD> </TR>
  <TR> 
    <TD>is=[off | on]</TD> 
    <TD align="center">off</TD> 
    <TD>Show image number in paths.</TD> </TR>
</TABLE>

<P>If image number is specified, 7-Zip works only with that image inside WIM archive.
Other images will be not changed. By default 7-Zip doesn't show image number, if there is only one 
image in WIM archive, or if image number is specified. But if the switch "is" specified, 
7-Zip shows image number.<P>

<H4>Examples</H4>

<PRE class="example">
7z a archive.zip *.jpg -mx0
</PRE>

<P>adds <SPAN class="filename">*.jpg</SPAN> files to
  <SPAN class="filename">archive.zip</SPAN> archive without compression.</P>

<PRE class="example">
7z a archive.7z *.exe *.dll -m0=BCJ -m1=LZMA:d=21
</PRE>

<P>adds <SPAN class="filename">*.exe</SPAN> and <SPAN class="filename">*.dll</SPAN> 
files to solid archive  <SPAN class="filename">archive.7z</SPAN> using LZMA method with 
2 MB dictionary and BCJ filter.</P>

<PRE class="example">
7z a archive.7z a.tar -mf=BCJ2 -mx
</PRE>

<P>adds <SPAN class="filename">a.tar</SPAN> 
  files to archive  <SPAN class="filename">archive.7z</SPAN> using BCJ2 filter.</P>

<PRE class="example">
7z a archive.7z *.wav -mf=Delta:4
</PRE>

<P>adds <SPAN class="filename">*.wav</SPAN> 
  files to archive  <SPAN class="filename">archive.7z</SPAN> using Delta:4 filter.</P>

<PRE class="example">
7z a a.7z *.exe *.dll -m0=BCJ2 -m1=LZMA:d25 -m2=LZMA:d19 -m3=LZMA:d19 -mb0:1 -mb0s1:2 -mb0s2:3
</PRE>

<P>adds <SPAN class="filename">*.exe</SPAN> and <SPAN class="filename">*.dll</SPAN> 
  files to archive  <SPAN class="filename">a.7z</SPAN> using BCJ2 filter, 
  LZMA with 32 MB dictionary for main output stream (s0), 
  and LZMA with 512 KB dictionary for s1 and s2 output streams of BCJ2.</P>

<PRE class="example">
7z a archive.7z *.txt -m0=PPMd
</PRE>

<P>adds <SPAN class="filename">*.txt</SPAN> files to archive  
<SPAN class="filename">archive.7z</SPAN> using PPMd method.</P>


<PRE class="example">
7z a a.tar.xz a.tar -mf=bcj -mx
</PRE>

<P>adds <SPAN class="filename">a.tar</SPAN> 
  files to archive  <SPAN class="filename">a.tar.xz</SPAN> using BCJ filter.</P>


<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/hash.htm">h (Hash)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/rename.htm">rn (Rename)</A>,
  <A href="../commands/update.htm">u (Update)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
  <A href="type.htm">-t (set Type of archive)</A>,
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-o (set Output directory) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-o (set Output directory) switch</H1>

<P>Specifies a destination directory where files are to be extracted.</P>
<P>This switch can be used only with extraction commands.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-o{dir_path}
</PRE>

<DL>
  <DT>{dir_path}</DT>
  <DD>This is the destination directory path. It's not required to end with a backslash.
  If you specify <B>*</B> in {dir_path}, 7-Zip substitutes that * character to archive name.</DD>
</DL>


<H4>Example</H4>

<PRE class="example">
7z x archive.zip -oc:\Doc
</PRE>

<P>extracts all files from the <SPAN class="filename">archive.zip</SPAN> archive
to the <SPAN class="filename">c:\Doc</SPAN> directory.</P>

<PRE class="example">
7z x *.zip -o*
</PRE>

<P>extracts all <SPAN class="filename">*.zip</SPAN> archives to subfolders
with names of these archives.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-ao (Overwrite mode) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-ao (Overwrite mode) switch</H1>

<P>Specifies the overwrite mode during extraction, to overwrite files already present on disk.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-ao[a | s | t | u ]
</PRE>


<TABLE>
  <TR> <TH width="80">Switch</TH> <TH>Description</TH> </TR>
  <TR> <TD>-aoa</TD> <TD>Overwrite All existing files without prompt.</TD> </TR>
  <TR> <TD>-aos</TD> <TD>Skip extracting of existing files.</TD> </TR>
  <TR> <TD>-aou</TD> <TD>aUto rename extracting file (for example, name.txt will 
      be renamed to name_1.txt).</TD> </TR>
  <TR> <TD>-aot</TD> <TD>auto rename existing file (for example, name.txt will 
      be renamed to name_1.txt).</TD> </TR>
</TABLE>

<H4>Examples</H4>

<PRE class="example">
7z x test.zip -aoa
</PRE>

<P>extracts all files from <SPAN class="filename">test.zip</SPAN> archive and overwrites
existing files without any prompt.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
  <A href="yes.htm">-y (assume Yes on all queries)</A>,
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-p (set Password) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-p (set Password) switch</H1>

<P>Specifies password.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-p{password}
</PRE>

<DL>
  <DT>{password}</DT>
  <DD>Specifies password.</DD>
</DL>


<H4>Examples</H4>

<PRE class="example">
7z a archive.7z -psecret -mhe *.txt
</PRE>
<P>compresses *.txt files to <SPAN class="filename">archive.7z</SPAN> using password 
"secret". Also it encrypts archive headers (-mhe switch), so filenames will be encrypted.
</P>

<PRE class="example">
7z x archive.zip -psecret
</PRE>
<P>extracts all files from <SPAN class="filename">archive.zip</SPAN> using password 
"secret".</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/rename.htm">rn (Rename)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-r (Recurse subdirectories) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-r (Recurse subdirectories) switch</H1>

<P>Specifies the method of treating wildcards and filenames on the command line.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-r[- | 0]
</PRE>


<TABLE>
  <TR><TH width="80">Switch</TH> <TH>Description</TH></TR>
  <TR><TD>-r</TD> <TD>Enable recurse subdirectories.</TD></TR>
  <TR><TD>-r-</TD> <TD>Disable recurse subdirectories. This option is default for all commands.</TD></TR>
  <TR><TD>-r0</TD> <TD>Enable recurse subdirectories only for wildcard names.</TD></TR>
</TABLE>

<H4>Examples</H4>

<PRE class="example">
7z l archive.zip *.doc -r-
</PRE>

<P>lists all <SPAN class="filename">*.doc</SPAN> files
  that belong to the archived root directory
  in the <SPAN class="filename">archive.zip</SPAN> archive.
  </P>

<PRE class="example">
7z a -tzip archive.zip -r src\*.cpp src\*.h
</PRE>

<P>adds all <SPAN class="filename">*.cpp</SPAN> and <SPAN class="filename">*.h</SPAN>
  files from directory <SPAN class="filename">src</SPAN> and all it's subdirectories
  to the <SPAN class="filename">archive.zip</SPAN> archive.</P>

<PRE class="example">
7z a archive.7z folder1\
</PRE>

<P>adds all files from directory <SPAN class="filename">folder1</SPAN> and all it's subdirectories
  to the <SPAN class="filename">archive.7z</SPAN> archive.</P>

<PRE class="example">
7z a archive.7z -r folder2\
</PRE>

<P>searches all <SPAN class="filename">folder2</SPAN> directories in all subdirectories,
  and adds them (including all subdirectories) to the <SPAN class="filename">archive.7z</SPAN> archive.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/hash.htm">h (Hash)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/rename.htm">rn (Rename)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
  <A href="include.htm">-i (Include)</A>,
  <A href="exclude.htm">-x (Exclude)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-sa (set Archive name mode) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-sa (set Archive name mode) switch</H1>

<P>Specifies Archive name mode.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-sa[a | e | s]
</PRE>

<TABLE>
  <TR> <TH width="80"> Switch </TH> <TH> Description </TH> </TR>
  <TR> <TD> -saa </TD> <TD> Always add archive type extension. </TD> </TR>
  <TR> <TD> -sae </TD> <TD> Use exact name specified in command. </TD> </TR>
  <TR> <TD> -sas </TD> <TD> Add extension only if specified name has no extension.
                            It's default option.</TD> </TR>
</TABLE>

<H4>Examples</H4>

<PRE class="example">
  7z a arc 1.txt
</PRE>
  <P>creates <SPAN class="filename">arc.7z</SPAN></P>

<PRE class="example">
  7z a arc.spec 1.txt 
</PRE>
  <P>creates <SPAN class="filename">arc.spec</SPAN></P>

<PRE class="example">
  7z a arc 1.txt -sae
</PRE>
  <P>creates <SPAN class="filename">arc</SPAN></P>

<PRE class="example">
  7z a file.pdf file.pdf -saa -tzip
</PRE>
  <P>creates <SPAN class="filename">file.pdf.zip</SPAN></P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-scc (Set charset for console input/output) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-scc (Set charset for console input/output) switch</H1>

<P>Sets charset for for console input/output.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-scc{UTF-8 | WIN | DOS}
</PRE>

<P>Default charset is DOS.</P>

<DL>
  <DT>UTF-8</DT>
  <DD>Unicode UTF-8 character set.</DD>
  <DT>WIN</DT>
  <DD>Default character set of Windows.</DD>
  <DT>DOS</DT>
  <DD>DOS (OEM) character set of Windows.</DD>
</DL>

<H4>Example</H4>

<PRE class="example">
7z l archive.7z -sccUTF-8
</PRE>

<P>lists files from <SPAN class="filename">archive.7z</SPAN> in UTF-8 encoding.</P>


</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-scrc (Set hash function) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-scrc (Set hash function) switch</H1>

<P>Sets hash function for "extract" and "hash" commands.</P> 

<H4>Syntax</H4>

<PRE class="syntax">
[-scrc{Method}]
</PRE>

<P>Supported methods: CRC32, CRC64, SHA1, SHA256, BLAKE2sp, *. Default method is CRC32.</P>

<H4>Examples</H4>

<PRE class="example">
7z t -scrcSHA256 archive.gz
</PRE>

<P>tests archive <SPAN class="filename">archive.gz</SPAN> and calculated SHA-256 for decompressed data.</P>

<PRE class="example">
7z h -scrcsha1 *.iso
</PRE>

<P>calculates SHA-1 for <SPAN class="filename">*.iso</SPAN> files.</P>


<PRE class="example">
7z h -scrc* file.iso
</PRE>

<P>calculates hash values for <SPAN class="filename">file.iso</SPAN> file.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/hash.htm">h (Hash)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-sdel (Delete files after including to archive) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-sdel (Delete files after compression) switch</H1>

<H4>Syntax</H4>

<PRE class="syntax">
-sdel
</PRE>

<P> If -sdel switch is specified, 7-Zip deletes files 
after including to archive. So it works like moving files to archive.</P>
7-Zip deletes files at the end of operation and only if archive was successfully created.</P>

<H4>Examples</H4>

<PRE class="example">
7z a a.7z *.txt -sdel
</PRE>

<P>moves <SPAN class="filename">txt</SPAN> files from disk's directory to a.7z archive.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>
</P>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-sfx (Create SFX archive) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-sfx (Create SFX archive) switch</H1>

<P>Creates self extracting archive.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-sfx[<A class="parameter" href="#SFX_Module">{SFX_Module}</A>]
</PRE>

<DL>
  <DT><A name="SFX_Module"></A>{SFX_Module}</DT>
  <DD>
    <P>Specifies the SFX module that will be combined with the archive.
       This module must be placed in the same directory as the 7z.exe.
       If {SFX_Module} is not assigned, 7-Zip will use standard console 
       SFX module 7zCon.sfx.</P>
    <TABLE>
      <TR> <TH width="60">SFX_Module</TH> <TH>Description</TH> </TR>
      <TR> <TD>7z.sfx</TD> <TD>Windows version.</TD> </TR>
      <TR> <TD>7zCon.sfx</TD> <TD>Console version.</TD> </TR>
      <TR> <TD>7zS.sfx</TD> <TD>Windows version for installers.</TD> </TR>
      <TR> <TD>7zSD.sfx</TD> <TD>Windows version for installers (uses MSVCRT.dll).</TD> </TR>
    </TABLE>
  </DD>
</DL>

<P>SFX module can unpack 7z archive or 7z multivolume archive. For example, 
if you have name.7z or name.7z.001 archive, just rename sfx muldule to name.exe and place 
to same folder with archive.</P>

<H4>SFX modules for installers</H4>

<P>SFX modules for installers are included in an external package (7z_extra). You can download
these modules from www.7-zip.org. SFX modules for installers (7zS.sfx and 7zSD.sfx)
allow you to create your own installation program.
Such a module extracts the archive to the user's temp folder, and runs a specified program,
and removes the temp files after the program finishes.
A self-extracting archive for installers must be created as joining the following files:
SFX_Module, Installer_Config (optional), 7z_Archive. 
You can use the following command to create an installer self-extracting archive:</P>
<PRE class="example">
copy /b 7zS.sfx + config.txt + archive.7z archive.exe
</PRE>

<P>An optimally small installation package size can be achieved,
if the installation files are uncompressed before including them in the 7z archive.</P>

<P><SPAN class="filename">-y</SPAN> switch for installer module specifies quiet mode extraction.</P>

<H4>Installer Config file format</H4>
<P>
This config file contains commands for the Installer. The file begins with the string
<B>;!@Install@!UTF-8!</B> and ends with <B>;!@InstallEnd@!</B>.
The file must be written in UTF-8 encoding.
The file contains any or all these string pairs:
<P>ID_String="Value"</P>
<P>
    <TABLE>
      <TR> <TH width="60">ID_String</TH> <TH>Description</TH> </TR>
      <TR> <TD>Title</TD> <TD>Title for messages</TD> </TR>
      <TR> <TD>BeginPrompt</TD> <TD>Begin Prompt message</TD> </TR>
      <TR> <TD>Progress</TD> <TD>Value can be "yes" or "no". Default value is "yes".</TD> </TR>
      <TR> <TD>RunProgram</TD> <TD>Command for executing. Default value is "setup.exe". Substring <B>%%T</B> 
      will be replaced with path to temporary folder, where files were extracted</TD> </TR>
      <TR> <TD>Directory</TD> <TD>Directory prefix for "RunProgram". Default value is ".\\"</TD> </TR>
      <TR> <TD>ExecuteFile</TD> <TD>Name of file for executing</TD> </TR>
      <TR> <TD>ExecuteParameters</TD> <TD>Parameters for "ExecuteFile"</TD> </TR>
    </TABLE>
</P>
<P>You may omit any pair.</P>

<P>There are two ways to run a installation program: <B>RunProgram</B> and <B>ExecuteFile</B>.
Use <B>RunProgram</B>, if you want to run a program from the .7z archive.
Use <B>ExecuteFile</B>, if you want to open a document from the .7z archive, or
if you want to execute a command from Windows.</P>

<P>If you use <B>RunProgram</B>, and if you specify empty directory prefix: <B>Directory</B>="",
the system searches for the executable file in the following sequence:</P>
<OL>
<LI>The directory from which the application (installer) loaded. 
<LI>The temporary folder, where files were extracted.
<LI>The Windows system directory. 
</OL>

<H4>Config file Examples</H4>

<PRE class="example">
;!@Install@!UTF-8!
Title="7-Zip 4.00"
BeginPrompt="Do you want to install the 7-Zip 4.00?"
RunProgram="setup.exe"
;!@InstallEnd@!
</PRE>

<BR>


<PRE class="example">
;!@Install@!UTF-8!
Title="7-Zip 4.00"
BeginPrompt="Do you want to install the 7-Zip 4.00?"
ExecuteFile="7zip.msi"
;!@InstallEnd@!
</PRE>

<BR>

<PRE class="example">
;!@Install@!UTF-8!
Title="7-Zip 4.01 Update"
BeginPrompt="Do you want to install the 7-Zip 4.01 Update?"
ExecuteFile="msiexec.exe"
ExecuteParameters="/i 7zip.msi REINSTALL=ALL REINSTALLMODE=vomus"
;!@InstallEnd@!
</PRE>

<H4>Examples</H4>

<PRE class="example">
7z a -sfx a.exe *.txt
</PRE>

<P>adds <SPAN class="filename">*.txt</SPAN> files to self extracting 
  archive  <SPAN class="filename">a.exe</SPAN> using the default console SFX module.</P>

<PRE class="example">
7z a -sfx7z.sfx a.exe *
</PRE>

<P>adds all files to self extracting archive <SPAN class="filename">a.exe</SPAN>
with module <SPAN class="filename">7z.sfx</SPAN> using windows version of SFX mudule.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-ssw (Compress files open for writing) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-ssw (Compress files open for writing) switch</H1>

<P>Compresses files open for writing by another applications. If this switch is not 
set, 7-zip doesn't include such files to archive.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-ssw
</PRE>

<H4>Example</H4>

<PRE class="example">
7z a archive.7z -ssw *.txt
</PRE>

<P>compresses all <SPAN class="filename">*.txt</SPAN> files in 
current folder including files open for writing by another applications.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/hash.htm">h (Hash)</A>,
  <A href="../commands/update.htm">u (Update)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-sni (Store NT security information) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-sni (Store NT security information) switch</H1>

<H4>Syntax</H4>

<PRE class="syntax">
-sni
</PRE>

<P> Use this switch to store and restore NT (NTFS) security information for files and directories.
Note that only NTFS file system supports that feature.</P>

<P> Current version of 7-Zip can store NT security information only to WIM archives.</P>

<H4>Examples</H4>

<PRE class="example">
7z a a.wim -sni *.txt
</PRE>

<P>stores <SPAN class="filename">txt</SPAN> files with NT security information.</P>

                  
<PRE class="example">
7z x a.wim -sni
</PRE>
<P>unpacks <SPAN class="filename">a.wim</SPAN> and restores NT security information.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
    <A href="sns.htm">-sns</A>
</P>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-sns (Store NTFS alternate Streams) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-sns (Store NTFS alternate Streams) switch</H1>

<H4>Syntax</H4>

<PRE class="syntax">
-sns[-]
</PRE>

<TABLE>
  <TR><TH width="80">Switch</TH> <TH>Description</TH></TR>
  <TR><TD> -sns  </TD> <TD> Enable "Store NTFS alternate streams" mode. It's default option, if you extract archive.</TD></TR>
  <TR><TD> -sns- </TD> <TD> Disable "Store NTFS alternate streams" mode. It's default option, if you create archive or 
    call "list" command. </TD></TR>
</TABLE>


<P> If -sns mode is enabled, 7-Zip processes NTFS Alternate Data Streams for files and folders.</P>

<P> Current version of 7-Zip can store NTFS alternate streams only to WIM archives.</P>

<P> Note: 7-Zip can't include alternate streams to archives on 32-bit Windows XP and older systems.</P>

<H4>Examples</H4>

<PRE class="example">
7z a a.wim -sns *.txt
</PRE>
<P>stores <SPAN class="filename">txt</SPAN> files including alternate data streams.</P>

<PRE class="example">
7z x a.wim
</PRE>
<P>unpacks <SPAN class="filename">a.wim</SPAN> including alternate data streams.</P>

<PRE class="example">
7z x a.wim -sns-
</PRE>
<P>unpacks <SPAN class="filename">a.wim</SPAN> without alternate data streams.</P>

<PRE class="example">
7z l a.wim -sns
</PRE>
<P>lists files in <SPAN class="filename">a.wim</SPAN> including alternate data streams.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/hash.htm">h (Hash)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
    <A href="sni.htm">-sni</A>
</P>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-spf (Use fully qualified file paths) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-spf (Use fully qualified file paths) switch</H1>

<TABLE>
  <TR> <TH width="80">Switch</TH> <TH>Description</TH> </TR>
  <TR> <TD>-spf</TD> <TD>Use absolute paths including drive letter.</TD> </TR>
  <TR> <TD>-spf2</TD> <TD>Use full paths without drive letter.</TD> </TR>
</TABLE>

<P>Enables the mode that allows to use fully qualified file paths in archives.
If -spf switch is not specified, 7-Zip reduces file paths to relative paths when 
it adds files to archive, and 7-Zip converts paths to relative paths when 
you extract archive. 
If -spf switch is specified, 7-Zip doesn't try to process or convert paths.</P>

<P>Fully qualified file paths begin with one of the following:</P>
<UL>
<LI>A UNC name, which starts with two backslash characters, for example, "\\Server1\".
<LI>A disk designator with a backslash, for example "C:\".
<LI>A single backslash, for example, "\Folder".
</UL>

<P>If -spf switch is specified, but the path is not fully qualified, 7-Zip will use specified path, 
it will not convert the path to fully qualified path.</P>


<P>Please be careful, if you use -spf switch with "extract" command. 
Check that file names in archive are correct. Note that with -spf switch 
7-Zip can try to rewrite any file with path specified in archive.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-spf
</PRE>

<H4>Examples</H4>

<PRE class="example">
7z a a.7z -spf c:\Files\test.txt d:\test.txt
</PRE>

<P>stores both <SPAN class="filename">txt</SPAN> files with full paths.</P>

<PRE class="example">
7z x a.7z -spf
</PRE>

<P>extracts files from <SPAN class="filename">a.7z</SPAN> archive with exact 
file paths specified in archive.</P>


<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
</P>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-ssc (Set Sensitive Case mode) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-ssc (Set Sensitive Case mode) switch</H1>

<P>Sets sensitive case mode for file names.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-scs[-]
</PRE>

<TABLE>
  <TR><TH width="80">Switch</TH> <TH>Description</TH></TR>
  <TR><TD>-ssc</TD> <TD>Set case-sensitive mode. It's default for Posix/Linux systems.</TD></TR>
  <TR><TD>-ssc-</TD> <TD>Set case-insensitive mode. It's default for Windows systems.</TD></TR>
</TABLE>

<H4>Example</H4>

<PRE class="example">
7z a archive.7z A*.txt -ssc -r
</PRE>

<P>compresses all <SPAN class="filename">A*.txt</SPAN> files
  from current directory and all it's subdirectories. That command doesn't compress
  <SPAN class="filename">a*.txt</SPAN> files.

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-si (read data from stdin) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-si (read data from stdin) switch</H1>

<P>Causes 7-Zip to read data from stdin (standard input) instead of from disc files.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-si{file_name}
</PRE>

<DL>
  <DT>{file_name}</DT>
  <DD>Specifies a name that will be stored in the archive for the compressed data.
    If file_name is not specified, data will be stored without a name.</DD>
</DL>

<P>Note: The current version of 7-Zip support reading of archives from stdin only for xz, lzma, tar, gzip and bzip2 archives.</P>

<H4>Examples</H4>

<PRE class="example">
7z a archive.gz -tgzip -siDoc2.txt < Doc.txt
</PRE>

<P>compresses input stream from file Doc.txt to 
<SPAN class="filename">archive.gz</SPAN> archive
using <SPAN class="filename">Doc2.txt</SPAN> file name.</P>

<PRE class="example">
7z x 7z905.tar.gz -so | 7z x -si -ttar
</PRE>

<P>decompresses <SPAN class="filename">tar.gz</SPAN> archive.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/hash.htm">h (Hash)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-so (write data to stdout) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-so (write data to stdout) switch</H1>

<P>Causes 7-Zip to write output data to stdout (standard output stream).</P> 

<H4>Syntax</H4>

<PRE class="syntax">
-so
</PRE>

<P>If the -so switch is used with the command that creates archive, it works only 
with some archive formats: xz, gzip, bzip2 and tar.</P>


<H4>Examples</H4>

<PRE class="example">
7z x archive.gz -so > Doc.txt
</PRE>

<P>decompresses <SPAN class="filename">archive.gz</SPAN> 
archive to output stream and then redirects that stream to
<SPAN class="filename">Doc.txt</SPAN> file.</P>


<PRE class="example">
7z a dummy -tgzip -so Doc.txt > archive.gz
</PRE>

<P>compresses the <SPAN class="filename">Doc.txt</SPAN> file to the 7-Zip standard
output stream and writes that stream to 
<SPAN class="filename">archive.gz</SPAN> file.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-stl (Set archive timestamp from the most recently modified file) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-stl (Set archive timestamp from the most recently modified file) switch</H1>

<H4>Syntax</H4>

<PRE class="syntax">
-stl
</PRE>

<P> If -stl switch is specified, 7-Zip sets timestamp for archive file as 
timestamp from the most recently modified file in that archive.</P>

<H4>Examples</H4>

<PRE class="example">
7z u a.7z -stl *.txt
</PRE>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/rename.htm">rn (Rename)</A>,
  <A href="../commands/update.htm">u (Update)</A>
</P>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-- (Stop switches parsing) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-- (Stop switches parsing) switch</H1>

<P>Disables switch parsing after "--" on the command line.
This is to allow 7-Zip to use file names that start with "-".

<H4>Syntax</H4>

<PRE class="syntax">
--
</PRE>

<H4>Examples</H4>

<PRE class="example">
7z t -- -ArchiveName.7z
</PRE>

<P>tests <SPAN class="filename">-ArchiveName.7z</SPAN> archive.</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-stx (Exclude archive type) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-stx (Exclude archive type) switch</H1>

<P>The switch disables the code related to specified archive type and 
   an archive can not be open with specified archive type.</P>
<P>Multiple -stx switches are supported.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-stx{archive_type}
</PRE>

<DL>
  <DT>{archive_type}</DT>
    <DD> Specifies the type of archive. It can be: 7z, xz, split, zip, gzip, bzip2, tar, ....
    </DD>
</DL>

<H4>Example</H4>

<PRE class="example">
7z x -stxpe archive.exe
</PRE>

<P>extracts files from <SPAN class="filename">archive.exe</SPAN> archive and doesn't use PE format handler.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-t (set Type of archive) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-t (set Type of archive) switch</H1>

<P>Specifies the type of archive.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-t{archive_type}[:s{Size}][:r][:e][:a]
</PRE>

<DL>
  <DT>{archive_type}</DT>
    <DD> Specifies the type of archive. It can be: *, #, 7z, xz, split, zip, gzip, bzip2, tar, ....
    </DD>

  <DT>*:r</DT>
    <DD> Default mode. 7-Zip opens archive and subfile, if it's supported by format.
    </DD>

  <DT>*</DT>
    <DD> Opens only one top level archive.
    </DD>

  <DT>*:s{Size}[b | k | m | g]</DT>
    <DD>Sets upper limit for start of archive position.
        Default scan size is 8 MBytes "*:s8m".
        Example: "*:s0" means that it will open only file that has no any stub before archive.
    </DD>

  <DT>#</DT>
    <DD> Opens file in Parser mode, and ignores full archives.
    </DD>

  <DT>#:a</DT>
    <DD> Same as *, but it opens files with unknown extensions that contain archives in Parser Mode.
    </DD>

  <DT>#:e</DT>
    <DD> Opens file in Parser mode and checks all byte positions as start of archive.
    </DD>
</DL>

<P>If -t{archive_type} switch is not specified, 7-Zip uses extension of archive filename to 
  detect the type of archive. If you create new archive, -t{archive_type} switch is not 
  specified and there is no extension of archive, 7-Zip will create .7z archive.</P>

<P>If -t{archive_type} switch is not specified and archive name contains incorrect extension,
the program will show the warning.</P>

<P>It's possible to use the combined type (for example, mbr.vhd) for "Extract" and "List" 
commands for some archives.</P>
                             
<P>When you extract archive of some types that contains another 
archive without compression (for example, MBR in VHD), 7-Zip can open both 
levels in one step. If you want to open/extract just top 
level archive, use <SPAN class="filename">-t*</SPAN> switch.</P>

<P>Note: xz, gzip and bzip2 formats support only one file per archive.
If you want to compress more than one file to these formats,
create a tar archive at first, and then compress it with your selected format.</P>

<H4>Example</H4>

<PRE class="example">
7z a -tzip archive.zip *.txt
</PRE>

<P>adds all <SPAN class="filename">*.txt</SPAN> files from current directory 
to zip archive <SPAN class="filename">archive.zip</SPAN>.</P>

<PRE class="example">
7z t -t7z.split archive.7z.001
</PRE>

<P>tests all files in <SPAN class="filename">archive.7z.001</SPAN>. It also checks
that archive is multivolume .7z archive.</P>

<PRE class="example">
7z x -t# sfxarchive.exe
</PRE>

<P>extracts <SPAN class="filename">sfxarchive.exe </SPAN> in parser mode.</P>


<PRE class="example">
7z x -tiso archive.iso
</PRE>

<P>extracts files from <SPAN class="filename">archive.iso</SPAN> open as ISO archive.

<PRE class="example">
7z x -tudf archive.iso
</PRE>

<P>extracts files from <SPAN class="filename">archive.iso</SPAN> open as UDF archive.


<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/list.htm">l (List)</A>,
  <A href="../commands/test.htm">t (Test)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-u (Update options) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-u (Update options) switch</H1>

<P>Specifies how to update files in an archive and (or) how to create new archives.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-u<A class="parameter" href="#disable_base_archive">[-]</A>&lt;action_set><A class="parameter" href="#new_archive_name">[!{new_archive_name}]</A>

  &lt;action_set> ::= &lt;state_action>...

    &lt;state_action> ::= <A class="parameter" href="#state">&lt;state></A><A class="parameter" href="#state">&lt;action></A>

      <A class="parameter" href="#action">&lt;state></A> ::= p | q | r | x | y | z | w

      <A class="parameter" href="#action">&lt;action></A> ::= 0 | 1 | 2 | 3
</PRE>


<H4>Parameters</H4>

<DL>
  <DT><A name="disable_base_archive"></A>dash (-)</DT>
  <DD><P>Disables any updates in the base archive.</P>

      <P>The term <B>base archive</B> means the archive assigned by "base_archive_name"
      on the command line. See <A href="../syntax.htm">Command line syntax</A>
      for more details.</P>
  </DD>
  <DT><A name="new_archive_name"></A>{new_archive_name}</DT>
  <DD><P>Specifies the path name of the new archive to be created.
    All options in this switch will refer to this new archive.</P>
    <P>If not assigned, then all options in this switch will
                  refer to the base archive of the command.</P>
  </DD>
  <DT><A name="state"></A>&lt;state></DT>
  <DD><P>Specifies the state of a particular file to be processed.</P>
    <PRE class="syntax">&lt;state> ::= p | q | r | x | y | z | w</PRE>
    <P>For each unique filename there are 6 variants of state:</P>
    <TABLE>
      <TR> <TH>&lt;state></TH> <TH>State condition</TH>
           <TH width="20%">File on Disk</TH> <TH width="20%">File in Archive</TH> </TR>

      <TR> <TD align="center">p</TD> <TD>File exists in archive, but is not matched with wildcard.</TD>
           <TD>&nbsp;</TD> <TD>Exists, but is not matched</TD> </TR>

      <TR> <TD align="center">q</TD> <TD>File exists in archive, but doesn't exist on disk.</TD>
           <TD>Doesn't exist</TD> <TD>Exists</TD> </TR>

      <TR> <TD align="center">r</TD> <TD>File doesn't exist in archive, but exists  on disk.</TD>
           <TD>Exists</TD> <TD>Doesn't exist</TD> </TR>

      <TR> <TD align="center">x</TD> <TD>File in archive is newer than the file on disk.</TD>
           <TD>Older</TD> <TD>Newer</TD> </TR>

      <TR> <TD align="center">y</TD> <TD>File in archive is older than the file on disk.</TD>
           <TD>Newer</TD> <TD>Older</TD> </TR>

      <TR> <TD align="center">z</TD> <TD>File in archive is same as the file on disk</TD>
           <TD>Same</TD> <TD>Same</TD> </TR>

      <TR> <TD align="center">w</TD> <TD>Can not be detected what file is newer  
              (times are the same, sizes are different)</TD>
           <TD>?</TD> <TD>?</TD> </TR>
    </TABLE>
  </DD>

  <DT><A name="action"></A>&lt;action></DT>
  <DD><P>Specifies the action for a given <A class="parameter" href="#state">&lt;state></A>.</P>
    <PRE class="syntax">&lt;action> ::= 0 | 1 | 2 | 3</PRE>
    <P>For each state you can specify one of the three variants of actions:</P>
    <TABLE>
      <TR> <TH>&lt;action></TH> <TH>Description</TH></TR>
      <TR> <TD align="center">0</TD> <TD>Ignore file (don't create item in new archive for this file)</TD></TR>
      <TR> <TD align="center">1</TD> <TD>Copy file (copy from old archive to new)</TD></TR>
      <TR> <TD align="center">2</TD> <TD>Compress (compress file from disk to new archive)</TD></TR>
      <TR> <TD align="center">3</TD> <TD>Create Anti-item (item that will delete file or directory during extracting). This feature is supported only in 7z format.</TD></TR>
    </TABLE>
  </DD>
</DL>


<H4>Remarks</H4>

<P>Any update command (such as <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/update.htm">u (Update)</A>) can be assigned in these terms.</P>
<P>The following table shows action sets for update commands.</P>

<TABLE>
  <TR> <TH>command \ <A class="parameter" href="#state">&lt;state></A></TH>
              <TH>p</TH> <TH>q</TH> <TH>r</TH> <TH>x</TH> <TH>y</TH> <TH>z</TH> <TH>w</TH></TR>
  <TR> <TH><A href="../commands/delete.htm">d (Delete)</A></TH> <TD>1</TD> <TD>0</TD> <TD>0</TD> <TD>0</TD> <TD>0</TD> <TD>0</TD> <TD>0</TD></TR>
  <TR> <TH><A href="../commands/add.htm">a (Add)</A></TH> <TD>1</TD> <TD>1</TD> <TD>2</TD> <TD>2</TD> <TD>2</TD> <TD>2</TD>  <TD>2</TD></TR>
  <TR> <TH><A href="../commands/update.htm">u (Update)</A></TH> <TD>1</TD> <TD>1</TD> <TD>2</TD> <TD>1</TD> <TD>2</TD> <TD>1</TD> <TD>2</TD></TR>
  <TR> <TH>Freshen</TH> <TD>1</TD> <TD>1</TD> <TD>0</TD> <TD>1</TD> <TD>2</TD> <TD>1</TD> <TD>2</TD></TR>
  <TR> <TH>Synchronize</TH> <TD>1</TD> <TD>0</TD> <TD>2</TD> <TD>1</TD> <TD>2</TD> <TD>1</TD> <TD>2</TD></TR>
</TABLE>


<P>If you don't specify a
<A class="parameter" href="#new_archive_name"><I>!{new_archive_name}</I></A> option, then
all options will refer to the main archive (the archive assigned on the command line after the 7z command).
If you specify <A class="parameter" href="#new_archive_name"><I>!{new_archive_name}</I></A>
option, then 7-Zip also will create a new archive with the specified name and all options
will refer to that new archive.</P>

<P>Multiple update switches are supported.
7-Zip can create any number of new archives during one operation.</P>

<P>By default, the action set for each new archive is assigned
as the action set of the main command. There are 3 different
action sets for commands: <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/update.htm">u (Update)</A>.
You can overload any &lt;state_action> pair.</P>

<H4>Time zone notes</H4>
<P>If you change time zone (when you move your computer to another time zone 
or if there are clock changes for daylight saving in your zone), you can have some problems 
with update commands that depend from file's modification time. It's strongly recommended to use only 
file system that uses Coordinated Universal Time (UTC) and archive format that also uses UTC. 
In that case you will have no problems with time zone changes.
Also it's recommended to use only UTC formats in other cases, for example, if you send files to 
someone in another time zone.</P>

<P>Also in some cases there are no problems, if both file system and archive format use local time, for example, FAT file system and ZIP format.</P> 
<UL>
<LI>UTC file systems: NTFS
<LI>UTC archive formats: .zip with -mtc switch, 7z, tar, gzip2, iso, wim
<LI>Local time file systems : FAT, FAT32
<LI>Local time archive formats : rar, zip, cab
</UL>

<H4>Examples</H4>

<PRE class="example">
7z u c:\1\exist.7z -u- -up0q3x2z0!c:\1\update.7z *
</PRE>

<P>creates a new archive <SPAN class="filename">update.7z</SPAN> and
writes to this archive all files from current directory which differ from
files in <SPAN class="filename">exist.7z</SPAN> archive.
<SPAN class="filename">exist.7z</SPAN> archive will not be changed.</P>

<PRE class="example">
7z u c:\1\exist.7z -up0q3x2z0!c:\1\update.7z * -ms=off
</PRE>

<P>creates a new archive <SPAN class="filename">update.7z</SPAN> and
writes to this archive all files from the current directory which differ from
files in <SPAN class="filename">exist.7z</SPAN> archive.

<P>Note: the updating of solid .7z archives can be slow, since it 
can require some recompression.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/rename.htm">rn (Rename)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-v (Create Volumes) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-v (Create Volumes) switch</H1>

<P>Specifies volume sizes.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-v{Size}[b | k | m | g]

</PRE>
<DL>
  <DT>{Size}[b | k | m | g]</DT>
  <DD>Specifies volume size in Bytes, Kilobytes (1 Kilobyte = 1024 bytes),
  Megabytes (1 Megabyte = 1024 Kilobytes) or Gigabytes (1 Gigabyte = 1024 Megabytes).
  if you specify only {Size}, 7-zip will treat it as bytes.</DD>
</DL>

<P>It's possible to specify several -v switches.</P>

<P><B>NOTE:</B> Please don't use volumes (and don't copy volumes) before finishing archiving. 
7-Zip can change any volume (including first volume) at the end of archiving operation.</P>

<H4>Examples</H4>

<PRE class="example">
7z a a.7z *.txt -v10k -v15k -v2m
</PRE>

<P>creates multivolume <SPAN class="filename">a.7z</SPAN> archive.
First volume will be 10 KB, second will be 15 KB, and all others will be 2 MB.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-w (set Working directory) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-w (set Working directory) switch</H1>

<P>Sets the working directory for the temporary base archive. By
default, 7-Zip builds a new base archive file in the same directory as the
old base archive file. By specifying this switch, you can set the
working directory where the temporary base archive file will be built.
After the temporary base archive file is built, it is copied over the
original archive; then, the temporary file is deleted.</P>

<H4>Syntax</H4>

<PRE class="syntax">
-w[<A class="parameter" href="#dir_path">{dir_path}</A>]
</PRE>

<DL>
  <DT><A name="dir_path"></A>{dir_path}</DT>
  <DD>
    <P>Specifies the destination directory path. It's not required that
      a path end with a backslash.</P>
    <P>If &lt;dir_path> is not assigned, then 7-Zip will use the Windows temporary directory.</P>
  </DD>
</DL>


<H4>Example</H4>

<PRE class="example">
7z a -tzip archive.zip *.cpp -wc:\temp
</PRE>

<P>adds <SPAN class="filename">*.cpp</SPAN> files to the
<SPAN class="filename">archive.zip</SPAN> archive, creating a temporary archive
in <SPAN class="filename">c:\temp</SPAN> folder.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/add.htm">a (Add)</A>,
  <A href="../commands/delete.htm">d (Delete)</A>,
  <A href="../commands/rename.htm">rn (Rename)</A>,
  <A href="../commands/update.htm">u (Update)</A>,
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>-y (assume Yes on all queries) switch</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>-y (assume Yes on all queries) switch</H1>

<P>Disables most of the normal user queries during 7-Zip
execution. You can use this switch to suppress overwrite queries in the
<A href="../commands/extract.htm">e (Extract)</A> and
<A href="../commands/extract_full.htm">x (Extract with full paths)</A> commands.</P>

<H4>Syntax</H4>

<PRE class="syntax">-y</PRE>

<H4>Examples</H4>

<PRE class="example">
7z x src.zip -y
</PRE>

<P>extracts all files from
  <SPAN class="filename">src.zip</SPAN> archive. All overwrite queries will be
suppressed and files on disk with same filenames as in archive will be
overwritten.</P>

<H4>Commands that can be used with this switch</H4>

<P>
  <A href="../commands/extract.htm">e (Extract)</A>,
  <A href="../commands/extract_full.htm">x (Extract with full paths)</A>
</P>

<H4>See also</H4>

<P>
  <B>Switches:</B>
  <A href="overwrite.htm">-ao (Overwrite mode)</A>,
</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>About Dialog Box</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>About Dialog Box</H1>

<P>The About dialog box provides information about 7-Zip. This dialog box is available 
from the Help menu.</P>

<UL>
<LI>Press <B>www.7-zip.org</B> button for opening 7-Zip Home Page.</LI>
</UL>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Benchmark</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Benchmark</H1>

<P>This form allows you to measure the performance of your computer.</P>

<P>There are two tests:<P>
<OL>
  <LI>Compression with LZMA method
  <LI>Decompression with LZMA method
</OL>

<P>The benchmark shows a rating in MIPS (million instructions per second).
The rating value is calculated from the measured speed, and it
is normalized with results of Intel Core 2 CPU with multi-threading option switched off. 
So if you have modern CPU from Intel or AMD, rating values in single-thread mode 
must be close to real CPU frequency.</P>

<P>You can change the dictionary size to increase memory usage.
Also you can change the number of threads.</P>

<P>The <B>CPU Usage</B> column shows the percentage of time the processor is working.
It's normalized for a one-thread load. For example, 180% CPU Usage for 2 threads
can mean that average CPU usage is about 90% for each thread.</P>

<P>The <B>Rating / Usage</B> column shows rating normalized for 100% of CPU usage.
That column shows performance of the one CPU thread. It must be close to real CPU frequency,
if you have modern CPU.</P>

<P>The <B>Total rating</B> shows averages of the compressing and decompression ratings.</P>


<P>Compression speed and rating strongly depend from memory (RAM) latency.

<P>Decompression speed and rating strongly depend on CPU integer operations.
For example, an Intel Pentium 4 has big branch
misprediction penalty (which is effect of long pipeline) and pretty slow
multiply and shift operations. So, the  Pentium 4 has pretty low decompressing
ratings.</P>


<P>Also the program checks possible errors. 
If the program shows some error message, in most cases it means that 
your RAM is defective. If so, don't use 7-Zip for
compressing data, since such errors can lead to data losses.</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>7-Zip File Manager</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>7-Zip File Manager</H1>

<P>The 7-Zip File Manager is a program for manipulating files and folders.</P>

<P>The 7-Zip File Manager can work with two panels. You can switch between
panels by pressing the Tab button. Most of the operations can be
executed using keyboard shortcuts or by right-clicking on items 
and selecting the appropriate command from menu.</P>


<H4>In This Section</H4>

<DL>
  <DT><A href = "menu.htm">Menu Items and Shortcut Keys</A></DT>
    <DD>Describes the menu items and  keyboard shortcut.</DD>
  <DT><A href = "options.htm">Options Dialog Box</A></DT>
    <DD>Describes what settings you can change that affect the 7-Zip File Manager.</DD>
  <DT><A href = "benchmark.htm">Benchmark</A></DT>
    <DD>Describes a 7-Zip Benchmark for measuring CPU performance.</DD>
  <DT><A href = "about.htm">About Dialog Box</A></DT>
    <DD>Provides information about 7-Zip.</DD>
  <DT><A href = "plugins/index.htm">Plugins</A></DT>
    <DD>Describes plugins for the 7-Zip File Manager.</DD>
</DL>

<HR>
<P>You have access to the following items from root folder in 7-Zip File Manager:</P>
<UL>
  <LI><B>Computer</B>: computer's disks
  <LI><B>Documents</B>: My Documents folder of current user
  <LI><B>Network</B>
  <LI><B>\\.</B> : the folder for low-level access to disks. 
  You must have administrator's rights to use that folder. 
  You can 
  <UL>
    <LI>copy .iso images from CD/DVD to file. 
    <LI>view NTFS/FAT partitions via 7-Zip parser. It provides read-only access to files.
  </UL>
</UL>
</P>


</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Menu Items and Shortcut Keys</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H2>Menu Items</H2>

<P>Note: 'Grey' refers to the numeric keypad.</P>

<H3>File</H3>
<TABLE>
  <TR> <TH>Menu item</TH> <TH>Shortcut</TH>  <TH>Description</TH> </TR>
  <TR> <TD>System</TD> <TD></TD> <TD>Submenu with menu commands from system shell. It can be enabled in Options.</TD> </TR>
  <TR> <TD>Open</TD> <TD>Enter</TD> <TD>Open current item</TD> </TR>
  <TR> <TD>Open Inside</TD> <TD>Ctrl+PgDn</TD> <TD>Open current item as folder inside 7-Zip</TD> </TR>
  <TR> <TD>Open Outside</TD> <TD>Shift+Enter</TD> <TD>Open current item in new window</TD> </TR>
  <TR> <TD>View</TD> <TD>F3</TD> <TD>Open selected item with viewer</TD> </TR>
  <TR> <TD>Edit</TD> <TD>F4</TD> <TD>Open selected item with editor</TD> </TR>
  <TR> <TD>Rename</TD> <TD>F2</TD> <TD>Rename selected item</TD> </TR>
  <TR> <TD>Copy To...</TD> <TD>F5</TD> <TD>Copy selected items</TD> </TR>
  <TR> <TD>Move To...</TD> <TD>F6</TD> <TD>Move selected items</TD> </TR>
  <TR> <TD>Delete</TD> <TD>Delete</TD> <TD>Delete selected items</TD> </TR>
  <TR> <TD>Split file...</TD> <TD></TD> <TD>Split file to parts</TD> </TR>
  <TR> <TD>Combine files...</TD> <TD></TD> <TD>Combine files to one file</TD> </TR>
  <TR> <TD>Properties</TD> <TD>Alt+Enter</TD> <TD>Show Properties of file</TD> </TR>
  <TR> <TD>Comment</TD> <TD>Ctrl+Z</TD> <TD>Set comment for file</TD> </TR>
  <TR> <TD>Calculate checksum</TD> <TD></TD> <TD>Calculates CRC checksum for files</TD> </TR>
  <TR> <TD>Diff</TD> <TD></TD> <TD>Show the differences between two files. It can be enabled, if the diff program is set in Options</TD> </TR>
  <TR> <TD>Create Folder</TD> <TD>F7</TD> <TD>Create new folder</TD> </TR>
  <TR> <TD>Create File</TD> <TD>Shift+F4</TD> <TD>Creates new file</TD> </TR>
  <TR> <TD>Link...</TD> <TD></TD> <TD>Create symbolic link or hard link</TD> </TR>
  <TR> <TD>Alternate Streams</TD> <TD></TD> <TD>Show alternate file streams at NTFS.</TD> </TR>
  <TR> <TD>Exit</TD> <TD>Alt+F4</TD> <TD>Closes the program.</TD> </TR>
</TABLE>

<H3>Edit</H3>
<TABLE>
  <TR> <TH>Menu Item</TH> <TH>Shortcut</TH>  <TH>Description</TH> </TR>
  <TR> <TD>Select All</TD> <TD>Shift+[Grey +]</TD> <TD>Select all items</TD> </TR>
  <TR> <TD>Deselect All</TD> <TD>Shift+[Grey -]</TD> <TD>Select all items</TD> </TR>
  <TR> <TD>Invert Selection</TD> <TD>[Grey *]</TD> <TD>Select / Deselect all items</TD> </TR>
  <TR> <TD>Select...</TD> <TD>[Grey +]</TD> <TD>Select specified items</TD> </TR>
  <TR> <TD>Deselect...</TD> <TD>[Grey -]</TD> <TD>Deselect specified items</TD> </TR>
  <TR> <TD>Select by Type</TD> <TD>Alt+[Grey +]</TD> <TD>Select all items with the same extension as current item</TD> </TR>
  <TR> <TD>Deselect by Type</TD> <TD>Alt+[Grey -]</TD> <TD>Deselect all items with the same extension as current item</TD> </TR>
</TABLE>

<H3>View</H3>
<TABLE>
  <TR> <TH>Menu Item</TH> <TH>Shortcut</TH>  <TH>Description</TH> </TR>
  <TR> <TD>Large Icons</TD><TD>Ctrl+1</TD> <TD>Displays items by using large icons</TD> </TR>
  <TR> <TD>Small Icons</TD><TD>Ctrl+2</TD> <TD>Displays items by using small icons</TD> </TR>
  <TR> <TD>List</TD> <TD>Ctrl+3</TD><TD>Displays items in a list</TD> </TR>
  <TR> <TD>Details</TD> <TD>Ctrl+4</TD><TD>Displays items in a list with detailed information about each item</TD> </TR>

  <TR> <TD>Name</TD> <TD>Ctrl+F3</TD> <TD>Sort items by Name</TD> </TR>
  <TR> <TD>Type</TD> <TD>Ctrl+F4</TD> <TD>Sort items by Type</TD> </TR>
  <TR> <TD>Date</TD> <TD>Ctrl+F5</TD> <TD>Sort items by Date</TD> </TR>
  <TR> <TD>Size</TD> <TD>Ctrl+F6</TD> <TD>Sort items by Size</TD> </TR>
  <TR> <TD>Unsorted</TD> <TD>Ctrl+F7</TD> <TD>Do not sort items</TD> </TR>

  <TR> <TD>Flat View</TD> <TD></TD> <TD>Switch Flat view mode for list of files</TD> </TR>
  <TR> <TD>2 Panels</TD> <TD>F9</TD> <TD>Switch On/Off second panel</TD> </TR>
  <TR> <TD>Toolbars</TD> <TD></TD> <TD>Menu items for toolbars handling</TD> </TR>

  <TR> <TD>Open Root Folder</TD>  <TD>\</TD> <TD>Open root computer folder</TD> </TR>
  <TR> <TD>Up One Level</TD> <TD>Backspace</TD> <TD>Open the folder one level up</TD> </TR>
  <TR> <TD>Folders History...</TD> <TD>Alt+F12</TD> <TD>Open folders history</TD> </TR>
  <TR> <TD>Refresh</TD> <TD>Ctrl+R</TD> <TD>Refresh items list</TD> </TR>
  <TR> <TD>Auto Refresh</TD> <TD></TD> <TD>If "Auto Refresh" is enabled, 7-Zip reloads list of files, if there are changes in files on drive.</TD> </TR>
</TABLE>

<H3>Favorites</H3>
<TABLE>
  <TR> <TH>Menu Item</TH> <TH>Shortcut</TH>  <TH>Description</TH> </TR>
  <TR> <TD>Add folder to Favorites as</TD> <TD></TD> <TD>Adds folder to favorities</TD> </TR>
</TABLE>

<H3>Tools</H3>
<TABLE>
  <TR> <TH>Menu Item</TH> <TH>Shortcut</TH>  <TH>Description</TH> </TR>
  <TR> <TD>Options...</TD> <TD></TD> <TD>Open Options dialog box</TD> </TR>
  <TR> <TD>Benchmark</TD> <TD></TD> <TD>Measure the performance of your computer with 7-Zip LZMA benchmark</TD> </TR>
</TABLE>


<H3>Help</H3>
<TABLE>
  <TR> <TH>Menu Item</TH> <TH>Shortcut</TH>  <TH>Description</TH> </TR>
  <TR> <TD>Contents...</TD> <TD>F1</TD> <TD>Opens 7-Zip Help</TD> </TR>
  <TR> <TD>About 7-Zip...</TD> <TD></TD> <TD>Opens About dialog box</TD> </TR>
</TABLE>


<H2>Miscellaneous commands</H2>
<TABLE>
  <TR> <TH>Shortcut</TH>  <TH>Description</TH> </TR>
  <TR> <TD>Tab</TD> <TD>Switch between panels</TD> </TR>
  <TR> <TD>Insert</TD> <TD>Select / Deselect current item</TD> </TR>
  <TR> <TD>Shift+F10</TD> <TD>Display the shortcut menu for the selected items</TD> </TR>
  <TR> <TD>RightCtrl+0<BR>Alt+0<BR>...<BR>RightCtrl+9<BR>Alt+9</TD> <TD>Open folder bookmark</TD> </TR>
  <TR> <TD>Shift+RightCtrl+0<BR>Shift+Alt+0<BR>...<BR>Shift+RightCtrl+9<BR>Shift+Alt+9</TD> <TD>Creates folder bookmark</TD> </TR>
  <TR> <TD>Alt+F1</TD> <TD>Edit the Folder Address on left panel</TD> </TR>
  <TR> <TD>Alt+F2</TD> <TD>Edit the Folder Address on right panel</TD> </TR>
  <TR> <TD>Alt+Up</TD> <TD>Open same folder in other panel</TD> </TR>
  <TR> <TD>Alt+Left,<BR>Alt+Right</TD> <TD>Open current folder in other panel</TD> </TR>
  <TR> <TD>Ctrl+[Grey +]</TD> <TD>Adjust optimal column width for items</TD> </TR>
  <TR> <TD>Ctrl+C</TD> <TD>Copy the name of selected file to clipboard</TD> </TR>
</TABLE>

<H2>Keyboard Shortcuts</H2>

<TABLE>
  <TR> <TH>Key</TH>  <TH>Normal</TH> <TH>Ctrl</TH> <TH>Alt</TH> <TH>Shift</TH> </TR>
  <TR> <TH>Tab</TH> <TD>Switch panel</TD> <TD></TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>F1</TH> <TD>Help</TD> <TD></TD> <TD>Left Path</TD> <TD></TD> </TR>
  <TR> <TH>F2</TH> <TD>Rename</TD> <TD></TD>  <TD>Right Path</TD> <TD></TD> </TR>
  <TR> <TH>F3</TH> <TD>View</TD> <TD>Sort by Name</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>F4</TH> <TD>Edit</TD> <TD>Sort by Type</TD> <TD>Exit</TD> <TD>Create File</TD> </TR>
  <TR> <TH>F5</TH> <TD>Copy</TD> <TD>Sort by Date</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>F6</TH> <TD>Move</TD> <TD>Sort by Size</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>F7</TH> <TD>Create Folder</TD> <TD>Unsorted</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>F9</TH> <TD>1/2 Panels</TD> <TD></TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>F10</TH> <TD>Menu</TD> <TD></TD> <TD></TD> <TD>Shortcut Menu</TD> </TR>
  <TR> <TH>F12</TH> <TD></TD> <TD></TD> <TD>Folders History</TD> <TD></TD> </TR>
  <TR> <TH>0-9</TH> <TD></TD> <TD>R: Folder Bookmark</TD><TD>Folder Bookmark</TD> <TD></TD> </TR>
  <TR> <TH>A</TH> <TD></TD> <TD>Select All</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>C</TH> <TD></TD> <TD>Copy to clipboard</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>N</TH> <TD></TD> <TD>Create File</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>R</TH> <TD></TD> <TD>Refresh</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Z</TH> <TD></TD> <TD>Comment</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Backspace</TH> <TD>Up One Level</TD> <TD></TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Enter</TH> <TD>Open</TD> <TD></TD> <TD>Properties</TD> <TD>Open outside</TD> </TR>
  <TR> <TH>Insert</TH> <TD>Select Item</TD> <TD></TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Delete</TH> <TD>Delete Item</TD> <TD></TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Page Down</TH> <TD></TD> <TD>Open Inside</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Page Up</TH> <TD></TD> <TD>Up One Level</TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Up</TH> <TD></TD> <TD></TD> <TD>Open same folder</TD> <TD></TD> </TR>
  <TR> <TH>Left</TH> <TD></TD> <TD></TD> <TD>Open current folder</TD> <TD></TD> </TR>
  <TR> <TH>Right</TH> <TD></TD> <TD></TD> <TD>Open current folder</TD> <TD></TD> </TR>
  <TR> <TH>\</TH> <TD>Open root</TD> <TD></TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Grey /</TH> <TD>Open root</TD> <TD></TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Grey *</TH> <TD>Select All</TD> <TD></TD> <TD></TD> <TD></TD> </TR>
  <TR> <TH>Grey +</TH> <TD>Select</TD> <TD>Adjust columns</TD> <TD>Select by Type</TD> <TD>Select All</TD> </TR>
  <TR> <TH>Grey -</TH> <TD>Deselect</TD> <TD></TD> <TD>Deselect by Type</TD> <TD>Deselect All</TD> </TR>
</TABLE>

</BODY>
</HTML>
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Options Dialog Box</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Options Dialog Box</H1>


<P>You can change many of the settings that affect the 7-Zip File Manager 
in the Options dialog box. To access this dialog box select Options 
from the Tools menu.</P> 

<P>The options dialog box contains the following pages:</P>
<UL>
  <LI><A href = "#system">System  Page</A></LI>
  <LI><A href = "#sevenZip">7-Zip</A></LI>
  <LI><A href = "#folders">Folders Page</A></LI>
  <LI><A href = "#editor">Editor Page</A></LI>
  <LI><A href = "#settings">Settings Page</A></LI>
  <LI><A href = "#language">Language Page</A></LI>
</UL>

<H2><a name="system"></a>System  Page</H2>
<P>Allows you to specify the behavior of 7-Zip in the filing system.</P>
<DL>
  <DT>Associate 7-Zip with</DT>
    <DD>Allows to associate 7-Zip with file name extensions.
        There are two list of associations: for "Current User" and for "All Users".
        To set associations for "All Users" you must run 7-Zip File Manager 
        with administrator rights.
        Each association can have up to 4 states: 
    <UL>
      <LI>no association.
      <LI>AppName - the extension is associated with another program (not 7-Zip).
      <LI>[7-Zip] - the extension is associated with another copy (edition) of 7-Zip.
      <LI>7-Zip - the extension is associated with this copy of 7-Zip.
    </UL>

    <P> You can switch between these states by clicking on cell. Or you can change states 
        for all extension by clicking on "+" button.</P>
</DL>

<H2><a name="sevenZip"></a>7-Zip Page</H2>
<P>Allows you to specify behavior of 7-Zip in Windows Shell.</P>
<DL>
  <DT>Integrate 7-Zip to shell context menu</DT>
    <DD>Select this check box to add 7-Zip commands to Shell Context Menu. 
        There are two check boxes in 64-bit system. So it's possible to enable
        7-Zip context menu for 32-bit and 64-bit applications.</DD>
  <DT>Cascaded context menu</DT>
    <DD>Select this check box to group 7-Zip context menu items to one <B>7-Zip</B> submenu.</DD>
  <DT>Icons in context menu</DT>
    <DD>Select this check box to show 7-Zip icon in context menu items.</DD>
  <DT>Eliminate duplication of root folder</DT>
    <DD>That option allows to eliminate duplication of root folder for "Extract to" operations,
        if all files in archive are placed in folder with name that is identical to name of output folder.</DD>
  <DT>Context menu items</DT>
    <DD>Lists the optional context menu items. If an item is checked,
        7-Zip will add this item to the context menu.</DD>
</DL>


<H2><a name="folders"></a>Folders Page</H2>
<P>Allows you to set the folders which 7-Zip will use for internal purposes.</P>

<H3>Working folder</H3>

<P>The working folder section allows you to specify a folder which will be used
for temporary archive files:</P>

<DL>
  <DT>System temp folder</DT>
    <DD>7-Zip will use the Windows temp folder.</DD>
  <DT>Current</DT>
    <DD>7-Zip will use the folder containing the target archive.</DD>
  <DT>Specified</DT>
    <DD>7-Zip will use the folder specified in the following edit control.</DD>
</DL>

<DL>
  <DT>Use for removable drives only</DT>
    <DD> Specifies whether 7-Zip should use the specified folder settings
         only for removable drives;  for other drives, 7-Zip will create
         temporary archives in the folder containing the target archive.
         If you clear this check box, 7-Zip always will use the specified folder
         settings mode always.
    </DD>
</DL>

<P>7-Zip uses temporary archive files for all update operations. 
So, for speed reasons, it is recommended that you select the
<B>System temp folder</B> option and select 
<B>Use for removable drives only</B> check box.
</P>

<H2><a name="editor"></a>Editor Page</H2>
<P>Allows you to specify settings for the editor.</P>
<DL>
  <DT>View</DT>
    <DD>Specifies the path to the viewer that will be used for "View" command (F3).</DD>
  <DT>Editor</DT>
    <DD>Specifies the path to the editor that will be used for "Edit" command (F4).</DD>
  <DT>Diff</DT>
    <DD>Specifies the path to a file comparison utility that shows the 
       differences between two files.</DD>
</DL>

<H2><a name="settings"></a>Settings Page</H2>
<P>Allows you to specify some settings.</P>
<DL>
  <DT>Show .. item</DT>
    <DD>Shows .. item in file list.</DD>
  <DT>Show real file icons</DT>
    <DD>Shows real file icons in file list. If this option is enabled,
      listing updates can be slower.</DD>
  <DT>Full row select</DT>
    <DD>When an item is selected, the item and all its subitems are highlighted.</DD>
  <DT>Show grid lines</DT>
    <DD>Displays gridlines around items and subitems.</DD>
  <DT>Single-click to open an item</DT>
    <DD>If enabled, File Manager opens files and folders by single-clicking them.</DT>
  <DT>Alternative selection mode</DT>
    <DD>If enabled, File Manager keeps selection mark when you move cursor.</DD>

  <DT>Show system menu</DT>
    <DD>Shows a system context sub-menu in the File menu.</DD>

  <DT>Use large memory pages</DT>
    <DD>If enabled, 7-Zip will try to use large pages. This feature allows an increase in speed of compression.
      This may cause 7-Zip to pause when starting compression, because of allocation of the large pages.
      Also, the Windows Task Manager doesn't show the real memory usage of the program, if 7-Zip uses large pages.
      This feature works only on Windows 2003 / XP x64. 
      Also you must have administrator's rights for your system.
      Recommended size of RAM: 1 GB or more.
      To install this feature you must run 7-Zip File Manager at least once, 
      close it and reboot the system.</DD>
</DL>

<H2><a name="language"></a>Language Page</H2>
<P><P>Allows you to change the default language.</P>
<DL>
  <DT>Language</DT>
    <DD>Lists the available languages.</DD>
</DL>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Plugins</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Plugins</H1>

<P>The 7-Zip File Manager can use internal and external plugins.</P>

<P>Currently 7-Zip uses the following plugins:</P>
<DL>
  <DT><A href = "7-zip/index.htm">7-Zip</A></DT>
    <DD>Plugin for manipulating archives.</DD>
</DL>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Add to Archive Dialog Box</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Add to Archive Dialog Box</H1>

<P>Allows you to specify options for creating or updating an archive.</P>

<H4>How to call this dialog box</H4>
<OL>
  <LI>In Windows Explorer or in 7-Zip, right-click the file(s) or folder(s) you want to compress.</LI>
  <LI>Point to <B>7-Zip</B>, and then click the <B>Add to archive...</B> command item.</LI>
</OL>

<H4>Parameters</H4>
<DL>
  <DT>Archive</DT>
  <DD>Provides a space for you to specify a destination archive name.
     You can click &quot;<B>...</B>&quot; button to display &quot;Open&quot; dialog box
     that you can use to locate archive.</DD>

  <DT>Archive format</DT>
  <DD>Specifies a format of created archive. Some formats (gzip and bzip2) 
    do not support compressing more the one file per archive.</DD>

  <DT>Compression level</DT>
  <DD>
    <P>Specifies compression level. There are 6 levels of compression:</P>
    <TABLE>
      <TR> <TH>Value</TH> <TH>Meaning</TH> </TR>
      <TR> <TD>Store</TD> <TD>Files will be copied to archive without compression.</TD> </TR>
      <TR> <TD>Fastest</TD> <TD>Fastest compression.</TD> </TR>
      <TR> <TD>Fast</TD> <TD>Fast compression.</TD> </TR>
      <TR> <TD>Normal</TD> <TD>Compression with balanced settings.</TD> </TR>
      <TR> <TD>Maximum</TD> <TD>Can give a higher compression ratio than Normal level.
               But it can be slower, and it can require more memory.</TD> </TR>
      <TR> <TD>Ultra</TD> <TD>Can give a higher compression ratio than Maximum level. 
               But it can be slower, and it can require more memory.</TD> </TR>
    </TABLE>
  </DD>

  <DT>Compression method</DT>
  <DD>
    <P>Specifies compression method. Each archive format can have its own compression methods:</P>
    <TABLE>
      <TR> <TH>Method</TH> <TH>Description</TH> </TR>
      <TR> <TD>LZMA</TD> <TD>It's base compression method for 7z format. 
                     Even old versions of 7-Zip can decompress archives created with LZMA method.
                     It provides high  compression ratio and very fast decompression.</TD> </TR>
      <TR> <TD>LZMA2</TD> <TD>Default compression method of 7z format.  LZMA2 is LZMA-based compression method. 
                     It provides better multithreading support than LZMA. But compression ratio
                     can be worse in some cases. For best compression ratio with LZMA2 use 1 
                     or 2 CPU threads. If you use LZMA2 with more than 2 threads, 7-zip splits data 
                     to chunks and compresses these chunks independently (2 threads per each chunk).</TD> </TR>
      <TR> <TD>PPMd</TD> <TD>Dmitry Shkarin's PPMdH algorithm with small changes. 
                  Usually it provides high compression ratio and high speed 
                  for text files.</TD> </TR>
      <TR> <TD>BZip2</TD> <TD>Standard compression method based on BWT algorithm. 
                     Usually it provides high speed and pretty good 
                     compression ratio for text files.</TD> </TR>
      <TR> <TD>Deflate</TD> <TD>Standard compression method of ZIP and GZip formats.
             Compression ratio is not too high. But it provides pretty fast 
             compressing and decompressing. Deflate method supports only 
             32 KB dictionary.</TD> </TR>
      <TR> <TD>Deflate64</TD> <TD>Modified version of Deflate algorithm with 
             bigger dictionary (64KB).</TD> </TR>
    </TABLE>

    <BR>
    <P>Estimated 7-Zip performance and memory requirements for 2 GHz dual core CPU:</P>
    <TABLE>
      <TR> 
        <TH class="cc">Method</TH> 
        <TH class="cc">Level</TH> 
        <TH class="cc">Dictionary Size</TH> 
        <TH class="cc">Compressing Speed</TH> 
        <TH class="cc">Decompressing Speed</TH> 
        <TH class="cc">Memory for Compressing</TH> 
        <TH class="cc">Memory for Decompressing</TH> 
      </TR>
      <TR>
         <TD class="cc" rowspan="5">LZMA</TD>
         <TD class="cc">fastest</TD>
         <TD class="cc">64 KB</TD>
         <TD class="cc">4.5 MB/s</TD>
         <TD class="cc" rowspan="5">15 MB/s</TD>
         <TD class="cc">3 MB</TD>
         <TD class="cc">3 MB</TD></TR>
      <TR>
         <TD class="cc">fast</TD>
         <TD class="cc">1 MB</TD>
         <TD class="cc">3 MB/s</TD>
         <TD class="cc">10 MB</TD>
         <TD class="cc">3 MB</TD></TR>
      <TR>
        <TD class="cc">normal</TD>
        <TD class="cc">16 MB</TD>
        <TD class="cc">2 MB/s</TD>
        <TD class="cc">186 MB</TD>
        <TD class="cc">18 MB</TD></TR>
      <TR>
        <TD class="cc">maximum</TD>
        <TD class="cc">32 MB</TD>
        <TD class="cc">1.8 MB/s</TD>
        <TD class="cc">376 MB</TD>
        <TD class="cc">34 MB</TD></TR>
      <TR>
        <TD class="cc">ultra</TD>
        <TD class="cc">64 MB</TD>
        <TD class="cc">1.6 MB/s</TD>
        <TD class="cc">709 MB</TD>
        <TD class="cc">66 MB</TD></TR>
      <TR>
        <TD class="cc" rowspan="4">PPMD</TD>
        <TD class="cc">fast</TD>
        <TD class="cc">4 MB</TD>
        <TD class="cc" colspan="2">1.4 MB/s</TD>
        <TD class="cc" colspan="2">6 MB</TD></TR>
      <TR>
        <TD class="cc">normal</TD>
        <TD class="cc">24MB</TD>
        <TD class="cc" colspan="2">1.2 MB/s</TD>
        <TD class="cc" colspan="2">26 MB</TD></TR>
      <TR>
        <TD class="cc">maximum</TD>
        <TD class="cc">64 MB</TD>
        <TD class="cc" colspan="2">1.0 MB/s</TD>
        <TD class="cc" colspan="2">66 MB</TD></TR>
      <TR>
        <TD class="cc">ultra</TD>
        <TD class="cc">192 MB</TD>
        <TD class="cc" colspan="2">0.9 MB/s</TD>
        <TD class="cc" colspan="2">194 MB</TD></TR>
      <TR>
        <TD class="cc" rowspan="4">Deflate</TD>
        <TD class="cc">fast</TD>
        <TD class="cc" rowspan="4">32 KB</TD>
        <TD class="cc">15 MB/s</TD>
        <TD class="cc" rowspan="4">40 MB/s</TD>
        <TD class="cc" rowspan="2">3 MB</TD>
        <TD class="cc" rowspan="4">2 MB</TD></TR>
      <TR>
        <TD class="cc">normal</TD>
        <TD class="cc">3.5 MB/s</TD></TR>
      <TR>
        <TD class="cc">maximum</TD>
        <TD class="cc">1.5 MB/s</TD>
        <TD class="cc" rowspan="2">4MB</TD></TR>
      <TR>
        <TD class="cc">ultra</TD>
        <TD class="cc">0.4 MB/s</TD>
      <TR>
        <TD class="cc" rowspan="3">BZip2</TD>
        <TD class="cc">normal</TD>
        <TD class="cc" rowspan="3">900 KB</TD>
        <TD class="cc">3 MB/s</TD>
        <TD class="cc" rowspan="3">16 MB/s</TD>
        <TD class="cc" rowspan="3">20 MB</TD>
        <TD class="cc" rowspan="3">7 MB</TD></TR>
      <TR>
        <TD class="cc">maximum</TD>
        <TD class="cc">1.2 MB/s</TD>
      <TR>
        <TD class="cc">ultra</TD>
        <TD class="cc">0.4 MB/s</TD>
    </TABLE>
  </DD>

  <DT>Dictionary size</DT>
  <DD>
    <P>Specifies Dictionary size for compression method.</P>
    <P>Usually, a higher Dictionary size gives a higher compression ratio.
    But compressing can be slower and it can require more memory.</P>
    <P>
    Memory (RAM) usage for LZMA compressing is about 11 times more than dictionary size.
    Memory usage for LZMA decompressing is close to  value of dictionary size. 
    Memory usage for PPMd compressing and decompressing is almost equal 
    to dictionary size.</P>
  </DD>

  <DT>Word size</DT>
  <DD>
    <P>Specifies the length of words, which will be used to find identical 
       sequences of bytes for compression.</P>
    <P>Usually for LZMA and Deflate, big Word size gives a little bit better
       compression ratio and slower compression process.
       A big Word size parameter can significantly increase compression ratio 
       for files which contain long identical sequences of bytes. For PPMd,
       the Word size strongly affects both compression ratio and 
       compression/decompression speed.</P>
  </DD>

  
  <DT>Solid Block size</DT>
  <DD>
    <P>Specifies the size of a solid block. You can also disable solid mode.
          In solid mode all files will be compressed as continuous data blocks. 
          Usually compressing to a solid archive improves the compression ratio.
          You can use this option only for 7z archives. The updating of solid .7z 
          archives can be slow, since it can require some recompression.</P>
.</P>
  </DD>

  <DT>Number of CPU threads</DT>
  <DD>
    <P>Specifies the number of threads for compressing. 
       A big number of threads can speed up compression speed on Multi-Processor systems.
       Sometimes it can increase speed even on single-core CPU.</P>
  </DD>

  <DT>Split to volumes</DT>
  <DD>
    <PRE class="syntax">
    {Size}[b | k | m | g]
    </PRE>

    <P>Specifies volume sizes in Bytes, Kilobytes (1 Kilobyte = 1024 bytes),
    Megabytes (1 Megabyte = 1024 Kilobytes) or Gigabytes (1 Gigabyte = 1024 Megabytes).
    If you specify only {Size}, 7-zip will treat it as bytes. It's possible to specify
    several values. Example:</P>

    <PRE class="example">
    10k 15k 2m
    </PRE>

    <P>The first volume will be 10 KB, the second will be 15 KB, and all others will be 2 MB.</P>
   
  </DD>

  <DT>Parameters</DT>
  <DD>
    <P>Allows you to specify parameters for compression. See the
    <A href="../../../../cmdline/switches/method.htm">-m (Method)</A> switch description for 
    more details. Omit the -m prefix (as in -m switch) when using this dialog box.<P>
    <P><B>Examples</B></P>
    <PRE class="example">
      f=delta:4</PRE>
      <P>uses Delta:4 filter (if you want to compress WAV files).</P>

    <PRE class="example">
      f=bcj2</PRE>
      <P>uses BCJ2 filter (for x86 executables).</P>

  </DD>

  <DT>Update mode</DT>
  <DD>
    <P>Specifies update mode:</P>
    <TABLE>
      <TR> <TH width="30%">Value</TH> <TH>Meaning</TH> </TR>
      <TR> <TD>Add and replace files</TD> <TD>Add all specified files to the archive.</TD> </TR>
      <TR> <TD>Update and add files</TD> <TD>Update older files in the archive and add
                files that are new to the archive.</TD> </TR>
      <TR> <TD>Freshen existing files</TD> <TD>Update specified files in the
               archive that are older than the selected disk files.</TD> </TR>
      <TR> <TD>Synchronize files</TD> <TD>Replace specified files only if
         added files are newer. Always add those files, which are not
         present in the archive. Delete from archive those files,
         which are not present on the disk.</TD> </TR>
    </TABLE>
  </DD>

  <DT>Options</DT>
  <DD>
    <P>Specifies compression options:</P>
    <TABLE>
      <TR> <TH width="30%">Option</TH> <TH>Meaning</TH> </TR>
      <TR> <TD>Create SFX archive</TD> <TD>Create self-extracting archive. You can use this option only 
           for 7z archives. Look to 
           <A href="../../../../cmdline/switches/sfx.htm">-sfx (Create SFX archive)</A> switch description for 
           more details about SFX modules.</TD> </TR>
      <TR> <TD>Compress shared files</TD> <TD>Compress files open for writing by another applications.</TD> </TR>
      <TR> <TD>Delete files after compression</TD> <TD>Delete files 
           after including to archive. So it works like moving files to archive.
           7-Zip deletes files at the end of operation and only if archive was successfully created.</TD> </TR>
    </TABLE>
  </DD>

  <DT>Encryption</DT>
  <DD>
    <P>Specifies password and encryption options.</P>
    <DL>
      <DT>Enter password</DT>
        <DD>Specify password here</DD>
      <DT>Reenter password</DT>
        <DD>Reenter password here for verification</DD>
      <DT>Show Password</DT>
        <DD>Shows Password</DD>
      <DT>Encryption method</DT>
        <DD>Specifies the encryption method. For 7z format, it can be only AES-256.
          For ZIP format you can select ZipCrypto or AES-256. 
          Use ZipCrypto, if you want to get archive compatible with most of the ZIP archivers. 
          AES-256 provides stronger encryption, but now AES-256 is supported only 
          by 7-Zip, WinZip and some other ZIP archivers.
      <DT>Encrypt file names</DT>
        <DD>Enables or disables archive header encryption, including file name encryption.</DD>
    </DL>
  </DD>


</DL>
<UL>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Extract Dialog Box</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Extract Dialog Box</H1>

<P>Allows you to specify options for extracting files from archive.</P>

<H4>How to run this dialog box</H4>

<P>There are two ways to run this dialog to extract all files from an archive:</P>
<UL>
  <LI>In Windows Explorer or in 7-Zip, right-click the archive file, point to <B>7-Zip</B>, and then click <B>Extract files...</B>.</LI>
  <LI>Select the archive file in 7-Zip and press <B>Extract</B> button.</LI>
</UL>


<H4>Parameters</H4>
<DL>
  <DT>Extract to</DT>
  <DD>Provides a space for you to specify an output folder.
     You can click &quot;<B>...</B>&quot; button to display &quot;Browse for folder&quot;
     dialog box that you can use to locate output folder.</DD>

  <DT>Path mode</DT>
  <DD>
    <P>Specify extract mode:</P>
    <TABLE>
      <TR> <TH>Value</TH> <TH>Meaning</TH> </TR>
      <TR> <TD>Full pathnames</TD> <TD>Extract files with full pathnames.</TD> </TR>
      <TR> <TD>No pathnames</TD> <TD>Extract files without folder paths.</TD> </TR>
      <TR> <TD>Absolute pathnames</TD> <TD>Extract files with absolute pathnames. 
               7-Zip doesn't use folder specified in "Extract to" field for files in archive 
               that have absolute pathnames. Absolute path can include drive name. </TD> </TR>
    </TABLE>
  </DD>

  <DT>Eliminate duplication of root folder</DT>
  <DD>That option allows to eliminate duplication of root folder, if all files
      in archive are placed in folder with name that is identical to name of output folder.</DD>

  <DT>Overwrite mode</DT>
  <DD>
    <P>Specify overwrite mode for files that already present on disk:</P>
    <TABLE>
      <TR> <TH>Value</TH> <TH>Meaning</TH> </TR>
      <TR> <TD>Ask before overwrite</TD> <TD>Ask before overwriting existing files.</TD> </TR>
      <TR> <TD>Overwrite without prompt</TD> <TD>Overwrite existing files without prompt.</TD> </TR>
      <TR> <TD>Skip existing files</TD> <TD>Skip extracting of existing files.</TD> </TR>
      <TR> <TD>Auto rename</TD> <TD>Rename extracted files, if a file with the same name already exists.
                        For example, file document.txt will be renamed to document_1.txt.</TD> </TR>
      <TR> <TD>Auto rename existing files</TD> <TD>Rename existing files, if a file with the same name already exists.
                        For example, file document.txt will be renamed to document_1.txt.</TD> </TR>
    </TABLE>
  </DD>

  <DT>Password</DT>
  <DD>
    <P>Specifies a password for encrypted archives.</P>
  </DD>
  <DT>Show Password</DT>
    <DD>Show a password in Password field.</DD>

  <DT>Restore file security</DT>
  <DD>Restore file security information, if archive contains that information.
      That feature now is implemented only for WIM archives.</DD>

</DL>
<UL>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>7-Zip Plugin</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>7-Zip Plugin</H1>

<P>7-Zip is a plugin for  manipulating archives. It makes all archive files 
look like usual folders in File Manager.</P>

<P>Most of the operations with compressed files can be initiated by
right-clicking on files in the File Manager (or in Windows Explorer) and
selecting the appropriate command from a menu.</P>

<H4>Using 7-Zip</H4>

<DL>
  <DT><A name="open"></A>Opening archive</DT>
  <DD>
    <P>There are two ways to open an archive file:</P>
    <UL>
      <LI>If you have the file type associated with 7-Zip, then you can open the
         file with 7-Zip by double-clicking the file or by right-clicking and selecting
         the <B>Open</B> command.</LI>
      <LI>You can right-click the archive file, point to <B>7-Zip</B>,
        and then click the <B>Open</B> command item.</LI>
    </UL>
  </DD>
  <DT>Extracting archive</DT>
  <DD>
    <P>There are two ways to extract files from an archive:</P>
    <UL>
      <LI>To extract all files from an archive right-click the archive file,
          point to <B>7-Zip</B>, and then click the <B>Extract files...</B>
          command item.</LI>
      <LI>To extract specific files from an archive, open it by
          <A href="#open">Open archive with 7-Zip</A>,
          select the items to extract, and run the <B>Copy To...</B> command.</LI>
    </UL>
    <P> <A href="extract.htm">Extract Dialog</A> will appear.</P>
  </DD>
  <DT>Testing archive</DT>
  <DD>
     <P>To test an archive, right-click the archive file,
          point to <B>7-Zip</B>, and then click the <B>Test archive</B>
          command item.</P>
  </DD>
  <DT>Creating and updating files in an archive</DT>
  <DD>
    <P>For creating or updating an archive file, right-click the file(s) or folder(s) you want to compress,
          point to <B>7-Zip</B>, and then click the <B>Add to archive...</B> command item.
    <A href="add.htm">Add to Archive Dialog</A> will appear.</P>
  </DD>
</DL>


</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>7z Format</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>7z Format</H1>

<P><B>7z</B> is a new archive format, providing a high compression ratio.</P>

<P>The main features of the <B>7z</B> format:</P>
<UL>
  <LI>Open architecture
  <LI>High compression ratio
  <LI>Strong AES-256 encryption
  <LI>Ability to use any compression, conversion or encryption method
  <LI>Supports files with sizes up to 16000000000 GB
  <LI>Unicode file names
  <LI>Solid compression
  <LI>Archive headers compression
</UL>

<P><B>7z</B> has an open architecture, so it can support any new compression methods.</P>
The following methods currently are integrated into <B>7z</B>:<P>

<TABLE cellspacing ="2" cellpadding ="4">
  <TR> <TH class="Title" width="60">Method</TH> <TH class="Title">Description</TH> </TR>
  <TR> <TD class="Item">LZMA</TD> <TD class="Item">Improved and optimized version of LZ77 algorithm</TD></TR>
  <TR> <TD class="Item">LZMA2</TD> <TD class="Item">LZMA-based compression method. It provides better multithreading support than LZMA</TD></TR>
  <TR> <TD class="Item">PPMD</TD> <TD class="Item">Dmitry Shkarin's PPMdH with small changes</TD></TR>
  <TR> <TD class="Item">BCJ</TD> <TD class="Item">Converter for 32-bit x86 executables</TD></TR>
  <TR> <TD class="Item">BCJ2</TD> <TD class="Item">Converter for 32-bit x86 executables</TD></TR>
  <TR> <TD class="Item">BZip2</TD> <TD class="Item">Standard BWT algorithm</TD></TR>
  <TR> <TD class="Item">Deflate</TD> <TD class="Item">Standard LZ77-based algorithm</TD></TR>
</TABLE>

<P><B>LZMA</B> is the default and general compression method of <B>7z</B> format. 
The main features of the <B>LZMA</B> method:</P>
<UL>
  <LI>High compression ratio
  <LI>Variable dictionary size (up to 4 GB)
  <LI>Compression speed: about 1 MB/s on 2 GHz CPU
  <LI>Decompression speed: about 10-20 MB/s on 2 GHz CPU
  <LI>Small memory requirement for decompression (depends from dictionary size)
  <LI>Small code size for decompression: about 5 KB
  <LI>Supports multi-threading and P4's hyper-threading
</UL>

<P>The <B>LZMA</B> compression algorithm is very suitable for embedded applications.
If you want to use <B>LZMA</B> code, you can ask for consultation, custom code programming,
and required developer licenses at 
<P><A href="http://www.7-zip.org/support.html" target="_blank">www.7-zip.org/support.html</A></P>
</P>

<H2>AES encryption</H2>

<P>7-Zip supports encryption with the AES-256 algorithm. 
This algorithm uses a cipher key with length of 256 bits. To create the key, 7-Zip 
uses a derivation function based on an SHA-256 hash algorithm.
A key derivation function produces a derived key from a text password defined by the user.
To increase the cost of an exhaustive search for passwords, 7-Zip uses a big number 
of iterations to produce the cipher key from the text password.</P>

<H2>Tips for selecting password length</H2>

<P>Here is an estimate of the time required for an exhaustive
password search attack, when the password is a random
sequence of lowercase Latin letters.</P>

<P>The most complex task for password search attack is SHA-256 calculation.
Special SHA-256 hardware or GPU can be used to accelerate password search attack.
Now modern GPU can provide about 10 times more performance for SHA-256 calculation 
than modern CPU. And special SHA-256 hardware can provide about 20 times more 
performance than GPU.</P>

<P>We suppose that one user with a budget of about $2000 (for GPUs) can check 
10000 passwords per second and an organization with a budget of about 
10^9 USD (one thousand million US dollars) can check 3 * 10^12 passwords per second.
We also suppose that the processor in use doubles its performance every two years;
so, each additional Latin letter of a long password adds about
9 years to an exhaustive key search attack.</P>

<P>The result is this estimate of the time to succeed in an attack:</P>

<TABLE>
  <TR align=center>
    <TH>Password Length</TH>
    <TH>Single User Attack</TH>
    <TH>Organization Attack</TH>
  </TR>
  <TR align=center> <TD> 1</TD> <TD>      1 s</TD> <TD>      1 s</TD> </TR>
  <TR align=center> <TD> 2</TD> <TD>      1 s</TD> <TD>      1 s</TD> </TR>
  <TR align=center> <TD> 3</TD> <TD>      2 s</TD> <TD>      1 s</TD> </TR>
  <TR align=center> <TD> 4</TD> <TD>    1 min</TD> <TD>      1 s</TD> </TR>
  <TR align=center> <TD> 5</TD> <TD>   30 min</TD> <TD>      1 s</TD> </TR>
  <TR align=center> <TD> 6</TD> <TD> 12 hours</TD> <TD>      1 s</TD> </TR>
  <TR align=center> <TD> 7</TD> <TD>  14 days</TD> <TD>      1 s</TD> </TR>
  <TR align=center> <TD> 8</TD> <TD>   1 year</TD> <TD>      1 s</TD> </TR>
  <TR align=center> <TD> 9</TD> <TD> 10 years</TD> <TD>      2 s</TD> </TR>
  <TR align=center> <TD>10</TD> <TD> 19 years</TD> <TD>    1 min</TD> </TR>
  <TR align=center> <TD>11</TD> <TD> 28 years</TD> <TD>   30 min</TD> </TR>
  <TR align=center> <TD>12</TD> <TD> 37 years</TD> <TD> 12 hours</TD> </TR>
  <TR align=center> <TD>13</TD> <TD> 46 years</TD> <TD>  14 days</TD> </TR>
  <TR align=center> <TD>14</TD> <TD> 55 years</TD> <TD>   1 year</TD> </TR>
  <TR align=center> <TD>15</TD> <TD> 64 years</TD> <TD> 10 years</TD> </TR>
  <TR align=center> <TD>16</TD> <TD> 73 years</TD> <TD> 19 years</TD> </TR>
  <TR align=center> <TD>17</TD> <TD> 82 years</TD> <TD> 28 years</TD> </TR>
  <TR align=center> <TD>18</TD> <TD> 91 years</TD> <TD> 37 years</TD> </TR>
  <TR align=center> <TD>19</TD> <TD>100 years</TD> <TD> 46 years</TD> </TR>
</TABLE>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Frequently Asked Questions (FAQ)</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Frequently Asked Questions (FAQ)</H1>

<H4>Can I use 7-Zip in a commercial organization?</H4>
<P>Yes, 7-Zip is free software. You can use it on any computer. You don't need to 
register or pay for 7-Zip.</P>

<H4>How can I set file associations to 7-Zip in Windows 7 and Windows Vista?</H4>
<P>You must run 7-Zip File Manager in administrator mode. 
Right-click the icon of 7-Zip File Manager, and then click <B>Run as administrator</B>.
Then you can change file associations and some other options.</P>

<H4>Why 7z archives created by new version of 7-Zip can be larger than archives created by old version of 7-Zip?</H4>

<P>New versions of 7-Zip (starting from version 15.06) use another file sorting 
order by default for solid 7z archives.</P>

<P>Old version of 7-Zip (before version 15.06) used file sorting "by type" ("by extension").</P>
<P>New version of 7-Zip supports two sorting orders:</P>
<UL>
  <LI>sorting by name - default order.</LI>
  <LI>sorting by type, if '<B>qs</B>' is specified in <B>Parameters</B> field in "Add to archive" window, 
     (or <B>-mqs</B> switch for command line version).</LI>
</UL>

<P>You can get big difference in compression ratio for different sorting methods,
if dictionary size is smaller than total size of files.
If there are similar files in different folders, the sorting "by type" can provide 
better compression ratio in some cases.</P>

<P>Note that sorting "by type" has some drawbacks.
For example, NTFS volumes use sorting order "by name", so if an archive uses 
another sorting, then the speed of some operations for files with unusual order 
can fall on HDD devices (HDDs have low speed for "seek" operations).</P>

<P>You can increase compression ratio with the following methods:</P>
<UL>
  <LI>Increase dictionary size. It can help when 'qs' is not used.</LI>
  <LI>Specify '<B>qs</B>' in <B>Parameters</B> field (or use <B>-mqs</B> switch for command line version).</LI>
</UL>

<P>If you think that unusual file order is not problem for you, 
and if better compression ratio with small dictionary is more important for you,
use '<B>qs</B>' mode.</P>

<H4>Why can't 7-Zip open some ZIP archives?</H4>
<P>In 99% of these cases it means that the archive contains incorrect headers.
Other ZIP programs can open some archives with incorrect headers, since these programs 
just ignore errors.</P>
<P>If you have such archive, please don't call the 7-Zip developers about it.
Instead try to find the program that was used to create the archive and inform the developers 
of that program that their software is not ZIP-compatible.</P>

<P>There are also some ZIP archives that were encoded with methods unsupported by 7-Zip,
for example, WAVPack (WinZip).</P>

<H4>Why does drag-and-drop archive extraction from 7-Zip to Explorer use temp files?</H4>
<P>7-Zip doesn't know folder path of drop target.
Only Windows Explorer knows exact drop target.
And Windows Explorer needs files (drag source) as decompressed files on disk.
So 7-Zip extracts files from archive to temp folder and then 
7-Zip notifies Windows Explorer about paths of these temp files.
Then Windows  Explorer copies these files to drop target folder.</P>

<P>To avoid temp file usage, you can use Extract command of 7-Zip or 
drag-and-drop from 7-Zip to 7-Zip.</P>

<H4>Why doesn't the command line version add files without extensions to an archive?</H4>
<P>You're probably using a *.* wildcard. 7-Zip doesn't use the operating system's wildcard mask parser, 
and consequently treats *.* as any file that has an extension. 
To process all files you must use the * wildcard instead or omit the wildcard altogether.</P>

<H4>Why doesn't -r switch work as expected?</H4>
<P>In most cases you don't need -r switch.
7-Zip can compress subfolders even without -r switch.</P>
<P>Example 1:</P>
<PRE>  7z.exe a c:\a.7z "C:\Program Files"</PRE>
<P>compresses "C:\Program Files" completely, including all subfolders.</P>
<P>Example 2:</P>
<PRE>  7z.exe a -r c:\a.7z "C:\Program Files"</PRE>
<P>searches and compresses "Program Files" in all subfolders of C:\ (for example, in "C:\WINDOWS").</P>
If you need to compress only files with some extension, you can use -r switch:
<PRE>  7z a -r c:\a.zip c:\dir\*.txt </PRE>
<P>compresses all *.txt files from folder c:\dir\ and all it's subfolders.</P>

<H4>Why can't 7-Zip use big dictionary in 32-bit Windows?</H4>
<P>32-bit Windows allocates only 2 GB of virtual space per one application. 
Also that block of 2 GB can be fragmented (for example, by some DLL file), 
so 7-Zip can't allocate one big contiguous block of virtual space.
There are no such limitations in 64-bit Windows. 
So you can use any dictionary in Windows x64, if you have required amount of physical RAM.</P>

<H4>How can I install 7-Zip in silent mode?</H4>

<P>For exe installer: Use the "/S" parameter to do a silent installation and the "/D=dir" parameter 
to specify the "output directory". These options are case-sensitive.</P>

<P>For msi installer: Use the /q INSTALLDIR="C:\Program Files\7-Zip" parameters.</P>


<H4>How can I recover corrupted 7z archive?</H4>

<P>There are some possible cases when archive is corrupted:
<UL>
  <LI>You can open archive and you can see the list of files, but when you press 
      Extract or Test command, there are some errors: Data Error or CRC Error.
  <LI>When you open archive, you get message "Can not open file 'a.7z' as archive"
</UL>

<P>It's possible to recover some data. Read about recovering procedure:

<P><A href = "http://www.7-zip.org/recover.html" target="_blank">Recover corrupted 7z archive</A></P>


</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Supported formats</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Supported formats</H1>

<TABLE>
  <TR>
    <TH>Format</TH>
    <TH>Creation</TH>
    <TH>Filename Extensions</TH>
  </TR>
  <TR> <TD align="center">7z</TD> <TD align="center">X</TD> <TD>7z</TD> </TR>
  <TR> <TD align="center">BZIP2</TD> <TD align="center">X</TD> <TD>bz2 bzip2 tbz2 tbz</TD> </TR>
  <TR> <TD align="center">GZIP</TD> <TD align="center">X</TD> <TD>gz gzip tgz</TD> </TR>
  <TR> <TD align="center">TAR</TD> <TD align="center">X</TD> <TD>tar</TD> </TR>
  <TR> <TD align="center">WIM</TD> <TD align="center">X</TD> <TD>wim swm</TD> </TR>
  <TR> <TD align="center">XZ</TD> <TD align="center">X</TD> <TD>xz txz</TD> </TR>
  <TR> <TD align="center"><A href="#zip">ZIP</A></TD> <TD align="center">X</TD> <TD>zip zipx jar xpi odt ods docx xlsx epub</TD> </TR>

  <TR> <TD align="center">APM</TD> <TD></TD> <TD>apm</TD> </TR>
  <TR> <TD align="center">AR</TD> <TD></TD> <TD>ar a deb lib</TD> </TR>
  <TR> <TD align="center">ARJ</TD> <TD></TD> <TD>arj</TD> </TR>
  <TR> <TD align="center">CAB</TD> <TD></TD> <TD>cab</TD> </TR>
  <TR> <TD align="center">CHM</TD> <TD></TD> <TD>chm chw chi chq</TD> </TR>
  <TR> <TD align="center">COMPOUND</TD> <TD></TD> <TD>msi msp doc xls ppt</TD> </TR>
  <TR> <TD align="center">CPIO</TD> <TD></TD> <TD>cpio</TD> </TR>
  <TR> <TD align="center">CramFS</TD> <TD></TD> <TD>cramfs</TD> </TR>
  <TR> <TD align="center">DMG</TD> <TD></TD> <TD>dmg</TD> </TR>
  <TR> <TD align="center">Ext</TD> <TD></TD> <TD>ext ext2 ext3 ext4 img</TD> </TR>
  <TR> <TD align="center">FAT</TD> <TD></TD> <TD>fat img</TD> </TR>
  <TR> <TD align="center">HFS</TD> <TD></TD> <TD>hfs hfsx</TD> </TR>
  <TR> <TD align="center">HXS</TD> <TD></TD> <TD>hxs hxi hxr hxq hxw lit</TD> </TR>
  <TR> <TD align="center">iHEX</TD> <TD></TD> <TD>ihex</TD> </TR>
  <TR> <TD align="center">ISO</TD> <TD></TD> <TD>iso img</TD> </TR>
  <TR> <TD align="center"><A href="#lzh">LZH</A></TD> <TD></TD> <TD>lzh lha</TD></TR>
  <TR> <TD align="center">LZMA</TD> <TD></TD> <TD>lzma</TD> </TR>
  <TR> <TD align="center">MBR</TD> <TD></TD> <TD>mbr</TD> </TR>
  <TR> <TD align="center">MsLZ</TD> <TD></TD> <TD>mslz</TD> </TR>
  <TR> <TD align="center">Mub</TD> <TD></TD> <TD>mub</TD> </TR>
  <TR> <TD align="center">NSIS</TD> <TD></TD> <TD>nsis</TD> </TR>
  <TR> <TD align="center">NTFS</TD> <TD></TD> <TD>ntfs img</TD> </TR>
  <TR> <TD align="center">MBR</TD> <TD></TD> <TD>mbr</TD> </TR>
  <TR> <TD align="center">RAR</TD> <TD></TD> <TD>rar r00</TD> </TR>
  <TR> <TD align="center">RPM</TD>  <TD></TD> <TD>rpm</TD></TR>
  <TR> <TD align="center">PPMD</TD> <TD></TD> <TD>ppmd</TD> </TR>
  <TR> <TD align="center">QCOW2</TD> <TD></TD> <TD>qcow qcow2 qcow2c</TD> </TR>
  <TR> <TD align="center">SPLIT</TD> <TD></TD> <TD>001 002 ...</TD> </TR>
  <TR> <TD align="center">SquashFS</TD> <TD></TD> <TD>squashfs</TD> </TR>
  <TR> <TD align="center">UDF</TD> <TD></TD> <TD>udf iso img</TD> </TR>
  <TR> <TD align="center">UEFIc</TD> <TD></TD> <TD>scap</TD> </TR>
  <TR> <TD align="center">UEFIs</TD> <TD></TD> <TD>uefif</TD> </TR>
  <TR> <TD align="center">VDI</TD> <TD></TD> <TD>vdi</TD> </TR>
  <TR> <TD align="center">VHD</TD> <TD></TD> <TD>vhd</TD> </TR>
  <TR> <TD align="center">VMDK</TD> <TD></TD> <TD>vmdk</TD> </TR>
  <TR> <TD align="center">WIM</TD> <TD></TD> <TD>wim esd</TD> </TR>
  <TR> <TD align="center">XAR</TD> <TD></TD> <TD>xar pkg</TD> </TR>
  <TR> <TD align="center">Z</TD> <TD></TD> <TD>z taz</TD> </TR>
</TABLE>

<H2><a name="zip"></a>ZIP</H2>

<P>7-Zip creates ZIP compatible archives. 
7-Zip supports the following ZIP compression methods:</P>
<UL>
  <LI>0 - Store</LI>
  <LI>1 - Shrink (decompression only)</LI>
  <LI>6 - Implode (decompression only)</LI>
  <LI>8 - Deflate</LI>
  <LI>9 - Deflate64</LI>
  <LI>12 - BZip2</LI>
  <LI>14 - LZMA</LI>
  <LI>95 - xz (decompression only)</LI>
  <LI>98 - PPMd</LI>
  <LI>99 - WinZip AES</LI>
</UL>

<P>Files compressed with other ZIP compression methods
can't be extracted by the current version of the 7-Zip.
But these supported methods are the most popular today,
and therefore 7-Zip can decompress most ZIP archives.
To extract files compressed with non-supported methods you must use some
other ZIP utility.</P>

<P>7-Zip supports the Zip64 extension of ZIP format.</P>

<H2><a name="lzh"></a>LZH</H2>

<P>7-Zip supports LZH archives only for listing, browsing and decompressing.
7-Zip supports -lh0-, -lh4-, -lh5-, -lh6- and -lh7- methods.</P>


</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>General Information</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>General Information</H1>

<h4>The main features of 7-Zip</h4>

<UL>
  <LI><A href = "../fm/index.htm">Powerful file manager</A></LI>
  <LI><A href = "performance.htm">High compression ratio and high speed</A></LI>
  <LI><A href = "formats.htm">Big number of supported archive formats</A></LI>
  <LI><A href = "../cmdline/index.htm">Additional command line version</A></LI>
</UL>

<H4>See Also</H4>
<UL>
  <LI><A href = "license.htm">License for use and distribution</A></LI>
</UL>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>License for use and distribution</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>License</H1>

<P>7-Zip Copyright (C) 1999-2016 Igor Pavlov.</P>

<P>Licenses for files are:</P>
<IL>
  <LI>7z.dll: GNU LGPL + unRAR restriction
  <LI>All other files: GNU LGPL
</IL>

<P>The GNU LGPL + unRAR restriction means that you must follow both 
  GNU LGPL rules and unRAR restriction rules.</P>

<P>Note: You can use 7-Zip on any computer, including a computer in a commercial 
    organization. You don't need to register or pay for 7-Zip.</P>

<P>Read file License.txt for full information about license.</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Performance</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Performance</H1>

<H4>ZIP Format</H4>
<P>Compression ratio results are very dependent upon the data used for
the tests. We compared 7-Zip with some of the leading 
commercial archivers: PKZIP 2.04g, WinZip 7.0.</P>

<P>FILE SET: The Canterbury Corpus (11 files totaling 2,810,784 bytes,
popular file set used to compression rates).</P>

<TABLE>
  <TR>
    <TH>Archiver</TH>
    <TH>Compressed size</TH>
    <TH>Ratio</TH>
  </TR>
  <TR>
    <TD><B>7-Zip (zip format)</B></TD>
    <TD><B>676284</B></TD>
    <TD><B>100%</B></TD>
  </TR>
  <TR>
    <TD>PKZIP 2.04g -ex</TD>
    <TD>726047</TD>
    <TD>107%</TD>
  </TR>
  <TR>
    <TD>WinZip 7.0 (Max)</TD>
    <TD>731499</TD>
    <TD>108%</TD>
  </TR>
</TABLE>


<H4>7z Format</H4>

<P>7z is the new archive format, providing a high compression ratio.</P>

<P>FILE SET: The GIMP 1.2.4 for Windows after full installation 
(127 subfolders, 1304 files totaling 27,128,826 bytes).  
The GIMP is the GNU Image Manipulation Program. It can be downloaded from 
www.gimp.org.</P>

<TABLE>
  <TR>
    <TH>Archiver</TH>
    <TH>Compressed size</TH>
    <TH>Ratio</TH>
  </TR>
  <TR>
    <TD><B>7-Zip (7z format)</B></TD>
    <TD><B>5445402</B></TD>
    <TD><B>100%</B></TD>
  </TR>
  <TR>
    <TD>WinRAR 3.10</TD>
    <TD>6004155</TD>
    <TD>110%</TD>
  </TR>
  <TR>
    <TD>WinAce 2.3</TD>
    <TD>6242424</TD>
    <TD>115%</TD>
  </TR>
  <TR>
    <TD>CABARC 1.0</TD>
    <TD>6455327</TD>
    <TD>119%</TD>
  </TR>
  <TR>
    <TD><B>7-Zip (zip format)</B></TD>
    <TD><B>9461621</B></TD>
    <TD><B>174%</B></TD>
  </TR>
  <TR>
    <TD>PKZIP 2.50</TD>
    <TD>9842800</TD>
    <TD>181%</TD>
  </TR>
</TABLE>

<H4>GZIP Format</H4>

<P>7-Zip provides the best compression ratio for GZIP format. The compression ratio
is equal to its compression ratio for ZIP format (above).</P>

</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=Windows-1252">
  <TITLE>Thanks</TITLE>
  <LINK href="style.css" rel="stylesheet" type="text/css">
</HEAD>

<BODY>

<H1>Thanks</H1>

<P>I would like to thank:</P>
<UL>
  <LI>myspace from sf.net - for porting to Unix/Linux (p7zip), testing, bug fixing and more.
  <LI>ARJ Software - for ARJ.
  <LI>Eric Biggers - for LZMS description (wimlib).
  <LI>Wei Dai - for SHA-256 code and Crypto++ Library.
  <LI>Jeff Gilchrist - for compressing tests.
  <LI>Szymon Grabowski  - for some ideas.
  <LI>Microsoft Corporation - for CAB/WIM formats descriptions, and WiX (Windows Installer XML).
  <LI>Nullsoft, Inc. and NSIS team - for NSIS (Nullsoft Scriptable Install System).
  <LI>Robert Martinez - 7-Zip Logo.
  <LI>Alexander Ratushnyak - for compressing tests.
  <LI>Eugene Roshal - for RAR.
  <LI>Matthew Russotto - for CHM/CAB format description.
  <LI>Julian Seward - for BZip2.
  <LI>Eugene Shelwien - for some ideas and algorithms.
  <LI>Dmitry Shkarin - for PPMd algorithm.
  <LI>Yoshioka Tsuneo - for TAR32 program.
  <LI>Vadim Yoockin - for compressing tests.
  <LI>Bulat Ziganshin - for some ideas.
  <LI>John Michael Williams - for help file corrections.
  <LI>Apple Inc. - for HFS.
  <LI>vu1tur(DMG2IMG) - for .DMG hints.
  <LI>Yutaka Sawada - for hints to ZIP Strong Encryption format.
  <LI>NTFS-3G team - for hints to NTFS.
  <LI>Phillip Lougher - for SquashFS.
  <LI>Haruyasu Yoshizaki - for LHA/LZH.
</UL>

</BODY>
</HTML>
#! /bin/sh

# program t archive1.7z ... archiveN.7z
# program x directory_out archive1.7z ... archiveN.7z
# program xd directory_out archive1.7z ... archiveN.7z
# program a -t7z current_directory file1 ... fileN
# program ad -tzip current_directory file1 ... fileN

P7ZIP="7zG"

list=/tmp/p7zip.list.$$
rm -f ${list}

trace=/tmp/7zG1.txt
rm -f ${trace}

for file in "$@"
do
	echo "arg=${file}" >> ${trace}
done

cmd="$1"
shift

flag_ad=""
flag_type=""

case "${cmd}" in
b|t)
	;;
x|xs)
	;;
xd)
	flag_ad="-ad"
	;;
a)
	flag_type="$1"
	shift
	;;
ad)
	flag_type="$1"
	shift
	flag_ad="-ad"
	;;
*)
	echo "Unknown command \"${cmd}\""
	exit 1
	;;
esac

#ext=".7z"
#if [ "${flag_type}" = "-tzip" ]
#then
#	ext=".zip"
#fi

argn="$#"
file1="$1"
dir1=`dirname "${file1}"`
file2="$2"
echo "argn=${argn}" >> ${trace}
echo "flag_type=${flag_type}" >> ${trace}
echo "file1=${file1}" >> ${trace}
echo "dir1=${dir1}" >> ${trace}
echo "file2=${file2}" >> ${trace}

if [ "a${dir1}" != "a" ]
then
	cd "${dir1}"
fi

for file in "$@"
do
	file=`basename "${file}"`
	echo ${file} >> ${list}
	echo "list=${file}" >> ${trace}
done

case "${cmd}" in
b)
	${P7ZIP} b
	;;
t)
	${P7ZIP} t -an -ai@${list}
	;;
x|xd)
	${P7ZIP} x ${flag_ad} -an -ai@${list}
	;;
xs)
	dir_out=`dirname "${file1}"`
	${P7ZIP} x ${flag_ad} -o"*" -an -ai@${list}
	;;
a|ad)
	if [ ${argn} -eq "1" ]
	then
		file=`basename "${file1}"`${ext}
		echo "archive_out=${file}" >> ${trace}
		${P7ZIP} a ${flag_ad} ${flag_type} -i@${list} ${flag} -- "${file}"
	else
		file=`basename "${dir1}"`${ext}
		echo "archive_out=${file}" >> ${trace}
		${P7ZIP} a ${flag_ad} ${flag_type} -i@${list} ${flag} -- "${file}"
	fi
	;;
esac

rm -f ${list}

icns  }is32  m                   	                                                  	                                                  	                               s8mk  PNG

   IHDR         a   sRGB    bKGD      	pHYs        tIME+Qhp   IDAT8K0Dd'9 (UaH<iy0	 x)(33%go$`fADl.
9zuRnSkr8#isWh>R;+G>|`+    IENDB`PNG

   IHDR         a   sRGB    gAMA  a    cHRM  z&         u0  `  :  pQ<   cIDAT8O
  C?n(j	sUm:xc=[4`C` PX@{@N3 yV15hq'l    IENDB`PNG

   IHDR           szz   sRGB    bKGD      	pHYs        tIME$5   IDATXK
0DUr+U|FKU . ,	|" I-Lu7"3"#kO	H]$zJrV<n:=pwq~S 2:e    IENDB`/* XPM */
static char * p7zip_32_xpm[] = {
"32 32 3 1",
" 	c None",
".	c #000000",
"+	c #FFFFFF",
"                                ",
"                                ",
"                                ",
"                                ",
"................................",
"................................",
"..++++++++++++++++++++++++++++..",
"..++++++++++++++++++++++++++++..",
"..++++++++++++++++++++++++++++..",
"..+++.............++++++++++++..",
"..+++.............++++++++++++..",
"..+++.............++++++++++++..",
"..+++..+++++++++..++++++++++++..",
"..+++..+++++++++..++++++++++++..",
"..+++........+++..++.......+++..",
"..+++.......+++...++.......+++..",
"..+++......+++....++++++...+++..",
"..+++.....+++.....+++++...++++..",
"..+++.....+++.....++++...+++++..",
"..+++.....+++.....+++...++++++..",
"..+++.....+++.....++...+++++++..",
"..+++.....+++.....++...+++++++..",
"..+++.............++.......+++..",
"..+++.............++.......+++..",
"..++++++++++++++++++++++++++++..",
"..++++++++++++++++++++++++++++..",
"..++++++++++++++++++++++++++++..",
"................................",
"................................",
"                                ",
"                                ",
"                                "};
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleDisplayName</key>
	<string>7zFM</string>
	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>7z</string>
				<string>7Z</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>p7zip</string>
			<key>CFBundleTypeName</key>
			<string>7-Zip</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>bz2</string>
				<string>BZ2</string>
				<string>bzip2</string>
				<string>BZIP2</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-bz2.icns</string>
			<key>CFBundleTypeName</key>
			<string>BZip2</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>tbz2</string>
				<string>TBZ2</string>
				<string>tbzip2</string>
				<string>TBZIP2</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-tbz2.icns</string>
			<key>CFBundleTypeName</key>
			<string>TBZip2</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>bz</string>
				<string>BZ</string>
				<string>bzip</string>
				<string>BZIP</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-bz.icns</string>
			<key>CFBundleTypeName</key>
			<string>BZip</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>tbz</string>
				<string>TBZ</string>
				<string>tbzip</string>
				<string>TBZIP</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-tbz.icns</string>
			<key>CFBundleTypeName</key>
			<string>TBzip</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>gz</string>
				<string>GZ</string>
				<string>gzip</string>
				<string>GZIP</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-gz.icns</string>
			<key>CFBundleTypeName</key>
			<string>GZip</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>tgz</string>
				<string>TGZ</string>
				<string>tgzip</string>
				<string>TGZIP</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-tgz.icns</string>
			<key>CFBundleTypeName</key>
			<string>TGZip</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>tar</string>
				<string>TAR</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-tar.icns</string>
			<key>CFBundleTypeName</key>
			<string>Tar</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>cpio</string>
				<string>CPIO</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-cpio.icns</string>
			<key>CFBundleTypeName</key>
			<string>CPIO</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>cpgz</string>
				<string>CPGZ</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-cpgz.icns</string>
			<key>CFBundleTypeName</key>
			<string>CPGZ</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>lzma</string>
				<string>LZMA</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>p7zip</string>
			<key>CFBundleTypeName</key>
			<string>Lzma</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>pax</string>
				<string>PAX</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-pax.icns</string>
			<key>CFBundleTypeName</key>
			<string>Pax</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>001</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>p7zip</string>
			<key>CFBundleTypeName</key>
			<string>Volume</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>iso</string>
				<string>ISO</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/DiskImageMounter.app/Contents/Resources/diskcopy-doc.icns</string>
			<key>CFBundleTypeName</key>
			<string>ISO</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>exe</string>
				<string>EXE</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/ExecutableBinaryIcon.icns</string>
			<key>CFBundleTypeName</key>
			<string>Windows Exe</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>cab</string>
				<string>CAB</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/ExecutableBinaryIcon.icns</string>
			<key>CFBundleTypeName</key>
			<string>CAB</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>zip</string>
				<string>ZIP</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>/System/Library/CoreServices/Archive Utility.app/Contents/Resources/bah-zip.icns</string>
			<key>CFBundleTypeName</key>
			<string>Zip</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>rar</string>
				<string>RAR</string>
				<string>.r00</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>p7zip</string>
			<key>CFBundleTypeName</key>
			<string>Rar</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>ace</string>
				<string>ACE</string>
				<string>.c00</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>p7zip</string>
			<key>CFBundleTypeName</key>
			<string>Ace</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>*</string>
			</array>
			<key>CFBundleTypeName</key>
			<string>Archive</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>LSTypeIsPackage</key>
			<false/>
			<key>NSPersistentStoreTypeKey</key>
			<string>XML</string>
		</dict>
	</array>
	<key>CFBundleExecutable</key>
	<string>7zFM</string>
	<key>CFBundleIconFile</key>
	<string>p7zip</string>
	<key>CFBundleIdentifier</key>
	<string>p7zip.7zFM</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>7zFM</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>0.1.3.2</string>
	<key>CFBundleSignature</key>
	<string>aONe</string>
	<key>CFBundleVersion</key>
	<string>57</string>
	<key>NSHumanReadableCopyright</key>
	<string>Copyright  2009-2010 aONe</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
	<key>SUFeedURL</key>
	<string>http://p7zip.sourceforge.net</string>
</dict>
</plist>
APPLaONeicns  il32                                                                                                                                                                                            l8mk                                                                                                                                                                                                                                  ;!@Lang2@!UTF-8!
;  4.09 : Petri Jooste
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Afrikaans
Afrikaans
401
OK
Kanselleer



&Ja
&Nee
A&fsluit
Hulp

&Gaan voort
440
Ja vir &almal
Nee vir a&lmal
Stop
Herbegin
&Agtergrond
&Voorgrond
&Wag
Wagtend
Is u seker dat u wil kanselleer?
500
&Ler
R&edigeer
&Vertoon
G&unstelinge
&Gereedskap
&Hulp
540
&Open
Open &Binne
Open B&uite
&Wys
R&edigeer
Her&noem
&Kopieer na...
&Verskuif na...
Ve&rwyder
Ver&deel ler...
Kom&bineer lers...
E&ienskappe
Komme&ntaar


Maak gids
Maak ler
A&fsluit
600
Selekteer &alles
Deselekteer a&lles
Keer &seleksie om
Selekteer...
Deselekteer...
Selekteer op Soort
Deselekteer op Soort
700
&Groot ikone
&Klein ikone
&Lys
&Detail
730
Ongesorteer

&2 Panele
&Nutsbalke
Maak wortelgids oop
Een vlak hor
Gidse geskiedenis...
&Verfris
750
Argiveernutsbalk
Standaardnutsbalk
Groot knoppies
Wys teks op knoppies
800
Voeg gids by gunstelinge &as
Boekmerk
900
&Opsies...
&Normtoetsing
960
&Inhoud...
&Aangaande 7-Zip...
1003
Pad
Naam
Uitgang
Gids
Grootte
Ingepakte grootte
Kenmerke
Gemaak
Laatste toegang
Gewysig
Kompak
Kommentaar
Versleuteld
Verdeel Voor
Verdeel Na
Woordeboek
CRC
Tipe
Anti
Metode
Gasheer BS
Lersstelsel
Gebruiker
Groep
Blok
Kommentaar
Posisie

























Fout
Totale grootte
Vrye ruimte
Klustergrootte
Etiket
Plaaslike naam
Verskaffer
2100
Opsies
Taal
Taal:
Redigeerder
R&edigeerder:

2200
Stelsel
Assosieer 7-Zip met:
2301
Integreer 7-Zip in kontekskeuselys.
Trapsgewyse kontekskeuselys
Kontekskeuselysitems:
2320
<Gids>
<Argief>
Open
Pak lers uit...
Voeg by argief...
Toets argief
Pak hier uit
Pak uit in {0}
Voeg by {0}
Saampers en e-pos...
Pers saam in {0} en e-pos
2400
Gidse
&Werkgids
&TEMP-gids van het stelsel
&Huidige gids
&Gespesifiseerde gids:
Gebruik slegs vir verwisselbare media.
Spesifiseer die stoorplek vir tydelyke argieflers.
2500
Instellings
Wys ".." &item
Wys &ware lerikone
Wys &stelselkeuselys
Wys seleksie oor &hele ry(e)
Wys &roosterlyne



2900
Aangaande 7-Zip
7-Zip is gratis programmatuur. Indien u egter so baie van 7-Zip hou dat u die verdere ontwikkeling wil ondersteun, registreer dan asb. met 'n geldelike donasie aan die 7-Zip Projek.
3000

Daar is geen foute nie
{0} objekt(e) is geselekteer
Kan gids '{0}' nie maak nie
Bywerk-funksie word vir hierdie argief nie ondersteun nie.




Ler '{0}' is gewysig.\nWil u dit bywerk in die argief?
Kan ler\n'{0}' nie bywerk nie
Redigeerder nie aan die gang gesit word nie.




Te veel items
3300
Besig om uit te pak
Besig met saampersing
Besig om te toets
Besig om oop te maak...

3400
&Uitpak
U&itpak in:
Gee 'n bestemming vir uitgepakte lers.
3410
Pad-metode
Volledige padname
Geen padname
3420
Vervang lers
Vervang slegs met bevestiging
Vervang sonder bevestiging
Slaan bestaande lers oor
Hernoem outomaties
Hernoem bestaande lers outomaties
3500
Bevestig leroorskrywing
Doelgids bevat alreeds 'n ler met hierdie naam.
Wil u die bestaande ler vervang
deur hierdie ler ?
{0} grepe
O&utomaties hernoem
3700
Nie-ondersteunde saampersmetode vir '{0}'.
Datafout in '{0}'. Ler is beskadig.
CRC het misluk in '{0}'. Ler is beskadig.


3800
Tik wagwoord in
Tik wagwoord in:

&Wys wagwoord



&Wagwoord
3900
Tydsduur sovr:
Oorblywende tyd:
Grootte:
Spoed:


Foute:

4000
Voeg by argief
&Argief:
&Bywerkwyse:
Argie&fformaat:
Saampersingv&lak:
&Saampersmetode:
&Woordeboekgrootte:
&Woordgrootte:


Pa&rameters:
Opsies
Maak SF&X argief



Enkripteer ler&name
Geheuegebruik vir saampersing:
Geheuegebruik vir uitpakking:
4050
Stoor
Vinnigste
Vinnig
Normaal
Maksimum
Ultra
4060
Lers byvoeg en vervang
Lers bywerk en byvoeg
Verfris bestaande lers
Sinkroniseer lers
4070
Blaai
Alle lers


6000
Kopieer
Verskuif
Kopieer na:
Verskuif na:
Besig met kopiring...
Besig met verskuiwing...
Besig met hernoeming...

Bewerking word nie ondersteun nie.
Fout by hernoeming van ler of gids


6100
Bevestig lerverwydering
Bevestig gidsverwydering
Bevestig verwydering van meerdere lers
Is u seker dat u '{0}' wil verwyder?
Is u seker dat u gids '{0}' asook die inhoud daarvan wil verwyder?
Is u seker dat u hierdie {0} items wil verwyder?
Besig met verwydering...
Fout by verwydering van ler of gids

6300
Maak gids
Maak ler
Naam van die gids:
Lernaam:
Nuwe gids
Nuwe ler
Fout by maak van gids
Fout by maak van nuwe ler
6400


Selekteer
Deselekteer
Masker:
6600

Gidse-geskiedenis
Diagnostiese boodskappe
Boodskap
7100
Rekenaar
Network

Stelsel
7200
Voeg by
Pak uit
Toets
Kopier
Skuif
Vee uit
Intigting
7300
Verdeel ler
&Verdeel na:
Verdeel in &volumes, aantal grepe:
Besig met verdeling...





7400
Kombineer lers
&Kombineer na:
Besig met kombinering...



7500




7600
Meet
Geheuegebruik:
Inpakking
Uitpakking
Gradering
Totale gradering
Huidige
Resultaat


Lopies:
;!@Lang2@!UTF-8!
;       : Feliciano Martnez Tur
;  9.07 : Juan Pablo Martnez
;
;
;
;
;
;
;
;
;
0
7-Zip
Aragonese
Aragons
401
Acceptar
Cancelar



&S
&No
&Zarrar
Aduya

&Continar
440
S a &tot
No a t&ot
Aturar
Tornar a empecipiar
Se&gundo plano
P&rimer plano
&Pausa
Aturau
Yes seguro que quiers cancelar?
500
&Fichero
&Editar
&Veyer
&Favoritos
&Ferramientas
Ad&uya
540
&Ubrir
Ubrir &adintro
Ubrir &difuera
&Veyer
&Editar
Re&nombrar
&Copiar en...
&Mover ta...
&Borrar
Di&vidir o fichero...
C&ombinar os fichers...
&Propiedatz
Comen&tario
Calcular a suma de comprebacin
Diff
Creyar carpeta
Creyar fichero
&Salir
600
Seleccionar-lo &tot
Deseleccionar-lo tot
&Invertir seleccin
Seleccionar...
Deseleccionar...
Seleccionar por tipo
Deseleccionar por tipo
700
Iconos g&rans
&Iconos chicotz
&Lista
&Detalles
730
Desordenau
Anvista plana
&2 panels
&Barras de ferramientas
Ubrir a carpeta radiz
Carpeta mai
Historial de carpetas...
&Esviellar
750
Barra de ferramientas d'archivo
Barras de ferramientas estandard
Botons grans
Amostrar texto en os botons
800
&Adhibir carpeta a favoritos como
Adhibir a favoritos
900
&Opcions...
&Prebas de referencia (benchmark)
960
&Conteniu...
A&rredol de 7-Zip...
1003
Rota
Nombre
Tipo de fichero
Carpeta
Grandaria
Grandaria comprimida
Atributos
Creyau
Zaguer acceso
Zaguera modificacin
Compacto
Comentario
Zifrau
Expandiu antis
Expandiu dimpus
Diccionario
CRC
Tipo
Anti
Metodo
SO d'orichen
Sistema de fichers
Usuario
Grupo
Bloque
Comentario
Posicin
Prefixo de rota
Carpeta
Fichers
Versin
Fragmento
Multiframento
Desplazamiento
Vinclos
Bloques
Fragmentos

64-bit
Big-endian
CPU
Grandaria fisica
Grandaria d'as cabeceras
Suma de comprebacin
Caracteristicas
Adreza virtual
ID
Nombre curto
Aplicacin creyadera
Grandaria de sector
Modo
Vinclo
Error
Espacio total
Espacio libre
Grandaria de sector
Etiqueta
Nombre local
Proveyedor
2100
Opcions
Luenga
Luenga:
Editor
&Editor:
&Diff:
2200
Sistema
Asociar 7-Zip con:
2301
Integrar 7-Zip en o men contextual de Windows
Men contextual en cascada
Elementos d'o men contextual:
2320
<Carpeta>
<Archivo>
Ubrir archivo
Extrayer-ne os fichers...
Adhibir a l'archivo...
Comprebar l'archivo
Extrayer aqu
Extrayer en {0}
Adhibir a {0}
Comprimir y ninviar por correu...
Comprimir en {0} y ninviar por correu
2400
Carpeta
Carpeta de &treballo
Carpeta temporal d'o &sistema
Carpeta &actual
&Especificar una carpeta:
No emplegar que ta dispositivos extrayibles
Especificar una carpeta ta archivos temporals.
2500
Propiedatz
Amostrar l'elemento ".."
Amostrar iconos propios
Amostrar o men d'o sistema
&Seleccionar ringlera(s) completa(s)
Amostrar as linias d'a &quadricla
Clicar una vegada ta ubrir elemento
Modo de seleccin &alternativo
Emplegar pachinas de memoria &grans
2900
Arredol de 7-Zip
7-Zip ye un programa libre y gratuito. Si quiers, puetz colaborar en o desembolique de 7-Zip rechistrando-te ta contribuyir a amillorar o programa.
3000
O sistema no ha puesto asignar a cantidat necesaria de memoria
No i hai errors
{0} elemento(s) seleccionau(s)
No se puet creyar a carpeta '{0}'
Ista mena d'archivo no permite actualizacin.
No se puet ubrir o fichero '{0}' como archivo comprimiu
No se puet ubrir l'archivo zifrau '{0}'. Comprebe si a clau ye incorrecta.
Tipo d'archivo no admeso
O fichero {0} ya existe
O fichero '{0}' s'ha modificau.\nQuiers esviellar-lo en l'archivo?
No se puet esviellar o fichero\n'{0}'
No se puet executar l'editor.
O fichero pareix un virus (o nombre d'o fichero contiene espacios largos).
No se puet execitar ista operacin dende una carpeta que tienga una rota larga.
Has de seleccionar un fichero
Has de seleccionar un u ms fichers
Masiaus elementos
3300
Extrayendo
comprimindo
Prebando
Ubrindo...
Buscando...
3400
Extrayer
E&xtrayer a:
Selecciona un destn ta os fichers extrayius.
3410
Modo de rota
Rotas completas
Sin rotas
3420
Modo de sobrescritura
Con confirmacin
Sin confirmacin
Conservar os fichers ya existents
Renombrar automaticament
Renombrar automaticament os fichers ya existents
3500
Confirmar a substitucin de fichers
A carpeta de destn ya contiene un fichero con o mesmo nombre.
Quiers substituyir o fichero existent
por iste atro?
{0} bytes
Renombrar a&utomaticament
3700
Metodo de compresin no valido ta '{0}'.
Error de datos en '{0}'. O fichero ye corrompiu.
O CRC ha fallau en '{0}'. O fichero ye corrompiu.
Error de datos en o fichero zifrau '{0}'. Verifica a clau.
Error de CRC en o fichero zifrau '{0}'. Verifica a clau.
3800
Escribe a clau
Escribe a clau:
Torne a escribir a clau:
&Amostrar a clau
As claus son diferents. Por favor, torne a escribir-la.
Emplega en a clau noms as letras de l'alfabeto angls, numeros y caracters especials (!, #, $, ...)
A clau ye masiau larga.
Contrasenya
3900
Tiempo transcorriu:
Tiempo pendient:
Grandaria:
Velocidat:
Procesau:
Razn de compresin:
Errors:
Archivos:
4000
Adhibir a l'archivo
&Archivo:
M&odo d'actualizacin:
&Formato d'archivo:
&Libel de compresin:
&Metodo de compresin:
Grandaria de &diccionario:
Granda&ria d'a parola:
Grandaria de bloque compacto:
Numero de filos d'a CPU:
&Parametros:
Opcions
Creyar archivo SF&X (autoextrayible)
Comprimir fichers compartius
Encriptacin
Metodo d'e &zifrau:
Zifrar &nombres de fichero
Memoria emplegada ta comprimir:
Memoria emplegada ta descomprimir:
4050
Sin compresin
A mas rapida
Rapida
Normal
Maxima
Ultra
4060
Adhibir y substituyir fichers
Esviellar y adhibir-ie fichers
Esviellar fichers ya presents
Sincronizar fichers
4070
Explorar
Totz os fichers
No compacto
Compacto
6000
Copiar
Mover
Copiar en:
Mover ta:
Copiando...
Movendo...
Renombrando...
Selecciona a carpeta de destn
Operacin no permitida.
Error en enombrar un fichero u carpeta
Confirmar a copia d'o fichero
Yes seguro de que quiers copiar os fichers en l'archivo
6100
Confirmar borrau de fichero
Confirmar borrau de carpeta
Confirmar borrau multiple fichers
Yes seguro que quiers borrar '{0}'?
Yes seguro que quiers borrar a carpeta '{0}' y tot o suyo conteniu?
Yes seguro que quiers borrar istos {0} elementos?
Borrando...
Error borrando fichero u carpeta
O sistema no puet mover un fichero con rota larga ta la Papelera de Reciclache
6300
Creyar carpeta
Creyar fichero
Nombre de'a carpeta:
Nombre de'o fichero:
Carpeta nueva
Fichero nuevo
Error en creyar carpeta
Error en creyar o fichero:
6400
Comentario
&Comentario:
Seleccionar
Deseleccionar
Patrn:
6600
Propiedatz
Historial de carpetas
Mensaches de diagnostico
Mensache
7100
O mo ordinador
Entorno de ret
Documentos
Sistema
7200
Adhibir
Extrayer
Prebar
Copiar
Mover
Borrar
Informacin
7300
Dividir fichero
Di&vidir a:
Dividir en fra&gmentos (bytes):
Dividindo...
Confirmar a divisin
Yes seguro que quiers dividir o fichero en {0} fragmentos?
A grandaria d'os fragmentos ha d'estar menor que a d'o fichero orichinal
Grandaria de fragmento incorrecta
Grandaria de fragmento especificada: {0} bytes.\nYe seguro que quiere dividir o fichero en fragmentos d'ixa grandaria?
7400
Combinar fichers
&Combinar en:
Combinando...
Selecciona noms o primer fichero
No s'ha puesto detectar o fichero como parti d'un fichero por fragmentos
No s'ha puesto trobar que un fragmento d'o fichero por fragmentos
7500
Calculando a suma de verificacin...
Suma de verificacin (CRC)
CRC d'os datos:
CRC d'os datos y os nombres:
7600
Prebas de referencia (benchmark)
Emplego de memoria:
Compresin
Descompresin
Taxa
Taxa total
Actual
Resultant
Emplego de CPU
Taxa / Emplego
Pasadas:
;!@Lang2@!UTF-8!
;  9.07 : Awadh A Al-Ghaamdi
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Arabic

401

 



&
&
&


&
440
 
 

 
&
&
& 
 
    
500
&
&
&
&
&
&
540
&
& 
& 
&
&
 
.. 
.. 
&
& ...
& ...
&
&
  

 
 

600
 
  
 

 
  
   
700
 
 
&
&
730

 
&
& 
  
  
... 
&
750
  
  
 
  
800
&   

900
...&
& 
960
..&
7-Zip &...
1003





 







 
 

CRC



 
 





 



 
  



 

64-bit
Big-endian
CPU
 
 
 

 

 
 
 



 
 
 

 

2100


   - 

&:
&:
2200

   :
2301
    
   
   :
2320
<>
<>

 ...
  ...
 
 
  {0}
  {0}
  ...
  {0}  
2400

& 
&  
&
&:
   
    
2500

".."  
   
  
&  
  
    
&  
 &  
2900

             20 .          
3000
      
  
  {0} 
'{0}'    
     
 '{0}'    
    . '{0}'    
   
  {0} 
    \n '{0}'  
   \n'{0}'
   
(   (     
        
   
     
  
3300



......
... 
3400

 :
   
3410
 
  
  
3420
  
   
   
  
 
    
3500
  
    
   
 
{0} 
  
3700
'{0}'    
'{0}'  .  
'{0}'    .  
     '{0}' .     
      '{0}' .     
3800
  
  :
   :
&  
   
         (!,#,,$ ...)  
   
 
3900
 :
 :
 :
:
:
 :
:
 :
4000
 
&:
& :
 :
 &:
 :
& :
& :
   :
CPU    :
& :

   
  

  :
  &
   :
    :
4050






4060
  
   
   
 
4070

 
 

6000


 :
 :
......
......
 ...
  
  
       
  
      
6100
  
  
  
' {0}'    
      '{0}'    
 {0}       
...
      
          
6300
 
 
 :
 :
 
 
    
    
6400

&:

 

6600

 
 

7100
 



7200







7300
 
& :
   :
...
 
      {0}  
         
   
   : {0} \n         
7400
 
& :
...
      
        
          
7500
...   
  
 CRC  :
   CRC  :
7600
 
 :

 

 


CPU  
 / 
:
;!@Lang2@!UTF-8!
;  4.07 : Dinamiteru
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Asturian
Asturianu
401
Val
Torgar



&Si
&Non
&Zarrar
Axuda

&Siguir
440
Si a &Too
Non a T&oo
Parar
Reentamar
&De fondu
&En primer planu
&Posar
Posao
Tas fixu que quies paralo?
500
F&icheru
&Remanar
&Ver
F&avoritos
&Ferramientes
A&xuda
540
&Abrir
Abrir &Dientro
Abrir F&uera
&Ver
&Remanar
Reno&mar
&Copiar a...
&Mover a...
&Borrar
&Partir ficheru...
Com&binar ficheros...
P&ropiedaes
Come&ntariu


Crear carpeta
Crear ficheru
Co&lar
600
Seleicionar &Too
Deseleicionar too
&Invertir seleicin
Seleicionar...
Deseleicionar...
Seleicionar por Tipu
Deseleicionar por Tipu
700
Miniatures &Grandes
&Miniatures Pequees
&Llista
&Detalles
730
Ensn Ordenar

&2 Paneles
&Barres de Ferramientes
Abrir Carpeta Raiz
Xubir Un Nivel
Hestorial de Carpetes...
Actualiza&r
750
Barra Ferramientes dArchivu
Barra Ferramientes Normal
Botones Grandes
Amosar Testu nos Botones
800
&Aedir carpeta a Favoritos como
Marca
900
&Opciones...
&Bancu de Pruebes
960
&Contenos...
&Al rodiu 7-Zip...
1003
Ruta
Nome
Estensin
Carpeta
Tamau
Tamau comprimo
Atributos
Creao
Accedo
Cambiao
Slidu
Comentao
Cifrao
Partir antes
Partir dempus
Diccionariu
CRC
Tipu
Anti
Mtodu
S.O. dAcoyida
Sistema de ficheros
Usuariu
Grupu
Bloque
Comentariu
Posicin

























Error
Tamau total
Espaciu llibre
Tamau del clster
Etiqueta
Nome llocal
Suministrador
2100
Opciones
Llingua
Llingua:
Remanaor
&Remanaor:

2200
Sistema
Asociar 7-Zip con:
2301
Integrar 7-Zip nel men contestual
Men contestual en cascada
Artculos del men contestual:
2320
<Carpeta>
<Archivu>
Abrir archivu
Estrayer ficheros...
Aedir al archivu...
Probar archivu
Estrayer equ
Estrayer a {0}
Aedir a {0}
Comprimir y mandar per correu...
Comprimir en {0} y mandar per correu
2400
Carpetes
&Carpeta de trabayu
Carpeta &temporal de sistema
&Actual
&Especificar:
Usar slo pa dispositivos estrayibles
Especificar llocalizacin pa ficheros darchivos temporales.
2500
Iges
Amosar ".." artculu
Amosar les miniatures reales del ficheru
Amosar men del sistema
Seleicionar tola &fila
Amosar les llinies de la &cuadrcula



2900
Al rodiu 7-Zip
7-Zip ye software llibre. De toos moos, t pues sofitar el desendolcu de 7-Zip rexistrndote.
3000

Ensn errores
{0} oxetu(os) seleicionaos
Nun se puede crear la carpeta '{0}'
Esti archivu nun permite les operaciones dactualizacin.




El ficheru '{0}' foi modificu.\nDo Quies actualizalu nel archivu?
Nun se pudo actualizar larchivu\n'{0}'
Nun se pudo entamar el Remanaor.




Demasiaos artculos
3300
Estrayendo
Comprimiendo
Probando
Abriendo...

3400
Estrayer
E&strayer a:
Especificar llocalizacin pa ficheros estrayos.
3410
Mou de ruta
Nomes de ruta completos
Ensn nomes de ruta
3420
Mou de sobreescritura
Entrugar enantes de sobreescribir
Sobreescribir ensn confirmacin
Dexar ficheros esistentes
Auto renomar
Auto renomar ficheros esistentes
3500
Confirmar sustitucin de ficheros
La carpeta destn y tien el ficheru procesu.
Quis sustituyir el ficheru esistente
con esti otru?
{0} bytes
A&uto Renomar
3700
Mtodu de compresin nun permitu pa '{0}'.
Error de datos en '{0}'. El ficheru ta rotu.
El CRC fall en '{0}'. El ficheru ta rotu.


3800
Introduz clave
Introduz clave:

Amo&sar clave



Clave
3900
Tiempu trescurru:
Tiempu pa finar:
Tamau:
Velocid:


Errores:

4000
Aedir al archivu
&Archivu:
Mo&u dactualizacin:
&Formatu del archivu:
Nive&l de compresin:
&Mtodu de compresin:
Tamau del &Diccionariu:
Tamau de la pa&llabra:


&Parmetros:
Opciones
Crear archivu SF&X



Cifrar &nomes de ficheru
Usu de memoria pa la compresin:
Usu de memoria pa la descompresin:
4050
Nenguna
Ms rpida
Rpida
Normal
Msima
Ultra
4060
Aedir y sustituyir ficheros
Actualizar y aedir ficheros
Actualizar ficheros esistentes
Sincronizar ficheros
4070
Ageyar
Tolos ficheros


6000
Copiar
Mover
Copiar a:
Mover a:
Copiando...
Moviendo...
Renomando...

La operacin nun t permita.
Error al renomar el ficheru o carpeta


6100
Confirmar Borru de Ficheru
Confirmar Borru de Carpeta
Confirmar Borru Mltiple de Ficheros
Tas fixu que quies borrar '{0}'?
Tas fixu que quies borrar la carpeta '{0}' y tolos sos contenos?
Tas fixu que quies borrar estos {0} artculos?
Borrando...
Error al borrar el ficheru o carpeta

6300
Crear Carpeta
Crear ficheru
Nome de la carpeta:
Nome del ficheru:
Nueva carpeta
Nuevu ficheru
Error al crear la carpeta
Error al crear el ficheru
6400
Comentariu
&Comentariu:
Seleicionar
Deseleicionar
Mazcarita:
6600

Hestorial de carpetes
Mensaxes de diagnsticu
Mensax
7100
Ordenador
Rede de Trabayu

Sistema
7200
Aedir
Estrayer
Probar
Copiar
Mover
Borrar
Informacin
7300
Partir Ficheru
&Partir a:
Partir en &cachos, bytes:
Partiendo...





7400
Combinar Ficheros
&Combinar a:
Combinando...



7500




7600
Bancu de Pruebes
Usu de memoria:
Comprimiendo
Descomprimiendo
Valoracin
Valoracin total
Actual
Resultu


Correutos:
;!@Lang2@!UTF-8!
; 9.07 : F@rhad
; 15.02 : 22/05/2015 : . 
;
;
;
;
;
;
;
;
;
0
7-Zip
Azerbaijani
Azrbaycanca
401
OLDU
mtina



&Bli
&Xeyr
&Bala
Kmk

&Davam
440
&Hamsna Bli
Ha&msna Xeyr
Dayan
Yenidn bala
&Arxa planda
&nd
F&asil
Fasild
Hqiqtn mliyyat dayandrmaq istyirsiniz?
500
&Fayl
&Dzli
&Grn
S&eilmilr
&Vasitlr
&Aray
540
&A
&Daxild A
B&ayrda a
&Bax
&Dzli
Ye&nidn Adlandr
&Nsxl...
&Kr...
&Sil
Fayl &Bl...
Fayllar B&irldir...
X&susiyytlr
r&h...
Yoxlama Cmi
Mqayis
Qovluq Yarat
Fayl Yarat
&x
stinad
&vzedici Axnlar
600
&Hamsn Se
Seimi Lv Et
&Seimi evir
Se...
Seimi Lv Et...
Nvn Gr Se
Nvn Gr Seimi Lv Et
700
&Byk arlr
K&iik arlr
&Siyah
&Cdvl
730
eidsiz
Mstvi Grn
&2 Lvh
&Altlr Lvhlri
Kk Qovluu A
Bir Sviyy Yuxar
Qovluqlar Tarixsi...
&Yenil
Bilavasit Yenilm
750
Arxivlyicinin Dymlr Lvhsi
Sad Dymlr Lvhsi
Byk Dymlr
Dymlr zrind Mtnlr
800
&Qovluu Seilmilr Frqli lav Et
lfcin
900
Tnzimlmlr...
Smr Sna
960
&Balq...
7-Zip &Haqqnda...
1003
stiqamt
Ad
Genilm
Qovluq
l
Sxlm
Rmzlr
Yaranb
Aq
Dyiilib
Aramsz
rh
ifrlnib
vvlki para
Sonrak para
Lt

Nv
leyhin
Sxlma sulu
Qurulu
Fayl Quruluu
stifadi
Dst
Blm
rh
Mvqe
stiqamt
Qovluq
Fayl
Buraxl
Cild
ox Cildli
Uzlama
stinad
Blm
Cild



Prosessor
Fiziki l
Balqlar ls
Yoxlama Cmi
Xasslr
Xyali nvan

Qsa Ad
Yaradc
Sah ls
Vziyyt
Rmzi stinad
Xta
Cmi Hcm
Azad Hcm
Toplam Hcm
Nian
Qsa Ad
Tchizatc
NT Thlksizlik
vzedici Axn

Silinmi
Aac


Xta Nv
Xtalar
Xtalar
Xbrdarlqlar
Xbrdarlq
Axnlar
vzedici Axnlar
vzedici Axnlar ls
Xyali l
Ceidli l
mumi Fiziki l
Cild Nmrsi
Nvalt
Qsa rh
ifrlnmi Shif



Qalq ls
Ttbiq Olunmu Blm ls
stinad
Srt stinad
iNode

Yalnz Oxumaq n
2100
Tnzimlmlr
Dil
Dil:
Dzli
&Dzli:
&Mqayis:
2200
Qurulu
7-Zip Fayllarla laqlnsin
Btn stifadilr
2301
7-Zip hat tklifin ttbiq edilsin 
Zncirvari hat tklifi
nsrl hat tklifi:
hat tklifind nianlar
2320
<Qovluq>
<rxiv>
Arxivi A
eidl
Arxiv lav Et...
Snaq
Burda eidl
{0} eidl
{0} lav Et
Sx V E-Potla Gndr...
{0} Sx V E-Potla Gndr
2400
Qovluqlar
& Qovluu
&Mvqqti Qurulu Qovluu
&Cari
&Tyin Et:
Yalnz dyikn dayclar n istifad
Mvqqti arxivlr n yer gstr.
2500
Tnzimlmlr
".." nsrn gstr
Hqiqi fayl iarlri gstr
Qurulu tklifini gstr
Ox btn stir zr
Ayrclar Gstr 
Bir Toxunula A
vzedici vziyyt iarlnmsi
Byk yadda shiflri istifadsi
2900
7-Zip Haqqnda
7-Zip Srbst Yaylan Proqramdr
3000
Kifayt qdr bo yadda yoxdur
Shvlr taplmad
{0} Ayrlm hdf
'{0}' Qovluunu yaratmaq mmkn olmad
Bu arxiv n dyiiklik mliyat dstklnmir
'{0}' Fayln arxiv kimi amaq alnmad
ifrlnmi '{0}' arxivini amaq alnmad. Yanl ifr?
Dstklnmyn arxiv
{0} fayl artq mvcuddur
'{0}' faylna dyiiklik edildi.\nSiz onu arxivd yenilmk istyirsiz? 
\n'{0}' fayln yenilmk alnmad
Redaktni i salmaq alnmad
Fayl zrrvericiy oxayr (fayln ad uzun boluq ardcll tkil edir).
mliyyat uzun yol tkil edn qovluqdan icra oluna bilmir.
Siz bir fayl semlisiniz
Siz bir v ya bir ne fayl semlisiniz
Hddn ox nsr
Fayl, '{0}' arxivi kimi amaq alnmad
Fayl, {0} arxivi kimi ald
Arxiv vzlnrk ald
3300
eidlnm
Sxlma
Snaq
Alma...
Yoxlama...
Silinm
3320
lav Etmk
Yenilnm
Thlil
Nsxlnm
Yenidn eidlnm
Kem cazsi
Silinm
Balqlar Yaradlmas
3400
Ayr
&eidl:
Ayrlan fayllarn yerini gstrin.
3410
Fayllara istiqamt:
Tam istiqamtlr
stiqamtsiz
Mtlq istiqamtlr
Nisbi istiqamtlr
3420
Yenidn yazlma:
Tsdiqli
Tsdiqsiz
trmk
Birbaa yenidn adlandr
Mvcud olanlar yenidn adlandr
3430
Kk qovluqla bnzrliyi aradan qaldr
Fayln thlksizlik brpas 
3500
Fayln vzlnm tsdiqi
Qovluq artq emal olunan fayl tkil edir.
Mvcud fayl vzl
nvbti faylla?
{0} bayt
Birbaa yenidn adlandr
3700
'{0}' faylnn dstklnmyn sxlma sulu.
'{0}' mlumatlarnda xta. Fayl korlanb.
'{0}' CRC xtas. Fayl korlanb.
'{0}' ifrli fayl mlumatlarnda xta. Yanl ifr?
'{0}' ifrli fayl n CRC xtas. Yanl ifr?
3710
Yanl ifr?
3721
Dstklnmyn sxlma sulu
Dlillrd xta
CRC xtas
Mvcud olmayan dlillr
Dlillrin gzlnilmz sonu
Blmnin sonunda faydal dlillr olduuna dlillr var
Arxiv deyil
Balqlarda Xta
Yanl ifr
3763
Arxivin vvli mvcud deyil
Tsdiqsiz arxiv vvli



Dstklnmyn xsusiyyt
3800
ifr daxil etm
&ifr daxil edin:
ifrni tkrarlayn:
&ifrni gstr
ifrlr uyun deyil
ifr n yalnz latn hrflri, rqmlr v xsusi rmzlr istifad edin (!, #, $, ...)
ifr ox uzundur
&ifr
3900
Kedi:
Qalb:
Cmi:
Srt:
l:
Sxlma drcsi:
Xta:
Arxiv:
4000
Arxiv lav etmk
&Arxiv:
&Dyim vziyyti:
Arxiv &qismi:
Sxlma &drcsi:
Sxlma &sulu:
&Lt ls:
&Sz ls:
Blm ls:
Axn say:
&Nizamlar:
&Seimlr
SF&X arxiv yarat
Yazl n aq fayllar sx
ifrlm
ifrlm sulu:
Fayl adlarn &ifrl
Qabladrma n yadda hcmi:
eidlm n yadda hcmi:
Sxlmadan sonra fayllar sil
4040
Rmzli keidlri saxla
Srt keidlri saxla
vzedici axnlar saxla
Giri hququnu saxla
4050
Sxlmasz
Srtli
Cld
Mqbul
Yksk
Daha Yksk (Ultra)
4060
lav et v vzl
Yenil v lav et
Yenil
Eynildir (Sinxron)
4070
Vrql
Btn Fayllar
Fayl lsn gr
Aramsz
6000
Nsxl
Kr
Nsxl:
Kr:
Nsxllnm...
Krlm...
Yenidn adlandrlma...
Qovluu gstrin.
mliyyat bu qovluq n dstklnmir.
Fayl v ya Qovluun Yenidn Adlandrlmas Zaman Xta 
Fayllarn Nsxllnm Tsdiqi
Siz hqiqtn bu fayllar arxiv nsxlmk istyirsiz
6100
Fayl silinm tsdiqi
Qovluq silinm tsdiqi
Fayllar dstsinin silinm tsdiqi
Siz hqiqtn "{0}" silmk istyirsiz?
Siz hqiqtn "{0}" qovluunu v onun btn mzmununu silmk istyirsiz?
Siz hqiqtn {0} hdfi silmk istyirsiz?
Silinm...
Fayl v ya Qovluq Silinmsi Zaman Xta
Qurulu uzun yollu fayllarn sbt silinmsi mliyyatn dstklmir
6300
Qovluq Yarat
Fayl Yarat
Qovluq Ad:
Fayl Ad:
Yeni Qovluq
Yeni Fayl
Qovluq Yaradlmas Zaman Zta
Fayl Yaradlmas Zaman Zta
6400
rh
&rh:
Sein
Seimi Lv Edin
zlk (Maska):
6600
Xasslr
Qovluqlar Tarixsi
smarclar
smarc
7100
Kompter
bk
Sndlr
Qurulu
7200
lav Et
Ayr
Snaq
Nsxl
Kr
Sil
Mlumat
7300
Fayl Blmk
&Blmk:
Cildlr &blmk, (bayt) ld:
Blnm...
Blnm Tsdiqi
Siz hqiqtn fayl {0} hissy blmk istyirsiz?
Cild ls ilkin fayl lsndn kiik olmaldr
Cildlrin l tyin etm sahsind xta
Tyin edilmi cild ls: {0} bayt.\nSiz hqiqtn arxivi bel cildlr blmk istyirsiniz?
7400
Fayllar Birldir
&Birldirmk:
Birlm...
Blnm fayln yalnz birinci hisssini semk lazmdr
Blnm fayln tannmas mmkn olmad
Blnm fayln birdn ox hisssini tapmaq mmkn olmad
7500
Yoxlanma cminin hesablanmas...
Yoxlanma cmi
Dlillr n CRC yoxlanma cmi:
Dlillr v adlar n CRC yoxlanma cmi:
7600
Smr Sina
Yadda Hcmi:
Qabladrma
eidlnm
Drc
mumi Drc
Cari
Ntic
Yklnm
Yklnm Drcsi
Keid:
7700
stinad
laqlndir
Mnb:
Mqsd:
7710
stinad Qismi
Srt stinad 
Rmzi stinad (Fayl)
Rmzi stinad (Qovluq)
Balant Nqtsi (Qovaq)
;!@Lang2@!UTF-8!
;  9.20 : Haqmar : www.bashqort.com
; 
;
;
;
;
;
;
;
;
;
0
7-Zip
Bashkir

401

 



&
&
&


&
440
  &
&  

 
& 
& 
& 

     ?
500
&
&
&
&
&
&
540
&
& 
& 
&
&
& 
&...
&...
&
 &...
 &...
&
&
 
Diff
 ...
 &...
&
600
&  
&  
&  
  ...
 ...
  
   
700
& 
& 
&
&
730
 
  
&2 
& 
  
  
 ...
&
750
& 
 
 
 
800
   :

900
&...
& 
960
&...
7-Zip &h...
1003





 







 
 

CRC




 

T



 




 





64-bit
Big-endian

 
 
 

 
ID
 

 



 
 
 

 

2100

 
:

&:
&Diff:
2200

7-Zip  :
2301
  7-Zip- 
  
  :
2320
<>
<>
 
 ...
 ...
 
 
{0}  
{0}  
, e-mail  ...
{0}    e-mail  
2400

& 
&  
&
&:
    
    .
2500

".."  
   
  
  
 
   
  
   
2900
7-Zip h
7-Zip    .
3000
  
 
{0}  
{0}   
     .
'{0}'     
 '{0}'   .  ?
  
{0}  
'{0}'  .\n   ?
  \n'{0}'
  .
   (  -     ).
      .
   
     
  
3300
 ...
 ...

...
 ...
3400

 &:
    .
3410
 
&  
  
3420
 
&   
&   
   
  
    
3500
  
    .

   ?
{0} 
&  
3700
'{0}'     .
'{0}'    .  .
'{0}'  CRC  .  .
 '{0}'   .  ?
 '{0}'  CRC .  ?
3800
 
& :
&  :
& 
  
    ,     (!, #, $, ...) 
  

3900
 :
 :
:
:
:
 :
:
:
4000

&:
& :
& :
 &:
& :
& :
 &:
 :
 :
&:
&
SFX & 
   

 :
&  
  :
  :
4050

 




4060
  
  


4070

 
  

6000
 

  :
 :
 ...
...
  ...
 .
  
      
  
   ?
6100
  
  
    
'{0}' ?
'{0}'    ?
{0}  ?
 ...
    
      
6300
 h
 h
 :
 :
 
 
  
  
6400

&:
h
  
:
6600

 


7100




7200



 



7300
 
&  :
/&  :
 ...
 
  {0}   ?
      
  
  : {0} .\n    ?
7400
 
&  :
 ...
     
   
      
7500
   ...
 
  CRC  :
    CRC  :
7600
 
 :



 


 
 / . .
:
;!@Lang2@!UTF-8!
;                    : Kirill Gulyakevitch
;  9.07 : 2011-03-15 : Drive DRKA
;
;
;
;
;
;
;
;
;
0
7-Zip
Belarusian

401
OK




&
&
&


&
440
  &
  &


&
&  
&
 
    ?
500
&
&
&
&
&
&
540
&
 &
 &

&
&
& ...
& ...
&
& ...
&' ...
&
&
 
Diff
& 
& 
&
600
 &
 
& &
...
 ...
  
   
700
& 
& 
&
&
730
 
 
&2 
& 
  
    
 ...
&
750
  
  
 
  
800
   & 

900
...
 
960
&...
 &...
1003













 
 

CRC




 
















64-bit
Big-endian

 
 
 

 
ID
 I

 
i




 

 

2100


:

&:
&Diff:
2200

 7-Zip  :
2301
 7-Zip    
  
  :
2320
<>
<>
 

  ...

 
  {0}
  {0}
    email...
  {0}    email
2400

& 
&  
&
&:
    
    .
2500

  ".."
   
  
   
 
   i
  
   
2900
  7-Zip
7-Zip '   .       7-Zip,    .  Drive DRKA.  : drka2003@mail.ru.    2007 .
3000
  
  
 ': {0}
    '{0}'
      .
    '{0}'  
     '{0}'.  ?
  
 {0}  
 '{0}'  .\n     ?
   \n'{0}'
   
    (     ).
      ,    .
    
      
  
3300



...
...
3400

& :
    .
3410

& 
& 
3420

& 
& 
&
 .
. . .
3500
  
    .
  
 ?
{0} 
 .
3700
     '{0}'.
    '{0}'.  .
 CRC  '{0}'.  .
     '{0}'.  ?
 CRC    '{0}'.  ?
3800
 
& :
& :
& 
  
      ,     (!, #, $, ...)
  
&
3900
:
:
:
:
:
 :
:
:
4000
  
&:
& :
& :
& :
& :
 &:
 &:
 :
 :
&:
&
 SF&X-
    

 :
&  
'   :
'   :
4050
 





4060
  
  


4070

 
  

6000


 :
 :
...
...
...
 .
     .
     
  
       
6100
  
  
   
    "{0}"?
     "{0}"    ?
     ' ({0} .)?
...
     
          
6300
 
 
 :
 :
 
 
   
   
6400

&:

 
:
6600

 


7100




7200







7300
 
& :
  &  ( ):
...
  
      {0} ?
       
      
  : {0} .\n       ?
7400
' 
&' :
'...
      
    
       
7500
  ...
 
  CRC  :
  CRC    :
7600
 
' :



 



 / .
:
;!@Lang2@!UTF-8!
;       : chavv
;       : icobgr
;  4.65 : Vassia Atanassova
;
;
;
;
;
;
;
;
0
7-Zip
Bulgarian

401
OK




&
&
&


&
440
  &
  &

 
& 
& 
&
 
    ?
500
&
&
&
&
&
&
540
&
 &
 &
&
&
&
& ...
& ...
&
&  ...
&  ...
&
&
   

  
  
&
600
&  
&  
&  
...
...
  
  
700
& 
& 
&
&
730

 
&2 
&  
   
  
  ...
&
750
  
 
 
    
800
&    :

900
&...
&
960
&...
& 7-zip...
1003





 







 
 

CRC



 
 





  




Multivolume
Offset
Links
Blocks


64-
Big-endian
CPU
 
   
 

 







 
 
  

 

2100


:

&:

2200

  7-Zip :
2301
  7-Zip     
  
   :
2320
<>
<>
  
  ...
  ...
  
 
  {0}
  {0}
  ...
  {0}  
2400

& 
& TEMP 
&
&:
    
     .
2500

   ".."
     
   
&   
   &

&   
  &   
2900

7-Zip     .  ,      7-zip,   .
3000
       .
   
{0} () 
      '{0}'
      .
 '{0}'       
  '{0}'     .   ?
  ,    
 {0}  
 '{0}'   .\n       ?
      \n'{0}'
     .
    (     ).
           .
     
       
  
3300



...
...
3400

& :
     .
3410
  
 
 
3420
  
  
  
   
 
    
3500
   
      .
     
  ?
{0} 
& 
3700
      '{0}'.
    '{0}'.   .
       '{0}'.   .
      '{0}'.   ?
         '{0}'.   ?
3800
 
 :
  :
&  
   
      ,     (!, #, $, ...)
   
&
3900
 :
 :
:
:
:
  :
:
:
4000
  
&:
  :
  :
&  :
  :
  &:
  &:
   :
  :
&:
&
&  
  

  :
   &
   :
   :
4050
 
-




4060
    
    
   
  
4070

 
Non-solid
 (solid) 
6000


 :
 :
...
...
...
   .
      .
      
    
  ,       ?
6100
    
    
     
  ,     '{0}'?
  ,      '{0}'    ?
  ,      {0} ?
...
      
         
6300
  
  
  :
  :
 
 
    
    
6400

&:


:
6600

  
 

7100




7200







7300
  
& :
  &, :
...
  
  ,       {0} ?
      -     
   
   : {0} .\n  ,          ?
7400
  
& :
...
       
         
         
7500
   ...
   
CRC    :
CRC      :
7600

 :



 




 :
;!@Lang2@!UTF-8!
;  4.46 : Team Oruddho (Fahad Mohammad Shaon, Mahmud Hassan) : http://www.oruddho.com
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Bangla

401
 




&
&
& 


& 
440
&  
&  

 
&
& 
&
 
   ?
500
&
&
&
&
&
&
540
& 
7-zip-  
  
&
&
 
& ...
 ...
& 
& ...
 ...


Checksum  

 
 

600
 
  
 
...
  ...
  
    
700
 
 
&
&
730

 
& 
&
   
   ...
  ...
&
750
  
 
 
  
800
&    ...
 
900
&...
&
960
&...
&7-Zip ...
1003





 

 
 
 

Commented

 
 

CRC



  
 





  (Path Prefix)

























 
 
 

 

2100


:

  :

2200
 
7-Zip-   :
2301
  7-Zip 
      
  :
2320
<>
< >
   
 ...
  ...
  
 
   {0}
   {0}
  -...
 -  {0}  -
2400

& 
& 
&
&:
    
   
2500

".."  
   
   
  
  

  
  
2900
7-Zip 
7-Zip      7-Zip          
3000

  
{0} () 
'{0}'     
         
'{0}' -       
'{0}'       .  ?


 '{0}' .\n      ?
   \n'{0}'
    




  
3300
  
 
  ...
  ...
  ... (Scanning...)
3400

&  :
  
3410
  
 

3420
 
 
 
     
 
     
3500
   
    
     ?
 ?
{0} bytes
 
3700
   -'{0}'.
'{0}'   .  
'{0}'  CRC .  
'{0}'    .  ?
'{0}'   CRC .   ?
3800
  
  
   
& 
   
  ,     (!, #, $, ...)    
    

3900
 
  
:
:


 :

4000
 
&
& :
 & :
 &:
 &:
&Dictionary size:
&Word size:
Solid block size:
CPU- thread- :
&Parameters:

   
  
 
  :
  & 
   :
   :
4050
 
 



 
4060
   
   
   
  
4070

 
Non-solid
Solid
6000
 
    
  :
 :
  ...
 ...
 ...
  .
  
      
  
        
6100
     
     
     
     - '{0}'?
'{0}'          ?
 {0}       ?
  ...
      

6300
 
 
 :
 :
 
 
  
  
6400

&:

  
 :
6600

  
  

7100

 

 
7200



 

 

7300
 
&  :
volumes(), bytes()- 
  ...
  
    {0}    ?
        
  
   : {0} bytes.\n         ?
7400
  
&  :
 ...
    


7500
Checksum  ...
Checksum 
  CRC checksum:
    CRC checksum:
7600

  :
 ...
 ...

 


CPU  
Rating /  
 :
;!@Lang2@!UTF-8!
;  3.12 : KAD-Korvigello An Drouizig (drouizig.org).
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Breton
Brezhoneg
401
Mat eo
Nulla



&Ya
&Ket
&Serri
Skoazell

&Kenderc'hel
440
Ya be&pred
Ket &bepred
Paouez
Adloc'ha
&Drekleur
&Rakleur
&Ehan
Ehanet
Ha fellout a ra deoc'h nulla ?
500
&Restr
&Aoza
&Gwelout
Di&babo
&Ostilho
&Skoazell
540
&Digeri
Digeri a-zia&barzh
Digeri a-zia&vaez
&Gwelout
&Aoza
Adenv&el
&Kopia diwar...
&Dilec'hia diwar...
D&ilemel
&Troc'ha restr...
&Kendeuzi restro...
P&erzhio
Evezhia&denn


Sevel un teul
Sevel ur restr
&Kuitaat
600
Diuz pep &tra
Diziuz pe tra
Lakaat an &diuzad war an tu gin
Diuz...
Diziuz...
Diuz diouzh ar rizh
Diziuz diouzh ar rizh
700
Arlunio &bras
Arlunio &bihan
&Roll
&Munudo
730
Dirummet

&2 brenestr
&Barrenno ostilho
Digeri an teul gwrizienn
Teul kerent
Roll istor an teul...
Fresk&aat
750
Barrenn ziell
Barrenn skouerek
Meudellio bras
Diskouez an destenn
800
&Ouzhpenna ar c'havlec'h d'ar sinedo
Sined
900
&Dibabo...
&Amproui
960
&Roll ar pennado...
A-&zivout 7-Zip...
1003
Treug
Anv
Astenn
Teul
Ment
Gwasket
Doareenno
Savet d'ar
Stoket d'ar
Kemmet d'ar
Solut
Evezhiadenn
Ennodet
Ranna a-raok
Ranna war-lerc'h
Geriadur
CRC
Rizh
Enep
Hentenn
OS ostiz
Reizhiad restro
Implijour
Strollad
Bloc'h
Evezhiadenn
Lec'hiadur

























Fazi
Ment en holl
Egor vak
Ment ar c'hleusteurio
Skritellig
Anv lec'hel
Pourchaser
2100
Dibabo
Yezh
Yezh :
Embanner
&Embanner :

2200
Reizhiad
Kenstaga 7-Zip ouzh :
2301
Lakaat 7-Zip el laser kemperzhel
Laser kemperzhel a-steud
Elfenno al laser kemperzhel :
2320
<Teul>
<Diell>
Digeri
Eztenna ar restro...
Ouzhpenna d'an diell...
Gwiria an diell
Eztenna ama
Eztenna diwar {0}
Ouzhpenna da {0}
Gwaska ha kas dre postel...
Gwaska diwar {0} ha kas dre postel.
2400
Teulio
Teulio &labour
Teul dibadelus ar &reizhiad
Teul &red
Teul &spisaet :
Implijout nemet evit ar mediao dilec'hus
Spisait un teul evit lakaat ar restro diell dibadelus.
2500
Perzhio
Diskouez an elfenn ".."
Diskouez arlunio gwirion ar restro
Diskouez al laser reizhiad
&Diuz ar banno a-bezh
Diskouez al &linenno kael



2900
Kelo
Digoust eo ar meziant 7-Zip. Mar plij deoc'h 7-zip ha mar fell deoc'h skoazella ar raktres-ma e c'hellit donezoni argant da 7-Zip.
3000

N'eus fazi ebet
{0} elfenn ziuzet
N'haller ket sevel ar restr '{0}'
N'haller ket ober gant an oberiadenno nevesaat evti an diell-ma.




Kemmet ez eo bet ar restr '{0}'.\nHa fellout a ra deoc'h he nevesaat en diell ?
N'haller ket nevesaat\n'{0}'
N'haller ket loc'ha an embanner.




Re a elfenno
3300
Eztenna
O waska
Gwiria
O tigeri...

3400
Eztenna
E&ztenna diwar :
Dibabit un teul evit eztenna an restro.
3410
Treugo
Treugo klok
Treug ebet
3420
Mod erlec'hia
Goulenn a-raok erlec'hia
Erlec'hia hep goulenn
Lakaat ar restro a zo anezho a-gostez
Adenvel ent-emgefre ar restro a zo anezho

3500
Kadarnaat a-raok erlec'hia ur restr
Ema dija ur restr gant ar memes anv en teul bukenn.
Ha fellout a ra deoc'h lakaat e-lec'h
ar restr da heul ?
{0} eizhtet
Adenvel ent-&emgefre
3700
Hentenn waska direizh evit '{0}'.
Stlenn faziet e-barzh '{0}'. Gwastet eo ar restr.
Fazi ar reoli CRC evit '{0}'. Gwastet eo ar restr.


3800
Roit ar ger-tremen
Roit ar ger-tremen :

&Diskouez ar ger-tremen



Ger-tremen
3900
Amzer dremenet :
Amzer o chom :
Ment :
Tizh :


Fazio :

4000
Ouzhpenna d'an diell
&Diell :
&Mod nevesaat :
&Mentrezh an diell :
L&ive gwaska :
Rizh &gwaska:
&Ment ar geriadur :
Me&nt ar gerio :


&Perzhio:
&Dibabo
Sevel un diell SF&X



Ennodi an &anvio restro
Memor evit ar waskerezh :
Memor evit an diwaskerezh :
4050
Gwaska ebet
Prima
Prim
Reizh
Uhela
Gour
4060
Ouzhpenna hag erlec'hia ar restro
Nevesaat hag ouzhpenna ar restro
Freskaat ar restro a zo anezho
Goubreda ar restro
4070
Furchal
An holl restro


6000
Kopia
Dilec'hia
Kopia e-barzh :
Dilec'hia diwar :
O kopia...
O tilec'hia...
Oc'h adenvel...

N'haller ket ober an oberiadenn-ma.
Fazi oc'h adenvel ar restr pe an teul


6100
Kadarna a-raok dilemel ar restr
Kadarna a-raok dilemel an teul
Kadarna a-raok dilemel an holl restro
Ha fellout a ra deoc'h dilemel '{0}' ?
Ha fellout a ra deoc'h dilemel an teul '{0}' ha pep tra a zo e-barzh ?
Ha fellout a ra deoc'h dilemel ar {0} elfenn-ma ?
O tilemel...
Fazo o tilemel ar restr pe an teul

6300
Sevel un teul
Sevel ur restr
Anv an teul :
Anv restr :
Teul nevez
Restr nevez
Fazi o sevel an teul
Fazi o sevel ar restr
6400
Evezhiadenn
&Evezhiadenn :
Diuz
Diziuz
Kuzh :
6600

Roll istor an teulio
Kemenno yalc'h
Kemenn
7100
Urzhiataer
Rouedad

Reizhiad
7200
Ouzhpenna
Eztenna
Amproui
Kopia
Dilec'hia
Dilemel
Kelo
7300
Troc'ha restr
&Troc'ha da :
Troc'ha e &levrenno, eizhteto :
O troc'ha...





7400
Kendeuzi restro
&Kendeuzi da :
O kendeuzi...



7500




7600
Amproui
Implij ar vemor :
Gwaskerezh
Diwaskerezh
Feur
Feur en holl
Red
Da heul


Tremenio :
;!@Lang2@!UTF-8!
;  9.07 : Josep Casals, Marc Folch
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Catalan
Catal
401
D'acord
Cancel.la



&S
&No
Tan&ca
Ajuda

&Continua
440
S a &tot
No a t&ot
Atura
Reinicia
Rerefons
Primer pla
&Pausa
Aturat
Esteu segur que voleu cancel.lar?
500
&Fitxer
&Edita
&Visualitza
&Preferits
E&ines
Aj&uda
540
&Obre
Obre d&ins
Obre fora
&Visualitza
&Edita
Renom&ena
&Copia a...
&Moure a...
Suprimeix
&Divideix el fitxer...
Com&bina el fitxer...
P&ropietats
Come&ntari
Calcula el checksum
Diff
Crea carpeta
Crea fitxer
Surt
600
Seleccion&a-ho tot
Deselecciona-ho tot
&Inverteix selecci
Selecciona...
Deselecciona...
Selecciona per tipus
Deselecciona per tipus
700
Icones g&rans
Icones petites
&Llista
&Detalls
730
No ordenat
Vista plana
&2 Taules
&Barres d'eines
Obre carpeta arrel
Carpeta pare
Historial de carpetes...
&Actualitza
750
Barra d'eines afegeix/extreu
Barra d'eines estndard
Botons grans
Mostra botons amb text
800
&Afegeix la carpeta als Preferits com
Personal
900
Opcions...
&Test de referncia
960
&Contingut...
Quant a 7-Zip...
1003
Adrea
Nom
Tipus de fitxer
Carpeta
Mida
Mida comprimit
Atributs
Creat
Darrer accs
Darrera modificaci
Compacte
Comentari
Xifrat
Expandit abans
Expandit desprs
Diccionari
CRC
Tipus
Anti
Mtode
SO orgen
Sistema de fitxers
Usuari
Grup
Bloc
Comentari
Posici
Path Prefix
Carpetes
Fitxers
Versi
Volum
Multivolum
Desplaament
Enllaos
Blocs
Volums

64-bits
Big-endian
CPU
Mida fsica
Mida capaleres
Suma de verificaci
Caracterstiques
Adrea virtual
ID
Nom curt
Aplicaci creadora
Mida del sector
Mode
Enlla
Error
Mida total
Espai lliure
Mida sector
Etiqueta
Nom local
Provedor
2100
Opcions
Llengua
Llengua:
Editor
&Editor:
&Diff:
2200
Sistema
Associa 7-Zip amb:
2301
Integra 7-Zip dins el men contextual de Windows
Men contextual en cascada
Objectes del men contextual:
2320
<Carpeta>
<fitxer>
Obre
Extreu fitxers...
Afegeix al fitxer...
Comprova el fitxer
Extreu a aquesta carpeta
Extreu a {0}
Afegeix a {0}
Comprimeix i envia per correu electrnic...
Comprimeix a {0} i envia per correu electrnic
2400
Carpetes
Carpeta de &treball
Carpeta temporal del &sistema
Carpeta a&ctual
E&specifica una carpeta:
Utilitza nicament per a discs extrables
Especifica una carpeta pels fitxers temporals.
2500
Selecci
Mostra l'element ".."
Mostra icones reals dels fitxers
Mostra el men de sistema
&Selecci de columna completa
Mostra les lnies de &graella
Obre amb un sol clic els elements
Mode de selecci &alternatiu
Usa pgines de memria &grans
2900
Informaci sobre 7-Zip
7-Zip s programari lliure. De totes maneres, podeu col.laborar en el seu desenvolupament registrant el programa.
3000
El sistema no pot assignar la quantitat de memria requerida
No hi ha errors
{0} objecte(s) seleccionat(s)
No es pot crear la carpeta '{0}'
Aquest tipus de fitxer no permet actualitzaci.
No es pot obrir el fitxe '{0}' com a arxiu
No es pot obrir el fitxer xifrat '{0}'. La contrasenya s incorrecta?
Tipus d'arxiu no adms
El fitxer {0} ja existeix
El fitxer '{0}' ha estat modificat.\nVoleu actualitzar-lo a l'arxiu?
No pot actualitzar-se el fitxer\n'{0}'
No pot executar-se l'editor.
El fitxer sembla un virus (el nom del fitxer cont espais molt llargs al nom).
L'operaci no es pot cridar des d'una carpeta amb una ruta llarga.
Heu de seleccionar un fitxer
Heu de seleccionar un o ms fitxers
Massa objectes
3300
Extraient
Comprimint
Provant
Obrint...
Scanning...
3400
Extreu
E&xtreu a:
Seleccioneu una destinaci pels fitxers extrets.
3410
Mode d'adrea
Adrea completa
Sense adrea
3420
Sobreescriure
Amb confirmaci
Sense confirmaci
Conserva els fitxers ja existents
Reanomena automticament
Auto-reanomena fitxers existents
3500
Confirmeu substituci de fitxers
La carpeta de dest cont un fitxer amb el mateix nom.
Voleu substituir el fitxer existent
per aquest altre?
{0} bytes
Renomena a&utomticament
3700
Mtode de compressi no vlid per a '{0}'.
Error de dades en '{0}'. El fitxer s corrupte.
CRC ha fallat en '{0}'. El fitxer s corrupte.
Error de dades al fitxer xifrat '{0}'. Contrasenya errnia?
CRC ha fallat al fitxer xifrat '{0}'. Contrasenya errnia?
3800
Introduu la contrasenya
Introduu la contrasenya:
Torneu a introduir la contrasenya:
Mo&stra la contrasenya
Les contrasenyes no coincideixen
Utilitza noms lletres (sense accents), nmeros i carcters especials (!, #, $, ...) a la contrasenya
La contrasenya s massa llarga
Contrasenya
3900
Temps transcorregut:
Temps restant:
Mida:
Taxa:
Processat:
Rtio de compressi:
Errors:
Arxius:
4000
Afegir al fitxer
&Fitxer:
Mode d'act&ualitzaci:
&Format del fitxer:
Nivell de &compressi:
&Tipus de compressi:
Mida del &diccionari:
Mida de la paraula:
Mida de bloc slid:
Nombre de fils de la CPU:
&Parmetres:
Opcions
Crea fitxer SF&X
Comprimeix fitxers compartits
Xifrat
Mtode de xifrat:
Xifra el nom dels fitxers
s de memria per comprimir:
s de memria per descomprimir:
4050
Sense compressi
Rpida

Normal
Mxima
Ultra
4060
Afegeix i substitueix fitxers
Actualitza i afegeix fitxers
Actualitza fitxers ja presents
Sincronitza fitxers
4070
Visualitza
Tots els fitxers
No slid
Slid
6000
Copia
Mou
Copia a:
Mou a:
Copiant...
Movent...
Renomenant...
Seleccioneu una carpeta de dest.
Operaci no permesa.
Error renomenant fitxer o carpeta
Confirmeu la cpia del fitxer
Esteu segur que voleu copiar els fitxers a l'arxiu
6100
Confirmeu la supressi del fitxer
Confirmeu la supressi de la carpeta
Confirmeu supressi mltiple de fitxers
Esteu segur que voleu suprimir '{0}'?
Esteu segur que voleu suprimir la carpeta '{0}' i tot el seu contingut?
Esteu segur que voleu esborrar aquests {0} elements?
Suprimint...
Error esborrant fitxer o carpeta
El sistema no pot moure un fitxer amb una ruta llarga a la paperea de reciclatge
6300
Crea carpeta
Crea arxiu
Nom de carpeta:
Nom d'arxiu:
Carpeta nova
Fitxer nou
Error creant carpeta
Error creant el fitxer
6400
Comentari
&Comentari:
Selecciona
No selecciona
Mscara:
6600
Properties
Historial de carpetes
Missatges de diagnosi
Missatge
7100
El meu ordinador
Entorn de xarxa
Documents
Sistema
7200
Afegeix
Extreu
Prova
Copia
Mou
Suprimeix
Info
7300
Divideix fitxer
&Divideix a:
Divideix en &volums, bytes:
Dividint...
Confirmaci de la divisi
Esteu segur que voleu dividir el fitxer en {0} volums?
La mida del volum ha de ser ms petita que la mida del fitxer original
Mida del volum incorrecte
Mida de volum especificada: {0} bytes.\nEsteu segur que voleu dividir el fitxer en aquests volums?
7400
Combina fitxers
&Combina a:
Combinant...
Seleccioneu noms el primer fitxer
No es pot detectar un fitxer com a una part del fitxer dividit
No es pot trobar ms d'una part del fitxer dividit
7500
Calculant el checksum...
Informaci del checksum
CRC checksum per les dades:
CRC checksum per les dades i els noms:
7600
Test de referncia
s de la memria:
Comprimint
Decomprimint
Taxa
Taxa total
Actual
Resultant
s de la CPU
Taxa / s
Passades:
;!@Lang2@!UTF-8!
;  15.00 : Patriccollu di Santa Maria  Sich
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Corsican
Corsu
401
OK
Abbandun



&I
I&nn
&Chjode
Aiutu

&Cuntinu
440
I per &Tutti
Inn per T&utti
Piant
Riavvi
&Arci pianu
P&rimu pianu
&Pausa
In pausa
Site sicuru di vul abbandun ?
500
&Schedariu
&Mudific
&Affiss
&Favuriti
A&ttrezzi
A&iutu
540
&Apre
Apre Den&tru
Apre F&ora
A&ffiss
&Mudific
&Rinum
&Cupi Ver Di...
&Dispiazz Ver Di...
S&quass
&Sparte u schedariu...
&Unisce i schedarii...
&Prupriet
Cumme&ntu...
Calcul a somma di cuntrollu
Paragun e sfarenze
Cre un Cartulare
Cre un Schedariu
&Esce
Leia
Flussi A&lternativi
600
Selezziun &Tuttu
n selezziun &Nunda
&Arritrus a Selezzione
&Selezziun...
n selezziun &micca...
Selezziun da u Tipu
n Selezziun da u Tipu
700
Icone &Mai
Icone &Chjuche
&Lista
&Detaglii
730
Non &Ordinatu
&Vista Sparta
&2 Finestre
&Barre d'Attrezzi
Apre u Cartulare di &Radica
Livellu &Superiore
Crunulugia di i Cartulari...
&Attualiz
Attualisazione Autumatica
750
Barra d'Attrezzi d'Archiviu
Barra d'Attrezzi Classica
Buttoni Mai
Affiss u Testu di i Buttoni
800
&Aghjunghje u cartulare  i Favuriti cum'
Indetta
900
&Ozzioni...
&Sperimentu di pussibilit
960
&Cuntenutu (in inglese)...
&Apprupositu di 7-Zip...
1003
Passeghju
Nome
Estensione
Cartulare
Dimensione
Dimensione Cumpressa
Attributi
Creatu u
Accessu u
Mudificatu u
Solidu
Cummentatu
Cifratu
Frazziun Nanzu
Frazziun Dopu
Dizziunariu

Tipu
Anti
Metoda
OS ospite
Sistema di Schedariu
Utilizatore
Gruppu
Bloccu
Cummentu
Pusizione
Prefissu di Passeghju
Cartulari
Schedarii
Versione
Vulume
Multi-Vulume
Offset
Leie
Blocchi
Vulumi

64-bit
Big-endian
CPU
Dimensione Fisica
Dimensione di l'Intestature
Somma di cuntrollu
Caratteristiche
Indirizzu Virtuale
ID
Nome Cortu
Appiecazione d'Urigine
Dimensione di Settore
Modu
Leia Simbolica
Sbagliu
Dimensione Tutale
Spaziu Liberu
Dimensione di Cluster
Nome di Vulume
Nome Lucale
Furnidore
Sicurit NT
Flussu Alternativu
Ausiliaru
Squassatu
In Arburu


Tipu di Sbagliu
Sbaglii
Sbaglii
Avertimenti
Avertimentu
Flussi
Flussi Alternativi
Dimensione di i Flussi Alternativi
Dimensione Virtuale
Dimensione Senza Compressione
Dimensione Fisica Tutale
Indice di Vulume
SottuTipu
Cummentu Cortu
Pagina di Codice



Dimensione di a Coda
Dimensione di u Mozzicone Incurpuratu
Leia
Leia Solida
iNode

Lettura sola
2100
Ozzioni
Lingua
Lingua :
Editore
&Editore :
Paragun e sfarenze :
2200
Sistema
Assuci 7-Zip c :
Tutti l'utilizatori
2301
Integr 7-Zip  l'interfaccia cuntestuale
Interfaccia cuntestuale in cascata
Elementi di l'interfaccia cuntestuale :
Icone in l'interfaccia cuntestuale
2320
<Cartulare>
<Archiviu>
Apre l'archiviu
Estrae i schedarii...
Aghjunghje  l'archiviu...
Verific l'archiviu
Estrae Qu
Estrae ver di {0}
Aghjunghje  {0}
Cumprime  mand da email...
Cumprime ver di {0}  mand da email.
2400
Cartulari
Cartulare di &travagliu
Cartulare timpurariu di &sistema
&Currente
&Specificatu :
Impieg solu per i dischi amuvibili
Specificate un cartulare per i schedarii timpurarii d'archiviu.
2500
Preferenze
Affiss l'elementu ".."
Affiss e vere icone di i schedarii
Affiss l'interfaccia sistema
Selezziun tutta a linea
Affiss linee &quadrittate
Cliccu unicu per apre un elementu
Modu di selezzione &alternativa
Impieg pagine mai di memoria
2900
Apprupositu di 7-Zip
7-Zip h un prugramma liberu.\n\nTraduttu in lingua corsa da Patriccollu di Santa Maria  Sich.
3000
U sistema n p micca attribuisce a quantit richiesta di memoria
n ci h micca sbagliu
{0} ughjettu(i) selezziunatu(i)
U cartulare '{0}' n p micca esse creatu
L'azzioni di mudificazione n s micca pussibule per quessu archiviu.
U schedariu '{0}' n p micca esse apertu cum' un archiviu
L'archiviu cifratu '{0}' n p micca esse apertu. Parolla d'intrata falsa ?
Stu tipu d'archiviu n h micca accettatu
U schedariu {0} esiste dighj
U schedariu '{0}' h statu mudificatu.\nVulete cambiallu in l'archiviu ?
n h micca pussibule di cambi u schedariu\n'{0}'
n h micca pussibule d'avvi l'editore.
U schedariu h podasse infettatu da un virus (u so nome cuntene spazii numerosi).
St'azzione n p micca fassi dapoi un cartulare c u nome di passeghju cus longu.
Ci vole  selezziun un schedariu
Ci vole  selezziun al menu un schedariu
Troppu elementi
n h micca pussibule d'apre u schedariu cum' un archiviu {0}
U schedariu h apertu cum' un archiviu {0}
L'archiviu h apertu c offset
3300
Estrazzione
Cumpressione
Verificazione
Apertura...
Esplurazione...
Cacciatura
3320
Aghjuntu
Mudificazione
Analisa
Riproduzzione
Rimballasgiu
Tralasciamentu
Squassatura
Creazione di l'intestatura in corsu
3400
Estrae
E&strae ver di :
Sciglite un cartulare per l'estrazzione di i schedarii.
3410
Modu di passeghju :
Nomi cumpletti di passeghju
Alcunu nome di passeghju
Nomi assuluti di passeghju
Nomi relativi di passeghju
3420
Modu di rimpiazzamentu :
Cunfirm nanzu di rimpiazz
Rimpiazz senza dumand
Ignur i schedarii esistenti
Rinum autumaticamente
Rinum autumaticamente i schedarii esistenti
3430
n cupi micca u cartulare di radica
Ristur a sicurit di i schedarii
3500
Cunfirm u Rimpiazzamentu di Schedariu
U cartulare di distinazione cuntene dighj un schedariu c stu nome.
Vulete rimpiazz u schedariu esistentu
c quessu ?
{0} ottetti
Rinum &Autumaticamente
3700
Metoda di cumpressione micca accettatu per '{0}'.
Sbagliu di dati in '{0}'. U schedariu h alteratu.
Fiascu di l'ispezzione CRC per u schedariu '{0}'. U schedariu h alteratu.
Sbagliu di dati in u schedariu cifratu '{0}'. Parolla d'intrata falsa ?
Fiascu di l'ispezzione CRC per u schedariu cifratu '{0}'. Parolla d'intrata falsa ?
3710
Parolla d'intrata falsa ?
3721
Metoda di compressione micca accettatu
Sbagliu di dati
Fiascu di CRC
Dati micca dispunibule
Fine inaspettata di dati
Ci h d'altri dati dopu  a fine di i dati ghjuvevule
n h un archiviu
Sbagliu d'Intestature
Parolla d'intrata falsa 
3763
Principiu di l'archiviu micca dispunibule
Principiu di l'archiviu micca confirmatu



Funzione micca accettata
3800
Scrivite a parolla d'intrata
Scrivite a parolla d'intrata :
Scrivite torna a parolla d'intrata :
&Affiss a parolla d'intrata
E parolle d'intrata s sfarente
Per a parolla d'intrata, pudete impieg solu : lettere senza aletta, cifri  segni particulari (!, #, $, ...)
A parolla d'intrata h troppu longa
Parolla d'intrata
3900
Tempu passatu :
Tempu rimanentu :
Dimensione tutale :
Celerit :
Prucessu :
Reditu di cumpressione :
Sbaglii :
Archivii :
4000
Aghjunghje  l'archiviu
&Archiviu :
Modu di m&udificazione :
&Forma d'archiviu :
&Livellu de cumpressione :
&Metoda di cumpressione :
&Dimensione di u dizziunariu :
Dimensione di &e parolle :
Dimensione di u bloccu solidu :
Numeru di flussi CPU :
&Parametri :
Ozzioni
Cre un archiviu SF&X
Cumprime schedarii sparti
Cifratura
Metoda di cifratura :
Cifr i &nomi di schedariu
Memoria impiegata da a Cumpressione :
Memoria impiegata da a Scumpressione :
Squass i schedarii dopu  a cumpressione
4040
Cunserv e leie simboliche
Cunserv e leie solide
Cunserv i flussi di dati alternativi
Cunserv a sicurit di i schedarii
4050
Alcuna
A pi rapida
Rapida
Nurmale
Massima
Ultra
4060
Aghjunghje  rimpiazz i schedarii
Mudific  aghjunghje i schedarii
Attualiz i schedarii esistenti
Sincruniz i schedarii
4070
Sfugli
Tutti i Schedarii
Non-solidu
Solidu
6000
Cupi
Dispiazz
Cupi ver di :
Dispiazz ver di :
Copia in corsu...
Dispiazzamentu in corsu...
Cambiamentu di nome in corsu...
Selezziun u cartulare di distinazione.
St'azzione n h micca accettata per stu cartulare.
Sbagliu durante u Cambiu di Nome di Schedariu o di Cartulare
Cunfirmazione di a Copia di Schedariu
Site sicuru di vul cupi u(i) schedariu(i) ver di l'archiviu
6100
Cunfirm a Squassatura di u Schedariu
Cunfirm a Squassatura di u Cartulare
Cunfirm a Squassatura di Schedarii Multiplice
Site sicuru di vul squass '{0}' ?
Site sicuru di vul squass u cartulare '{0}'  tuttu u so cuntenutu ?
Site sicuru di vul squass sti {0} elementi ?
Squassatura in corsu...
Sbagliu durante a Squassatura di Schedariu o di Cartulare
U sistema n p micca mette  a Rumenzula un schedariu c u nome di passeghju cus longu
6300
Cre un Cartulare
Cre un Schedariu
Nome di cartulare :
Nome di schedariu :
Novu Cartulare
Novu Schedariu
Sbagliu durante a Creazione di Cartulare
Sbagliu durante a Creazione di Schedariu
6400
Cummentu
&Cummentu :
Selezziun
n Selezziun
Filtru :
6600
Prupriet
Crunulugia di i Cartulari
Messaghji di diagnosticu
Messaghju
7100
Urdinatore
Reta
Ducumenti
Sistema
7200
Aghjunghje
Estrae
Verific
Cupi
Dispiazz
Squass
Infurmazione
7300
Sparte u schedariu
&Sparte in :
Sparte in &vulumi, ottetti :
Spartimentu...
Cunfirm u Spartimentu
Site sicuru di vul sparte u schedariu in {0} vulumi ?
A dimensione di u vulume deve esse pi chjucu ch u schedariu d'urighjine
Dimensione di vulume falsa
Dimensione di vulume specificata : {0} ottetti.\nSite sicuru di vul tagli l'archiviu in tali vulumi ?
7400
Unisce i Schedarii
&Unisce in :
Unione...
Selezziun solu a prima parte di l'archiviu spartutu
n si trova alcuna parte d'archiviu spartutu
n si trova micca pi d'una parte d'archiviu spartutu
7500
Calculu di a somma di cuntrollu...
Infurmazione nant' a somma di cuntrollu
Somma di cuntrollu CRC per i dati :
Somma di cuntrollu CRC per i dati  i nomi :
7600
Sperimentu di pussibilit
Memoria impiegata :
Cumpressione
Scumpressione
Percentuale
Percentuale tutale
Attuale
Risultante
Impiegu CPU
Estimatu / Impiegatu
Passagi :
7700
Leia
Lig
Leia d'urigine :
Leia di distinazione :
7710
Tipu di Leia
Leia Solida
Leia Simbolica di Schedariu
Leia Simbolica di Cartulare
Unione di Cartulare
;!@Lang2@!UTF-8!
;  4.30 : Milan Hrub
;  4.33 : Michal Molhanec
;  9.07 : Ji Malk
;
;
;
;
;
;
;
;
0
7-Zip
Czech
etina
401
OK
Storno



&Ano
&Ne
Zav&t
Npovda

Po&kraovat
440
Ano na &vechno
N&e na vechno
Zastavit
Spustit znovu
&Pozad
P&oped
Po&zastavit
Pozastaveno
Jste si jist, e to chcete stornovat?
500
&Soubor
pr&avy
&Zobrazen
&Oblben
&Nstroje
Npo&vda
540
&Otevt
Otevt u&vnit
Otevt &mimo
&Zobrazit
&Upravit
&Pejmenovat
Koprovat &do...
P&esunout do...
Vymaza&t
&Rozdlit soubor...
&Slouit soubory...
Vlast&nosti
Poznmk&a
Vypotat kontroln souet
Porovnat soubory
Vytvoit sloku
Vytvoit soubor
&Konec
600
Vybrat &ve
Zruit vbr ve
&Invertovat vbr
Vybrat...
Zruit vbr...
Vybrat podle typu
Zruit vbr podle typu
700
&Velk ikony
&Mal ikony
&Seznam
&Podrobnosti
730
&Bez tdn
"Ploch" zobrazen
&2 panely
Nstrojov lity
Otevt koenovou sloku
O rove v
Historie sloek...
&Obnovit
750
Archivan lita
Standardn lita
Velk tlatka
Zobrazovat text tlatek
800
&Pidat sloku do oblbench jako
Zloka
900
&Monosti...
&Zkouka vkonu
960
&Obsah...
O progr&amu 7-Zip...
1003
Cesta
Nzev
Ppona
Sloka
Velikost
Komprimovan velikost
Atributy
Vytvoen
Pouit
Zmnn
Pevn
S poznmkou
Zakdovan
Rozdlen do
Rozdlen od
Slovnk
CRC
Typ
Anti
Metoda
Hostitelsk OS
Souborov systm
Uivatel
Skupina
Blok
Poznmka
Pozice
Cesta
Sloky
Soubory
Verze
Dl
Vcedln
Offset
Odkazy
Blok
Dl

64-bit
Big-endian
Pocesor
Fyzick velikost
Velikost hlaviek
Kontroln souet
Charakteristiky
Virtuln adresa
ID
Krtk jmno
Autor
Velikost sektoru
Reim
Odkaz
Chyba
Celkov velikost
Voln msto
Velikost clusteru
Oznaen
Mstn nzev
Poskytovatel
2100
Monosti
Jazyk
Jazyk:
Editor
&Editor:
Program pro &porovnn soubor:
2200
Systm
Asociovat 7-Zip s:
2301
&Integrovat 7-Zip do kontextovho menu
S&tupovit kontextov menu
&Poloky kontextovho menu:
2320
<Sloka>
<Archiv>
Otevt
Rozbalit soubory...
Pidat do archivu...
Zkontrolovat archiv
Rozbalit zde
Rozbalit do {0}
Pidat do {0}
Zkomprimovat a odeslat potou...
Zkomprimovat do {0} a odeslat potou
2400
Sloky
Pracovn sloka
&Systmov sloka pro doasn soubory
&Aktuln
S&loka:
&Pouvat pouze pro vyjmateln disky
Vyberte umstn pro doasn komprimovan soubory.
2500
Nastaven
Zobrazovat poloku ".."
Zobrazovat skutenou ikonu souboru
Zobrazovat systmov menu
&Vybrat cel dek
Zobrazovat &mku
Otevt poloku jednm kliknutm
&Alternativn zpsob vbru
&Pouvat velk strnky pamti
2900
O programu 7-Zip
7-Zip je svobodn software. Nicmn mete podpoit jeho vvoj registrac.
3000
Systm neme pidlit poadovanou velikost pamti
Nedolo k dnm chybm
vybrno {0} objekt()
Nelze vytvoit sloku '{0}'
Aktualizace nen podporovna pro tento archiv.
Soubor '{0}' nelze otevt jako archiv
Zakdovan archiv '{0}' nelze otevt. patn heslo?
Nepodporovan typ archivu
Soubor {0} ji existuje
Soubor '{0}' byl zmnn.\nChcete ho aktualizovat v archivu?
Nelze aktualizovat soubor\n'{0}'
Editor nelze spustit.
Soubor se jev jako virus (ve jmnu souboru jsou dlouh mezery).
Operace neme bt provedena ze sloky s dlouhou cestou.
Muste vybrat jeden soubor
Muste vybrat jeden nebo vce soubor
Pli mnoho poloek
3300
Rozbalovn
Komprimovn
Konrola
Otevrn...
Prohledvn...
3400
Rozbalit
&Rozbalit do:
Vyberte umstn pro rozbalen soubory.
3410
Cesty
Pln cesty
Bez cesty
3420
Zpsob pepisovn
Zeptat se ped pepisem
Pepsat bez vzvy
Peskoit existujc soubory
Automatick pejmenovn
Automatick pejmenovn existujcch soubor
3500
Potvrzen nahrazen souboru
Clov sloka ji obsahuje zpracovan soubor.
Chcete nahradit existujc soubor
tmto?
{0} bajt
A&utomaticky pejmenovat
3700
Nepodporovan kompriman metoda pro '{0}'.
Chyba dat v '{0}'. Soubor je pokozen.
Chyba CRC v '{0}'. Soubor je pokozen.
Chyba dat v zakdovanm souboru '{0}'. Chybn heslo?
Chyba CRC v zakdovanm souboru '{0}'. Chybn heslo?
3800
Vloit heslo
Vloit heslo:
Potvrzen hesla:
Zobrazit he&slo
Heslo nesouhlas
Pro heslo poujte pouze anglick psmena, slice a speciln znaky (!, #, $, ...)
Heslo je pli dlouh
Heslo
3900
Uplynul as:
Zbvajc as:
Celkov velikost:
Rychlost:
Zpracovno:
Kompriman pomr:
Chyb:
Archvy:
4000
Pidat do archivu
&Archiv:
Zpsob aktualizace:
&Formt archivu:
&rove komprese:
&Kompriman metoda:
Ve&likost slovnku:
V&elikost slova:
Velikost bloku:
Poet vlken procesoru:
&Parametry:
Monosti
Vytvoit SF&X archiv
Zkomprimovat oteven soubory
Zakdovn
Metoda zakdovn:
Zakdovat &nzvy soubor
Spoteba pamti pro zabalen:
Spoteba pamti pro rozbalen:
4050
Skladovac
Nejrychlej
Rychl
Normln
Maximln
Ultra
4060
Pidat a nahradit soubory
Aktualizovat a pidat soubory
Aktualizovat existujc soubory
Synchronizovat soubory
4070
Prochzet
Vechny soubory
Podle velikosti souboru
Pevn
6000
Koprovat
Pesunout
Koprovat do:
Pesunout do:
Koprovn...
Pesouvn...
Pejmenovn...
Vyberte clovou sloku.
Operace nen podporovna.
Chyba pi pejmenovn souboru nebo sloky
Potvrzen koprovn soubor
Jste si jist, e chcete zkoprovat soubory do archivu
6100
Potvrdit vymazn souboru
Potvrdit vymazn sloky
Potvrdit mnohonsobn vymazn souboru
Jste si jist, e chcete vymazat '{0}'?
Jste si jist, e chcete vymazat sloku '{0}' a vechno co obsahuje?
Jste si jist, e chcete vymazat tyto {0} poloky?
Mazn...
Chyba pi mazn souboru nebo sloky
Systm nepodporuje pesun soubor s dlouhou cestou do Odpadkovho koe
6300
Vytvoit sloku
Vytvoit soubor
Nzev sloky:
Nzev souboru:
Nov sloka
Nov soubor
Chyba pi vytven sloky
Chyba pi vytven souboru
6400
Poznmka
&Poznmka:
Vybrat
Zruit vbr
Maska:
6600
Vlastnosti
Historie sloek
Diagnostick zprvy
Zprva
7100
Pota
S
Dokumenty
Systm
7200
Pidat
Rozbalit
Zkontrolovat
Koprovat
Pesunout
Vymazat
Informace
7300
Rozdlit soubor
Rozdlit do:
Rozdlit na dly, bajt:
Rozdlovn...
Potvrdit rozdlovn
Jste si jist, e chcete rozdlit soubor na {0} dl?
Velikost dlu mus bt men ne velikost pvodnho souboru
Nesprvn velikost dlu
Zadan velikost dlu: {0} byt.\nJste si jist, e chcete rozdlit archiv do takovch dl?
7400
Slouit soubory
Slouit do:
Sluovn...
Mus se vybrat pouze prvn dl rozdlenho soubor
Nepodailo se rozpoznat rozdlen soubor
Nepodailo se nalzt vce ne jeden dl rozdlenho souboru
7500
Vypotvn kontrolnho soutu...
Informace o kontrolnm soutu
CRC kontroln souet pro data:
CRC kontroln souet pro data a jmna:
7600
Zkouka vkonu
Spoteba pamti:
Komprimovn
Rozbalovn
Vkon
Celkov vkon
Aktuln
Vsledn
Vyuit procesoru
Vkon / Vyuit
Prchod:
;!@Lang2@!UTF-8!
;  4.37 : Owain Lewis
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Welsh
Cymraeg
401
Iawn
Canslo



&Iawn
&Na
&Cau
Cymorth

P&arhau
440
Iawn i'r &Cwbwl
Na i'r C&wbwl
Stopio
Ailgychwyn
&Cefndir
&Blaendir
&Pwyllo
Pwyllo
Ydych chi am canslo?
500
&Ffeil
&Golygu
Gwe&ld
Ff&efrynnau
&Offer
&Cymorth
540
&Agor
Agor tu &Mewn
Agor tu &Fas
Gwe&ld
&Golygu
A&ilenwi
&Copo i...
&Symud i...
&Dileu
&Hollti ffeil...
Cy&funo ffeilau...
&Priodweddau
Syl&wad
Cyfrifo swm-gwirio

Creu Ffolder
Creu Ffeil
Alla&n
600
Dewis y C&yfan
Dad-ddewis y Cyfan
Gwrt&hdroi'r Dewis
Dewis...
Dad-ddewis...
Dewis trwy Math
Dad-ddewis trwy Math
700
Eiconau &Mawr
Eiconau &Bach
&Rhestr
Ma&nylion
730
Dad-dosbarthu
Golwg Flat
&2 Paneli
Bariau &Offer
Agor Ffolder Gwraidd
Lan Un Lefel
Hanes Ffolderi...
&Adnewyddu
750
Bar Offer Archif
Bar Offer Arferol
Botwmau Fawr
Dangos Testun Botwmau
800
&Ychwanegu ffolder i Ffefrynnau fel
Llyfrnod
900
&Dewisiadau...
&Meincnod
960
&Cynnwys...
&Manylion 7-Zip...
1003
Llwybr
Enw
Estyniad
Ffolder
Maint
Maint wedi'i Cywasgu
Priodweddau
Crwyd
Cyrchwyd
Addaswyd
Solet
Sylwad
Amgryptio
Hollti Cyn
Hollti ar l
Geiriadur
CRC
Math
Anti
Dull
SW Cynnal
System Ffeiliau
Ddefnyddiwr
Grp
Bloc
Sylwad
Safle
Rhagddodiad y Llwybr
























Gwall
Cyfanswm Maint
Lle Rhydd
Maint Clwstwr
Label
Enw Lleol
Darparwr
2100
Dewisiadau
Iaith
Iaith:
Golygydd
&Golygydd:

2200
System
Cysylltu 7-Zip gyda:
2301
Cyfuno 7-Zip mewn i dewislen cyd-destun y cribyn
Dewislen cyd-destun wedi'i rhaeadru
Eitemau dewislen cyd-destun:
2320
<Ffolder>
<Archif>
Agor archif
Echdynnu ffeiliau...
Ychwanegu i'r archif...
Profi archif
Echdynnu Yma
Echdynnu i {0}
Ychwanegu i {0}
Cywasgu ac e-bostio...
Cywasgu i {0} ac e-bostio
2400
Ffolderi
Ffolder &gweithio
Ffolder tymor byr y &system
&Cyfredol
&Penodol:
Defnyddiwch am gyriant symudadwy yn unig
Nodwch lleoliad am ffeiliau archif tymor byr.
2500
Gosodiadau
Dangos eitem ".."
Dangos eicon ffeil go iawn
Dangos dewislen y system
Dethol &holl rhes
Dangos llinellau &grid

Modd dethol &arallddewisiol
Defnyddiwch tudalenau cof &mawr
2900
Manylion 7-Zip
Mae 7-Zip yn meddalwedd am ddim. Ond, gallwch cefnogi y\ndatblygiad o 7-Zip trwy cofrestru.
3000

Mae na ddim wallau
{0} gwrthrych(au) dethol
Ddim yn gallu creu y ffolder '{0}'
Mae gweithrediadau diweddaru ddim yn ateg am yr archif hyn.




Roedd ffeil '{0}' wedi'i addasu.\nWyt ti moen ei diweddaru yn yr\narchif?
Ddim yn gallu diweddaru ffeil\n'{0}'
Ddim yn gallu dechrau golygydd.




Gormod o eitemau
3300
Echdynnu
Cywasgu
Ymbrofi
Agor...
Sganio...
3400
Echdynnu
E&chdynnu i:
Nodwch lleoliad am echdynnu ffeiliau.
3410
Modd llwybr
Enwau llwybr llawn
Dim enwau llwybr
3420
Modd disodli
Gofyn cyn disodli
Disodli heb awgrymeb
Crychneidio ffeiliau presennol
Ailenwu yn awtomatig
Ailenwu ffeiliau presennol yn awtomatig
3500
Cadarnhau Disodli Ffeil
Mae'r ffolder hon eisioes yn cynnwys y ffeil cyrchfan.
Hoffech chi ddisodli'r ffeil sy'n bodoli eisioes
Gyda hon?
{0} beit
Ailenwi A&wtomatig
3700
Modd cywasgu ddim yn dilys am '{0}'.
Gwall data mewn '{0}'. Ffeil wedi'i torri.
CRC wedi'i methu mewn '{0}'. Ffeil wedi'i torri.


3800
Mewnbynnwch cyfrinair
Mewnbynnwch cyfrinair:

&Dangos cyfrinair



Cyfrinair
3900
Wedi treiglo:
Amser a'r l:
Maint:
Cyflymder:


Gwallau:

4000
Ychwanegu i'r archif
&Archif:
Modd &diweddaru:
&Fformat yr archif:
&Lefel cywasgu:
Dull &cywasgu:
Maint &geiriadur:
Maint geiria&u:


&Paramedrau:
Dewisiadau
Creu archif SF&X



Amgryptio &enwau ffeiliau
Defnydd cof am Cywasgu:
Defnydd cof am Datgywasgu:
4050
Storio
Cyflymach
Cyflum
Arferol
Uchafswm
Ultra
4060
Ychwanegu ac amnewid ffeiliau
Diweddaru ac ychwanegu ffeiliau
Adnewyddu y ffeiliau presennol
Cyfamseru ffeiliau
4070
Pori
Pob Ffeil


6000
Copo
Symud
Copo i:
Symud i:
Copo...
Symud...
Ailenwi...

Mae'r gweithrediad ddim wedi'i ategu.
Gwall wrth Ailenwi Ffeil neu Ffolder
Cadarnhau Copi Ffeil
Ydych chi'n sir eich bod am copo'r ffeiliau i'r archif
6100
Cadarnhau Dileu Ffeil
Cadarnhau Dileu Ffolder
Cadarnhau Dileu Ffeiliau Amryfal
Ydych chi'n sir eich bod am dileu '{0}'?
Ydych chi'n sir eich bod am dileu y ffolder '{0}' ac ei holl\ncynnwys?
Ydych chi'n sir eich bod am dileu yr eitemau hyn {0}?
Dileu...
Gwall Dileu Ffeil neu Ffolder

6300
Creu Ffolder
Creu Ffeil
Enw Ffolder:
Enw Ffeil:
Ffolder Newydd
Ffeil Newydd
Gwall wrth Creu Ffolder
Gwall wrth Creu Ffeil
6400
Sylwad
&Sylwad:
Dewis
Dad-ddewis
Mwgwd:
6600

Hanes Ffolderi
Neges diagnostig
Neges
7100
Cyfrifiadur
Rhyngrwyd

System
7200
Ychwanegu
Echdynnu
Profi
Copo
Symud
Dileu
Gwybodaeth
7300
Hollti Ffeil
&Hollti i:
Hollti i &cyfeintiau, beitiau:
Hollti...





7400
Cyfuno Ffeiliau
&Cyfuno i:
Cyfuno...



7500
Cyfrifo swm-gwirio...
Gwybodaeth swm-gwirio
Swm-gwirio CRC am data:
Swm-gwirio CRC am data ac enwau:
7600
Meincnod
Defnyddiad cof:
Cywasgu
Datgywasgu
Amcangyfrif
Amcangyfrif llwyr
Presennol
Canlyniad


Pasio:
;!@Lang2@!UTF-8!
;       : Jakob Schmidt
;  9.07 : Kian Andersen, Jrgen Rasmussen
; 15.00 : 2016-04-08 : scootergrisen
;
;
;
;
;
;
;
;
0
7-Zip
Danish
Dansk
401
OK
Annuller



&Ja
&Nej
&Luk
Hjlp

&Fortst
440
Ja til &alle
Nej til a&lle
Stop
Genstart
&Baggrund
&Forgrund
&Pause
Pauset
Er du sikker p du vil annullere?
500
&Filer
R&ediger
&Vis
F&avoritter
Funk&tioner
&Hjlp
540
&bn
bn &inden i
bn &uden for
&Vis
&Rediger
O&mdb
&Kopier til...
&Flyt til...
S&let
&Opdel fil...
Kom&biner filer...
&Egenskaber
Komme&ntar...
Udregn checksum
Sammenlign
Opret mappe
Opret fil
&Afslut
Opret/rediger genvej
&Alternative streams
600
Vlg &alle
Fravlg alle
&Omvendt markering
Vlg...
Fravlg...
Vlg efter type
Fravlg efter type
700
Sto&re ikoner
S&m ikoner
&Liste
&Detaljer
730
Usorteret
Flad visning
&2 paneler
&Vrktjslinjer
bn rodmappe
Et niveau op
Mappehistorik...
&Opdater
Opdater automatisk
750
Arkivlinje
Standardlinje
Store knapper
Vis knappernes tekst
800
&Fj mappe til Favoritter som
Bogmrke
900
&Indstillinger...
&Benchmark
960
&Indhold...
&Om 7-Zip...
1003
Sti
Navn
Filtype
Mappe
Strrelse
Pakket strrelse
Attributter
Oprettet
bnet
ndret
Solid
Kommentar
Krypteret
Opdeling fr
Opdeling efter
Leksikon

Type
Anti
Metode
Vrt OS
Filsystem
Bruger
Gruppe
Blok
Kommentar
Position
Sti prfiks
Mapper
Filer
Version
Bind
Flerbindsarkiv
Offset
Links
Blokke
Bind

64-bit
Big-endian
CPU
Fysisk strrelse
Headerstrrelse
Checksum
Karakteristika
Virtuel adresse
ID
Kort navn
Oprettende program
Sektorstrrelse
Tilstand
Link
Fejl
Samlet strrelse
Fri plads
Clusterstrrelse
Etiket
Lokalt navn
Udbyder
NT Security
Alternativ stream
Aux
Slettet
Er tr


Fejltype
Fejl
Fejl
Advarsler
Advarsel
Streams
Alternative streams
Alternative streamsstrrelse
Virtuel strrelse
Udpakket strrelse
Samlet fysiske strrelse
Bind-indeks
Undertype
Kort kommentar
Tegnst



Halestrrelse
Indlejret stumpstrrelse
Genvej
Fast forbindelse (Hard Link)
iNode

Skrivebeskyttet
2100
Indstillinger
Sprog
Sprog:
Redigering
&Rediger:
&Sammenlign (Diff):
2200
System
Knyt 7-Zip til:
Alle brugere
2301
Vis i Windows genvejsmenu
Brug undermenu
Punkter i genvejsmenu:
Ikoner i genvejsmenu
2320
<Mappe>
<Arkiv>
bn arkiv
Udpak filer...
Fj til arkiv...
Undersg arkiv
Udpak her
Udpak til {0}
Fj til {0}
Pak og e-mail...
Pak til {0} og e-mail
2400
Mapper
&Arbejdsmappe
&Systemets temp-mappe
&Nuvrende
&Brugerdefineret:
Brug kun til flytbare drev
Angiv placering til midlertidige filer.
2500
Indstillinger
Vis ".." element
Vis rigtige filikoner
Vis systemmenu
&Markr hele rkken
Vis &gitter
t klik for at bne element
&Alternativ markeringsmetode
Brug &store hukommelsessider
2900
Om 7-Zip
7-Zip er fri software
3000
Systemet kan ikke tildele den ndvendige mngde hukommelse
Der er ingen fejl
{0} markerede element(er)
Kan ikke oprette mappe '{0}'
Arkivet understtter ikke opdatering.
Kan ikke bne filen '{0}' som arkiv
Kan ikke bne krypterede arkiv '{0}'. Forkert adgangskode?
Arkivtypen er ikke understttet
Filen {0} findes allerede
Filen '{0}' er blevet ndret.\nVil du opdatere den i arkivet?
Kan ikke opdatere filen\n'{0}'
Kan ikke starte redigering.
Filen ligner en virus (filnavnet indeholder lange mellemrum i navn).
Handlingen kan ikke kaldes fra en mappe med lang sti.
Du skal vlge en fil
Du skal vlge en eller flere filer
For mange elementer
Kan ikke bne filen som {0}-arkiv
Filen er bnet som {0}-arkiv
Arkivet er bnet med offset
3300
Udpakker
Nedpakker
Undersger
bner...
Skanner...
Fjerner
3320
Tilfjer
Opdaterer
Analyserer
Replikerer
Ompakker
Overspringer
Sletter
Opretter header
3400
Udpak
U&dpak til:
Vlg en placering til udpakkede filer.
3410
Stitype
Fulde stinavne
Ingen stinavne
Absolutte stinavne
Relative stinavne
3420
Erstatningstype:
Sprg fr erstatning
Erstat uden at sprge
Spring eksisterende filer over
Omdb automatisk
Omdb automatisk eksisterende filer
3430
Forhindre duplikering af rodmappe
Genskab filsikkerhed
3500
Bekrft filerstatning
Destinationsmappen indeholder allerede behandlede filer.
nsker du at udskifte den eksisterende fil
med denne?
{0} bytes
A&utomatisk omdbning
3700
Ikke understttet pakkemetode for '{0}'.
Datafejl i '{0}'. Filen er delagt.
CRC mislykkedes i '{0}'. Filen er delagt.
Datafejl i den krypterede fil '{0}'. Forkert adgangskode?
CRC mislykkedes i den krypterede fil '{0}'. Forkert adgangskode?
3710
Forkert adgangskode?
3721
Pakkemetoden er ikke understttet
Datafejl
CRC mislykkedes
Utilgngelig data
Uventet slutning p data
Der er data efter slutningen af nyttedataene
Ikke et arkiv
Fejl i headers
Forkert adgangskode
3763
Utilgngelig begyndelse p arkiv
Ubekrftet begyndelse p arkiv



Funktionen understttes ikke
3800
Indtast adgangskode
Indtast adgangskode:
Indtast adgangskode igen:
&Vis adgangskode
Adgangskoderne er ikke ens
Brug kun engelske bogstaver, numre og specialtegn (!, #, $, ...) til adgangskoden
Adgangskoden er for lang
Adgangskode
3900
Forlbet tid:
Resterende tid:
Samlet strrelse:
Hastighed:
Behandlet:
Komprimeringsforhold:
Fejl:
Arkiver:
4000
Fj til arkiv
&Arkiv:
O&pdateringstype:
Arkiv&format:
Komprimerings&niveau:
Pakke&metode:
Strrelse p or&dbog:
Strrelse p &ord:
Strrelse p solid block:
Antal CPU trde:
Pa&rametre:
Funktioner
Opret selvudpakkende SF&X-arkiv
Komprimer delte filer
Kryptering
Krypteringsmetode:
Kr&ypter filnavne
Hukommelsesforbrug ved nedpakning:
Hukommelsesforbrug ved udpakning:
Slet filer efter komprimering
4040
Gem symbolsk links
Gem hard links
Gem alternative data streams
Gem filsikkerhed
4050
Kun gem
Hurtigste
Hurtig
Normal
Bedste
Ultra
4060
Tilfj og erstat filer
Opdater og tilfj filer
Opdater eksisterende filer
Synkroniser filer
4070
Gennemse
Alle filer
Non-solid
Solid
6000
Kopier
Flyt
Kopier til:
Flyt til:
Kopierer...
Flytter...
Omdber...
Vlg destinationsmappen.
Handlingen er ikke understttet for denne mappe.
Fejl under omdbning af fil eller mappe
Bekrft filkopiering
Er du sikker p at du vil kopiere filer til arkiv
6100
Bekrft sletning af fil
Bekrft sletning af mappe
Bekrft sletning af flere filer
Er du sikker p du vil slette '{0}'?
Er du sikker p du vil slette mappen '{0}' og alt dens indhold?
Er du sikker p du vil slette disse {0} elementer?
Sletter...
Fejl under sletning af fil eller mappe
Systemet kan ikke flytte en fil med lang sti til Papirkurven
6300
Opret mappe
Opret fil
Mappenavn:
Filnavn:
Ny mappe
Ny fil
Fejl under oprettelse af mappe
Fejl under oprettelse af fil
6400
Kommentar
&Kommentar:
Vlg
Fravlg
Maske:
6600
Egenskaber
Mappehistorik
Diagnostiske meddelelser
Meddelelse
7100
Computer
Netvrk
Dokumenter
System
7200
Tilfj
Udpak
Test
Kopier
Flyt
Slet
Info
7300
Opdel fil
&Opdel til:
Opd&el i bind, bytes:
Opdeler...
Bekrft opdeling
Er du sikker p du vil opdele filen i {0} bind?
Strrelsen p bind skal vre mindre end strrelsen p den oprindelige fil
Forkert strrelse p bind
Angivet strrelse p bind: {0} bytes.\nEr du sikker p du nsker, at opdele arkivet i disse bind?
7400
Kombiner filer
&Kombiner til:
Kombinerer...
Vlg kun frste del af opdelt fil
Kan ikke genkende fil, som del af en opdelt fil
Kan ikke finde mere end n del af opdelt fil
7500
Beregner checksum...
Checksum information
CRC checksum for data:
CRC checksum for data og navne:
7600
Benchmark
Hukommelsesforbrug:
Nedpakning
Udpakning
Vurdering
Samlet vurdering
Aktuelt
Resultat
CPU forbrug
Vurdering/forbrug
Gennemlb:
7700
Opret/rediger genvej
Opret/rediger genvej
Genvej fra:
Genvej til:
7710
Linktype
Fast forbindelse (Hard Link)
Fil symbolsk link
Mappe symbolsk link
Mappe forbindelsespunkt (Directory Junction)
;!@Lang2@!UTF-8!
;  2.30 : Soeren Finster
;  4.07 : JAK-Software.DE
;  9.07 : Joachim Henke
;
;
;
;
;
;
;
;
0
7-Zip
German
Deutsch
401
OK
Abbrechen



&Ja
&Nein
&Schlieen
Hilfe

&Fortsetzen
440
Ja fr &alle
Nein fr a&lle
Stopp
Neustart
&Hintergrund
&Vordergrund
&Pause
Pause
Mchten Sie wirklich abbrechen?
500
&Datei
&Bearbeiten
&Ansicht
&Favoriten
&Extras
&Hilfe
540
&ffnen
I&ntern ffnen
E&xtern ffnen
&Ansehen
&Bearbeiten
&Umbenennen
&Kopieren nach...
&Verschieben nach...
&Lschen
Datei auf&splitten...
Dateien &zusammenfgen...
E&igenschaften
K&ommentieren
&Prfsumme berechnen
Ver&gleichen
Ordner erstellen
Datei erstellen
Be&enden
Verknpfung...
&Alternative Datenstrme
600
Alles &markieren
Alles abwhlen
Markierung &umkehren
Auswhlen...
Auswahl aufheben...
Nach Typ auswhlen
Nach Typ abwhlen
700
&Groe Symbole
&Kleine Symbole
&Liste
&Details
730
Unsortiert
Alles in einer &Ebene
&Zweigeteiltes Fenster
&Symbolleisten
Wurzelverzeichnis
bergeordneter Ordner
Ordnerverlauf...
&Aktualisieren
Auto-Aktualisierung
750
Archivfunktionen
Standardfunktionen
Groe Schaltflchen
Schaltflchenbeschriftung
800
&Ordner hinzufgen als
Favorit
900
&Optionen...
&Benchmark
960
&Hilfethemen
&ber 7-Zip...
1003
Pfad
Name
Erweiterung
Ordner
Gre
Gepackte Gre
Attribute
Erstellt am
Letzter Zugriff
Gendert am
Kompakt (solid)
Kommentiert
Verschlsselt
Vorher geteilt
Danach geteilt
Wrterbuch
CRC
Typ
Anti
Verfahren
Herkunft
Dateisystem
Besitzer
Gruppe
Block
Kommentar
Position
Pfad
Ordner
Dateien
Version
Teilarchiv
Mehrteiliges Archiv
Offset
Verknpfungen
Blcke
Teilarchive

64 Bit
Big-Endian
CPU
Gesamtgre
Header-Gre
Prfsumme
Kenndaten
Virtuelle Adresse
ID
Kurzname
Erstellt durch
Sektorgre
Zugriffsrechte
Link
Fehler
Gesamtgre
Freier Speicherplatz
Cluster-Gre
Name
Lokaler Name
Provider
NT-Sicherheit
Alternativer Datenstrom
Aux
Gelscht
Ist Baum


Fehlertyp
Fehler
Fehler
Warnungen
Warnung
Datenstrme
Alternative Datenstrme
Gre der alternativen Datenstrme
Virtuelle Gre
Entpackte Gre
Gesamte physikalische Gre
Teilstck Index
Untertyp
Kurzkommentar
Code-Seite



Endungsgre
integrierte Stub-Gre
Verknpfung
Harte Verknpfung
iNode

Schreibgeschtzt
2100
Optionen
Sprache
Sprache:
Editor
&Editor:
Programm zum &Vergleichen:
2200
System
7-Zip verknpfen mit:
alle Benutzer
2301
7-Zip in Kontextmen integrieren
Kontextmen kaskadieren
Eintrge im Kontextmen:
Symbole im Kontextmen
2320
<Verzeichnis>
<Archiv>
ffnen
Dateien entpacken...
Zu einem Archiv hinzufgen...
Archiv berprfen
Hier entpacken
Entpacken nach {0}
Hinzufgen zu {0}
Archivieren und versenden...
Archivieren in {0} und versenden
2400
Ordner
&Arbeitsverzeichnis
&TEMP-Ordner des Systems
Aktueller &Ordner
&Benutzerdefiniert:
Nur bei &Wechselmedien benutzen
Whlen Sie einen Ordner fr temporre Archivdateien:
2500
Einstellungen
&Verzeichniseintrag ".." anzeigen
Symbole aus &Dateien laden und anzeigen
System-Kontext&men im Dateimen anzeigen
Dateiauswahl markiert ganze &Zeile
&Gitternetzlinien anzeigen
Einfacher &Klick zum ffnen
&Alternativer Dateiauswahl-Modus
Groe &Speicherseiten verwenden
2900
Info ber 7-Zip
7-Zip ist freie Software. Sie knnen jedoch das Projekt durch eine Registrierung untersttzen.
3000
Das System kann die bentigte Speichermenge nicht bereit stellen.
Es sind keine Fehler aufgetreten.
{0} Objekt(e) markiert
Kann den Ordner "{0}" nicht erstellen.
Aktualisierungen werden fr dieses Archiv nicht untersttzt.
Die Datei "{0}" kann nicht als Archiv geffnet werden.
Das verschlsselte Archiv "{0}" kann nicht geffnet werden. Falsches Passwort?
Typ des Archives wird nicht untersttzt
Die Datei {0} existiert bereits.
Die Datei "{0}" wurde gendert.\nSoll sie im Archiv aktualisiert werden?
Die Datei konnte nicht aktualisiert werden.\n"{0}"
Kann Editor nicht starten
Die Datei scheint ein Virus zu sein (Dateiname enthlt lange Reihen von Leerzeichen).
Die Operation kann nicht aus einem Ordner mit langem Pfad aufgerufen werden.
Bitte genau eine Datei auswhlen.
Bitte mindestens eine Datei auswhlen.
Zu viele Objekte
Die Datei kann nicht als {0}-Archiv geffnet werden.
Die Datei wurde als {0}-Archiv geffnet.
Die Datei wurde mit einem Offset geffnet.
3300
Entpacken
Komprimiere
berprfen
ffne...
Durchsuche...
Entferne
3320
Hinzufgen
Aktualisieren
Analysieren
Replizieren
Neu Packen
berspringen
Lschen
Header erstellen
3400
Entpacken
&Entpacken nach:
Whlen Sie einen Ordner fr die entpackten Dateien:
3410
Verzeichnisstruktur wiederherstellen
Komplette Pfadangaben
Keine Pfadangaben
Absolute Pfadangaben
Relative Pfadangaben
3420
Dateien berschreiben
Nur mit Besttigung
Ohne Besttigung
Vorhandene Dateien berspringen
Automatisch umbenennen
Vorhandene Dateien umbenennen
3430
Verdoppelung des Wurzelordners vermeiden
Dateirechte wiederherstellen
3500
berschreiben besttigen
Der Zielordner beinhaltet bereits eine Datei diesen Namens.
Wollen Sie diese Datei
durch diese ersetzen?
{0} Bytes
A&utomatisch umbenennen
3700
Das Kompressionsverfahren in "{0}" wird nicht untersttzt.
Datenfehler in "{0}". Die Datei ist beschdigt.
CRC-Prfsummenfehler. Die Datei "{0}" ist beschdigt.
Datenfehler in der verschlsselten Datei "{0}". Falsches Passwort?
CRC-Prfsummenfehler bei verschlsselter Datei "{0}". Falsches Passwort?
3710
Falsches Passwort?
3721
Nicht untersttzte Kompressionsmethode
Datenfehler
CRC-Fehler
Daten stehen nicht zur Verfgung
Unerwartetes Datenende
Es gibt noch Daten hinter den Hauptdaten
Ist kein Archiv
Headers-Fehler
Falsches Passwort
3763
Anfang des Archivs fehlt
Anfang des Archivs nicht besttigt



Nicht untersttzte Funktion
3800
Kennworteingabe
Passwort eingeben:
Passwort besttigen:
Passwort an&zeigen
Die Passwrter stimmen nicht berein.
Bitte nur Buchstaben des englischen Alphabets, Ziffern und Sonderzeichen (!, #, $, ...) im Passwort verwenden!
Das Passwort ist zu lang.
Passwort
3900
Verstrichene Zeit:
Verbleibende Zeit:
Gesamtdatenmenge:
Geschwindigkeit:
Verarbeitet:
Kompressionsrate:
Fehler:
Archive:
4000
Zu Archiv hinzufgen
&Archiv:
Art der Akt&ualisierung:
Archiv&format:
&Kompressionsstrke:
Kompressions&verfahren:
Wrter&buchgre:
&Wortgre:
Gre &solider Blcke:
Anzahl &CPU-Threads:
&Parameter:
Optionen
Selbstentpackendes Archiv (SF&X) erstellen
Zum Schreiben &geffnete Dateien einbeziehen
Verschlsselung
Verfahren:
Datei&namen verschlsseln
Speicherbedarf beim Komprimieren:
Speicherbedarf beim Entpacken:
Dateien nach Komprimierung lschen
4040
Symbolische Verknpfungen speichern
Harte Verknpfungen speichern
Alternative Datenstrme speichern
Dateirechte speichern
4050
Speichern
Schnellste
Schnell
Normal
Maximum
Ultra
4060
Hinzufgen und Ersetzen
Aktualisieren und Hinzufgen
Vorhandene Dateien aktualisieren
Synchronisieren
4070
Durchsuchen
Alle Dateien
Nicht solide
Solide
6000
Kopieren
Verschieben
Kopieren nach:
Verschieben nach:
Kopiere...
Verschiebe...
Umbenennen...
Zielordner auswhlen
Die Operation wird fr diesen Ordner nicht untersttzt.
Fehler beim Umbenennen von Datei oder Ordner
Kopieren besttigen
Sollen die Dateien wirklich in dieses Archiv kopiert werden:
6100
Lschen von Datei besttigen
Lschen von Ordner besttigen
Lschen von mehreren Dateien besttigen
Soll "{0}" wirklich gelscht werden?
Soll der Ordner "{0}" und sein gesamter Inhalt wirklich gelscht werden?
Sollen diese {0} Objekte wirklich gelscht werden?
Lsche...
Fehler beim Lschen von Datei oder Ordner
Das System kann Dateien mit langem Pfad nicht in den Papierkorb verschieben.
6300
Ordner erstellen
Datei erstellen
Ordnername:
Dateiname:
Neuer Ordner
Neue Datei
Fehler beim Erstellen des Ordners
Fehler beim Erstellen der Datei
6400
Kommentar
&Kommentar:
Auswhlen
Auswahl aufheben
Filter:
6600
Eigenschaften
Ordnerverlauf
Diagnosemeldungen
Meldung
7100
Arbeitsplatz
Netzwerk
Dokumente
System
7200
Hinzufgen
Entpacken
berprfen
Kopieren
Verschieben
Lschen
Eigenschaften
7300
Datei aufsplitten
Teildateien &nach:
In &Teildateien aufsplitten (Bytes):
Aufsplitten...
Aufsplitten besttigen
Sind Sie sicher, die Datei in {0} Teildateien aufsplitten zu wollen?
Die Gre der Teildateien muss kleiner sein als die der ursprnglichen Datei.
Ungltiger Wert fr Dateigren
Angegebene Gre fr Teildateien: {0} Bytes.\nSind Sie sicher, dass das Archiv dementsprechend aufgesplittet werden soll?
7400
Dateien zusammenfgen
Zieldatei &nach:
Zusammenfgen...
Bitte nur den ersten Teil der Datei auswhlen.
Datei nicht als Teil einer aufgesplitteten Datei erkannt
Kann nicht mehr als eine Teildatei finden.
7500
Berechne Prfsumme...
Prfsummen-Information
CRC-Prfsumme ber die Daten:
Prfsumme ber Daten und Namen:
7600
Benchmark
Speichernutzung:
Komprimierung
Dekomprimierung
Bewertung
Gesamtwertung
Aktuell
Ergebnis
CPU-Nutzung
Bewert./Nutzung
Durchlufe:
7700
Verknpfung
Verknpfung
Verknpfung von:
Verknpfung zu:
7710
Verknpfungsart
Harte Verknpfung
Datei Symbolische Verknpfung
Ordner Symbolische Verknpfung
Ordner Verbindung
;!@Lang2@!UTF-8!
;       : Vasileios Karakoidas, Jacaranda Bill, Vasilis Kosmidis
;  9.07 : SkyHi [HDManiacs Team]
; 15.00 : 2015-05-07: Pete D
;
;
;
;
;
;
;
;
0
7-Zip
Greek

401
OK




&
&
&


&
440
  &
  &
&

 &
 &
&

     ;
500
&
&
&
&
&
&
540
&
  & 
  & 
&
&
&
&...
&...
&
& ...
& ...
&

  
Diff
 
 
&

&Alternate Streams
600
& 
 
 
...
...
     
     
700
 &
& 
&
&
730
 
 
2 
& 
  
   
& ...
&
 
750


 
 
800
&    

900
&...
& 
960
&...
&  7-Zip...
1003





 







 
 






 





 





Offset




64-bit
Big-endian
CPU
 
 headers
 

 
ID
 
 
 
 


 
 
 

 

NT Security
Alternate Stream
Aux
Deleted
Is Tree


 




Streams
Alternate Streams
Alternate Streams Size
 
 
  
 
SubType
 




Tail Size
Embedded Stub Size

 
iNode

-
2100


:
 
& :
&Diff:
2200

  7-Zip   :
  
2301
  7-Zip  
   
   :
   
2320
<>
< >

 ...
   ...
  
 
   {0}
  {0}
    e-mail...
  {0}    e-mail
2400

& 
&  
& 
&:
     
       .
2500

  ".."
     
  
&  
  
    
  
  & 
2900
   7-Zip
 7-Zip   .            .
3000
         .
  
{0}  
     '{0}'
           .
      '{0}'   
       '{0}'.  ;
   .
  {0}  .
  '{0}' .\n     ;
    \n'{0}'
       .
     (     ).
            .
    .
      .
  
     {0} 
     {0} 
      offset
3300



...
...
...
3320
..
..
..
..
..
..
..
 ..
3400

&  :
   .
3410
  
  
  
  
  
3420
  
  
  
   
 
    
3430
  
  
3500
   
          .
     
 ;
{0} bytes
 &
3700
      '{0}'.
   {0}.    .
  CRC   '{0}'.    .
     '{0}'.  ;
  CRC     '{0}'.  ;
3710
 ;
3721
   
 
  CRC 
  
  
       
   
 
 
3763
     
    



  
3800
  
 :
   :
& 
   .
   ,     (!, #, ...)  .
    .
 
3900
:
:
:
:
:
 
:
 :
4000
   
&  :
& :
  &:
 :
& :
 &:
 &:
  :
  CPU
&:
 
   (SF&X)
  

 
  &
   :
   :
    
4040
  
  
   
  
4050

 




4060
   
   
   
 
4070

  
-

6000


 :
 :
...
...
...
  .
   .
    .
  
          ;
6100
   
   
   
       '{0}' ;
        '{0}'     ;
        {0} ;
...
    .
             .
6300
 
 
 :
 :
 
 
    .
    .
6400

&:


 :
6600

 
 

7100




7200







7300
 
& :
  :
...
 
         {0} ;
            .
  
  : {0} bytes.\n          ;
7400
 
& :
...
    
         .
         .
7500
  ...
  
  CRC  :
  CRC    :
7600
 
 :



. 
 

 CPU
//
:
7700


 :
 :
7710
 
 
  
  
 
;!@Lang2@!UTF-8!
; 15.00 : 2015-03-29 : Igor Pavlov
;
;
;
;
;
;
;
;
;
;
0
7-Zip
English
English
401
OK
Cancel



&Yes
&No
&Close
Help

&Continue
440
Yes to &All
No to A&ll
Stop
Restart
&Background
&Foreground
&Pause
Paused
Are you sure you want to cancel?
500
&File
&Edit
&View
F&avorites
&Tools
&Help
540
&Open
Open &Inside
Open O&utside
&View
&Edit
Rena&me
&Copy To...
&Move To...
&Delete
&Split file...
Com&bine files...
P&roperties
Comme&nt...
Calculate checksum
Diff
Create Folder
Create File
E&xit
Link
&Alternate Streams
600
Select &All
Deselect All
&Invert Selection
Select...
Deselect...
Select by Type
Deselect by Type
700
Lar&ge Icons
S&mall Icons
&List
&Details
730
Unsorted
Flat View
&2 Panels
&Toolbars
Open Root Folder
Up One Level
Folders History...
&Refresh
Auto Refresh
750
Archive Toolbar
Standard Toolbar
Large Buttons
Show Buttons Text
800
&Add folder to Favorites as
Bookmark
900
&Options...
&Benchmark
960
&Contents...
&About 7-Zip...
1003
Path
Name
Extension
Folder
Size
Packed Size
Attributes
Created
Accessed
Modified
Solid
Commented
Encrypted
Split Before
Split After
Dictionary

Type
Anti
Method
Host OS
File System
User
Group
Block
Comment
Position
Path Prefix
Folders
Files
Version
Volume
Multivolume
Offset
Links
Blocks
Volumes

64-bit
Big-endian
CPU
Physical Size
Headers Size
Checksum
Characteristics
Virtual Address
ID
Short Name
Creator Application
Sector Size
Mode
Symbolic Link
Error
Total Size
Free Space
Cluster Size
Label
Local Name
Provider
NT Security
Alternate Stream
Aux
Deleted
Is Tree


Error Type
Errors
Errors
Warnings
Warning
Streams
Alternate Streams
Alternate Streams Size
Virtual Size
Unpack Size
Total Physical Size
Volume Index
SubType
Short Comment
Code Page



Tail Size
Embedded Stub Size
Link
Hard Link
iNode

Read-only
2100
Options
Language
Language:
Editor
&Editor:
&Diff:
2200
System
Associate 7-Zip with:
All users
2301
Integrate 7-Zip to shell context menu
Cascaded context menu
Context menu items:
Icons in context menu
2320
<Folder>
<Archive>
Open archive
Extract files...
Add to archive...
Test archive
Extract Here
Extract to {0}
Add to {0}
Compress and email...
Compress to {0} and email
2400
Folders
&Working folder
&System temp folder
&Current
&Specified:
Use for removable drives only
Specify a location for temporary archive files.
2500
Settings
Show ".." item
Show real file icons
Show system menu
&Full row select
Show &grid lines
Single-click to open an item
&Alternative selection mode
Use &large memory pages
2900
About 7-Zip
7-Zip is free software
3000
The system cannot allocate the required amount of memory
There are no errors
{0} object(s) selected
Cannot create folder '{0}'
Update operations are not supported for this archive.
Can not open file '{0}' as archive
Can not open encrypted archive '{0}'. Wrong password?
Unsupported archive type
File {0} is already exist
File '{0}' was modified.\nDo you want to update it in the archive?
Can not update file\n'{0}'
Cannot start editor.
The file looks like a virus (the file name contains long spaces in name).
The operation cannot be called from a folder that has a long path.
You must select one file
You must select one or more files
Too many items
Can not open the file as {0} archive
The file is open as {0} archive
The archive is open with offset
3300
Extracting
Compressing
Testing
Opening...
Scanning...
Removing
3320
Adding
Updating
Analyzing
Replicating
Repacking
Skipping
Deleting
Header creating
3400
Extract
E&xtract to:
Specify a location for extracted files.
3410
Path mode:
Full pathnames
No pathnames
Absolute pathnames
Relative pathnames
3420
Overwrite mode:
Ask before overwrite
Overwrite without prompt
Skip existing files
Auto rename
Auto rename existing files
3430
Eliminate duplication of root folder
Restore file security
3500
Confirm File Replace
Destination folder already contains processed file.
Would you like to replace the existing file
with this one?
{0} bytes
A&uto Rename
3700
Unsupported compression method for '{0}'.
Data error in '{0}'. File is broken.
CRC failed in '{0}'. File is broken.
Data error in encrypted file '{0}'. Wrong password?
CRC failed in encrypted file '{0}'. Wrong password?
3710
Wrong password?
3721
Unsupported compression method
Data error
CRC failed
Unavailable data
Unexpected end of data
There are some data after the end of the payload data
Is not archive
Headers Error
Wrong password
3763
Unavailable start of archive
Unconfirmed start of archive



Unsupported feature
3800
Enter password
Enter password:
Reenter password:
&Show password
Passwords do not match
Use only English letters, numbers and special characters (!, #, $, ...) for password
Password is too long
Password
3900
Elapsed time:
Remaining time:
Total size:
Speed:
Processed:
Compression ratio:
Errors:
Archives:
4000
Add to archive
&Archive:
&Update mode:
Archive &format:
Compression &level:
Compression &method:
&Dictionary size:
&Word size:
Solid block size:
Number of CPU threads:
&Parameters:
Options
Create SF&X archive
Compress shared files
Encryption
Encryption method:
Encrypt file &names
Memory usage for Compressing:
Memory usage for Decompressing:
Delete files after compression
4040
Store symbolic links
Store hard links
Store alternate data streams
Store file security
4050
Store
Fastest
Fast
Normal
Maximum
Ultra
4060
Add and replace files
Update and add files
Freshen existing files
Synchronize files
4070
Browse
All Files
Non-solid
Solid
6000
Copy
Move
Copy to:
Move to:
Copying...
Moving...
Renaming...
Select destination folder.
The operation is not supported for this folder.
Error Renaming File or Folder
Confirm File Copy
Are you sure you want to copy files to archive
6100
Confirm File Delete
Confirm Folder Delete
Confirm Multiple File Delete
Are you sure you want to delete '{0}'?
Are you sure you want to delete the folder '{0}' and all its contents?
Are you sure you want to delete these {0} items?
Deleting...
Error Deleting File or Folder
The system cannot move a file with long path to the Recycle Bin
6300
Create Folder
Create File
Folder name:
File Name:
New Folder
New File
Error Creating Folder
Error Creating File
6400
Comment
&Comment:
Select
Deselect
Mask:
6600
Properties
Folders History
Diagnostic messages
Message
7100
Computer
Network
Documents
System
7200
Add
Extract
Test
Copy
Move
Delete
Info
7300
Split File
&Split to:
Split to &volumes, bytes:
Splitting...
Confirm Splitting
Are you sure you want to split file into {0} volumes?
Volume size must be smaller than size of original file
Incorrect volume size
Specified volume size: {0} bytes.\nAre you sure you want to split archive into such volumes?
7400
Combine Files
&Combine to:
Combining...
Select only first part of split file
Can not detect file as part of split file
Can not find more than one part of split file
7500
Checksum calculating...
Checksum information
CRC checksum for data:
CRC checksum for data and names:
7600
Benchmark
Memory usage:
Compressing
Decompressing
Rating
Total Rating
Current
Resulting
CPU Usage
Rating / Usage
Passes:
7700
Link
Link
Link from:
Link to:
7710
Link Type
Hard Link
File Symbolic Link
Directory Symbolic Link
Directory Junction
;!@Lang2@!UTF-8!
;  4.37 : Dmitri Gabinski
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Esperanto
Esperanto
401
B&one
Nuligu



&Jes
&Ne
&Fermu
Helpo

&Darigu
440
Jes por &iuj
Ne por i&uj
&Haltu
Restartigu
&Fono
&Malfono
&Pazo
Pazita
u vi vere volas nuligi?
500
&Dosiero
&Redakto
&Vido
&Favoritaj
&Agordoj
&Helpo
540
&Malfermu
Malfermu &ene
Malfermu ek&stere
&Vidigu
&Redaktu
&anu nomon
&Kopiu en...
M&ovu en...
&Forigu
&Erigu dosierojn...
Komb&inu dosierojn...
A&tributoj
Ko&mentu
Kalkulu kontrolsumon

Kreu &dosierujon
Kre&u dos&ieron
E&liru
600
M&arku iun
Ma&lmarku iun
&Inversigu markon
Marku...
Malmarku...
Marku la tipo
Malmarku la tipo
700
&Grandaj bildetoj
&Malgrandaj bildetoj
&Listo
&Detale
730
&Neordigite
Ununivela vido
&2 paneloj
&Ilobretoj
Malfermu radikan dosierujon
Supren je unu nivelo
Dosierujhistorio...
&isdatigu
750
Arivo-ilobreto
Norma ilobreto
Grandaj bildetoj
Montru butontekston
800
&Aldonu dosierujon al favorataj kiel
Legosigno
900
&Agordoj...
&Etalono
960
&Enhavo...
&Pri 7-Zip...
1003
Dosierindiko
Nomo
Dosiernoma sufikso
Dosierujo
Grando
Enariva grando
Atributoj
Kreita
Malfermita
anita
Solida
Komento
ifra
Disigita anta
Disigita post
Vortaro
CRC
Tipo
Kontra
Metodo
Gastiga operaciumo
Dosiersistemo
Uzulo
Grupo
Bloko
Komento
Pozicio
Vojprefikso
























Eraro
Kapacito
Libera
Faskogrando
Marko
Loka nomo
Provizanto
2100
Agordoj
Lingvo
Lingvo:
Redaktilo
&Redaktilo:

2200
Sistemo
Asociu 7-Zip-on kun dosieroj:
2301
Metu 7-Zip'on en kuntekstan menuon de elo
Kaskada kunteksta menuo
Punktoj de kunteksta menuo:
2320
<Dosierujo>
<Arivo>
Malfermu
Elarivigu dosierojn...
Enarivigu...
Testu arivon
Elarivigu i-tien
Elarivigu en {0}
Aldonu al {0}
Enarivigu kaj enretpotigu...
Enarivigu en {0} kaj enretpotigu...
2400
Dosierujoj
&Kuranta dosierujo
&Sistema labora dosierujo
&i tiu
&Specifu:
&Uzi nur por demeteblaj datumportiloj
Specifu ujon por laboraj dosieroj.
2500
Agordoj
Montru ".."-elementon
Montru realajn dosierbildetojn
Montru sisteman menuon
Marku &tutan linion
Montru &kradliniojn

&Alternativa markreimo
Uzu &grandajn memorpaojn
2900
Informo
7-Zip estas senpaga programo. Tamen, vi povas subteni evoluadon de 7-Zip per enregistrio.
3000

Eraroj ne trovitaj
{0} objekto(j) markita(j)
Fiaskis krei dosierujon '{0}'
isdatigoperacioj ne estas subtenataj por i-tiu arivo.




Dosiero '{0}' aniis.\nu vi volas istadigi in enraive?
Fiaskis isdatigi dosieron\n'{0}''
Fiaskis startigi redaktilon.




Troaj elementoj
3300
Elarivigo
Densigo
Testado
Malfermo...
Analizante...
3400
&Elarivigu
E&larivigu en:
Specifu ujon por elarivendaj dosieroj.
3410
Dosierindikoj
&Absolutaj dosierindikoj
&Sen dosierindikoj
3420
Anstataiga skribreimo
&Kun konfirmo
&Sen konfirmo
&Preterlasu estantaj dosieroj
Atonomano
Atonomano de ekzistantaj dosieroj
3500
Konfirmo de nomano
Dosierujo jam enhavas prilaboratan dosieron.
Anstataigu estantan dosieron
per i-tiu?
{0} bajtoj
&Atonomano.
3700
Ne estas subtenata densigmetodo por dosiero '{0}'.
Datumeraro en '{0}'. Difektiinta dosiero.
CRC-eraro en '{0}'. Difektiinta dosiero.


3800
Pasvorto
Enigu pasvorton:

&Montru pasvorton



&Pasvorto
3900
Pasinta tempo:
Restanta tempo:
Grando:
Rapideco:


Eraroj:

4000
Enarivigu
&Arivo:
A&nstataigreimo:
A&rivformato:
Densigo&nivelo
&Densigmetodo:
&Vortarogrando:
Vo&rtogrando:


&Parametroj:
Agordoj
Kreu SF&X-arivon



ifru dosier&nomojn
Memoruzo por densigo:
Memoruzo por maldensigo:
4050
Sen densigo
Plej rapide
Rapide
Normala densigo
Maksimuma densigo
Ultra
4060
Aldonu kaj anstataigu dosierojn
isdatigu kaj aldonu dosierojn
Refreigu estantajn dosierojn
Sinkronigu dosierojn
4070
Foliumu
iuj dosieroj


6000
Kopiu
Movu
Kopiu en:
Movu en:
Kopio...
Movo...
Nomano...

Operacio ne estas subtenata.
Eraro dum nomano de dosiero a dosierujo
Konfirmu dosierkopion
u vere kopii dosierojn enariven
6100
Konfirmo de forigo de dosiero
Konfirmo de forigo de dosierujo
Konfirmo de forigo de dosieraro
u vi vere volas forigi '{0}'?
u vi vere volas forigi dosierujon "{0}" kaj tutan ian enhavon?
u vi vere volas forigi i tiajn {0} objektojn?
Forigo...
Eraro dum forigo de dosiero a dosierujo

6300
Kreu dosierujon
Kreu dosieron
Dosierujnomo:
Dosiernomo:
Nova dosierujo
Nova dosiero
Eraro dum dosierujkreo
Eraro dum dosierkreo
6400
Komento
&Komento:
Marku
Malmarku
Masko:
6600

Dosierujhistorio
Diagnozaj mesaoj
Mesao
7100
Komputilo
Reto

Sistemo
7200
Enarivigu
Elarivigu
Testu
Kopiu
Movu
Forigu
Informo
7300
Erigu dosieron
&Erigu en:
&Plurvolumigu, bajtoj:
Erigo...





7400
Kombinu dosierojn
&Kombinu en:
Kombino...



7500
Kalkulante kontrolsumon...
Informo pri kontrolsumo
CRC-kontrolsumo por datumoj:
CRC-kontrolsumo por datumoj kaj nomoj:
7600
Etalono
Memoruzo:
Densigo
Maldensigo
Takso
Tuta takso
Kuranta
Rezulta


Pasoj:
;!@Lang2@!UTF-8!
;                    : Pablo Rodriguez
;                    : Jbc25
;       : 2007-09-05 : Guillermo Gabrielli
;  9.07 : 2010-06-10 : Purgossu
;         2010-10-23 : Sergi Medina (corrected) 
;
;
;
;
;
;
0
7-Zip
Spanish
Espaol
401
Aceptar
Cancelar



&S
&No
&Cerrar
Ayuda

&Continuar
440
S a &todo
No a t&odo
Parar
Volver a empezar
Se&gundo plano
P&rimer plano
&Pausa
Pausado
Ests seguro de que deseas cancelar?
500
&Archivo
&Editar
&Ver
&Favoritos
&Herramientas
Ay&uda
540
&Abrir
Abrir &dentro
Abrir &fuera
&Ver
&Editar
Re&nombrar
&Copiar a...
&Mover a...
&Borrar
Di&vidir archivo...
C&ombinar archivos...
&Propiedades
Comen&tario
Suma de verificacin
Diff
Crear carpeta
Crear archivo
&Salir
600
Seleccionar &todo
Deseleccionar todo
&Invertir seleccin
Seleccionar...
Deseleccionar...
Seleccionar por tipo
Deseleccionar por tipo
700
Iconos g&randes
&Iconos pequeos
&Lista
&Detalles
730
Desordenado
Vista plana (flat view)
&2 paneles
&Barras de herramientas
Abrir directorio raz
Subir un directorio
Historia de carpetas...
&Actualizar
750
Barra de herramientas Archivo
Barras de herramientas estndar
Botones grandes
Mostrar texto en los botones
800
&Aadir carpeta a favoritos como
Agregar a favoritos
900
&Opciones...
&Pruebas (benchmark)
960
&Contenido...
&Acerca de 7-Zip...
1003
Ruta
Nombre
Tipo de archivo
Directorio
Tamao
Tamao comprimido
Atributos
Creado
Acceso
Modificado
Compacto
Comentado
Encriptado
expandido antes
expandido despus
Diccionario
CRC
Tipo
Anti
Mtodo
SO de origen
Sistema de archivos
Usuario
Grupo
Bloque
Comentario
Posicin
Ruta
Directorios
Ficheros
Versin
Volumen
Multivolumen
Desplazamiento
Vnculos
Bloques
Volmenes

64-bit
Big-endian
CPU
Tamao fsico
Tamao de las cabeceras
Verificacin de suma
Caractersticas
Direccin virtual
ID
Nombre corto
Aplicacin de creacin
Tamao de sector
Modo
Enlace
Error
Espacio total
Espacio libre
Tamao de clster
Etiqueta
Nombre local
Proveedor
2100
Opciones
Lengua
Lengua:
Editor
&Editor:
&Diff:
2200
Sistema
Asociar 7-Zip con:
2301
Integrar 7-Zip en el men contextual de Windows
Men contextual en cascada
Elementos en el men contextual:
2320
<Carpeta>
<Archivo>
Abrir comprimido
Extraer ficheros...
Aadir al archivo...
Comprobar archivo
Extraer aqu
Extraer en {0}
Aadir a {0}
Comprimir y enviar por correo...
Comprimir a {0} y enviar por correo
2400
Directorios
Directorio de &trabajo
Directorio temporal del &sistema
Directorio &actual
&Especificar directorio:
Usar solo para dispositivos extrables
Especificar un directorio para archivos temporales.
2500
Propiedades
Mostrar el elemento ".."
Mostrar iconos propios
Mostrar men del sistema
&Seleccionar fila(s) entera(s)
Mostrar &cuadrcula
Clicar una vez para abrir elemento
Modo de seleccin &alternativo
Usar pginas &grandes de memoria
2900
Acerca de 7-Zip
7-Zip es un programa excelente; adems, es libre y gratuito. T puedes apoyar el desarrollo de 7-Zip registrndote para contribuir a mejorar el programa.
3000
El sistema no ha podido asignar la cantidad necesaria de memoria
No hay errores
{0} elemento(s) seleccionado(s)
No se puede crear el directorio '{0}'
Este tipo de archivo no permite actualizacin.
No se puede abrir '{0}' como un archivo comprimido
No se puede abrir el archivo encriptado '{0}'. Verifique la contrasea.
Tipo de archivo no soportado
El fichero {0} ya existe
El fichero '{0}' ha sido modificado.\nQuieres actualizarlo en el archivo?
No puede actualizarse el fichero\n'{0}'
No puede ejecutarse el editor.
El fichero parece un virus (el nombre del fichero contiene espacios largos).
No puede realizarse la operacin desde una carpeta que tenga una ruta larga.
Debes seleccionar un fichero
Debes seleccionar uno o ms ficheros
Demasiados elementos
3300
extrayendo
comprimiendo
probando
abriendo...
Buscando...
3400
Extraer
E&xtraer a:
Selecciona destino para los archivos extrados.
3410
Modo de directorio
Directorio completo
Sin directorio
3420
Sobreescribir
Con confirmacin
Sin confirmacin
Conservar archivos existentes
Renombrar automticamente
Autorrenombrar archivos existentes
3500
Confirmar sustitucin de archivos
El directorio ya contiene un archivo con el mismo nombre.
Deseas sustituir el archivo existente
por este otro?
{0} bytes
Renombrar a&utomticamente
3700
Mtodo de compresin no vlido para '{0}'.
Error de datos en '{0}'. El archivo est corrupto.
CRC ha fallado en '{0}'. El archivo est corrupto.
Error de datos en el archivo encriptado '{0}'. Verifica la contrasea.
Fallo de CRC en el archivo encriptado '{0}'. Verifica la contrasea.
3800
Introduce la contrasea
E&scribe la contrasea:
Escribe nue&vamente la contrasea:
&Mostrar la contrasea
Las contraseas son diferentes. Por favor, vuelve a escribirlas.
Usa en la contrasea solamente letras del alfabeto ingls, nmeros y caracteres especiales (!, #, $, ...)
La contrasea es demasiado larga.
Contrasea
3900
Tiempo transcurrido:
Tiempo pendiente:
Tamao:
Velocidad:
Procesado:
Razn de compresin:
Errores:
Archivos:
4000
Aadir al archivo
&Archivo:
M&odo de actualizacin:
&Formato de archivo:
Nive&l de compresin:
&Tipo de compresin:
Tamao de &diccionario:
Tama&o de la palabra:
Tamao de bloque compacto:
Nmero de hilos de la CPU:
&Parmetros:
Opciones
Crear archivo SF&X (autoextrable)
Comprimir archivos abiertos para escritura
Encriptacin
Mtodo de &encriptacin:
Encriptar &nombres de fichero
Memoria usada para comprimir:
Memoria usada para descomprimir:
4050
Sin compresin
La ms rpida
Rpida
Normal
Mxima
Ultra
4060
Aadir y sustituir archivos
Actualizar y aadir archivos
Solo actualizar archivos
Sincronizar archivos
4070
Explorar
Todos los archivos
No compacto
Sin lmite
6000
Copiar
Mover
Copiar a:
Mover a:
copiado...
movido...
Renombrando...
Selecciona la carpeta de destino
Operacin no permitida.
Error renombrando fichero o carpeta
Confirmar copia de ficheros
Ests seguro de que deseas copiar los ficheros al archivo
6100
Confirmar borrado de archivo
Confirmar borrado de carpeta
Confirmar borrado de numerosos ficheros
Ests seguro de querer borrar '{0}'?
Ests seguro de querer borrar la carpeta '{0}' y todo su contenido?
Ests seguro de querer borrar estos {0} elementos?
Borrando...
Error borrando fichero o carpeta
El sistema no puede mover un fichero con ruta larga a la Papelera de Reciclaje
6300
Crear carpeta
Crear archivo
Nombre de carpeta:
Nombre de archivo:
Carpeta nueva
Archivo nuevo
Error creando carpeta
Error creando archivo
6400
Comentario
&Comentario:
Seleccionar
Deseleccionar
Mscara:
6600
Propiedades
Historial de carpetas
Mensajes de diagnstico
Mensaje
7100
Mi PC
Entorno de red
Documentos
Sistema
7200
Agregar
Extraer
Probar
Copiar
Mover
Borrar
Informacin
7300
Dividir archivo
Di&vidir a:
Dividir en fra&gmentos (bytes):
Dividiendo...
Confirmar divisin
Ests seguro de que deseas dividir el archivo en {0} partes?
El tamao de los fragmentos debe ser menor que el del archivo original
Tamao de fragmento incorrecto
Tamao de fragmento especificado: {0} bytes.\nEsts seguro de que deseas dividir el archivo en fragmentos de ese tamao?
7400
Combinar archivos
&Combinar a:
Combinando...
Selecciona solamente el primer archivo
No se ha podido detectar el fichero como parte de un fichero por volmenes
No se ha podido encontrar ms que un fragmento del fichero por volmenes
7500
Calculando suma de verificacin...
Suma de verificacin (CRC)
CRC de los datos:
CRC de los datos y nombres:
7600
Pruebas (benchmark)
Uso de memoria:
Compresin
Descompresin
Tasa
Tasa total
Actual
Resultante
Uso de CPU
Resultante/uso
Pasos:
;!@Lang2@!UTF-8!
;  3.09 : Kaupo Suviste
;  9.07 : Mihkel Tnnov
;
;
;
;
;
;
;
;
;
0
7-Zip
Estonian
eesti keel
401
OK
Loobu



&Jah
&Ei
&Sulge
Abi

&Jtka
440
Kigile j&ah
Kigile e&i
Seiska
Restardi
&Taustal
&Esiplaanile
&Paus
Pausiks peatatud
Kas soovite kindlasti loobuda?
500
&Fail
&Redigeeri
&Vaade
&Lemmikud
&Triistad
&Abi
540
&Ava
Ava s&ees
Ava vljasp&ool
Vaat&ur
&Redigeeri
&Nimeta mber
&Kopeeri asukohta...
&Teisalda asukohta...
Ku&stuta
Tkel&da fail...
&henda failid...
Atri&buudid
Ko&mmentaar...
Arvuta kontrollsumma
Vrdle
Loo kaust
Loo fail
&Vlju
600
V&ali kik
Thista kik valikud
&Pra valik
Vali...
Thista valik...
Vali tbi jrgi
Thista tbi jrgi valik
700
&Suured ikoonid
Vik&esed ikoonid
&Loend
ksikasja&d
730
Sortimata
Lame vaade
&Kaks paani
&Triistaribad
Ava juurkaust
Taseme vrra les
Kaustaajalugu...
&Vrskenda
750
Arhiiviriistariba
Standardnupuriba
Suured nupud
Kuva nupusildid
800
&Lisa kaust lemmikute hulka jrjehoidjana
Jrjehoidja
900
&Hlestus...
&Judlustest
960
&Sisukord...
&Teave 7-Zipi kohta...
1003
Tee
Nimi
Laiend
Kaust
Maht
Maht tihendatult
Atribuudid
Loodud
Avatud
Muudetud
htne
Kommenteeritud
Krptitud
Tkeldatud enne
Tkeldatud prast
Snastik
CRC
Tp
Anti
Meetod
Opssteem
Failissteem
Kasutaja
Rhm
Plokk
Kommentaar
Koht
Tee prefiks
Kaustu
Faile
Versioon
Kide
Mitmekiteline
Nihe
Linke
Plokke
Kiteid

64-bitine
Big-Endian
Protsessor
Fsiline maht
Piste maht
Kontrollsumma
Karakteristikud
Virtuaalaadress
ID
Lhinimi
Loomisrakendus
Sektori maht
Reiim
Link
Trge
Kogumaht
Vaba ruum
Klastri suurus
Silt
Kohalik nimi
Teenusepakkuja
2100
Hlestus
Keel
Keel:
Redaktor
&Redaktor:
&Vrdlusprogramm:
2200
Ssteem
Seosta 7-Zip laienditega:
2301
Integreeri 7-Zip kesta hpikmensse
Kaskaad-hpikmen
Hpikmen ksud:
2320
<Kaust>
<Arhiiv>
Ava arhiiv
Eralda failid...
Lisa arhiivi...
Testi arhiivi
Eralda siia
Eralda kausta {0}
Lisa arhiivi {0}
Tihenda ja meili...
Tihenda arhiiviks {0} ja meili
2400
Kaustad
&Tkaust
&Ssteemi ajutiste failide kaust
&Praegune kaust
&Kasutaja mratud:
Kasuta ainult irddraivide puhul
Mrake ajutiste arhiivifailide asukoht.
2500
Stted
Kuva element ".."
Kuva tegelikud failiikoonid
Kuva ssteemimen
&Vali terve rida
Kuva &ruudujooned
Ava ksus he klpsuga
&Alternatiivne valikureiim
Kasuta &suuri mluleheklgi
2900
Teave 7-Zipi kohta
7-Zip on vaba tarkvara. Kuid kui soovite toetada 7-Zipi arendamist, siis saate programmi registreerida.\n\n7-Zipi Eesti koduleht:\nhttp://www.hot.ee/somberg/7zip.html
3000
Ssteem ei saa eraldada nutavat mlumahtu.
Vigu ei leitud.
{0} ksus(t) valitud
Ei saa luua kausta {0}
Selle arhiivi vrskendamistoiminguid ei toetata.
Ei saa avada faili {0} arhiivina.
Ei saa avada krptitud arhiivi {0}. Kas vale parool?
Toetamata arhiivitp.
Fail {0} on juba olemas.
Faili {0} on muudetud.\nKas soovite selle arhiivis vrskendada?
Ei saa vrskendada faili\n{0}
Ei saa kivitada redaktorit.
See fail sarnaneb viirusega (faili nimi sisaldab pikka thikute jada).
Toimingut ei saa kivitada kaustast, millel on pikk tee.
Te peate valima he faili.
Te peate valima he vi mitu faili.
Liiga palju ksusi.
3300
vlja eraldatud
tihendatud
Testimine
Avamine...
Lbivaatamine...
3400
Vljaeraldamine
&Eralda vlja kausta:
Mrake vljaeraldatud failide asukoht.
3410
Teed
&Tielikud teenimed
Teenime&deta
3420
lekirjutus
Ksi e&nne lekirjutamist
Ki&rjuta ksimata le
&Jta olemasolevad failid vahele
Nimeta a&utomaatselt mber
Nimeta &olemasolevad f. autom. mber
3500
Failiasenduse kinnitamine
Sihtkaust juba sisaldab tdeldavat faili.
Kas soovite asendada olemasoleva faili
selle failiga?
{0} baiti
Nimeta a&utomaatselt mber
3700
Toetuseta tihendusmeetod failile {0}.
Andmeviga failis {0}. Fail on rikutud.
Tskkelkoodkontroll (CRC) failis {0} nurjus. Fail on rikutud.
Andmeviga krptitud failis {0}. Kas vale parool?
Tskkelkoodkontroll (CRC) krptitud failis {0} nurjus. Kas vale parool?
3800
Parooli sisestamine
Sisestage parool:
Parooli kordus:
&Kuva parool
Paroolid ei kattu.
Kasutage paroolis ainult inglise keele thti, numbreid ja erimrke (!, #, $, ...).
Parool on liiga pikk.
&Parool
3900
Kulunud aeg:
Jrelejnud aeg:
Kogumaht:
Kiirus:
Tdeldud:
Tihendussuhe:
Vigu:
Arhiive:
4000
Arhiivi lisamine
&Arhiiv:
Vrskend&usreiim:
Arhiivi&vorming:
&Tihendusaste:
Tihendus&meetod:
Snaraamatu ma&ht:
&Sna maht:
htse ploki maht:
Protsessorilimede arv:
Pa&rameetrid:
Suvandid
Loo is&eavanev arhiiv
Tihenda kirjutuseks avatud failid
Krptimine
Krptimismeetod:
Krpti faili&nimed
Mlu hivatus tihendamisel:
Mlu hivatus hrendamisel:
4050
Tihenduseta
Kiireim tihendus
Kiirtihendus
Normaaltihendus
Maksimaaltihendus
Ultratihendus
4060
Lisa ja asenda failid
Vrskenda ja lisa failid
Vrskenda olemasolevad failid
Snkrooni failid
4070
Sirvi
Kik failid
Mittehtne
htne
6000
Kopeerimine
Teisaldamine
Kopeeri asukohta:
Teisalda asukohta:
Kopeerimine...
Teisaldamine...
mbernimetamine...
Valige sihtkaust.
See toiming pole selles kaustas toetatud.
Trge faili vi kausta mbernimetamisel
Failikopeerimise kinnitamine
Kas soovite kindlasti kopeerida arhiivi jrgmised failid:
6100
Failikustutuse kinnitamine
Kaustakustutuse kinnitamine
Mitme faili kustutamise kinnitamine
Kas soovite kindlasti kustutada faili {0}?
Kas soovite kindlasti kustutada kausta {0} ja kogu selle sisu?
Kas soovite kindlasti kustutada need {0} ksust?
Kustutamine...
Trge faili vi kausta kustutamisel
Ssteem ei saa teisaldada prgikasti pika teega faili.
6300
Kausta loomine
Faili loomine
Kausta nimi:
Faili nimi:
Uus kaust
Uus fail
Trge kausta loomisel
Trge faili loomisel
6400
- kommentaar
&Kommentaar:
Valimine
Valiku thistamine
Mask:
6600
Atribuudid
Kaustaajalugu
Diagnostikateated
Teade
7100
Arvuti
Vrk
Dokumendid
Ssteem
7200
Lisa
Eralda vlja
Testi
Kopeeri
Teisalda
Kustuta
Teave
7300
Faili tkeldamine:
&Tkelda asukohta:
&Tkelda kideteks (baitides):
Tkeldamine...
Tkeldamise kinnitamine
Kas soovite kindlasti tkeldada faili {0} kiteks?
Kite maht peab olema algfaili mahust viksem.
Sobimatu kitemaht.
Mratud kitemaht: {0} baiti.\nKas soovite kindlasti tkeldada arhiivi niisugusteks kideteks?
7400
Failide hendamine:
&henda asukohta:
hendamine...
Valige ainult tkeldatud faili esimene osa.
Ei nnestu tuvastada, et see fail oleks tkeldatud faili osa.
Ei leia rohkem kui hte tkeldatud faili osa.
7500
Kontrollsumma arvutamine...
Kontrollsumma
Andmete CRC-kontrollsumma:
Andmete ja nimede CRC-kontrollsumma:
7600
Judlustest
Mlu hivatus:
Tihendamine
Hrendamine
Hinnang
ldine judlushinnang
Praegune:
Lpptulemus:
CPU hivatus
Hinnang/hivatus
Ttiire:
;!@Lang2@!UTF-8!
;  15.12 : 2015-12-04 : Xabier Aramendi
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Basque
Euskara
401
&Ongi
E&zeztatu



&Bai
&Ez
It&xi
&Laguntza

&Jarraitu
440
Bai &Guztiari
Ez G&uztiari
Gelditu
Berrabiarazi
Ba&rrenean
&Gainean
&Pausatu
Pausatuta
Zihur zaude ezeztatzea nahi duzula?
500
&Agiria
&Editatu
&Ikusi
&Gogokoenak
&Tresnak
&Laguntza
540
&Ireki
Ireki &Barnean
Ireki &Kanpoan
Ik&usi
&Editatu
Berrize&ndatu
Kopiatu &Hona...
&Mugitu Hona...
E&zabatu
Banan&du agiria...
Nahas&tu agiriak...
Ezau&garriak
&Aipamena...
Ka&lkulatu egiaztapen-batura
Ezber
Sortu Agiritegia
S&ortu Agiria
I&rten
Lotura
&Aldikatu Jarioak
600
Hautatu &Guztiak
Deshatutau G&uztiak
&Alderantzizkatu Hautapena
&Hautatu...
&Deshautatu...
Hautatu &Motaz
Deshautatu M&otaz
700
Ikur &Handiak
Ikur Txi&kiak
&Zerrenda
&Xehetasunak
730
Ant&olatugabe
Ik&uspegi Laua
&2 Panel
&Tresnabarrak
Ireki &Erro Agiritegia
Maila Bat &Gora
Agiritegi &Historia...
&Berritu
Be&rez Berritu
750
Artxibo Tresnabarra
Tresnabarra Estandarra
Botoi Handiak
Erakutsi Botoien Idazkia
800
&Gehitu agiritegia Gogokoenetara honela
Lastermarka
900
A&ukerak...
&Benchmark
960
&Edukiak...
&7-Zip Buruz...
1003
Helburua
Izena
Luzapena
Agiritegia
Neurria
Pakete Neurria
Ezaugarriak
Sortua
Sartua
Aldatua
Solidoa
Aipatua
Enkriptatua
Banandu Aurretik
Banandu Ondoren
Hiztegia

Mota
Anti
Metodoa
Hostalari SE
Agiri Sistema
Erabiltzailea
Taldea
Blokea
Aipamena
Kokapena
Helburu Aurrizkia
Agiritegiak
Agiriak
Bertsioa
Bolumena
Bolumen-anitz
Oreka
Loturak
Blokeak
Bolumenak

64-bit
Big-endian
CPU
Neurri Fisikoa
Idazburu Neurria
Egiaztapen-batura
Ezaugarriak
Helbide Birtuala
ID-a
Izen Laburra
Aplikazio Sortzailea
Sektore Neurria
Modua
Lotura Sinbolikoa
Akatsa
Neurria Guztira
Toki Askea
Kluster Neurria
Etiketa
Tokiko Izena
Hornitzailea
NT Segurtasuna
Aldikatu Jarioa
Aux
Ezabatuta
Zuhaitza da


Akats Mota
Akatsak
Akatsak
Ohartarazpenak
Ohartarazpena
Jarioak
Aldikatu Jarioak
Aldikatu Jario Neurriak
Neurri Birtuala
Despaketatu Neurria
Neurri Fisikoa Guztira
Bolumen Aurkibidea
AzpiMota
Aipamen Labura
Kode Orrialdea



Isats Neurria
Barneratutako Stub Neurria
Lotura
Lotura Gogorra
iNode

Irakurtzeko-bakarrik
2100
Aukerak
Hizkuntza
Hizkuntza:
Editatzailea
&Editatzailea:
E&zberdintasunak:
2200
Sistema
Elkartu 7-Zip hauekin:
Erabiltzaile guztiak
2301
&Bateratu 7-Zip shell hitzinguru menura
&Urjauzi hitzinguru menua
Hitzinguru menuko gaiak:
&Ikurrak hitzinguru menuan
2320
<Agiritegia>
<Artxiboa>
Ireki artxiboa
Atera agiriak...
Gehitu &artxibora...
Aztertu artxiboa
Atera Hemen
Atera hona: {0}
Gehitu hona: {0}
Konprimitu eta &bidali post@z...
Konprimitu hona {0} eta bidali post@z
2400
Agiritegiak
&Lan agiritegia
&Sistemaren aldibaterako agiritegia
&Oraingoa
A&dierazia:
&Erabili gidagailu kengarrientzat bakarrik
Adierazi aldibaterako artxibo agirientzako kokalekua
2500
Ezarpenak
&Erakutsi ".." gai
E&rakutsi egizko agiriaren ikurrak
Erakutsi siste&maren menua
&Lerro osoko hautapena
Erakutsi &saretxo lerroak
&Klik-bakarra gai bat irekitzeko
A&ukerazko hautapen modua
Erabili &oroimen handiko orrialdeak
2900
7-Zip buruz
7-Zip software askea da
3000
Sistemak ezin du beharrezko oroimen kopurua esleitu
Ez dago akatsik
{0} objetu hautaturik
Ezin da '{0}' agiritegia sortu
Eguneratze eragiketak ez daude sostengaturik artxibo honentzat.
Ezinezkoa '{0}' agiria artxibo bezala irekitzea
Ezinezkoa '{0}' artxibo enkriptatua ireki. Sarhitz okerra?
Artxibo mota ez dago sostengatua
{0} agiria badago jadanik
'{0}' agiria aldatu egin da.\nArtxioboan eguneratzea nahi duzu?
Ezinezkoa agiria eguneratzea\n'{0}'
Ezin da editatzailea abiarazi.
Agiriak birus bat ematen du (agiri izenak tarte luzeak ditu izenean).
Eragiketa ezin da helburu luze bat duen agiritegi batetik deitu
Agiri bat hautatu behar duzu
Agiri bat edo gehiago hautatu behar dituzu
Gai gehiegi
Ezin da agiria {0} artxibo bezala ireki
Agiria {0} artxibo bezala dago irekita
Artxiboa orekaz irekita dago
3300
Ateratzen
Konprimitzen
Aztertzen
Atzeratzen...
Mihatzen...
Kentzen
3320
Gehitzen
Eguneratzen
Aztertzen
Erreplikatzen
Berpaketatzen
Jauzten
Ezabatzen
Idazburua sortzen
3400
&Atera
Atera &hona:
A&dierazi ateratako agirientzako kokaleku bat.
3410
Helburu mo&dua:
Helburu-izen osoak
Helburu-izenik ez
Helburu-izen absolutoak
Helburu-izen erlatiboak
3420
Gainidazketa modua:
Galdetu gainidatzi aurretik
Gainidazi galdetu gabe
Jauzi dauden agiriak
Berez berrizendatu
Berez berrizendatu dauden agiriak
3430
Ezabatu erro agiritegi bikoizketa
Leheneratu agiri segurtasuna
3500
Baieztatu Agiri Ordeztea
Helmuga agiritegiak jadanik badu prozesatutako agiria.
Dagoen agiria ordeztea nahi duzu
beste honekin?
{0} byte
&Berez Berrizendatu
3700
Konpresio metodo sostengatu gabea '{0}'-rako.
Datu akatsa '{0}'. Agiria hautsita dago.
CRC hutsegitea '{0}'. Agiria hautsita dago.
Datu akatsa '{0}' enkriptaturiko agirian. Sarhitz okerra?
CRC hutsegitea '{0}' enkriptaturiko agirian. Sarhitz okerra?
3710
Sarhitz okerra?
3721
Konpresio metodoa ez dago sostengatua
Datu akatsa
CRC hutsegitea
Datu eskuraezinak
Ustekabeko datu amaiera
Zenbait akats daude gertaketa amaieraren ondoren
Ez da artxiboa
Idazburu Akatsa
Sarhitz okerra
3763
Artxibo hasiera eskuraezina
Artxibo hasiera baieztatugabe



Ezaugarri sostengu gabea
3800
Sartu sarhitza
Sartu sarhitza:
Bersartu sarhitza:
&Erakutsi sarhitza
Sarhitzak ez datoz bat
Erabili bakarrik Ingelerazko hizkiak, zenbakiak eta hizki bereziak (!, #, $, ...) sarhitzarentzat
Sarhitza luzeegia da
Sarhitza
3900
Igarotako denbora:
Gelditzen den denbora:
Neurria guztira:
Abiadura:
Prozesatuta:
Konpresio maila:
Akatsak:
Artxiboak:
4000
Gehitu artxibora
&Artxiboa:
Egu&neraketa modua:
Artxibo he&uskarria:
Konpre&sio maila:
Konpresio &metodoa:
&Hiztegi neurria:
Hi&tz neurria:
&Bloke solidoaren neurria:
&CPU hari zenbatekoa:
&Parametroak:
Aukerak
Sortu SF&X artxiboa
&Konprimitu elkarbanaturiko agiriak
Enkriptaketa
Enkriptaketa metodoa:
Enkriptatu agiri &izenak
Oroimen erabilera Konprimitzeko:
Oroimen erabilera Deskonprimitzeko:
Ezabatu agi&riak konprimitu ondoren
4040
Biltegiratu lotura sinbolikoak
Biltegiratu lotura gogorrak
Biltegiratu aldikatu datu jarioak
Biltegiratu agiri segurtasuna
4050
Biltegia
Azkarrena
Azkarra
Arrunta
Gehiena
Ultra
4060
Gehitu eta ordeztu agiriak
Eguneratu eta gehitu agiriak
Berritu dauden agiriak
Aldiberetu agiriak
4070
Bilatu
Agiri Denak
Ez-solidoa
Solidoa
6000
Kopiatu
Mugitu
Kopiatu hona:
Mugitu hona:
Kopiatzen...
Mugitzen...
Berrizendatzen...
Hautatu helmuga agiritegia.
Eragiketa hau ez dago sostengatua agiritegi honentzat.
Akatsa Agiria edo Agiritegia Berrizendatzerakoan
Baieztatu Agiri Kopiatzea
Zihur zaude agiriak artxibora kopiatzea nahi dituzula
6100
Baieztatu Agiri Ezabapena
Baieztatu Agiritegi Ezabapena
Baieztatu Agiri Anitz Ezabapena
Zihur zaude '{0}' ezabatzea nahi duzula?
Zihur zaude '{0}' agiritegia eta bere eduki guztiak ezabatzea nahi dituzula?
Zihur zaude {0} gai hauek ezabatzea nahi dituzula?
Ezabatzen...
Akatsa Agiria edo Agiritegia Ezabatzerakoan
Sistemak ezin du helburu luzeko agiria Birziklapen Ontzira mugitu
6300
Sortu Agiritegia
Sortu Agiria
Agiritegi izena:
Agiri Izena:
Agiritegi Berria
Agiri Berria
Akatsa Agiritegia Sortzerakoan
Akatsa Agiria Sortzerakoan
6400
Aipamena
&Aipamena:
Hautatu
Deshautatu
Mozorroa:
6600
Ezaugarriak
Agiritegi Historia
Azterketa mezuak
Mezuak
7100
Ordenagailua
Sarea
Agiriak
Sistema
7200
Gehitu
Atera
Aztertu
Kopiatu
Mugitu
Ezabatu
Argibideak
7300
Banandu Agiria
Banandu &hona:
Banandu &bolumenetan, byte:
Banantzen...
Baieztatu Banantzea
Zihur zaude agiria {0} bolumenetan banantzea nahi duzula?
Bolumen neurria jatorrizko agiriaren neurria baino txikiagoa izan behar da
Bolumen neurri okerra
Adierazitako bolumen neurria: {0} byte.\nZihur zaude artxiboa bolumenetan banantzea nahi duzula?
7400
Nahastu Agiriak
&Nahastu hona:
Nahasten...
Hautatu bakarrik banantzeko agiriaren lehen atala
Ezin da agiria atzeman banandutako agiriaren atal bezala
Ezin da aurkitu banandutako agiriaren atal bat baino gehiago
7500
Egiaztapen-batura kalkulatzen...
Egiaztapen-batura argibideak
CRC Egiaztapen-batura datuentzat:
CRC Egiaztapen-batura datu eta izenentzat:
7600
Benchmark
Oroimen erabilpena:
Konprimitzen
Deskonprimitzen
Mailaketa
Mailaketa Guztira
Oraingoa
Emaitza
CPU Erabilpena
Mailaketa / Erabilpena
Pasaldiak:
7700
Lotura
Lotura
Lotura hemendik:
Lotura hona:
7710
Lotura Mota
Lotura Gogorra
Agiri Lotura Sinbolikoa
Zuzenbide Lotura Sinbolikoa
Zuzenbide Elkargunea
;!@Lang2@!UTF-8!
;       : Miguel Angel
;  9.07 : Purgossu
;
;
;
;
;
;
;
;
;
0
7-Zip
Extremaduran
Estremeu
401
Acetal
Cancelal



&S
&Nu
&Fechal
Ayua

A&continal
440
S &a t
Nu a &t
Paral
Reinicial
Se&gundu pranu
&Primel pranu
&Paral
Parau
De siguru que quieri cancelal la operacin?
500
&Archivu
&Eital
&Vel
A&tihus
&Herramientas
A&yua
540
&Abril
Abril &dentru
Abril &huera
&Vel
&Eital
Renom&bral
&Copial a...
&Movel pa...
&Eliminal
De&sapartal ficheru...
Com&binal ficherus...
P&ropieais
Come&ntariu
Calculal suma e verificacin
Diff
Creal diretriu
Creal ficheru
&Salil
600
Selecional &t
Deselecional t
&Invertil selecin
Selecional...
Deselecional...
Selecional pol tipu
Deselecional pol tipu
700
Iconus g&randis
Iconus caquerus
&Listau
&Detallis
730
Nu soportau
Vista prana
&2 panelis
Barra e herramien&tas
Abril diretriu ra
Subil un nivel
Estorial de diretrius...
&Atualizal
750
Barra e herramientas 'archivu'
Barra e herramientas estndal
Botonis grandis
Muestral testu enus botonis
800
&Al diretriu a Atihus comu
Atihu
900
&Ocionis...
&Prebas ('benchmark')
960
&Contenius...
&Al tentu 7-Zip...
1003
Ruta
Nombri
Estensin
Diretriu
Tamau
Tamau comprimiu
Atributus
Creau'l
rtimu acesu
Escambiau'l
Sliu
Comentau
Encrihtau
Desapartau enantis
Desapartau endispus
Izionriu
CRC
Tipu
Anti
Mtou
S.O. orihin
Sistema d'archivus
Usuariu
Grupu
Broqui
Comentariu
Posicin
Prefihu la ruta
Diretrius
Ficherus
Velsin
Volumin
Murtivolumin
Desprazamientu
Enlacis
Broquis
Volmenis

64-bit
Big-endian
UCP
Tamau fsicu
Tamau las cabiceras
Suma e cumprebacin
Caratersticas
Direcin virtual
ID
Nombri cortu
Apricacin criaora
Tamau el setol
Mou
Enlaci
Yerru
Tamau total
Espaciu dispunibri
Tamau el 'cluster'
Etiqueta
Nombri local
Proveol
2100
Ocionis
Palra
Palra:
Eitol
&Eitol:
&Diff:
2200
Sistema
Asocial 7-Zip a hormatus:
2301
Integral 7-Zip nel men contestual
Men contestual en casc
Elementus del men contestual:
2320
<Diretriu>
<Archivu>
Abril archivu
Estrayel ficherus...
Al al archivu...
Comprebal archivu
Estrayel aquina
Estrayel en {0}
Aiil a {0}
Comprimil i envial pol correu-e...
Comprimil en {0} i envial pol correu
2400
Diretrius
Diretriu e labu&tu
Diretriu temporal del &sistema
Diretriu &ahtual
&Especifical:
Usal slu pa dispositivus estraybris
Especifical ruta pa ficherus d'archivus temporalis.
2500
Configuracin
Muestral l'elementu \.."
Muestral icunus propius del ficheru
Muestral men el sistema
&Selecional fila(s) enteriza(s)
Muestral lnias e la &cuaircula
'Click' nicu p'abril un elementu
Mu e selecin &alternativu
Usa&l phinas de memoria grandis
2900
About 7-Zip
7-Zip es una apricacin libri i a gastus pagus. Peru puei apoyal el desarrollu e 7-Zip meyanti'l rehistru el pograma.
3000
El sistema nu  su escaps d'asinal la canti prehisa de memoria
Sin yerrus
{0} elementu(s) selecionaus
Nu s' puiu crial el diretriu '{0}'
Nu se puei atualizal esti tipu d'archivu.
Nu s' puiu abril '{0}' comu archivu
Nu s'a puiu abril l'archivu encritau '{0}'. Consea yerronia?
Tipu archivu nu suportau
File {0} is already exist
El ficheru '{0}'  su moificau.\nAtualizalu nel archivu?
Nu s' puu atualizal l'archivu\n'{0}'
Nu s' puu ehecutal el eitol.
El ficheru pahi un virus (el nombri'l ficheru contieni espacius largus nel nombri).
Nu puei realizasi la operacin dendi un diretriu que tenga una ruta larga.
You must select one file
You must select one or more files
Ai elementus en demasa
3300
Estrayendu
Comprimiendu
Comprebandu
Abriendu...
Escaneandu...
3400
Estrayel
E&strayel a:
Especifical destinu palus ficherus estrayus.
3410
Mou e ruta
Ruta compreta
Sin ruta
3420
Mou e sobrescrebil
Preguntal enantis
Sobrescrebil sin preguntal
Conserval ficherus esistentis
Renombral de horma automtica
Autu-renombral ficherus esistentis
3500
Confirmal remprazu de ficherus
El diretriu ya contieni un ficheru el mesmu nombri.
Escambial el ficheru esistenti
pol esti otru?
{0} bytes
Escambial nombri a&utomticamenti
3700
Mtou e compresin nu soportau pa '{0}'.
Yerru datus en '{0}'. El ficheru est changarrau.
Yerru e CRC '{0}'. El ficheru est changarrau.
Yerru e datus nel ficheru encritau '{0}'. Consea yerrnia?
Yerru e CRC nel ficheru encritau '{0}'. Consea yerrnia?
3800
Introuzil consea
Introuzil consea:
Repitil consea:
Mue&stral consea
Las cunseas nu coincin
Usi slu letras ingresas, nmirus i carteris especialis (!, #, $, ...) pala consea
La consea tieni largura'n demasa
Consea
3900
Tiempu trascurru:
Tiempu restanti:
Tamau total:
Veloci:
Procesau:
Tasa e compresin:
Yerrus:
Archivus:
4000
Aiil a archivu
&Archivu:
&Mou d'atualizacin:
&Hormatu d'archivu:
Nive&l de compresin:
M&tou e compresin:
Tamau el i&zionariu:
Tama&u e parabra:
Tamau el bloqui sliu:
Nmiru hilus e la UCP:
&Parmetrus:
Ocionis
Creal archivu 'SF&X'
Comprimil ficherus compartus
Encritacin
Mtou encritacin:
Encrital &nombris de ficheru
Usu e memoria pa compresin:
Usu e memoria pa decompresin:
4050
Almacenal
La ms respahila
Respahila
Normal
Msima
Ultra
4060
Aiil i remprazal ficherus
Atualizal i aiil ficherus
Atualizal slu ficherus esistentis
Sincronizal ficherus
4070
Esproral
Tolos ficherus
Nu sliu
Sliu
6000
Copial
Movel
Copial a:
Movel pa:
Copiandu...
Moviendu...
Renombrandu...
Selecional diretriu destinu.
Operacin nu soport.
S'alcuentrau'n yerru al renombral el ficheru u diretriu
Confirmal copia el ficheru
De siguru que quieri copiar estus ficherus al archivu?
6100
Confirmal eliminacin del ficheru
Confirmal eliminacin del direhtoriu
Confirmal eliminacin de varius ficherus
De siguru que quieri eliminal '{0}'?
De siguru que quieri eliminal el diretriu '{0}' i tol su conteniu?
De siguru que quieri eliminal estus {0} elementus?
Eliminandu...
S'alcuentrau'n yerru al eliminal el ficheru u diretriu
El sistema nu puei movel un ficheru con ruta larga a la Papelera Recicrahi
6300
Creal diretriu
Creal ficheru
Nombri e diretriu:
Nombri el ficheru:
Nuevu diretriu
Nuevu ficheru
S'alcuentrau'n yerru al creal el diretriu
S'alcuentrau'n yerru al creal el ficheru
6400
Comentriu
&Comentriu:
Selecional
Deselecional
Mscara:
6600
Propieais
Estorial de diretrius
Mensahis de diansticu
Mensahi
7100
Mi PC
Entorno de red
Documentos
Sistema
7200
Aiil
Estrayel
Comprebal
Copial
Movel
Eliminal
Inhormazin
7300
Desapartal ficheru
&Desapartal a:
Desapartal en &balandronis, 'bytes':
Desapartandu...
Confirmal desapartamientu
De siguru que quieri desapartal el ficheru'n {0} volmenis?
El tamau lus volmenis debi sel mas caqueru que'l del ficheru orihinal
Tamau el volumin nu vliu
Introuza'l tamau el volumin: {0} 'bytes'.\nDe siguru que quieri desapartal l'archivu'n tantus volmenis?
7400
Uil ficherus
&Uil en:
Uiendu...
Selecional slu'l primel ficheru
Nu s' puu detetal el ficheru comu parti d'un ficheru desapartau
Nu s' puu alcuentral ms d'un balandrn del ficheru desapartau
7500
Calculandu la suma e verificacin...
Inhormazin de suma e verificacin
Suma e verificacin de 'CRC' pala inhormazin:
Suma e verificacin de 'CRC' pala inhormazin i lus nombris:
7600
Prebas ('benchmark')
Usu e memoria:
Comprimiendu
Comprimiendu
Razn
Razn total
Atual
Resurtau
Usu e CPU
Razn / Usu
Pasis:
;!@Lang2@!UTF-8!
;  3.12 : Edris Naderan
;  4.53 : Mehdi Farhadi
;  9.22 : Hessam Mohamadi
;
;
;
;
;
;
;
;
0
7-Zip
Farsi

401





&
&




440
  
  


 
 


     
500



 


540

  
  



 ...
 ...

 ...
 ..

..
   
 
 
 

600
 
  
 
...
 ...
   
    
700
 
 


730

 
2 

  
   
  ..
 
750
 
 
 
   
800
     

900
 ..

960
..
 ..
1003





  

 
 
 

 
 
  
  
 
  

Anti

 
 





 
 
 


 


 
 

64 
Big-endian

 
  
  

 

 
 
 



 
 
 

 
 
2100
 

:

:
 :
2200

   :
2301
     
      
   :
2320
<>
<>
 
 ...
  ...
 
  
  {0}
  {0}
     ...
  {0}    
2400
 
   
  

 :
     
        
2500

  ".."
   
  
    
  
     
  
    
2900
 
                       .
3000
       
  
{0}   
  '{0}'  
      
 '{0}'       
   '{0}'    .  
   
 {0}    
 '{0}'   .\n        
    \n'{0}'
    
    (       ).
          
     
        
     
3300
  
 

 ..
  ..
3400

 :
        
3410
 
  
  
3420
 
   
  
  
 
    
3500
  
         
    
   
{0} 
 
3700
    '{0}'   
   '{0}'.    
    '{0}'  .  
      '{0}'.   
       '{0}'  .  
3800

:
 :
 
  
        (! # $ ...)    
   

3900
  :
 :
 :
:
 :
  :
:
:
4000
  
:
 :
 :
 :
  :
  :
 :
  :
  
:
 
  
       

 :
   
    :
   :
4050






4060
    
    
    
  
4070

  
-

6000


 :
 :
  ...
  ...
...
    
     
     
  
        
6100
  
  
   
  '{0}'   
   '{0}'       
   {0}    
  ...
    
           
6300
 
 
 :
 :
 
 
  
  
6400

:

 
:
6600

 
 

7100




7200







7300
 
 :
    :
  ...
  
      {0}   
         
   
    : {0} .\n           
7400
  
 :
  ...
      
        
          
7500
   ..
   
       :
         :
7600

 :
 

 
  :


 
  / 
 :
;!@Lang2@!UTF-8!
;  3.08 : Ari Ryynanen
;  4.30 : Jarko P.
;  4.42 : Juhani Valtasalmi
;  9.35b : T.Sakkara
;  15.05 : 2015-08-07 : Lauri Kentt
;
;
;
;
;
;
0
7-Zip
Finnish
Suomi
401
OK
Peruuta



&Kyll
&Ei
&Sulje
Ohje

&Jatka
440
Kyll k&aikkiin
E&i kaikkiin
Pysyt
Aloita uudelleen
&Tausta-ajona
&Normaali prioriteetti
&Pysyt
Pysytetty
Keskeytetnk toiminto?
500
&Tiedosto
&Muokkaa
&Nyt
&Suosikit
Ty&kalut
&Ohje
540
&Avaa
Avaa s&isisesti
Avaa ulkoisesti
&Nyt
&Muokkaa
Nime &uudelleen
&Kopioi...
&Siirr...
&Poista
&Jaa osiin...
&Yhdist jaetut...
&Ominaisuudet
Ku&vaus
Laske tarkiste
Erot
Luo kansio
Luo tiedosto
&Lopeta
Linkit
Vaihtoehtoiset tietovirrat
600
V&alitse kaikki
Poista &valinnat
&Knteinen valinta
Valitse...
Poista valinta...
Valitse lajeittain
Poista valinta lajeittain
700
Suu&ret kuvakkeet
&Pienet kuvakkeet
&Luettelo
&Tiedot
730
Alkuperinen jrjestys
Kansioiden sislt luetteloituna
&Kaksi panelia
&Tykalupalkki
Avaa pkansio
Avaa ylkansio
Kansiohistoria...
P&ivit
Automaattipivitys
750
Pakettipalkki
Vakiopalkki
Suuret painikkeet
Nyt painiketekstit
800
&Lis kansio Suosikkeihin
Kirjanmerkki
900
&Asetukset...
&Nopeustesti
960
&Sislt...
&Tietoja ohjelmasta...
1003
Polku
Nimi
Pte
Kansio
Koko
Pakattu koko
Mritteet
Luotu
Kytetty
Muokattu
Kiinte
Kuvailtu
Suojaus
Jaa ennen
Jaa jlkeen
Sanakirja
Tarkiste
Laji
Vastakohta
Menetelm
Isntjrjestelm
Tiedostojrjestelm
Kyttj
Ryhm
Lohkoja
Kuvaus
Kohta
Polun etuliite
Kansioita
Tiedostoja
Versio
Nimi
Jaettu osiin
Siirtym
Linkit
Lohkot
Nimet

64-bittinen
Big-endian
Suoritin
Fyysinen koko
Otsikon koko
Tarkiste
Ominaisuudet
Nennisosoite
ID
Lyhyt nimi
Luontisovellus
Sektorikoko
Tila
Symbolinen linkki
Virhe
Aseman koko
Vapaata tilaa
Varausyksikn koko
Nimi
Paikallinen nimi
Palveluntarjoja
NT-suojaukset
Vaihtoehtoinen tietovirta
Muu
Poistettu
On kansiorakenne


Virhelaji
Virheet
Virheet
Varoitukset
Varoitus
Tietovirrat
Vaihtoehtoiset tietovirrat
Vaihtoehtoisten tietovirtojen koko
Nenniskoko
Pakkaamaton koko
Fyysinen koko
Aseman indeksi
Alilaji
Kuvaus
Koodisivu



Loppupn koko
Upotetun segmentin koko
Linkki
Kiinte linkki
iNode

Vain luku
2100
Asetukset
Kieli
Kieli:
Muokkausohjelmat
&Tekstieditori:
&Erojen etsint:
2200
Jrjestelmliitnnt
Liit 7-Zip seuraaviin tiedostotyypeihin:
Kaikki kyttjt
2301
Liit 7-Zip jrjestelmn valikoihin.
Ryhmitetty jrjestelmvalikko
Jrjestelmvalikon sislt:
Nyt jrjestelmvalikon kuvakkeet
2320
<Kansio>
<Paketti>
Avaa
Pura...
Lis pakettiin...
Eheystarkastus
Pura tnne
Pura kansioon {0}
Lis pakettiin {0}
Pakkaa tiedostot ja lhet...
Lis pakettiin {0} ja lhet
2400
Kansiot
&Tykansio
&Jrjestelmn vliaikaiskansio
&Nykyinen kansio
&Valittu kansio:
Kyt vain siirrettville tietovlineille
Mrit vliaikaistiedostojen sijainti.
2500
Tiedostoikkuna
Nyt &ylkansion symboli
Nyt &aidot tiedostokuvakkeet
Nyt &jrjestelmvalikko
&Valitse koko rivi
Nyt &ruudukko
Avaa &kertanapsautuksella
Vaihtoehtoinen valintojen &esitystapa
Kyt &suuria muistisivuja
2900
Tietoja
7-Zip on ilmaisohjelmisto.
3000
Ei riittvsti muistia toimintoa varten
Ei virheit.
{0} tiedosto(a) valittu
Ei voida luoda kansioita '{0}.'
Tt pakettia ei voi pivitt.
Tiedoston '{0}' pakkausta ei voi purkaa.
Ei voi avata suojattua pakettia '{0}'. Vr salasana?
Pakkaustapaa ei tueta
Tiedosto {0} on jo olemassa
Tiedostoa '{0}' on muutettu.\nHaluatko pivitt paketin?
Ei voida pivitt tiedostoa \n'{0}'.
Editoria ei voida kynnist.
Tiedosto vaikuttaa haittaohjelmalta, sill sen nimi sislt perkkisi vlilyntej.
Toimintoa ei voi suorittaa kansiosta, jonka nimi on pitk.
Valitse yksi tiedosto
Valitse vhintn yksi tiedosto
Liian monta kohdetta.
Ei voida avata tiedostoa {0}-pakettina
Tiedosto on avattu {0}-pakettina
Paketti on auki eri alkukohdasta (offset)
3300
Puretaan paketti
Listn pakettiin
Eheystarkistus
Avataan...
Etsitn...
Poistetaan
3320
Listn
Pivitetn
Analysoidaan
Kopioidaan
Pakataan uudestaan
Ohitetaan
Poistetaan
Luodaan otsikkoa
3400
Pura
&Pura kansioon
Mrit puretuille tiedostoille sijainti.
3410
Polut:
Tydet polut
Ei polkuja (vain nimi)
Absoluuttiset polut
Suhteelliset polut
3420
Samannimiset tiedostot:
Kysy tapauskohtaisesti
Korvaa
Ohita
Uudelleennime automaattisesti
Uudelleennime entiset automaattisesti
3430
Est pkansion kahdennus
Palauta tiedostojen suojaukset
3500
Vahvista tiedoston korvaus
Kansiossa on jo samanniminen tiedosto.
Korvataanko aiempi tiedosto
tll tiedostolla?
{0} tavua
&Uudelleennime automaattisesti
3700
Tiedoston '{0}' pakkaustapaa ei tueta.
Sisltvirhe tiedostossa '{0}'. Tiedosto on viottunut.
Tiedoston '{0}' eheystarkistus eponnistui. Tiedosto on vioittunut.
Virhe avattaessa suojattua tiedostoa '{0}'. Vr salasana?
Tarkistevirhe avattaessa suojattua tiedostoa '{0}'. Vr salasana?
3710
Vr salasana?
3721
Pakkaustapaa ei tueta
Sisltvirhe
Tarkistevirhe
Sislt ei ole kytettviss
Sislln ennenaikainen loppuminen
Varsinaisen tietosislln jlkeen on ylimrist sislt
Tiedosto ei ole pakattu
Otsikkovirhe
Vr salasana
3763
Pakkauksen alku ei kytettviss
Pakkauksen alkua ei vahvistettu



Toiminto ei tuettu
3800
Syt salasana
Syt salasana:
Toista salasana:
Nyt &salasana
Salasanat eivt tsm
Salasanassa voi kytt numeroita ja erikoismerkkej, mutta EI skandinaavisia kirjaimia.
Liian pitk salasana
Salasana
3900
Aikaa kulunut:
Aikaa jljell:
Koko:
Nopeus:
Ksitelty:
Pakkaussuhde:
Virheit:
Paketteja:
4000
Lis pakettiin
&Paketti:
&Pivitystapa:
Pakkaus&:
Pakkauksen &taso:
Pakkaus&menetelm:
&Sanakirjan koko:
&Sanan koko:
Lohkokoko
Prosessorisikeet:
&Parametrit:
Lisasetukset
Luo itsepurkautuva paketti
Pakkaa yhteiset tiedostot
Suojaus
Salausalgoritmi
Tiedosto&nimien suojaus
Pakkaamiseen kytettv muisti:
Purkamiseen kytettv muisti:
Poista pakkauksen jlkeen
4040
Tallenna symboliset linkit
Tallenna kiintet linkit
Tallenna vaihtoehtoiset tietovirrat
Tallenna tiedostojen suojaukset
4050
Ei pakkausta
Nopein
Nopea
Normaali
Maksimi
Ultra
4060
Lis ja korvaa
Pivit ja lis
Pivit
Synkronoi
4070
Selaa
Kaikki tiedostot
Muuttuva
Kiinte
6000
Kopioi
Siirr
Kopioi kansioon:
Siirr kansioon:
Kopioidaan...
Siirretn...
Nimetn uudelleen...
Valitse kohdekansio.
Toiminto ei ole tuettu.
Virhe uudelleennimettess tiedostoa tai kansiota
Vahvista tiedoston kopioiminen
Kopioidaanko tiedostot pakettiin
6100
Vahvista tiedoston poisto
Vahvista kansion poisto
Vahvista useiden kohteiden poisto
Poistetaanko tiedosto '{0}'?
Poistetaanko kansio '{0}' ja kaikki sen sislt?
Poistetaanko nm {0} kohdetta?
Poistetaan...
Virhe poistettaessa tiedostoa tai kansiota
Roskakoriin ei voida siirt tiedostoa, jolla on pitk nimi
6300
Luo uusi kansio
Luo uusi tiedosto
Kansion nimi:
Tiedostonimi:
Uusi kansio
Uusi tiedosto
Virhe luotaessa kansiota
Virhe luotaessa tiedostoa
6400
Kuvaus
&Kuvaus:
Valitse
Poista valinta
Maski:
6600
Ominaisuudet
Kansiohistoria
Tietoja
Viesti
7100
Tietokone
Verkko
Dokumentit
Jrjestelm
7200
Lis
Pura
Eheystarkistus
Kopioi
Siirr
Poista
Ominaisuudet
7300
Jaa tiedosto osiin
&Jaa kansioon:
&Osien koko jaettaessa:
Jaetaan osiin...
Vahvista jakaminen.
Jaetaanko tiedosto {0} osaan?
Jaetun osan koon pit olla alkuperist pienempi.
Jaetun osan koko ei kelpaa
Jaettavien osien koko: {0} tavua.\nJaetaanko tiedosto sen kokoisiin osiin?
7400
Yhdist jaetut tiedostot
&Yhdist kansioon:
Yhdistetn...
Valitse jaetusta tiedostosta vain ensimminen osa
Tiedosto ei ole jaetun tiedoston osa
Jaetun tiedoston osista lydettiin vain yksi
7500
Lasketaan tarkiste...
Tarkisteet
Sislln tarkiste:
Sislln ja tiedostonimien tarkiste:
7600
Nopeustesti
Muistin kytt:
Pakkaaminen
Purkaminen
Luokitus
Kokonaisluokitus
Nykyinen
Tulos
Suoritinkytt
Luokitus / kytt
Lpisty:
7700
Linkitys
Linkit
Linkitys kohteesta:
Linkitys kohteeseen:
7710
Linkkilaji
Kiinte linkki
Symbolinen tiedostolinkki
Symbolinen kansiolinkki
Kansioliitos
;!@Lang2@!UTF-8!
;  4.07 : Nicolas Sierro
;  9.07 : Philippe Berthault
; 15.14 : Sylvain St-Amand (SSTSylvain)
;
;
;
;
;
;
;
;
0
7-Zip
French
Franais
401
OK
Annuler



&Oui
&Non
&Fermer
Aide

&Continuer
440
Oui pour &Tous
Non pour T&ous
Arrter
Redmarrer
&Arrire-plan
P&remier plan
&Pause
En pause
tes-vous sur de vouloir annuler ?
500
&Fichier
&dition
Affic&hage
Fa&voris
&Outils
&Aide
540
&Ouvrir
Ouvrir  l'&intrieur
Ouvrir  l'e&xtrieur
&Voir
&dition
Reno&mmer
&Copier vers...
&Dplacer vers...
S&upprimer
Diviser le &fichier...
Combiner les fic&hiers...
P&roprits
Comme&ntaire...
Somme de contrle
Diff
Crer un dossier
Crer un fichier
&Quitter
Lien
Flux &Alternatif
600
Slectionner &Tout
Dslectionner Tout
&Inverser la Slection
Slectionner...
Dslectionner...
Slectionner par Sorte
Dslectionner par Sorte
700
&Grandes Icnes
&Petites Icnes
&Liste
&Dtails
730
Non tri
Vue  plat
&2 Fentres
&Barres d'outils
Ouvrir le dossier racine
Dossier parent
Historique des dossiers...
Actualis&er
Actualiser Automatiquement
750
Barre d'Archive
Barre Standard
Grands Boutons
Montrer le texte des Boutons
800
&Ajouter le rpertoire aux Favoris
Signet
900
&Options...
&Test de performance
960
&Contenu...
 &propos de 7-Zip...
1003
Chemin
Nom
Extension
Dossier
Taille
Compress
Attributs
Cr le
Accd le
Modifi le
Solide
Commentaire
Chiffrer
Diviser Avant
Diviser Aprs
Dictionnaire

Sorte
Anti
Mthode
OS hte
Systme de Fichiers
Utilisateur
Groupe
Bloc
Commentaire
Position
Prfixe
Dossiers
Fichiers
Version
Volume
Multivolume
Offset
Liens
Blocs
Volumes

64 bits
Big-endian
CPU
Taille physique
Taille des en-ttes
Somme de contrle
Caractristiques
Adresse virtuelle
ID
Nom court
Application cratrice
Taille de secteur
Mode
Lien Symbolique
Erreur
Taille Totale
Espace Libre
Taille des clusters
Nom de volume
Nom local
Fournisseur
Scurit NT
Flux alternatif
Aux
Effacer
En Arbre


Type d'erreur
Erreurs
Erreurs
Avertissements
Avertissement
Flux
Flux Altern
Grosseur du Flux Altern
Grosseur Virtuel
Grosseur Dcompress
Grosseur Physique Totale
Indexe du Volume
Sous-Type
Commentaire Bref
Code Page



Grosseur Tail
Grosseur Embedded Stub
Lien
Lien Solide
iNode

Lecture-seulement
2100
Options
Langue
Langue :
diteur
&diteur :
&Diff :
2200
Systme
Associer avec 7-Zip :
Tous les utilisateurs
2301
Intgrer 7-Zip au menu contextuel
Menu contextuel en cascade
lments du menu contextuel :
Icnes dans le menu contextuel
2320
<Dossier>
<Archive>
Ouvrir archive
Extraire les fichiers...
Ajouter  l'archive...
Contrler l'archive
Extraire Ici
Extraire vers {0}
Ajouter  {0}
Compresser et envoyer par courriel...
Compresser vers {0} et envoyer par courriel
2400
Dossiers
Dossier de &travail
Dossier temporaire du &systme
&Courant
S&pcifi :
N'utiliser que pour les mdias amovibles
Spcifiez un dossier pour les fichiers d'archive temporaires.
2500
Paramtres
Afficher l'lment ".."
Afficher les icnes relles des fichiers
Afficher le menu systme
&Slectionner toute la ligne
Afficher la &grille
Simple clic pour ouvrir un item
Utiliser la slection &alternative
Utiliser des &grosses pages mmoire
2900
A propos de 7-Zip
7-Zip est un logiciel libre
3000
Le systme ne peut allouer la quantit de mmoire ncessaire
Il n'y a pas d'erreurs
{0} objet(s) slectionn(s)
Le dossier '{0}' ne peut pas tre cr
Les oprations de mise  jour ne sont pas disponibles pour cette archive.
Le fichier '{0}' ne peut tre ouvert comme une archive
L'archive crypte '{0}' ne peut tre ouverte. Mauvais mot de passe ?
Ce type d'archive n'est pas support
Le fichier {0} existe dj
Le fichier '{0}' a t modifi.\nVoulez-vous le mettre  jour dans l'archive ?
Impossible de mettre  jour\n'{0}'
Impossible de dmarrer l'diteur.
Le fichier est peut-tre un virus (le nom contient des grands espacements pour masquer l'extension).
Cette opration ne peut tre effectue depuis un dossier ayant un trop long chemin d'accs.
Vous devez slectionner un fichier
Vous devez slectionner un ou plusieurs fichiers
Trop d'objets
Ne peut ouvrir les fichiers {0} comme une archive
Le fichier {0} est ouvert comme une archive
L'archive est ouverte avec un dcalage
3300
Extraction
Compression
Contrle
Ouverture...
Exploration...
Enlever
3320
Ajoute
Modifie
Analyse
Rplique
Remballage
Passe
Efface
Cration d'un en-tte
3400
Extraire
E&xtraire vers :
Choisissez un dossier pour l'extraction des fichiers.
3410
Mode de chemin :
Nom de chemin complet
Pas de nom de chemin
Nom de chemin absolu
Nom de chemin relatif
3420
Mode de remplacement :
Confirmer avant de remplacer
Remplacer sans demander
Ignorer les fichiers existants
Renommer automatiquement
Renommer les fichiers existants
3430
limine la duplication du rpertoire racine
Restauration du fichier de scurit
3500
Confirmer le remplacement de fichier
Le dossier de destination contient dj un fichier avec ce nom.
Voulez-vous remplacer le fichier existant
par celui-ci ?
{0} octets
Renommer &automatiquement
3700
Mthode de compression non valide pour '{0}'.
Donne errone dans le fichier '{0}'. Le fichier est corrompu.
chec du contrle CRC dans le fichier '{0}'. Le fichier est corrompu.
Donne errone dans le fichier crypt '{0}'. Mauvais mot de passe ?
chec du contrle CRC dans le fichier crypt '{0}'. Mauvais mot de passe ?
3710
Pas le bon mot de passe ?
3721
Mthode de compression non supporte
Erreur de donne
chec de CRC
Donne non disponible
Fin de donnes inattendues
Il y a des donnes aprs la fin des donnes utiles
N'est pas une archive
Erreur en-ttes
Mauvais mot de passe
3763
Dmarrage non disponible d'une archive
Dmarrage non confirm d'une archive



Option non supporte
3800
Entrez le mot de passe
Entrez le mot de passe :
Entrez le mot de passe  nouveau :
&Afficher le mot de passe
Les mots de passe ne correspondent pas
Pour le mot de passe, n'utilisez que des lettres non accentues, des chiffres et des caractres spciaux (!, #, $, ...)
Le mot de passe est trop long
Mot de passe
3900
Temps coul :
Temps restant :
Taille totale :
Vitesse :
Trait :
Taux de compression :
Erreurs :
Archive :
4000
Ajouter  l'archive
&Archive :
&Mode de mise  jour :
&Format de l'archive :
N&iveau de compression :
Mthode de &compression :
&Taille du dictionnaire :
Tai&lle des mots :
Taille de bloc solide :
Nombre de threads CPU :
&Paramtres :
Options
Crer une archive SF&X
Compresser des fichiers partags
Chiffrement
Mthode de chiffrement :
Chiffre les &noms de fichiers
Mmoire pour la compression :
Mmoire pour la dcompression :
Effacer les fichiers aprs compression
4040
Emmagasine liens symboliques
Emmagasine liens solides
Emmagasine flux de donnes alternatifs
Emmagasine fichier de scurit
4050
Aucune
Le plus rapide
Rapide
Normale
Maximum
Ultra
4060
Ajouter et remplacer les fichiers
Mettre  jour et ajouter les fichiers
Rafrachir les fichiers existants
Synchroniser les fichiers
4070
Choisir
Tous les fichiers
Non-solide
Solide
6000
Copier
Dplacer
Copier dans :
Dplacer vers :
Copie...
Dplacement...
Renommage...
Slectionnez le dossier de destination.
L'opration n'est pas possible pour ce dossier.
Erreur durant le Renommage du Fichier ou du Dossier
Confirmation de la Copie de(s) Fichier(s)
Confirmer la copie de(s) fichier(s)  archiver
6100
Confirmer la Suppression du Fichier
Confirmer la Suppression du Dossier
Confirmer la Suppression de Multiple Fichiers
tes-vous sr de vouloir supprimer '{0}' ?
tes-vous sr de vouloir supprimer le dossier '{0}' et tout ce qu'il contient ?
tes-vous sr de vouloir supprimer ces {0} objets ?
Suppression...
Erreur durant la suppression du fichier ou du dossier
Le systme ne peut mettre  la Corbeille un fichier avec un trop long chemin d'accs
6300
Crer un Dossier
Crer un Fichier
Nom du dossier :
Nom du fichier :
Nouveau dossier
Nouveau fichier
Erreur durant la cration du dossier
Erreur durant la cration du fichier
6400
Commentaire
&Commentaire :
Slectionner
Dslectionner
Masquer :
6600
Proprits
Historique des dossiers
Messages de diagnostic
Message
7100
Ordinateur
Rseau
Documents
Systme
7200
Ajouter
Extraire
Tester
Copier
Dplacer
Supprimer
Informations
7300
Diviser le fichier
&Diviser en :
Diviser en &volumes, octets :
Dcouper...
Confirmez le dcoupage
tes-vous sr de vouloir dcouper le fichier en {0} volumes ?
La taille de volume doit tre infrieure  la taille du fichier d'origine
Taille de volume incorrecte
Taille de volume spcifie : {0} octets.\ntes-vous sr de vouloir dcouper l'archive dans de tels volumes ?
7400
Combiner les fichiers
&Combiner en :
Combinaison...
Ne slectionnez que le premier fichier
Ne trouve aucun fichier faisant partie d'une archive divise
Ne trouve qu'un seul fichier faisant partie d'une archive divise
7500
Calcul de la somme de contrle...
Informations sur la somme de contrle
Somme de contrle des donnes :
Somme de contrle des donnes et des noms :
7600
Test de performance
Utilisation de la mmoire :
Compression
Dcompression
Taux
Taux total
Actuel
Rsultant
Utilisation CPU
Estim / Usage
Passe :
7700
Lien
Lien
Lien depuis :
Lien ver :
7710
Sorte de lien
Lien solide
Lien symbolique de fichier
Lien symbolique de rpertoire
Jonction de rpertoire
;!@Lang2@!UTF-8!
;  4.60 : Andrea Decorte (Klenje) : http://softfurlan.altervista.org : secont l'ortografie uficil de Provincie di Udin
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Friulian
Furlan
401
Va ben
Scancele



&S
&No
&Siare
&Jutori

&Continue
440
S &a ducj
No a &ducj
Ferme
Torne a invi
&Sfont
P&rin plan
&Pause
In pause
Sstu sigr di vol scancel?
500
&File
&Modifiche
&Viodude
&Preferts
&Imprescj
&Jutori
540
&Viar
Viar dentri 7-&Zip
V&iar fr di 7-Zip
&Mostre
M&odifiche
Gambie &non
&Copie in...
M&f in...
&Elimine
&Divt file...
Torne a &un files...
P&ropietts
Comen&t
Calcole so&me di control

Cree cartele
Cree file
V&a fr
600
Selezione d&ut
&Deselezione dut
&Inverts selezion
Selezione...
Deselezione...
Selezione par gjenar
Deselezione par gjenar
700
Iconis &grandis
Iconis &piulis
&Liste
&Detais
730
Cence ordin
Viodude plane
&2 panei
Sbaris dai impresc&j
Viar cartele principl
Parsore di un nivel
Storic des cartelis...
&Atualize
750
Sbare dai imprescj par l'archivi
Sbare dai imprescj standard
Botons larcs
Mostre test dai botons
800
&Zonte cartele ai Preferts sicu
Prefert
900
&Opzions...
&Banc di prove
960
&Argoments...
&Informazions su 7-Zip...
1003
Percors
Non
Estension
Cartele
Dimension
Dimension comprimude
Atribts
Cret
Ultin acs
Modifict
Solit
Comentt
Cifrt
Divt prin di
Divt dasp di
Dizionari
CRC
Gjenar
Anti
Metodi
SO di origjin
Sisteme dai files
Utent
Grup
Bloc
Coment
Posizion
Prefs dal troi
Cartelis
Files
Version
Volum
Multivolum
Offset
Leams
Blocs
Volums

64-bit
Big-endian
CPU
Dimension fisiche
Dimension intestazions
Some di control
Caracteristichis
Direzion virtul






Err
Dimension totl
Puest libar
Dimension setr
Etichete
Non locl
Furnidr
2100
Opzions
Lenghe
Lenghe:
Editr
&Editr:

2200
Sisteme
Associe 7-Zip cun:
2301
Integre 7-Zip intal men contestul de shell
Men contestul in discjadude
Elements dal men contestul:
2320
<Cartele>
<archivi>
Viar archivi
Tire fr files...
Zonte a un archivi...
Prove archivi
Tire fr ca
Tire fr in {0}
Zonte a {0}
Comprim e mande par email...
Comprim in {0} e mande par email
2400
Cartelis
Cartele di &vore
Cartele &provisorie dal sisteme
&Corinte
&Specificade:
Dopre dome pai drives che si puedin gjav
Specifiche une posizion pai files provisoris di un archivi.
2500
Configurazion
Mostre l'element ".."
Mostre lis veris iconis dai files
Mostre il men dal sisteme
&Selezione la rie intire
Mostre les liniis de &gridele sot

Mt di selezion &alternatf
Dopre pagjinis di memorie &largjis
2900
Informazions su 7-Zip
7-Zip al  un program libar. Purpr, tu puedis supuart il disvilup di 7-Zip cu la regjistrazion. I utents regjistrts a podaran otign supuart tecnic.
3000
Il sisteme nol rive a cjoli la cuantitt di memorie che e covente
Nissun err cjatt
{0} ogjet(s) seleziont(s)
No si pues cre la cartele '{0}'
Lis operazions di atualizazion no son supuartadis par chest archivi.
No si pues viarzi il file '{0}' come archivi
No si pues viarzi l'archivi cifrt '{0}'. Ise sbaliade la peraule clf?
Gjenar di archivi no supuartt
Il file {0} al esist za
Il file '{0}' al  stt modifict.\nVuelistu atualizlu intal archivi?
No si pues atualiz il file\n'{0}'
No si pues invi l'editr.
Il file al samee un virus (il non al  dentri un grum di spazis).
Cheste operazion no pues jessi clamade di une cartele cuntun troi lunc.
Tu scugnis sielzi un file
Tu scugnis sielzi un o plui files
Masse elements
3300
Dar a tir fr...
Dar a comprimi
Dar a prov
Dar a viarzi...
Dar a scandai...
3400
Tire fr
Tir&e fr in:
Specifiche une posizion pai files tirts fr.
3410
Struture des cartelis
Percors intrs
Nissun percors
3420
Sore scriture
Domande prin di scrivi parsore
Scrf parsore cence domand
Salte i files che esistin
Gambie nons in automatic
Gambie nons in automatic se a esistin
3500
Conferme de sostituzion dal file
Inte cartele di destinazion al  za il file processt.
Vuelistu sostitu il file esistint
cun chest file?
{0} bytes
&Gambie non in automatic
3700
Il metodi di compression nol  supuartt par '{0}'.
Err di dts in '{0}'. Il file al  corot.
CRC falt in '{0}'. Il file al  corot.
Err di dts tal file cifrt '{0}'. Peraule clf sbaliade?
CRC falt tal file cifrt '{0}'. Peraule clf sbaliade?
3800
Scrf peraule clf
Scrf la peraule clf:
Torne a inser la peraule clf:
&Mostre la peraule clf
Lis peraulis clfs no son compagnis
Dopre dome lis letaris inglesis (no acentadis), i numars e i caratars specii (!, #, $, ...) inte peraule clf
La peraule clf e je masse lungje
Peraule clf
3900
Timp passt:
Timp restant:
Dimension:
Sveltece:
Elabort:
Tas di compression:
Errs:
Archivis:
4000
Zonte a un archivi
&Archivi:
Mt di at&ualizazion:
&Formt archivi:
Nive&l di compression:
&Metodi di compression:
&Dimension dizionari:
Dimension &peraule:
Dimension bloc solit:
Numar di threads de CPU:
&Parametris:
Opzions
Cree archivi SF&X
Comprim i files condividts
Ciframent
Metodi di ciframent:
Cifre i &nons dai files
Utilizazion memorie comprimint:
Utilizazion memorie decomprimint:
4050
Cence compression
Il pi svelt
Svelt
Norml
Massim
Super
4060
Zonte e sostitus files
Atualize e zonte files
Atualize i files che esistin
Sincronize i files
4070
Sgarfe
Ducj i files
No-solit
Solit
6000
Copie
Mf
Copie in:
Mf in:
Dar a copi...
Dar a movi...
Dar a gambi non...
Siel la cartele di destinazion.
L'operazion no je supuartade.
Err gambiant non a un file o une cartele
Conferme de copie dai files
Sstu sigr di vol copi i files tal archivi
6100
Conferme de eliminazion dal file
Conferme de eliminazion de cartele
Conferme de eliminazion di plui files
Sstu sigr di vol elimin '{0}'?
Sstu sigr di vol elimin la cartele '{0}' e dut ce ch'al  l dentri?
Sstu sigr di vol elimin chescj {0} elements?
Dar a elimin...
Err eliminant un file o une cartele
Il sisteme nol pues movi un file cuntun troi lunc te Scovacere
6300
Cree cartele
Cree file
Non de cartele:
Non dal file:
Gnove cartele
Gnf file
Err inte creazion de cartele
Err inte creazion dal file
6400
Coment
&Coment:
Selezione
Deselezione
Filtri:
6600
Propietts
Storic des cartelis
Messas diagnostics
Messa
7100
Ordenadr
Rt
Documents
Sisteme
7200
Zonte
Tire fr
Prove
Copie
Mf
Elimine
Info
7300
Divt file
&Divt in:
Divt in &volums, grandece in bytes:
Dar a dividi...
Conferme de division
Sstu sigr di vol dividi il file in {0} tocs?
La dimension di un volum e  di jessi plui piule di ch dal file origjinl
Dimension dai volums sbaliade
Dimension dai volums volude: {0} bytes.\nSstu sigr di vol dividi l'archivi in tocs di cheste dimension?
7400
Torne a un files
&Torne a un in:
Dar a torn a un...
Siel dome il prin file
No si pues rilev il file come toc di un file dividt
No son stts cjatts plui tocs di file dividts
7500
Dar a calcol la some di control...
Informazions su la some di control
Some di control CRC pai dts:
Some di control CRC pai dts e i nons:
7600
Banc di prove
Utilizazion memorie:
Comprimint
Decomprimint
Valutazion
Valutazion totl
Corint
Risultant
Utilizazion CPU
Judizi / Utilizazion
Passas:
;!@Lang2@!UTF-8!
;  4.53 : Berend Ytsma
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Frisian
Frysk
401
Okee
Ofbrekke



&Jawis
&Nee
&Slute
Help

&Ferfetsje
440
Jawis foar &Alles
Nee foar A&lles
Stopje
Opnij begjinne
&Eftergrn
&Foargrn
&Skoftsje
Skoft
Binne jo wis dat jo fbrekke wolle?
500
&Triem
&Bewurkje
&Byld
B&ldwizers
&Ark
&Help
540
&Iepenje
Iepenje &yn
Iepenje b&ten
&Byld
&Bewurkje
Omne&ame
&Kopiearje nei...
&Ferpleats nei...
&Wiskje
Triemmen &spjalte...
Triemmen Kom&binearje...
E&igenskippen
Komme&ntaar
Kontrlesom berekenje

Map meitsje
Triem meitsje
U&tgong
600
&Alles selektearje
Alles net selektearje
&Seleksje omdraaien
Selektearje...
Net selektearje...
Selektearje neffens type
Net selektearje neffens type
700
Gru&tte Ikoanen
L&ytse Ikoanen
&List
&Details
730
Net Sortearre
Platte werjefte
&2 Panielen
&Arkbalke
Haadmap iepenje
Ien nivo omheech
Maphistoarje...
&Ferfarskje
750
Argyf arkbalke
Standert arkbalke
Grutte knoppen
Knoptekst sjen litte
800
Map oan bldwizers &taheakje  as
Bldwizer meitsje
900
&Opsjes...
&Ykpunt
960
&Ynhld...
&7-Zip it hoe en het...
1003
Paad
Namme
Taheaksel
Map
Grutte
Ynpakte grutte
Skaaimerk
Makke
Lste tagong
Feroare
Kompakt
Kommentaar
Fersifere
Spjalt foar
Spjalt efter
Wurdboek
CRC
Type
Anty
Metoade
Host OS
Triemsysteem
Brker
Keppel
Blok
Kommentaar
Posysje
Paad foarheaksel
Mappen
Triemmen
Ferzje
Folume
Multifolume
Offset
Links
Blokken
Folumes















Flater
Totale grutte
Frije romte
Kluster grutte
Kaartsje
Lokale namme
Ferskaffer
2100
Opsjes
Taal
Taal:
Bewurker
&Bewurker:

2200
Systeem
Ferbyn 7-Zip Mei:
2301
Yntegraasje fan 7-Zip yn ferbnmenu
Ferbnmenu yn trepfoarm
Ferbnmenu-items:
2320
<Map>
<Argyf>
Argyf iepenje
Triemmen tpakke...
Oan argyf taheakje...
Argyf teste
Hjir tpakke
Utpakke yn {0}
Oan {0} taheakje
komprimearje en ferstjoere...
Komprimearje nei {0} en poste
2400
Mappen
&Wurkmap
&Tydlikesysteemmap
&Aktive
&Oantsjutte:
Allinnich brke foar tnimbere skiven
ynfiere fan de lokaasje foar tydlike argyftriemmen.
2500
Ynstellings
".." item sjen litte
Echte triem ikoanen sjen litte
Systeemmenu sjen litte
&Folsleine rige selektearje
&Roaster sjen litte

&Alternative seleksje modus
Brk &grut nthld siden
2900
7-Zip it hoe en het
7-Zip is fergees. Mar, jo kinne de ntwikkeling stypje troch jo te registrearjen.
3000

Der binne gjin flaters
{0} objekt(en) selektearre
Kin map '{0}' net meitsje
Bywurk operaasje waard net stipe troch dit argyf.
Kin triem '{0} net as argyf iepenje
Kin fersifere argyf '{0}' net iepenje. Ferkeard wachtwurd?


Triem '{0}' is wizige.\nWolle jo it bywurkje yn it argyf?
Kin triem '{0}'\nnet bywurkje
Kin bewurker net starte.




Tefolle items
3300
Utpakke
Oan it komprimearjen
Oan it Testen
Oan it iepenjen...
Oan it skennen...
3400
Utpakke
U&tpakke nei:
De lokaasje om nei t te pakken oantsjutte.
3410
Paad modus
Folsleine paadnammen
Gjin paadnammen
3420
Oerskriuw modus
Freegje foardat jo oerskriuwe
Oerskriuwe snder pront
Besteande triemmen oerslaan
Automatysk omneame
Automatysk ek by besteande triemmen
3500
It ferfangen fan de triem befstigje
Bestimmingsmap befettet al in triem mei dizze namme.
Wolle jo de triem ferfange
Mei dizze?
{0} bytes
A&utomatysk omneame
3700
Net stipe kompresjemetoade foar '{0}'.
Data flater yn '{0}'. Triem is beskeadige.
CRC mislearre yn '{0}'. Triem is beskeadige.
Data flater yn fersifere triem '{0}'. Ferkeard wachtwurd?
CRC mislearre yn fersifere triem '{0}'. Ferkeard wachtwurd?
3800
Wachtwurd ynfiere
Wachtwurd ynfiere:
Wachwurd opnij ynfiere:
Wachtwurd &sjen litte
Wachtwurden komme net oerien
Brk allinne ingelske letters, nmers en spesjale karakters (!, #, $, ...) foar it wachtwurd
Wachtwurd is te lang
Wachtwurd
3900
Ferstrutsen tiid:
Tiid noch te gean:
Totale grutte:
Fluggens:
Ferwurke:
Kompresje nivo:
Flaters:
Argiven:
4000
Oan argyf taheakje
&Argyf:
&Bywurkmodus:
Argyf &formaat:
Kompresje&nivo:
Kompresje&metoade:
&Wurdboekgrutte:
&Wurdgrutte:
Kompakte blokgrutte:
Tal CPU trieden:
&Parameters:
Opsjes
Meitsje SF&X-argyf
Dielde triemmen komprimearje
Fersifering
Fersiferingmetoade:
Fersiferje triem&nammen
Unthld gebrk by komprimearjen:
Unthld gebrk by ntkomprimearjen:
4050
Bewarje
Fluchst
Fluch
Normaal
Maksimum
Ultra
4060
Triemmen taheakje en ferfange
Triemmen taheakje en bywurkje
Besteande triemmen ferfarskje
Triemmen lyk rinne litte
4070
Bldzje
Alle triemmen
net-kompakt
Kompakt
6000
Kopiearje
Ferpleatse
Kopiearje nei:
Ferpleats nei:
Oan it kopiearren...
Oan it ferpleatsen...
Omneame...
Bestimmingsmap selektearje.
Operaasje wurdt net stipe.
Flater by it omneamen fan triem of map
Triem kopiearje befstigje
Binne jo wis dat jo de triemmen nei it argyf kopiearje wolle?
6100
It wiskjen fan de triem befstigje
It wiskjen fan de map befstigje
It wiskjen fan meardere triemmen befstigje
Binne jo wis dat jo '{0}' wiskje wolle?
Binne jo wis dat jo de map '{0}' en al syn ynhld wiskje wolle?
Binne jo wis dat jo {0} items wiskje wolle?
Oan it wiskjen
Flater by it wiskjen fan triem of map

6300
Map meitsje
Triem meitsje
Mapnamme:
Triem namme:
Nije map
Nije triem
Flater by it meitsjen fan map
Flater byt meitsjen fan triem
6400
Kommentaar
&Kommentaar:
Selektearje
Net Selektearje
Masker:
6600
Eigenskippen
Maphistoarje
Diagnostyk berjocht
Berjocht
7100
Kompjter
Netwurk

Systeem
7200
Taheakje
Utpakke
Test
Kopiearje
Ferpleatse
Wiskje
Ynformaasje
7300
Triem spjalte
&Spjalt nei:
Spjalte nei &folumes, bytes:
Oan it Spjalten...
Spjalte befstigje
Wolle jo de triem spjalte yn {0} dielen?
Folumegrutte moat lytser wze dan de grutte fan it orizjineel
Net juste folumegrutte
Oantsjutte folumegrutte: {0} bytes.\nWolle jo it argyf yn sokke folumes spjalte?
7400
Triemmen kombinearje
&Kombinearje nei:
Oan it kombinearjen...
Allinne earste triem selektearje


7500
Kontrlesom oan it berekenjen...
Kontrlesom ynformaasje
CRC kontrlesom foar data:
CRC kontrlesom foar data en nammen:
7600
Benchmark
Unthld gebrk:
Oan it komprimearren
Oan it ntkomprimearren
Wurdearring
Totale Wurdearring
Hjoeddeiske
Resultaat
CPU brkens
Beoardieling / Brkens
Kear foarbei:
;!@Lang2@!UTF-8!
;  9.07 : Seann  Coistn
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Irish
Gaeilge
401
T go maith
Cealaigh



&T
&Nl
&Dn
Cabhair

&Lean ar aghaidh
440
T do gach ceann
Nl go gach ceann
Stad
Atosaigh
&Clra
&Tulra
&Cuir ar sos
Ar sos
An bhfuil t cinnte gur mian leat  a cheal?
500
&Comhad
&Leagan
Am&harc
Ceanin
&Uirlis
&Cabhair
540
&Oscail
Oscail &istigh
Oscail &lasamuigh
&Amharc
&Eagar
Athainmnigh
&Macasamhlaigh go...
&Bog go...
S&crios
Scar an comhad...
Cumascaigh na comhaid...
Aironna
Nta trchta
Romh an tsuim sheicela
Diff
Cruthaigh fillten
Cruthaigh comhad
&Scoir
600
Roghnaigh &uile
Droghnaigh uile
&Aisiompaigh an roghnchn
Roghnaigh...
Droghnaigh...
Roghnaigh de rir cinel
Droghnaigh de rir cinel
700
&Deilbhn mra
&Deilbhn beaga
&Liosta
&Sonra
730
Neamhaicmithe
Gach rud in aon chiseal
&2 fhuinneog
&Barra na n-uirlis
Oscail an framhfhillten
Suas fillten amhin
Oireas na bhfillten...
Athnuaigh
750
Barra cartlanna
Barra na n-uirlis caighdenacha
Cnaip mra
Taispein an tacs ar na cnaip
800
&Cuir an fillten leis na Ceanin
Leabharmharc
900
&Roghanna...
Tstil fheidhmochta
960
&Inneachair...
Maidir le 7-Zip...
1003
Conair
Ainm
Breisen
Fillten
Mid
Comhbhrite
Trithe
Cruthaithe an
Rochtain faighte ar an
Mionathraithe ar an
Fothil
Trcht
Criptithe
Roinn roimh
Roinn i ndiaidh
Foclir
CRC
Cinel
Frith
Modh
stach an CO
Cras na gcomhad
sideoir
Aicme
Ceap
Nta trchta
Suomh
Rimr na conaire
Filltein
Comhaid
Leagan
Imleabhar
Il-imleabhair
Frithirigh
Naisc
Ceapa
Imleabhair

64 bheart
Foirceann mr
LAP
Mid aiceanta
Mid na gceanntsc
Suim seicela
Trithe
Seoladh foril
ID
Ainm gearr
Feidhmchlr a chruthaigh 
Mid na hearnla
Modh
Nasc
Botn
Mid iomln
Sl at saor
Mid na braisle
Lipad
Ainm lognta
Solthra
2100
Roghanna
Teanga
Teanga:
Eagarthir
&Eagarthir:
&Diff:
2200
Cras
Comhthiomsaigh 7-Zip le:
2301
Comhththaigh 7-Zip sa roghchlr comhthacs
Roghchlr comhthacs ag titim
Nithe an roghchlir chomhthacs:
2320
<Fillten>
<Comhad>
Oscail
Asbhain na comhaid...
Cuir leis an gcartlann...
Tstil an chartlann
Asbhain anseo
Bain go {0}
Cuir le {0}
Comhbhrigh agus seol i romphost iad...
Comhbhrigh go {0} agus seol i romhphost iad
2400
Filltein
Fillten oibre
Fillten sealadach an chrai&s
An comhad reatha
Fillten &sonraithe:
Bain feidhm as do thiomntin inaistrithe amhin
Sonraigh suomh i gcomhair comhaid chartlainne sealadacha.
2500
Socruithe
Taispein an n ".."
Taispein fordheilbhn an chomhaid
Taispein roghchlr an chrais
Roghnaigh an tsraith ar fad
Taispein lnte na greille
Brigh uair amhin chun n a oscailt
Bain feidhm as modh roghnaithe malartach
Bain feidhm as leathanaigh chuimhne mhra
2900
Maidir le 7-Zip
Is saorearra  7-Zip. Is fidir tacaocht a thabhairt d fhorbairt amach anseo, fach, tr chlr.
3000
N fidir leis an gcras an mid cuimhne at de dhth a leathdhileadh d
Nl aon bhotn ann
{0} n/nithe roghnaithe
N fidir an fillten '{0}' a chruth
N fidir an chartlann seo a nuashonr.
N fidir an comhad '{0}' a oscailt mar chartlann
N fidir an chartlann chriptithe '{0}' a oscailt. An bhfuil an focal faire mcheart?
N thugtar tacaocht don chinel comhad seo
T an comhad {0} ann cheana
Mionathraodh an comhad '{0}'.\nAr mhaith leat  a nuashonr sa chartlann?
N fidir an comhad a leanas a nuashonr\n'{0}'
N fidir an t-eagarthir a thos.
B'fhidir gur aicd  an comhad (t bearna mra in ainm an chomhaid).
N fidir an oibrocht seo a chur i bhfeidhm  fhillten a bhfuil conair fhada aige.
Caithfear comhad amhin a roghn
Caithfear comhad amhin n nos m a roghn
An iomarca nithe
3300
Asbhaint
Ag comhbhr
Ag tstil
Ag oscailt...
Ag taiscal...
3400
Bain
Bain go:
Roghnaigh fillten do na comhaid asbhainte.
3410
Conair
Conair iomlna
Nl conair ann
3420
Modh forscrofa
Deimhnigh sular forscrobhtar
Forscrobh gan iarraidh
Dan neamhaird de na comhaid at ann cheana
Athainmnigh go huathoibroch
Athainmnigh na comhaid at ann cheana
3500
Deimhnigh ionad comhaid
T comhad leis an ainm seo sa spriocfhillten cheana fin.
Ar mhaith leat an comhad at ann cheana a ionad
leis an gceann seo?
{0} bearta
Athainmnigh go huathoibroch
3700
Nl an bealach comhbhrite bail i gcomhair '{0}'.
Botn sna sonra sa chomhad '{0}'. T an comhad briste.
Theip ar CRC sa chomhad '{0}'. T an comhad briste.
Sonra mcheart sa chomhad criptithe '{0}'. Focal faire mcheart?
Theip ar CRC sa chomhad chriptithe '{0}'. Focal faire mcheart?
3800
Cuir isteach an focal faire
Cuir an focal faire isteach:
Cuir an focal faire isteach ars:
&Taispein an focal faire
N hionann an d fhocal faire
Bain feidhm as litreacha gan snt fada, uimhreacha agus carachtair shainila (!, #, $, ...)
T an focal faire rfhada
Focal faire
3900
Am caite:
Am fgtha:
Mid iomln:
Luas:
Danta:
Luas an chomhbhrite:
Botin:
Cartlanna:
4000
Cuir leis an gcartlann
&Cartlann:
&Modh nuashonraithe:
&Formid na cartlainne:
Mid comhbhrite:
Modh comhbhrite:
&Mid an fhoclra:
Mid na bhfocal:
Mid an chip fhothla:
Lon na snitheanna LAP:
&Teorainneacha:
Roghanna
Cruthaigh cartlann SF&X
Comhbhrigh na comhaid a roinneadh
Cripti
Modh criptichin:
Criptigh ainmneacha na gcomhad
Cuimhne don chomhbhrigh:
Cuimhne don dhchomhbhrigh:
4050
Taisc
Is gasta
Gasta
Gnth
Uasmhid
Forghasta
4060
Cuir comhaid leis agus ionadaigh
Nuashonraigh na comhaid agus cuir leo
Athnuaigh comhaid at ann cheana
Comhionannaigh na comhaid
4070
Siortaigh
Gach comhad
Neamhfhothil
Fothil
6000
Macasamhlaigh
Bog
Macasamhlaigh chuig:
Bog chuig:
Ag acasamhl...
Ag bogadh...
Ag athainmni...
Roghnaigh an spriocfhillten.
N fidir sin a dhanamh.
Tharla botn ag athainmni an comhad n an fillten
Deimhnigh macasamhl an chomhaid
An bhfuil t cinnte gur mian leat na comhaid a mhacasamhl go dt an chartlann?
6100
Deimhnigh scriosadh an chomhaid
Deimhnigh scriosadh an chomhaid
Deimhnigh scriosadh iliomad comhad
An bhfuil t cinnte gur mian leat '{0}' a scriosadh?
An bhfuil t cinnte gur mian leat an fillten '{0}' agus gach rud ann a scriosadh?
An bhfuil t cinnte gur mian leat na {0} nithe seo a scriosadh?
Ag scriosadh...
Tharla botn ag scriosadh an comhad n an fillten
N thig leis an gcras comhad le conair fhada a bhogadh go dt an bosca athchrsla
6300
Cruthaigh comhad
Cruthaigh comhad
Ainm an chomhaid:
Ainm an chomhaid:
Comhad nua
Comhad nua
Tharla botn fad is a bh an comhad  chruth
Tharla botn fad is a bh an comhad  chruth
6400
Trcht
&Trcht:
Roghnaigh
Droghnaigh
Folaigh:
6600
Aironna
Oireas na bhfillten
Teachtaireachta diagniseach
Teachtaireacht
7100
Romhaire
Lonra
Cipis
Cras
7200
Cuir leis
Asbhain
Tstil
Macasamhlaigh
Bog
Scrios
Faisnis
7300
Roinn an comhad
&Roinn chuig:
Roinn in imleabhair, bearta:
Ag roinnt...
Deimhnigh an roinnt
An bhfuil t cinnte go dteastaonn uait an comhad a roinnt i {0} imleabhair?
N mr do mhid an imleabhair a bheith nos l n mid an chomhaid bhunaidh
T mid an cholin mcheart
Mid an cholin sonraithe: {0} bearta.\nAn bhfuil t cinnte gur mian leat an chartlann a roinnt in imleabhair?
7400
Cumaisc comhaid
&Cumaisc go:
Ag cumasc...
N roghnaigh an chad chomhad
N fidir an comhad a bhraith mar chuid de chomhad scoilte
N fidir nos m n aon chuid amhin den chomhad scoilte a aimsi
7500
Ag romh na suime seicela...
Faisnis maidir leis an suim sheicela
Suim sheicela do shonra:
Suim sheicela do shonra agus d'ainmneacha
7600
Tstil fheidhmochta
Gnthaocht na cuimhne:
Ag comhbhr
Ag dchomhbhr
Measn
Measn iomln
Reatha
Toradh
Gnthaocht an LAP
Measn / Gnthaocht
Beala:
;!@Lang2@!UTF-8!
;  3.12 : Xos Calvo
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Galician
Galego
401
Dacordo
Cancelar



&Si
&Non
&Fechar
Axuda

&Continuar
440
Si a &Todo
Non a T&odo
Parar
Reiniciar
&Fondo
&Letras
&Pausa
Parado
Ten a certeza de que quer cancelar?
500
&Ficheiro
&Modificar
&Ver
F&avoritos
&Ferramentas
&Axuda
540
&Abrir
Abrir &Dentro
Abrir &Fora
&Ver
&Modificar
Reno&mear
&Copiar Para...
&Mover Para...
&Eliminar


&Propriedades
Come&ntario


Crear Cartafol
Crear Ficheiro
Sa&ir
600
Seleccionar &Todo
De-seleccionar Todo
&Inverter a Seleccin
Seleccionar...
De-seleccionar...
Seleccionar por Tipo
De-select por Tipo
700
Icones &Grandes
Icones &Pequenos
&Lista
&Detalles
730
Sen Orde

&Dous Paineis
&Barras de Ferramentas
Abrir o Cartafol Raz
Subir un Nvel
Histrico de Cartafois...
&Refrescar
750
Barra de Ferramentas de arquivos
Barra de Ferramentas normal
Botns grandes
Mostrar o Texto dos Botns
800
&Adicionar o cartafol aos Favoritos como
Marcador
900
&Opcins...
&Anlise
960
&Contido...
&Acerca do 7-Zip...
1003
Camio
Nome
Extensin
Cartafol
Tamao
Tamao comprimido
Atributos
Creado
ltimo acceso
Modificado
Slido
Comentado
Encriptado
Partir Antes
Partir Depois
Dicionario
CRC
Tipo
Anti
Mtodo
OS do Servidor
Sistema de Ficheiros
Usario
Grupo
Bloco
Comentario


























Erro
Tamao total
Tamao disponbel
Tamao co cluster
Etiqueta
Nome local
Fornecedor
2100
Opcis
Idioma
Idioma:
Editor
&Editor:

2200
Sistema
Asociar 7-Zip con:
2301
Integratar 7-Zip no men de contexto
Men de contexto en cascata
Elementos do Men de contexto:
2320
<Cartafol>
<Arquivo>
Abrir arquivo
Extrair ficheiros...
Adicionar ao arquivo...
Comprobar arquivo
Extrair Aqu
Extrair para {0}
Adicionar a {0}
Comprimir e enviar por correo...
Comprimir a {0} e enviar por correo
2400
Cartafois
&cartafol de traballo
Cartafol &temporario do sistema
Cartafol a&ctual
&Especificar:
Usar s discos removveis
Especificar unha localizacin para os ficheiros de arquivo temporarios.
2500
Axustes
Mostrar o elemento ".."
Mostrar os icones reais dos ficheiros
Mostrar o men do sistema





2900
Sobre o 7-Zip
7-Zip  un programa gratuito. Contodo, pode contribuir co seu desenvolvimento rexistrndose. Se se rexistrar, ter direito a receber apoio tcnico.
3000

Non se produciron erross
{0} obxecto(s) seleccionados
Non  posbel crear o cartafol '{0}'
Este tipo de arquivo non permite actualizacins.




Modificouse o Ficheiro '{0}'.\nQureo actualizar no arquivo?
Non  posbel actualizar o ficheiro\n'{0}'
Non se pode iniciar o editor.




Demasiados elementos
3300
Extraindo
Comprimir
Proba
Abrindo...

3400
Extrair
E&xtrair para:
Especificar unha localizacin de destino para os ficheiros extrados.
3410
Modo nome de cartafol
Camios completos
Sen camios
3420
Modo sobreposicin
Con confirmacin
Sen confirmacin
Manter os ficheiros existentes
Renomear automaticamente

3500
Confirmar a Substitucin dos Ficheiros
O cartafol de destino xa contn un ficheiro co mesmo nome.
Desexa substituir o ficheiro co mesmo nome
por este?
{0} bytes
Renomear &automaticamente
3700
Mtodo de compresin non vlido para '{0}'.
Erro de datos en '{0}'. O ficheiro est mal.
CRC fallou en '{0}'. O ficheiro est mal.


3800
Introduza o contrasinal
Introduza o contrasinal:

&Mostrar o contrasinal



Contrasinal
3900
Tempo pasado:
Tempo restante:
Tamao:
Velocidade:


Erros:

4000
Adicionar ao arquivo
&Arquivo:
&Modo de actualizacin:
&Format do arquivo:
&Nvel de compresin:
&Tipo de compresin:
Tamao do &dicionario:
Tamao das &palabras:


&Parmetros:
Opcins
Crear un arquivo SF&X



Encriptar os &nomes dos ficheiros
Uso da memoria para a Compresin:
Uso da memoria para a Decompresin:
4050
Sen compresin
Mis rpida
Rpida
Normal
Mxima
Ultra
4060
Adicionar e substituir os ficheiros
Actualizar e adicionar os ficheiros
S actualizar os ficheiros existentes
Sincronizar os ficheiros
4070
Ver
Todos os ficheiros


6000
Copiar
Mover
Copiar para:
Mover para:
A copiar...
a mover...
A renomear...

Non  posbel efectuar esta operacin.
Erro ao Renomear Ficheiro ou Cartafol


6100
Confirmar Eliminar Ficheiro
Confirmar Eliminar Cartafol
Confirmar Eliminar Mltiplos Ficheiros
Ten a certeza de que desexa eliminar '{0}'?
Ten a certeza de que desexa eliminar o cartafol '{0}' e todo o seu contido?
Ten a certeza de que desexa eliminar estes {0} elementos?
A eliminar...
Erro ao eliminar Ficheiro ou Cartafol

6300
Crear Cartafol
Crear Ficheiro
Nome do cartafol:
Nome do Ficheiro:
Novo Cartafol
Novo Ficheiro
Erro ao crear o Cartafol
Erro ao crear o Ficheiro
6400
Comentario
&Comentario:
Seleccionar
De-seleccionar
Mscara:
6600

Histrico dos Cartafois
mensaxes de diagnstico
Mensaxe
7100
Computador
Rede

Sistema
7200
Adicionar
Extrair
Probar
Copiar
Mover
Eliminar
Informacin
7300


Partir en &volumes, bytes:






7400






7500




7600
Anlise
Uso da memoria:
Compresin
Decompresin
Relacin
Relacin total
Actual
Resultante


Pases:
;!@Lang2@!UTF-8!
;  9.07 : Vinayy Sharrma :              .    ,   !   !    !  
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Gujarati, Indian, 

401





&
&
& 


& 
440
&  
&  

  
&
&()
&

    .    ?
500
&
&
&
&
&
&
540
&
& 
& 
&
&
&: 
&  ...
&  ...
&
&  ...
&  ...
&  
&
&   
&
&  
&  
&
600
&  
&  
&  
 ...
 ...
  
  
700
 
 
&
&
730

 
& 
& 
  
   
  ...
& 
750
  
  
 ()
()  
800
&    ...

900
&...
&( )
960
&...
-  ...
1003





 
  






  () 
  () 





 ( )
 


  


 




 





-
-

 
 


 

 
 
 



 
 ( )
() 
()
 

2100


:

&:
&:
2200
  
  -  :
2301
-   ()    
()  
()  :
2320
<>
<()>
 
  ...
 ...
  
  
{0}   
{0}  
()   ...
{0}     
2400

& 
& () 
&
&:
  ()     
      ().
2500

 ".."
   
   
&  
&()  
    ()-
&  
&    
2900
7-  
7-    .  ,  ()  -      .
3000
   ()    
    
{0}  ()
'{0}'     
      .
'{0}'      
'{0}'     .  ?
  
 {0}   
'{0}'    .\n       ?
     \n'{0}'
    .
   ()    (       ).
          .
       
         
  
3300
   
   

  ...
()   ...
3400
 
& :
      .
3410
 
 
   
3420
 
   
  (  ) 
   
 : 
   () :  
3500
    
       .
        ?
 ?
{0} 
 : 
3700
'{0}'     .
 {0}' .   .
'{0}'   .   .
'{0}' ()    .  ?
'{0}' ()    .  ?
3800
() 
() :
  :
&() 
   
    ,     (!, #, $, ...)    
    
()
3900
 :
  :
 :
:
 :
(  ):
:
:
4000
 
&:
& ():
 &:
& :
& :
& :
& :
  :
  :
&:

&(SFX)   
   

 :
 &  
   :
   :
4050

 




4060
    
    
   
 () 
4070
  
 
-

6000

 
 :
  :
...
   ...
 ...
   .
       .
      
    
           
6100
    
   
    
         '{0}'?
          {0}'     ?
          {0}  ?
  ...
    
      ( )    .
6300
  
  
 :
 :
 
 
   
   
6400

&:

 
:
6600
  
 
 

7100




7200

 


 


7300
  
& :
 , :
   ...
   
        {0}     ?
         
   
  : {0} .\n        ,    ?
7400
  
&  :
   ...
       
        
        
7500
()    ...
() 
 ()   :
 ()     :
7600
( )
 :
   
   

 


 
 / 
:
;!@Lang2@!UTF-8!
;                    : peterg
;                    : Gal Brill
;  9.13 : 2010-04-30 : Jonathan Lahav
;
;
;
;
;
;
;
;
0
7-Zip
Hebrew

401





&
&
&


&
440
 &
& 

 
&
&
&

? / /  
500
&
&
&
&
&
&
540
&
 &
 &
&
&
& 
... &
... &
&
... &
... &
&

  

 
 
&
600
& 
 
& 
...
... 
  
   
700
 &
 &
&
&
730
 
  
& 
& 
  
  
... 
&
750
 
 
 
    
800
&   

900
&...
& 
960
&...
&...7-Zip 
1003





 





 

 
 

CRC



 
 





 




 





64
   
 /
 
  
 

 
' 
 
 
 



 
 
 / 

 

2100

Language / 
Language / :

&:
&:
2200

7-Zip   :
2301
   - 
 
 :
2320
<>
<>
 
... 
... 
 
 
{0} - 
{0} - 
   
 - {0}   
2400

& 
 & "Temp"  
&
& :
      
.    
2500

".."   
   
   
   &
  &
   
 & 
   & 
2900
7-Zip 
   .  ,       
3000
       
 
( {0} (
'{0}'     
.      
'      '{0}' 
'?       '{0}'.  
   
 {0}  
?    \n. '{0}' 
'{0}'\n    
.    
(    (    
.       
 /   
      
  
3300



...
...
3400

& :
.   
3410
 
 
 
3420
  
  
  
   
  
    
3500
  
.      
     
? 
{: {0
  &
3700
.'{0}'     
.   '{0}'.   
.     '{0}'.   
'?    '{0}'.  
'?      '{0}'.  
3800
 
 :
   :
& 
  
(!, #, $, ...)      ,    
  

3900
 :
 :
 :
:
:
 :
:
:
4000
 
&:
 &:
& :
 &:
& :
 &:
 &:
  :
  /:
&:

  &-
  

 :
&  
  :
  :
4050

 




4060
  
  
  
 
4070

 
 

6000


 :
 :
...
...
... 
  .
     
       
  
? / /    
6100
  
  
   
?'{0}'  / /   
? / /     '{0}'   
? / /    {0}  
...
      
         
6300
 
 
 :
 :
 
 
  
  
6400

&:

 
:
6600

 
 

7100




7200







7300
 
& :
 , :
...
 
?  / /     {0} 
       
  
? / /      \n  : {0} 
7400
 
& :
... 
       
        
        
7500
...  
  
  CRC    :
   CRC    :
7600
 
 :



 


 /
 / 
:
;!@Lang2@!UTF-8!
;  9.07 : Vinayy Sharrma :                .    ,   !   !
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Hindi, Indian, 

401
 




&
&
& 


& 
440
&   
&   

  
&
&()
&

    .    ?
500
&
&
&
&
&
&
540
&
& 
& 
&
&
&: 
&  ...
&  ...
&
&   ...
&   ...
&  
&
&    
&
&  
&  
&
600
&  
&  
&  
 ...
 ...
  
  
700
 
 
&
&
730

 
& 
& 
  
   
  ...
& 
750
 
  
 ()
()   
800
&    ...

900
&...
&( )
960
&...
7-   ...
1003





 
  

 




  () 
  () 





 ( )
 


  


 




 





64-
-

 
  


 

 
 
  



 
 ( )
() 
()
 

2100


:

&:
&:
2200
  
  7-  :
2301
7-   ()    
()  
()  :
2320
<>
<()>
 
  ...
  ...
   
  
{0}   
{0}  
()   ...
{0}     
2400

& 
&  () 
&
&:
  ()      
       ().
2500

 ".."
   
   
&   
&()  
     ()-
&  
&     
2900
7-   
7-    .  ,  () -       .
3000
    ()     
     
{0}  ()
'{0}'     
        .
'{0}'         
'{0}'      .  ?
  
 {0}    
'{0}'    .\n        ?
     \n'{0}'
     .
   ()   (        ).
            .
        
        
  
3300
   
   

  ...
()   ...
3400
 
& :
        .
3410
 
 
    
3420
 
    
  (  ) 
     
 : 
     () :  
3500
    
         .
         ?
 ?
{0} 
 : 
3700
'{0}'      .
 '{0}' .    .
'{0}'   .    .
'{0}' ()    .  ?
'{0}'()    .  ?
3800
() 
() :
  :
&() 
     
     ,     (!, #, $, ...)    
    
()
3900
 :
  :
 :
:
  :
(  )  :
:
:
4000
  
&:
& ():
 &:
& :
& :
& :
& :
   :
  :
&:

&(SFX)   
   

 :
 &  
    :
    :
4050

 




4060
    
    
   
 () 
4070
  
 
-

6000

 
 :
  :
...
   ...
: ...
   .
         .
    :   
     
            
6100
    
   
    
         '{0}'?
          '{0}'     ?
          {0}  ?
  ...
     
       ( )      .
6300
  
  
 :
 :
 
 
    
    
6400

&:

 
:
6600
  
  
 

7100




7200

 


 


7300
   
& :
  , :
   ...
   
        {0}      ?
             
    
  : {0} .\n          ,    ?
7400
  
& :
   ...
        
           
         
7500
()     ...
() 
 ()    :
 ()      :
7600
( )
 :
   
   

 


 
 / 
:
;!@Lang2@!UTF-8!
;  3.12 : Alan imek
;  4.53 : Hasan Osmanagi
;  9.07 : 
; 15.05 : 2015-06-15 : Stjepan Treger  
;
;
;
;
;
;
;
0
7-Zip
Croatian
Hrvatski
401
U redu
Odustani



&Da
&Ne
&Zatvori
Pomo

Nastavi
440
Da za &Sve
Ne za Sv&e
&Stani
Ponovi
U pozadini
U prvom planu
&Pauza
Pauzirano
Ponititi?
500
&Datoteke
&Ureivanje
&Izgled
Omiljene mape
&Alati
&Pomo
540
&Otvori
Ot&vori mapu
Otvori u &sustavu
Iz&gled
&Ureivanje
Prei&menuj
&Kopiraj u...
Premje&sti u...
O&brii
Podije&li datoteku...
Spo&ji datoteke...
Svojs&tva
Komentar
Izraun kontrolnog zbroja
Usporeivanje
Stvo&ri mapu
Stvori &datoteku
&Izlaz
Poveznica
&Alternativni tokovi
600
Odaberi &sve
Poniti odabir
&Obrni odabir
Odaberi...
Poniti odabir...
Odabir po tipu
Poniti odabir tipa
700
&Velike ikone
&Male ikone
&Popis
&Detalji
730
Neso&rtirano
Sadraj mapa
&2 okna
Alatne &trake
&Korijen
&Nadmapa
Pro&le mape...
O&svjei
Automatski osvjei
750
Alatna traka arhiva
Standardna alatna traka
Velike tipke
Prikai tekst
800
Dod&aj u popis omiljenih kao
Zabiljeka
900
&Mogunosti...
M&jerenje
960
&7-Zip pomo...
&O programu...
1003
Putanja
Prema nazivu
Tip
Mapa
Prema veliini
Saeta veliina
Atributi
Kreirano
Pristupano
Prema mijenjanju
Zbijeno
Komentar
Enkripcija
Podjeli prije
Podjeli poslije
Rjenik

Prema tipu
Anti
Nain
Glavni OS
Sustav datoteka
Korisnik
Grupa
Zbijeno
Komentar
Pozicija
U datoteci
Mape
Datoteke
Inaica
Dio
Viedijelni
Razmak
Veza
Blokovi
Dijelova

64-bitno
Big-endian
CPU
Fizika veliina
Veliina zaglavlja
Kontrolni zbroj
Karakteristike
Virtualna adresa
Jedinstvena oznaka
Kratko ime
Aplikacija stvaranja
Veliina sektora
Nain
Poveznica
Greka
Ukupni kapacitet
Slobodni prostor
Veliina klastera
Naziv
Lokalni naziv
Pruatelj
NT sigurnost
Alternativni tok
Dodatno
Obrisano
Je stablo


Tip greke
Greke
Greke
Upozorenja
Upozorenje
Tokovi
Alternativni tokovi
Veliina alternativnih tokova
Virtualna veliina
Veliina raspakiranog
Ukupna fizika veliina
Indeks dijela
Podtip
Kratki komentar
Kodna stranica



Veliina repa
Veliina ugraenog odsjeka
Poveznica
vrsta poveznica
iNode

Samo za itanje
2100
Mogunosti
Jezik
Jezik:
Ureiva
&Program za ureivanje:
Program za usporeivanje:
2200
Sustav
Povei 7-Zip sa:
Svi korisnici
2301
Integriraj 7-Zip u padajui kontekstni izbornik
Padajui kontekstni izbornik
Stavke kontekstnog izbornika:
Ikone kontekstnog izbornika
2320
<Mapa>
<Arhiva>
Otvori arhiv
Raspakiraj datoteke...
Dodaj u arhiv...
Testiraj arhiv
Raspakiraj ovdje
Raspakiraj u {0}
Dodaj u {0}
Saimanje i slanje e-potom
Saimanje u {0} i slanje e-potom
2400
Mape
&Radna mapa
&Privremena sistemska mapa
&Trenutna
&Navedena:
Koristi samo za izmjenjive diskove
Lokaciju za smjetaj privremenih datoteka.
2500
Postavke
Nadmapa ".."
Prikai prave ikone datoteka
Prikai sistemski izbornik
&Oznai cijeli redak
Prikai &linije mree
Jedan klik za otvaranje stavke
Drugi n&ain oznaavanja
Koristi raspo&loivu memoriju
2900
O 7-Zip-u
7-Zip je besplatan softver.
3000
Sustav ne moe pripremiti potrebnu koliinu memorije
Nema greaka
{0} objekt(a) izabrano
Ne mogu kreirati mapu '{0}'
Obnova nije podrana za ovaj arhiv.
Nemogue otvoriti datoteku '{0}' kao arhiv
Nemogue otvoriti kriptiranu arhivu '{0}'. Kriva lozinka?
Tip arhive nije podran
Datoteka {0} ve postoji
Datoteka '{0}' je izmijenjena.\nObnoviti arhiv?
Nije mogue obnoviti datoteku\n'{0}'
Nije mogue zapoeti ureivanje.
Datoteka izgleda kao virus (naziv datoteke sadri dugake razmake).
Operaciju nemogue pozvati iz mape koja ima dugaku putanju.
Morate obiljeiti jednu datoteku
Morate obiljeiti jednu ili vie datoteka
Previe stavki
Nemogue otvoriti datoteku kao {0} arhivu
Datoteka je otvorena kao {0} arhiva
Arhiva je otvorena sa pomakom
3300
Raspakiranje
Saimanje u arhiv
Testiranje
Otvaranje u tijeku...
Skeniram...
Uklanjanje
3320
Dodavanje
Auriranje
Analiziranje
Replikiranje
Repakiranje
Preskakanje
Brisanje
Stvaranje zaglavlja
3400
Raspakiraj
&Raspakiraj u:
Lokacija za raspakiranje datoteka.
3410
Putanja mapa:
Potpune putanje
Bez putanja
Apsolutne putanje
Relativne putanje
3420
Natpii postojee
Pitaj prije natpisivanja postojeeg
Natpii postojee bez upozorenja
Preskoi postojee datoteke
Automatska promjena naziva
Automatska promjena naziva postojeih datoteka
3430
Eliminiraj dupliranje korijenske mape
Vrati sigurnost datoteka
3500
Potvrdite zamjenu datoteka
Ciljana mapa ve sadri datoteku koja se trenutno obrauje.
Zamijeniti postojeu
datoteku s ovom?
{0} bajte
A&utomatska promjena naziva
3700
Nije podran nain saimanja za '{0}'.
Podatkovna greka u '{0}'. Datoteka je neispravna.
CRC greka u '{0}'. Datoteka je neispravna.
Greka u kriptiranoj datoteci '{0}'. Kriva lozinka?
CRC greka u kriptiranoj datoteci '{0}'. Kriva lozinka?
3710
Kriva lozinka?
3721
Nepodrana metoda kompresije
Greka podataka
CRC neuspjean
Nedostupni podaci
Neoekivan kraj podataka
Postoji jo podataka nakon glavnih podataka
Nije arhiva
Greka zaglavlja
Kriva lozinka
3763
Neoekivan poetak arhive
Nepotvren poetak arhive



Nepodrano svojstvo
3800
Unesite lozinku
Unesite lozinku:
Ponovite lozinku:
&Prikai lozinku
Lozinka nije jednaka
Koristite samo engleska slova, brojeve i specijalne znake (!, #, $, ...) za lozinku
Lozinka je preduga
&Lozinka
3900
Utroeno vrijeme:
Preostalo vrijeme:
Veliina:
Brzina:
Obraeno:
Omjer kompresije:
Greke:
Arhive:
4000
Dodaj u arhiv
&Arhiv:
&Nain obnove:
&Format arhiva:
Stupanj saimanja
&Metoda saimanja:
Veliina &rjenika:
&Veliina rijei:
Veliina bloka u zbijenom:
Broj niti u CPU:
&Parametri:
&Mogunosti
Kreiraj E&XE arhiv
Sami dijeljene datoteke
Kriptiranje
Metoda kriptiranja:
Enkripcija naziva datoteka
Koritenje memorije za saimanje:
Koritenje memorije za raspakiranje:
Obrii datoteke nakon kompresije
4040
Spremi simboline poveznice
Spremi vrste poveznice
Spremi alternativne tokove podataka
Spremi sigurnost datoteka
4050
Bez saimanja
Vrlo brzo
Brzo
Uobiajeno
Najjae
Ultra
4060
Dodaj i zamjeni datoteke
Obnovi i dodaj datoteke
Osvjei postojee datoteke
Sinkroniziraj datoteke
4070
Trai
Sve datoteke
Bez-zbijanja
Zbijeno
6000
Kopiraj
Premjesti
Kopiraj u:
Premjesti u:
Kopiranje u tijeku...
Premjetanje u tijeku...
Preimenovanje u tijeku...
Odabir odredine mape.
Operacija nije podrana.
Greka pri preimenovanju datoteke ili mape
Potvrdite kopiranje datoteka
Kopiranje datoteka u arhiv?
6100
Potvrdite brisanje datoteke
Potvrdite brisanje mape
Potvrdite viestruko brisanje datoteka
Obrisati '{0}'?
Obrisati mapu '{0}' i sav njezin sadraj?
Obrisati ove {0} podatke?
Brisanje u tijeku...
Greka pri brisanju datoteke ili mape
Sustav ne moe premjestiti datoteku sa dugakom putanjom u Kantu za recikliranje
6300
Kreiraj mapu
Kreiraj datoteku
Naziv mape:
Naziv datoteke:
Nova mapa
Nova datoteka
Greka pri kreiranju mape
Greka pri kreiranju datoteka
6400
Komentar
&Komentar:
Odaberi
Poniti odabir
Maska:
6600
Svojstva
Kronologija mapa
Dijagnostike poruke
Poruka
7100
Raunalo
Mrea
Dokumenti
Sustav
7200
Dodaj
Raspakiraj
Testiraj
Kopiraj
Premjesti
Obrii
Svojstva
7300
Podijeli datoteku
&Podijeli u:
Razdvajanje na dijelove, bajta:
Dioba...
Potvrdite diobu
Podijeliti datoteku u {0} dijelova?
Veliina diobenog dijela mora biti manja od izvorne datoteke
Netona veliina bloka
Veliina bloka: {0} bajtova.\nJeste li sigurni da elite podijeliti u takve dijelove?
7400
Spoji datoteke
&Spoji u:
Spajanje...
Oznaite samo prvu datoteku
Nije pronaena datoteka koja je dio razdijeljenih datoteka
Pronaena samo jedna datoteka od razdijeljenih datoteka
7500
Izraunavanje kontrolnog zbroja...
Info kontrolni zbroj
CRC kontrolni zbroj za podatke:
CRC kontrolni zbroj za podatke i nazive:
7600
Mjerenje
Koritenje memorije:
Saimanje
Raspakiranje
Ocjena
Ukupna ocjena
Trenutno
Rezultat
CPU zauzee
Ocjena / Zauzee
Prolazi:
7700
Poveznica
Poveznica
Veza od:
Veza do:
7710
Tip poveznice
vrsta poveznica
Simbolina poveznica datoteka
Simbolina poveznica mapa
Mapa vorita
;!@Lang2@!UTF-8!
;       : Jozsef Tamas Herczeg
;  9.16 : Nyilas MISY
;
;
;
;
;
;
;
;
;
0
7-Zip
Hungarian
Magyar
401
OK
Mgsem



&Igen
&Nem
&Bezrs
Sg

&Folytats
440
I&gen, mindre
N&em, mindre
Lellts
jraindts
&Httrben
&Eltrben
&Sznet
Sznet
Biztos, hogy megszaktja a folyamatot?
500
&Fjl
S&zerkeszts
&Nzet
Ked&vencek
&Eszkzk
&Sg
540
M&egnyits
Megnyits &bell
Megnyits k&vl
&Nzet
S&zerkeszts
tn&evezs
Ms&ols mappba...
t&helyezs mappba...
&Trls
Fjl&darabols...
Fjl&egyests...
T&ulajdonsgok
&Megjegyzs
Checksum szmolsa
Klnbsg
Mappa ltrehozsa
Fjl ltrehozsa
&Kilps
600
Min&d kijellse
Kijells megszntetse
Kijells &megfordtsa
Kijells...
Megszntets...
Kijells tpus alapjn
Megszntets tpus alapjn
700
&Nagy ikonok
&Kis ikonok
&Lista
&Rszletek
730
Rendezetlen
Lapos ikonok
&2 panel
&Eszkztrak
Gykrmappa megnyitsa
Egy szinttel feljebb
Mappa elzmnyek...
&Frissts
750
Archivls eszkztr
Szoksos eszkztr
Nagy gombok
Szvegcmkk megjelentse
800
Mappa &hozzadsa a Kedvencekhez mint
Knyvjelz
900
&Belltsok...
&Teljestmnymrs
960
&Tartalomjegyzk...
7-Zip &nvjegye...
1003
tvonal
Nv
Kiterjeszts
Mappa
Mret
Tmrtett mret
Attribtumok
Ltrehozva
Hozzfrs
Mdostva
Tmr
Megjegyzs
Titkostott
Feldarabols eltt
Feldarabols utn
Sztr
CRC
Tpus
Anti
Mdszer
Gazda OS
Fjlrendszer
Felhasznl
Csoport
Blokk
Megjegyzs
Pozci
tvonal eltag
Mappk
Fjlok
Verzi
Ktet
Tbbktet
Eltols
Linkek
Blokkok
Ktetek

64-bit
Big-endian
CPU
Fizikai mret
Fejlcek mrete
Checksum
Karakterisztika
Virtulis cm
ID
Nv rendezse
Alkalmazs ksztje
Szakasz mrete
Md
Link
Hiba
Teljes mret
Szabad terlet
Klusztermret
Cmke
Helyi nv
Szolgltat
2100
Belltsok
Nyelv
Nyelv:
Szerkeszt
&Szerkeszt:
&Klnbsg:
2200
Rendszer
7-Zip trstsa:
2301
7-Zip hozzadsa a parancsrtelmez helyi menjhez
Lpcszetes helyi men
Helyi men elemek:
2320
<Mappa>
<Archvum>
Archvum megnyitsa
Fjlok kibontsa...
Hozzad az archvumhoz...
Archvum tesztelse
Kibonts ide
Kibonts ide: {0}
Hozzads: {0}
Tmrts s klds...
Tmrts {0} archvumba s klds
2400
Mappk
&Munkamappa
A &rendszer ideiglenes mappja
&Jelenlegi
&Meghatrozott:
Csak cserlhet meghajtkhoz
Vlassza ki az ideiglenes archv fjlok mappjt.
2500
Belltsok
A ".." elem lthat
Az eredeti fjlikonok lthatk
Lthat a rendszermen
&Teljes soros kijells
&Rcsvonalak kijelzse
Elem megnyitsa egyszeres kattintssal
&Alternativ kivlasztsi md
&Nagy memria haszlata
2900
A 7-Zip nvjegye
A 7-Zip ingyenes szoftver. Ha elnyerte a tetszst, s mgis szeretn tmogatni a tovbbi fejlesztst, regisztrlja 20 USD ron, fizethet hitelkrtyval vagy ms mdon.
3000
A rendszer nem tudja lefoglalni a szksges memrit
Az archvum hibamentes
{0} objektum kijellve
A(z) '{0}' mappt nem lehet ltrehozni
Az aktualizls ennl az archvumtpusnl nem tmogatott.
A(z) '{0}' fjl nem nyithat meg archvknt
A(z) '{0}' titkostott archvum nem megnyithat. Hibs a jelsz?
Nem tmogatott archvum tpus
A(z) {0} fjl mr ltezik
'{0}'\nA fjl tartalma megvltozott.\nKvnja aktualizlni az archvumban?
A fjl nem aktualizlhat:\n'{0}'
A szerkeszt nem indthat.
A fjl vrusnak nz ki (a fjlnv hossz szkzt tartalmaz a nevben).
A mvelet nem hvhat meg abbl a mappbl amelynek hossz az elrsi tvonala.
Egy fjlt ki kell jellnie!
Egy vagy tbb fjlt ki kell jellnie
Tl sok elem
3300
Kibonts
Tmrts
Tesztels
Megnyits...
Vizsglat...
3400
Kibonts
&Kibonts ide:
Hatrozza meg a kibontott fjlok trolmappjt.
3410
tvonal
Teljes tvonal
Nincs tvonal
3420
Fellrs
Rkrdezs fellrs eltt
Fellrs rkrdezs nlkl
A ltez fjlok kihagysa
Automatikus tnevezs
A ltez fjlok automatikus tnevezse
3500
Fjlcsere megerstse
A clmappa mr tartalmazza a feldolgozott fjlt.
Kvnja lecserlni a ltez fjlt
ezzel a fjllal?
{0} bjt
A&utomatikus tnevezs
3700
A(z) '{0}' tmrtsi mdja nem tmogatott.
Adathiba a kvetkezben: '{0}'. A fjl srlt.
CRC-hiba a kvetkezben: '{0}'. A fjl srlt.
Adathiba a titkostott fjlban: '{0}'. Hibs a jelsz?
CRC-hiba a titkostott fjlban: '{0}'. Hibs a jelsz?
3800
Jelsz bersa
rja be a jelszt:
Jelsz jbli bersa:
A &jelsz megjelentse
Jelszavak nem egyeznek
Csak kezetmentes karaktereket, szmokat s specilis karaktereket (!, #, $, ...) hasznljon a jelszavaknak
A jelsz tl hossz
Jelsz
3900
Eltelt id:
Htralv id:
Mret:
Sebessg:
Feldolgozott:
Tmrtsi arny:
Hibk:
Archvumok:
4000
Behelyezs archvumba
&Archvum:
Akt&ualizls mdja:
Archvum &formtuma:
Tmrts &foka:
Tmrts &mdja:
&Cmtr mrete:
&Sz mrete:
Tmr blokk mret:
CPU szmok:
&Tulajdonsgok:
Belltsok
SF&X archvum ltrehozsa
Megosztott fjlok tmrtse
Titkosts
Titkostsi eljrs:
Fjlnevek &titkostsa
A tmrts memriahasznlata:
A kitmrts memriahasznlata:
4050
Raktr
Leggyorsabb
Gyors
Norml
Legnagyobb
Ultra
4060
Fjlok behelyezse s cserje
Fjlok aktualizlsa s behelyezse
Ltez fjlok frisstse
Fjlok szinkronizlsa
4070
Tallzs
Minden fjl
Nem tmr
Tmr
6000
Msols
thelyezs
Msols ide:
thelyezs ide:
Msols...
thelyezs...
tnevezs...
Vlassza ki a cl mappt.
A mvelet nem tmogatott.
Hiba trtnt a fjl vagy a mappa tnevezsekor
Fjl msolsnak megerstse
Biztos, hogy fjl(oka)t akar msolni az archvumba?
6100
Fjltrls megerstse
Mappatrls megerstse
Tbb fjltrls megerstse
Biztos, hogy trlni akarja a kvetkezt: '{0}'?
Biztos, hogy trlni akarja a(z) '{0}' mappt s annak teljes tartalmt?
Biztos, hogy trlni akarja ezt a(z) {0} elemet?
Trls...
Hiba trtnt a fjl vagy a mappa trlsekor
A rendszer nembrja mozgatni a fjlt a hossz tvonallal a Lomtrba
6300
Mappa ltrehozsa
Fjl ltrehozsa
Mappa neve:
Fjlnv:
j mappa
j fjl
Hiba trtnt a mappa ltrehozsakor
Hiba trtnt a fjl ltrehozsakor
6400
Megjegyzs
&Megjegyzs:
Kijells
Megszntets
Maszk:
6600
Tulajdonsgok
Mappa elzmnyek
Diagnosztikai zenetek
zenet
7100
Sajtgp
Hlzati helyek
Dokumentumok
Rendszer
7200
Hozzads
Kibonts
Teszt
Msols
thelyezs
Trls
Tulajdonsgok
7300
Fjldarabols
&Darabols ide:
Darabols &ktetekre, bjt:
Darabols...
Darabols megerstse
Biztos szt akarja darabolni a fjlt {0} ktetre?
Ktet mretnek kissebbnek kell lennie, mint az eredeti fjl mrete
Hibs ktet mret
A megadott ktet mrete: {0} byte.\nBiztos fel akarja darabolni az archvumot ilyen ktetre?
7400
Fjlegyests
&Egyests ide:
Egyests...
Csak az els rsz kivlasztsa a darabolt fjlbl
Nem ismeri fel a fjlt, mint darabolt fjl rsze
Nem tall egynl tbb rszt a darabolt fjlbl
7500
Lers szmolsa...
Lers informci
CRC lers az adathoz:
CRC lers az adathoz s nvhez:
7600
Teljestmnymrs
Memriahasznlat:
Tmrts
Kitmrts
rtkels
sszrtkels
Jelenlegi
Eredmny
CPU hasznlata
Becsls / Hasznlat
Menetek:
;!@Lang2@!UTF-8!
;       : Gevorg Papikyan
; 15.00 : Hrant Ohanyan : http://haysoft.org
;
;
;
;
;
;
;
;
;
0
7-Zip
Armenian

401





&
&
&


&
440
  &
  &


&
&
&
  

500
&
&
&
&
&
&
540
&
 &
 &

&
&
&...
&...
&
& ...
& ...
&
&


& 
& 
&

& 
600
 &

& &
...
...
  
  
700
& 
& 
&
&
730
 
 
&2 
& 
  
  
 ...
&

750
  
  
 
 
800
  & 

900
...
 
960
&...
 &...
1003







 

 


 
  
  






 


















CPU
 
 


 

 

 

 


 
 

 


 





 





 
  
 
 
  
 

 
 



 
  

 
iNode

 






2100


.

&
& .
2200

 7-Zip-   
 
2301
 7-Zip-  
 
  
  
2320


 
 
 ...

  
 {0}-
 {0}-
   . ...
 {0}-   . 
2400

& 
&  
&
&.
    
    
2500

  ".."
   
  
  
 
  
  
   
2900
7-Zip- 
7-Zip-    :
3000
  
 
  {0} 
   '{0}' :
     :
   '{0}'   
   '{0}'  :  :
   
{0}    
'{0}'   :\n   :
    \n'{0}'
   :
   :
     ,    :
   
      
  
     {0} 
    {0} 
   
3300
  
 
 
 ...
...

3320
 
 

 

  

 
3400
 
& 
   :
3410
 .
& 
& 
 
 
3420


 
 

  
3430
  . 
  
3500
  
    :
  
 :
{0} 
 .
3700
'{0}'     
 '{0}'-:   :
CRC '{0}'-:   :
 '{0}'   :   :
CRC  '{0}'   :   :
3710
  
3721
  
 
CRC 
 
  
     
 
 
  
3763
  
  



 
3800
 
& .
 .
& 
  
     ,     (!, #, $, ...)
   
&.
3900
 .
 .
.
.
.
 
.
.
4000
 
&.
& .
& .
& .
& .
 &.
 &.
 .
CPU  .
&.
&
 SF&X 
  

 .
&  
.   .
.    .
   
4040
  
  
  
  
4050
 





4060
  
  


4070

 
 

6000




 ...
 ...
 ...
 
  
`    :
  
    :
6100
  
  
  
     "{0}"-:
     "{0}"    :
    ({0} ) :
 ...
`    :
      :
6300
 
 
 .
 .
 
 
`  
`  
6400

&


.
6600

 


7100




7200

 





7300
 
&
 & ()`
...
 
   {0} 
        
 
  . {0} :\n  :
7400
 
&.
...
     
    
     
7500
Checksum- ...
Checksum
CRC checksum  .
CRC checksum    .
7600
 
 .

 

 

 
CPU- -
./.
.
7700


.
.
7710
 
 
  ()
  ()
  (Junction)
;!@Lang2@!UTF-8!
; 15.14 : 02/01/2016 : Frans Liando
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Indonesian
Bahasa Indonesia
401
Oke
Batal



&Ya
&Tidak
&Tutup
Bantuan

&Lanjut
440
Ya untuk &semua
Tidak untuk s&emua
Henti
Mulai Ulang
Latar Bela&kang
Latar &Depan
&Jeda
Terjeda
Anda yakin ingin batal?
500
&Berkas
&Edit
Tam&pilan
&Kesukaan
Pera&latan
Ban&tuan
540
&Buka
Buka Sisi &Dalam
Buka Sisi L&uar
&Tampilkan
&Edit
&Nama Ulang
&Salin Ke...
P&indahkan Ke...
&Hapus
Be&lah Berkas...
Gabun&g Berkas...
P&roperti
K&omentari
Hitung ceksum
Beda
Buat Direktori
Buat Berkas
&Keluar
Tautan
Alternati&f Aliran
600
Pi&lih Semua
Batal Pilih Semua
Pilih Sebal&iknya
Pilih...
Batal Pilih...
Pilih Berdasarkan Tipe
Batal Pilih Berdasarkan Tipe
700
Ikon &Besar
Ikon &Kecil
&Daftar
&Rincian
730
Tidak Berurutan
Tampilan Datar
&2 Panel
Bilah Ala&t
Buka Akar Direktori
Naik Satu Tingkat
Riwayat Direktori...
&Segarkan
Segarkan Otomatis
750
Bilah Alat Arsip
Bilah Ala&t Standar
Tombol Besar
Perlihatkan Teks Tombol
800
Tambah direktori ke Favorit sebagai
Markah
900
&Pilihan...
&Tolok Ukur
960
Petun&juk...
Mengen&ai 7-Zip...
1003
Lintasan
Nama
Ekstensi
Direktori
Ukuran
Ukuran dipak
Atribut
Dibuat
Diakses
Dimodifikasi
Padat
Dikomentari
Dienkripsi
Belah Sebelum
Belah Setelah
Kamus

Tipe
Anti
Metode
SO Host
Sistem Berkas
Pengguna
Grup
Blok
Komentar
Posisi
Awalan Lintasan
Direktori
Berkas
Versi
Volume
Multivolume
Gelinciran
Tautan
Blok
Volume

64-bit
Big-endian
CPU
Ukuran Fisik
Ukuran Tajuk
Ceksum
Karakteristik
Alamat Maya
ID
Nama Singkat
Aplikasi Pembuat
Ukuran Sektor
Ragam
Tautan Simbolik
Kesalahan
Ukuran Total
Ruang Kosong
Ukuran Gugus
Label
Nama Lokal
Penyelenggara
Keamanan NT
Alternatif ALiran
Aux
Dihapus
Apakah Pohon


Tipe Kesalahan
Kesalahan
Kesalahan
Peringatan
Peringatan
Aliran
Alternatif Aliran
Ukuran Alternatif Aliran
Ukuran Maya
Ukuran Terbongkar
Jumlah Ukuran Fisik
Indeks Volume
SubTipe
Komentar Singkat
Laman Kode



Ukuran Ujung
Ukuran Rintisan Tertanam
Tautan
Tautan Keras
iNode

Hanya-baca
2100
Pilihan
Bahasa
Bahasa:
Editor
&Editor:
Be&da:
2200
Sistem
Asosiasikan 7-Zip dengan:
Semua pengguna
2301
Integrasikan 7-Zip ke cangkang menu konteks
Menu konteks dikaskade
Butir-butir menu konteks:
Ikon-ikon di menu konteks
2320
<Direktori>
<Arsip>
Buka arsip
Ekstrak berkas...
Tambah ke arsip...
Uji arsip
Ekstrak di sini
Ekstrak ke {0}
Tambah ke {0}
Mampat dan surat kawat...
Mampat ke {0} dan surat kawat
2400
Direktori
&Direktori kerja
Direktori temporer &sistem
S&ekarang
&Ditentukan:
Hanya untuk kandar yang dapat dilepas
Tetapkan lokasi untuk berkas arsip sementara.
2500
Pengaturan
Perlihatkan butir ".."
Perlihatkan ikon asli berkas
Perlihatkan menu sistem
&Memilih baris penuh
Perlihatkan &garis kisi-kisi
Klik-tunggal untuk membuka
Ragam pemilihan &alternatif
Gunakan halaman memori &besar
2900
Mengenai 7-Zip
7-Zip merupakan perangkat lunak gratis.\n\nTerjemahan oleh Frans Liando.
3000
Sistem tidak bisa mengalokasikan jumlah memori yang diperlukan
Tidak ada kesalahan
{0} objek terpilih
Tidak bisa membuat Direktori '{0}'
Operasi pembaruan tidaklah didukung untuk arsip ini.
Tidak bisa membuka berkas arsip '{0}'
Tidak bisa membuka arsip terenkripsi '{0}'. Salah kata sandi?
Tipe arsip tidak didukung
Berkas {0} telah ada
Berkas '{0}' telah termodifikasi.\nApakah Anda ingin perbarui berkas dalam arsip?
Tidak bisa perbarui berkas\n'{0}'
Tidak bisa memulai editor.
Berkas ini tampaknya seperti virus (pada nama berkas berisi spasi yang panjang).
Pengoperasian tidak bisa dipanggil dari direktori yang berlintasan panjang.
Anda harus pilih satu berkas
Anda harus pilih satu berkas atau lebih
Terlalu banyak butir
Tidak bisa buka berkas sebagai arsip {0}
Berkas dibuka sebagai arsip {0}
Berkas dibuka dengan gelinciran
3300
Mengekstrak
Pemampatan
Pengujian
Membuka...
Memindai...
Memindah
3320
Menambah
Memperbarui
Menganalisa
Mereplikasi
Pak ulang
Melewatkan
Menghapus
Membuat tajuk
3400
Ekstrak
E&kstrak ke:
Tetapkan lokasi untuk berkas yang diekstrak.
3410
Ragam lintasan:
Nama lengkap lintasan
Tidak ada nama lintasan
Nama lintasan absolut
Nama lintasan relatif
3420
Ragam tulis timpa:
Konfirmasikan sebelum tulis timpa
Tulis timpa tanpa konfirmasi
Lewati berkas yang ada
Penamaan ulang automatis
Penamaan ulang automatis terhadap berkas yang ada
3430
Hilangkan duplikasi direktori akar
Pulihkan keamanan berkas
3500
Konfirmasi Penggantian Berkas
Direktori tujuan telah berisi berkas yang terproses.
Maukah Anda mengganti berkas yang ada
dengan yang satu ini?
{0} bita
Nama &Ulang Automatis
3700
Metode mampat untuk '{0}' tidak didukung.
Kesalahan data di '{0}'. Berkas ini rusak.
CRC gagal di '{0}'. Berkas ini rusak.
Kesalahan data di berkas terenkripsi '{0}'. Salah kata sandi?
CRC gagal di berkas terenkripsi '{0}'. Salah kata sandi?
3710
Salah kata sandi?
3721
Metode mampat tidak didukung
Kesalahan data
CRC gagal
Data tidak tersedia
Akhir data tidak terduga
Terdapat suatu data setelah akhir muatan data
Bukan arsip
Kesalahan Tajuk
Salah kata sandi
3763
Awal arsip belum tersedia
Awal arsip belum dikonfirmasi



Fitur tidak didukung
3800
Masukkan kata sandi
Masukkan kata sandi:
Konfirmasi kata sandi:
&Perlihatkan kata sandi
Kata sandi tidak cocok
Gunakanlah hanya huruf bahasa Indonesia, nomor dan karakter khusus (!, #, $, ...) untuk kata sandi
Kata sandi terlalu panjang
Kata sandi
3900
Waktu terpakai:
Sisa waktu:
Jumlah ukuran:
Kecepatan:
Terproses:
Rasio mampat:
Kesalahan:
Arsip:
4000
Tambah ke arsip
&Arsip:
Ragam perbar&u:
&Format arsip:
&Level mampat:
&Metode mampat:
Ukuran &kamus:
Ukuran ka&ta:
Ukuran blok padat:
Jumlah CPU:
&Parameter:
Pilihan
Buat arsip SF&X
Kompres berkas bersama
Enkripsi
Metode enkripsi:
Enkripsi &nama berkas
Pemakaian memori untuk Pemampatan:
Pemakaian memori untuk Pengawamampatan:
Hapus berkas setelah dimampatkan
4040
Simpan tautan simbolik
Simpan tautan keras
Simpan alternatif aliran data
Simpan keamanan berkas
4050
Simpan
Tercepat
Cepat
Normal
Maksimum
Ultra
4060
Tambah dan ganti berkas
Perbarui dan tambah berkas
Segarkan ulang berkas yang ada
Sinkronisasikan berkas
4070
Ramban
Semua Berkas
Non-padat
Padat
6000
Salin
Pindah
Salin ke:
Pindah ke:
Menyalin...
Memindah...
Penamaan Ulang...
Pilih direktori tujuan.
Pengoperasian tidak didukung untuk direktori demikian.
Kesalahan Penamaan Ulang Berkas atau Direktori
Konfirmasi Salin Berkas
Anda yakin ingin menyalin berkas ke arsip?
6100
Konfirmasi Hapus Berkas
Konfirmasi Hapus Direktori
Konfirmasi Hapus Berkas-berkas
Anda yakin ingin hapus '{0}'?
Anda yakin ingin hapus direktori '{0}' dan semua isinya?
Anda yakin ingin hapus {0} butir?
Menghapus...
Kesalahan Penghapusan Berkas atau Direktori
Sistem tidak bisa memindah suatu berkas yang berlintasan panjang ke Recycle Bin
6300
Buat Direktori
Buat Berkas
Nama Direktori:
Nama berkas:
Direktori Baru
Berkas Baru
Kesalahan Membuat Direktori
Kesalahan Pembuatan Berkas
6400
Komentar
&Komentari:
Pilih
Tidak Memilih
Masker:
6600
Properti
Riwayat Direktori
Pesan Diagnosa
Pesan
7100
Komputer
Jaringan
Dokumen
Sistem
7200
Tambah
Ekstrak
Uji
Salin
Pindah
Hapus
Info
7300
Belah Berkas
&Belah ke:
Belah ke &volume, bita:
Membelah...
Konfirmasi Membelah
Anda yakin ingin membelah berkas menjadi {0} volume?
Ukuran volume seharusnya lebih kecil dari pada ukuran asli berkas
Ukuran volume salah
Tentukan ukuran volume: {0} bita.\nAnda Yakin ingin membelah arsip menjadi volume demikian?
7400
Gabung Berkas
&Gabung ke:
Menggabung...
Pilih bagian pertama saja dari berkas belahan
Tidak bisa mendeteksi berkas sebagai bagian berkas belahan
Tidak bisa menemukan lebih dari satu bagian berkas belahan
7500
Hitung ceksum...
Informasi ceksum
Ceksum CRC untuk data:
Ceksum CRC untuk data dan nama:
7600
Tolok Ukur
Pemakaian memori:
Pemampatan
Pengawamampatan
Penilaian
Jumlah Penilaian
Sekarang
Hasil
Pemakaian CPU
Penilaian/Pemakaian
Lulus:
7700
Tautan
Tautan
Tautan dari:
Tautan ke:
7710
Tipe Tautan
Tautan Keras
Berkas Tautan Simbolik
Direktori Tautan Simbolik
Cabang Direktori
;!@Lang2@!UTF-8!
;  4.08 : iZoom
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Ido
Ido
401
B&one
Abandonar



&Yes
&No
&Klozez
Helpo

&Durez
440
Yes por &omni
No por o&mni
Haltez
Ristartez
&Fono
&Avanajo
&Pauzo
Pauzita
Kad vu ya volas abortar?
500
&Dosiero
&Redakto
&Aspekto
&Favoraji
&Utensili
&Helpo
540
&Apertigar
Apertigar int&erne
Apertigar e&xter
&Vidigar
&Redaktar
Ch&anjar nomo
Ko&piar aden...
Transp&ozar aden...
E&facar
F&endar dosiero...
Komb&inar dosieri...
In&heraji
Ko&mentar


Krear &dosieruyo
Krear dos&iero
E&kirar
600
Merk&ar omno
Des&merkar omno
&Inversigar merko
Merkar...
Desmerkar...
Merkar segun tipo
Desmerkar segun tipo
700
&Granda ikoneti
&Mikra ikoneti
&Listo
&Tabelo
730
&Nearanjite

&2 paneli
Utens&ila paneli
Apertigar radika dosieruyo
Ad-supre ye un nivelo
Dosieruya historio...
R&inovigar
750
Utensila panelo di arkivo
Norma utensila panelo
Granda ikoneti
Videbla butontexto
800
&Adjuntar dosieruyo ad la favorata quale
Lektomerkajo
900
&Ajusti...
&Experienco dil rapideso
960
&Konteno...
&Pri 7-Zip...
1003
Dosiervoyo
Nomo
Dosiernoma sufixo
Dosieruyo
Grandeso
Enarkiva grandeso
Atributi
Kreita
Acesita
Chanjita
Solida
Komentita
Chifrita
Fendita ante
Fendita pos
Vortaro
CRC
Tipo
Kontre
Metodo
Operacala sistemo
Dosiersistemo
Uzero
Grupo
Bloko
Komenturo
Poziciono

























Eroro
Tota kapacivo
Vakanta
Faskogrando
Etiketo
Lokala nomo
Provizanto
2100
Ajusti
Linguo
Linguo:
Redaktilo
&Redaktilo:

2200
Sistemo
Asociar 7-Zip-o kun dosieru:
2301
Pozar 7-Zip'o en kuntexta menuo di shelo
Kaskada kuntexta menuo
Elementi di kuntexta menuo:
2320
<Dosieruyo>
<Arkivo>
Apertar
Extraktar dosieri...
Adjuntar ad arkivo...
Verifikar arkivo
Extraktez hike
Extraktez aden {0}
Adjuntar ad {0}
Enarkivigar ed sendar elk-posto...
Enarkivigar aden {0} e sendar elk-posto...
2400
Dosieruyi
&Laborala dosieruyo
&Sistemala provizora dosieruyo
&Nuna
&Definez:
&Uzar nur por deprenebla datumportili
Definar loko por provizora arkiva dosieri.
2500
Ajusti
Montrar ".."-elemento
Montrar reala dosier-ikoneti
Montrar sistemala menuo
Merkar &tota lineo
Montrar &streki separanta



2900
Pri progamo...
7-Zip esas gratuita programo. Tamen, vu povas mantenar developado di 7-Zip per enregistrigesar.
3000

Erori ne es trovita
{0} objekt(o|i) merkita
Krear dosieruyo '{0}' neposiblesis
Rinovigo ne suportesas por ica arkivo.




Dosiero '{0}' chanjesis.\nKa vu volas rinovigar lu enarkive?
Rinovigo dil dosiero\n'{0}' faliis
Startigo dil redaktilo.




Tro multa objekti
3300
Extrakto
Kompreso
Probado
Aperto...

3400
&Extraktar
E&xtraktar aden:
Definez loko por dosieri extraktenda.
3410
Dosiervoyi
&Absoluta dosiervoyi
&Sen dosiervoyi
3420
Remplasala skribmodo
&Kun konfirmo
&Sen konfirmo
&Omisar existanta dosieri
Automata nomchanjo
Automata nomchanjo de existanta dosieri
3500
Konfirmo di nomchanjo
Dosieruyo ja kontenas operacata dosiero.
Kad remplasor esanta dosiero
per la ica?
{0} bayti*
&Automata nomchanjo.
3700
Kompresmetodo ne esas suportata por dosiero '{0}'.
Datumeroro en '{0}'. Dosiero es fushita.
CRC-eroro en '{0}'. Dosiero es fushita.


3800
Pasovorto
Sugestez pasovorto:

&Montrar pasovorto



&Pasovorto
3900
Pasinta tempo:
Restanta tempo:
Grandeso:
Rapideso:


Erori:

4000
Adjuntar aden arkivo
&Arkivo:
R&emplasomodo:
A&rkiva formato:
Kompreso&grado
&Kompresometodo:
&Vortarograndeso:
Vo&rtograndeso:


&Parametri:
Ajustaji
Krear SF&X-arkivo



Chifrar dosier&nomi
Memoruzo por kompresar:
Memoruzo por extraktar:
4050
Sen kompresar
Maxim rapide
Rapide
Normala kompreso
Maxim granda kompreso
Extreme
4060
Adjuntar e remplasar dosieri
Rinovigar e adjuntar dosieri
Rifreshigar existanta dosieri
Sinkronizar dosieri
4070
Inspektar
Omna dosieri


6000
Kopiar
Transpozar
Kopiez aden:
Transpozez aden:
Kopio...
Transpozo...
Nomchanjo...

Operaco ne suportesas.
Eroro dum nomchanjo di dosiero o dosieruyo


6100
Konfirmo dil efaco di dosiero
Konfirmo dil efaco di dosieruyo
Konfirmo dil efaco di dosieraro
Ka vu ya volas efacar '{0}'?
Ka vu ya volas efacar dosieruyo "{0}" e omna lua kontenaji?
Ka vu ya volas efacar ita {0} objekti?
Efaco...
Eroro dum efacar di dosiero o dosieruyo

6300
Krear dosieruyo
Krear dosiero
Dosieruynomo:
Dosiernomo:
Nova dosieruyo
Nova dosiero
Eroro dum dosieruykreo
Eroro dum dosierkreo
6400
Komento
&Komento:
Merkar
Desmerkar
Masko:
6600

Dosieruyhistorio
Diagnozala mesaji
Mesajo
7100
Komputilo
Reto

Sistemo
7200
Adjuntar
Extraktar
Verifikar
Kopiar
Transpozar
Efacar
Informo
7300
Fendar dosiero
&Fendez aden:
&Fendar por volumini, bayti:
Fendo...





7400
Kombinar dosieri
&Kombinar aden:
Kombino...



7500




7600
Experienco dil rapideso
Memoruzo:
Kompresado
Extraktado
Aprecuro
Tota aprecuro
Kuranta
Rezulta


Pasi:
;!@Lang2@!UTF-8!
; 15.14 : 2016-04-23 : Stefn rvar Sigmundsson
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Icelandic
slenska
401
 lagi
Vihtta



&J
&Nei
&Loka
Hjlp

&Halda fram
440
&J vi llu
&Nei vi llu
Stva
Endurrsa
&Bakgrunnur
&Forgrunnur
&Gera hl
 hli
Ert  viss um a  viljir vihtta?
500
&Skr
&Breyta
S&koa
&Upphald
&Verkfri
&Hjlp
540
&Opna
Opna a &innanveru
Opna a &utanveru
S&koa
&Breyta
&Endurnefna
&Afrita 
&Fra 
E&ya
K&ljfa skr
S&ameina skrr
E&iginleikar
&Gera athugasemd
Reikna samtlu
Mismunur
Skapa &mppu
Skapa &skr
&Htta
&Tengill
&Vxlstraumar
600
&Velja allt
&Afvelja allt
&Umsna vali
&Velja
&Afvelja
&Velja eftir tegund
&Afvelja eftir tegund
700
&Strar tknmyndir
S&mar tknmyndir
&Listi
Sm&atrii
730
flokka
&Flatsn
&2 spjld
&Verkfrastikur
&Opna rtarmppu
&Upp um eitt stig
M&ppusaga
&Endurgla
S&jlfendurglun
750
Safnverkfrastika
Stlu verkfrastika
Strir takkar
Sna takkatexta
800
&Vibta mppu  upphald sem
Bkamerki
900
&Valmguleikar
&Afkastaprfa
960
&Efnisyfirlit
&Um 7-Zip
1003
Sl
Nafn
Framlenging
Mappa
Str
jppu str
Eiginleikar
Skapa
Akomi
Dagsetning
tt
Athugasemd
Dulka
Kljfa fyrir
Kljfa eftir
Orasafn

Tegund
And
Afer
Strikerfi hsils
Skrakerfi
Notandi
Hpur
Blkur
Athugasemd
Stasetning
Slarforskeyti
Mppur
Skrr
tgfa
Bindi
Fjlbinda
Afsetning
Tenglar
Blkar
Bindi

64-bita
Henda
Gjrvi
Efnisleg str
Hfastr
Samtala
Einkenni
Sndarvistfang
Aukenni
Stutt nafn
Skaparahugbnaur
Geirastr
Hamur
Mjktengill
Villa
Heildarstr
Laust plss
Klasastr
Merki
Staarnafn
Veitandi
NT-ryggi
Vxlstraumur
Astoar-
Eytt
Er tr


Villutegund
Villur
Villur
Vivaranir
Vivrun
Straumar
Vxlstraumar
Vxlstraumastr
Sndarstr
Afjppu str
Efnisleg heildarstr
Bindaskr
Undirtegund
Stutt athugasemd
Kasa



Halastr
Innfallin stubbastr
Tengill
Hartengill
Skrhntur

Einungis lesanlegt
2100
Valmguleikar
Tunguml
Tunguml:
Ritill
&Ritill:
&Mismunur:
2200
Kerfi
Tengja 7-Zip vi:
Allir notendur
2301
&Innleia 7-Zip  samhengisvalmynd skeljar
&repaskipt samhengisvalmynd
Samhengisvalmyndaratrii:
&Tknmyndir  samhengisvalmynd
2320
<Mappa>
<Safn>
Opna safn
Afjappa skrr
Vibta  safn
Prfa safn
Afjappa hr
Afjappa  {0}
Vibta  {0}
jappa og senda  rafpsti
jappa  {0} og senda  rafpsti
2400
Mppur
Vinnslumappa
&Tmabundin mappa kerfis
&Nverandi
Til&greind:
N&ota einungis fyrir fjarlgjanleg drif
Tilgreina stasetningu fyrir tmabundnar safnskrr.
2500
Stillingar
Sna .. &atrii
Sna &raunverulegar skrartknmyndir
Sna &kerfisvalmynd
&Fullraaval
Sna &tflulnur
&Einsmella til a opna atrii
Annars konar &valhamur
Nota strar &minnissur
2900
Um 7-Zip
7-Zip er frjls hugbnaur
3000
Kerfi getur ekki rstafa nausynlega magninu af minninu
a eru engar villur
{0} hlutir valdir
Getur ekki skapa mppuna {0}
Uppfrsluagerir eru ekki studdar fyrir etta safn.
Getur ekki opna skrna {0} sem safn
Getur ekki opna dulkaa safni {0}. Rangt agangsor?
studd safntegund
Skrin {0} er n egar til
Skrnni {0} var breytt.\nVilt  uppfra hana  safninu?
Getur ekki uppfrt skrna\n{0}
Getur ekki rst ritilinn.
Skrin ltur t eins og veira (skrarnafni inniheldur lng bil).
Agerina er ekki hgt a kalla  fr mppu sem hefur langa sl.
 verur a velja eina skr
 verur a velja eina ea fleiri skrr
Of mrg atrii
Getur ekki opna skrna sem {0}-safn
Skrin er opin sem {0}-safn
Safni er opi me afsetningu
3300
Afjappar
jappar
Prfar
Opnar
Skimar
Fjarlgir
3320
Vibtir
Uppfrir
Greinir
Endurtekur
Endurpakkar
Sleppir
Eyir
Skapar hfu
3400
Afjappa
Afjappa :
Tilgreindu stasetningu fyrir afjppuu skrrnar.
3410
Slarhamur:
Full slarnfn
Engin slarnfn
Algild slarnfn
Afst slarnfn
3420
Yfirritunarhamur:
Spyrja ur en yfirrita er
Yfirrita n kvaningar
Sleppa gildandi skrm
Sjlfendurnefnun
Sjlfendurnefnun gildandi skra
3430
trma afritinu af rtarmppunni
Endurheimta skrarryggi
3500
Stafesta skraryfirritun
fangastasmappan inniheldur n egar mehndluu skrna.
Vilt  yfirrita gildandi skrna
me essari?
{0} bti
Sjlfendurnefnun
3700
studd jppunarafer fyrir {0}.
Gagnavilla  {0}. Skrin er brotin
CRC mistkst  {0}. Skrin er brotin.
Gagnavilla  dulkuu {0}. Rangt agangsor?
CRC mistkst  dulkuu skrnni {0}. Rangt agangsor?
3710
Rangt agangsor?
3721
studd jppunarafer
Gagnavilla
CRC mistkst
tiltk ggn
vntur endir gagna
a eru ggn eftir endanum  aalggnunum
Er ekki safn
Hfavillur
Rangt agangsor
3763
tiltkt upphaf safns
stafest upphaf safns



studdur eiginleiki
3800
Ritau agangsori
Ritau agangsori:
Endurritau agangsori:
Sna agangsori
Agangsorin samsvarast ekki
Notau einungis enska stafi, tlur og srstk rittkn (!, #, $, o.s.frv.)  agangsorunum
Agangsori er of langt
Agangsor
3900
Liinn tmi:
Tmi eftir:
Heildarstr:
Hrai:
Mehndla:
jppunarhlutfall:
Villur:
Sfn:
4000
Vibta safni
Safn:
Uppfrsluhamur:
Safnsni:
jppunarsni:
jppunarafer:
Orasafnsstr:
Orastr:
ttblkstr:
Fjldi gjrvara:
Fribreytur:
Valmguleikar
Skapa SFX-safn
jappa sameiginlegum skrm
Dulkun
Dulkunarafer:
Dulka skrarnfn
Minnisnotkun fyrir jppun:
Minnisnotkun fyrir afjppun:
Eya skrm eftir jppun
4040
Geyma mjktengla
Geyma hartengla
Geyma vxlgagnastrauma
Geyma skrarryggi
4050
Geyma
Hraast
Hratt
Venjulegt
Hmarks
fga-
4060
Vibta og yfirrita skrr
Uppfra og vibta skrm
Hressa vi gildandi skrm
Samstilla skrr
4070
Vafra
Allar skrr
tt
tt
6000
Afrita
Fra
Afrita :
Fra :
Afritar
Frir
Endurnefnir
Veldu mttkumppu.
Aferin er ekki stutt fyrir essa mppu.
Villa vi endurnefnun skrar ea mppu
Stafesta skrarafritun
Ert  viss um a  viljir afrita skrrnar  safni
6100
Stafesta skrareyingu
Stafesta mppueyingu
Stafesta fjlskraeyingu
Ert  viss um a  viljir eya {0}?
Ert  viss um a  viljir eya mppunni {0} og llu innihaldinu hennar?
Ert  viss um a  viljir eya essum {0} atrium?
Eyir
Villa vi eyingu skrar ea mppu
Kerfi getur ekki frt skr me langri sl  Recycle Bin
6300
Skapa mppu
Skapa skr
Mppunafn:
Skrarnafn:
N mappa
N skr
Villa vi skpun mppunnar
Villa vi skpun skrarinnar
6400
Athugasemd
Athugasemd:
Velja
Afvelja
Mt:
6600
Eiginleikar
Mppusaga
Greiningarskilabo
Skilabo
7100
Tlva
Net
Skjl
Kerfi
7200
Vibta
Afjappa
Prfa
Afrita
Fra
Eya
Upplsingar
7300
Kljfa skr
Kljfa :
Kljfa  bindi, bti:
Klfur
Stafesta klofning
Ert  viss um a  viljir kjfa skrna  {0} bindi?
Bindisstr verur a vera minni en strin  upprunalegu skrnni
Rng bindisstr
Tilgreindu bindisstr: {0} bti.\nErt  viss um a  viljir kljfa safni  slk bindi?
7400
Sameina skrr
Sameina :
Sameinar
Veldu einungis fyrsta hlutann af klofningsskrnni
Get ekki greint skrna sem hluta af klofningsskrnni
Get ekki fundi meira en einn hluta af klofningsskrnni
7500
Reiknar samtlu
Samtluupplsingar
CRC-samtala fyrir ggn:
CRC-samtala fyrir ggn og nfn:
7600
Afkastaprf
Minnisnotkun:
jppun
Afjppun
Niurstaa
Heildarniurstaa
Nverandi
tkoma
Gjrvanotkun
Niurstaa / Notkun
Yfirferir:
7700
Tengill
Tengill
Tengill fr:
Tengill til:
7710
Tengiltegund
Hartengill
Skrarmjktengill
Skrasafnsmjktengill
Skrasafnstenging;!@Lang2@!UTF-8!
;  4.07 : Leandro Spagnol
;       : Vincenzo Reale (some corrections)
; 15.05 : 2015-06-17 : TJL73 : http://tjl73.altervista.org/
;
;
;
;
;
;
;
;
0
7-Zip
Italian
Italiano
401
OK
Annulla



&S
&No
&Chiudi
Aiuto

&Riprendi
440
S per &tutti
No per t&utti
Ferma
Riavvia
&In background
&In primo piano
&Pausa
In pausa
Sei sicuro di voler annullare?
500
&File
&Modifica
&Visualizza
&Preferiti
&Strumenti
&Aiuto
540
&Apri
Apri in &7-Zip File Manager
Apri in E&xplorer
&Visualizza
Apri con l'&editor predefinito
Rino&mina
&Copia in...
&Sposta in...
&Elimina
&Dividi il file...
&Unisci i file...
&Propriet
Comme&nto...
Calcola chec&ksum
Comparazione differenze (Diff)
Crea cartella
Crea file
E&sci
Collegamento
&Alternate Data Streams
600
&Seleziona tutto
&Deseleziona tutto
In&verti selezione
Seleziona...
Deseleziona...
Seleziona per tipo
Deseleziona per tipo
700
Icone &grandi
Icone &piccole
&Elenco
&Dettagli
730
Nessun ordine
Vista non strutturata
Interfaccia a &2 pannelli
Barre degli &strumenti
Apri cartella principale
Livello superiore
Cronologia...
&Aggiorna
Aggiornamento automatico
750
Barra archivio
Barra standard
Icone grandi
Mostra etichette di testo
800
&Aggiungi la cartella ai Preferiti come
Collegamento
900
&Opzioni...
&Benchmark
960
&Guida...
&Informazioni su 7-Zip...
1003
Percorso
Nome
Estensione
Cartella
Dimensione
Dimensione compressa
Attributi
Creato
Ultimo accesso
Ultima modifica
Solido
Commentato
Cifrato
Dividi prima
Dividi dopo
Dizionario

Tipo
Estensione
Metodo
OS destinatario
File system
Utente
Gruppo
Blocco
Commento
Posizione
Percorso completo
Cartelle
File
Versione
Unit
Unit multiple
Offset
Collegamenti
Blocchi
Unit

64-bit
Big-endian
CPU
Dimensione fisica
Dimensione intestazioni
Checksum
Caratteristiche
Indirizzo virtuale
ID
Nome breve
Applicativo origine
Dimensione settore
Modalit
Collegamento simbolico
Errore
Capacit
Disponibili
Dimensione dei cluster
Etichetta
Nome locale
Rete
Sicurezza NT
Flusso alternato
Ausiliario
Eliminato
Ad albero


Tipo di errori
Errori
Errori
Avvertimenti
Avvertimento
Flussi
Flussi alternati
Dimensione dei flussi alternati
Dimensione virtuale
Dimensione decompressione
Dimensione fisica totale
Indice del volume
Sottotipo
Commento breve
Pagina dei codici



Dimensione della coda
Dimensione della matrice integrato
Collegamento
Collegamento statico
iNode

Sola lettura
2100
Opzioni
Lingua
Lingua:
Editor
&Editor predefinito:
Comparatore &differenze (Diff):
2200
Sistema
Associa 7-Zip a:
Tutti gli utenti
2301
Integra 7-Zip nel menu contestuale della shell
Menu contestuale a cascata
Elementi del menu contestuale:
Icone nel menu contestuale
2320
<cartella>
<archivio>
Apri
Estrai i file...
Aggiungi all'archivio...
Verifica l'archivio
Estrai qui
Estrai in {0}
Aggiungi a {0}
Comprimi ed invia per email...
Comprimi in {0} ed invia per email
2400
Cartelle
Cartella di lavoro
Cartella &TEMP di sistema
&Corrente
&Specificata:
&Utilizza solo per dischi rimovibili
Specifica una cartella per i file temporanei.
2500
Impostazioni
Mostra l'elemento ".."
Mostra le icone dei file
Mostra le icone di sistema
Selezione a &riga intera
Mostra &griglia
Click singolo per aprire una voce
Modalit di selezione &alternativa
Utilizza pagine &larghe di memoria
2900
Informazioni
7-Zip  un software libero.\n\nLocalizzazione italiana a cura di:\nTJL73 <http://tjl73.altervista.org/>
3000
Non  possibile allocare la quantit di memoria richiesta
Nessun errore.
Oggetti selezionati: {0}
Impossibile creare la cartella '{0}'
Non  possibile effettuare aggiornamenti su questo archivio.
Impossibile aprire il file '{0}' come archivio.
Impossibile aprire l'archivio cifrato '{0}'. Password errata?
Archivio non supportato
Il file {0}  gi presente
Il file '{0}'  stato modificato.\nVuoi aggiornare l'archivio?
Impossibile aggiornare il file\n'{0}'
Impossibile avviare l'editor.
Il file sembra essere un virus (contiene molti spazi nel nome).
L'operazione non pu essere richiamata da una cartella con percorso lungo.
Devi selezionare un file
Devi selezionare almeno un file
Troppi elementi
Impossibile aprire il file come archivio {0}
Il file  aperto come archivio {0}
L'archivio  aperto con offset
3300
Estrazione in corso
Compressione in corso
Verifica archivio
Apertura in corso...
Scansione...
Rimozione
3320
Aggiunta
Aggiornamento
Analisi
Replica
Ripacchettizzazione
Salto
Eliminazione
Creazione intestazione
3400
Estrai
E&strai in:
Specifica una cartella in cui estrarre i file.
3410
Struttura delle cartelle:
Percorsi completi
Nessun percorso
Percorsi assoluti
Percorsi relativi
3420
Sovrascrittura:
Chiedi prima di sovrascrivere
Sovrascrivi senza chiedere
Non sovrascrivere i file esistenti
Rinomina automaticamente
Rinomina autom. i file esistenti
3430
Elimina la duplicazione della radice
Ripristina sicurezza dei file
3500
Conferma la sovrascrittura del file
File gi esistente nella cartella di destinazione.
Vuoi sostituire il file esistente
con questo?
{0} byte
&Rinomina automaticamente
3700
Metodo di compressione non supportato per '{0}'.
Errore nei dati in '{0}'. Il file  danneggiato.
CRC non corretto in '{0}'. Il file  danneggiato.
Errore nel file cifrato '{0}'. Password errata?
CRC errato nel file cifrato '{0}'. Password errata?
3710
Password errata?
3721
Metodo di compressione non supportata
Errore dei dati
CRC errato
Dati non disponibili
Fine dei dati inattesa
Sono presenti dati oltre la fine del blocco utile
Non  un archivio
Errore intestazioni
Password errata
3763
Inizio dell'archivio non disponibile
Inizio dell'archivio non confermato
	
	
	
Funzionalit non supportata
3800
Inserisci password
&Inserisci password:
&Reinserisci password:
Mostra pass&word
Password differenti
Per la password, utilizzare solo lettere ASCII, numeri e caratteri speciali (!, #, $, ...)
La password  troppo lunga
Password
3900
Tempo trascorso:
Tempo rimanente:
Dimensione totale:
Velocit:
Elaborato:
Rapporto compressione:
Errori:
Archivi:
4000
Aggiungi all'archivio
Nome &archivio:
Modalit a&ggiornamento:
&Formato dell'archivio:
&Livello di compressione:
&Metodo di compressione:
Dimensione &Dizionario:
Dimensioni &Parola:
Dimensione del &blocco solido:
N&umero di flussi (thread) CPU:
Parametri &opzionali:
Opzioni
Crea archivio auto-&estraente
Comprimi file condivisi
Cifratura
Metodo &cifratura:
Cifra anche il &nome dei file
Quantit memoria per compressione:
Quantit memoria per decompressione:
Elimina i file dopo la compressione
4040
Memorizza collegamenti simbolici
Memorizza collegamenti statici
Memorizza flussi dati alternati
Memorizza sicurezza dei file
4050
Nessuna
Velocissima
Veloce
Normale
Massima
Ultra
4060
Aggiungi e sostituisci i file
Aggiorna e aggiungi i file
Aggiorna i file esistenti
Sincronizza i file
4070
Sfoglia
Tutti i file
Non-solido
Solido
6000
Copia
Sposta
Copia in:
Sposta in:
Copia in corso...
Spostamento in corso...
Rinomina in corso...
Selezionare la cartella di destinazione.
Operazione non supportata per questa cartella.
Errore nella rinomina del file o cartella
Conferma copia
Sei sicuro di voler copiare questi file nell'archivio
6100
Conferma l'eliminazione del file
Conferma l'eliminazione della cartella
Conferma l'eliminazione di pi elementi
Sei certo di voler eliminare '{0}'?
Sei certo di voler eliminare la cartella '{0}' e tutto il suo contenuto?
Sei certo di voler eliminare questi {0} elementi?
Eliminazione in corso...
Errore nell'eliminazione del file o della cartella
Impossibile spostare un file con percorso lungo nel Cestino
6300
Crea cartella
Crea file
Nome cartella:
Nome file:
Nuova cartella
Nuovo file
Errore nella creazione della cartella
Errore nella creazione del file
6400
Commento
&Commento:
Seleziona
Deseleziona
Filtro:
6600
Propriet
Cronologia
Messaggi di diagnostica
Messaggio
7100
Computer
Rete
Documenti
Sistema
7200
Aggiungi
Estrai
Verifica
Copia
Sposta
Elimina
Propriet
7300
Dividi file
&Dividi in:
Di&vidi in pi file (dimensione in byte):
Dividi in...
Conferma divisione
Sicuro di voler dividere l'archivio in {0} porzioni?
La dimensione di ciascuna porzione deve essere pi piccola della dimensione totale dell'archivio originale
Dimensione non corretta
Dimensione specificata: {0} byte.\nSicuro di voler dividere l'archivio in questo modo?
7400
Unisci i file
&Unisci in:
Unisci...
Seleziona solo la prima parte del file diviso
Impossibile riconoscere il file come archivio diviso
Impossibile trovare pi di una parte dell'archivio diviso
7500
Calcolo del checksum...
Informazioni sul checksum
CRC checksum sui dati:
CRC checksum su dati e nomi:
7600
Benchmark
Utilizzo memoria:
Compressione in corso
Decompressione in corso
Valutazione
Valutazione totale
Attuale
Risultante
Utilizzo CPU
Stima / Utilizzo
Passaggi:
7700
Collegamento
Collega
Origine collegamento:
Destinazione collegamento:
7710
Tipo di collegamento
Collegamento statico
Collegamento simbolico al file
Collegamento simbolico alla cartella
Giunzione cartella
;!@Lang2@!UTF-8!
;       : Komuro, Mick, 2chBBS-software
;       : Crus Mitsuaki
;  9.07 : Stepanushkin Dmitry
;  9.23 : 2011-06-22 : Stepanushkin Dmitry, nabeshin
;  9.33 : 2014-06-17 : Stepanushkin Dmitry
; 15.00 : 2015-04-30 : Stepanushkin Dmitry
;
;
;
;
;
0
7-Zip
Japanese

401
OK




(&Y)
(&N)
(&C)


(&C)
440
 (&A)
 (&L)


(&B)
(&F)
(&P)


500
(&F)
(&E)
(&V)
(&A)
(&T)
(&H)
540
(&O)
7-Zip(&I)
(&U)
(&V)
(&E)
(&M)
(&C)...
(&M)...
(&D)
(&S)...
(&B)...
(&R)
(&N)




(&X)

(&A)
600
(&A)

(&I)
...
...


700
(&G)
(&M)
(&L)
(&D)
730


&2
(&T)

1
...
(&R)

750




800
(&A)

900
(&O)...
(&B)
960
(&C)...
7-Zip(&A)...
1003




















OS

















64

CPU





ID












NT




























i


2100




(&E)
diff(&D)
2200

7-Zip

2301
7-Zip
7-Zip


2320
<>
<>

...
...


{0}
{0}
...
{0}
2400

(&W)
(&S)
(&C)
(&P)


2500

'..'


(&F)
(&G)

(&A)
(&L)
2900
7-Zip
7-Zip
3000


{0}
'{0}'

'{0}'
'{0}'

{0}
'{0}'\n
\n'{0}'



1
1

{0}
{0}

3300



...
...

3320








3400

(&X)

3410





3420






3430


3500




{0}
(&U)
3700
'{0}'
'{0}'
'{0}'CRC
'{0}'
'{0}'CRC
3710

3721


CRC






3763






3800



(&S)

(!, #, $, ...)


3900








4000

(&A)
(&U)
(&F)
(&L)
(&M)
(&D)
(&W)

CPU
(&P)

(&X)



(&N)



4040




4050






4060




4070




6000




...
...
...





6100



'{0}'
'{0}'
{0}
...


6300








6400

(&C)



6600




7100




7200







7300

(&S)
(&V)
...

{0}


{0}\n
7400

(&C)
...



7500
...

CRC
CRC
7600








CPU
 / 

7700




7710





;!@Lang2@!UTF-8!
;  9.23 : 2011-09-25 : Translated by Giorgi Maghlakelidze, original translation by Dimitri Gogelia, 
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Georgian

401
OK




&
&
&


&
440
 &
 &


&
& 
&
&
   ?
500
&
&
&
&
&
&
540
&
 &
 &
&
&
&
& ...
&...
&
& ...
& ...
&
&
  
Diff
 
 
&
600
& 
 
 
...
 ...
  
   
700
& 
& 
&
&
730

 
&2 
& 
  
 
 ...
&
750
 
 
 
 
800
&   

900
&...
& 
960
...
7-Zip- ...
1003





 







 
 

CRC




 





 










64 
Big-endian
CPU
 
 
 

 
ID
 
 
 



 
 
 

 

2100


:

:
&Diff:
2200

 7-Zip-:
2301
7-Zip-    
  
  :
2320
<>
<>
 
 ...
 ...
 
 
 {0}-
{0}- 
   ...
{0}-    
2400

& 
&  
&
&:
   
   .
2500

".."  
   
  
 & 
 & 
   
 & 
&   
2900
7-Zip- 
7-Zip     .
3000
    
  
 {0} 
  '{0}'  
     .
'{0}'     
'{0}'     .  ?
    
 '{0}'  
 '{0}' .\n   ?
 \n'{0}'- 
  .
    (     ).
 -   
   
     
  
3300
 
 
 
 ...
 ...
3400

&:
   .
3410

 
 
3420

 
  
  
-
  -
3500
  
    .
   
 ?
{0} 
&-
3700
   '{0}'-.
  '{0}'-.  .
CRC-  '{0}'-.  .
    '{0}'.  ?
CRC    '{0}'.  ?
3800
 
 :
 :
 &
  
    ,     (!, #, $, ...)
  

3900
 :
 :
 :
:
:
 :
:
:
4000
 
&:
& :
 &:
 &:
 &:
& :
& :
  :
CPU  :
&:

 SF&X 
  

 :
 & 
 :
 :
4050
 





4060
   
   
 
 
4070

 


6000
 

 :
:
 ...
...
...
  .
   .
    
   
    
6100
  
  
   
 ,    '{0}'?
 ,    '{0}'     ?
 ,    {0} ?
...
    
         .
6300
 
 
 :
 :
 
 
  
  
6400

&:

 
:
6600

 
 

7100




7200







7300
 
&:
 &,  ():
...
 
    {0} ?
       
  
  : {0} .\n      ?
7400
 
&:
...
     
 ,      
      
7500
  ...
  
CRC  :
CRC    :
7600
 
 :



 


CPU 
./
:
;!@Lang2@!UTF-8!
;  9.07 : Atabek Murtazaev
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Karakalpak - Latin
Qaraqalpaqsha - Latn
401
OK
Biykar etiw



&Awa
&Yaq
&Jabw
Ja'rdem

&Dawam etiw
440
&Barlg'na awa
Ba&rlg'na yaq
Toqtatw
Qaytadan baslaw
&Artq fong'a
Aldng' &fong'a
&Pauza
Pauza qlng'an
Anq biykar etiwdi qa'leysizbe?
500
&Fayl
&Du'zetiw
&Ko'rinis
&Saylandlar
A's&baplar
&Ja'rdem
540
&Ashw
&shinde ashw
&Srtnda ashw
&Ko'riw
&Du'zetiw
Atn o'&zgertiw
Bul jerge &nusqasn alw...
Bul jerge ko'shiriw...
O'shiriw
&Fayld bo'liw...
Fayllard &biriktiriw...
Sazlawla&r
Kom&mentariy...
Qadag'alaw summas
Diff
Papka jaratw
Fayl jaratw
Sh&g'w
600
Barlg'n &saylaw
Saylawd alp taslaw
Saylawd &teris awdarw
Saylaw...
Saylawd alp taslaw...
Tu'ri boynsha saylaw
Tu'ri boynsha saylawd alp taslaw
700
U'&lken ikonalar
Kishi &ikonalar
&Dizim
&Keste
730
Ta'rtipsiz
Tegis ko'rinis
&2 panel
&A'sbaplar paneli
Derek papkasn ashw
Bir da'reje joqarg'a ko'teriliw
Papkalar tariyx...
&Jan'alaw
750
Arxivator knopkalar paneli
Standart knopkalar paneli
U'lken knopkalar
Knopkalar tekstin ko'rsetiw
800
&Papkan saylandlarg'a qosw
Belgi
900
&Sazlawlar...
&O'nimlilikti tekseriw
960
&Mazmun...
&7-Zip haqqnda...
1003
Jol
At
Ken'eytpe
Papka
Ko'lemi
Qslg'andag' ko'lemi
Attributlar
Jaratlg'an
Ashlg'an
O'zgertilgen
U'ziliksiz
Kommentariy berilgen
Shifrlengen
deyin bo'lingen
keyin bo'lingen
So'zlik
CRC
Tu'ri
Anti
Usl
Basqarwsh OS
Fayl sistemas
Paydalanwsh
Topar
Blok
Kommentariy
Orn
Jol prefiksi
Papkalar
Fayllar
Versiya
Tom
Ko'p toml
Jljw
Siltewler
Bloklar
Tomlar

64-bit
Big-endian
Protsessor
Fizikalq ko'lemi
Baslama ko'lemi
Qadag'alaw summas
Xarakteristika
Virtual adresi
ID
Qsqa at
Jaratwsh bag'darlama
Sektor ko'lemi
Rejim
Siltew
Qa'te
Ulwma ko'lem
Bos orn
Klaster ko'lemi
Belgi
Jergilikli at
Provayder
2100
Sazlawlar
Til
Til:
Redaktor
&Redaktor:
&Diff:
2200
Sistema
To'mendegi fayllard 7-Zip penen baylanstrw:
2301
7-Zip ti qabq kontekst menyuine qosw
Kaskadl kontekst menyu
Kontekst menyu elementleri:
2320
<Papka>
<Arxiv>
Arxivti ashw
Fayllard shg'arp alw...
Arxivke qosw...
Arxivti snaw
Us jerge shg'arw
Mna jerge shg'arw: {0}
Mnag'an qosw: {0}
Qsw ha'm email arqal jiberiw...
Mnag'an qsw: {0} ha'm email arqal jiberiw
2400
Papkalar
&slewshi papka
&Sistemann' waqtnshalq papkas
Ha'zirgi &papka
&Ko'rsetilgen:
Tek alnbal tasg'shlar ushn paydalanw
Waqtnshalq arxiv fayllardn' ornn ko'rsetin'.
2500
Sazlawlar
".." elementti ko'rsetiw
Fayldn' haqyqy ikonalarn ko'rsetiw
Sistema menyuin ko'rsetiw
&Tolq jold saylaw
Tor &szqlarn ko'rsetiw
Elementti bir baswdan ashw
Saylawdn' &alternativ usl
U'lken &yad betlerin paydalanw
2900
7-Zip haqqnda
7-Zip bul biypul bag'darlama
3000
Sistema kerekli bolg'an yad mug'darn ajrata almad
Qa'te tablmad
{0} obekt saylang'an
'{0}' papkasn jaratw iske aspad
Bul arxiv ushn jan'alaw operatsiyalar qollanlmayd.
'{0}' fayln arxiv spatnda ashw iske aspad
Shifrlang'an '{0}' arxivin ashw iske aspad. Parol qa'te emespe?
Qollanbaytug'n arxiv tu'ri
{0} fayl a'lle qashan bar (jaratlg'an)
'{0}' fayl o'zgertilgen.\nOn arxiv ishinde jan'alawd qa'leysizbe?
Mna fayld jan'alaw iske aspad\n'{0}'
Redaktord ashw iske aspad.
Fayl virusqa uqsayd (fayl atnda uzn bos ornlar qollanlg'an).
Operatsiya uzun joll papkadan ju'klene almayd.
Siz bir fayl saylawn'z kerek
Siz bir yamasa onnan ko'p fayllard saylawn'z kerek
Elementler san dm ko'p
3300
Shg'arlmaqta
Qslmaqta
Snaw
Ashlmaqta...
Skanerlenbekte...
3400
Shg'arw
&Bul jerge shg'arw:
Shg'arlatug'n fayllar ushn orn ko'rsetin'.
3410
Jol usl
Tolq jol atlar
Jolsz
3420
U'stinen jazw usl
U'stine jazwdan aldn soraw
Soramastan u'stine jazw
Aldnnan bar fayllard o'tkizip jiberiw
Avtomat ta'rizde qayta at beriw
Aldnnan bar fayllarg'a avtomat ta'rizde qayta at beriw
3500
Fayldn' u'stinen jazwd tastyqlaw
Taynlang'an papka a'lle qashan islengen fayld o'z ishine alg'an.
Siz bar fayld
mna fayl menen almastrwd qa'leysizbe?
{0} bayt
A&vtomat ta'rizde qayta at beriw
3700
'{0}' fayl ushn tans bolmag'an qsw usl.
'{0}' faylnda mag'lwmat qa'tesi tabld. Fayl buzlg'an.
'{0}' faylnda CRC qa'tesi tabld. Fayl buzlg'an.
'{0}' shifrlang'an faylnda mag'lwmat qa'tesi tabld. Parol qa'te emespe?
'{0}' shifrlang'an faylnda CRC qa'tesi tabld. Parol qa'te emespe?
3800
Paroldi kiritiw
Paroldi kiritin':
Paroldi qayta kiritin':
Paroldi &ko'rsetiw
Paroller sa'ykes kelmedi
Parol ushn tek latn a'lipbesi ha'riplerin, sanlar ha'm arnawl simvollard (!, #, $, ...) paydalann'
Parol dm uzn
Parol
3900
O'tken waqt:
Qalg'an waqt:
Tolq ko'lem:
Tezlik:
slengen ko'lem:
Qsw da'rejesi:
Qa'teler:
Arxivler:
4000
Arxivke qosw
&Arxiv:
&Jan'alaw usl:
Arxiv &format:
Qsw &da'rejesi:
Qsw &usl:
&So'zlik ko'lemi:
So'z &ko'lemi:
Blok ko'lemi:
CPU ag'mlar san:
&Parametrler:
Sazlawlar
SF&X arxivin jaratw
Jazw ushn ashlg'an fayllard qsw
Shifrlaw
Shifrlaw usl:
Fayl a&tlarn shifrlaw
Qswg'a arnalg'an yad:
Ajratwg'a arnalg'an yad:
4050
Qswsz
En' tez
Tez
Qa'dimgi
En' joqar
Ultra
4060
Fayllard qosw ha'm almastrw
Fayllard jan'alaw ha'm qosw
Bar fayllard jan'alaw
Fayllard sinxronlastrw
4070
Belgilew
Barlq fayllar
Fayl ko'lemi boynsha
U'ziliksiz
6000
Nusqasn alw
Ko'shiriw
Mna papkag'a nusqasn alw:
Mna papkag'a ko'shiriw:
Nusqa alnbaqta...
Ko'shirilmekte...
Qayta at berilmekte...
Papkan saylan'.
Ko'rsetilgen operatsiya bul papka ushn qollanlmayd.
Fayl yaki papkag'a qayta at beriwde qa'te ju'z berdi
Fayldn' nusqasn alwd tastyqlan'
Siz bul fayllard anq arxivke ko'shiriwdi qa'leysizbe
6100
Fayl o'shiriliwin tastyqlaw
Papka o'shiriliwin tastyqlaw
Fayllar toparnn' o'shiriliwin tastyqlaw
'{0}' degendi anq o'shiriwdi qa'leysizbe?
'{0}' papkas ha'm onn' ishindegilerdi anq o'shiriwdi qa'leysizbe?
Bul obektlerdi ({0} dana) anq o'shiriwdi qa'leysizbe?
O'shirilmekte...
Fayl yaki papkan o'shiriwde qa'te ju'z berdi
Sistema uzn joll fayllard sebetke ko'shire almayd
6300
Papka jaratw
Fayl jaratw
Papka at:
Fayl at:
Jan'a papka
Jan'a fayl
Papkan jaratwda qa'te ju'z berdi
Fayld jaratwda qa'te ju'z berdi
6400
Kommentariy
&Kommentariy:
Saylaw
Saylawd alp taslaw
Maska:
6600
Sazlawlar
Papkalar tariyx
Diagnostik xabarlar
Xabar
7100
Kompyuter
Tarmaq
Hu'jjetler
Sistema
7200
Qosw
Shg'arw
Snaw
Nusqa alw
Ko'shiriw
O'shiriw
Mag'lwmat
7300
Fayld bo'liw
&Mnag'an bo'liw:
Tomlarg'a &bo'liw (baytlarda):
Bo'linbekte...
Bo'liwdi tastyqlan'
Siz fayld {0} bo'lekke anq bo'liwdi qa'leysizbe?
Bo'lek ko'lemi original fayl ko'leminen kishi bolw kerek
Tom ko'lemi natuwr berilgen
Tomnn' ko'rsetilgen ko'lemi: {0} bayt.\nArxivti bunday tomlarg'a anq bo'liwdi qa'leysizbe?
7400
Fayllard biriktiriw
&Mnag'an biriktiriw:
Biriktirilmekte...
Bo'lingen fayldn' tek birinshi bo'legin saylaw kerek
Fayl bo'lingen fayldn' bo'legi retinde tanlmad
Bo'lingen fayldn' birden ko'p bo'legi tablmad
7500
Qadag'alaw summasn esaplaw...
Qadag'alaw summas mag'lwmat
Mag'lwmatlar ushn CRC qadag'alaw summas:
Mag'lwmatlar ha'm atamalar ushn CRC qadag'alaw summas:
7600
O'nimlilikti tekseriw
Yad ko'lemi:
Qsw
Ajratw
Reyting
Ulwma reyting
Ha'zirgi
Ja'mi
Awrlq
Reyting / Awr.
O'tkenler:
;!@Lang2@!UTF-8!
;  9.07 : Arslan Beisenov, Arman Beisenov
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Kazakh

401





&
&
&


&
440
 &
 &

  
&
& 
&

   ?
500
&
&
&
&
&
&
540
&
 &
 

&
 
&...
&...
&
 ...
 ...

&...
 
Diff
& 
 

600
 
 
& 
...
 ...
 - 
 -  
700
& 
&. 

&
730

 
&2 
& 
  
   
 ...

750
  
  
 
 
800
   

900
...
 
960
&...
...
1003













 
 

CRC




 










 





64-bit
Big-endian

 
 
 

 -
ID
 

 





 

 

2100


:

&:
&Diff:
2200

7-Zip  :
2301
   7-Zip 
  
  :
2320
<>
<>
 
 
 ...

 
{0}  
{0}  
 - ...
{0}  , - 
2400

& 
&  
&
&:
    
   .
2500

".."  
   
  
  
 
  
  
   
2900
7-Zip 
7-Zip -   .
3000
  
  
 : {0}
'{0}'    
    .
'{0}'      
 '{0}'    .    ?
  
{0}   
'{0}'  .\n    ?
\n'{0}'    
   
   (     ).
    
    
      
  
3300



...
...
3400

& :
   .
3410

& 
&
3420
 
&
&
 &
  .
  .  
3500
  
    .
 
  ?
{0} 
  
3700
'{0}'     .
'{0}'  .  .
'{0}' CRC .  .
 '{0}'   .    ?
 '{0}'  CR .    ?
3800
 
& :
& :
& 
  
    ,     (!, #, $, ...)
  
&
3900
:
:
:
.:
:
 :
:
:
4000
 
&:
& :
& :
& :
& :
 &:
 &:
 :
 :
&:
&
SF&X- 
    

 :
&  
  :
  :
4050




 

4060
, 
, 


4070

 
  -

6000


 :
 :
...
...
 ...
 
   .
      
  
     
6100
  
  
   
"{0}"    ?
"{0}"       ?
({0} )    ?
...
    
      
6300
 
 
 :
 :
 
 
  
    
6400

&:


:
6600

 


7100




7200







7300
 
&:
  ():
...
 
 {0}    ?
       
   
  : {0} .\n    ?
7400
 
& :
...
     
    
     
7500
  ...
 
  CRC  :
    CRC  :
7600
 
 :



 



 / .
:
;!@Lang2@!UTF-8!
;       : ZannyLim ()
;       : bzImage
;  4.52 : Hyeong il  Kim (kurt Sawyer)
;  9.07 : Dong-yoon Han ()
; 15.12 : Winterscenery (Ji-yong BAE)
;
;
;
;
;
;
0
7-Zip
Korean

401





(&Y)
(&N)
(&C)


(&C)
440
 (&A)
 (&L)

 
 (&B)
 (&F)
(&P)
 
 ?
500
(&F)
(&E)
(&V)
(&A)
(&T)
(&H)
540
(&O)
 (&I)
 (&U)
 (&V)
(&E)
 (&M)
(&C)...
(&M)...
(&D)
 (&S)
 (&B)
(&R)
(&N)
 
 
 
 
(&X)
...
  (&A)
600
 (&A)
  
  (&I)
...
 ...
  
   
700
 (&G)
 (&M)
(&L)
(&S)
730
 
 
2 (&2)
 (&T)
  
 
 ...
 (&R)
  
750
  
  
 
  
800
 (&A)

900
(&P)...
(&B)...
960
 (&C)...
7-Zip (&A)...
1003





 

 
 
 



 
 

CRC


 
 OS
 





 










64-bit
Big-endian
CPU
 
 


 
ID
 
 
 



 
 
 

 

NT 
  
Aux
Deleted
Is Tree


 





  
   
 
   
  
 
SubType
Short Comment
 



Tail Size
Embedded Stub Size
Link
Hard Link
iNode

 
2100


:

 (&E):
 (&D):
2200

7-Zip  :
 
2301
7-Zip   
   
  :
   
2320
<>
<>
 
 ...
 ...
 
  
{0} 
{0} 
  
{0}   
2400

 (&W)
  (&S)
 (&C)
 (&S):
  
      .
2500

".."  
   
  
  (&F)
 (&G)
    
  
   
2900
7-Zip 
7-Zip   .
3000
      
 
{0}  
'{0}'    
     .
 '{0}'()    
  '{0}'()   .  ?
   
{0}   
 '{0}' .\n  ?
'{0}'     .
   .
    (    ).
       .
    
      
  
Can not open the file as {0} archive
The file is open as {0} archive
The archive is open with offset
3300
  
 
 
 ...
 ...
 
3320
 
 
 
 
  
 
 
  
3400
 
 (&X):
    .
3410
 
 
 
 
 
3420
 
  
  
  
  
   
3430
   
   
3500
  
    .
 
 ?
{0} 
  (&U)
3700
'{0}'    .
'{0}'   .  .
'{0}' CRC  .  .
  '{0}'   .  ?
  '{0}' CRC  .  ?
3710
  ?
3721
   
 
CRC 
  
 
There are some data after the end of the payload data
  .
 
 .
3763
Unavailable start of archive
Unconfirmed start of archive



  
3800
 
 :
  :
 (&S)
  
 ,     (!, #, $, ...) 
  

3900
 :
 :
 :
:
:
 :
:
:
4000
 
(&A):
 (&U):
 (&F):
 (&L):
 (&M):
 (&D):
(word) (&W):
  :
CPU  :
(&P):

(SFX)  (&X)
  

 :
  (&N)
  :
   :
    
4040
  
  
   
   
4050

 



 
4060
  
  
   
  
4070

 
  

6000


 :
 :
 ...
 ...
  ...
  .
  .
     
  
   ?
6100
  
  
   
'{0}'() ?
 '{0}'    ?
 {0}  ?
 ...
    
       
6300
 
 
 :
 :
 
 
  
  
6400

(&C):

 
:
6600

 
 

7100




7200

 





7300
 
(&S):
 , (&V):
 ...
 
 {0}   ?
     .
  .
  : {0} .\n    ?
7400
 
(&B):
  ...
  
      
       
7500
 ...
 
 CRC :
  CRC :
7600

 :
 
  

 


CPU 
 / 
:
7700

 
:
:
7710
 
 
  
  
 
;!@Lang2@!UTF-8!
;       : Ara Bakhtiar
;  4.66 : Ara Qadir : http://www.chawg.org
;
;
;
;
;
;
;
;
;
0
7-Zip
Kurdish - Sorani

401





&
&
&


&
440
  &
  &


&
&
&

  
500
&
&
&
&
&
&
540
&
 & 
  &
&
&
&
& ...
& ...
&
& ...
&  ...
&
&
 checksum

 
 
&
600
  
  
% 
 ...
 ...
    
   
700
 &
 &
&
&
730

  
&2 
& 
  
   
 ...
&
750
  
  
 
  
800
&    

900
&
& 
960
&...
& 7-Zip...
1003





 





  

 
 

CRC



 
 





  Prefix




 
Offset




-
Big-endian
CPU
 
 


 







 
 
 

 

2100


:

&:

2200

7-Zip   :
2301
7-Zip    
    
  :
2320
<>
<>
 
 
  
 
 
  {0}
  {0}
   ...
  {0}     
2400

 &
  &
&
&:
          (removable disk)
      .
2500

 ".." 
   
  
  &
  &grid 

  &/ 
  & 
2900
7-Zip 
7-Zip  .        7-Zip.
3000
       
  
{0}  
  '{0}' .
      .
  '{0}'   .
   '{0}' .   
   
 {0}  
 '{0}' .     
  \n'{0}' 
  .
    (    ).
         .
  
    
(item)  
3300
 
 ...

...
 ...
3400

& :
     
3410
 
  
  
3420
  
   
   
  
 
   
3500
   
      .
   
  
{0} 
 &
3700
     '{0}'.
 '{0}' .  .
CRC  .  .
     '{0}'.   
CRC     '{0}'.   
3800
 :
 :
 :
& 
   
       ($ % #)   
  

3900
. :
 :
 :
:
:
 :
:
:
4000
  
&:
& :
& :
& :
& :
 &:
 &:
  :
  CPU:
&:

  SF&X
  

 
&   (encrypt)
    :
     :
4050






4060
   
   
  
  Synchronize
4070
/ Browse
 
-

6000


 :
 :
 ...
 ...
 ...
   .
   
       .
   
     
6100
   
   
    
   '{0}'
    '{0}'   
    {0} 
 ...
      
         
6300
 
 
 :
 :
 
 
    
    
6400

&:
 
 
:
6600

 
 / 

7100




7200







7300
 
&  :
   &  :
 ...
  
    {0}   
          
  
  : {0} .\n      
7400
 
%  :
 ...
    
       
       
7500
 ...
 
 CRC  :
 CRC    :
7600
 
  :

 

 


CPU  
  / 
:
;!@Lang2@!UTF-8!
;  4.37 : Rizoy Xerz
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Kurdish
Kurd
401
Temam
Betal



&Er
&Na
Bi&gire
Alkar

Bi&domne
440
&Ji Bo Hemy Er
Ji &Bo Hemy Na
Raweste
Dsa Destpke
L%i Pit
Li &P
&Rawestne
Rawestiya -
Ma bila betal bibe?
500
&Dosya
&Bipergalne
&Nan Bide
Bi&jare
&Amr
A&lkar
540
&Veke
&Di Panel De Veke
Di &Pacey De Veke
&Nan Bide
&Sererast bike
&Navek N Bid
&Ji Ber Bigire
B&ar Bike
J B&ibe
Pare Bi&ke...
Bike &Yek...
&Taybet
Da&xuyan
checksum heseb bike

Pe&ldankeke N
Do&siyeke N
De&rkeve
600
&Hemy hilbijre
He&m hilijartin rake
Be&revaj w hilbijre
&Hilbijre...
Hilbijarti&n Rake...
V curey hilbijre
Hilbijartina cure rake
700
&Dawrn Mezin
D&awrn Bik
&Lste
&Hragah
730
B Dor
xuyakirina sade
&2 Panelan veke
Da&rik amran
Peldanka Kok Veke
Astek Berjor
Droka Peldank...
&N Bike
750
Darik arv
Darik standart
Bikojkn mezin
Bila nivsa bikojkan bixuye
800
Pe&ldanka derbasdar veke
Cih
900
&Vebijrk...
&Pvana alakbn
960
&Naverok...
D&er bar 7-Zip de...
1003
R
Nav
Cure
Peldank
Mezinah
Mezinahiya di arv de
Taybetiyn xweser
by
Gihat
Guhert
Hik
Daxuyankir
frekir
Parey bor
Parey pitre
Ferheng
CRC
Cure
Dij
Away idandin
Platform
Pergala Dosiy
Bikarhner
Kom
Stn
Daxuyan
Cih
Path Prefix
























ewt
Hem Mezinah
Cih Vala
Mezinahiya telpik
Etket
Nav Herm
Derfetkar
2100
Vebijrk
Ziman
Ziman:
Per&galker
Pergalker De&q:

2200
Pergal
Bi 7-Zip re tkildar bike:
2301
Bila di pekn naverok de 7-Zip bixuye
Peka naverok ya slav
Hmann peeka naverok:
2320
<Peldank>
<Arv>
Arv veke
Dosiyan derxe...
Bike Arv...
Arv bihne
Valake vir
Peldanka {0} derxe
Wek {0} bike arv
Biidne  bine...
Wek {0} biidne  bine
2400
Peldank
Peldanka &Xebat
&Peldanka TEMP a Pergal
P&eldanka Derbasdar
Pe&ldanka Navbor:
Bi ten ji bo ajokarn derket bi kar bne
Ji bo dosiyn demdem yn arv cih bel bike.
2500
Mheng
Bila hmana ".." xuya bike
Bila dawrn dosiyn rast xuya bikin
Bila peka pergal xuya bike
Bila &hem rzik bibore
Bila &xzn tabloy xuya bike

&Kipa hilbijartina alternatf
bra berfireh bikar bne
2900
Der bar 7-Zip de
7-Zip nivsbariyeke azad e. L, tu dikar wek tomarkirin desteka pxistina 7-zip bib.
3000

ewt nn e.
{0} heb hman hilbijart ne
Peldanka '{0}' nay kirin
Tu nikar v arv rojane bik.




Dosiya '{0}' hatiye guhartin.\nMa bila di arv bte rojanekirin?
Dosiya '{0}' nehate rojanekirin
Pergalker deq nehate destpkirin.




Hman zde ne
3300
Tn derxistin
tn idandin
t handin
vedibe...
T raguhestin
3400
Derxe
&Cih D Derkev:
Ji bo dosya derkevin cihek bel bike.
3410
Nav R
Nav tevah yn r
Bila navn r tune bin
3420
Dosiyn hey
Ji bo li ser binivse bipirse
B pirs li ser binivse
Derxistin
Navek n li yn di arv de bike
Navek n li yn hey bike
3500
Rewla Lisernivsandin
Di dosiya armanckir de bi v nav dosiyek heye. Bila li ser bte nivsn?
Dosiya hey:
Dosiya t derxistin:
{0} bayt
Na&vek n l bike
3700
Ji bo '{0}' away idandin nehate nasn.
'{0}' xerabe ye. (ewtiya daney)
'{0}' xerabe ye. (ewtiya CRC)


3800
Tketina frey
frey binivse:

Bi&la fre bixuye



fre
3900
Dema bor:
Dema may:
Mezinah:
Lez:


ewt:

4000
Bike Arv
&Arv:
A&way rojanekirin:
Awa&y arv:
A&sta idandin:
Away i&dandin:
Me&zinahiya ferheng:
M&ezinahiya bjey:


&Parametre:
Vebijrk
Bila ew bixwe derxe (SFX)



Navn dosiy bike fre
Bikaranna br (idandin):
Bikaranna br (Vekirin):
4050
By idandin
Leztirn
Bi Lez
Asay
Her Pir
Ultra
4060
Dosiyan tx, yn hey derxe
Dosiyan tx, yn kevin rojane bike
Bi ten yn kevin rojane bike
Dosiyan bike wek hev
4070
Bibne
Hem dosya


6000
Ji Ber Bigire
Bar Bike
Cih D Were Jibergirtin:
Cih D Were Barkirin:
t jibergirtin...
t barkirin...
navek n t lkirin...

Kirin ne pkan e.
ewtiya Navlkirin
Erkirina Jibergirtin
Ma bila dos ji bo arv bn jibergirtin
6100
Erkirina jbirina dosiy
Erkirina jbirina peldank
Erkirina jbirina gelek dosiyan
Ma bila dosiya '{0}' bte jbirin?
Ma bila peldanka  '{0}'  yn t de bn jbirin?
Ma bila hmana {0} bte jbirin?
t jbirin...
ewtiya Jbirin

6300
Peldankeke n
Dosiyeke N
Nav peldank:
Nav Dosiy:
Peldankeke N
Dosiyeke N
ewtiya kirina peldank
ewtiya kirina Dosiy
6400
Daxuyan
&Daxuyan:
Hilbijre
Hilbijartin rake
Derbirna hilbijartin:
6600

Rabirdya Peldank
Peyamn haydariy
Peyam
7100
Komputer
Tor

Pergal
7200
Bike Arv
Derxe
Bihne
Ji Ber Bigire
Bar Bike
J Bibe
Agah
7300
Bike Pare
Di &v peldank de pare bike:
Wek Bayt/&cilt bike pare:
t parekirin...





7400
Bike Yek
Di v &peldank de bike yek:
t yekirin...



7500
Hesab sererastkir...
Agahiyn hesab sererast
CRC hesab sererast bo data:
CRC hesab sererast bo data  nav:
7600
alakiya komputer
Bikaranna bir:
idandin
Vekirin
Puan
bi gulover puanan
Car
Encam


Serkeft:
;!@Lang2@!UTF-8!
;  9.20 : Kalil uulu Bolot
;
;
;
;
;
;
;
;
;
;
0
7-Zip
Kyrgyz

401
OK




&
&
&


&
440
 &
 & 

 
&
& 
&

      ?
500
&
&
&
&
&
&
540
&
& 
& 

&
& 
& ...
&  ...
&
& ...
& ...
&
&
 
Diff
& 
& 
&
600
 &
 
& &
...
 ...
  
   
700
& 
& 
&
&
730

 
&2 
& 
  
   
 ...
&
750
  
  
 
 
800
 &  
 
900
-...
 
960
&...
 &...
1003













 
 

CRC




 




 











64-bit
Big-endian

 
  
 

 
ID
 

 





 

 

2100
-

:

&:
&Diff:
2200

7-Zip   :
2301
7-Zip    
  
  :
2320
<>
<>
 
 
 ...

  
   {0}
  {0}
   email  ...
  {0}  email  
2400

& 
&  
&
&:
    
    .
2500
-
".."  
   
  
  
 
   
  
   
2900
7-Zip  
7-Zip   .  7-Zip   ,    .
3000
   
  
{0}  
'{0}'     
     .
'{0}'      
      '{0}'. -  ?
   
{0}   
'{0}'  .\n     ?
\n'{0}'     
 ,   
   (     ).
   ,  .
    
     
   
3300
 


...
...
3400

&   :
     .
3410

& 
&
3420
 
& 
&
&
   .
     .
3500
  
    .
  
  ?
{0} 
   .
3700
'{0}'    .
'{0}'  . .
'{0}' CRC . .
'{0}'   .   -?
'{0}'    CRC .   -?
3800
- 
&- :
&- :
&- 
- -  
-      ,   (!, #, $, ...) 
-  
&-
3900
:
:
:
:
:
 :
:
:
4000
 
&:
& :
& :
& :
& :
 &:
 &:
 :
 :
&:
&-
SF&X- 
    

 :
&  
    :
    :
4050




 

4060
  
  


4070

 
 

6000


 :
 :
...
 ...
 ...
 .
    .
     
  
        
6100
  
  
   
 "{0}"     ?
 "{0}"        ?
({0} .)      ?
...
    
       
6300
 
 
 :
 :
 
 