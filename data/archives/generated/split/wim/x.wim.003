ARAM(p + kCmdSize, 2) == 1
              && Get32(p + kCmdSize * 2) == EW_PUSHPOP // Pop $VAR
              && GET_CMD_PARAM(p + kCmdSize * 2, 1) != 0)
          {
            if (IsVarStr(params[0], GET_CMD_PARAM(p + kCmdSize * 2, 0)))
            {
              s += "Exch";
              AddParam(params[0]);
              NewLine();
              Tab(true);
              endCommentIndex = kkk + 3;
            }
          }
          s += "Push";
          AddParam(params[0]);
        }
        break;
      }

      case EW_FINDWINDOW:
      {
        AddParam_Var(params[0]);
        AddParam(params[1]);
        AddOptionalParams(params + 2, 3);
        break;
      }

      case EW_SENDMESSAGE:
      {
        // SendMessage: 6 [output, hwnd, msg, wparam, lparam, [wparamstring?1:0 | lparamstring?2:0 | timeout<<2]
        AddParam(params[1]);

        const char *w = NULL;
        AString t;
        ReadString2(t, params[2]);
        UInt32 wm;
        if (StringToUInt32(t, wm))
        {
          switch (wm)
          {
            case 0x0C: w = "SETTEXT"; break;
            case 0x10: w = "CLOSE"; break;
            case 0x30: w = "SETFONT"; break;
          }
        }
        if (w)
        {
          s += " ${WM_";
          s += w;
          s += '}';
        }
        else
          SpaceQuStr(t);
        
        UInt32 spec = params[5];
        for (unsigned i = 0; i < 2; i++)
        {
          AString s2;
          if (spec & ((UInt32)1 << i))
            s2 += "STR:";
          ReadString2(s2, params[3 + i]);
          SpaceQuStr(s2);
        }

        if ((Int32)params[0] >= 0)
          AddParam_Var(params[0]);

        spec >>= 2;
        if (spec != 0)
        {
          s += " /TIMEOUT=";
          Add_UInt(spec);
        }
        break;
      }

      case EW_ISWINDOW:
      {
        AddParam(params[0]);
        Add_GotoVars2(&params[1]);
        break;
      }

      case EW_GETDLGITEM:
      {
        AddParam_Var(params[0]);
        AddParams(params + 1, 2);
        break;
      }
      
      case EW_SETCTLCOLORS:
      {
        AddParam(params[0]);

        UInt32 offset = params[1];
        
        if (_size < bhCtlColors.Offset
           || _size - bhCtlColors.Offset < offset
           || _size - bhCtlColors.Offset - offset < k_CtlColors_Size)
        {
          AddError("bad offset");
          break;
        }

        const Byte *p2 = _data + bhCtlColors.Offset + offset;
        CNsis_CtlColors colors;
        colors.Parse(p2);

        if ((colors.flags & kColorsFlags_BK_SYS) != 0 ||
            (colors.flags & kColorsFlags_TEXT_SYS) != 0)
          s += " /BRANDING";
        
        AString bk;
        bool bkc = false;
        if (colors.bkmode == MY__TRANSPARENT)
          bk += " transparent";
        else if (colors.flags & kColorsFlags_BKB)
        {
          if ((colors.flags & kColorsFlags_BK_SYS) == 0 &&
              (colors.flags & kColorsFlags_BK) != 0)
            bkc = true;
        }
        if ((colors.flags & kColorsFlags_TEXT) != 0 || !bk.IsEmpty() || bkc)
        {
          Space();
          if ((colors.flags & kColorsFlags_TEXT_SYS) != 0 || (colors.flags & kColorsFlags_TEXT) == 0)
            AddQuotes();
          else
            Add_Color(colors.text);
        }
        s += bk;
        if (bkc)
        {
          Space();
          Add_Color(colors.bkc);
        }

        break;
      }

      case EW_SETBRANDINGIMAGE:
      {
        s += " /IMGID=";
        Add_UInt(params[1]);
        if (params[2] == 1)
          s += " /RESIZETOFIT";
        AddParam(params[0]);
        break;
      }

      case EW_CREATEFONT:
      {
        AddParam_Var(params[0]);
        AddParam(params[1]);
        AddOptionalParams(params + 2, 2);
        if (params[4] & 1) s += " /ITALIC";
        if (params[4] & 2) s += " /UNDERLINE";
        if (params[4] & 4) s += " /STRIKE";
        break;
      }

      case EW_SHOWWINDOW:
      {
        AString hw, sw;
        ReadString2(hw, params[0]);
        ReadString2(sw, params[1]);
        if (params[3] != 0)
          s += "EnableWindow";
        else
        {
          UInt32 val;
          bool valDefined = false;
          if (StringToUInt32(sw, val))
          {
            if (val < ARRAY_SIZE(kShowWindow_Commands))
            {
              sw.Empty();
              sw += "${";
              Add_ShowWindow_Cmd_2(sw, val);
              sw += '}';
              valDefined = true;
            }
          }
          bool isHwndParent = IsVarStr(params[0], IsNsis225 ? kVar_HWNDPARENT_225 : kVar_HWNDPARENT);
          if (params[2] != 0)
          {
            if (valDefined && val == 0 && isHwndParent)
            {
              s += "HideWindow";
              break;
            }
          }
          if (valDefined && val == 5 && isHwndParent &&
              kkk + 1 < bh.Num && GetCmd(Get32(p + kCmdSize)) == EW_BRINGTOFRONT)
          {
            s += "  ; ";
          }
          s += "ShowWindow";
        }
        SpaceQuStr(hw);
        SpaceQuStr(sw);
        break;
      }

      case EW_SHELLEXEC:
      {
        AddParams(params, 2);
        if (params[2] != 0 || params[3] != MY__SW_SHOWNORMAL)
        {
          AddParam(params[2]);
          if (params[3] != MY__SW_SHOWNORMAL)
          {
            Space();
            Add_ShowWindow_Cmd(params[3]);
          }
        }
        if (params[5] != 0)
        {
          s += "    ;";
          AddParam(params[5]); // it's tatus text update
        }
        break;
      }

      case EW_EXECUTE:
      {
        if (params[2] != 0)
          s += "Wait";
        AddParam(params[0]);
        if (params[2] != 0)
          if ((Int32)params[1] >= 0)
            AddParam_Var(params[1]);
        break;
      }
      
      case EW_GETFILETIME:
      case EW_GETDLLVERSION:
      {
        AddParam(params[2]);
        AddParam_Var(params[0]);
        AddParam_Var(params[1]);
        break;
      }

      case EW_REGISTERDLL:
      {
        AString func;
        ReadString2(func, params[1]);
        bool printFunc = true;
        // params[4] = 1; for plugin command
        if (params[2] == 0)
        {
          s += "CallInstDLL";
          AddParam(params[0]);
          if (params[3] == 1)
            s += " /NOUNLOAD";
        }
        else
        {
          if (func == "DllUnregisterServer")
          {
            s += "UnRegDLL";
            printFunc = false;
          }
          else
          {
            s += "RegDLL";
            if (func == "DllRegisterServer")
              printFunc = false;
          }
          AddParam(params[0]);
        }
        if (printFunc)
          SpaceQuStr(func);
        break;
      }

      case EW_CREATESHORTCUT:
      {
        unsigned numParams;
        for (numParams = 6; numParams > 2; numParams--)
          if (params[numParams - 1] != 0)
            break;

        UInt32 spec = params[4];
        if (spec & 0x8000) // NSIS 3.0b0
          s += " /NoWorkingDir";

        AddParams(params, numParams > 4 ? 4 : numParams);
        if (numParams <= 4)
          break;

        UInt32 icon = (spec & 0xFF);
        Space();
        if (icon != 0)
          Add_UInt(icon);
        else
          AddQuotes();

        if ((spec >> 8) == 0 && numParams < 6)
          break;
        UInt32 sw = (spec >> 8) & 0x7F;
        Space();
        // NSIS encoder replaces these names:
        if (sw == MY__SW_SHOWMINNOACTIVE)
          sw = MY__SW_SHOWMINIMIZED;
        if (sw == 0)
          AddQuotes();
        else
          Add_ShowWindow_Cmd(sw);
        
        UInt32 modKey = spec >> 24;
        UInt32 key = (spec >> 16) & 0xFF;

        if (modKey == 0 && key == 0)
        {
          if (numParams < 6)
            break;
          Space();
          AddQuotes();
        }
        else
        {
          Space();
          if (modKey & 1) s += "SHIFT|"; // HOTKEYF_SHIFT
          if (modKey & 2) s += "CONTROL|";
          if (modKey & 4) s += "ALT|";
          if (modKey & 8) s += "EXT|";
          
          static const unsigned kMy_VK_F1 = 0x70;
          if (key >= kMy_VK_F1 && key <= kMy_VK_F1 + 23)
          {
            s += 'F';
            Add_UInt(key - kMy_VK_F1 + 1);
          }
          else if (key >= 'A' && key <= 'Z' || key >= '0' && key <= '9')
            s += (char)key;
          else
          {
            s += "Char_";
            Add_UInt(key);
          }
        }
        AddOptionalParam(params[5]); // description
        break;
      }

      case EW_COPYFILES:
      {
        if (params[2] & 0x04) s += " /SILENT"; // FOF_SILENT
        if (params[2] & 0x80) s += " /FILESONLY"; // FOF_FILESONLY
        AddParams(params, 2);
        if (params[3] != 0)
        {
          s += "    ;";
          AddParam(params[3]); // status text update
        }
        break;
      }

      case EW_REBOOT:
      {
        if (params[0] != 0xbadf00d)
          s += " ; Corrupted ???";
        else if (kkk + 1 < bh.Num && GetCmd(Get32(p + kCmdSize)) == EW_QUIT)
          endCommentIndex = kkk + 2;
        break;
      }

      case EW_WRITEINI:
      {
        unsigned numAlwaysParams = 0;
        if (params[0] == 0)  // Section
          s += "FlushINI";
        else if (params[4] != 0)
        {
          s += "WriteINIStr";
          numAlwaysParams = 3;
        }
        else
        {
          s += "DeleteINI";
          s += (params[1] == 0) ? "Sec" : "Str";
          numAlwaysParams = 1;
        }
        AddParam(params[3]); // filename
        // Section, EntryName, Value
        AddParams(params, numAlwaysParams);
        AddOptionalParams(params + numAlwaysParams, 3 - numAlwaysParams);
        break;
      }

      case EW_READINISTR:
      {
        AddParam_Var(params[0]);
        AddParam(params[3]); // FileName
        AddParams(params +1, 2); // Section, EntryName
        break;
      }

      case EW_DELREG:
      {
        // NSIS 2.00 used another scheme!
        
        if (params[4] == 0)
          s += "Value";
        else
        {
          s += "Key";
          if (params[4] & 2)
            s += " /ifempty";
        }
        AddRegRoot(params[1]);
        AddParam(params[2]);
        AddOptionalParam(params[3]);
        break;
      }

      case EW_WRITEREG:
      {
        const char *s2 = 0;
        switch (params[4])
        {
          case 1: s2 = "Str"; break;
          case 2: s2 = "ExpandStr"; break; // maybe unused
          case 3: s2 = "Bin"; break;
          case 4: s2 = "DWORD"; break;
          default:
            s += '?';
            Add_UInt(params[4]);
        }
        if (params[4] == 1 && params[5] == 2)
          s2 = "ExpandStr";
        if (s2)
          s += s2;
        AddRegRoot(params[0]);
        AddParams(params + 1, 2); // keyName, valueName
        if (params[4] != 3)
          AddParam(params[3]); // value
        else
        {
          // Binary data.
          Space();
          UInt32 offset = params[3];
          bool isSupported = false;
          if (AfterHeaderSize >= 4
              && bhData.Offset <= AfterHeaderSize - 4
              && offset <= AfterHeaderSize - 4 - bhData.Offset)
          {
            // we support it for solid archives.
            const Byte *p2 = _afterHeader + bhData.Offset + offset;
            UInt32 size = Get32(p2);
            if (size <= AfterHeaderSize - 4 - bhData.Offset - offset)
            {
              for (UInt32 i = 0; i < size; i++)
              {
                Byte b = (p2 + 4)[i];
                unsigned t;
                t = (b >> 4); s += (char)(((t < 10) ? ('0' + t) : ('A' + (t - 10))));
                t = (b & 15); s += (char)(((t < 10) ? ('0' + t) : ('A' + (t - 10))));
              }
              isSupported = true;
            }
          }
          if (!isSupported)
          {
            // we must read from file here;
            s += "data[";
            Add_UInt(offset);
            s += " ... ]";
            s += "  ; !!! Unsupported";
          }
        }
        break;
      }

      case EW_READREGSTR:
      {
        s += (params[4] == 1) ? "DWORD" : "Str";
        AddParam_Var(params[0]);
        AddRegRoot(params[1]);
        AddParams(params + 2, 2);
        break;
      }

      case EW_REGENUM:
      {
        s += (params[4] != 0) ? "Key" : "Value";
        AddParam_Var(params[0]);
        AddRegRoot(params[1]);
        AddParams(params + 2, 2);
        break;
      }

      case EW_FCLOSE:
      case EW_FINDCLOSE:
      {
        AddParam_Var(params[0]);
        break;
      }

      case EW_FOPEN:
      {
        AddParam_Var(params[0]);
        AddParam(params[3]);
        UInt32 acc = params[1]; // dwDesiredAccess
        UInt32 creat = params[2]; // dwCreationDisposition
        if (acc == 0 && creat == 0)
          break;
        char cc = 0;
        if (acc == MY__GENERIC_READ && creat == OPEN_EXISTING)
          cc = 'r';
        else if (creat == CREATE_ALWAYS && acc == MY__GENERIC_WRITE)
          cc = 'w';
        else if (creat == OPEN_ALWAYS && (acc == (MY__GENERIC_WRITE | MY__GENERIC_READ)))
          cc = 'a';
        // cc = 0;
        if (cc != 0)
        {
          Space();
          s += cc;
          break;
        }

        if (acc & MY__GENERIC_READ)     s += " GENERIC_READ";
        if (acc & MY__GENERIC_WRITE)    s += " GENERIC_WRITE";
        if (acc & MY__GENERIC_EXECUTE)  s += " GENERIC_EXECUTE";
        if (acc & MY__GENERIC_ALL)      s += " GENERIC_ALL";
        
        const char *s2 = NULL;
        switch (creat)
        {
          case MY__CREATE_NEW:        s2 = "CREATE_NEW"; break;
          case MY__CREATE_ALWAYS:     s2 = "CREATE_ALWAYS"; break;
          case MY__OPEN_EXISTING:     s2 = "OPEN_EXISTING"; break;
          case MY__OPEN_ALWAYS:       s2 = "OPEN_ALWAYS"; break;
          case MY__TRUNCATE_EXISTING: s2 = "TRUNCATE_EXISTING"; break;
        }
        Space();
        if (s2)
          s += s2;
        else
          Add_UInt(creat);
        break;
      }

      case EW_FPUTS:
      case EW_FPUTWS:
      {
        if (commandId == EW_FPUTWS)
          s += (params[2] == 0) ? "UTF16LE" : "Word";
        else if (params[2] != 0)
          s += "Byte";
        AddParam_Var(params[0]);
        AddParam(params[1]);
        break;
      }

      case EW_FGETS:
      case EW_FGETWS:
      {
        if (commandId == EW_FPUTWS)
          s += (params[3] == 0) ? "UTF16LE" : "Word";
        if (params[3] != 0)
          s += "Byte";
        AddParam_Var(params[0]);
        AddParam_Var(params[1]);
        AString maxLenStr;
        ReadString2(maxLenStr, params[2]);
        UInt32 maxLen;
        if (StringToUInt32(maxLenStr, maxLen))
        {
          if (maxLen == 1 && params[3] != 0)
            break;
          if (maxLen == 1023 && params[3] == 0) // NSIS_MAX_STRLEN - 1; can be other value!!
            break;
        }
        SpaceQuStr(maxLenStr);
        break;
      }

      case EW_FSEEK:
      {
        AddParam_Var(params[0]);
        AddParam(params[2]);
        if (params[3] == 1) s += " CUR"; // FILE_CURRENT
        if (params[3] == 2) s += " END"; // FILE_END
        if ((Int32)params[1] >= 0)
        {
          if (params[3] == 0) s += " SET"; // FILE_BEGIN
          AddParam_Var(params[1]);
        }
        break;
      }

      case EW_FINDNEXT:
      {
        AddParam_Var(params[1]);
        AddParam_Var(params[0]);
        break;
      }

      case EW_FINDFIRST:
      {
        AddParam_Var(params[1]);
        AddParam_Var(params[0]);
        AddParam(params[2]);
        break;
      }

      case EW_LOG:
      {
        if (params[0] != 0)
        {
          s += "Set ";
          s += (params[1] == 0) ? "off" : "on";
        }
        else
        {
          s += "Text";
          AddParam(params[1]);
        }
      }

      case EW_SECTIONSET:
      {
        if ((Int32)params[2] >= 0)
        {
          s += "Get";
          Add_SectOp(params[2]);
          AddParam(params[0]);
          AddParam_Var(params[1]);
        }
        else
        {
          s += "Set";
          UInt32 t = -(Int32)params[2] - 1;
          Add_SectOp(t);
          AddParam(params[0]);
          AddParam(params[t == 0 ? 4 : 1]);

          // params[3] != 0 means call SectionFlagsChanged in installer
          // used by SECTIONSETFLAGS command
        }
        break;
      }

      case EW_INSTTYPESET:
      {
        int numQwParams = 0;
        const char *s2;
        if (params[3] == 0)
        {
          if (params[2] == 0)
          {
            s2 = "InstTypeGetText";
            numQwParams = 1;
          }
          else
          {
            s2 = "InstTypeSetText";
            numQwParams = 2;
          }
        }
        else
        {
          if (params[2] == 0)
            s2 = "GetCurInstType";
          else
          {
            s2 = "SetCurInstType";
            numQwParams = 1;
          }
        }
        s += s2;
        AddParams(params, numQwParams);
        if (params[2] == 0)
          AddParam_Var(params[1]);
        break;
      }
      
      case EW_LOCKWINDOW:
      {
        s += (params[0] == 0) ? " on" : " off";
        break;
      }

      case EW_FINDPROC:
      {
        AddParam_Var(params[0]);
        AddParam(params[1]);
        break;
      }

      default:
      {
        numSkipParams = 0;
      }
      #endif
    }
    
    #ifdef NSIS_SCRIPT

    unsigned numParams = kNumCommandParams;

    for (; numParams > 0; numParams--)
      if (params[numParams - 1] != 0)
        break;

    if (numParams > numSkipParams)
    {
      s += " ; !!!! Unknown Params: ";
      unsigned i;
      for (i = 0; i < numParams; i++)
        AddParam(params[i]);

      s += "   ;";
      
      for (i = 0; i < numParams; i++)
      {
        Space();
        UInt32 v = params[i];
        if (v > 0xFFF00000)
          Add_SignedInt(s, (Int32)v);
        else
          Add_UInt(v);
      }
    }

    NewLine();
    
    #endif
  }

  #ifdef NSIS_SCRIPT

  if (sectionIsOpen)
  {
    if (curSectionIndex < bhSections.Num)
    {
      const CSection &sect = Sections[curSectionIndex];
      if (sect.StartCmdIndex + sect.NumCommands + 1 == kkk)
      {
        PrintSectionEnd();
        sectionIsOpen = false;
        // lastSectionEndCmd = kkk;
        curSectionIndex++;
      }
    }
  }
  
  while (curSectionIndex < bhSections.Num)
  {
    const CSection &sect = Sections[curSectionIndex];
    if (sectionIsOpen)
    {
      if (sect.StartCmdIndex + sect.NumCommands != kkk)
        AddErrorLF("SECTION ERROR");
      PrintSectionEnd();
      sectionIsOpen = false;
      curSectionIndex++;
    }
    else
    {
      if (curSectionIndex == 49)
        curSectionIndex = curSectionIndex;

      if (PrintSectionBegin(sect, curSectionIndex))
        curSectionIndex++;
      else
        sectionIsOpen = true;
    }
  }
  
  #endif

  return S_OK;
}

static int CompareItems(void *const *p1, void *const *p2, void *param)
{
  const CItem &i1 = **(CItem **)p1;
  const CItem &i2 = **(CItem **)p2;
  RINOZ(MyCompare(i1.Pos, i2.Pos));
  const CInArchive *inArchive = (const CInArchive *)param;
  if (inArchive->IsUnicode)
  {
    if (i1.Prefix != i2.Prefix)
    {
      if (i1.Prefix < 0) return -1;
      if (i2.Prefix < 0) return 1;
      RINOZ(wcscmp(
          inArchive->UPrefixes[i1.Prefix],
          inArchive->UPrefixes[i2.Prefix]));
    }
    RINOZ(wcscmp(i1.NameU, i2.NameU));
  }
  else
  {
    if (i1.Prefix != i2.Prefix)
    {
      if (i1.Prefix < 0) return -1;
      if (i2.Prefix < 0) return 1;
      RINOZ(strcmp(
          inArchive->APrefixes[i1.Prefix],
          inArchive->APrefixes[i2.Prefix]));
    }
    RINOZ(strcmp(i1.NameA, i2.NameA));
  }
  return 0;
}

HRESULT CInArchive::SortItems()
{
  {
    Items.Sort(CompareItems, (void *)this);
    unsigned i;

    for (i = 0; i + 1 < Items.Size(); i++)
    {
      const CItem &i1 = Items[i];
      const CItem &i2 = Items[i + 1];
      if (i1.Pos != i2.Pos)
        continue;

      if (IsUnicode)
      {
        if (i1.NameU != i2.NameU) continue;
        if (i1.Prefix != i2.Prefix)
        {
          if (i1.Prefix < 0 || i2.Prefix < 0) continue;
          if (UPrefixes[i1.Prefix] != UPrefixes[i2.Prefix]) continue;
        }
      }
      else
      {
        if (i1.NameA != i2.NameA) continue;
        if (i1.Prefix != i2.Prefix)
        {
          if (i1.Prefix < 0 || i2.Prefix < 0) continue;
          if (APrefixes[i1.Prefix] != APrefixes[i2.Prefix]) continue;
        }
      }
      Items.Delete(i + 1);
      i--;
    }
    
    for (i = 0; i < Items.Size(); i++)
    {
      CItem &item = Items[i];
      UInt32 curPos = item.Pos + 4;
      for (unsigned nextIndex = i + 1; nextIndex < Items.Size(); nextIndex++)
      {
        UInt32 nextPos = Items[nextIndex].Pos;
        if (curPos <= nextPos)
        {
          item.EstimatedSize_Defined = true;
          item.EstimatedSize = nextPos - curPos;
          break;
        }
      }
    }
    
    if (!IsSolid)
    {
      for (i = 0; i < Items.Size(); i++)
      {
        CItem &item = Items[i];
        RINOK(_stream->Seek(GetPosOfNonSolidItem(i), STREAM_SEEK_SET, NULL));
        const UInt32 kSigSize = 4 + 1 + 1 + 4; // size,[flag],prop,dict
        BYTE sig[kSigSize];
        size_t processedSize = kSigSize;
        RINOK(ReadStream(_stream, sig, &processedSize));
        if (processedSize < 4)
          return S_FALSE;
        UInt32 size = Get32(sig);
        if ((size & kMask_IsCompressed) != 0)
        {
          item.IsCompressed = true;
          size &= ~kMask_IsCompressed;
          if (Method == NMethodType::kLZMA)
          {
            if (processedSize < 9)
              return S_FALSE;
            /*
            if (FilterFlag)
              item.UseFilter = (sig[4] != 0);
            */
            item.DictionarySize = Get32(sig + 4 + 1 + (FilterFlag ? 1 : 0));
          }
        }
        else
        {
          item.IsCompressed = false;
          item.Size = size;
          item.Size_Defined = true;
        }
        item.CompressedSize = size;
        item.CompressedSize_Defined = true;
      }
    }
  }
  return S_OK;
}

// Flags for common_header.flags
#define CH_FLAGS_DETAILS_SHOWDETAILS 1
#define CH_FLAGS_DETAILS_NEVERSHOW 2
#define CH_FLAGS_PROGRESS_COLORED 4
#define CH_FLAGS_SILENT 8
#define CH_FLAGS_SILENT_LOG 16
#define CH_FLAGS_AUTO_CLOSE 32
#define CH_FLAGS_DIR_NO_SHOW 64  // unused now
#define CH_FLAGS_NO_ROOT_DIR 128
#define CH_FLAGS_COMP_ONLY_ON_CUSTOM 256
#define CH_FLAGS_NO_CUSTOM 512

static const char * const k_PostStrings[] =
{
    "install_directory_auto_append"
  , "uninstchild"     // NSIS 2.25+, used by uninstaller:
  , "uninstcmd"       // NSIS 2.25+, used by uninstaller:
  , "wininit"         // NSIS 2.25+, used by move file on reboot
};

HRESULT CInArchive::Parse()
{
  // UInt32 offset = ReadUInt32();
  // ???? offset == FirstHeader.HeaderSize
  const Byte *p = _data;

  CBlockHeader bhEntries, bhStrings, bhLangTables;
  bhEntries.Parse(p + 4 + 8 * 2);
  bhStrings.Parse(p + 4 + 8 * 3);
  bhLangTables.Parse(p + 4 + 8 * 4);

  #ifdef NSIS_SCRIPT

  CBlockHeader bhFont;
  bhPages.Parse(p + 4 + 8 * 0);
  bhSections.Parse(p + 4 + 8 * 1);
  bhCtlColors.Parse(p + 4 + 8 * 5);
  bhFont.Parse(p + 4 + 8 * 6);
  bhData.Parse(p + 4 + 8 * 7);

  #endif

  _stringsPos = bhStrings.Offset;
  if (_stringsPos > _size)
    return S_FALSE;
  {
    if (bhLangTables.Offset < bhStrings.Offset)
      return S_FALSE;
    UInt32 stringTableSize = bhLangTables.Offset - bhStrings.Offset;
    if (stringTableSize < 2)
      return S_FALSE;
    const Byte *strData = _data + _stringsPos;
    if (strData[stringTableSize - 1] != 0)
      return S_FALSE;
    IsUnicode = (Get16(strData) == 0);
    NumStringChars = stringTableSize;
    if (IsUnicode)
    {
      if ((stringTableSize & 1) != 0)
        return S_FALSE;
      NumStringChars >>= 1;
      if (strData[stringTableSize - 2] != 0)
        return S_FALSE;
    }

  }

  if (bhEntries.Num > (1 << 25))
    return S_FALSE;
  if (bhEntries.Offset > _size)
    return S_FALSE;
  if (bhEntries.Num * kCmdSize > _size - bhEntries.Offset)
    return S_FALSE;

  DetectNsisType(bhEntries, _data + bhEntries.Offset);

  #ifdef NSIS_SCRIPT

  {
    AddCommentAndString("NSIS script");
    if (IsUnicode)
      Script += " (UTF-8)";
    Space();
    Script += GetFormatDescription();
    AddLF();
  }
  {
    AddCommentAndString(IsInstaller ? "Install" : "Uninstall");
    AddLF();
  }

  AddLF();
  if (IsUnicode)
    AddStringLF("Unicode true");

  if (Method != NMethodType::kCopy)
  {
    const char *m = NULL;
    switch (Method)
    {
      case NMethodType::kDeflate: m = "zlib"; break;
      case NMethodType::kBZip2: m = "bzip2"; break;
      case NMethodType::kLZMA: m = "lzma"; break;
    }
    Script += "SetCompressor";
    if (IsSolid)
      Script += " /SOLID";
    if (m)
    {
      Space();
      Script += m;
    }
    AddLF();
  }
  if (Method == NMethodType::kLZMA)
  {
    // if (DictionarySize != (8 << 20))
    {
      Script += "SetCompressorDictSize";
      AddParam_UInt(DictionarySize >> 20);
      AddLF();
    }
  }

  Separator();
  PrintNumComment("HEADER SIZE", FirstHeader.HeaderSize);
  // if (bhPages.Offset != 300 && bhPages.Offset != 288)
  if (bhPages.Offset != 0)
  {
    PrintNumComment("START HEADER SIZE", bhPages.Offset);
  }

  if (bhSections.Num > 0)
  {
    if (bhEntries.Offset < bhSections.Offset)
      return S_FALSE;
    SectionSize = (bhEntries.Offset - bhSections.Offset) / bhSections.Num;
    if (bhSections.Offset + bhSections.Num * SectionSize != bhEntries.Offset)
      return S_FALSE;
    if (SectionSize < kSectionSize_base)
      return S_FALSE;
    UInt32 maxStringLen = SectionSize - kSectionSize_base;
    if (IsUnicode)
    {
      if ((maxStringLen & 1) != 0)
        return S_FALSE;
      maxStringLen >>= 1;
    }
    // if (maxStringLen != 1024)
    {
      if (maxStringLen == 0)
        PrintNumComment("SECTION SIZE", SectionSize);
      else
        PrintNumComment("MAX STRING LENGTH", maxStringLen);
    }
  }
  
  PrintNumComment("STRING CHARS", NumStringChars);
  // PrintNumComment("LANG TABLE SIZE", bhCtlColors.Offset - bhLangTables.Offset);
  
  if (bhCtlColors.Offset > _size)
    AddErrorLF("Bad COLORS TABLE");
  // PrintNumComment("COLORS TABLE SIZE", bhFont.Offset - bhCtlColors.Offset);
  if (bhCtlColors.Num != 0)
    PrintNumComment("COLORS Num", bhCtlColors.Num);

  // bhData uses offset in _afterHeader (not in _data)
  // PrintNumComment("FONT TABLE SIZE", bhData.Offset - bhFont.Offset);
  if (bhFont.Num != 0)
    PrintNumComment("FONTS Num", bhFont.Num);

  // PrintNumComment("DATA SIZE", FirstHeader.HeaderSize - bhData.Offset);
  if (bhData.Num != 0)
    PrintNumComment("DATA NUM", bhData.Num);

  AddLF();

  AddStringLF("OutFile [NSIS].exe");
  AddStringLF("!include WinMessages.nsh");

  AddLF();

  strUsed.Alloc(NumStringChars);
  memset(strUsed, 0, NumStringChars);

  {
    UInt32 ehFlags = Get32(p);
    UInt32 showDetails = ehFlags & 3;// CH_FLAGS_DETAILS_SHOWDETAILS & CH_FLAGS_DETAILS_NEVERSHOW;
    if (showDetails >= 1 && showDetails <= 2)
    {
      Script += IsInstaller ? "ShowInstDetails" : "ShowUninstDetails";
      Script += (showDetails == 1) ? " show" : " nevershow";
      AddLF();
    }
    if (ehFlags & CH_FLAGS_PROGRESS_COLORED) AddStringLF("InstProgressFlags colored" );
    if ((ehFlags & (CH_FLAGS_SILENT | CH_FLAGS_SILENT_LOG)) != 0)
    {
      Script += IsInstaller ? "SilentInstall " : "SilentUnInstall ";
      Script += (ehFlags & CH_FLAGS_SILENT_LOG) ? "silentlog" : "silent";
      AddLF();
    }
    if (ehFlags & CH_FLAGS_AUTO_CLOSE) AddStringLF("AutoCloseWindow true");
    if ((ehFlags & CH_FLAGS_NO_ROOT_DIR) == 0) AddStringLF("AllowRootDirInstall true");
    if (ehFlags & CH_FLAGS_NO_CUSTOM) AddStringLF("InstType /NOCUSTOM");
    if (ehFlags & CH_FLAGS_COMP_ONLY_ON_CUSTOM) AddStringLF("InstType /COMPONENTSONLYONCUSTOM");
  }

  // Separator();
  // AddLF();

  Int32 licenseLangIndex = -1;
  {
    const Byte *pp = _data + bhPages.Offset;

    for (UInt32 pageIndex = 0; pageIndex < bhPages.Num; pageIndex++, pp += kPageSize)
    {
      UInt32 wndProcID = Get32(pp + 4);
      UInt32 param1 = Get32(pp + 44 + 4 * 1);
      if (wndProcID != PWP_LICENSE || param1 == 0)
        continue;
      if ((Int32)param1 < 0)
        licenseLangIndex = - ((Int32)param1 + 1);
      else
        noParseStringIndexes.AddToUniqueSorted(param1);
    }
  }

  unsigned paramsOffset = 4 + 8 * 8;
  if (bhPages.Offset == 276)
    paramsOffset -= 8;

  const Byte *p2 = p + paramsOffset;

  {
    UInt32 rootKey = Get32(p2); // (rootKey = -1) in uninstaller by default (the bug in NSIS)
    UInt32 subKey = Get32(p2 + 4);
    UInt32 value = Get32(p2 + 8);
    if ((rootKey != 0 && rootKey != (UInt32)(Int32)-1) || subKey != 0 || value != 0)
    {
      Script += "InstallDirRegKey";
      AddRegRoot(rootKey);
      AddParam(subKey);
      AddParam(value);
      AddLF();
    }
  }


  {
    UInt32 bg_color1 = Get32(p2 + 12);
    UInt32 bg_color2 = Get32(p2 + 16);
    UInt32 bg_textcolor = Get32(p2 + 20);
    if (bg_color1 != (UInt32)(Int32)-1 || bg_color2 != (UInt32)(Int32)-1 || bg_textcolor != (UInt32)(Int32)-1)
    {
      Script += "BGGradient";
      if (bg_color1 != 0 || bg_color2 != 0xFF0000 || bg_textcolor != (UInt32)(Int32)-1)
      {
        Add_ColorParam(bg_color1);
        Add_ColorParam(bg_color2);
        if (bg_textcolor != (UInt32)(Int32)-1)
          Add_ColorParam(bg_textcolor);
      }
      AddLF();
    }
  }

  {
    UInt32 lb_bg = Get32(p2 + 24);
    UInt32 lb_fg = Get32(p2 + 28);
    if ((lb_bg != (UInt32)(Int32)-1 || lb_fg != (UInt32)(Int32)-1) &&
      (lb_bg != 0 || lb_fg != 0xFF00))
    {
      Script += "InstallColors";
      Add_ColorParam(lb_fg);
      Add_ColorParam(lb_bg);
      AddLF();
    }
  }

  UInt32 license_bg = Get32(p2 + 36);
  if (license_bg != (UInt32)(Int32)-1 && license_bg != -15) // COLOR_BTNFACE
  {
    Script += "LicenseBkColor";
    if ((Int32)license_bg == -5)  // COLOR_WINDOW
      Script += " /windows";
    /*
    else if ((Int32)license_bg == -15)
      Script += " /grey";
    */
    else
      Add_ColorParam(license_bg);
    AddLF();
  }

  UInt32 langtable_size = Get32(p2 + 32);
  if (bhLangTables.Num > 0)
  {
    if (langtable_size == (UInt32)(Int32)-1)
      return E_NOTIMPL; // maybe it's old NSIS archive()

    UInt32 numStrings = (langtable_size - 10) / 4;
    _numLangStrings = numStrings;
    AddLF();
    Separator();
    PrintNumComment("LANG TABLES", bhLangTables.Num);
    PrintNumComment("LANG STRINGS", numStrings);
    AddLF();

    if (licenseLangIndex >= 0)
    {
      for (UInt32 i = 0; i < bhLangTables.Num; i++)
      {
        const Byte *p = _data + bhLangTables.Offset + langtable_size * i;
        LANGID langID = Get16(p);
        UInt32 val = Get32(p + 10 + (UInt32)licenseLangIndex * 4);
        if (val != 0)
        {
          Script += "LicenseLangString ";
          Add_LangStr_Simple(licenseLangIndex);
          AddParam_UInt(langID);
          AddLicense(val, langID);
          noParseStringIndexes.AddToUniqueSorted(val);
          NewLine();
        }
      }
      AddLF();
    }
    
    UInt32 brandingText = 0;
    UInt32 caption = 0;
    UInt32 name = 0;
    UInt32 i;
    for (i = 0; i < bhLangTables.Num; i++)
    {
      const Byte *p = _data + bhLangTables.Offset + langtable_size * i;
      LANGID langID = Get16(p);
      if (i == 0 || langID == 1033)
        _mainLang = p + 10;
      {
        UInt32 v = Get32(p + 10 + 0 * 4);
        if (v != 0 && (langID == 1033 || brandingText == 0))
          brandingText = v;
      }
      {
        UInt32 v = Get32(p + 10 + 1 * 4);
        if (v != 0 && (langID == 1033 || caption == 0))
          caption = v;
      }
      {
        UInt32 v = Get32(p + 10 + 2 * 4);
        if (v != 0 && (langID == 1033 || name == 0))
          name = v;
      }
    }
    
    if (name != 0)
    {
      Script += "Name";
      AddParam(name);
      NewLine();

      ReadString2(Name, name);
    }
    
    /*
    if (caption != 0)
    {
      Script += "Caption";
      AddParam(caption);
      NewLine();
    }
    */
    
    if (brandingText != 0)
    {
      Script += "BrandingText";
      AddParam(brandingText);
      NewLine();

      ReadString2(BrandingText, brandingText);
    }

    for (i = 0; i < bhLangTables.Num; i++)
    {
      const Byte *p = _data + bhLangTables.Offset + langtable_size * i;
      LANGID langID = Get16(p);
      
      AddLF();
      AddCommentAndString("LANG:");
      AddParam_UInt(langID);
      /*
      Script += " (";
      LangId_To_String(Script, langID);
      Script += ')';
      */
      AddLF();
      // UInt32 dlg_offset = Get32(p + 2);
      // UInt32 g_exec_flags_rtl = Get32(p + 6);
      
      
      for (UInt32 j = 0; j < numStrings; j++)
      {
        UInt32 val = Get32(p + 10 + j * 4);
        if (val != 0)
        {
          if ((Int32)j != licenseLangIndex)
          {
            Script += "LangString ";
            Add_LangStr_Simple(j);
            AddParam_UInt(langID);
            AddParam(val);
            AddLF();
          }
        }
      }
      AddLF();
    }
    ClearLangComment();
  }

  {
    unsigned numInternalVars = GET_NUM_INTERNAL_VARS;
    UInt32 numUsedVars = GetNumUsedVars();
    if (numUsedVars > numInternalVars)
    {
      Separator();
      PrintNumComment("VARIABLES", numUsedVars - numInternalVars);
      AddLF();
      AString temp;
      for (UInt32 i = numInternalVars; i < numUsedVars; i++)
      {
        Script += "Var ";
        temp.Empty();
        GetVar2(temp, i);
        AddStringLF(temp);
      }
      AddLF();
    }
  }

  onFuncOffset = paramsOffset + 40;
  numOnFunc = ARRAY_SIZE(kOnFunc);
  if (bhPages.Offset == 276)
    numOnFunc--;
  p2 += 40 + numOnFunc * 4;
  
  #define NSIS_MAX_INST_TYPES 32

  AddLF();

  UInt32 i;
  for (i = 0; i < NSIS_MAX_INST_TYPES + 1; i++, p2 += 4)
  {
    UInt32 instType = Get32(p2);
    if (instType != 0)
    {
      Script += "InstType";
      AString s2;
      if (!IsInstaller)
        s2 += "un.";
      ReadString2(s2, instType);
      SpaceQuStr(s2);
      NewLine();
    }
  }
  
  {
    UInt32 installDir = Get32(p2);
    p2 += 4;
    if (installDir != 0)
    {
      Script += "InstallDir";
      AddParam(installDir);
      NewLine();
    }
  }

  if (bhPages.Offset >= 288)
    for (i = 0; i < 4; i++)
    {
      if (i != 0 && bhPages.Offset < 300)
        break;
      UInt32 param = Get32(p2 + 4 * i);
      if (param == 0 || param == (UInt32)(Int32)-1)
        continue;
      
      /*
      uninstaller:
      UInt32 uninstChild = Get32(p2 + 8); // "$TEMP\\$1u_.exe"
      UInt32 uninstCmd = Get32(p2 + 12); // "\"$TEMP\\$1u_.exe\" $0 _?=$INSTDIR\\"
      int str_wininit = Get32(p2 + 16); // "$WINDIR\\wininit.ini"
      */
      
      AddCommentAndString(k_PostStrings[i]);
      Script += " =";
      AddParam(param);
      NewLine();
    }

  AddLF();

  #endif

  RINOK(ReadEntries(bhEntries));

  #ifdef NSIS_SCRIPT

  Separator();
  AddCommentAndString("UNREFERENCED STRINGS:");
  AddLF();
  AddLF();
  CommentOpen();

  for (i = 0; i < NumStringChars;)
  {
    if (!strUsed[i] && i != 0)
    // Script += "!!! ";
    {
      Add_UInt(i);
      AddParam(i);
      NewLine();
    }
    if (IsUnicode)
      i += GetUi16Str_Len((const Byte *)_data + _stringsPos + i * 2);
    else
      i += (UInt32)strlen((const char *)(const Byte *)_data + _stringsPos + i);
    i++;
  }
  CommentClose();
  #endif

  return SortItems();
}

static bool IsLZMA(const Byte *p, UInt32 &dictionary)
{
  dictionary = Get32(p + 1);
  return (p[0] == 0x5D &&
      p[1] == 0x00 && p[2] == 0x00 &&
      p[5] == 0x00 && (p[6] & 0x80) == 0x00);
}

static bool IsLZMA(const Byte *p, UInt32 &dictionary, bool &thereIsFlag)
{
  if (IsLZMA(p, dictionary))
  {
    thereIsFlag = false;
    return true;
  }
  if (p[0] <= 1 && IsLZMA(p + 1, dictionary))
  {
    thereIsFlag = true;
    return true;
  }
  return false;
}

static bool IsBZip2(const Byte *p)
{
  return (p[0] == 0x31 && p[1] < 14);
}

HRESULT CInArchive::Open2(const Byte *sig, size_t size)
{
  const UInt32 kSigSize = 4 + 1 + 5 + 2; // size, flag, 5 - lzma props, 2 - lzma first bytes
  if (size < kSigSize)
    return S_FALSE;

  _headerIsCompressed = true;
  IsSolid = true;
  FilterFlag = false;
  UseFilter = false;
  DictionarySize = 1;

  #ifdef NSIS_SCRIPT
  AfterHeaderSize = 0;
  #endif

  UInt32 compressedHeaderSize = Get32(sig);
  

  /*
    XX XX XX XX             XX XX XX XX == FirstHeader.HeaderSize, nonsolid, uncompressed
    5D 00 00 dd dd 00       solid LZMA
    00 5D 00 00 dd dd 00    solid LZMA, empty filter (there are no such archives)
    01 5D 00 00 dd dd 00    solid LZMA, BCJ filter   (only 7-Zip installer used that format)
    
    SS SS SS 80 00 5D 00 00 dd dd 00     non-solid LZMA, empty filter
    SS SS SS 80 01 5D 00 00 dd dd 00     non-solid LZMA, BCJ filte
    SS SS SS 80 01 tt         non-solid BZip (tt < 14
    SS SS SS 80               non-solid  deflate

    01 tt         solid BZip (tt < 14
    other         solid Deflate
  */

  if (compressedHeaderSize == FirstHeader.HeaderSize)
  {
    _headerIsCompressed = false;
    IsSolid = false;
    Method = NMethodType::kCopy;
  }
  else if (IsLZMA(sig, DictionarySize, FilterFlag))
    Method = NMethodType::kLZMA;
  else if (sig[3] == 0x80)
  {
    IsSolid = false;
    if (IsLZMA(sig + 4, DictionarySize, FilterFlag) && sig[3] == 0x80)
      Method = NMethodType::kLZMA;
    else if (IsBZip2(sig + 4))
      Method = NMethodType::kBZip2;
    else
      Method = NMethodType::kDeflate;
  }
  else if (IsBZip2(sig))
    Method = NMethodType::kBZip2;
  else
    Method = NMethodType::kDeflate;

  if (IsSolid)
  {
    RINOK(_stream->Seek(DataStreamOffset, STREAM_SEEK_SET, NULL));
  }
  else
  {
    _headerIsCompressed = ((compressedHeaderSize & kMask_IsCompressed) != 0);
    compressedHeaderSize &= ~kMask_IsCompressed;
    _nonSolidStartOffset = compressedHeaderSize;
    RINOK(_stream->Seek(DataStreamOffset + 4, STREAM_SEEK_SET, NULL));
  }

  _data.Alloc(FirstHeader.HeaderSize);
  _size = (size_t)FirstHeader.HeaderSize;

  Decoder.Method = Method;
  Decoder.FilterFlag = FilterFlag;
  Decoder.Solid = IsSolid;
  Decoder.InputStream = _stream;
  Decoder.Buffer.Alloc(kInputBufSize);
  Decoder.StreamPos = 0;

  if (_headerIsCompressed)
  {
    RINOK(Decoder.Init(_stream, UseFilter));
    if (IsSolid)
    {
      size_t processedSize = 4;
      Byte buf[4];
      RINOK(Decoder.Read(buf, &processedSize));
      if (processedSize != 4)
        return S_FALSE;
      if (Get32((const Byte *)buf) != FirstHeader.HeaderSize)
        return S_FALSE;
    }
    size_t processedSize = FirstHeader.HeaderSize;
    RINOK(Decoder.Read(_data, &processedSize));
    if (processedSize != FirstHeader.HeaderSize)
      return S_FALSE;
    
    #ifdef NSIS_SCRIPT
    if (IsSolid)
    {
      /* we need additional bytes for data for WriteRegBin */
      AfterHeaderSize = (1 << 12);
      _afterHeader.Alloc(AfterHeaderSize);
      size_t processedSize = AfterHeaderSize;
      RINOK(Decoder.Read(_afterHeader, &processedSize));
      AfterHeaderSize = (UInt32)processedSize;
    }
    #endif
  }
  else
  {
    size_t processedSize = FirstHeader.HeaderSize;
    RINOK(ReadStream(_stream, (Byte *)_data, &processedSize));
    if (processedSize < FirstHeader.HeaderSize)
      return S_FALSE;
  }

  #ifdef NUM_SPEED_TESTS
  for (unsigned i = 0; i < NUM_SPEED_TESTS; i++)
  {
    RINOK(Parse());
    Clear2();
  }
  #endif

  return Parse();
}

/*
NsisExe =
{
  ExeStub
  Archive  // must start from 512 * N
  #ifndef NSIS_CONFIG_CRC_ANAL
  {
    Some additional data
  }
}

Archive
{
  FirstHeader
  Data
  #ifdef NSIS_CONFIG_CRC_SUPPORT && FirstHeader.ThereIsCrc()
  {
    CRC
  }
}

FirstHeader
{
  UInt32 Flags;
  Byte Signature[16];
  // points to the header+sections+entries+stringtable in the datablock
  UInt32 HeaderSize;
  UInt32 ArcSize;
}
*/


// ---------- PE (EXE) parsing ----------

static const unsigned k_PE_StartSize = 0x40;
static const unsigned k_PE_HeaderSize = 4 + 20;
static const unsigned k_PE_OptHeader32_Size_MIN = 96;

static inline bool CheckPeOffset(UInt32 pe)
{
  return (pe >= 0x40 && pe <= 0x1000 && (pe & 7) == 0);
}


static bool IsArc_Pe(const Byte *p, size_t size)
{
  if (size < 2)
    return false;
  if (p[0] != 'M' || p[1] != 'Z')
    return false;
  if (size < k_PE_StartSize)
    return false; // k_IsArc_Res_NEED_MORE;
  UInt32 pe = Get32(p + 0x3C);
  if (!CheckPeOffset(pe))
    return false;
  if (pe + k_PE_HeaderSize > size)
    return false; // k_IsArc_Res_NEED_MORE;

  p += pe;
  if (Get32(p) != 0x00004550)
    return false;
  return Get16(p + 4 + 16) >= k_PE_OptHeader32_Size_MIN;
}

HRESULT CInArchive::Open(IInStream *inStream, const UInt64 *maxCheckStartPosition)
{
  Clear();
  
  RINOK(inStream->Seek(0, STREAM_SEEK_CUR, &StartOffset));
  
  const UInt32 kStartHeaderSize = 4 * 7;
  const unsigned kStep = 512; // nsis start is aligned for 512
  Byte buf[kStep];
  UInt64 pos = StartOffset;
  size_t bufSize = 0;
  UInt64 pePos = (UInt64)(Int64)-1;
  
  for (;;)
  {
    bufSize = kStep;
    RINOK(ReadStream(inStream, buf, &bufSize));
    if (bufSize < kStartHeaderSize)
      return S_FALSE;
    if (memcmp(buf + 4, kSignature, kSignatureSize) == 0)
      break;
    if (IsArc_Pe(buf, bufSize))
      pePos = pos;
    pos += kStep;
    UInt64 proc = pos - StartOffset;
    if (maxCheckStartPosition && proc > *maxCheckStartPosition)
    {
      if (pePos == 0)
      {
        if (proc > (1 << 20))
          return S_FALSE;
      }
      else
        return S_FALSE;
    }
  }
  
  if (pePos == (UInt64)(Int64)-1)
  {
    UInt64 posCur = StartOffset;
    for (;;)
    {
      if (posCur < kStep)
        break;
      posCur -= kStep;
      if (pos - posCur > (1 << 20))
        break;
      bufSize = kStep;
      RINOK(inStream->Seek(posCur, STREAM_SEEK_SET, NULL));
      RINOK(ReadStream(inStream, buf, &bufSize));
      if (bufSize < kStep)
        break;
      if (IsArc_Pe(buf, bufSize))
      {
        pePos = posCur;
        break;
      }
    }

    // restore buf to nsis header
    bufSize = kStep;
    RINOK(inStream->Seek(pos, STREAM_SEEK_SET, NULL));
    RINOK(ReadStream(inStream, buf, &bufSize));
    if (bufSize < kStartHeaderSize)
      return S_FALSE;
  }

  StartOffset = pos;
  UInt32 peSize = 0;
  
  if (pePos != (UInt64)(Int64)-1)
  {
    UInt64 peSize64 = (pos - pePos);
    if (peSize64 < (1 << 20))
    {
      peSize = (UInt32)peSize64;
      StartOffset = pePos;
    }
  }

  DataStreamOffset = pos + kStartHeaderSize;
  FirstHeader.Flags = Get32(buf);
  if ((FirstHeader.Flags & (~kFlagsMask)) != 0)
    return S_FALSE;
  IsInstaller = (FirstHeader.Flags & NFlags::kUninstall) == 0;

  FirstHeader.HeaderSize = Get32(buf + kSignatureSize + 4);
  FirstHeader.ArcSize = Get32(buf + kSignatureSize + 8);
  if (FirstHeader.ArcSize <= kStartHeaderSize)
    return S_FALSE;
    
  RINOK(inStream->Seek(0, STREAM_SEEK_END, &_fileSize));

  IsArc = true;

  if (peSize != 0)
  {
    ExeStub.Alloc(peSize);
    RINOK(inStream->Seek(pePos, STREAM_SEEK_SET, NULL));
    RINOK(ReadStream_FALSE(inStream, ExeStub, peSize));
  }

  HRESULT res = S_FALSE;
  try
  {
    CLimitedInStream *_limitedStreamSpec = new CLimitedInStream;
    _stream = _limitedStreamSpec;
    _limitedStreamSpec->SetStream(inStream);
    _limitedStreamSpec->InitAndSeek(pos, FirstHeader.ArcSize);
    DataStreamOffset -= pos;
    res = Open2(buf + kStartHeaderSize, bufSize - kStartHeaderSize);
  }
  catch(...)
  {
    _stream.Release();
    throw;
    // res = S_FALSE;
  }
  if (res != S_OK)
  {
    _stream.Release();
    // Clear();
  }
  return res;
}

UString CInArchive::ConvertToUnicode(const AString &s) const
{
  if (IsUnicode)
  {
    UString res;
    if (ConvertUTF8ToUnicode(s, res))
      return res;
  }
  return MultiByteToUnicodeString(s);
}

void CInArchive::Clear2()
{
  IsUnicode = false;
  NsisType = k_NsisType_Nsis2;
  IsNsis225 = false;
  IsNsis200 = false;
  LogCmdIsEnabled = false;
  BadCmd = -1;

  #ifdef NSIS_SCRIPT
  Name.Empty();
  BrandingText.Empty();
  Script.Empty();
  LicenseFiles.Clear();
  _numRootLicenses = 0;
  _numLangStrings = 0;
  langStrIDs.Clear();
  LangComment.Empty();
  noParseStringIndexes.Clear();
  #endif

  APrefixes.Clear();
  UPrefixes.Clear();
  Items.Clear();
  IsUnicode = false;
  ExeStub.Free();
}

void CInArchive::Clear()
{
  Clear2();
  IsArc = false;
  _stream.Release();
}

}}
// NsisIn.h

#ifndef __ARCHIVE_NSIS_IN_H
#define __ARCHIVE_NSIS_IN_H

#include "../../../../C/CpuArch.h"

#include "../../../Common/DynLimBuf.h"
#include "../../../Common/MyBuffer.h"
#include "../../../Common/MyCom.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/UTFConvert.h"

#include "NsisDecode.h"

/* If NSIS_SCRIPT is defined, it will decompile NSIS script to [NSIS].nsi file.
   The code is much larger in that case. */
 
// #define NSIS_SCRIPT

namespace NArchive {
namespace NNsis {

const size_t kScriptSizeLimit = 1 << 27;

const unsigned kSignatureSize = 16;
extern const Byte kSignature[kSignatureSize];
#define NSIS_SIGNATURE { 0xEF, 0xBE, 0xAD, 0xDE, 'N', 'u', 'l', 'l', 's', 'o', 'f', 't', 'I', 'n', 's', 't' }

const UInt32 kFlagsMask = 0xF;
namespace NFlags
{
  const UInt32 kUninstall = 1;
  const UInt32 kSilent = 2;
  const UInt32 kNoCrc = 4;
  const UInt32 kForceCrc = 8;
}

struct CFirstHeader
{
  UInt32 Flags;
  UInt32 HeaderSize;
  UInt32 ArcSize;

  bool ThereIsCrc() const
  {
    return
        (Flags & NFlags::kForceCrc) != 0 ||
        (Flags & NFlags::kNoCrc) == 0;
  }

  UInt32 GetDataSize() const { return ArcSize - (ThereIsCrc() ? 4 : 0); }
};


struct CBlockHeader
{
  UInt32 Offset;
  UInt32 Num;

  void Parse(const Byte *p)
  {
    Offset = GetUi32(p);
    Num = GetUi32(p + 4);
  }
};

struct CItem
{
  bool IsCompressed;
  bool Size_Defined;
  bool CompressedSize_Defined;
  bool EstimatedSize_Defined;
  bool Attrib_Defined;
  bool IsUninstaller;
  // bool UseFilter;
  
  UInt32 Attrib;
  UInt32 Pos;
  UInt32 Size;
  UInt32 CompressedSize;
  UInt32 EstimatedSize;
  UInt32 DictionarySize;
  UInt32 PatchSize; // for Uninstaller.exe
  int Prefix; // - 1 means no prefix

  FILETIME MTime;
  AString NameA;
  UString NameU;
  
  CItem():
      IsCompressed(true),
      Size_Defined(false),
      CompressedSize_Defined(false),
      EstimatedSize_Defined(false),
      Attrib_Defined(false),
      IsUninstaller(false),
      // UseFilter(false),
      Attrib(0),
      Pos(0),
      Size(0),
      CompressedSize(0),
      EstimatedSize(0),
      DictionarySize(1),
      PatchSize(0),
      Prefix(-1)
  {
    MTime.dwLowDateTime = 0;
    MTime.dwHighDateTime = 0;
  }

  /*
  bool IsINSTDIR() const
  {
    return (PrefixA.Len() >= 3 || PrefixU.Len() >= 3);
  }
  */
};

enum ENsisType
{
  k_NsisType_Nsis2,
  k_NsisType_Nsis3,
  k_NsisType_Park1, // Park 2.46.1-
  k_NsisType_Park2, // Park 2.46.2  : GetFontVersion
  k_NsisType_Park3  // Park 2.46.3+ : GetFontName
};

#ifdef NSIS_SCRIPT

struct CSection
{
  UInt32 InstallTypes; // bits set for each of the different install_types, if any.
  UInt32 Flags; // SF_* - defined above
  UInt32 StartCmdIndex; // code;
  UInt32 NumCommands; // code_size;
  UInt32 SizeKB;
  UInt32 Name;

  void Parse(const Byte *data);
};

struct CLicenseFile
{
  UInt32 Offset;
  UInt32 Size;
  AString Name;
  CByteBuffer Text;
};

#endif

class CInArchive
{
public:
  #ifdef NSIS_SCRIPT
  CDynLimBuf Script;
  #endif
  CByteBuffer _data;
  CObjectVector<CItem> Items;
  bool IsUnicode;
private:
  UInt32 _stringsPos;     // relative to _data
  UInt32 NumStringChars;
  size_t _size;           // it's Header Size

  AString Raw_AString;
  UString Raw_UString;

  ENsisType NsisType;
  bool IsNsis200; // NSIS 2.03 and before
  bool IsNsis225; // NSIS 2.25 and before
  
  bool LogCmdIsEnabled;
  int BadCmd; // -1: no bad command; in another cases lowest bad command id

  bool IsPark() const { return NsisType >= k_NsisType_Park1; }

  UInt64 _fileSize;
  
  bool _headerIsCompressed;
  UInt32 _nonSolidStartOffset;

  #ifdef NSIS_SCRIPT
  
  CByteBuffer strUsed;

  CBlockHeader bhPages;
  CBlockHeader bhSections;
  CBlockHeader bhCtlColors;
  CBlockHeader bhData;
  UInt32 AfterHeaderSize;
  CByteBuffer _afterHeader;

  UInt32 SectionSize;
  const Byte *_mainLang;
  UInt32 _numLangStrings;
  AString LangComment;
  CRecordVector<UInt32> langStrIDs;
  UInt32 numOnFunc;
  UInt32 onFuncOffset;
  // CRecordVector<UInt32> OnFuncs;
  unsigned _numRootLicenses;
  CRecordVector<UInt32> noParseStringIndexes;
  AString _tempString_for_GetVar;
  AString _tempString_for_AddFuncName;
  AString _tempString;

  #endif


public:
  CMyComPtr<IInStream> _stream; // it's limited stream that contains only NSIS archive
  UInt64 StartOffset;           // offset in original stream.
  UInt64 DataStreamOffset;      // = sizeof(FirstHeader) = offset of Header in _stream

  bool IsArc;

  CDecoder Decoder;
  CByteBuffer ExeStub;
  CFirstHeader FirstHeader;
  NMethodType::EEnum Method;
  UInt32 DictionarySize;
  bool IsSolid;
  bool UseFilter;
  bool FilterFlag;
  
  bool IsInstaller;
  AString Name;
  AString BrandingText;
  UStringVector UPrefixes;
  AStringVector APrefixes;

  #ifdef NSIS_SCRIPT
  CObjectVector<CLicenseFile> LicenseFiles;
  #endif

private:
  void GetShellString(AString &s, unsigned index1, unsigned index2);
  void GetNsisString_Raw(const Byte *s);
  void GetNsisString_Unicode_Raw(const Byte *s);
  void ReadString2_Raw(UInt32 pos);
  bool IsGoodString(UInt32 param) const;
  bool AreTwoParamStringsEqual(UInt32 param1, UInt32 param2) const;

  void Add_LangStr(AString &res, UInt32 id);

  #ifdef NSIS_SCRIPT

  void Add_UInt(UInt32 v);
  void AddLicense(UInt32 param, Int32 langID);

  void Add_LangStr_Simple(UInt32 id);
  void Add_FuncName(const UInt32 *labels, UInt32 index);
  void AddParam_Func(const UInt32 *labels, UInt32 index);
  void Add_LabelName(UInt32 index);

  void Add_Color2(UInt32 v);
  void Add_ColorParam(UInt32 v);
  void Add_Color(UInt32 index);

  void Add_ButtonID(UInt32 buttonID);

  void Add_ShowWindow_Cmd(UInt32 cmd);
  void Add_TypeFromList(const char * const *table, unsigned tableSize, UInt32 type);
  void Add_ExecFlags(UInt32 flagsType);
  void Add_SectOp(UInt32 opType);

  void Add_Var(UInt32 index);
  void AddParam_Var(UInt32 value);
  void AddParam_UInt(UInt32 value);

  void Add_GotoVar(UInt32 param);
  void Add_GotoVar1(UInt32 param);
  void Add_GotoVars2(const UInt32 *params);


 
  bool PrintSectionBegin(const CSection &sect, unsigned index);
  void PrintSectionEnd();

  void GetNsisString(AString &res, const Byte *s);
  void GetNsisString_Unicode(AString &res, const Byte *s);
  UInt32 GetNumUsedVars() const;
  void ReadString2(AString &s, UInt32 pos);

  void MessageBox_MB_Part(UInt32 param);
  void AddParam(UInt32 pos);
  void AddOptionalParam(UInt32 pos);
  void AddParams(const UInt32 *params, unsigned num);
  void AddPageOption1(UInt32 param, const char *name);
  void AddPageOption(const UInt32 *params, unsigned num, const char *name);
  void AddOptionalParams(const UInt32 *params, unsigned num);
  void AddRegRoot(UInt32 value);

 
  void ClearLangComment();
  void Separator();
  void Space();
  void Tab();
  void Tab(bool commented);
  void BigSpaceComment();
  void SmallSpaceComment();
  void AddCommentAndString(const char *s);
  void AddError(const char *s);
  void AddErrorLF(const char *s);
  void CommentOpen();
  void CommentClose();
  void AddLF();
  void AddQuotes();
  void TabString(const char *s);
  void AddStringLF(const char *s);
  void NewLine();
  void PrintNumComment(const char *name, UInt32 value);
  void Add_QuStr(const AString &s);
  void SpaceQuStr(const AString &s);
  bool CompareCommands(const Byte *rawCmds, const Byte *sequence, size_t numCommands);

  #endif

  #ifdef NSIS_SCRIPT
  unsigned GetNumSupportedCommands() const;
  #endif

  UInt32 GetCmd(UInt32 a);
  void FindBadCmd(const CBlockHeader &bh, const Byte *);
  void DetectNsisType(const CBlockHeader &bh, const Byte *);

  HRESULT ReadEntries(const CBlockHeader &bh);
  HRESULT SortItems();
  HRESULT Parse();
  HRESULT Open2(const Byte *data, size_t size);
  void Clear2();

  void GetVar2(AString &res, UInt32 index);
  void GetVar(AString &res, UInt32 index);
  Int32 GetVarIndex(UInt32 strPos) const;
  Int32 GetVarIndex(UInt32 strPos, UInt32 &resOffset) const;
  Int32 GetVarIndexFinished(UInt32 strPos, Byte endChar, UInt32 &resOffset) const;
  bool IsVarStr(UInt32 strPos, UInt32 varIndex) const;
  bool IsAbsolutePathVar(UInt32 strPos) const;
  void SetItemName(CItem &item, UInt32 strPos);

public:
  HRESULT Open(IInStream *inStream, const UInt64 *maxCheckStartPosition);
  AString GetFormatDescription() const;
  HRESULT InitDecoder()
  {
    bool useFilter;
    return Decoder.Init(_stream, useFilter);
  }

  HRESULT SeekTo_DataStreamOffset()
  {
    return _stream->Seek(DataStreamOffset, STREAM_SEEK_SET, NULL);
  }

  HRESULT SeekToNonSolidItem(unsigned index)
  {
    return _stream->Seek(GetPosOfNonSolidItem(index), STREAM_SEEK_SET, NULL);
  }

  void Clear();

  bool IsDirectString_Equal(UInt32 offset, const char *s) const;
  /*
  UInt64 GetDataPos(unsigned index)
  {
    const CItem &item = Items[index];
    return GetOffset() + FirstHeader.HeaderSize + item.Pos;
  }
  */

  UInt64 GetPosOfSolidItem(unsigned index) const
  {
    const CItem &item = Items[index];
    return 4 + (UInt64)FirstHeader.HeaderSize + item.Pos;
  }
  
  UInt64 GetPosOfNonSolidItem(unsigned index) const
  {
    const CItem &item = Items[index];
    return DataStreamOffset + _nonSolidStartOffset + 4 + item.Pos;
  }

  void Release()
  {
    Decoder.Release();
  }

  bool IsTruncated() const { return (_fileSize - StartOffset < FirstHeader.ArcSize); }

  UString GetReducedName(unsigned index) const
  {
    const CItem &item = Items[index];

    UString s;
    if (item.Prefix >= 0)
    {
      if (IsUnicode)
        s = UPrefixes[item.Prefix];
      else
        s = MultiByteToUnicodeString(APrefixes[item.Prefix]);
      if (s.Len() > 0)
        if (s.Back() != L'\\')
          s += L'\\';
    }

    if (IsUnicode)
    {
      s += item.NameU;
      if (item.NameU.IsEmpty())
        s += L"file";
    }
    else
    {
      s += MultiByteToUnicodeString(item.NameA);
      if (item.NameA.IsEmpty())
        s += L"file";
    }
    
    const char *kRemoveStr = "$INSTDIR\\";
    if (s.IsPrefixedBy_Ascii_NoCase(kRemoveStr))
    {
      s.Delete(0, MyStringLen(kRemoveStr));
      if (s[0] == L'\\')
        s.DeleteFrontal(1);
    }
    if (item.IsUninstaller && ExeStub.Size() == 0)
      s += L".nsis";
    return s;
  }

  UString ConvertToUnicode(const AString &s) const;

  CInArchive()
    #ifdef NSIS_SCRIPT
      : Script(kScriptSizeLimit)
    #endif
    {}
};

}}
  
#endif
// NsisRegister.cpp

#include "StdAfx.h"

#include "../../Common/RegisterArc.h"

#include "NsisHandler.h"

namespace NArchive {
namespace NNsis {

REGISTER_ARC_I(
  "Nsis", "nsis", 0, 0x9,
  kSignature,
  4,
  NArcInfoFlags::kFindSignature |
  NArcInfoFlags::kUseGlobalOffset,
  NULL)

}}
// Rar5Handler.cpp

#include "StdAfx.h"

#include "../../../../C/7zCrc.h"
#include "../../../../C/CpuArch.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/IntToString.h"
#include "../../../Common/UTFConvert.h"

#include "../../../Windows/PropVariantUtils.h"
#include "../../../Windows/TimeUtils.h"

#include "../../IPassword.h"

#include "../../Common/FilterCoder.h"
#include "../../Common/LimitedStreams.h"
#include "../../Common/ProgressUtils.h"
#include "../../Common/RegisterArc.h"
#include "../../Common/StreamObjects.h"
#include "../../Common/StreamUtils.h"

#include "../../Common/RegisterCodec.h"

#include "../../Compress/CopyCoder.h"

#include "../../Crypto/Rar5Aes.h"

#include "../Common/FindSignature.h"
#include "../Common/ItemNameUtils.h"

#include "../HandlerCont.h"

#include "RarVol.h"
#include "Rar5Handler.h"

using namespace NWindows;

#define Get32(p) GetUi32(p)

namespace NArchive {
namespace NRar5 {

static const unsigned kMarkerSize = 8;

#define SIGNATURE { 0x52 , 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0 }

static const Byte kMarker[kMarkerSize] = SIGNATURE;

static const size_t kCommentSize_Max = (size_t)1 << 16;

static const char * const kHostOS[] =
{
    "Windows"
  , "Unix"
};

static const CUInt32PCharPair k_ArcFlags[] =
{
  { 0, "Volume" },
  { 1, "VolumeField" },
  { 2, "Solid" },
  { 3, "Recovery" },
  { 4, "Lock" }
};



template <unsigned alignMask>
struct CAlignedBuffer
{
  Byte *_buf;
  Byte *_bufBase;
  size_t _size;

  CAlignedBuffer(): _buf(NULL), _bufBase(NULL), _size(0) {}
  ~CAlignedBuffer() { ::MyFree(_bufBase); }
public:
  operator       Byte *()       { return _buf; }
  operator const Byte *() const { return _buf; }

  void AllocAtLeast(size_t size)
  {
    if (_buf && _size >= size)
      return;
    ::MyFree(_bufBase);
    _buf = NULL;
    _size = 0;
    _bufBase = (Byte *)::MyAlloc(size + alignMask);
   
    if (_bufBase)
    {
      _size = size;
      // _buf = (Byte *)(((uintptr_t)_bufBase + alignMask) & ~(uintptr_t)alignMask);
         _buf = (Byte *)(((ptrdiff_t)_bufBase + alignMask) & ~(ptrdiff_t)alignMask);
    }
  }
};

static unsigned ReadVarInt(const Byte *p, size_t maxSize, UInt64 *val)
{
  *val = 0;

  for (unsigned i = 0; i < maxSize;)
  {
    Byte b = p[i];
    if (i < 10)
      *val |= (UInt64)(b & 0x7F) << (7 * i++);
    if ((b & 0x80) == 0)
      return i;
  }
  return 0;
}


int CItem::FindExtra(unsigned type, unsigned &recordDataSize) const
{
  recordDataSize = 0;
  size_t offset = 0;

  for (;;)
  {
    size_t rem = Extra.Size() - offset;
    if (rem == 0)
      return -1;
    
    {
      UInt64 size;
      unsigned num = ReadVarInt(Extra + offset, rem, &size);
      if (num == 0)
        return -1;
      offset += num;
      rem -= num;
      if (size > rem)
        return -1;
      rem = (size_t)size;
    }
    {
      UInt64 type2;
      unsigned num = ReadVarInt(Extra + offset, rem, &type2);
      if (num == 0)
        return -1;
      offset += num;
      rem -= num;

      // There was BUG in RAR 5.21- : it stored (size-1) instead of (size)
      // for Subdata record in Service header.
      // That record always was last in bad archives, so we can fix that case.
      if (type2 == NExtraRecordType::kSubdata
          && RecordType == NHeaderType::kService
          && rem + 1 == Extra.Size() - offset)
        rem++;

      if (type2 == type)
      {
        recordDataSize = (unsigned)rem;
        return (int)offset;
      }

      offset += rem;
    }
  }
}


bool CCryptoInfo::Parse(const Byte *p, size_t size)
{
  unsigned num = ReadVarInt(p, size, &Algo);
  if (num == 0) return false; p += num; size -= num;
  
  num = ReadVarInt(p, size, &Flags);
  if (num == 0) return false; p += num; size -= num;

  if (size != 1 + 16 + 16 + (unsigned)(IsThereCheck() ? 12 : 0))
    return false;

  Cnt = p[0];

  return true;
}


bool CItem::FindExtra_Version(UInt64 &version) const
{
  unsigned size;
  int offset = FindExtra(NExtraRecordType::kVersion, size);
  if (offset < 0)
    return false;
  const Byte *p = Extra + (unsigned)offset;

  UInt64 flags;
  unsigned num = ReadVarInt(p, size, &flags);
  if (num == 0) return false; p += num; size -= num;
  
  num = ReadVarInt(p, size, &version);
  if (num == 0) return false; p += num; size -= num;

  return size == 0;
}

bool CItem::FindExtra_Link(CLinkInfo &link) const
{
  unsigned size;
  int offset = FindExtra(NExtraRecordType::kLink, size);
  if (offset < 0)
    return false;
  const Byte *p = Extra + (unsigned)offset;

  unsigned num = ReadVarInt(p, size, &link.Type);
  if (num == 0) return false; p += num; size -= num;
  
  num = ReadVarInt(p, size, &link.Flags);
  if (num == 0) return false; p += num; size -= num;

  UInt64 len;
  num = ReadVarInt(p, size, &len);
  if (num == 0) return false; p += num; size -= num;

  if (size != len)
    return false;

  link.NameLen = (unsigned)len;
  link.NameOffset = (unsigned)(p - Extra);
  return true;
}

bool CItem::Is_CopyLink() const
{
  CLinkInfo link;
  return FindExtra_Link(link) && link.Type == NLinkType::kFileCopy;
}

void CItem::Link_to_Prop(unsigned linkType, NWindows::NCOM::CPropVariant &prop) const
{
  CLinkInfo link;
  if (!FindExtra_Link(link))
    return;

  if (link.Type != linkType)
  {
    if (linkType != NLinkType::kUnixSymLink)
      return;
    switch ((unsigned)link.Type)
    {
      case NLinkType::kUnixSymLink:
      case NLinkType::kWinSymLink:
      case NLinkType::kWinJunction:
        break;
      default: return;
    }
  }

  AString s;
  s.SetFrom_CalcLen((const char *)(Extra + link.NameOffset), link.NameLen);

  UString unicode;
  if (ConvertUTF8ToUnicode(s, unicode))
    prop = NItemName::GetOSName(unicode);
}

bool CItem::GetAltStreamName(AString &name) const
{
  name.Empty();
  unsigned size;
  int offset = FindExtra(NExtraRecordType::kSubdata, size);
  if (offset < 0)
    return false;
  name.SetFrom_CalcLen((const char *)(Extra + (unsigned)offset), size);
  return true;
}


class CHash
{
  bool _calcCRC;
  UInt32 _crc;
  int _blakeOffset;
  CBlake2sp _blake;
public:

  void Init_NoCalc()
  {
    _calcCRC = false;
    _crc = CRC_INIT_VAL;
    _blakeOffset = -1;
  }

  void Init(const CItem &item);
  void Update(const void *data, size_t size);
  UInt32 GetCRC() const { return CRC_GET_DIGEST(_crc); }

  bool Check(const CItem &item, NCrypto::NRar5::CDecoder *cryptoDecoderSpec);
};

void CHash::Init(const CItem &item)
{
  _crc = CRC_INIT_VAL;
  _calcCRC = item.Has_CRC();
  
  _blakeOffset = item.FindExtra_Blake();
  if (_blakeOffset >= 0)
    Blake2sp_Init(&_blake);
}

void CHash::Update(const void *data, size_t size)
{
  if (_calcCRC)
    _crc = CrcUpdate(_crc, data, size);
  if (_blakeOffset >= 0)
    Blake2sp_Update(&_blake, (const Byte *)data, size);
}

bool CHash::Check(const CItem &item, NCrypto::NRar5::CDecoder *cryptoDecoderSpec)
{
  if (_calcCRC)
  {
    UInt32 crc = GetCRC();
    if (cryptoDecoderSpec)
      crc = cryptoDecoderSpec->Hmac_Convert_Crc32(crc);
    if (crc != item.CRC)
      return false;
  }
    
  if (_blakeOffset >= 0)
  {
    Byte digest[BLAKE2S_DIGEST_SIZE];
    Blake2sp_Final(&_blake, digest);
    if (cryptoDecoderSpec)
      cryptoDecoderSpec->Hmac_Convert_32Bytes(digest);
    if (memcmp(digest, &item.Extra[(unsigned)_blakeOffset], BLAKE2S_DIGEST_SIZE) != 0)
      return false;
  }

  return true;
}


class COutStreamWithHash:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  ISequentialOutStream *_stream;
  UInt64 _pos;
  UInt64 _size;
  bool _size_Defined;
  Byte *_destBuf;
public:
  CHash _hash;

  COutStreamWithHash(): _destBuf(NULL) {}

  MY_UNKNOWN_IMP
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  void SetStream(ISequentialOutStream *stream) { _stream = stream; }
  void Init(const CItem &item, Byte *destBuf)
  {
    _size_Defined = false;
    _size = 0;
    _destBuf = NULL;
    if (!item.Is_UnknownSize())
    {
      _size_Defined = true;
      _size = item.Size;
      _destBuf = destBuf;
    }
    _pos = 0;
    _hash.Init(item);
  }
  UInt64 GetPos() const { return _pos; }
};


STDMETHODIMP COutStreamWithHash::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  HRESULT result = S_OK;
  if (_size_Defined)
  {
    UInt64 rem = _size - _pos;
    if (size > rem)
      size = (UInt32)rem;
  }
  if (_stream)
    result = _stream->Write(data, size, &size);
  if (_destBuf)
    memcpy(_destBuf + (size_t)_pos, data, size);
  _hash.Update(data, size);
  _pos += size;
  if (processedSize)
    *processedSize = size;
  return result;
}





class CInArchive
{
  CAlignedBuffer<AES_BLOCK_SIZE - 1> _buf;
  size_t _bufSize;
  size_t _bufPos;
  ISequentialInStream *_stream;

  NCrypto::NRar5::CDecoder *m_CryptoDecoderSpec;
  CMyComPtr<ICompressFilter> m_CryptoDecoder;



  HRESULT ReadStream_Check(void *data, size_t size);

public:
  bool m_CryptoMode;

  bool WrongPassword;
  bool IsArc;
  bool UnexpectedEnd;

  UInt64 StreamStartPosition;
  UInt64 Position;
    
  bool ReadVar(UInt64 &val);

  struct CHeader
  {
    UInt64 Type;
    UInt64 Flags;
    size_t ExtraSize;
    UInt64 DataSize;
  };

  HRESULT ReadBlockHeader(CHeader &h);
  bool ReadFileHeader(const CHeader &header, CItem &item);
  void AddToSeekValue(UInt64 addValue)
  {
    Position += addValue;
  }

  HRESULT Open(IInStream *inStream, const UInt64 *searchHeaderSizeLimit, ICryptoGetTextPassword *getTextPassword,
      CInArcInfo &info);
};
  

static HRESULT MySetPassword(ICryptoGetTextPassword *getTextPassword, NCrypto::NRar5::CDecoder *cryptoDecoderSpec)
{
  CMyComBSTR password;
  RINOK(getTextPassword->CryptoGetTextPassword(&password));
  AString utf8;
  const unsigned kPasswordLen_MAX = 127;
  UString unicode = (LPCOLESTR)password;
  if (unicode.Len() > kPasswordLen_MAX)
    unicode.DeleteFrom(kPasswordLen_MAX);
  ConvertUnicodeToUTF8(unicode, utf8);
  cryptoDecoderSpec->SetPassword((const Byte *)(const char *)utf8, utf8.Len());
  return S_OK;
}


bool CInArchive::ReadVar(UInt64 &val)
{
  unsigned offset = ReadVarInt(_buf + _bufPos, _bufSize - _bufPos, &val);
  _bufPos += offset;
  return (offset != 0);
}


HRESULT CInArchive::ReadStream_Check(void *data, size_t size)
{
  size_t size2 = size;
  RINOK(ReadStream(_stream, data, &size2));
  if (size2 == size)
    return S_OK;
  UnexpectedEnd = true;
  return S_FALSE;
}


HRESULT CInArchive::ReadBlockHeader(CHeader &h)
{
  h.Type = 0;
  h.Flags = 0;
  h.ExtraSize = 0;
  h.DataSize = 0;

  const unsigned kStartSize = 4 + 3;
  const unsigned kBufSize = AES_BLOCK_SIZE + AES_BLOCK_SIZE; // must be >= kStartSize;
  Byte buf[kBufSize];
  unsigned filled;
  
  if (m_CryptoMode)
  {
    RINOK(ReadStream_Check(buf, kBufSize));
    memcpy(m_CryptoDecoderSpec->_iv, buf, AES_BLOCK_SIZE);
    RINOK(m_CryptoDecoderSpec->Init());

    _buf.AllocAtLeast(1 << 12);
    if (!(Byte *)_buf)
      return E_OUTOFMEMORY;

    memcpy(_buf, buf + AES_BLOCK_SIZE, AES_BLOCK_SIZE);
    if (m_CryptoDecoderSpec->Filter(_buf, AES_BLOCK_SIZE) != AES_BLOCK_SIZE)
      return E_FAIL;
    memcpy(buf, _buf, AES_BLOCK_SIZE);
    filled = AES_BLOCK_SIZE;
  }
  else
  {
    RINOK(ReadStream_Check(buf, kStartSize));
    filled = kStartSize;
  }
  
  UInt64 val;
  unsigned offset = ReadVarInt(buf + 4, 3, &val);
  if (offset == 0)
    return S_FALSE;
  {
    size_t size = (size_t)val;
    _bufPos = (4 + offset);
    _bufSize = _bufPos + size;
    if (size < 2)
      return S_FALSE;
  }
  
  size_t allocSize = _bufSize;
  if (m_CryptoMode)
    allocSize = (allocSize + AES_BLOCK_SIZE - 1) & ~(size_t)(AES_BLOCK_SIZE - 1);
  _buf.AllocAtLeast(allocSize);
  if (!(Byte *)_buf)
    return E_OUTOFMEMORY;
  
  memcpy(_buf, buf, filled);

  size_t rem = allocSize - filled;
  AddToSeekValue(allocSize + (m_CryptoMode ? AES_BLOCK_SIZE : 0));
  RINOK(ReadStream_Check(_buf + filled, rem));
  if (m_CryptoMode)
  {
    if (m_CryptoDecoderSpec->Filter(_buf + filled, (UInt32)rem) != rem)
      return E_FAIL;
  }

  if (CrcCalc(_buf + 4, _bufSize - 4) != Get32(buf))
    return S_FALSE;

  if (!ReadVar(h.Type)) return S_FALSE;
  if (!ReadVar(h.Flags)) return S_FALSE;

  if (h.Flags & NHeaderFlags::kExtra)
  {
    UInt64 extraSize;
    if (!ReadVar(extraSize))
      return S_FALSE;
    if (extraSize > _bufSize)
      return S_FALSE;
    h.ExtraSize = (size_t)extraSize;
  }
  
  if (h.Flags & NHeaderFlags::kData)
  {
    if (!ReadVar(h.DataSize))
      return S_FALSE;
  }
  
  return S_OK;
}


/*
int CInArcInfo::FindExtra(unsigned type, unsigned &recordDataSize) const
{
  recordDataSize = 0;
  size_t offset = 0;

  for (;;)
  {
    size_t rem = Extra.Size() - offset;
    if (rem == 0)
      return -1;
    
    {
      UInt64 size;
      unsigned num = ReadVarInt(Extra + offset, rem, &size);
      if (num == 0)
        return -1;
      offset += num;
      rem -= num;
      if (size > rem)
        return -1;
      rem = (size_t)size;
    }
    {
      UInt64 type2;
      unsigned num = ReadVarInt(Extra + offset, rem, &type2);
      if (num == 0)
        return -1;
      offset += num;
      rem -= num;

      if (type2 == type)
      {
        recordDataSize = (unsigned)rem;
        return (int)offset;
      }

      offset += rem;
    }
  }
}


bool CInArcInfo::FindExtra_Locator(CLocator &locator) const
{
  locator.Flags = 0;
  locator.QuickOpen = 0;
  locator.Recovery = 0;

  unsigned size;
  int offset = FindExtra(kArcExtraRecordType_Locator, size);
  if (offset < 0)
    return false;
  const Byte *p = Extra + (unsigned)offset;

  unsigned num;

  num = ReadVarInt(p, size, &locator.Flags);
  if (num == 0) return false; p += num; size -= num;

  if (locator.Is_QuickOpen())
  {
    num = ReadVarInt(p, size, &locator.QuickOpen);
    if (num == 0) return false; p += num; size -= num;
  }

  if (locator.Is_Recovery())
  {
    num = ReadVarInt(p, size, &locator.Recovery);
    if (num == 0) return false; p += num; size -= num;
  }

  return true;
}
*/


HRESULT CInArchive::Open(IInStream *stream, const UInt64 *searchHeaderSizeLimit, ICryptoGetTextPassword *getTextPassword,
    CInArcInfo &info)
{
  m_CryptoMode = false;
  
  WrongPassword = false;
  IsArc = false;
  UnexpectedEnd = false;

  Position = StreamStartPosition;

  UInt64 arcStartPos = StreamStartPosition;
  {
    Byte marker[kMarkerSize];
    RINOK(ReadStream_FALSE(stream, marker, kMarkerSize));
    if (memcmp(marker, kMarker, kMarkerSize) == 0)
      Position += kMarkerSize;
    else
    {
      if (searchHeaderSizeLimit && *searchHeaderSizeLimit == 0)
        return S_FALSE;
      RINOK(stream->Seek(StreamStartPosition, STREAM_SEEK_SET, NULL));
      RINOK(FindSignatureInStream(stream, kMarker, kMarkerSize,
          searchHeaderSizeLimit, arcStartPos));
      arcStartPos += StreamStartPosition;
      Position = arcStartPos + kMarkerSize;
      RINOK(stream->Seek(Position, STREAM_SEEK_SET, NULL));
    }
  }

  info.StartPos = arcStartPos;
  _stream = stream;

  CHeader h;
  RINOK(ReadBlockHeader(h));
  info.IsEncrypted = false;
  
  if (h.Type == NHeaderType::kArcEncrypt)
  {
    info.IsEncrypted = true;
    IsArc = true;
    if (!getTextPassword)
      return E_NOTIMPL;

    m_CryptoMode = true;
    
    if (!m_CryptoDecoder)
    {
      m_CryptoDecoderSpec = new NCrypto::NRar5::CDecoder;
      m_CryptoDecoder = m_CryptoDecoderSpec;
    }

    RINOK(m_CryptoDecoderSpec->SetDecoderProps(
        _buf + _bufPos, (unsigned)(_bufSize - _bufPos), false, false));

    RINOK(MySetPassword(getTextPassword, m_CryptoDecoderSpec));

    if (!m_CryptoDecoderSpec->CalcKey_and_CheckPassword())
    {
      WrongPassword = True;
      return S_FALSE;
    }

    RINOK(ReadBlockHeader(h));
  }

  if (h.Type != NHeaderType::kArc)
    return S_FALSE;

  IsArc = true;
  info.VolNumber = 0;
  
  if (!ReadVar(info.Flags))
    return S_FALSE;
  
  if (info.Flags & NArcFlags::kVolNumber)
    if (!ReadVar(info.VolNumber))
      return S_FALSE;
  
  if (h.ExtraSize != 0)
  {
    if (_bufSize - _bufPos < h.ExtraSize)
      return S_FALSE;
    /*
    info.Extra.Alloc(h.ExtraSize);
    memcpy(info.Extra, _buf + _bufPos, h.ExtraSize);
    */
    _bufPos += h.ExtraSize;

    /*
    CInArcInfo::CLocator locator;
    if (info.FindExtra_Locator(locator))
      locator.Flags = locator.Flags;
    */
  }

  if (_bufPos != _bufSize)
    return S_FALSE;

  return S_OK;
}


bool CInArchive::ReadFileHeader(const CHeader &header, CItem &item)
{
  item.UnixMTime = 0;
  item.CRC = 0;
  item.Flags = 0;
  
  item.CommonFlags = (UInt32)header.Flags;
  item.PackSize = header.DataSize;

  UInt64 flags64;
  if (!ReadVar(flags64)) return false;
  item.Flags = (UInt32)flags64;

  if (!ReadVar(item.Size)) return false;
  
  {
    UInt64 attrib;
    if (!ReadVar(attrib)) return false;
    item.Attrib = (UInt32)attrib;
  }

  if (item.Has_UnixMTime())
  {
    if (_bufSize - _bufPos < 4)
      return false;
    item.UnixMTime = Get32(_buf + _bufPos);
    _bufPos += 4;
  }

  if (item.Has_CRC())
  {
    if (_bufSize - _bufPos < 4)
      return false;
    item.CRC = Get32(_buf + _bufPos);
    _bufPos += 4;
  }

  {
    UInt64 method;
    if (!ReadVar(method)) return false;
    item.Method = (UInt32)method;
  }

  if (!ReadVar(item.HostOS)) return false;

  {
    UInt64 len;
    if (!ReadVar(len)) return false;
    if (len > _bufSize - _bufPos)
      return false;
    item.Name.SetFrom_CalcLen((const char *)(_buf + _bufPos), (unsigned)len);
    _bufPos += (unsigned)len;
  }
  
  item.Extra.Free();
  size_t extraSize = header.ExtraSize;
  if (extraSize != 0)
  {
    if (_bufSize - _bufPos < extraSize)
      return false;
    item.Extra.Alloc(extraSize);
    memcpy(item.Extra, _buf + _bufPos, extraSize);
    _bufPos += extraSize;
  }

  
  return (_bufPos == _bufSize);
}



struct CLinkFile
{
  unsigned Index;
  unsigned NumLinks;
  CByteBuffer Data;
  HRESULT Res;
  bool crcOK;

  CLinkFile(): Index(0), NumLinks(0), Res(S_OK), crcOK(true) {}
};


struct CUnpacker
{
  NCompress::CCopyCoder *copyCoderSpec;
  CMyComPtr<ICompressCoder> copyCoder;
  
  CMyComPtr<ICompressCoder> LzCoders[2];
  bool NeedClearSolid[2];

  CFilterCoder *filterStreamSpec;
  CMyComPtr<ISequentialInStream> filterStream;

  NCrypto::NRar5::CDecoder *cryptoDecoderSpec;
  CMyComPtr<ICompressFilter> cryptoDecoder;

  CMyComPtr<ICryptoGetTextPassword> getTextPassword;

  COutStreamWithHash *outStreamSpec;
  CMyComPtr<ISequentialOutStream> outStream;

  CByteBuffer _tempBuf;

  CLinkFile *linkFile;

  CUnpacker(): linkFile(NULL) { NeedClearSolid[0] = NeedClearSolid[1] = true; }

  HRESULT Create(DECL_EXTERNAL_CODECS_LOC_VARS const CItem &item, bool isSolid, bool &wrongPassword);

  HRESULT Code(const CItem &item, const CItem &lastItem, UInt64 packSize,
      ISequentialInStream *inStream, ISequentialOutStream *outStream, ICompressProgressInfo *progress,
      bool &isCrcOK);

  HRESULT DecodeToBuf(DECL_EXTERNAL_CODECS_LOC_VARS const CItem &item, UInt64 packSize, ISequentialInStream *inStream, CByteBuffer &buffer);
};


static const unsigned kLzMethodMax = 5;

HRESULT CUnpacker::Create(DECL_EXTERNAL_CODECS_LOC_VARS const CItem &item, bool isSolid, bool &wrongPassword)
{
  wrongPassword = false;

  if (item.GetAlgoVersion() != 0)
    return E_NOTIMPL;

  if (!outStream)
  {
    outStreamSpec = new COutStreamWithHash;
    outStream = outStreamSpec;
  }

  unsigned method = item.GetMethod();

  if (method == 0)
  {
    if (!copyCoder)
    {
      copyCoderSpec = new NCompress::CCopyCoder;
      copyCoder = copyCoderSpec;
    }
  }
  else
  {
    if (method > kLzMethodMax)
      return E_NOTIMPL;

    /*
    if (item.IsSplitBefore())
      return S_FALSE;
    */

    int lzIndex = item.IsService() ? 1 : 0;
    CMyComPtr<ICompressCoder> &lzCoder = LzCoders[lzIndex];
  
    if (!lzCoder)
    {
      const UInt32 methodID = 0x40305;
      RINOK(CreateCoder(EXTERNAL_CODECS_LOC_VARS methodID, false, lzCoder));
      if (!lzCoder)
        return E_NOTIMPL;
    }

    CMyComPtr<ICompressSetDecoderProperties2> csdp;
    RINOK(lzCoder.QueryInterface(IID_ICompressSetDecoderProperties2, &csdp));

    Byte props[2] = { (Byte)(item.GetDictSize()), (Byte)(isSolid ? 1 : 0) };
    RINOK(csdp->SetDecoderProperties2(props, 2));
  }

  unsigned cryptoSize = 0;
  int cryptoOffset = item.FindExtra(NExtraRecordType::kCrypto, cryptoSize);

  if (cryptoOffset >= 0)
  {
    if (!filterStream)
    {
      filterStreamSpec = new CFilterCoder(false);
      filterStream = filterStreamSpec;
    }

    if (!cryptoDecoder)
    {
      cryptoDecoderSpec = new NCrypto::NRar5::CDecoder;
      cryptoDecoder = cryptoDecoderSpec;
    }

    RINOK(cryptoDecoderSpec->SetDecoderProps(item.Extra + (unsigned)cryptoOffset, cryptoSize, true, item.IsService()));

    if (!getTextPassword)
    {
      wrongPassword = True;
      return E_NOTIMPL;
    }

    RINOK(MySetPassword(getTextPassword, cryptoDecoderSpec));
      
    if (!cryptoDecoderSpec->CalcKey_and_CheckPassword())
      wrongPassword = True;
  }

  return S_OK;
}


HRESULT CUnpacker::Code(const CItem &item, const CItem &lastItem, UInt64 packSize,
    ISequentialInStream *volsInStream, ISequentialOutStream *realOutStream, ICompressProgressInfo *progress,
    bool &isCrcOK)
{
  isCrcOK = true;

  unsigned method = item.GetMethod();
  if (method > kLzMethodMax)
    return E_NOTIMPL;

  if (linkFile && !lastItem.Is_UnknownSize())
  {
    size_t dataSize = (size_t)lastItem.Size;
    if (dataSize != lastItem.Size)
      return E_NOTIMPL;
    linkFile->Data.Alloc(dataSize);
  }

  bool isCryptoMode = false;
  ISequentialInStream *inStream;

  if (item.IsEncrypted())
  {
    filterStreamSpec->Filter = cryptoDecoder;
    filterStreamSpec->SetInStream(volsInStream);
    filterStreamSpec->SetOutStreamSize(NULL);
    inStream = filterStream;
    isCryptoMode = true;
  }
  else
    inStream = volsInStream;

  ICompressCoder *commonCoder = (method == 0) ? copyCoder : LzCoders[item.IsService() ? 1 : 0];

  outStreamSpec->SetStream(realOutStream);
  outStreamSpec->Init(lastItem, (linkFile ? (Byte *)linkFile->Data : NULL));

  NeedClearSolid[item.IsService() ? 1 : 0] = false;

  HRESULT res = S_OK;
  if (packSize != 0 || lastItem.Is_UnknownSize() || lastItem.Size != 0)
  {
    res = commonCoder->Code(inStream, outStream, &packSize,
      lastItem.Is_UnknownSize() ? NULL : &lastItem.Size, progress);
  }
  else
  {
    res = res;
  }

  if (isCryptoMode)
    filterStreamSpec->ReleaseInStream();

  UInt64 processedSize = outStreamSpec->GetPos();
  if (res == S_OK && !lastItem.Is_UnknownSize() && processedSize != lastItem.Size)
    res = S_FALSE;

  // if (res == S_OK)
  {
    unsigned cryptoSize = 0;
    int cryptoOffset = lastItem.FindExtra(NExtraRecordType::kCrypto, cryptoSize);
    NCrypto::NRar5::CDecoder *crypto = NULL;

    if (cryptoOffset >= 0)
    {
      CCryptoInfo cryptoInfo;
      if (cryptoInfo.Parse(lastItem.Extra + (unsigned)cryptoOffset, cryptoSize))
        if (cryptoInfo.UseMAC())
          crypto = cryptoDecoderSpec;
    }
    
    isCrcOK = outStreamSpec->_hash.Check(lastItem, crypto);
  }

  if (linkFile)
  {
    linkFile->Res = res;
    linkFile->crcOK = isCrcOK;
    if (!lastItem.Is_UnknownSize() && processedSize != lastItem.Size)
      linkFile->Data.ChangeSize_KeepData((size_t)processedSize, (size_t)processedSize);
  }

  return res;
}


HRESULT CUnpacker::DecodeToBuf(DECL_EXTERNAL_CODECS_LOC_VARS const CItem &item, UInt64 packSize, ISequentialInStream *inStream, CByteBuffer &buffer)
{
  CBufPtrSeqOutStream *outSpec = new CBufPtrSeqOutStream;
  CMyComPtr<ISequentialOutStream> out = outSpec;
  _tempBuf.AllocAtLeast((size_t)item.Size);
  outSpec->Init(_tempBuf, (size_t)item.Size);

  bool wrongPassword;

  if (item.IsSolid())
    return E_NOTIMPL;

  HRESULT res = Create(EXTERNAL_CODECS_LOC_VARS item, item.IsSolid(), wrongPassword);
  
  if (res == S_OK)
  {
    if (wrongPassword)
      return S_FALSE;

    CLimitedSequentialInStream *limitedStreamSpec = new CLimitedSequentialInStream;
    CMyComPtr<ISequentialInStream> limitedStream(limitedStreamSpec);
    limitedStreamSpec->SetStream(inStream);
    limitedStreamSpec->Init(packSize);

    bool crcOK = true;
    res = Code(item, item, packSize, limitedStream, out, NULL, crcOK);
    if (res == S_OK)
    {
      if (!crcOK || outSpec->GetPos() != item.Size)
        res = S_FALSE;
      else
        buffer.CopyFrom(_tempBuf, (size_t)item.Size);
    }
  }
  
  return res;
}


struct CTempBuf
{
  CByteBuffer _buf;
  size_t _offset;
  bool _isOK;

  void Clear()
  {
    _offset = 0;
    _isOK = true;
  }

  CTempBuf() { Clear(); }

  HRESULT Decode(DECL_EXTERNAL_CODECS_LOC_VARS
      const CItem &item,
      ISequentialInStream *inStream, CUnpacker &unpacker, CByteBuffer &destBuf);
};


HRESULT CTempBuf::Decode(DECL_EXTERNAL_CODECS_LOC_VARS
    const CItem &item,
    ISequentialInStream *inStream,
    CUnpacker &unpacker,
    CByteBuffer &destBuf)
{
  const size_t kPackSize_Max = (1 << 24);
  if (item.Size > (1 << 24)
      || item.Size == 0
      || item.PackSize >= kPackSize_Max)
  {
    Clear();
    return S_OK;
  }

  if (item.IsSplit() /* && _isOK */)
  {
    size_t packSize = (size_t)item.PackSize;
    if (packSize > kPackSize_Max - _offset)
      return S_OK;
    size_t newSize = _offset + packSize;
    if (newSize > _buf.Size())
      _buf.ChangeSize_KeepData(newSize, _offset);
    
    Byte *data = (Byte *)_buf + _offset;
    RINOK(ReadStream_FALSE(inStream, data, packSize));
    
    _offset += packSize;
    
    if (item.IsSplitAfter())
    {
      CHash hash;
      hash.Init(item);
      hash.Update(data, packSize);
      _isOK = hash.Check(item, NULL); // RAR5 doesn't use HMAC for packed part
    }
  }
  
  if (_isOK)
  {
    if (!item.IsSplitAfter())
    {
      if (_offset == 0)
      {
        RINOK(unpacker.DecodeToBuf(EXTERNAL_CODECS_LOC_VARS
            item, item.PackSize, inStream, destBuf));
      }
      else
      {
        CBufInStream *bufInStreamSpec = new CBufInStream;
        CMyComPtr<ISequentialInStream> bufInStream = bufInStreamSpec;
        bufInStreamSpec->Init(_buf, _offset);
        RINOK(unpacker.DecodeToBuf(EXTERNAL_CODECS_LOC_VARS
            item, _offset, bufInStream, destBuf));
      }
    }
  }

  return S_OK;
}



static const Byte kProps[] =
{
  kpidPath,
  kpidIsDir,
  kpidSize,
  kpidPackSize,
  kpidMTime,
  kpidCTime,
  kpidATime,
  kpidAttrib,

  kpidIsAltStream,
  kpidEncrypted,
  kpidSolid,
  kpidSplitBefore,
  kpidSplitAfter,
  kpidCRC,
  kpidHostOS,
  kpidMethod,

  kpidSymLink,
  kpidHardLink,
  kpidCopyLink,
};


static const Byte kArcProps[] =
{
  kpidTotalPhySize,
  kpidCharacts,
  kpidSolid,
  kpidNumBlocks,
  kpidEncrypted,
  kpidIsVolume,
  kpidVolumeIndex,
  kpidNumVolumes,
  kpidComment
};


IMP_IInArchive_Props
IMP_IInArchive_ArcProps


UInt64 CHandler::GetPackSize(unsigned refIndex) const
{
  UInt64 size = 0;
  unsigned index = _refs[refIndex].Item;
  for (;;)
  {
    const CItem &item = _items[index];
    size += item.PackSize;
    if (item.NextItem < 0)
      return size;
    index = item.NextItem;
  }
}


STDMETHODIMP CHandler::GetArchiveProperty(PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN

  NCOM::CPropVariant prop;

  const CInArcInfo *arcInfo = NULL;
  if (!_arcs.IsEmpty())
    arcInfo = &_arcs[0].Info;

  switch (propID)
  {
    case kpidVolumeIndex: if (arcInfo && arcInfo->IsVolume()) prop = arcInfo->GetVolIndex(); break;
    case kpidSolid: if (arcInfo) prop = arcInfo->IsSolid(); break;
    case kpidCharacts:
    {
      if (!_arcs.IsEmpty())
      {
        FLAGS_TO_PROP(k_ArcFlags, (UInt32)arcInfo->Flags, prop);
      }
      break;
    }
    case kpidEncrypted: if (arcInfo) prop = arcInfo->IsEncrypted; break; // it's for encrypted names.
    case kpidIsVolume: if (arcInfo) prop = arcInfo->IsVolume(); break;
    case kpidNumVolumes: prop = (UInt32)_arcs.Size(); break;
    case kpidOffset: if (arcInfo && arcInfo->StartPos != 0) prop = arcInfo->StartPos; break;

    case kpidTotalPhySize:
    {
      if (_arcs.Size() > 1)
      {
        UInt64 sum = 0;
        FOR_VECTOR (v, _arcs)
          sum += _arcs[v].Info.GetPhySize();
        prop = sum;
      }
      break;
    }

    case kpidPhySize:
    {
      if (arcInfo)
        prop = arcInfo->GetPhySize();
      break;
    }

    case kpidComment:
    {
      // if (!_arcs.IsEmpty())
      {
        // const CArc &arc = _arcs[0];
        const CByteBuffer &cmt = _comment;
        if (cmt.Size() != 0 && cmt.Size() < (1 << 16))
        {
          AString s;
          s.SetFrom_CalcLen((const char *)(const Byte *)cmt, (unsigned)cmt.Size());
          UString unicode;
          if (ConvertUTF8ToUnicode(s, unicode))
            prop = unicode;
        }
      }
      break;
    }

    case kpidNumBlocks:
    {
      UInt32 numBlocks = 0;
      FOR_VECTOR (i, _refs)
        if (!_items[_refs[i].Item].IsSolid())
          numBlocks++;
      prop = (UInt32)numBlocks;
      break;
    }
    
    case kpidError:
    {
      if (/* &_missingVol || */ !_missingVolName.IsEmpty())
      {
        UString s;
        s.SetFromAscii("Missing volume : ");
        s += _missingVolName;
        prop = s;
      }
      break;
    }

    case kpidErrorFlags:
    {
      UInt32 v = _errorFlags;
      if (!_isArc)
        v |= kpv_ErrorFlags_IsNotArc;
      prop = v;
      break;
    }

    /*
    case kpidWarningFlags:
    {
      if (_warningFlags != 0)
        prop = _warningFlags;
      break;
    }
    */

    case kpidExtension:
      if (_arcs.Size() == 1)
      {
        if (arcInfo->IsVolume())
        {
          char sz[32];
          ConvertUInt64ToString(arcInfo->GetVolIndex() + 1, sz);
          unsigned len = MyStringLen(sz);
          AString s = "part";
          for (; len < 2; len++)
            s += '0';
          s += sz;
          s += ".rar";
          prop = s;
        }
      }
      break;

    case kpidIsAltStream: prop = true; break;
  }

  prop.Detach(value);
  return S_OK;
  
  COM_TRY_END
}


STDMETHODIMP CHandler::GetNumberOfItems(UInt32 *numItems)
{
  *numItems = _refs.Size();
  return S_OK;
}


static const Byte kRawProps[] =
{
  kpidChecksum,
  kpidNtSecure
};


STDMETHODIMP CHandler::GetNumRawProps(UInt32 *numProps)
{
  *numProps = ARRAY_SIZE(kRawProps);
  return S_OK;
}

STDMETHODIMP CHandler::GetRawPropInfo(UInt32 index, BSTR *name, PROPID *propID)
{
  *propID = kRawProps[index];
  *name = 0;
  return S_OK;
}

STDMETHODIMP CHandler::GetParent(UInt32 index, UInt32 *parent, UInt32 *parentType)
{
  *parentType = NParentType::kDir;
  *parent = (UInt32)(Int32)-1;

  if (index >= _refs.Size())
    return S_OK;

  const CRefItem &ref = _refs[index];
  const CItem &item = _items[ref.Item];

  if (item.Is_STM() && ref.Parent >= 0)
  {
    *parent = (UInt32)ref.Parent;
    *parentType = NParentType::kAltStream;
  }

  return S_OK;
}


STDMETHODIMP CHandler::GetRawProp(UInt32 index, PROPID propID, const void **data, UInt32 *dataSize, UInt32 *propType)
{
  *data = NULL;
  *dataSize = 0;
  *propType = 0;

  if (index >= _refs.Size())
    return E_INVALIDARG;

  const CItem &item = _items[_refs[index].Item];

  if (propID == kpidNtSecure)
  {
    if (item.ACL >= 0)
    {
      const CByteBuffer &buf = _acls[item.ACL];
      *dataSize = (UInt32)buf.Size();
      *propType = NPropDataType::kRaw;
      *data = (const Byte *)buf;
    }
    return S_OK;
  }
  
  if (propID == kpidChecksum)
  {
    int hashRecOffset = item.FindExtra_Blake();
    if (hashRecOffset >= 0)
    {
      *dataSize = BLAKE2S_DIGEST_SIZE;
      *propType = NPropDataType::kRaw;
      *data = &item.Extra[hashRecOffset];
    }
    return S_OK;
  }
  
  return S_OK;
}


static void TimeRecordToProp(const CItem &item, unsigned stampIndex, NCOM::CPropVariant &prop)
{
  unsigned size;
  int offset = item.FindExtra(NExtraRecordType::kTime, size);
  if (offset < 0)
    return;

  const Byte *p = item.Extra + (unsigned)offset;
  UInt64 flags;
  {
    unsigned num = ReadVarInt(p, size, &flags);
    if (num == 0)
      return;
    p += num;
    size -= num;
  }

  if ((flags & (NTimeRecord::NFlags::kMTime << stampIndex)) == 0)
    return;
  
  unsigned numStamps = 0;
  unsigned i;
  for (i = 0; i < 3; i++)
    if ((flags & (NTimeRecord::NFlags::kMTime << i)) != 0)
      numStamps++;
  unsigned stampSizeLog = ((flags & NTimeRecord::NFlags::kUnixTime) != 0) ? 2 : 3;
  
  if ((numStamps << stampSizeLog) != size)
    return;
  
  numStamps = 0;
  for (i = 0; i < stampIndex; i++)
    if ((flags & (NTimeRecord::NFlags::kMTime << i)) != 0)
      numStamps++;

  p += (numStamps << stampSizeLog);

  FILETIME ft;
  if ((flags & NTimeRecord::NFlags::kUnixTime) != 0)
    NWindows::NTime::UnixTimeToFileTime(Get32(p), ft);
  else
  {
    ft.dwLowDateTime = Get32(p);
    ft.dwHighDateTime = Get32(p + 4);
  }
  
  prop = ft;
}


STDMETHODIMP CHandler::GetProperty(UInt32 index, PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  
  NCOM::CPropVariant prop;
  const CRefItem &ref = _refs[index];
  const CItem &item = _items[ref.Item];
  const CItem &lastItem = _items[ref.Last];

  switch (propID)
  {
    case kpidPath:
    {
      UString unicodeName;
      
      if (item.Is_STM())
      {
        AString s;
        if (ref.Parent >= 0)
        {
          CItem &mainItem = _items[_refs[ref.Parent].Item];
          s = mainItem.Name;
        }

        AString name;
        item.GetAltStreamName(name);
        if (name[0] != ':')
          s += ':';
        s += name;
        if (!ConvertUTF8ToUnicode(s, unicodeName))
          break;
      }
      else
      {
        if (!ConvertUTF8ToUnicode(item.Name, unicodeName))
          break;
        if (item.Version_Defined)
        {
          wchar_t temp[32];
          // temp[0] = ';';
          // ConvertUInt64ToString(item.Version, temp + 1);
          // unicodeName += temp;
          ConvertUInt64ToString(item.Version, temp);
          UString s2 = L"[VER]" WSTRING_PATH_SEPARATOR;
          s2 += temp;
          s2.Add_PathSepar();
          unicodeName.Insert(0, s2);
        }
      }
      
      NItemName::ConvertToOSName2(unicodeName);
      prop = unicodeName;

      break;
    }
    
    case kpidIsDir: prop = item.IsDir(); break;
    case kpidSize: if (!lastItem.Is_UnknownSize()) prop = lastItem.Size; break;
    case kpidPackSize: prop = GetPackSize(index); break;
    
    case kpidMTime:
    {
      TimeRecordToProp(item, NTimeRecord::k_Index_MTime, prop);
      if (prop.vt == VT_EMPTY && item.Has_UnixMTime())
      {
        FILETIME ft;
        NWindows::NTime::UnixTimeToFileTime(item.UnixMTime, ft);
        prop = ft;
      }
      if (prop.vt == VT_EMPTY && ref.Parent >= 0)
      {
        const CItem &baseItem = _items[_refs[ref.Parent].Item];
        TimeRecordToProp(baseItem, NTimeRecord::k_Index_MTime, prop);
        if (prop.vt == VT_EMPTY && baseItem.Has_UnixMTime())
        {
          FILETIME ft;
          NWindows::NTime::UnixTimeToFileTime(baseItem.UnixMTime, ft);
          prop = ft;
        }
      }
      break;
    }
    case kpidCTime: TimeRecordToProp(item, NTimeRecord::k_Index_CTime, prop); break;
    case kpidATime: TimeRecordToProp(item, NTimeRecord::k_Index_ATime, prop); break;

    case kpidName:
    {
      if (item.Is_STM())
      {
        AString name;
        item.GetAltStreamName(name);
        if (name[0] == ':')
        {
          name.DeleteFrontal(1);
          UString unicodeName;
          if (ConvertUTF8ToUnicode(name, unicodeName))
            prop = unicodeName;
        }
      }
      break;
    }

    case kpidIsAltStream: prop = item.Is_STM(); break;

    case kpidSymLink: item.Link_to_Prop(NLinkType::kUnixSymLink, prop); break;
    case kpidHardLink: item.Link_to_Prop(NLinkType::kHardLink, prop); break;
    case kpidCopyLink: item.Link_to_Prop(NLinkType::kFileCopy, prop); break;

    case kpidAttrib: prop = item.GetWinAttrib(); break;
    case kpidEncrypted: prop = item.IsEncrypted(); break;
    case kpidSolid: prop = item.IsSolid(); break;

    case kpidSplitBefore: prop = item.IsSplitBefore(); break;
    case kpidSplitAfter: prop = lastItem.IsSplitAfter(); break;
    case kpidCRC:
    {
      const CItem *item2 = (lastItem.IsSplitAfter() ? &item : &lastItem);
      if (item2->Has_CRC())
        prop = item2->CRC;
      break;
    }

    case kpidMethod:
    {
      char temp[64];
      unsigned algo = item.GetAlgoVersion();
      char *s = temp;
      if (algo != 0)
      {
        ConvertUInt32ToString(algo, s);
        s += MyStringLen(s);
        *s++ = ':';
      }
      unsigned m = item.GetMethod();
      {
        s[0] = 'm';
        s[1] = (char)(m + '0');
        s[2] = 0;
        if (!item.IsDir())
        {
          s[2] = ':';
          ConvertUInt32ToString(item.GetDictSize() + 17, s + 3);
        }
      }

      unsigned cryptoSize = 0;
      int cryptoOffset = item.FindExtra(NExtraRecordType::kCrypto, cryptoSize);
      if (cryptoOffset >= 0)
      {
        s = temp + strlen(temp);
        *s++ = ' ';
        strcpy(s, "AES:");
        CCryptoInfo cryptoInfo;
        if (cryptoInfo.Parse(item.Extra + (unsigned)cryptoOffset, cryptoSize))
        {
          s += strlen(s);
          ConvertUInt32ToString(cryptoInfo.Cnt, s);
          s += strlen(s);
          *s++ = ':';
          ConvertUInt64ToString(cryptoInfo.Flags, s);
        }
      }

      prop = temp;
      break;
    }
    
    case kpidHostOS:
      if (item.HostOS < ARRAY_SIZE(kHostOS))
        prop = kHostOS[(size_t)item.HostOS];
      else
        prop = (UInt64)item.HostOS;
      break;
  }
  
  prop.Detach(value);
  return S_OK;
  
  COM_TRY_END
}



// ---------- Copy Links ----------

static int CompareItemsPaths(const CHandler &handler, unsigned p1, unsigned p2, const AString *name1)
{
  const CItem &item1 = handler._items[handler._refs[p1].Item];
  const CItem &item2 = handler._items[handler._refs[p2].Item];
  
  if (item1.Version_Defined)
  {
    if (!item2.Version_Defined)
      return -1;
    int res = MyCompare(item1.Version, item2.Version);
    if (res != 0)
      return res;
  }
  else if (item2.Version_Defined)
    return 1;

  if (!name1)
    name1 = &item1.Name;
  return strcmp(*name1, item2.Name);
}

static int CompareItemsPaths2(const CHandler &handler, unsigned p1, unsigned p2, const AString *name1)
{
  int res = CompareItemsPaths(handler, p1, p2, name1);
  if (res != 0)
    return res;
  return MyCompare(p1, p2);
}

static int CompareItemsPaths_Sort(const unsigned *p1, const unsigned *p2, void *param)
{
  return CompareItemsPaths2(*(const CHandler *)param, *p1, *p2, NULL);
}

static int FindLink(const CHandler &handler, const CUIntVector &sorted,
    const AString &s, unsigned index)
{
  unsigned left = 0, right = sorted.Size();
  for (;;)
  {
    if (left == right)
    {
      if (left > 0)
      {
        unsigned refIndex = sorted[left - 1];
        if (CompareItemsPaths(handler, index, refIndex, &s) == 0)
          return refIndex;
      }
      if (right < sorted.Size())
      {
        unsigned refIndex = sorted[right];
        if (CompareItemsPaths(handler, index, refIndex, &s) == 0)
          return refIndex;
      }
      return -1;
    }

    unsigned mid = (left + right) / 2;
    unsigned refIndex = sorted[mid];
    int compare = CompareItemsPaths2(handler, index, refIndex, &s);
    if (compare == 0)
      return refIndex;
    if (compare < 0)
      right = mid;
    else
      left = mid + 1;
  }
}

void CHandler::FillLinks()
{
  unsigned i;
  
  for (i = 0; i < _refs.Size(); i++)
  {
    const CItem &item = _items[_refs[i].Item];
    if (!item.IsDir() && !item.IsService() && item.NeedUse_as_CopyLink())
      break;
  }

  if (i == _refs.Size())
    return;
  
  CUIntVector sorted;
  for (i = 0; i < _refs.Size(); i++)
  {
    const CItem &item = _items[_refs[i].Item];
    if (!item.IsDir() && !item.IsService())
      sorted.Add(i);
  }
  
  if (sorted.IsEmpty())
    return;
  
  sorted.Sort(CompareItemsPaths_Sort, (void *)this);
  
  AString link;
  
  for (i = 0; i < _refs.Size(); i++)
  {
    CRefItem &ref = _refs[i];
    const CItem &item = _items[ref.Item];
    if (item.IsDir() || item.IsService() || item.PackSize != 0)
      continue;
    CItem::CLinkInfo linkInfo;
    if (!item.FindExtra_Link(linkInfo) || linkInfo.Type != NLinkType::kFileCopy)
      continue;
    link.SetFrom_CalcLen((const char *)(item.Extra + linkInfo.NameOffset), linkInfo.NameLen);
    int linkIndex = FindLink(*this, sorted, link, i);
    if (linkIndex < 0)
      continue;
    if ((unsigned)linkIndex >= i)
      continue; // we don't support forward links that can lead to loops
    const CRefItem &linkRef = _refs[linkIndex];
    const CItem &linkItem = _items[linkRef.Item];
    if (linkItem.Size == item.Size)
    {
      if (linkRef.Link >= 0)
        ref.Link = linkRef.Link;
      else if (!linkItem.NeedUse_as_CopyLink())
        ref.Link = linkIndex;
    }
  }
}



HRESULT CHandler::Open2(IInStream *stream,
    const UInt64 *maxCheckStartPosition,
    IArchiveOpenCallback *openCallback)
{
  CMyComPtr<IArchiveOpenVolumeCallback> openVolumeCallback;
  CMyComPtr<ICryptoGetTextPassword> getTextPassword;
  
  NRar::CVolumeName seqName;
  
  UInt64 totalBytes = 0;
  UInt64 curBytes = 0;
  
  if (openCallback)
  {
    openCallback->QueryInterface(IID_IArchiveOpenVolumeCallback, (void **)&openVolumeCallback);
    openCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&getTextPassword);
  }
  
  CTempBuf tempBuf;
  
  CUnpacker unpacker;
  unpacker.getTextPassword = getTextPassword;
  
  int prevSplitFile = -1;
  int prevMainFile = -1;
  
  bool nextVol_is_Required = false;

  CInArchive arch;
  
  for (;;)
  {
    CMyComPtr<IInStream> inStream;
    
    if (_arcs.IsEmpty())
      inStream = stream;
    else
    {
      if (!openVolumeCallback)
        break;
      
      if (_arcs.Size() == 1)
      {
        UString baseName;
        {
          NCOM::CPropVariant prop;
          RINOK(openVolumeCallback->GetProperty(kpidName, &prop));
          if (prop.vt != VT_BSTR)
            break;
          baseName = prop.bstrVal;
        }
        if (!seqName.InitName(baseName))
          break;
      }
      
      const UString volName = seqName.GetNextName();
      
      HRESULT result = openVolumeCallback->GetStream(volName, &inStream);
      
      if (result != S_OK && result != S_FALSE)
        return result;

      if (!inStream || result != S_OK)
      {
        if (nextVol_is_Required)
          _missingVolName = volName;
        break;
      }
    }
    
    UInt64 endPos = 0;
    RINOK(inStream->Seek(0, STREAM_SEEK_CUR, &arch.StreamStartPosition));
    RINOK(inStream->Seek(0, STREAM_SEEK_END, &endPos));
    RINOK(inStream->Seek(arch.StreamStartPosition, STREAM_SEEK_SET, NULL));
    
    if (openCallback)
    {
      totalBytes += endPos;
      RINOK(openCallback->SetTotal(NULL, &totalBytes));
    }
    
    CInArcInfo arcInfoOpen;
    {
    HRESULT res = arch.Open(inStream, maxCheckStartPosition, getTextPassword, arcInfoOpen);
    if (arch.IsArc && arch.UnexpectedEnd)
      _errorFlags |= kpv_ErrorFlags_UnexpectedEnd;
    if (_arcs.IsEmpty())
    {
      _isArc = arch.IsArc;
    }
    
    if (res != S_OK)
    {
      if (res != S_FALSE)
        return res;
      if (_arcs.IsEmpty())
        return res;
      break;
    }
    }
    
    CArc &arc = _arcs.AddNew();
    CInArcInfo &arcInfo = arc.Info;
    arcInfo = arcInfoOpen;
    arc.Stream = inStream;
    
    CItem item;
    
    for (;;)
    {
      item.Clear();
      
      arcInfo.EndPos = arch.Position;

      if (arch.Position > endPos)
      {
        _errorFlags |= kpv_ErrorFlags_UnexpectedEnd;
        break;
      }
      
      RINOK(inStream->Seek(arch.Position, STREAM_SEEK_SET, NULL));
      
      {
        CInArchive::CHeader h;
        HRESULT res = arch.ReadBlockHeader(h);
        if (res != S_OK)
        {
          if (res != S_FALSE)
            return res;
          if (arch.UnexpectedEnd)
          {
            _errorFlags |= kpv_ErrorFlags_UnexpectedEnd;
            if (arcInfo.EndPos < arch.Position)
              arcInfo.EndPos = arch.Position;
            if (arcInfo.EndPos < endPos)
              arcInfo.EndPos = endPos;
          }
          else
            _errorFlags |= kpv_ErrorFlags_HeadersError;
          break;
        }
        
        if (h.Type == NHeaderType::kEndOfArc)
        {
          arcInfo.EndPos = arch.Position;
          arcInfo.EndOfArchive_was_Read = true;
          if (!arch.ReadVar(arcInfo.EndFlags))
            _errorFlags |= kpv_ErrorFlags_HeadersError;
          if (arcInfo.IsVolume())
          {
            // for multivolume archives RAR can add ZERO bytes at the end for alignment.
            // We must skip these bytes to prevent phySize warning.
            RINOK(inStream->Seek(arcInfo.EndPos, STREAM_SEEK_SET, NULL));
            bool areThereNonZeros;
            UInt64 numZeros;
            const UInt64 maxSize = 1 << 12;
            RINOK(ReadZeroTail(inStream, areThereNonZeros, numZeros, maxSize));
            if (!areThereNonZeros && numZeros != 0 && numZeros <= maxSize)
              arcInfo.EndPos += numZeros;
          }
          break;
        }
        
        if (h.Type != NHeaderType::kFile &&
            h.Type != NHeaderType::kService)
        {
          _errorFlags |= kpv_ErrorFlags_UnsupportedFeature;
          break;
        }
        
        item.RecordType = (Byte)h.Type;
        
        if (!arch.ReadFileHeader(h, item))
        {
          _errorFlags |= kpv_ErrorFlags_HeadersError;
          break;
        }
        
        // item.MainPartSize = (UInt32)(Position - item.Position);
        item.DataPos = arch.Position;
      }
      
      bool isOk_packSize = true;
      {
        arcInfo.EndPos = arch.Position;
        if (arch.Position + item.PackSize < arch.Position)
        {
          isOk_packSize = false;
          _errorFlags |= kpv_ErrorFlags_HeadersError;
          if (arcInfo.EndPos < endPos)
            arcInfo.EndPos = endPos;
        }
        else
        {
          arch.AddToSeekValue(item.PackSize); // Position points to next header;
          arcInfo.EndPos = arch.Position;
        }
      }

      bool needAdd = true;
      
      {
        if (_comment.Size() == 0
            && item.Is_CMT()
            && item.PackSize < kCommentSize_Max
            && item.PackSize == item.Size
            && item.PackSize != 0
            && item.GetMethod() == 0
            && !item.IsSplit())
        {
          RINOK(unpacker.DecodeToBuf(EXTERNAL_CODECS_VARS item, item.PackSize, inStream, _comment));
          needAdd = false;
        }
      }
      
      if (needAdd)
      {
        CRefItem ref;
        ref.Item = _items.Size();
        ref.Last = ref.Item;
        ref.Parent = -1;
        ref.Link = -1;
        
        if (item.IsService())
        {
          if (item.Is_STM())
          {
            if (prevMainFile >= 0)
              ref.Parent = prevMainFile;
          }
          else
          {
            needAdd = false;
            if (item.Is_ACL() && (!item.IsEncrypted() || arch.m_CryptoMode))
            {
              if (prevMainFile >= 0 && item.Size < (1 << 24) && item.Size != 0)
              {
                CItem &mainItem = _items[_refs[prevMainFile].Item];
                
                if (mainItem.ACL < 0)
                {
                  CByteBuffer acl;
                  HRESULT res = tempBuf.Decode(EXTERNAL_CODECS_VARS item, inStream, unpacker, acl);
                  if (!item.IsSplitAfter())
                    tempBuf.Clear();
                  if (res != S_OK)
                  {
                    tempBuf.Clear();
                    if (res != S_FALSE && res != E_NOTIMPL)
                      return res;
                  }
                  // RINOK();
                  
                  if (res == S_OK && acl.Size() != 0)
                  {
                    if (_acls.IsEmpty() || acl != _acls.Back())
                      _acls.Add(acl);
                    mainItem.ACL = _acls.Size() - 1;
                  }
                }
              }
            }
          }
        }
        
        if (needAdd)
        {
          if (item.IsSplitBefore())
          {
            if (prevSplitFile >= 0)
            {
              CRefItem &ref2 = _refs[prevSplitFile];
              CItem &prevItem = _items[ref2.Last];
              if (item.IsNextForItem(prevItem))
              {
                ref2.Last = _items.Size();
                prevItem.NextItem = ref2.Last;
                needAdd = false;
              }
            }
          }
        }
        
        if (needAdd)
        {
          if (item.IsSplitAfter())
            prevSplitFile = _refs.Size();
          if (!item.IsService())
            prevMainFile = _refs.Size();
          _refs.Add(ref);
        }
      }
      
      {
        UInt64 version;
        if (item.FindExtra_Version(version))
        {
          item.Version_Defined = true;
          item.Version = version;
        }
      }
      
      item.VolIndex = _arcs.Size() - 1;
      _items.Add(item);
      
      if (openCallback && (_items.Size() & 0xFF) == 0)
      {
        UInt64 numFiles = _items.Size();
        UInt64 numBytes = curBytes + item.DataPos;
        RINOK(openCallback->SetCompleted(&numFiles, &numBytes));
      }

      if (!isOk_packSize)
        break;
    }
      
    curBytes += endPos;

    nextVol_is_Required = false;

    if (!arcInfo.IsVolume())
      break;

    if (arcInfo.EndOfArchive_was_Read)
    {
      if (!arcInfo.AreMoreVolumes())
        break;
      nextVol_is_Required = true;
    }
  }

  FillLinks();

  return S_OK;
}


STDMETHODIMP CHandler::Open(IInStream *stream,
    const UInt64 *maxCheckStartPosition,
    IArchiveOpenCallback *openCallback)
{
  COM_TRY_BEGIN
  Close();
  return Open2(stream, maxCheckStartPosition, openCallback);
  COM_TRY_END
}

STDMETHODIMP CHandler::Close()
{
  COM_TRY_BEGIN
  _missingVolName.Empty();
  _errorFlags = 0;
  // _warningFlags = 0;
  _isArc = false;
  _refs.Clear();
  _items.Clear();
  _arcs.Clear();
  _acls.Clear();
  _comment.Free();
  return S_OK;
  COM_TRY_END
}


class CVolsInStream:
  public ISequentialInStream,
  public CMyUnknownImp
{
  UInt64 _rem;
  ISequentialInStream *_stream;
  const CObjectVector<CArc> *_arcs;
  const CObjectVector<CItem> *_items;
  int _itemIndex;
public:
  bool CrcIsOK;
private:
  CHash _hash;
public:
  MY_UNKNOWN_IMP
  void Init(const CObjectVector<CArc> *arcs,
      const CObjectVector<CItem> *items,
      unsigned itemIndex)
  {
    _arcs = arcs;
    _items = items;
    _itemIndex = itemIndex;
    _stream = NULL;
    CrcIsOK = true;
  }

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
};

STDMETHODIMP CVolsInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  UInt32 realProcessedSize = 0;

  while (size != 0)
  {
    if (!_stream)
    {
      if (_itemIndex < 0)
        break;
      const CItem &item = (*_items)[_itemIndex];
      IInStream *s = (*_arcs)[item.VolIndex].Stream;
      RINOK(s->Seek(item.GetDataPosition(), STREAM_SEEK_SET, NULL));
      _stream = s;
      if (CrcIsOK && item.IsSplitAfter())
        _hash.Init(item);
      else
        _hash.Init_NoCalc();
      _rem = item.PackSize;
    }
    {
      UInt32 cur = size;
      if (cur > _rem)
        cur = (UInt32)_rem;
      UInt32 num = cur;
      HRESULT res = _stream->Read(data, cur, &cur);
      _hash.Update(data, cur);
      realProcessedSize += cur;
      if (processedSize)
        *processedSize = realProcessedSize;
      data = (Byte *)data + cur;
      size -= cur;
      _rem -= cur;
      if (_rem == 0)
      {
        const CItem &item = (*_items)[_itemIndex];
        _itemIndex = item.NextItem;
        if (!_hash.Check(item, NULL)) // RAR doesn't use MAC here
          CrcIsOK = false;
        _stream = NULL;
      }
      if (res != S_OK)
        return res;
      if (realProcessedSize != 0)
        return S_OK;
      if (cur == 0 && num != 0)
        return S_OK;
    }
  }
  
  return S_OK;
}


static int FindLinkBuf(CObjectVector<CLinkFile> &linkFiles, unsigned index)
{
  unsigned left = 0, right = linkFiles.Size();
  for (;;)
  {
    if (left == right)
      return -1;
    unsigned mid = (left + right) / 2;
    unsigned linkIndex = linkFiles[mid].Index;
    if (index == linkIndex)
      return mid;
    if (index < linkIndex)
      right = mid;
    else
      left = mid + 1;
  }
}


static inline int DecoderRes_to_OpRes(HRESULT res, bool crcOK)
{
  if (res == E_NOTIMPL)
    return NExtract::NOperationResult::kUnsupportedMethod;
  // if (res == S_FALSE)
  if (res != S_OK)
    return NExtract::NOperationResult::kDataError;
  return crcOK ?
    NExtract::NOperationResult::kOK :
    NExtract::NOperationResult::kCRCError;
}


static HRESULT CopyData_with_Progress(const Byte *data, size_t size,
    ISequentialOutStream *outStream, ICompressProgressInfo *progress)
{
  size_t pos = 0;
  
  while (pos < size)
  {
    const UInt32 kStepSize = ((UInt32)1 << 24);
    UInt32 cur32;
    {
      size_t cur = size - pos;
      if (cur > kStepSize)
        cur = kStepSize;
      cur32 = (UInt32)cur;
    }
    RINOK(outStream->Write(data + pos, cur32, &cur32));
    if (cur32 == 0)
      return E_FAIL;
    pos += cur32;
    if (progress)
    {
      UInt64 pos64 = pos;
      RINOK(progress->SetRatioInfo(&pos64, &pos64));
    }
  }
  
  return S_OK;
}


STDMETHODIMP CHandler::Extract(const UInt32 *indices, UInt32 numItems,
    Int32 testMode, IArchiveExtractCallback *extractCallback)
{
  COM_TRY_BEGIN

  bool allFilesMode = (numItems == (UInt32)(Int32)-1);
  if (allFilesMode)
    numItems = _refs.Size();
  if (numItems == 0)
    return S_OK;
  
  CByteArr extractStatuses(_refs.Size());
  memset(extractStatuses, 0, _refs.Size());

  // we don't want to use temp buffer for big link files.
  const size_t k_CopyLinkFile_MaxSize = (size_t)1 << (28 + sizeof(size_t) / 2);

  const Byte kStatus_Extract = 1 << 0;
  const Byte kStatus_Skip = 1 << 1;
  const Byte kStatus_Link = 1 << 2;

  CObjectVector<CLinkFile> linkFiles;

  {
    UInt64 total = 0;
    bool isThereUndefinedSize = false;
    bool thereAreLinks = false;

    {
      unsigned solidLimit = 0;
      for (UInt32 t = 0; t < numItems; t++)
      {
        unsigned index = allFilesMode ? t : indices[t];
        const CRefItem &ref = _refs[index];
        const CItem &item = _items[ref.Item];
        const CItem &lastItem = _items[ref.Last];
        
        extractStatuses[index] |= kStatus_Extract;

        if (!lastItem.Is_UnknownSize())
          total += lastItem.Size;
        else
          isThereUndefinedSize = true;
        
        if (ref.Link >= 0)
        {
          if (!testMode)
          {
            if ((unsigned)ref.Link < index)
            {
              const CRefItem &linkRef = _refs[(unsigned)ref.Link];
              const CItem &linkItem = _items[linkRef.Item];
              if (linkItem.IsSolid() && linkItem.Size <= k_CopyLinkFile_MaxSize)
              {
                if (extractStatuses[(unsigned)ref.Link] == 0)
                {
                  const CItem &lastLinkItem = _items[linkRef.Last];
                  if (!lastLinkItem.Is_UnknownSize())
                    total += lastLinkItem.Size;
                  else
                    isThereUndefinedSize = true;
                }
                extractStatuses[(unsigned)ref.Link] |= kStatus_Link;
                thereAreLinks = true;
              }
            }
          }
          continue;
        }
        
        if (item.IsService())
          continue;
        
        if (item.IsSolid())
        {
          unsigned j = index;
          
          while (j > solidLimit)
          {
            j--;
            const CRefItem &ref2 = _refs[j];
            const CItem &item2 = _items[ref2.Item];
            if (!item2.IsService())
            {
              if (extractStatuses[j] == 0)
              {
                const CItem &lastItem2 = _items[ref2.Last];
                if (!lastItem2.Is_UnknownSize())
                  total += lastItem2.Size;
                else
                  isThereUndefinedSize = true;
              }
              extractStatuses[j] |= kStatus_Skip;
              if (!item2.IsSolid())
                break;
            }
          }
        }
        
        solidLimit = index + 1;
      }
    }

    if (thereAreLinks)
    {
      unsigned solidLimit = 0;

      FOR_VECTOR(i, _refs)
      {
        if ((extractStatuses[i] & kStatus_Link) == 0)
          continue;
        const CItem &item = _items[_refs[i].Item];
        /*
        if (item.IsService())
          continue;
        */
        
        CLinkFile &linkFile = linkFiles.AddNew();
        linkFile.Index = i;
        
        if (item.IsSolid())
        {
          unsigned j = i;
          
          while (j > solidLimit)
          {
            j--;
            const CRefItem &ref2 = _refs[j];
            const CItem &item2 = _items[ref2.Item];
            if (!item2.IsService())
            {
              if (extractStatuses[j] != 0)
                break;
              extractStatuses[j] = kStatus_Skip;
              {
                const CItem &lastItem2 = _items[ref2.Last];
                if (!lastItem2.Is_UnknownSize())
                  total += lastItem2.Size;
                else
                  isThereUndefinedSize = true;
              }
              if (!item2.IsSolid())
                break;
            }
          }
        }
        
        solidLimit = i + 1;
      }

      for (UInt32 t = 0; t < numItems; t++)
      {
        unsigned index = allFilesMode ? t : indices[t];
        const CRefItem &ref = _refs[index];
       
        int linkIndex = ref.Link;
        if (linkIndex < 0 || (unsigned)linkIndex >= index)
          continue;
        const CItem &linkItem = _items[_refs[(unsigned)linkIndex].Item];
        if (!linkItem.IsSolid() || linkItem.Size > k_CopyLinkFile_MaxSize)
          continue;
        int bufIndex = FindLinkBuf(linkFiles, linkIndex);
        if (bufIndex < 0)
          return E_FAIL;
        linkFiles[bufIndex].NumLinks++;
      }
    }
    
    if (total != 0 || !isThereUndefinedSize)
    {
      RINOK(extractCallback->SetTotal(total));
    }
  }


  UInt64 totalUnpacked = 0;
  UInt64 totalPacked = 0;
  UInt64 curUnpackSize = 0;
  UInt64 curPackSize = 0;

  CUnpacker unpacker;

  CVolsInStream *volsInStreamSpec = new CVolsInStream;
  CMyComPtr<ISequentialInStream> volsInStream = volsInStreamSpec;

  CLocalProgress *lps = new CLocalProgress;
  CMyComPtr<ICompressProgressInfo> progress = lps;
  lps->Init(extractCallback, false);

  // bool needClearSolid = true;

  FOR_VECTOR(i, _refs)
  {
    if (extractStatuses[i] == 0)
      continue;

    totalUnpacked += curUnpackSize;
    totalPacked += curPackSize;
    lps->InSize = totalPacked;
    lps->OutSize = totalUnpacked;
    RINOK(lps->SetCur());
    
    CMyComPtr<ISequentialOutStream> realOutStream;

    Int32 askMode =
        ((extractStatuses[i] & kStatus_Extract) != 0) ? (testMode ?
          NExtract::NAskMode::kTest :
          NExtract::NAskMode::kExtract) :
          NExtract::NAskMode::kSkip;

    unpacker.linkFile = NULL;

    if (((extractStatuses[i] & kStatus_Link) != 0))
    {
      int bufIndex = FindLinkBuf(linkFiles, i);
      if (bufIndex < 0)
        return E_FAIL;
      unpacker.linkFile = &linkFiles[bufIndex];
    }

    UInt32 index = i;

    const CRefItem *ref = &_refs[index];
    const CItem *item = &_items[ref->Item];
    const CItem &lastItem = _items[ref->Last];

    curUnpackSize = 0;
    if (!lastItem.Is_UnknownSize())
      curUnpackSize = lastItem.Size;

    curPackSize = GetPackSize(index);

    RINOK(extractCallback->GetStream(index, &realOutStream, askMode));

    bool isSolid;
    {
      bool &needClearSolid = unpacker.NeedClearSolid[item->IsService() ? 1 : 0];
      isSolid = (item->IsSolid() && !needClearSolid);
      if (item->IsService())
        isSolid = false;
      needClearSolid = !item->IsSolid();
    }

    if (item->IsDir())
    {
      RINOK(extractCallback->PrepareOperation(askMode));
      RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK));
      continue;
    }

    int index2 = ref->Link;

    int bufIndex = -1;

    if (index2 >= 0)
    {
      const CRefItem &ref2 = _refs[index2];
      const CItem &item2 = _items[ref2.Item];
      const CItem &lastItem2 = _items[ref2.Last];
      if (!item2.IsSolid())
      {
        item = &item2;
        ref = &ref2;
        if (!lastItem2.Is_UnknownSize())
          curUnpackSize = lastItem2.Size;
        else
          curUnpackSize = 0;
        curPackSize = GetPackSize(index2);
      }
      else if ((unsigned)index2 < index)
        bufIndex = FindLinkBuf(linkFiles, index2);
    }

    if (!realOutStream)
    {
      if (testMode)
      {
        if (item->Is_CopyLink() && item->PackSize == 0)
        {
          RINOK(extractCallback->PrepareOperation(askMode));
          RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK));
          continue;
        }
      }
      else
      {
        if (item->IsService())
          continue;

        bool needDecode = false;

        for (unsigned n = i + 1; n < _refs.Size(); n++)
        {
          const CItem &nextItem = _items[_refs[n].Item];
          if (nextItem.IsService())
            continue;
          if (!nextItem.IsSolid())
            break;
          if (extractStatuses[i] != 0)
          {
            needDecode = true;
            break;
          }
        }
        
        if (!needDecode)
          continue;
    
        askMode = NExtract::NAskMode::kSkip;
      }
    }

    RINOK(extractCallback->PrepareOperation(askMode));

    if (bufIndex >= 0)
    {
      CLinkFile &linkFile = linkFiles[bufIndex];
      if (linkFile.NumLinks == 0)
        return E_FAIL;
      if (realOutStream)
      {
        RINOK(CopyData_with_Progress(linkFile.Data, linkFile.Data.Size(), realOutStream, progress));
      }
      if (--linkFile.NumLinks == 0)
        linkFile.Data.Free();
      RINOK(extractCallback->SetOperationResult(DecoderRes_to_OpRes(linkFile.Res, linkFile.crcOK)));
      continue;
    }

    if (item->Is_CopyLink() && item->PackSize == 0)
    {
      RINOK(extractCallback->SetOperationResult(
          realOutStream ?
            NExtract::NOperationResult::kUnsupportedMethod:
            NExtract::NOperationResult::kOK));
      continue;
    }

    volsInStreamSpec->Init(&_arcs, &_items, ref->Item);

    UInt64 packSize = curPackSize;

    if (item->IsEncrypted())
      if (!unpacker.getTextPassword)
        extractCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&unpacker.getTextPassword);

    bool wrongPassword;
    HRESULT result = unpacker.Create(EXTERNAL_CODECS_VARS *item, isSolid, wrongPassword);

    if (wrongPassword)
    {
      realOutStream.Release();
      RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kWrongPassword));
      continue;
    }
        
    bool crcOK = true;
    if (result == S_OK)
      result = unpacker.Code(*item, _items[ref->Last], packSize, volsInStream, realOutStream, progress, crcOK);
    realOutStream.Release();
    if (!volsInStreamSpec->CrcIsOK)
      crcOK = false;

    int opRes = crcOK ?
        NExtract::NOperationResult::kOK:
        NExtract::NOperationResult::kCRCError;

    if (result != S_OK)
    {
      if (result == S_FALSE)
        opRes = NExtract::NOperationResult::kDataError;
      else if (result == E_NOTIMPL)
        opRes = NExtract::NOperationResult::kUnsupportedMethod;
      else
        return result;
    }

    RINOK(extractCallback->SetOperationResult(opRes));
  }

  {
    FOR_VECTOR(i, linkFiles)
      if (linkFiles[i].NumLinks != 0)
        return E_FAIL;
  }

  return S_OK;
  
  COM_TRY_END
}


IMPL_ISetCompressCodecsInfo

REGISTER_ARC_I(
  "Rar5", "rar r00", 0, 0xCC,
  kMarker,
  0,
  NArcInfoFlags::kFindSignature,
  NULL)

}}


class CBlake2spHasher:
  public IHasher,
  public CMyUnknownImp
{
  CBlake2sp _blake;
  Byte mtDummy[1 << 7];

public:
  CBlake2spHasher() { Init(); }

  MY_UNKNOWN_IMP
  INTERFACE_IHasher(;)
};

STDMETHODIMP_(void) CBlake2spHasher::Init() throw()
{
  Blake2sp_Init(&_blake);
}

STDMETHODIMP_(void) CBlake2spHasher::Update(const void *data, UInt32 size) throw()
{
  Blake2sp_Update(&_blake, (const Byte *)data, size);
}

STDMETHODIMP_(void) CBlake2spHasher::Final(Byte *digest) throw()
{
  Blake2sp_Final(&_blake, digest);
}

REGISTER_HASHER(CBlake2spHasher, 0x202, "BLAKE2sp", BLAKE2S_DIGEST_SIZE)
// Rar5Handler.h

#ifndef __RAR5_HANDLER_H
#define __RAR5_HANDLER_H

#include "../../../../C/Blake2.h"

#include "../../../Common/MyBuffer.h"

#include "../../../Windows/PropVariant.h"

#include "../../Common/CreateCoder.h"

#include "../IArchive.h"

namespace NArchive {
namespace NRar5 {

namespace NHeaderFlags
{
  const unsigned kExtra   = 1 << 0;
  const unsigned kData    = 1 << 1;
  // const unsigned kUnknown = 1 << 2;
  const unsigned kPrevVol = 1 << 3;
  const unsigned kNextVol = 1 << 4;
  // const unsigned kIsChild = 1 << 5;
  // const unsigned kPreserveChild = 1 << 6;
}
  
namespace NHeaderType
{
  enum
  {
    kArc = 1,
    kFile,
    kService,
    kArcEncrypt,
    kEndOfArc
  };
}

namespace NArcFlags
{
  const unsigned kVol       = 1 << 0;
  const unsigned kVolNumber = 1 << 1;
  const unsigned kSolid     = 1 << 2;
  // const unsigned kRecovery  = 1 << 3;
  // const unsigned kLocked    = 1 << 4;
}

const unsigned kArcExtraRecordType_Locator = 1;

namespace NLocatorFlags
{
  const unsigned kQuickOpen  = 1 << 0;
  const unsigned kRecovery   = 1 << 1;
}

namespace NFileFlags
{
  const unsigned kIsDir    = 1 << 0;
  const unsigned kUnixTime = 1 << 1;
  const unsigned kCrc32    = 1 << 2;
  const unsigned kUnknownSize = 1 << 3;
}

namespace NMethodFlags
{
  // const unsigned kVersionMask = 0x3F;
  const unsigned kSolid = 1 << 6;
}

namespace NArcEndFlags
{
  const unsigned kMoreVols = 1 << 0;
}

enum EHostOS
{
  kHost_Windows = 0,
  kHost_Unix
};



// ---------- Extra ----------

namespace NExtraRecordType
{
  enum
  {
    kCrypto = 1,
    kHash,
    kTime,
    kVersion,
    kLink,
    kUnixOwner,
    kSubdata
  };
}

// const unsigned kCryptoAlgo_AES = 0;

namespace NCryptoFlags
{
  const unsigned kPswCheck = 1 << 0;
  const unsigned kUseMAC   = 1 << 1;
}

struct CCryptoInfo
{
  UInt64 Algo;
  UInt64 Flags;
  Byte Cnt;

  bool UseMAC()       const { return (Flags & NCryptoFlags::kUseMAC) != 0; }
  bool IsThereCheck() const { return (Flags & NCryptoFlags::kPswCheck) != 0; }
  bool Parse(const Byte *p, size_t size);
};

const unsigned kHashID_Blake2sp = 0;

namespace NTimeRecord
{
  enum
  {
    k_Index_MTime = 0,
    k_Index_CTime,
    k_Index_ATime
  };
  
  namespace NFlags
  {
    const unsigned kUnixTime = 1 << 0;
    const unsigned kMTime    = 1 << 1;
    // const unsigned kCTime    = 1 << 2;
    // const unsigned kATime    = 1 << 3;
  }
}

namespace NLinkType
{
  enum
  {
    kUnixSymLink = 1,
    kWinSymLink,
    kWinJunction,
    kHardLink,
    kFileCopy
  };
}

namespace NLinkFlags
{
  const unsigned kTargetIsDir = 1 << 0;
}


struct CItem
{
  UInt32 CommonFlags;
  UInt32 Flags;

  Byte RecordType;
  bool Version_Defined;

  int ACL;

  AString Name;

  int VolIndex;
  int NextItem;

  UInt32 UnixMTime;
  UInt32 CRC;
  UInt32 Attrib;
  UInt32 Method;

  CByteBuffer Extra;

  UInt64 Size;
  UInt64 PackSize;
  UInt64 HostOS;
  
  UInt64 DataPos;
  UInt64 Version;

  CItem() { Clear(); }

  void Clear()
  {
    CommonFlags = 0;
    Flags = 0;
    
    VolIndex = 0;
    NextItem = -1;

    Version_Defined = false;
    Version = 0;

    Name.Empty();
    Extra.Free();
    ACL = -1;
  }

  bool IsSplitBefore()  const { return (CommonFlags & NHeaderFlags::kPrevVol) != 0; }
  bool IsSplitAfter()   const { return (CommonFlags & NHeaderFlags::kNextVol) != 0; }
  bool IsSplit()        const { return (CommonFlags & (NHeaderFlags::kPrevVol | NHeaderFlags::kNextVol)) != 0; }

  bool IsDir()          const { return (Flags & NFileFlags::kIsDir) != 0; }
  bool Has_UnixMTime()  const { return (Flags & NFileFlags::kUnixTime) != 0; }
  bool Has_CRC()        const { return (Flags & NFileFlags::kCrc32) != 0; }
  bool Is_UnknownSize() const { return (Flags & NFileFlags::kUnknownSize) != 0; }

  bool IsNextForItem(const CItem &prev) const
  {
    return !IsDir() && !prev.IsDir() && IsSplitBefore() && prev.IsSplitAfter() && (Name == prev.Name);
      // && false;
  }

  bool IsSolid() const { return ((UInt32)Method & NMethodFlags::kSolid) != 0; }
  unsigned GetAlgoVersion() const { return (unsigned)Method & 0x3F; }
  unsigned GetMethod() const { return ((unsigned)Method >> 7) & 0x7; }
  UInt32 GetDictSize() const { return (((UInt32)Method >> 10) & 0xF); }

  bool IsService() const { return RecordType == NHeaderType::kService; }
  
  bool Is_STM() const { return IsService() && Name == "STM"; }
  bool Is_CMT() const { return IsService() && Name == "CMT"; }
  bool Is_ACL() const { return IsService() && Name == "ACL"; }
  // bool Is_QO()  const { return IsService() && Name == "QO"; }

  int FindExtra(unsigned type, unsigned &recordDataSize) const;

  bool IsEncrypted() const
  {
    unsigned size;
    return FindExtra(NExtraRecordType::kCrypto, size) >= 0;
  }

  int FindExtra_Blake() const
  {
    unsigned size = 0;
    int offset = FindExtra(NExtraRecordType::kHash, size);
    if (offset >= 0
        && size == BLAKE2S_DIGEST_SIZE + 1
        && Extra[(unsigned)offset] == kHashID_Blake2sp)
      return offset + 1;
    return -1;
  }

  bool FindExtra_Version(UInt64 &version) const;

  struct CLinkInfo
  {
    UInt64 Type;
    UInt64 Flags;
    unsigned NameOffset;
    unsigned NameLen;
  };

  bool FindExtra_Link(CLinkInfo &link) const;
  void Link_to_Prop(unsigned linkType, NWindows::NCOM::CPropVariant &prop) const;
  bool Is_CopyLink() const;

  bool NeedUse_as_CopyLink() const { return PackSize == 0 && Is_CopyLink(); }

  bool GetAltStreamName(AString &name) const;

  UInt32 GetWinAttrib() const
  {
    UInt32 a;
    switch (HostOS)
    {
      case kHost_Windows: a = Attrib; break;
      case kHost_Unix: a = (Attrib << 16); break;
      default: a = 0;
    }
    // if (IsDir()) a |= FILE_ATTRIBUTE_DIRECTORY;
    return a;
  }

  UInt64 GetDataPosition() const { return DataPos; }
};


struct CInArcInfo
{
  UInt64 Flags;
  UInt64 VolNumber;
  UInt64 StartPos;
  UInt64 EndPos;

  UInt64 EndFlags;
  bool EndOfArchive_was_Read;

  bool IsEncrypted;

  // CByteBuffer Extra;

  /*
  struct CLocator
  {
    UInt64 Flags;
    UInt64 QuickOpen;
    UInt64 Recovery;
    
    bool Is_QuickOpen() const { return (Flags & NLocatorFlags::kQuickOpen) != 0; }
    bool Is_Recovery() const { return (Flags & NLocatorFlags::kRecovery) != 0; }
  };

  int FindExtra(unsigned type, unsigned &recordDataSize) const;
  bool FindExtra_Locator(CLocator &locator) const;
  */

  CInArcInfo():
    Flags(0),
    VolNumber(0),
    StartPos(0),
    EndPos(0),
    EndFlags(0),
    EndOfArchive_was_Read(false),
    IsEncrypted(false)
      {}

  /*
  void Clear()
  {
    Flags = 0;
    VolNumber = 0;
    StartPos = 0;
    EndPos = 0;
    EndFlags = 0;
    EndOfArchive_was_Read = false;
    Extra.Free();
  }
  */

  UInt64 GetPhySize() const { return EndPos - StartPos; }

  bool AreMoreVolumes()  const { return (EndFlags & NArcEndFlags::kMoreVols) != 0; }

  bool IsVolume()             const { return (Flags & NArcFlags::kVol) != 0; }
  bool IsSolid()              const { return (Flags & NArcFlags::kSolid) != 0; }
  bool Is_VolNumber_Defined() const { return (Flags & NArcFlags::kVolNumber) != 0; }

  UInt64 GetVolIndex() const { return Is_VolNumber_Defined() ? VolNumber : 0; }
};


struct CRefItem
{
  unsigned Item;
  unsigned Last;
  int Parent;
  int Link;
};


struct CArc
{
  CMyComPtr<IInStream> Stream;
  CInArcInfo Info;
};


class CHandler:
  public IInArchive,
  public IArchiveGetRawProps,
  PUBLIC_ISetCompressCodecsInfo
  public CMyUnknownImp
{
public:
  CRecordVector<CRefItem> _refs;
  CObjectVector<CItem> _items;
private:
  CObjectVector<CArc> _arcs;
  CObjectVector<CByteBuffer> _acls;

  UInt32 _errorFlags;
  // UInt32 _warningFlags;
  bool _isArc;
  CByteBuffer _comment;
  UString _missingVolName;

  DECL_EXTERNAL_CODECS_VARS

  UInt64 GetPackSize(unsigned refIndex) const;
  
  void FillLinks();
  
  HRESULT Open2(IInStream *stream,
      const UInt64 *maxCheckStartPosition,
      IArchiveOpenCallback *openCallback);

public:
  MY_QUERYINTERFACE_BEGIN2(IInArchive)
  MY_QUERYINTERFACE_ENTRY(IArchiveGetRawProps)
  QUERY_ENTRY_ISetCompressCodecsInfo
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE
  
  INTERFACE_IInArchive(;)
  INTERFACE_IArchiveGetRawProps(;)

  DECL_ISetCompressCodecsInfo
};

}}

#endif
// RarHandler.cpp

#include "StdAfx.h"

#include "../../../../C/CpuArch.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/IntToString.h"
#include "../../../Common/UTFConvert.h"

#include "../../../Windows/PropVariantUtils.h"
#include "../../../Windows/TimeUtils.h"

#include "../../IPassword.h"

#include "../../Common/CreateCoder.h"
#include "../../Common/FilterCoder.h"
#include "../../Common/LimitedStreams.h"
#include "../../Common/MethodId.h"
#include "../../Common/ProgressUtils.h"
#include "../../Common/RegisterArc.h"
#include "../../Common/StreamUtils.h"

#include "../../Compress/CopyCoder.h"

#include "../../Crypto/Rar20Crypto.h"
#include "../../Crypto/RarAes.h"

#include "../Common/FindSignature.h"
#include "../Common/ItemNameUtils.h"
#include "../Common/OutStreamWithCRC.h"

#include "../HandlerCont.h"

#include "RarVol.h"
#include "RarHandler.h"

using namespace NWindows;

#define Get16(p) GetUi16(p)
#define Get32(p) GetUi32(p)

namespace NArchive {
namespace NRar {

#define SIGNATURE { 0x52 , 0x61, 0x72, 0x21, 0x1a, 0x07, 0x00 }

static const Byte kMarker[NHeader::kMarkerSize] = SIGNATURE;

const unsigned kPasswordLen_MAX = 127;
      
bool CItem::IgnoreItem() const
{
  switch (HostOS)
  {
    case NHeader::NFile::kHostMSDOS:
    case NHeader::NFile::kHostOS2:
    case NHeader::NFile::kHostWin32:
      return ((Attrib & NHeader::NFile::kLabelFileAttribute) != 0);
  }
  return false;
}

bool CItem::IsDir() const
{
  if (GetDictSize() == NHeader::NFile::kDictDirectoryValue)
    return true;
  switch (HostOS)
  {
    case NHeader::NFile::kHostMSDOS:
    case NHeader::NFile::kHostOS2:
    case NHeader::NFile::kHostWin32:
      if ((Attrib & FILE_ATTRIBUTE_DIRECTORY) != 0)
        return true;
  }
  return false;
}

UInt32 CItem::GetWinAttrib() const
{
  UInt32 a;
  switch (HostOS)
  {
    case NHeader::NFile::kHostMSDOS:
    case NHeader::NFile::kHostOS2:
    case NHeader::NFile::kHostWin32:
      a = Attrib;
      break;
    default:
      a = 0; // must be converted from unix value;
  }
  if (IsDir())
    a |= NHeader::NFile::kWinFileDirectoryAttributeMask;
  return a;
}
  
static const char * const kHostOS[] =
{
    "MS DOS"
  , "OS/2"
  , "Win32"
  , "Unix"
  , "Mac OS"
  , "BeOS"
};

static const char *kUnknownOS = "Unknown";

static const CUInt32PCharPair k_Flags[] =
{
  { 0, "Volume" },
  { 1, "Comment" },
  { 2, "Lock" },
  { 3, "Solid" },
  { 4, "NewVolName" }, // pack_comment in old versuons
  { 5, "Authenticity" },
  { 6, "Recovery" },
  { 7, "BlockEncryption" },
  { 8, "FirstVolume" },
  { 9, "EncryptVer" }
};

enum EErrorType
{
  k_ErrorType_OK,
  k_ErrorType_Corrupted,
  k_ErrorType_UnexpectedEnd,
  k_ErrorType_DecryptionError
};

class CInArchive
{
  IInStream *m_Stream;
  UInt64 m_StreamStartPosition;
  CBuffer<wchar_t> _unicodeNameBuffer;
  CByteBuffer _comment;
  CByteBuffer m_FileHeaderData;
  NHeader::NBlock::CBlock m_BlockHeader;
  NCrypto::NRar3::CDecoder *m_RarAESSpec;
  CMyComPtr<ICompressFilter> m_RarAES;
  CBuffer<Byte> m_DecryptedData;
  Byte *m_DecryptedDataAligned;
  UInt32 m_DecryptedDataSize;
  bool m_CryptoMode;
  UInt32 m_CryptoPos;


  HRESULT ReadBytesSpec(void *data, size_t *size);
  bool ReadBytesAndTestSize(void *data, UInt32 size);
  void ReadName(const Byte *p, unsigned nameSize, CItem &item);
  bool ReadHeaderReal(const Byte *p, unsigned size, CItem &item);
  
  HRESULT Open2(IInStream *stream, const UInt64 *searchHeaderSizeLimit);

  void AddToSeekValue(UInt64 addValue)
  {
    m_Position += addValue;
  }

  void FinishCryptoBlock()
  {
    if (m_CryptoMode)
      while ((m_CryptoPos & 0xF) != 0)
      {
        m_CryptoPos++;
        m_Position++;
      }
  }

public:
  UInt64 m_Position;
  CInArcInfo ArcInfo;
  bool HeaderErrorWarning;

  HRESULT Open(IInStream *inStream, const UInt64 *searchHeaderSizeLimit);
  HRESULT GetNextItem(CItem &item, ICryptoGetTextPassword *getTextPassword,
      bool &filled, EErrorType &error);
};
  
static bool CheckHeaderCrc(const Byte *header, size_t headerSize)
{
  return Get16(header) == (UInt16)(CrcCalc(header + 2, headerSize - 2) & 0xFFFF);
}

HRESULT CInArchive::Open(IInStream *stream, const UInt64 *searchHeaderSizeLimit)
{
  HeaderErrorWarning = false;
  m_CryptoMode = false;
  RINOK(stream->Seek(0, STREAM_SEEK_CUR, &m_StreamStartPosition));
  RINOK(stream->Seek(0, STREAM_SEEK_END, &ArcInfo.FileSize));
  RINOK(stream->Seek(m_StreamStartPosition, STREAM_SEEK_SET, NULL));
  m_Position = m_StreamStartPosition;

  UInt64 arcStartPos = m_StreamStartPosition;
  {
    Byte marker[NHeader::kMarkerSize];
    RINOK(ReadStream_FALSE(stream, marker, NHeader::kMarkerSize));
    if (memcmp(marker, kMarker, NHeader::kMarkerSize) == 0)
      m_Position += NHeader::kMarkerSize;
    else
    {
      if (searchHeaderSizeLimit && *searchHeaderSizeLimit == 0)
        return S_FALSE;
      RINOK(stream->Seek(m_StreamStartPosition, STREAM_SEEK_SET, NULL));
      RINOK(FindSignatureInStream(stream, kMarker, NHeader::kMarkerSize,
          searchHeaderSizeLimit, arcStartPos));
      m_Position = arcStartPos + NHeader::kMarkerSize;
      RINOK(stream->Seek(m_Position, STREAM_SEEK_SET, NULL));
    }
  }
  Byte buf[NHeader::NArchive::kArchiveHeaderSize + 1];

  RINOK(ReadStream_FALSE(stream, buf, NHeader::NArchive::kArchiveHeaderSize));
  AddToSeekValue(NHeader::NArchive::kArchiveHeaderSize);


  UInt32 blockSize = Get16(buf + 5);

  ArcInfo.EncryptVersion = 0;
  ArcInfo.Flags = Get16(buf + 3);

  UInt32 headerSize = NHeader::NArchive::kArchiveHeaderSize;
  
  /*
  if (ArcInfo.IsThereEncryptVer())
  {
    if (blockSize <= headerSize)
      return S_FALSE;
    RINOK(ReadStream_FALSE(stream, buf + NHeader::NArchive::kArchiveHeaderSize, 1));
    AddToSeekValue(1);
    ArcInfo.EncryptVersion = buf[NHeader::NArchive::kArchiveHeaderSize];
    headerSize += 1;
  }
  */
  
  if (blockSize < headerSize
      || buf[2] != NHeader::NBlockType::kArchiveHeader
      || !CheckHeaderCrc(buf, headerSize))
    return S_FALSE;

  size_t commentSize = blockSize - headerSize;
  _comment.Alloc(commentSize);
  RINOK(ReadStream_FALSE(stream, _comment, commentSize));
  AddToSeekValue(commentSize);
  m_Stream = stream;
  ArcInfo.StartPos = arcStartPos;
  return S_OK;
}

HRESULT CInArchive::ReadBytesSpec(void *data, size_t *resSize)
{
  if (m_CryptoMode)
  {
    size_t size = *resSize;
    *resSize = 0;
    const Byte *bufData = m_DecryptedDataAligned;
    UInt32 bufSize = m_DecryptedDataSize;
    size_t i;
    for (i = 0; i < size && m_CryptoPos < bufSize; i++)
      ((Byte *)data)[i] = bufData[m_CryptoPos++];
    *resSize = i;
    return S_OK;
  }
  return ReadStream(m_Stream, data, resSize);
}

bool CInArchive::ReadBytesAndTestSize(void *data, UInt32 size)
{
  size_t processed = size;
  if (ReadBytesSpec(data, &processed) != S_OK)
    return false;
  return processed == size;
}

static void DecodeUnicodeFileName(const Byte *name, const Byte *encName,
    unsigned encSize, wchar_t *unicodeName, unsigned maxDecSize)
{
  unsigned encPos = 0;
  unsigned decPos = 0;
  unsigned flagBits = 0;
  Byte flags = 0;
  Byte highByte = encName[encPos++];
  while (encPos < encSize && decPos < maxDecSize)
  {
    if (flagBits == 0)
    {
      flags = encName[encPos++];
      flagBits = 8;
    }
    switch (flags >> 6)
    {
      case 0:
        unicodeName[decPos++] = encName[encPos++];
        break;
      case 1:
        unicodeName[decPos++] = (wchar_t)(encName[encPos++] + (highByte << 8));
        break;
      case 2:
        unicodeName[decPos++] = (wchar_t)(encName[encPos] + (encName[encPos + 1] << 8));
        encPos += 2;
        break;
      case 3:
        {
          unsigned len = encName[encPos++];
          if (len & 0x80)
          {
            Byte correction = encName[encPos++];
            for (len = (len & 0x7f) + 2;
                len > 0 && decPos < maxDecSize; len--, decPos++)
              unicodeName[decPos] = (wchar_t)(((name[decPos] + correction) & 0xff) + (highByte << 8));
          }
          else
            for (len += 2; len > 0 && decPos < maxDecSize; len--, decPos++)
              unicodeName[decPos] = name[decPos];
        }
        break;
    }
    flags <<= 2;
    flagBits -= 2;
  }
  unicodeName[decPos < maxDecSize ? decPos : maxDecSize - 1] = 0;
}

void CInArchive::ReadName(const Byte *p, unsigned nameSize, CItem &item)
{
  item.UnicodeName.Empty();
  if (nameSize > 0)
  {
    unsigned i;
    for (i = 0; i < nameSize && p[i] != 0; i++);
    item.Name.SetFrom((const char *)p, i);

    if (item.HasUnicodeName())
    {
      if (i < nameSize)
      {
        i++;
        unsigned uNameSizeMax = MyMin(nameSize, (unsigned)0x400);
        _unicodeNameBuffer.AllocAtLeast(uNameSizeMax + 1);
        DecodeUnicodeFileName(p, p + i, nameSize - i, _unicodeNameBuffer, uNameSizeMax);
        item.UnicodeName = _unicodeNameBuffer;
      }
      else if (!ConvertUTF8ToUnicode(item.Name, item.UnicodeName))
        item.UnicodeName.Empty();
    }
  }
  else
    item.Name.Empty();
}

static int ReadTime(const Byte *p, unsigned size, Byte mask, CRarTime &rarTime)
{
  rarTime.LowSecond = (Byte)(((mask & 4) != 0) ? 1 : 0);
  unsigned numDigits = (mask & 3);
  rarTime.SubTime[0] =
  rarTime.SubTime[1] =
  rarTime.SubTime[2] = 0;
  if (numDigits > size)
    return -1;
  for (unsigned i = 0; i < numDigits; i++)
    rarTime.SubTime[3 - numDigits + i] = p[i];
  return numDigits;
}

#define READ_TIME(_mask_, _ttt_) \
  { int size2 = ReadTime(p, size, _mask_, _ttt_); if (size2 < 0) return false; p += (unsigned)size2, size -= (unsigned)size2; }

#define READ_TIME_2(_mask_, _def_, _ttt_) \
    _def_ = ((_mask_ & 8) != 0); if (_def_) \
    { if (size < 4) return false; \
      _ttt_ .DosTime = Get32(p); p += 4; size -= 4; \
      READ_TIME(_mask_, _ttt_); } \


bool CInArchive::ReadHeaderReal(const Byte *p, unsigned size, CItem &item)
{
  const Byte *pStart = p;

  item.Clear();
  item.Flags = m_BlockHeader.Flags;

  const unsigned kFileHeaderSize = 25;

  if (size < kFileHeaderSize)
    return false;

  item.PackSize = Get32(p);
  item.Size = Get32(p + 4);
  item.HostOS = p[8];
  item.FileCRC = Get32(p + 9);
  item.MTime.DosTime = Get32(p + 13);
  item.UnPackVersion = p[17];
  item.Method = p[18];
  unsigned nameSize = Get16(p + 19);
  item.Attrib = Get32(p + 21);

  item.MTime.LowSecond = 0;
  item.MTime.SubTime[0] =
      item.MTime.SubTime[1] =
      item.MTime.SubTime[2] = 0;

  p += kFileHeaderSize;
  size -= kFileHeaderSize;
  if ((item.Flags & NHeader::NFile::kSize64Bits) != 0)
  {
    if (size < 8)
      return false;
    item.PackSize |= ((UInt64)Get32(p) << 32);
    item.Size |= ((UInt64)Get32(p + 4) << 32);
    p += 8;
    size -= 8;
  }
  if (nameSize > size)
    return false;
  ReadName(p, nameSize, item);
  p += nameSize;
  size -= nameSize;

  /*
  // It was commented, since it's difficult to support alt Streams for solid archives.
  if (m_BlockHeader.Type == NHeader::NBlockType::kSubBlock)
  {
    if (item.HasSalt())
    {
      if (size < sizeof(item.Salt))
        return false;
      size -= sizeof(item.Salt);
      p += sizeof(item.Salt);
    }
    if (item.Name == "ACL" && size == 0)
    {
      item.IsAltStream = true;
      item.Name.Empty();
      item.UnicodeName.SetFromAscii(".ACL");
    }
    else if (item.Name == "STM" && size != 0 && (size & 1) == 0)
    {
      item.IsAltStream = true;
      item.Name.Empty();
      for (UInt32 i = 0; i < size; i += 2)
      {
        wchar_t c = Get16(p + i);
        if (c == 0)
          return false;
        item.UnicodeName += c;
      }
    }
  }
  */

  if (item.HasSalt())
  {
    if (size < sizeof(item.Salt))
      return false;
    for (unsigned i = 0; i < sizeof(item.Salt); i++)
      item.Salt[i] = p[i];
    p += sizeof(item.Salt);
    size -= sizeof(item.Salt);
  }

  // some rar archives have HasExtTime flag without field.
  if (size >= 2 && item.HasExtTime())
  {
    Byte aMask = (Byte)(p[0] >> 4);
    Byte b = p[1];
    p += 2;
    size -= 2;
    Byte mMask = (Byte)(b >> 4);
    Byte cMask = (Byte)(b & 0xF);
    if ((mMask & 8) != 0)
    {
      READ_TIME(mMask, item.MTime);
    }
    READ_TIME_2(cMask, item.CTimeDefined, item.CTime);
    READ_TIME_2(aMask, item.ATimeDefined, item.ATime);
  }

  unsigned fileHeaderWithNameSize = 7 + (unsigned)(p - pStart);
  
  item.Position = m_Position;
  item.MainPartSize = fileHeaderWithNameSize;
  item.CommentSize = (UInt16)(m_BlockHeader.HeadSize - fileHeaderWithNameSize);

  if (m_CryptoMode)
    item.AlignSize = (UInt16)((16 - ((m_BlockHeader.HeadSize) & 0xF)) & 0xF);
  else
    item.AlignSize = 0;
  AddToSeekValue(m_BlockHeader.HeadSize);
  
  // return (m_BlockHeader.Type != NHeader::NBlockType::kSubBlock || item.IsAltStream);
  return true;
}

HRESULT CInArchive::GetNextItem(CItem &item, ICryptoGetTextPassword *getTextPassword, bool &filled, EErrorType &error)
{
  filled = false;
  error = k_ErrorType_OK;
  for (;;)
  {
    m_Stream->Seek(m_Position, STREAM_SEEK_SET, NULL);
    ArcInfo.EndPos = m_Position;
    if (!m_CryptoMode && (ArcInfo.Flags &
        NHeader::NArchive::kBlockHeadersAreEncrypted) != 0)
    {
      m_CryptoMode = false;
      if (getTextPassword == 0)
      {
        error = k_ErrorType_DecryptionError;
        return S_OK; // return S_FALSE;
      }
      if (!m_RarAES)
      {
        m_RarAESSpec = new NCrypto::NRar3::CDecoder;
        m_RarAES = m_RarAESSpec;
      }
      // m_RarAESSpec->SetRar350Mode(ArcInfo.IsEncryptOld());

      // Salt
      const UInt32 kSaltSize = 8;
      Byte salt[kSaltSize];
      if (!ReadBytesAndTestSize(salt, kSaltSize))
        return S_FALSE;
      m_Position += kSaltSize;
      RINOK(m_RarAESSpec->SetDecoderProperties2(salt, kSaltSize))
      // Password
      CMyComBSTR password;
      RINOK(getTextPassword->CryptoGetTextPassword(&password))
      unsigned len = 0;
      if (password)
        len = MyStringLen(password);
      if (len > kPasswordLen_MAX)
        len = kPasswordLen_MAX;

      CByteArr buffer(len * 2);
      for (unsigned i = 0; i < len; i++)
      {
        wchar_t c = password[i];
        ((Byte *)buffer)[i * 2] = (Byte)c;
        ((Byte *)buffer)[i * 2 + 1] = (Byte)(c >> 8);
      }

      m_RarAESSpec->SetPassword((const Byte *)buffer, len * 2);

      const UInt32 kDecryptedBufferSize = (1 << 12);
      if (m_DecryptedData.Size() == 0)
      {
        const UInt32 kAlign = 16;
        m_DecryptedData.Alloc(kDecryptedBufferSize + kAlign);
        m_DecryptedDataAligned = (Byte *)((ptrdiff_t)((Byte *)m_DecryptedData + kAlign - 1) & ~(ptrdiff_t)(kAlign - 1));
      }
      RINOK(m_RarAES->Init());
      size_t decryptedDataSizeT = kDecryptedBufferSize;
      RINOK(ReadStream(m_Stream, m_DecryptedDataAligned, &decryptedDataSizeT));
      m_DecryptedDataSize = (UInt32)decryptedDataSizeT;
      m_DecryptedDataSize = m_RarAES->Filter(m_DecryptedDataAligned, m_DecryptedDataSize);

      m_CryptoMode = true;
      m_CryptoPos = 0;
    }

    m_FileHeaderData.AllocAtLeast(7);
    size_t processed = 7;
    RINOK(ReadBytesSpec((Byte *)m_FileHeaderData, &processed));
    if (processed != 7)
    {
      if (processed != 0)
        error = k_ErrorType_UnexpectedEnd;
      ArcInfo.EndPos = m_Position + processed; // test it
      return S_OK;
    }

    const Byte *p = m_FileHeaderData;
    m_BlockHeader.CRC = Get16(p + 0);
    m_BlockHeader.Type = p[2];
    m_BlockHeader.Flags = Get16(p + 3);
    m_BlockHeader.HeadSize = Get16(p + 5);

    if (m_BlockHeader.HeadSize < 7)
    {
      error = k_ErrorType_Corrupted;
      return S_OK;
      // ThrowExceptionWithCode(CInArchiveException::kIncorrectArchive);
    }

    if (m_BlockHeader.Type < NHeader::NBlockType::kFileHeader ||
        m_BlockHeader.Type > NHeader::NBlockType::kEndOfArchive)
    {
      error = m_CryptoMode ?
          k_ErrorType_DecryptionError :
          k_ErrorType_Corrupted;
      return S_OK;
    }

    if (m_BlockHeader.Type == NHeader::NBlockType::kEndOfArchive)
    {
      bool footerError = false;

      unsigned expectHeadLen = 7;
      if (m_BlockHeader.Flags & NHeader::NArchive::kEndOfArc_Flags_DataCRC)
        expectHeadLen += 4;
      if (m_BlockHeader.Flags & NHeader::NArchive::kEndOfArc_Flags_VolNumber)
        expectHeadLen += 2;
      if (m_BlockHeader.Flags & NHeader::NArchive::kEndOfArc_Flags_RevSpace)
        expectHeadLen += 7;

      // rar 5.0 beta 1 writes incorrect RevSpace and headSize

      if (m_BlockHeader.HeadSize < expectHeadLen)
        HeaderErrorWarning = true;
        
      if (m_BlockHeader.HeadSize > 7)
      {
        /* We suppose that EndOfArchive header is always small.
           It's only 20 bytes for multivolume
           Fix the limit, if larger footers are possible */
        if (m_BlockHeader.HeadSize > (1 << 8))
          footerError = true;
        else
        {
          if (m_FileHeaderData.Size() < m_BlockHeader.HeadSize)
            m_FileHeaderData.ChangeSize_KeepData(m_BlockHeader.HeadSize, 7);
          UInt32 afterSize = m_BlockHeader.HeadSize - 7;
          if (ReadBytesAndTestSize(m_FileHeaderData + 7, afterSize))
            processed += afterSize;
          else
          {
            if (!m_CryptoMode)
            {
              error = k_ErrorType_UnexpectedEnd;
              return S_OK;
            }
            footerError = true;
          }
        }
      }
      
      if (footerError || !CheckHeaderCrc(m_FileHeaderData, m_BlockHeader.HeadSize))
      {
        error = m_CryptoMode ?
          k_ErrorType_DecryptionError :
          k_ErrorType_Corrupted;
      }
      else
      {
        ArcInfo.EndFlags = m_BlockHeader.Flags;
        UInt32 offset = 7;
        
        if (m_BlockHeader.Flags & NHeader::NArchive::kEndOfArc_Flags_DataCRC)
        {
          if (processed < offset + 4)
            error = k_ErrorType_Corrupted;
          else
            ArcInfo.DataCRC = Get32(m_FileHeaderData + offset);
          offset += 4;
        }
        
        if (m_BlockHeader.Flags & NHeader::NArchive::kEndOfArc_Flags_VolNumber)
        {
          if (processed < offset + 2)
            error = k_ErrorType_Corrupted;
          ArcInfo.VolNumber = (UInt32)Get16(m_FileHeaderData + offset);
        }

        ArcInfo.EndOfArchive_was_Read = true;
      }

      m_Position += processed;
      FinishCryptoBlock();
      ArcInfo.EndPos = m_Position;
      return S_OK;
    }

    if (m_BlockHeader.Type == NHeader::NBlockType::kFileHeader
        /* || m_BlockHeader.Type == NHeader::NBlockType::kSubBlock */)
    {
      if (m_FileHeaderData.Size() < m_BlockHeader.HeadSize)
        m_FileHeaderData.ChangeSize_KeepData(m_BlockHeader.HeadSize, 7);
      // m_CurData = (Byte *)m_FileHeaderData;
      // m_PosLimit = m_BlockHeader.HeadSize;
      if (!ReadBytesAndTestSize(m_FileHeaderData + 7, m_BlockHeader.HeadSize - 7))
      {
        error = k_ErrorType_UnexpectedEnd;
        return S_OK;
      }

      bool okItem = ReadHeaderReal(m_FileHeaderData + 7, m_BlockHeader.HeadSize - 7, item);
      if (okItem)
      {
        if (!CheckHeaderCrc(m_FileHeaderData, (unsigned)m_BlockHeader.HeadSize - item.CommentSize))
        {
          error = k_ErrorType_Corrupted; // ThrowExceptionWithCode(CInArchiveException::kFileHeaderCRCError);
          return S_OK;
        }
        filled = true;
      }

      FinishCryptoBlock();
      m_CryptoMode = false;
      // Move Position to compressed Data;
      m_Stream->Seek(m_Position, STREAM_SEEK_SET, NULL);
      AddToSeekValue(item.PackSize);  // m_Position points to next header;
      // if (okItem)
        return S_OK;
      /*
      else
        continue;
      */
    }
    
    if (m_CryptoMode && m_BlockHeader.HeadSize > (1 << 10))
    {
      error = k_ErrorType_DecryptionError;
      return S_OK;
    }
    
    if ((m_BlockHeader.Flags & NHeader::NBlock::kLongBlock) != 0)
    {
      if (m_FileHeaderData.Size() < 7 + 4)
        m_FileHeaderData.ChangeSize_KeepData(7 + 4, 7);
      if (!ReadBytesAndTestSize(m_FileHeaderData + 7, 4))
      {
        error = k_ErrorType_UnexpectedEnd;
        return S_OK;
      }
      UInt32 dataSize = Get32(m_FileHeaderData + 7);
      AddToSeekValue(dataSize);
      if (m_CryptoMode && dataSize > (1 << 27))
      {
        error = k_ErrorType_DecryptionError;
        return S_OK;
      }
      m_CryptoPos = m_BlockHeader.HeadSize;
    }
    else
      m_CryptoPos = 0;
    
    {
      UInt64 newPos = m_Position + m_BlockHeader.HeadSize;
      if (newPos > ArcInfo.FileSize)
      {
        error = k_ErrorType_UnexpectedEnd;
        return S_OK;
      }
    }
    AddToSeekValue(m_BlockHeader.HeadSize);
    FinishCryptoBlock();
    m_CryptoMode = false;
  }
}


static const Byte kProps[] =
{
  kpidPath,
  kpidIsDir,
  kpidSize,
  kpidPackSize,
  kpidMTime,
  kpidCTime,
  kpidATime,
  kpidAttrib,

  kpidEncrypted,
  kpidSolid,
  kpidCommented,
  kpidSplitBefore,
  kpidSplitAfter,
  kpidCRC,
  kpidHostOS,
  kpidMethod,
  kpidUnpackVer
};

static const Byte kArcProps[] =
{
  kpidTotalPhySize,
  kpidCharacts,
  kpidSolid,
  kpidNumBlocks,
  // kpidEncrypted,
  kpidIsVolume,
  kpidVolumeIndex,
  kpidNumVolumes
  // kpidCommented
};

IMP_IInArchive_Props
IMP_IInArchive_ArcProps

UInt64 CHandler::GetPackSize(unsigned refIndex) const
{
  const CRefItem &refItem = _refItems[refIndex];
  UInt64 totalPackSize = 0;
  for (unsigned i = 0; i < refItem.NumItems; i++)
    totalPackSize += _items[refItem.ItemIndex + i].PackSize;
  return totalPackSize;
}

bool CHandler::IsSolid(unsigned refIndex) const
{
  const CItem &item = _items[_refItems[refIndex].ItemIndex];
  if (item.UnPackVersion < 20)
  {
    if (_arcInfo.IsSolid())
      return (refIndex > 0);
    return false;
  }
  return item.IsSolid();
}

STDMETHODIMP CHandler::GetArchiveProperty(PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NCOM::CPropVariant prop;
  switch (propID)
  {
    case kpidVolumeIndex: if (_arcInfo.Is_VolNumber_Defined()) prop = (UInt32)_arcInfo.VolNumber; break;
    case kpidSolid: prop = _arcInfo.IsSolid(); break;
    case kpidCharacts:
    {
      AString s = FlagsToString(k_Flags, ARRAY_SIZE(k_Flags), _arcInfo.Flags);
      // FLAGS_TO_PROP(k_Flags, _arcInfo.Flags, prop);
      if (_arcInfo.Is_DataCRC_Defined())
      {
        s.Add_Space_if_NotEmpty();
        s += "VolCRC";
      }
      prop = s;
      break;
    }
    // case kpidEncrypted: prop = _arcInfo.IsEncrypted(); break; // it's for encrypted names.
    case kpidIsVolume: prop = _arcInfo.IsVolume(); break;
    case kpidNumVolumes: prop = (UInt32)_arcs.Size(); break;
    case kpidOffset: if (_arcs.Size() == 1 && _arcInfo.StartPos != 0) prop = _arcInfo.StartPos; break;

    case kpidTotalPhySize:
    {
      if (_arcs.Size() > 1)
      {
        UInt64 sum = 0;
        FOR_VECTOR (v, _arcs)
          sum += _arcs[v].PhySize;
        prop = sum;
      }
      break;
    }

    case kpidPhySize:
    {
      if (_arcs.Size() != 0)
        prop = _arcInfo.GetPhySize();
      break;
    }

    // case kpidCommented: prop = _arcInfo.IsCommented(); break;

    case kpidNumBlocks:
    {
      UInt32 numBlocks = 0;
      FOR_VECTOR (i, _refItems)
        if (!IsSolid(i))
          numBlocks++;
      prop = (UInt32)numBlocks;
      break;
    }
    
    
    case kpidError:
    {
      // if (!_errorMessage.IsEmpty()) prop = _errorMessage; break;

      if (/* &_missingVol || */ !_missingVolName.IsEmpty())
      {
        UString s;
        s.SetFromAscii("Missing volume : ");
        s += _missingVolName;
        prop = s;
      }
      break;
    }

    case kpidErrorFlags:
    {
      UInt32 v = _errorFlags;
      if (!_isArc)
        v |= kpv_ErrorFlags_IsNotArc;
      prop = v;
      break;
    }

    case kpidWarningFlags:
    {
      if (_warningFlags != 0)
        prop = _warningFlags;
      break;
    }

    case kpidExtension:
      if (_arcs.Size() == 1)
      {
        if (_arcInfo.Is_VolNumber_Defined())
        {
          char sz[16];
          ConvertUInt32ToString((UInt32)_arcInfo.VolNumber + 1, sz);
          unsigned len = MyStringLen(sz);
          AString s = "part";
          for (; len < 2; len++)
            s += '0';
          s += sz;
          s += ".rar";
          prop = s;
        }
      }
      break;
  }
  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}

STDMETHODIMP CHandler::GetNumberOfItems(UInt32 *numItems)
{
  *numItems = _refItems.Size();
  return S_OK;
}

static bool RarTimeToFileTime(const CRarTime &rarTime, FILETIME &result)
{
  if (!NTime::DosTimeToFileTime(rarTime.DosTime, result))
    return false;
  UInt64 value =  (((UInt64)result.dwHighDateTime) << 32) + result.dwLowDateTime;
  value += (UInt64)rarTime.LowSecond * 10000000;
  value += ((UInt64)rarTime.SubTime[2] << 16) +
    ((UInt64)rarTime.SubTime[1] << 8) +
    ((UInt64)rarTime.SubTime[0]);
  result.dwLowDateTime = (DWORD)value;
  result.dwHighDateTime = DWORD(value >> 32);
  return true;
}

static void RarTimeToProp(const CRarTime &rarTime, NCOM::CPropVariant &prop)
{
  FILETIME localFileTime, utcFileTime;
  if (RarTimeToFileTime(rarTime, localFileTime))
  {
    if (!LocalFileTimeToFileTime(&localFileTime, &utcFileTime))
      utcFileTime.dwHighDateTime = utcFileTime.dwLowDateTime = 0;
  }
  else
    utcFileTime.dwHighDateTime = utcFileTime.dwLowDateTime = 0;
  prop = utcFileTime;
}

STDMETHODIMP CHandler::GetProperty(UInt32 index, PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NCOM::CPropVariant prop;
  const CRefItem &refItem = _refItems[index];
  const CItem &item = _items[refItem.ItemIndex];
  const CItem &lastItem = _items[refItem.ItemIndex + refItem.NumItems - 1];

  /*
  const CItem *mainItem = &item;
  if (item.BaseFileIndex >= 0)
    mainItem = &_items[_refItems[item.BaseFileIndex].ItemIndex];
  */
  switch (propID)
  {
    case kpidPath:
    {
      /*
      UString u;
      if (item.BaseFileIndex >= 0)
        u = mainItem->GetName();
      u += item.GetName();
      */
      prop = (const wchar_t *)NItemName::WinNameToOSName(item.GetName());
      break;
    }
    case kpidIsDir: prop = item.IsDir(); break;
    case kpidSize: if (lastItem.Is_Size_Defined()) prop = lastItem.Size; break;
    case kpidPackSize: prop = GetPackSize(index); break;
    case kpidMTime: RarTimeToProp(item.MTime, prop); break;
    case kpidCTime: if (item.CTimeDefined) RarTimeToProp(item.CTime, prop); break;
    case kpidATime: if (item.ATimeDefined) RarTimeToProp(item.ATime, prop); break;
    case kpidAttrib: prop = item.GetWinAttrib(); break;
    case kpidEncrypted: prop = item.IsEncrypted(); break;
    case kpidSolid: prop = IsSolid(index); break;
    case kpidCommented: prop = item.IsCommented(); break;
    case kpidSplitBefore: prop = item.IsSplitBefore(); break;
    case kpidSplitAfter: prop = _items[refItem.ItemIndex + refItem.NumItems - 1].IsSplitAfter(); break;
    case kpidCRC:
    {
      prop = ((lastItem.IsSplitAfter()) ? item.FileCRC : lastItem.FileCRC);
      break;
    }
    case kpidUnpackVer: prop = item.UnPackVersion; break;
    case kpidMethod:
    {
      char s[16];
      Byte m = item.Method;
      if (m < (Byte)'0' || m > (Byte)'5')
        ConvertUInt32ToString(m, s);
      else
      {
        s[0] = 'm';
        s[1] = (char)m;
        s[2] = 0;
        if (!item.IsDir())
        {
          s[2] = ':';
          ConvertUInt32ToString(16 + item.GetDictSize(), &s[3]);
        }
      }
      prop = s;
      break;
    }
    case kpidHostOS: prop = (item.HostOS < ARRAY_SIZE(kHostOS)) ? kHostOS[item.HostOS] : kUnknownOS; break;
  }
  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}


HRESULT CHandler::Open2(IInStream *stream,
    const UInt64 *maxCheckStartPosition,
    IArchiveOpenCallback *openCallback)
{
  {
    CMyComPtr<IArchiveOpenVolumeCallback> openVolumeCallback;
    CMyComPtr<ICryptoGetTextPassword> getTextPassword;
    
    CVolumeName seqName;

    UInt64 totalBytes = 0;
    UInt64 curBytes = 0;

    if (openCallback)
    {
      openCallback->QueryInterface(IID_IArchiveOpenVolumeCallback, (void **)&openVolumeCallback);
      openCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&getTextPassword);
    }

    bool nextVol_is_Required = false;

    CInArchive archive;

    for (;;)
    {
      CMyComPtr<IInStream> inStream;
      if (!_arcs.IsEmpty())
      {
        if (!openVolumeCallback)
          break;
        
        if (_arcs.Size() == 1)
        {
          if (!_arcInfo.IsVolume())
            break;
          UString baseName;
          {
            NCOM::CPropVariant prop;
            RINOK(openVolumeCallback->GetProperty(kpidName, &prop));
            if (prop.vt != VT_BSTR)
              break;
            baseName = prop.bstrVal;
          }
          if (!seqName.InitName(baseName, _arcInfo.HaveNewVolumeName()))
            break;
          /*
          if (_arcInfo.HaveNewVolumeName() && !_arcInfo.IsFirstVolume())
          {
            seqName.MakeBeforeFirstName();
          }
          */
        }

        const UString volName = seqName.GetNextName();
        
        HRESULT result = openVolumeCallback->GetStream(volName, &inStream);

        if (result != S_OK && result != S_FALSE)
          return result;

        if (!inStream || result != S_OK)
        {
          if (nextVol_is_Required)
            _missingVolName = volName;
          break;
        }
      }
      else
        inStream = stream;

      UInt64 endPos = 0;
      RINOK(inStream->Seek(0, STREAM_SEEK_END, &endPos));
      RINOK(inStream->Seek(0, STREAM_SEEK_SET, NULL));
      if (openCallback)
      {
        totalBytes += endPos;
        RINOK(openCallback->SetTotal(NULL, &totalBytes));
      }
      
      RINOK(archive.Open(inStream, maxCheckStartPosition));
      _isArc = true;
      CItem item;
      
      for (;;)
      {
        if (archive.m_Position > endPos)
        {
          _errorFlags |= kpv_ErrorFlags_UnexpectedEnd;
          break;
        }
        
        EErrorType error;
        // bool decryptionError;
        // AString errorMessageLoc;
        bool filled;
        HRESULT result = archive.GetNextItem(item, getTextPassword, filled, error);
        
        if (error != k_ErrorType_OK)
        {
          if (error == k_ErrorType_UnexpectedEnd)
            _errorFlags |= kpv_ErrorFlags_UnexpectedEnd;
          else if (error == k_ErrorType_Corrupted)
            _errorFlags |= kpv_ErrorFlags_HeadersError;
          else if (error == k_ErrorType_DecryptionError)
            _errorFlags |= kpv_ErrorFlags_EncryptedHeadersError;

          // AddErrorMessage(errorMessageLoc);
        }
        RINOK(result);
        
        if (!filled)
        {
          if (error == k_ErrorType_DecryptionError && _items.IsEmpty())
            return S_FALSE;

          if (archive.ArcInfo.ExtraZeroTail_is_Possible())
          {
            /* if there is recovery record for multivolume archive,
               RAR adds 18 bytes (ZERO bytes) at the end for alignment.
               We must skip these bytes to prevent phySize warning. */
            RINOK(inStream->Seek(archive.ArcInfo.EndPos, STREAM_SEEK_SET, NULL));
            bool areThereNonZeros;
            UInt64 numZeros;
            const UInt64 maxSize = 1 << 12;
            RINOK(ReadZeroTail(inStream, areThereNonZeros, numZeros, maxSize));
            if (!areThereNonZeros && numZeros != 0 && numZeros <= maxSize)
              archive.ArcInfo.EndPos += numZeros;
          }
          break;
        }
        
        if (item.IgnoreItem())
          continue;

        bool needAdd = true;
        
        if (item.IsSplitBefore())
        {
          if (!_refItems.IsEmpty())
          {
            CRefItem &refItem = _refItems.Back();
            refItem.NumItems++;
            needAdd = false;
          }
        }
        
        if (needAdd)
        {
          CRefItem refItem;
          refItem.ItemIndex = _items.Size();
          refItem.NumItems = 1;
          refItem.VolumeIndex = _arcs.Size();
          _refItems.Add(refItem);
        }

        _items.Add(item);
        
        if (openCallback && _items.Size() % 100 == 0)
        {
          UInt64 numFiles = _items.Size();
          UInt64 numBytes = curBytes + item.Position;
          RINOK(openCallback->SetCompleted(&numFiles, &numBytes));
        }
      }

      if (archive.HeaderErrorWarning)
        _warningFlags |= kpv_ErrorFlags_HeadersError;

      /*
      if (archive.m_Position < endPos)
        _warningFlags |= kpv_ErrorFlags_DataAfterEnd;
      */
      if (_arcs.IsEmpty())
        _arcInfo = archive.ArcInfo;
      // _arcInfo.EndPos = archive.EndPos;

      curBytes += endPos;
      {
        CArc &arc = _arcs.AddNew();
        arc.PhySize = archive.ArcInfo.GetPhySize();
        arc.Stream = inStream;
      }

      nextVol_is_Required = false;

      if (!archive.ArcInfo.IsVolume())
        break;

      if (archive.ArcInfo.EndOfArchive_was_Read)
      {
        if (!archive.ArcInfo.AreMoreVolumes())
          break;
        nextVol_is_Required = true;
      }
    }
  }

  /*
  int baseFileIndex = -1;
  for (unsigned i = 0; i < _refItems.Size(); i++)
  {
    CItem &item = _items[_refItems[i].ItemIndex];
    if (item.IsAltStream)
      item.BaseFileIndex = baseFileIndex;
    else
      baseFileIndex = i;
  }
  */
  return S_OK;
}

STDMETHODIMP CHandler::Open(IInStream *stream,
    const UInt64 *maxCheckStartPosition,
    IArchiveOpenCallback *openCallback)
{
  COM_TRY_BEGIN
  Close();
  // try
  {
    HRESULT res = Open2(stream, maxCheckStartPosition, openCallback);
    /*
    if (res != S_OK)
      Close();
    */

    return res;
  }
  // catch(const CInArchiveException &) { Close(); return S_FALSE; }
  // catch(...) { Close(); throw; }
  COM_TRY_END
}

STDMETHODIMP CHandler::Close()
{
  COM_TRY_BEGIN
  // _errorMessage.Empty();
  _missingVolName.Empty();
  _errorFlags = 0;
  _warningFlags = 0;
  _isArc = false;
  _refItems.Clear();
  _items.Clear();
  _arcs.Clear();
  return S_OK;
  COM_TRY_END
}

struct CMethodItem
{
  Byte RarUnPackVersion;
  CMyComPtr<ICompressCoder> Coder;
};


class CVolsInStream:
  public ISequentialInStream,
  public CMyUnknownImp
{
  UInt64 _rem;
  ISequentialInStream *_stream;
  const CObjectVector<CArc> *_arcs;
  const CObjectVector<CItem> *_items;
  CRefItem _refItem;
  unsigned _curIndex;
  UInt32 _crc;
  bool _calcCrc;

public:
  MY_UNKNOWN_IMP

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  
  void Init(const CObjectVector<CArc> *arcs,
      const CObjectVector<CItem> *items,
      const CRefItem &refItem)
  {
    _arcs = arcs;
    _items = items;
    _refItem = refItem;
    _curIndex = 0;
    _stream = NULL;
    CrcIsOK = true;
  }

  bool CrcIsOK;
};


STDMETHODIMP CVolsInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  UInt32 realProcessedSize = 0;

  while (size != 0)
  {
    if (!_stream)
    {
      if (_curIndex >= _refItem.NumItems)
        break;
      const CItem &item = (*_items)[_refItem.ItemIndex + _curIndex];
      IInStream *s = (*_arcs)[_refItem.VolumeIndex + _curIndex].Stream;
      RINOK(s->Seek(item.GetDataPosition(), STREAM_SEEK_SET, NULL));
      _stream = s;
      _calcCrc = (CrcIsOK && item.IsSplitAfter());
      _crc = CRC_INIT_VAL;
      _rem = item.PackSize;
    }
    {
      UInt32 cur = size;
      if (cur > _rem)
        cur = (UInt32)_rem;
      UInt32 num = cur;
      HRESULT res = _stream->Read(data, cur, &cur);
      if (_calcCrc)
        _crc = CrcUpdate(_crc, data, cur);
      realProcessedSize += cur;
      if (processedSize)
        *processedSize = realProcessedSize;
      data = (Byte *)data + cur;
      size -= cur;
      _rem -= cur;
      if (_rem == 0)
      {
        const CItem &item = (*_items)[_refItem.ItemIndex + _curIndex];
        _curIndex++;
        if (_calcCrc && CRC_GET_DIGEST(_crc) != item.FileCRC)
          CrcIsOK = false;
        _stream = NULL;
      }
      if (res != S_OK)
        return res;
      if (realProcessedSize != 0)
        return S_OK;
      if (cur == 0 && num != 0)
        return S_OK;
    }
  }

  return S_OK;
}

STDMETHODIMP CHandler::Extract(const UInt32 *indices, UInt32 numItems,
    Int32 testMode, IArchiveExtractCallback *extractCallback)
{
  COM_TRY_BEGIN
  CMyComPtr<ICryptoGetTextPassword> getTextPassword;
  UInt64 censoredTotalUnPacked = 0,
        // censoredTotalPacked = 0,
        importantTotalUnPacked = 0;
        // importantTotalPacked = 0;
  bool allFilesMode = (numItems == (UInt32)(Int32)-1);
  if (allFilesMode)
    numItems = _refItems.Size();
  if (numItems == 0)
    return S_OK;
  unsigned lastIndex = 0;
  CRecordVector<unsigned> importantIndexes;
  CRecordVector<bool> extractStatuses;

  bool isThereUndefinedSize = false;

  for (UInt32 t = 0; t < numItems; t++)
  {
    unsigned index = allFilesMode ? t : indices[t];
    
    {
      const CRefItem &refItem = _refItems[index];
      const CItem &item = _items[refItem.ItemIndex + refItem.NumItems - 1];
      
      if (item.Is_Size_Defined())
        censoredTotalUnPacked += item.Size;
      else
        isThereUndefinedSize = true;
      
      // censoredTotalPacked += item.PackSize;
    }
    
    unsigned j;
    for (j = lastIndex; j <= index; j++)
      // if (!_items[_refItems[j].ItemIndex].IsSolid())
      if (!IsSolid(j))
        lastIndex = j;
  
    for (j = lastIndex; j <= index; j++)
    {
      const CRefItem &refItem = _refItems[j];
      const CItem &item = _items[refItem.ItemIndex + refItem.NumItems - 1];

      if (item.Is_Size_Defined())
        importantTotalUnPacked += item.Size;
      else
        isThereUndefinedSize = true;
      // importantTotalPacked += item.PackSize;
      importantIndexes.Add(j);
      extractStatuses.Add(j == index);
    }

    lastIndex = index + 1;
  }

  if (importantTotalUnPacked != 0 || !isThereUndefinedSize)
  {
    RINOK(extractCallback->SetTotal(importantTotalUnPacked));
  }

  UInt64 currentImportantTotalUnPacked = 0;
  UInt64 currentImportantTotalPacked = 0;
  UInt64 currentUnPackSize, currentPackSize;

  CObjectVector<CMethodItem> methodItems;

  NCompress::CCopyCoder *copyCoderSpec = new NCompress::CCopyCoder;
  CMyComPtr<ICompressCoder> copyCoder = copyCoderSpec;

  CFilterCoder *filterStreamSpec = new CFilterCoder(false);
  CMyComPtr<ISequentialInStream> filterStream = filterStreamSpec;

  NCrypto::NRar2::CDecoder *rar20CryptoDecoderSpec = NULL;
  CMyComPtr<ICompressFilter> rar20CryptoDecoder;
  NCrypto::NRar3::CDecoder *rar3CryptoDecoderSpec = NULL;
  CMyComPtr<ICompressFilter> rar3CryptoDecoder;

  CVolsInStream *volsInStreamSpec = NULL;
  CMyComPtr<ISequentialInStream> volsInStream;

  CLocalProgress *lps = new CLocalProgress;
  CMyComPtr<ICompressProgressInfo> progress = lps;
  lps->Init(extractCallback, false);

  bool solidStart = true;
  
  for (unsigned i = 0;;
      i++,
      currentImportantTotalUnPacked += currentUnPackSize,
      currentImportantTotalPacked += currentPackSize)
  {
    lps->InSize = currentImportantTotalPacked;
    lps->OutSize = currentImportantTotalUnPacked;
    RINOK(lps->SetCur());

    if (i >= importantIndexes.Size())
      break;

    CMyComPtr<ISequentialOutStream> realOutStream;

    Int32 askMode;
    if (extractStatuses[i])
      askMode = testMode ?
          NExtract::NAskMode::kTest :
          NExtract::NAskMode::kExtract;
    else
      askMode = NExtract::NAskMode::kSkip;

    UInt32 index = importantIndexes[i];

    const CRefItem &refItem = _refItems[index];
    const CItem &item = _items[refItem.ItemIndex];
    const CItem &lastItem = _items[refItem.ItemIndex + refItem.NumItems - 1];
    
    UInt64 outSize = (UInt64)(Int64)-1;
    currentUnPackSize = 0;
    if (lastItem.Is_Size_Defined())
    {
      outSize = lastItem.Size;
      currentUnPackSize = outSize;
    }

    currentPackSize = GetPackSize(index);

    if (item.IgnoreItem())
      continue;

    RINOK(extractCallback->GetStream(index, &realOutStream, askMode));

    if (!IsSolid(index))
      solidStart = true;
    if (item.IsDir())
    {
      RINOK(extractCallback->PrepareOperation(askMode));
      RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK));
      continue;
    }

    bool mustBeProcessedAnywhere = false;
    if (i < importantIndexes.Size() - 1)
    {
      // const CRefItem &nextRefItem = _refItems[importantIndexes[i + 1]];
      // const CItem &nextItemInfo = _items[nextRefItem.ItemIndex];
      // mustBeProcessedAnywhere = nextItemInfo.IsSolid();
      mustBeProcessedAnywhere = IsSolid(importantIndexes[i + 1]);
    }
    
    if (!mustBeProcessedAnywhere && !testMode && !realOutStream)
      continue;
    
    if (!realOutStream && !testMode)
      askMode = NExtract::NAskMode::kSkip;

    RINOK(extractCallback->PrepareOperation(askMode));

    COutStreamWithCRC *outStreamSpec = new COutStreamWithCRC;
    CMyComPtr<ISequentialOutStream> outStream(outStreamSpec);
    outStreamSpec->SetStream(realOutStream);
    outStreamSpec->Init();
    realOutStream.Release();
    
    if (!volsInStream)
    {
      volsInStreamSpec = new CVolsInStream;
      volsInStream = volsInStreamSpec;
    }

    volsInStreamSpec->Init(&_arcs, &_items, refItem);

    UInt64 packSize = currentPackSize;

    // packedPos += item.PackSize;
    // unpackedPos += 0;
    
    CMyComPtr<ISequentialInStream> inStream;
    
    if (item.IsEncrypted())
    {
      // CMyComPtr<ICryptoSetPassword> cryptoSetPassword;
      
      if (item.UnPackVersion >= 29)
      {
        if (!rar3CryptoDecoder)
        {
          rar3CryptoDecoderSpec = new NCrypto::NRar3::CDecoder;
          rar3CryptoDecoder = rar3CryptoDecoderSpec;
        }
        // rar3CryptoDecoderSpec->SetRar350Mode(item.UnPackVersion < 36);
        /*
        CMyComPtr<ICompressSetDecoderProperties2> cryptoProperties;
        RINOK(rar3CryptoDecoder.QueryInterface(IID_ICompressSetDecoderProperties2,
            &cryptoProperties));
        */
        RINOK(rar3CryptoDecoderSpec->SetDecoderProperties2(item.Salt, item.HasSalt() ? sizeof(item.Salt) : 0));
        filterStreamSpec->Filter = rar3CryptoDecoder;
      }
      else if (item.UnPackVersion >= 20)
      {
        if (!rar20CryptoDecoder)
        {
          rar20CryptoDecoderSpec = new NCrypto::NRar2::CDecoder;
          rar20CryptoDecoder = rar20CryptoDecoderSpec;
        }
        filterStreamSpec->Filter = rar20CryptoDecoder;
      }
      else
      {
        outStream.Release();
        RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod));
        continue;
      }
      
      // RINOK(filterStreamSpec->Filter.QueryInterface(IID_ICryptoSetPassword, &cryptoSetPassword));

      if (!getTextPassword)
        extractCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&getTextPassword);

      if (!getTextPassword)
      {
        outStream.Release();
        RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod));
        continue;
      }

      // if (getTextPassword)
      {
        CMyComBSTR password;
        RINOK(getTextPassword->CryptoGetTextPassword(&password));
        
        if (item.UnPackVersion >= 29)
        {
          unsigned len = 0;
          if (password)
            len = MyStringLen(password);
          if (len > kPasswordLen_MAX)
            len = kPasswordLen_MAX;
          CByteArr buffer(len * 2);
          for (unsigned k = 0; k < len; k++)
          {
            wchar_t c = password[k];
            ((Byte *)buffer)[k * 2] = (Byte)c;
            ((Byte *)buffer)[k * 2 + 1] = (Byte)(c >> 8);
          }
          rar3CryptoDecoderSpec->SetPassword((const Byte *)buffer, len * 2);
        }
        else
        {
          AString oemPassword;
          if (password)
          {
            UString unicode = (LPCOLESTR)password;
            if (unicode.Len() > kPasswordLen_MAX)
              unicode.DeleteFrom(kPasswordLen_MAX);
            oemPassword = UnicodeStringToMultiByte(unicode, CP_OEMCP);
          }
          rar20CryptoDecoderSpec->SetPassword((const Byte *)(const char *)oemPassword, oemPassword.Len());
        }
      }
      /*
      else
      {
        RINOK(cryptoSetPassword->CryptoSetPassword(NULL, 0));
      }
      */
      
      filterStreamSpec->SetInStream(volsInStream);
      filterStreamSpec->SetOutStreamSize(NULL);
      inStream = filterStream;
    }
    else
    {
      inStream = volsInStream;
    }
    
    CMyComPtr<ICompressCoder> commonCoder;
    
    switch (item.Method)
    {
      case '0':
      {
        commonCoder = copyCoder;
        break;
      }
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      {
        unsigned m;
        for (m = 0; m < methodItems.Size(); m++)
          if (methodItems[m].RarUnPackVersion == item.UnPackVersion)
            break;
        if (m == methodItems.Size())
        {
          CMethodItem mi;
          mi.RarUnPackVersion = item.UnPackVersion;

          mi.Coder.Release();
          if (item.UnPackVersion <= 40)
          {
            UInt32 methodID = 0x40300;
            if (item.UnPackVersion < 20)
              methodID += 1;
            else if (item.UnPackVersion < 29)
              methodID += 2;
            else
              methodID += 3;
            RINOK(CreateCoder(EXTERNAL_CODECS_VARS methodID, false, mi.Coder));
          }
         
          if (mi.Coder == 0)
          {
            outStream.Release();
            RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod));
            continue;
          }

          m = methodItems.Add(mi);
        }
        CMyComPtr<ICompressCoder> decoder = methodItems[m].Coder;

        CMyComPtr<ICompressSetDecoderProperties2> compressSetDecoderProperties;
        RINOK(decoder.QueryInterface(IID_ICompressSetDecoderProperties2,
            &compressSetDecoderProperties));
        
        Byte isSolid = (Byte)((IsSolid(index) || item.IsSplitBefore()) ? 1: 0);
        if (solidStart)
        {
          isSolid = 0;
          solidStart = false;
        }


        RINOK(compressSetDecoderProperties->SetDecoderProperties2(&isSolid, 1));
          
        commonCoder = decoder;
        break;
      }
      default:
        outStream.Release();
        RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnsupportedMethod));
        continue;
    }
    
    HRESULT result = commonCoder->Code(inStream, outStream, &packSize, &outSize, progress);
    
    if (item.IsEncrypted())
      filterStreamSpec->ReleaseInStream();
    
    if (outSize == (UInt64)(Int64)-1)
      currentUnPackSize = outStreamSpec->GetSize();

    int opRes = (volsInStreamSpec->CrcIsOK && outStreamSpec->GetCRC() == lastItem.FileCRC) ?
        NExtract::NOperationResult::kOK:
        NExtract::NOperationResult::kCRCError;
    outStream.Release();

    if (result != S_OK)
    {
      if (result == S_FALSE)
        opRes = NExtract::NOperationResult::kDataError;
      else if (result == E_NOTIMPL)
        opRes = NExtract::NOperationResult::kUnsupportedMethod;
      else
        return result;
    }
    RINOK(extractCallback->SetOperationResult(opRes));
  }
  
  return S_OK;
  COM_TRY_END
}

IMPL_ISetCompressCodecsInfo

REGISTER_ARC_I(
  "Rar", "rar r00", 0, 3,
  kMarker,
  0,
  NArcInfoFlags::kFindSignature,
  NULL)

}}
// RarHandler.h

#ifndef __RAR_HANDLER_H
#define __RAR_HANDLER_H

#include "../IArchive.h"

#include "../../Common/CreateCoder.h"

#include "RarItem.h"

namespace NArchive {
namespace NRar {

struct CInArcInfo
{
  UInt32 Flags;
  Byte EncryptVersion;
  
  UInt64 StartPos;
  UInt64 EndPos;
  UInt64 FileSize;

  UInt32 EndFlags;
  UInt32 VolNumber;
  UInt32 DataCRC;
  bool EndOfArchive_was_Read;

  CInArcInfo(): EndFlags(0), EndOfArchive_was_Read(false) {}

  UInt64 GetPhySize() const { return EndPos - StartPos; }

  bool ExtraZeroTail_is_Possible() const { return IsVolume() && IsRecovery() && EndOfArchive_was_Read; }

  bool IsVolume()           const { return (Flags & NHeader::NArchive::kVolume) != 0; }
  bool IsCommented()        const { return (Flags & NHeader::NArchive::kComment) != 0; }
  // kLock
  bool IsSolid()            const { return (Flags & NHeader::NArchive::kSolid) != 0; }
  bool HaveNewVolumeName()  const { return (Flags & NHeader::NArchive::kNewVolName) != 0; }
  // kAuthenticity
  bool IsRecovery()         const { return (Flags & NHeader::NArchive::kRecovery) != 0; }
  bool IsEncrypted()        const { return (Flags & NHeader::NArchive::kBlockEncryption) != 0; }
  bool IsFirstVolume()      const { return (Flags & NHeader::NArchive::kFirstVolume) != 0; }

  // bool IsThereEncryptVer()  const { return (Flags & NHeader::NArchive::kEncryptVer) != 0; }
  // bool IsEncryptOld()       const { return (!IsThereEncryptVer() || EncryptVersion < 36); }

  bool AreMoreVolumes()       const { return (EndFlags & NHeader::NArchive::kEndOfArc_Flags_NextVol) != 0; }
  bool Is_VolNumber_Defined() const { return (EndFlags & NHeader::NArchive::kEndOfArc_Flags_VolNumber) != 0; }
  bool Is_DataCRC_Defined()   const { return (EndFlags & NHeader::NArchive::kEndOfArc_Flags_DataCRC) != 0; }
};

struct CArc
{
  CMyComPtr<IInStream> Stream;
  UInt64 PhySize;
  // CByteBuffer Comment;

  CArc(): PhySize(0) {}
  ISequentialInStream *CreateLimitedStream(UInt64 offset, UInt64 size) const;
};

struct CRefItem
{
  unsigned VolumeIndex;
  unsigned ItemIndex;
  unsigned NumItems;
};

class CHandler:
  public IInArchive,
  PUBLIC_ISetCompressCodecsInfo
  public CMyUnknownImp
{
  CRecordVector<CRefItem> _refItems;
  CObjectVector<CItem> _items;
  CObjectVector<CArc> _arcs;
  NArchive::NRar::CInArcInfo _arcInfo;
  // AString _errorMessage;
  UInt32 _errorFlags;
  UInt32 _warningFlags;
  bool _isArc;
  UString _missingVolName;

  DECL_EXTERNAL_CODECS_VARS

  UInt64 GetPackSize(unsigned refIndex) const;
  bool IsSolid(unsigned refIndex) const;
  
  /*
  void AddErrorMessage(const AString &s)
  {
    if (!_errorMessage.IsEmpty())
      _errorMessage += '\n';
    _errorMessage += s;
  }
  */

  HRESULT Open2(IInStream *stream,
      const UInt64 *maxCheckStartPosition,
      IArchiveOpenCallback *openCallback);

public:
  MY_QUERYINTERFACE_BEGIN2(IInArchive)
  QUERY_ENTRY_ISetCompressCodecsInfo
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE
  
  INTERFACE_IInArchive(;)

  DECL_ISetCompressCodecsInfo
};

}}

#endif
// Archive/RarHeader.h

#ifndef __ARCHIVE_RAR_HEADER_H
#define __ARCHIVE_RAR_HEADER_H

#include "../../../Common/MyTypes.h"

namespace NArchive {
namespace NRar {
namespace NHeader {

const unsigned kMarkerSize = 7;
  
const unsigned kArchiveSolid = 0x1;

namespace NBlockType
{
  enum EBlockType
  {
    kMarker = 0x72,
    kArchiveHeader,
    kFileHeader,
    kCommentHeader,
    kOldAuthenticity,
    kOldSubBlock,
    kRecoveryRecord,
    kAuthenticity,
    kSubBlock,
    kEndOfArchive
  };
}

namespace NArchive
{
  const UInt16 kVolume  = 1;
  const UInt16 kComment = 2;
  const UInt16 kLock    = 4;
  const UInt16 kSolid   = 8;
  const UInt16 kNewVolName = 0x10; // ('volname.partN.rar')
  const UInt16 kAuthenticity  = 0x20;
  const UInt16 kRecovery = 0x40;
  const UInt16 kBlockEncryption  = 0x80;
  const UInt16 kFirstVolume = 0x100; // (set only by RAR 3.0 and later)

  // const UInt16 kEncryptVer = 0x200; // RAR 3.6 : that feature was discarded by origial RAR

  const UInt16 kEndOfArc_Flags_NextVol   = 1;
  const UInt16 kEndOfArc_Flags_DataCRC   = 2;
  const UInt16 kEndOfArc_Flags_RevSpace  = 4;
  const UInt16 kEndOfArc_Flags_VolNumber = 8;

  const unsigned kHeaderSizeMin = 7;
  
  const unsigned kArchiveHeaderSize = 13;

  const unsigned kBlockHeadersAreEncrypted = 0x80;
}

namespace NFile
{
  const unsigned kSplitBefore = 1 << 0;
  const unsigned kSplitAfter  = 1 << 1;
  const unsigned kEncrypted   = 1 << 2;
  const unsigned kComment     = 1 << 3;
  const unsigned kSolid       = 1 << 4;
  
  const unsigned kDictBitStart     = 5;
  const unsigned kNumDictBits  = 3;
  const unsigned kDictMask         = (1 << kNumDictBits) - 1;
  const unsigned kDictDirectoryValue  = 0x7;
  
  const unsigned kSize64Bits    = 1 << 8;
  const unsigned kUnicodeName   = 1 << 9;
  const unsigned kSalt          = 1 << 10;
  const unsigned kOldVersion    = 1 << 11;
  const unsigned kExtTime       = 1 << 12;
  // const unsigned kExtFlags      = 1 << 13;
  // const unsigned kSkipIfUnknown = 1 << 14;

  const unsigned kLongBlock    = 1 << 15;
  
  /*
  struct CBlock
  {
    // UInt16 HeadCRC;
    // Byte Type;
    // UInt16 Flags;
    // UInt16 HeadSize;
    UInt32 PackSize;
    UInt32 UnPackSize;
    Byte HostOS;
    UInt32 FileCRC;
    UInt32 Time;
    Byte UnPackVersion;
    Byte Method;
    UInt16 NameSize;
    UInt32 Attributes;
  };
  */

  /*
  struct CBlock32
  {
    UInt16 HeadCRC;
    Byte Type;
    UInt16 Flags;
    UInt16 HeadSize;
    UInt32 PackSize;
    UInt32 UnPackSize;
    Byte HostOS;
    UInt32 FileCRC;
    UInt32 Time;
    Byte UnPackVersion;
    Byte Method;
    UInt16 NameSize;
    UInt32 Attributes;
    UInt16 GetRealCRC(const void *aName, UInt32 aNameSize,
        bool anExtraDataDefined = false, Byte *anExtraData = 0) const;
  };
  struct CBlock64
  {
    UInt16 HeadCRC;
    Byte Type;
    UInt16 Flags;
    UInt16 HeadSize;
    UInt32 PackSizeLow;
    UInt32 UnPackSizeLow;
    Byte HostOS;
    UInt32 FileCRC;
    UInt32 Time;
    Byte UnPackVersion;
    Byte Method;
    UInt16 NameSize;
    UInt32 Attributes;
    UInt32 PackSizeHigh;
    UInt32 UnPackSizeHigh;
    UInt16 GetRealCRC(const void *aName, UInt32 aNameSize) const;
  };
  */
  
  const unsigned kLabelFileAttribute            = 0x08;
  const unsigned kWinFileDirectoryAttributeMask = 0x10;
  
  enum CHostOS
  {
    kHostMSDOS = 0,
    kHostOS2   = 1,
    kHostWin32 = 2,
    kHostUnix  = 3,
    kHostMacOS = 4,
    kHostBeOS  = 5
  };
}

namespace NBlock
{
  const UInt16 kLongBlock = 1 << 15;
  struct CBlock
  {
    UInt16 CRC;
    Byte Type;
    UInt16 Flags;
    UInt16 HeadSize;
    //  UInt32 DataSize;
  };
}

/*
struct CSubBlock
{
  UInt16 HeadCRC;
  Byte HeadType;
  UInt16 Flags;
  UInt16 HeadSize;
  UInt32 DataSize;
  UInt16 SubType;
  Byte Level; // Reserved : Must be 0
};

struct CCommentBlock
{
  UInt16 HeadCRC;
  Byte HeadType;
  UInt16 Flags;
  UInt16 HeadSize;
  UInt16 UnpSize;
  Byte UnpVer;
  Byte Method;
  UInt16 CommCRC;
};


struct CProtectHeader
{
  UInt16 HeadCRC;
  Byte HeadType;
  UInt16 Flags;
  UInt16 HeadSize;
  UInt32 DataSize;
  Byte Version;
  UInt16 RecSectors;
  UInt32 TotalBlocks;
  Byte Mark[8];
};
*/

}}}

#endif
// RarItem.h

#ifndef __ARCHIVE_RAR_ITEM_H
#define __ARCHIVE_RAR_ITEM_H

#include "../../../Common/StringConvert.h"

#include "RarHeader.h"

namespace NArchive {
namespace NRar {

struct CRarTime
{
  UInt32 DosTime;
  Byte LowSecond;
  Byte SubTime[3];
};

struct CItem
{
  UInt64 Size;
  UInt64 PackSize;
  
  CRarTime CTime;
  CRarTime ATime;
  CRarTime MTime;

  UInt32 FileCRC;
  UInt32 Attrib;

  UInt16 Flags;
  Byte HostOS;
  Byte UnPackVersion;
  Byte Method;

  bool CTimeDefined;
  bool ATimeDefined;

  AString Name;
  UString UnicodeName;

  Byte Salt[8];
  
  bool Is_Size_Defined() const { return Size != (UInt64)(Int64)-1; }

  bool IsEncrypted()   const { return (Flags & NHeader::NFile::kEncrypted) != 0; }
  bool IsSolid()       const { return (Flags & NHeader::NFile::kSolid) != 0; }
  bool IsCommented()   const { return (Flags & NHeader::NFile::kComment) != 0; }
  bool IsSplitBefore() const { return (Flags & NHeader::NFile::kSplitBefore) != 0; }
  bool IsSplitAfter()  const { return (Flags & NHeader::NFile::kSplitAfter) != 0; }
  bool HasSalt()       const { return (Flags & NHeader::NFile::kSalt) != 0; }
  bool HasExtTime()    const { return (Flags & NHeader::NFile::kExtTime) != 0; }
  bool HasUnicodeName()const { return (Flags & NHeader::NFile::kUnicodeName) != 0; }
  bool IsOldVersion()  const { return (Flags & NHeader::NFile::kOldVersion) != 0; }
  
  UInt32 GetDictSize() const { return (Flags >> NHeader::NFile::kDictBitStart) & NHeader::NFile::kDictMask; }
  bool IsDir() const;
  bool IgnoreItem() const;
  UInt32 GetWinAttrib() const;

  UInt64 Position;
  unsigned MainPartSize;
  UInt16 CommentSize;
  UInt16 AlignSize;

  // int BaseFileIndex;
  // bool IsAltStream;

  UString GetName() const
  {
    if (( /* IsAltStream || */ HasUnicodeName()) && !UnicodeName.IsEmpty())
      return UnicodeName;
    return MultiByteToUnicodeString(Name, CP_OEMCP);
  }

  void Clear()
  {
    CTimeDefined = false;
    ATimeDefined = false;
    Name.Empty();
    UnicodeName.Empty();
    // IsAltStream = false;
    // BaseFileIndex = -1;
  }

  CItem() { Clear(); }

  UInt64 GetFullSize()  const { return MainPartSize + CommentSize + AlignSize + PackSize; }
  //  DWORD GetHeaderWithCommentSize()  const { return MainPartSize + CommentSize; }
  UInt64 GetCommentPosition() const { return Position + MainPartSize; }
  UInt64 GetDataPosition()    const { return GetCommentPosition() + CommentSize + AlignSize; }
};

}}

#endif
// RarVol.h

#ifndef __ARCHIVE_RAR_VOL_H
#define __ARCHIVE_RAR_VOL_H

#include "../../../Common/StringConvert.h"

#include "RarHeader.h"

namespace NArchive {
namespace NRar {

inline bool IsDigit(wchar_t c)
{
  return c >= L'0' && c <= L'9';
}

class CVolumeName
{
  bool _needChangeForNext;
  UString _before;
  UString _changed;
  UString _after;
public:
  CVolumeName(): _needChangeForNext(true) {};

  bool InitName(const UString &name, bool newStyle = true)
  {
    _needChangeForNext = true;
    _after.Empty();
    UString base = name;
    int dotPos = name.ReverseFind_Dot();

    if (dotPos >= 0)
    {
      const UString ext = name.Ptr(dotPos + 1);
      if (ext.IsEqualTo_Ascii_NoCase("rar"))
      {
        _after = name.Ptr(dotPos);
        base.DeleteFrom(dotPos);
      }
      else if (ext.IsEqualTo_Ascii_NoCase("exe"))
      {
        _after.SetFromAscii(".rar");
        base.DeleteFrom(dotPos);
      }
      else if (!newStyle)
      {
        if (ext.IsEqualTo_Ascii_NoCase("000") ||
            ext.IsEqualTo_Ascii_NoCase("001") ||
            ext.IsEqualTo_Ascii_NoCase("r00") ||
            ext.IsEqualTo_Ascii_NoCase("r01"))
        {
          _changed = ext;
          _before = name.Left(dotPos + 1);
          return true;
        }
      }
    }

    if (newStyle)
    {
      unsigned i = base.Len();

      for (; i != 0; i--)
        if (!IsDigit(base[i - 1]))
          break;

      if (i != base.Len())
      {
        _before = base.Left(i);
        _changed = base.Ptr(i);
        return true;
      }
    }
    
    _after.Empty();
    _before = base;
    _before += L'.';
    _changed.SetFromAscii("r00");
    _needChangeForNext = false;
    return true;
  }

  /*
  void MakeBeforeFirstName()
  {
    unsigned len = _changed.Len();
    _changed.Empty();
    for (unsigned i = 0; i < len; i++)
      _changed += L'0';
  }
  */

  UString GetNextName()
  {
    if (_needChangeForNext)
    {
      unsigned i = _changed.Len();
      if (i == 0)
        return UString();
      for (;;)
      {
        wchar_t c = _changed[--i];
        if (c == L'9')
        {
          c = L'0';
          _changed.ReplaceOneCharAtPos(i, c);
          if (i == 0)
          {
            _changed.InsertAtFront(L'1');
            break;
          }
          continue;
        }
        c++;
        _changed.ReplaceOneCharAtPos(i, c);
        break;
      }
    }
    
    _needChangeForNext = true;
    return _before + _changed + _after;
  }
};

}}

#endif
// TarHandler.cpp

#include "StdAfx.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/UTFConvert.h"

#include "../../../Windows/TimeUtils.h"

#include "../../Common/LimitedStreams.h"
#include "../../Common/MethodProps.h"
#include "../../Common/ProgressUtils.h"
#include "../../Common/StreamObjects.h"
#include "../../Common/StreamUtils.h"

#include "../Common/ItemNameUtils.h"

#include "TarHandler.h"

using namespace NWindows;

namespace NArchive {
namespace NTar {

static const UINT k_DefaultCodePage = CP_OEMCP; // it uses it if UTF8 check in names shows error


static const Byte kProps[] =
{
  kpidPath,
  kpidIsDir,
  kpidSize,
  kpidPackSize,
  kpidMTime,
  kpidPosixAttrib,
  kpidUser,
  kpidGroup,
  kpidSymLink,
  kpidHardLink,
  // kpidLinkType
};

static const Byte kArcProps[] =
{
  kpidHeadersSize,
  kpidCodePage
};

IMP_IInArchive_Props
IMP_IInArchive_ArcProps

STDMETHODIMP CHandler::GetArchiveProperty(PROPID propID, PROPVARIANT *value)
{
  NCOM::CPropVariant prop;
  switch (propID)
  {
    case kpidPhySize: if (_phySizeDefined) prop = _phySize; break;
    case kpidHeadersSize: if (_phySizeDefined) prop = _headersSize; break;
    case kpidErrorFlags:
    {
      UInt32 flags = 0;
      if (!_isArc)
        flags |= kpv_ErrorFlags_IsNotArc;
      else switch (_error)
      {
        case k_ErrorType_UnexpectedEnd: flags = kpv_ErrorFlags_UnexpectedEnd; break;
        case k_ErrorType_Corrupted: flags = kpv_ErrorFlags_HeadersError; break;
      }
      prop = flags;
      break;
    }

    case kpidCodePage:
    {
      const char *name = NULL;
      switch (_openCodePage)
      {
        case CP_OEMCP: name = "OEM"; break;
        case CP_UTF8: name = "UTF-8";  break;
      }
      if (name != NULL)
        prop = name;
      else
      {
        char sz[16];
        ConvertUInt32ToString(_openCodePage, sz);
        prop = sz;
      };
      break;
    }
  }
  prop.Detach(value);
  return S_OK;
}

HRESULT CHandler::ReadItem2(ISequentialInStream *stream, bool &filled, CItemEx &item)
{
  item.HeaderPos = _phySize;
  RINOK(ReadItem(stream, filled, item, _error));
  if (filled)
  {
    /*
    if (item.IsSparse())
      _isSparse = true;
    */
    if (item.IsPaxExtendedHeader())
      _thereIsPaxExtendedHeader = true;
  }
  _phySize += item.HeaderSize;
  _headersSize += item.HeaderSize;
  return S_OK;
}

HRESULT CHandler::Open2(IInStream *stream, IArchiveOpenCallback *callback)
{
  UInt64 endPos = 0;
  {
    RINOK(stream->Seek(0, STREAM_SEEK_END, &endPos));
    RINOK(stream->Seek(0, STREAM_SEEK_SET, NULL));
  }
  
  _phySizeDefined = true;
  
  bool utf8_OK = true;
  if (!_forceCodePage)
  {
    if (!utf8_OK)
      _curCodePage = k_DefaultCodePage;
  }

  for (;;)
  {
    CItemEx item;
    bool filled;
    RINOK(ReadItem2(stream, filled, item));
    if (!filled)
      break;

    _isArc = true;
    _items.Add(item);

    if (!_forceCodePage)
    {
      if (utf8_OK) utf8_OK = CheckUTF8(item.Name, item.NameCouldBeReduced);
      if (utf8_OK) utf8_OK = CheckUTF8(item.LinkName, item.LinkNameCouldBeReduced);
      if (utf8_OK) utf8_OK = CheckUTF8(item.User);
      if (utf8_OK) utf8_OK = CheckUTF8(item.Group);
    }
    
    RINOK(stream->Seek(item.GetPackSizeAligned(), STREAM_SEEK_CUR, &_phySize));
    if (_phySize > endPos)
    {
      _error = k_ErrorType_UnexpectedEnd;
      break;
    }
    /*
    if (_phySize == endPos)
    {
      _errorMessage = "There are no trailing zero-filled records";
      break;
    }
    */
    if (callback)
    {
      if (_items.Size() == 1)
      {
        RINOK(callback->SetTotal(NULL, &endPos));
      }
      if ((_items.Size() & 0x3FF) == 0)
      {
        UInt64 numFiles = _items.Size();
        RINOK(callback->SetCompleted(&numFiles, &_phySize));
      }
    }
  }

  if (!_forceCodePage)
  {
    if (!utf8_OK)
      _curCodePage = k_DefaultCodePage;
  }
  _openCodePage = _curCodePage;

  if (_items.Size() == 0)
  {
    if (_error != k_ErrorType_OK)
    {
      _isArc = false;
      return S_FALSE;
    }
    CMyComPtr<IArchiveOpenVolumeCallback> openVolumeCallback;
    if (!callback)
      return S_FALSE;
    callback->QueryInterface(IID_IArchiveOpenVolumeCallback, (void **)&openVolumeCallback);
    if (!openVolumeCallback)
      return S_FALSE;
    NCOM::CPropVariant prop;
    if (openVolumeCallback->GetProperty(kpidName, &prop) != S_OK)
      return S_FALSE;
    if (prop.vt != VT_BSTR)
      return S_FALSE;
    unsigned len = MyStringLen(prop.bstrVal);
    if (len < 4 || MyStringCompareNoCase(prop.bstrVal + len - 4, L".tar") != 0)
      return S_FALSE;
  }

  _isArc = true;
  return S_OK;
}

STDMETHODIMP CHandler::Open(IInStream *stream, const UInt64 *, IArchiveOpenCallback *openArchiveCallback)
{
  COM_TRY_BEGIN
  {
    Close();
    RINOK(Open2(stream, openArchiveCallback));
    _stream = stream;
  }
  return S_OK;
  COM_TRY_END
}

STDMETHODIMP CHandler::OpenSeq(ISequentialInStream *stream)
{
  Close();
  _seqStream = stream;
  _isArc = true;
  return S_OK;
}

STDMETHODIMP CHandler::Close()
{
  _isArc = false;
  _error = k_ErrorType_OK;

  _phySizeDefined = false;
  _phySize = 0;
  _headersSize = 0;
  _curIndex = 0;
  _latestIsRead = false;
  // _isSparse = false;
  _thereIsPaxExtendedHeader = false;
  _items.Clear();
  _seqStream.Release();
  _stream.Release();
  return S_OK;
}

STDMETHODIMP CHandler::GetNumberOfItems(UInt32 *numItems)
{
  *numItems = (_stream ? _items.Size() : (UInt32)(Int32)-1);
  return S_OK;
}

CHandler::CHandler()
{
  copyCoderSpec = new NCompress::CCopyCoder();
  copyCoder = copyCoderSpec;
  _openCodePage = CP_UTF8;
  Init();
}

HRESULT CHandler::SkipTo(UInt32 index)
{
  while (_curIndex < index || !_latestIsRead)
  {
    if (_latestIsRead)
    {
      UInt64 packSize = _latestItem.GetPackSizeAligned();
      RINOK(copyCoderSpec->Code(_seqStream, NULL, &packSize, &packSize, NULL));
      _phySize += copyCoderSpec->TotalSize;
      if (copyCoderSpec->TotalSize != packSize)
      {
        _error = k_ErrorType_UnexpectedEnd;
        return S_FALSE;
      }
      _latestIsRead = false;
      _curIndex++;
    }
    else
    {
      bool filled;
      RINOK(ReadItem2(_seqStream, filled, _latestItem));
      if (!filled)
      {
        _phySizeDefined = true;
        return E_INVALIDARG;
      }
      _latestIsRead = true;
    }
  }
  return S_OK;
}

void CHandler::TarStringToUnicode(const AString &s, NWindows::NCOM::CPropVariant &prop, bool toOs) const
{
  UString dest;
  if (_curCodePage == CP_UTF8)
    ConvertUTF8ToUnicode(s, dest);
  else
    MultiByteToUnicodeString2(dest, s, _curCodePage);
  if (toOs)
    NItemName::ConvertToOSName2(dest);
  prop = dest;
}

STDMETHODIMP CHandler::GetProperty(UInt32 index, PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NCOM::CPropVariant prop;

  const CItemEx *item;
  if (_stream)
    item = &_items[index];
  else
  {
    if (index < _curIndex)
      return E_INVALIDARG;
    else
    {
      RINOK(SkipTo(index));
      item = &_latestItem;
    }
  }

  switch (propID)
  {
    case kpidPath: TarStringToUnicode(item->Name, prop, true); break;
    case kpidIsDir: prop = item->IsDir(); break;
    case kpidSize: prop = item->GetUnpackSize(); break;
    case kpidPackSize: prop = item->GetPackSizeAligned(); break;
    case kpidMTime:
      if (item->MTime != 0)
      {
        FILETIME ft;
        if (NTime::UnixTime64ToFileTime(item->MTime, ft))
          prop = ft;
      }
      break;
    case kpidPosixAttrib: prop = item->Mode; break;
    case kpidUser:  TarStringToUnicode(item->User, prop); break;
    case kpidGroup: TarStringToUnicode(item->Group, prop); break;
    case kpidSymLink:  if (item->LinkFlag == NFileHeader::NLinkFlag::kSymLink  && !item->LinkName.IsEmpty()) TarStringToUnicode(item->LinkName, prop); break;
    case kpidHardLink: if (item->LinkFlag == NFileHeader::NLinkFlag::kHardLink && !item->LinkName.IsEmpty()) TarStringToUnicode(item->LinkName, prop); break;
    // case kpidLinkType: prop = (int)item->LinkFlag; break;
  }
  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}

HRESULT CHandler::Extract(const UInt32 *indices, UInt32 numItems,
    Int32 testMode, IArchiveExtractCallback *extractCallback)
{
  COM_TRY_BEGIN
  ISequentialInStream *stream = _seqStream;
  bool seqMode = (_stream == NULL);
  if (!seqMode)
    stream = _stream;

  bool allFilesMode = (numItems == (UInt32)(Int32)-1);
  if (allFilesMode)
    numItems = _items.Size();
  if (_stream && numItems == 0)
    return S_OK;
  UInt64 totalSize = 0;
  UInt32 i;
  for (i = 0; i < numItems; i++)
    totalSize += _items[allFilesMode ? i : indices[i]].GetUnpackSize();
  extractCallback->SetTotal(totalSize);

  UInt64 totalPackSize;
  totalSize = totalPackSize = 0;
  
  CLocalProgress *lps = new CLocalProgress;
  CMyComPtr<ICompressProgressInfo> progress = lps;
  lps->Init(extractCallback, false);

  CLimitedSequentialInStream *streamSpec = new CLimitedSequentialInStream;
  CMyComPtr<ISequentialInStream> inStream(streamSpec);
  streamSpec->SetStream(stream);

  CLimitedSequentialOutStream *outStreamSpec = new CLimitedSequentialOutStream;
  CMyComPtr<ISequentialOutStream> outStream(outStreamSpec);

  for (i = 0; i < numItems || seqMode; i++)
  {
    lps->InSize = totalPackSize;
    lps->OutSize = totalSize;
    RINOK(lps->SetCur());
    CMyComPtr<ISequentialOutStream> realOutStream;
    Int32 askMode = testMode ?
        NExtract::NAskMode::kTest :
        NExtract::NAskMode::kExtract;
    Int32 index = allFilesMode ? i : indices[i];
    const CItemEx *item;
    if (seqMode)
    {
      HRESULT res = SkipTo(index);
      if (res == E_INVALIDARG)
        break;
      RINOK(res);
      item = &_latestItem;
    }
    else
      item = &_items[index];

    RINOK(extractCallback->GetStream(index, &realOutStream, askMode));
    UInt64 unpackSize = item->GetUnpackSize();
    totalSize += unpackSize;
    totalPackSize += item->GetPackSizeAligned();
    if (item->IsDir())
    {
      RINOK(extractCallback->PrepareOperation(askMode));
      RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK));
      continue;
    }
    bool skipMode = false;
    if (!testMode && !realOutStream)
    {
      if (!seqMode)
      {
        /*
        // probably we must show extracting info it callback handler instead
        if (item->IsHardLink() ||
            item->IsSymLink())
        {
          RINOK(extractCallback->PrepareOperation(askMode));
          RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK));
        }
        */
        continue;
      }
      skipMode = true;
      askMode = NExtract::NAskMode::kSkip;
    }
    RINOK(extractCallback->PrepareOperation(askMode));

    outStreamSpec->SetStream(realOutStream);
    realOutStream.Release();
    outStreamSpec->Init(skipMode ? 0 : unpackSize, true);

    Int32 opRes = NExtract::NOperationResult::kOK;
    CMyComPtr<ISequentialInStream> inStream2;
    if (!item->IsSparse())
      inStream2 = inStream;
    else
    {
      GetStream(index, &inStream2);
      if (!inStream2)
        return E_FAIL;
    }

    {
      if (item->IsSymLink())
      {
        RINOK(WriteStream(outStreamSpec, (const char *)item->LinkName, item->LinkName.Len()));
      }
      else
      {
        if (!seqMode)
        {
          RINOK(_stream->Seek(item->GetDataPosition(), STREAM_SEEK_SET, NULL));
        }
        streamSpec->Init(item->GetPackSizeAligned());
        RINOK(copyCoder->Code(inStream2, outStream, NULL, NULL, progress));
      }
      if (outStreamSpec->GetRem() != 0)
        opRes = NExtract::NOperationResult::kDataError;
    }
    if (seqMode)
    {
      _latestIsRead = false;
      _curIndex++;
    }
    outStreamSpec->ReleaseStream();
    RINOK(extractCallback->SetOperationResult(opRes));
  }
  return S_OK;
  COM_TRY_END
}

class CSparseStream:
  public IInStream,
  public CMyUnknownImp
{
  UInt64 _phyPos;
  UInt64 _virtPos;
  bool _needStartSeek;

public:
  CHandler *Handler;
  CMyComPtr<IUnknown> HandlerRef;
  unsigned ItemIndex;
  CRecordVector<UInt64> PhyOffsets;

  MY_UNKNOWN_IMP2(ISequentialInStream, IInStream)
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);

  void Init()
  {
    _virtPos = 0;
    _phyPos = 0;
    _needStartSeek = true;
  }
};


STDMETHODIMP CSparseStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (size == 0)
    return S_OK;
  const CItemEx &item = Handler->_items[ItemIndex];
  if (_virtPos >= item.Size)
    return S_OK;
  {
    UInt64 rem = item.Size - _virtPos;
    if (size > rem)
      size = (UInt32)rem;
  }
  
  HRESULT res = S_OK;

  if (item.SparseBlocks.IsEmpty())
    memset(data, 0, size);
  else
  {
    unsigned left = 0, right = item.SparseBlocks.Size();
    for (;;)
    {
      unsigned mid = (left + right) / 2;
      if (mid == left)
        break;
      if (_virtPos < item.SparseBlocks[mid].Offset)
        right = mid;
      else
        left = mid;
    }
    
    const CSparseBlock &sb = item.SparseBlocks[left];
    UInt64 relat = _virtPos - sb.Offset;
    
    if (_virtPos >= sb.Offset && relat < sb.Size)
    {
      UInt64 rem = sb.Size - relat;
      if (size > rem)
        size = (UInt32)rem;
      UInt64 phyPos = PhyOffsets[left] + relat;
      if (_needStartSeek || _phyPos != phyPos)
      {
        RINOK(Handler->_stream->Seek(item.GetDataPosition() + phyPos, STREAM_SEEK_SET, NULL));
        _needStartSeek = false;
        _phyPos = phyPos;
      }
      res = Handler->_stream->Read(data, size, &size);
      _phyPos += size;
    }
    else
    {
      UInt64 next = item.Size;
      if (_virtPos < sb.Offset)
        next = sb.Offset;
      else if (left + 1 < item.SparseBlocks.Size())
        next = item.SparseBlocks[left + 1].Offset;
      UInt64 rem = next - _virtPos;
      if (size > rem)
        size = (UInt32)rem;
      memset(data, 0, size);
    }
  }
  
  _virtPos += size;
  if (processedSize)
    *processedSize = size;
  return res;
}

STDMETHODIMP CSparseStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _virtPos; break;
    case STREAM_SEEK_END: offset += Handler->_items[ItemIndex].Size; break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _virtPos = offset;
  if (newPosition)
    *newPosition = _virtPos;
  return S_OK;
}

STDMETHODIMP CHandler::GetStream(UInt32 index, ISequentialInStream **stream)
{
  COM_TRY_BEGIN
  
  const CItemEx &item = _items[index];

  if (item.IsSparse())
  {
    CSparseStream *streamSpec = new CSparseStream;
    CMyComPtr<IInStream> streamTemp = streamSpec;
    streamSpec->Init();
    streamSpec->Handler = this;
    streamSpec->HandlerRef = (IInArchive *)this;
    streamSpec->ItemIndex = index;
    streamSpec->PhyOffsets.Reserve(item.SparseBlocks.Size());
    UInt64 offs = 0;
    FOR_VECTOR(i, item.SparseBlocks)
    {
      const CSparseBlock &sb = item.SparseBlocks[i];
      streamSpec->PhyOffsets.AddInReserved(offs);
      offs += sb.Size;
    }
    *stream = streamTemp.Detach();
    return S_OK;
  }
  
  if (item.IsSymLink())
  {
    Create_BufInStream_WithReference((const Byte *)(const char *)item.LinkName, item.LinkName.Len(), (IInArchive *)this, stream);
    return S_OK;
  }
  
  return CreateLimitedInStream(_stream, item.GetDataPosition(), item.PackSize, stream);
  
  COM_TRY_END
}

void CHandler::Init()
{
  _forceCodePage = false;
  // _codePage = CP_OEMCP;
  _curCodePage = _specifiedCodePage = CP_UTF8;  // CP_OEMCP;
  _thereIsPaxExtendedHeader = false;
}

STDMETHODIMP CHandler::SetProperties(const wchar_t * const *names, const PROPVARIANT *values, UInt32 numProps)
{
  Init();

  for (UInt32 i = 0; i < numProps; i++)
  {
    UString name = names[i];
    name.MakeLower_Ascii();
    if (name.IsEmpty())
      return E_INVALIDARG;

    const PROPVARIANT &prop = values[i];

    if (name[0] == L'x')
    {
      // some clients write 'x' property. So we support it
      UInt32 level = 0;
      RINOK(ParsePropToUInt32(name.Ptr(1), prop, level));
    }
    else if (name.IsEqualTo("cp"))
    {
      UInt32 cp = CP_OEMCP;
      RINOK(ParsePropToUInt32(L"", prop, cp));
      _forceCodePage = true;
      _curCodePage = _specifiedCodePage = cp;
    }
    else
      return E_INVALIDARG;
  }
  return S_OK;
}

}}
// TarHandler.h

#ifndef __TAR_HANDLER_H
#define __TAR_HANDLER_H

#include "../../../Common/MyCom.h"

#include "../../../Windows/PropVariant.h"

#include "../../Compress/CopyCoder.h"

#include "../IArchive.h"

#include "TarIn.h"

namespace NArchive {
namespace NTar {

class CHandler:
  public IInArchive,
  public IArchiveOpenSeq,
  public IInArchiveGetStream,
  public ISetProperties,
  public IOutArchive,
  public CMyUnknownImp
{
public:
  CObjectVector<CItemEx> _items;
  CMyComPtr<IInStream> _stream;
  CMyComPtr<ISequentialInStream> _seqStream;
private:
  UInt32 _curIndex;
  bool _latestIsRead;
  CItemEx _latestItem;

  UInt64 _phySize;
  UInt64 _headersSize;
  bool _phySizeDefined;
  EErrorType _error;
  bool _isArc;

  // bool _isSparse;
  bool _thereIsPaxExtendedHeader;

  bool _forceCodePage;
  UInt32 _specifiedCodePage;
  UInt32 _curCodePage;
  UInt32 _openCodePage;

  NCompress::CCopyCoder *copyCoderSpec;
  CMyComPtr<ICompressCoder> copyCoder;

  HRESULT ReadItem2(ISequentialInStream *stream, bool &filled, CItemEx &itemInfo);
  HRESULT Open2(IInStream *stream, IArchiveOpenCallback *callback);
  HRESULT SkipTo(UInt32 index);
  void TarStringToUnicode(const AString &s, NWindows::NCOM::CPropVariant &prop, bool toOs = false) const;
public:
  MY_UNKNOWN_IMP5(
    IInArchive,
    IArchiveOpenSeq,
    IInArchiveGetStream,
    ISetProperties,
    IOutArchive
  )

  INTERFACE_IInArchive(;)
  INTERFACE_IOutArchive(;)
  STDMETHOD(OpenSeq)(ISequentialInStream *stream);
  STDMETHOD(GetStream)(UInt32 index, ISequentialInStream **stream);
  STDMETHOD(SetProperties)(const wchar_t * const *names, const PROPVARIANT *values, UInt32 numProps);

  void Init();
  CHandler();
};

}}

#endif
// TarHandlerOut.cpp

#include "StdAfx.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/Defs.h"
#include "../../../Common/MyLinux.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/UTFConvert.h"

#include "../../../Windows/PropVariant.h"
#include "../../../Windows/TimeUtils.h"

#include "TarHandler.h"
#include "TarUpdate.h"

using namespace NWindows;

namespace NArchive {
namespace NTar {

STDMETHODIMP CHandler::GetFileTimeType(UInt32 *type)
{
  *type = NFileTimeType::kUnix;
  return S_OK;
}

HRESULT GetPropString(IArchiveUpdateCallback *callback, UInt32 index, PROPID propId,
    AString &res, UINT codePage, bool convertSlash = false)
{
  NCOM::CPropVariant prop;
  RINOK(callback->GetProperty(index, propId, &prop));
  
  if (prop.vt == VT_BSTR)
  {
    UString s = prop.bstrVal;
    if (convertSlash)
      s = NItemName::MakeLegalName(s);

    if (codePage == CP_UTF8)
    {
      ConvertUnicodeToUTF8(s, res);
      // if (!ConvertUnicodeToUTF8(s, res)) // return E_INVALIDARG;
    }
    else
      UnicodeStringToMultiByte2(res, s, codePage);
  }
  else if (prop.vt != VT_EMPTY)
    return E_INVALIDARG;

  return S_OK;
}


// sort old files with original order.

static int CompareUpdateItems(void *const *p1, void *const *p2, void *)
{
  const CUpdateItem &u1 = *(*((const CUpdateItem **)p1));
  const CUpdateItem &u2 = *(*((const CUpdateItem **)p2));
  if (!u1.NewProps)
  {
    if (u2.NewProps)
      return -1;
    return MyCompare(u1.IndexInArc, u2.IndexInArc);
  }
  if (!u2.NewProps)
    return 1;
  return MyCompare(u1.IndexInClient, u2.IndexInClient);
}


STDMETHODIMP CHandler::UpdateItems(ISequentialOutStream *outStream, UInt32 numItems,
    IArchiveUpdateCallback *callback)
{
  COM_TRY_BEGIN

  if ((_stream && (_error != k_ErrorType_OK /* || _isSparse */)) || _seqStream)
    return E_NOTIMPL;
  CObjectVector<CUpdateItem> updateItems;
  UINT codePage = (_forceCodePage ? _specifiedCodePage : _openCodePage);
  
  for (UInt32 i = 0; i < numItems; i++)
  {
    CUpdateItem ui;
    Int32 newData;
    Int32 newProps;
    UInt32 indexInArc;
    
    if (!callback)
      return E_FAIL;
    
    RINOK(callback->GetUpdateItemInfo(i, &newData, &newProps, &indexInArc));
    
    ui.NewProps = IntToBool(newProps);
    ui.NewData = IntToBool(newData);
    ui.IndexInArc = indexInArc;
    ui.IndexInClient = i;

    if (IntToBool(newProps))
    {
      {
        NCOM::CPropVariant prop;
        RINOK(callback->GetProperty(i, kpidIsDir, &prop));
        if (prop.vt == VT_EMPTY)
          ui.IsDir = false;
        else if (prop.vt != VT_BOOL)
          return E_INVALIDARG;
        else
          ui.IsDir = (prop.boolVal != VARIANT_FALSE);
      }

      {
        NCOM::CPropVariant prop;
        RINOK(callback->GetProperty(i, kpidPosixAttrib, &prop));
        if (prop.vt == VT_EMPTY)
          ui.Mode =
                MY_LIN_S_IRWXO
              | MY_LIN_S_IRWXG
              | MY_LIN_S_IRWXU
              | (ui.IsDir ? MY_LIN_S_IFDIR : MY_LIN_S_IFREG);
        else if (prop.vt != VT_UI4)
          return E_INVALIDARG;
        else
          ui.Mode = prop.ulVal;
      }

      {
        NCOM::CPropVariant prop;
        RINOK(callback->GetProperty(i, kpidMTime, &prop));
        if (prop.vt == VT_EMPTY)
          ui.MTime = 0;
        else if (prop.vt != VT_FILETIME)
          return E_INVALIDARG;
        else
          ui.MTime = NTime::FileTimeToUnixTime64(prop.filetime);
      }
      
      RINOK(GetPropString(callback, i, kpidPath, ui.Name, codePage, true));
      if (ui.IsDir && !ui.Name.IsEmpty() && ui.Name.Back() != '/')
        ui.Name += '/';
      RINOK(GetPropString(callback, i, kpidUser, ui.User, codePage));
      RINOK(GetPropString(callback, i, kpidGroup, ui.Group, codePage));
    }

    if (IntToBool(newData))
    {
      NCOM::CPropVariant prop;
      RINOK(callback->GetProperty(i, kpidSize, &prop));
      if (prop.vt != VT_UI8)
        return E_INVALIDARG;
      ui.Size = prop.uhVal.QuadPart;
      /*
      // now we support GNU extension for big files
      if (ui.Size >= ((UInt64)1 << 33))
        return E_INVALIDARG;
      */
    }
    
    updateItems.Add(ui);
  }
  
  if (_thereIsPaxExtendedHeader)
  {
    // we restore original order of files, if there is pax header block
    updateItems.Sort(CompareUpdateItems, NULL);
  }
  
  return UpdateArchive(_stream, outStream, _items, updateItems, codePage, callback);
  
  COM_TRY_END
}

}}
// Archive/TarHeader.cpp

#include "StdAfx.h"

#include "TarHeader.h"

namespace NArchive {
namespace NTar {
namespace NFileHeader {

  const char *kLongLink = "././@LongLink";
  const char *kLongLink2 = "@LongLink";

  // The magic field is filled with this if uname and gname are valid.
  namespace NMagic
  {
    // const char *kUsTar  = "ustar";   // 5 chars
    // const char *kGNUTar = "GNUtar "; // 7 chars and a null
    // const char *kEmpty = "\0\0\0\0\0\0\0\0";
    const char kUsTar_00[8] = { 'u', 's', 't', 'a', 'r', 0, '0', '0' } ;
  }

}}}
// Archive/TarHeader.h

#ifndef __ARCHIVE_TAR_HEADER_H
#define __ARCHIVE_TAR_HEADER_H

#include "../../../Common/MyTypes.h"

namespace NArchive {
namespace NTar {

namespace NFileHeader
{
  const unsigned kRecordSize = 512;
  const unsigned kNameSize = 100;
  const unsigned kUserNameSize = 32;
  const unsigned kGroupNameSize = 32;
  const unsigned kPrefixSize = 155;

  const unsigned kUstarMagic_Offset = 257;

  /*
  struct CHeader
  {
    char Name[kNameSize];
    char Mode[8];
    char UID[8];
    char GID[8];
    char Size[12];
    char ModificationTime[12];
    char CheckSum[8];
    char LinkFlag;
    char LinkName[kNameSize];
    char Magic[8];
    char UserName[kUserNameSize];
    char GroupName[kGroupNameSize];
    char DeviceMajor[8];
    char DeviceMinor[8];
    char Prefix[155];
  };
  union CRecord
  {
    CHeader Header;
    Byte Padding[kRecordSize];
  };
  */

  namespace NLinkFlag
  {
    const char kOldNormal    = 0;   // Normal disk file, Unix compatible
    const char kNormal       = '0'; // Normal disk file
    const char kHardLink     = '1'; // Link to previously dumped file
    const char kSymLink      = '2'; // Symbolic link
    const char kCharacter    = '3'; // Character special file
    const char kBlock        = '4'; // Block special file
    const char kDirectory    = '5'; // Directory
    const char kFIFO         = '6'; // FIFO special file
    const char kContiguous   = '7'; // Contiguous file
    const char kGnu_LongLink = 'K';
    const char kGnu_LongName = 'L';
    const char kSparse       = 'S';
    const char kDumpDir      = 'D'; /* GNUTYPE_DUMPDIR.
      data: list of files created by the --incremental (-G) option
      Each file name is preceded by either
        - 'Y' (file should be in this archive)
        - 'N' (file is a directory, or is not stored in the archive.)
        Each file name is terminated by a null + an additional null after
        the last file name. */
  }

  extern const char *kLongLink;  //   = "././@LongLink";
  extern const char *kLongLink2; //   = "@LongLink";

  namespace NMagic
  {
    // extern const char *kUsTar;  //  = "ustar"; // 5 chars
    // extern const char *kGNUTar; //  = "GNUtar "; // 7 chars and a null
    // extern const char *kEmpty;  //  = "\0\0\0\0\0\0\0\0"
    extern const char kUsTar_00[];
  }
}

}}

#endif
// TarIn.cpp

#include "StdAfx.h"

#include "../../../../C/CpuArch.h"

#include "../../../Common/StringToInt.h"

#include "../../Common/StreamUtils.h"

#include "../IArchive.h"

#include "TarIn.h"

namespace NArchive {
namespace NTar {
 
static void MyStrNCpy(char *dest, const char *src, unsigned size)
{
  for (unsigned i = 0; i < size; i++)
  {
    char c = src[i];
    dest[i] = c;
    if (c == 0)
      break;
  }
}

static bool OctalToNumber(const char *srcString, unsigned size, UInt64 &res)
{
  char sz[32];
  MyStrNCpy(sz, srcString, size);
  sz[size] = 0;
  const char *end;
  unsigned i;
  for (i = 0; sz[i] == ' '; i++);
  res = ConvertOctStringToUInt64(sz + i, &end);
  if (end == sz + i)
    return false;
  return (*end == ' ' || *end == 0);
}

static bool OctalToNumber32(const char *srcString, unsigned size, UInt32 &res)
{
  UInt64 res64;
  if (!OctalToNumber(srcString, size, res64))
    return false;
  res = (UInt32)res64;
  return (res64 <= 0xFFFFFFFF);
}

#define RIF(x) { if (!(x)) return S_OK; }

/*
static bool IsEmptyData(const char *buf, size_t size)
{
  for (unsigned i = 0; i < size; i++)
    if (buf[i] != 0)
      return false;
  return true;
}
*/

static bool IsRecordLast(const char *buf)
{
  for (unsigned i = 0; i < NFileHeader::kRecordSize; i++)
    if (buf[i] != 0)
      return false;
  return true;
}

static void ReadString(const char *s, unsigned size, AString &result)
{
  char temp[NFileHeader::kRecordSize + 1];
  MyStrNCpy(temp, s, size);
  temp[size] = '\0';
  result = temp;
}

static bool ParseInt64(const char *p, Int64 &val)
{
  UInt32 h = GetBe32(p);
  val = GetBe64(p + 4);
  if (h == (UInt32)1 << 31)
    return ((val >> 63) & 1) == 0;
  if (h == (UInt32)(Int32)-1)
    return ((val >> 63) & 1) != 0;
  UInt64 uv;
  bool res = OctalToNumber(p, 12, uv);
  val = uv;
  return res;
}

static bool ParseSize(const char *p, UInt64 &val)
{
  if (GetBe32(p) == (UInt32)1 << 31)
  {
    // GNU extension
    val = GetBe64(p + 4);
    return ((val >> 63) & 1) == 0;
  }
  return OctalToNumber(p, 12, val);
}

#define CHECK(x) { if (!(x)) return k_IsArc_Res_NO; }

API_FUNC_IsArc IsArc_Tar(const Byte *p2, size_t size)
{
  if (size < NFileHeader::kRecordSize)
    return k_IsArc_Res_NEED_MORE;

  const char *p = (const char *)p2;
  p += NFileHeader::kNameSize;

  UInt32 mode;
  CHECK(OctalToNumber32(p, 8, mode)); p += 8;

  // if (!OctalToNumber32(p, 8, item.UID)) item.UID = 0;
  p += 8;
  // if (!OctalToNumber32(p, 8, item.GID)) item.GID = 0;
  p += 8;

  UInt64 packSize;
  Int64 time;
  UInt32 checkSum;
  CHECK(ParseSize(p, packSize)); p += 12;
  CHECK(ParseInt64(p, time)); p += 12;
  CHECK(OctalToNumber32(p, 8, checkSum));
  return k_IsArc_Res_YES;
}

static HRESULT GetNextItemReal(ISequentialInStream *stream, bool &filled, CItemEx &item, EErrorType &error)
{
  char buf[NFileHeader::kRecordSize];
  char *p = buf;

  error = k_ErrorType_OK;
  filled = false;

  bool thereAreEmptyRecords = false;
  for (;;)
  {
    size_t processedSize = NFileHeader::kRecordSize;
    RINOK(ReadStream(stream, buf, &processedSize));
    if (processedSize == 0)
    {
      if (!thereAreEmptyRecords)
        error = k_ErrorType_UnexpectedEnd; // "There are no trailing zero-filled records";
      return S_OK;
    }
    if (processedSize != NFileHeader::kRecordSize)
    {
      if (!thereAreEmptyRecords)
        error = k_ErrorType_UnexpectedEnd; // error = "There is no correct record at the end of archive";
      else
      {
        /*
        if (IsEmptyData(buf, processedSize))
          error = k_ErrorType_UnexpectedEnd;
        else
        {
          // extraReadSize = processedSize;
          // error = k_ErrorType_Corrupted; // some data after the end tail zeros
        }
        */
      }

      return S_OK;
    }
    if (!IsRecordLast(buf))
      break;
    item.HeaderSize += NFileHeader::kRecordSize;
    thereAreEmptyRecords = true;
  }
  if (thereAreEmptyRecords)
  {
    // error = "There are data after end of archive";
    return S_OK;
  }
  
  error = k_ErrorType_Corrupted;
  ReadString(p, NFileHeader::kNameSize, item.Name); p += NFileHeader::kNameSize;
  item.NameCouldBeReduced =
      (item.Name.Len() == NFileHeader::kNameSize ||
       item.Name.Len() == NFileHeader::kNameSize - 1);

  RIF(OctalToNumber32(p, 8, item.Mode)); p += 8;

  if (!OctalToNumber32(p, 8, item.UID)) item.UID = 0; p += 8;
  if (!OctalToNumber32(p, 8, item.GID)) item.GID = 0; p += 8;

  RIF(ParseSize(p, item.PackSize));
  item.Size = item.PackSize;
  p += 12;
  RIF(ParseInt64(p, item.MTime)); p += 12;
  
  UInt32 checkSum;
  RIF(OctalToNumber32(p, 8, checkSum));
  memset(p, ' ', 8); p += 8;

  item.LinkFlag = *p++;

  ReadString(p, NFileHeader::kNameSize, item.LinkName); p += NFileHeader::kNameSize;
  item.LinkNameCouldBeReduced =
      (item.LinkName.Len() == NFileHeader::kNameSize ||
       item.LinkName.Len() == NFileHeader::kNameSize - 1);

  memcpy(item.Magic, p, 8); p += 8;

  ReadString(p, NFileHeader::kUserNameSize, item.User); p += NFileHeader::kUserNameSize;
  ReadString(p, NFileHeader::kGroupNameSize, item.Group); p += NFileHeader::kGroupNameSize;

  item.DeviceMajorDefined = (p[0] != 0); if (item.DeviceMajorDefined) { RIF(OctalToNumber32(p, 8, item.DeviceMajor)); } p += 8;
  item.DeviceMinorDefined = (p[0] != 0); if (item.DeviceMinorDefined) { RIF(OctalToNumber32(p, 8, item.DeviceMinor)); } p += 8;

  if (p[0] != 0)
  {
    AString prefix;
    ReadString(p, NFileHeader::kPrefixSize, prefix);
    if (!prefix.IsEmpty()
        && item.IsUstarMagic()
        && (item.LinkFlag != 'L' /* || prefix != "00000000000" */ ))
      item.Name = prefix + '/' + item.Name;
  }

  p += NFileHeader::kPrefixSize;

  if (item.LinkFlag == NFileHeader::NLinkFlag::kHardLink)
  {
    item.PackSize = 0;
    item.Size = 0;
  }
  /*
    TAR standard requires sum of unsigned byte values.
    But some TAR programs use sum of signed byte values.
    So we check both values.
  */
  UInt32 checkSumReal = 0;
  Int32 checkSumReal_Signed = 0;
  for (unsigned i = 0; i < NFileHeader::kRecordSize; i++)
  {
    char c = buf[i];
    checkSumReal_Signed += (signed char)c;
    checkSumReal += (Byte)buf[i];
  }
  
  if (checkSumReal != checkSum)
  {
    if ((UInt32)checkSumReal_Signed != checkSum)
      return S_OK;
  }

  item.HeaderSize += NFileHeader::kRecordSize;

  if (item.LinkFlag == NFileHeader::NLinkFlag::kSparse)
  {
    Byte isExtended = buf[482];
    if (isExtended != 0 && isExtended != 1)
      return S_OK;
    RIF(ParseSize(buf + 483, item.Size));
    UInt64 min = 0;
    for (unsigned i = 0; i < 4; i++)
    {
      p = buf + 386 + 24 * i;
      if (GetBe32(p) == 0)
      {
        if (isExtended != 0)
          return S_OK;
        break;
      }
      CSparseBlock sb;
      RIF(ParseSize(p, sb.Offset));
      RIF(ParseSize(p + 12, sb.Size));
      item.SparseBlocks.Add(sb);
      if (sb.Offset < min || sb.Offset > item.Size)
        return S_OK;
      if ((sb.Offset & 0x1FF) != 0 || (sb.Size & 0x1FF) != 0)
        return S_OK;
      min = sb.Offset + sb.Size;
      if (min < sb.Offset)
        return S_OK;
    }
    if (min > item.Size)
      return S_OK;

    while (isExtended != 0)
    {
      size_t processedSize = NFileHeader::kRecordSize;
      RINOK(ReadStream(stream, buf, &processedSize));
      if (processedSize != NFileHeader::kRecordSize)
      {
        error = k_ErrorType_UnexpectedEnd;
        return S_OK;
      }

      item.HeaderSize += NFileHeader::kRecordSize;
      isExtended = buf[21 * 24];
      if (isExtended != 0 && isExtended != 1)
        return S_OK;
      for (unsigned i = 0; i < 21; i++)
      {
        p = buf + 24 * i;
        if (GetBe32(p) == 0)
        {
          if (isExtended != 0)
            return S_OK;
          break;
        }
        CSparseBlock sb;
        RIF(ParseSize(p, sb.Offset));
        RIF(ParseSize(p + 12, sb.Size));
        item.SparseBlocks.Add(sb);
        if (sb.Offset < min || sb.Offset > item.Size)
          return S_OK;
        if ((sb.Offset & 0x1FF) != 0 || (sb.Size & 0x1FF) != 0)
          return S_OK;
        min = sb.Offset + sb.Size;
        if (min < sb.Offset)
          return S_OK;
      }
    }
    if (min > item.Size)
      return S_OK;
  }
 
  filled = true;
  error = k_ErrorType_OK;
  return S_OK;
}

HRESULT ReadItem(ISequentialInStream *stream, bool &filled, CItemEx &item, EErrorType &error)
{
  item.HeaderSize = 0;
  bool flagL = false;
  bool flagK = false;
  AString nameL;
  AString nameK;
  
  for (;;)
  {
    RINOK(GetNextItemReal(stream, filled, item, error));
    if (!filled)
    {
      if (error == k_ErrorType_OK && (flagL || flagK))
        error = k_ErrorType_Corrupted;
      return S_OK;
    }
    
    if (error != k_ErrorType_OK)
      return S_OK;
    
    if (item.LinkFlag == NFileHeader::NLinkFlag::kGnu_LongName || // file contains a long name
        item.LinkFlag == NFileHeader::NLinkFlag::kGnu_LongLink)   // file contains a long linkname
    {
      AString *name;
      if (item.LinkFlag == NFileHeader::NLinkFlag::kGnu_LongName)
        { if (flagL) return S_OK; flagL = true; name = &nameL; }
      else
        { if (flagK) return S_OK; flagK = true; name = &nameK; }

      if (item.Name != NFileHeader::kLongLink &&
          item.Name != NFileHeader::kLongLink2)
        return S_OK;
      if (item.PackSize > (1 << 14))
        return S_OK;
      unsigned packSize = (unsigned)item.GetPackSizeAligned();
      char *buf = name->GetBuf(packSize);
      size_t processedSize = packSize;
      HRESULT res = ReadStream(stream, buf, &processedSize);
      item.HeaderSize += (unsigned)processedSize;
      name->ReleaseBuf_CalcLen((unsigned)item.PackSize);
      RINOK(res);
      if (processedSize != packSize)
      {
        error = k_ErrorType_UnexpectedEnd;
        return S_OK;
      }
      continue;
    }

    switch (item.LinkFlag)
    {
      case 'g':
      case 'x':
      case 'X':
      {
        // pax Extended Header
        break;
      }
      case NFileHeader::NLinkFlag::kDumpDir:
      {
        break;
        // GNU Extensions to the Archive Format
      }
      case NFileHeader::NLinkFlag::kSparse:
      {
        break;
        // GNU Extensions to the Archive Format
      }
      default:
        if (item.LinkFlag > '7' || (item.LinkFlag < '0' && item.LinkFlag != 0))
          return S_OK;
    }
    
    if (flagL)
    {
      item.Name = nameL;
      item.NameCouldBeReduced = false;
    }
    
    if (flagK)
    {
      item.LinkName = nameK;
      item.LinkNameCouldBeReduced = false;
    }

    error = k_ErrorType_OK;
    return S_OK;
  }
}

}}
// TarIn.h

#ifndef __ARCHIVE_TAR_IN_H
#define __ARCHIVE_TAR_IN_H

#include "../../IStream.h"

#include "TarItem.h"

namespace NArchive {
namespace NTar {
  
enum EErrorType
{
  k_ErrorType_OK,
  k_ErrorType_Corrupted,
  k_ErrorType_UnexpectedEnd,
};

HRESULT ReadItem(ISequentialInStream *stream, bool &filled, CItemEx &itemInfo, EErrorType &error);

API_FUNC_IsArc IsArc_Tar(const Byte *p, size_t size);

}}
  
#endif
// TarItem.h

#ifndef __ARCHIVE_TAR_ITEM_H
#define __ARCHIVE_TAR_ITEM_H

#include "../Common/ItemNameUtils.h"

#include "TarHeader.h"

namespace NArchive {
namespace NTar {

struct CSparseBlock
{
  UInt64 Offset;
  UInt64 Size;
};

struct CItem
{
  AString Name;
  UInt64 PackSize;
  UInt64 Size;
  Int64 MTime;

  UInt32 Mode;
  UInt32 UID;
  UInt32 GID;
  UInt32 DeviceMajor;
  UInt32 DeviceMinor;

  AString LinkName;
  AString User;
  AString Group;

  char Magic[8];
  char LinkFlag;
  bool DeviceMajorDefined;
  bool DeviceMinorDefined;

  CRecordVector<CSparseBlock> SparseBlocks;

  bool IsSymLink() const { return LinkFlag == NFileHeader::NLinkFlag::kSymLink && (Size == 0); }
  bool IsHardLink() const { return LinkFlag == NFileHeader::NLinkFlag::kHardLink; }
  bool IsSparse() const { return LinkFlag == NFileHeader::NLinkFlag::kSparse; }
  UInt64 GetUnpackSize() const { return IsSymLink() ? LinkName.Len() : Size; }
  bool IsPaxExtendedHeader() const
  {
    switch (LinkFlag)
    {
      case 'g':
      case 'x':
      case 'X':  // Check it
        return true;
    }
    return false;
  }

  bool IsDir() const
  {
    switch (LinkFlag)
    {
      case NFileHeader::NLinkFlag::kDirectory:
      case NFileHeader::NLinkFlag::kDumpDir:
        return true;
      case NFileHeader::NLinkFlag::kOldNormal:
      case NFileHeader::NLinkFlag::kNormal:
      case NFileHeader::NLinkFlag::kSymLink:
        return NItemName::HasTailSlash(Name, CP_OEMCP);
    }
    return false;
  }

  bool IsUstarMagic() const
  {
    for (int i = 0; i < 5; i++)
      if (Magic[i] != NFileHeader::NMagic::kUsTar_00[i])
        return false;
    return true;
  }

  UInt64 GetPackSizeAligned() const { return (PackSize + 0x1FF) & (~((UInt64)0x1FF)); }
};

struct CItemEx: public CItem
{
  UInt64 HeaderPos;
  unsigned HeaderSize;
  bool NameCouldBeReduced;
  bool LinkNameCouldBeReduced;

  UInt64 GetDataPosition() const { return HeaderPos + HeaderSize; }
  UInt64 GetFullSize() const { return HeaderSize + PackSize; }
};

}}

#endif
// TarOut.cpp

#include "StdAfx.h"

#include "../../Common/StreamUtils.h"

#include "TarOut.h"

namespace NArchive {
namespace NTar {

HRESULT COutArchive::WriteBytes(const void *data, unsigned size)
{
  Pos += size;
  return WriteStream(m_Stream, data, size);
}

static void MyStrNCpy(char *dest, const char *src, unsigned size)
{
  for (unsigned i = 0; i < size; i++)
  {
    char c = src[i];
    dest[i] = c;
    if (c == 0)
      break;
  }
}

static bool WriteOctal_8(char *s, UInt32 val)
{
  const unsigned kNumDigits = 8 - 1;
  if (val >= ((UInt32)1 << (kNumDigits * 3)))
    return false;
  for (unsigned i = 0; i < kNumDigits; i++)
  {
    s[kNumDigits - 1 - i] = (char)('0' + (val & 7));
    val >>= 3;
  }
  return true;
}

static void WriteOctal_12(char *s, UInt64 val)
{
  const unsigned kNumDigits = 12 - 1;
  if (val >= ((UInt64)1 << (kNumDigits * 3)))
  {
    // GNU extension;
    s[0] = (char)(Byte)0x80;
    s[1] = s[2] = s[3] = 0;
    for (unsigned i = 0; i < 8; i++, val <<= 8)
      s[4 + i] = (char)(val >> 56);
    return;
  }
  for (unsigned i = 0; i < kNumDigits; i++)
  {
    s[kNumDigits - 1 - i] = (char)('0' + (val & 7));
    val >>= 3;
  }
}

static void WriteOctal_12_Signed(char *s, Int64 val)
{
  if (val >= 0)
  {
    WriteOctal_12(s, val);
    return;
  }
  s[0] = s[1] = s[2] = s[3] = (char)(Byte)0xFF;
  for (unsigned i = 0; i < 8; i++, val <<= 8)
    s[4 + i] = (char)(val >> 56);
}

static bool CopyString(char *dest, const AString &src, unsigned maxSize)
{
  if (src.Len() >= maxSize)
    return false;
  MyStringCopy(dest, (const char *)src);
  return true;
}

#define RETURN_IF_NOT_TRUE(x) { if (!(x)) return E_FAIL; }

HRESULT COutArchive::WriteHeaderReal(const CItem &item)
{
  char record[NFileHeader::kRecordSize];
  memset(record, 0, NFileHeader::kRecordSize);
  char *cur = record;

  if (item.Name.Len() > NFileHeader::kNameSize)
    return E_FAIL;
  MyStrNCpy(cur, item.Name, NFileHeader::kNameSize);
  cur += NFileHeader::kNameSize;

  RETURN_IF_NOT_TRUE(WriteOctal_8(cur, item.Mode)); cur += 8;
  RETURN_IF_NOT_TRUE(WriteOctal_8(cur, item.UID)); cur += 8;
  RETURN_IF_NOT_TRUE(WriteOctal_8(cur, item.GID)); cur += 8;

  WriteOctal_12(cur, item.PackSize); cur += 12;
  WriteOctal_12_Signed(cur, item.MTime); cur += 12;
  
  memset(cur, ' ', 8);
  cur += 8;

  *cur++ = item.LinkFlag;

  RETURN_IF_NOT_TRUE(CopyString(cur, item.LinkName, NFileHeader::kNameSize));
  cur += NFileHeader::kNameSize;

  memcpy(cur, item.Magic, 8);
  cur += 8;

  RETURN_IF_NOT_TRUE(CopyString(cur, item.User, NFileHeader::kUserNameSize));
  cur += NFileHeader::kUserNameSize;
  RETURN_IF_NOT_TRUE(CopyString(cur, item.Group, NFileHeader::kGroupNameSize));
  cur += NFileHeader::kGroupNameSize;


  if (item.DeviceMajorDefined) RETURN_IF_NOT_TRUE(WriteOctal_8(cur, item.DeviceMajor)); cur += 8;
  if (item.DeviceMinorDefined) RETURN_IF_NOT_TRUE(WriteOctal_8(cur, item.DeviceMinor)); cur += 8;

  if (item.IsSparse())
  {
    record[482] = (char)(item.SparseBlocks.Size() > 4 ? 1 : 0);
    WriteOctal_12(record + 483, item.Size);
    for (unsigned i = 0; i < item.SparseBlocks.Size() && i < 4; i++)
    {
      const CSparseBlock &sb = item.SparseBlocks[i];
      char *p = record + 386 + 24 * i;
      WriteOctal_12(p, sb.Offset);
      WriteOctal_12(p + 12, sb.Size);
    }
  }

  {
    UInt32 checkSum = 0;
    {
      for (unsigned i = 0; i < NFileHeader::kRecordSize; i++)
        checkSum += (Byte)record[i];
    }
    /* we use GNU TAR scheme:
       checksum field is formatted differently from the
       other fields: it has [6] digits, a null, then a space. */
    // RETURN_IF_NOT_TRUE(WriteOctal_8(record + 148, checkSum));
    const unsigned kNumDigits = 6;
    for (unsigned i = 0; i < kNumDigits; i++)
    {
      record[148 + kNumDigits - 1 - i] = (char)('0' + (checkSum & 7));
      checkSum >>= 3;
    }
    record[148 + 6] = 0;
  }

  RINOK(WriteBytes(record, NFileHeader::kRecordSize));

  if (item.IsSparse())
  {
    for (unsigned i = 4; i < item.SparseBlocks.Size();)
    {
      memset(record, 0, NFileHeader::kRecordSize);
      for (unsigned t = 0; t < 21 && i < item.SparseBlocks.Size(); t++, i++)
      {
        const CSparseBlock &sb = item.SparseBlocks[i];
        char *p = record + 24 * t;
        WriteOctal_12(p, sb.Offset);
        WriteOctal_12(p + 12, sb.Size);
      }
      record[21 * 24] = (char)(i < item.SparseBlocks.Size() ? 1 : 0);
      RINOK(WriteBytes(record, NFileHeader::kRecordSize));
    }
  }

  return S_OK;
}

HRESULT COutArchive::WriteHeader(const CItem &item)
{
  unsigned nameSize = item.Name.Len();
  unsigned linkSize = item.LinkName.Len();

  /* There two versions of GNU tar:
    OLDGNU_FORMAT: it writes short name and zero at the  end
    GNU_FORMAT:    it writes only short name without zero at the end
    we write it as OLDGNU_FORMAT with zero at the end */

  if (nameSize < NFileHeader::kNameSize &&
      linkSize < NFileHeader::kNameSize)
    return WriteHeaderReal(item);

  CItem mi = item;
  mi.Name = NFileHeader::kLongLink;
  mi.LinkName.Empty();
  for (int i = 0; i < 2; i++)
  {
    const AString *name;
    // We suppose that GNU tar also writes item for long link before item for LongName?
    if (i == 0)
    {
      mi.LinkFlag = NFileHeader::NLinkFlag::kGnu_LongLink;
      name = &item.LinkName;
    }
    else
    {
      mi.LinkFlag = NFileHeader::NLinkFlag::kGnu_LongName;
      name = &item.Name;
    }
    if (name->Len() < NFileHeader::kNameSize)
      continue;
    unsigned nameStreamSize = name->Len() + 1;
    mi.PackSize = nameStreamSize;
    RINOK(WriteHeaderReal(mi));
    RINOK(WriteBytes((const char *)*name, nameStreamSize));
    RINOK(FillDataResidual(nameStreamSize));
  }

  mi = item;
  if (mi.Name.Len() >= NFileHeader::kNameSize)
    mi.Name.SetFrom(item.Name, NFileHeader::kNameSize - 1);
  if (mi.LinkName.Len() >= NFileHeader::kNameSize)
    mi.LinkName.SetFrom(item.LinkName, NFileHeader::kNameSize - 1);
  return WriteHeaderReal(mi);
}

HRESULT COutArchive::FillDataResidual(UInt64 dataSize)
{
  unsigned lastRecordSize = ((unsigned)dataSize & (NFileHeader::kRecordSize - 1));
  if (lastRecordSize == 0)
    return S_OK;
  unsigned rem = NFileHeader::kRecordSize - lastRecordSize;
  Byte buf[NFileHeader::kRecordSize];
  memset(buf, 0, rem);
  return WriteBytes(buf, rem);
}

HRESULT COutArchive::WriteFinishHeader()
{
  Byte record[NFileHeader::kRecordSize];
  memset(record, 0, NFileHeader::kRecordSize);
  for (unsigned i = 0; i < 2; i++)
  {
    RINOK(WriteBytes(record, NFileHeader::kRecordSize));
  }
  return S_OK;
}

}}
// Archive/TarOut.h

#ifndef __ARCHIVE_TAR_OUT_H
#define __ARCHIVE_TAR_OUT_H

#include "../../../Common/MyCom.h"

#include "../../IStream.h"

#include "TarItem.h"

namespace NArchive {
namespace NTar {

class COutArchive
{
  CMyComPtr<ISequentialOutStream> m_Stream;

  HRESULT WriteBytes(const void *data, unsigned size);
  HRESULT WriteHeaderReal(const CItem &item);
public:
  UInt64 Pos;
  
  void Create(ISequentialOutStream *outStream)
  {
    m_Stream = outStream;
  }

  HRESULT WriteHeader(const CItem &item);
  HRESULT FillDataResidual(UInt64 dataSize);
  HRESULT WriteFinishHeader();
};

}}

#endif
// TarRegister.cpp

#include "StdAfx.h"

#include "../../Common/RegisterArc.h"

#include "TarHandler.h"

namespace NArchive {
namespace NTar {

static const Byte k_Signature[] = { 'u', 's', 't', 'a', 'r' };

REGISTER_ARC_IO(
  "tar", "tar ova", 0, 0xEE,
  k_Signature,
  NFileHeader::kUstarMagic_Offset,
  NArcInfoFlags::kStartOpen |
  NArcInfoFlags::kSymLinks |
  NArcInfoFlags::kHardLinks,
  IsArc_Tar)
 
}}
// TarUpdate.cpp

#include "StdAfx.h"

#include "../../../Windows/TimeUtils.h"

#include "../../Common/LimitedStreams.h"
#include "../../Common/ProgressUtils.h"

#include "../../Compress/CopyCoder.h"

#include "TarOut.h"
#include "TarUpdate.h"

namespace NArchive {
namespace NTar {

HRESULT GetPropString(IArchiveUpdateCallback *callback, UInt32 index, PROPID propId,
    AString &res, UINT codePage, bool convertSlash = false);

HRESULT UpdateArchive(IInStream *inStream, ISequentialOutStream *outStream,
    const CObjectVector<NArchive::NTar::CItemEx> &inputItems,
    const CObjectVector<CUpdateItem> &updateItems,
    UINT codePage,
    IArchiveUpdateCallback *updateCallback)
{
  COutArchive outArchive;
  outArchive.Create(outStream);
  outArchive.Pos = 0;

  CMyComPtr<IOutStream> outSeekStream;
  outStream->QueryInterface(IID_IOutStream, (void **)&outSeekStream);

  CMyComPtr<IArchiveUpdateCallbackFile> opCallback;
  updateCallback->QueryInterface(IID_IArchiveUpdateCallbackFile, (void **)&opCallback);

  UInt64 complexity = 0;

  unsigned i;
  for (i = 0; i < updateItems.Size(); i++)
  {
    const CUpdateItem &ui = updateItems[i];
    if (ui.NewData)
      complexity += ui.Size;
    else
      complexity += inputItems[ui.IndexInArc].GetFullSize();
  }

  RINOK(updateCallback->SetTotal(complexity));

  NCompress::CCopyCoder *copyCoderSpec = new NCompress::CCopyCoder;
  CMyComPtr<ICompressCoder> copyCoder = copyCoderSpec;

  CLocalProgress *lps = new CLocalProgress;
  CMyComPtr<ICompressProgressInfo> progress = lps;
  lps->Init(updateCallback, true);

  CLimitedSequentialInStream *streamSpec = new CLimitedSequentialInStream;
  CMyComPtr<CLimitedSequentialInStream> inStreamLimited(streamSpec);
  streamSpec->SetStream(inStream);

  complexity = 0;

  for (i = 0; i < updateItems.Size(); i++)
  {
    lps->InSize = lps->OutSize = complexity;
    RINOK(lps->SetCur());

    const CUpdateItem &ui = updateItems[i];
    CItem item;
  
    if (ui.NewProps)
    {
      item.Mode = ui.Mode;
      item.Name = ui.Name;
      item.User = ui.User;
      item.Group = ui.Group;
      
      if (ui.IsDir)
      {
        item.LinkFlag = NFileHeader::NLinkFlag::kDirectory;
        item.PackSize = 0;
      }
      else
      {
        item.LinkFlag = NFileHeader::NLinkFlag::kNormal;
        item.PackSize = ui.Size;
      }
      
      item.MTime = ui.MTime;
      item.DeviceMajorDefined = false;
      item.DeviceMinorDefined = false;
      item.UID = 0;
      item.GID = 0;
      memcpy(item.Magic, NFileHeader::NMagic::kUsTar_00, 8);
    }
    else
      item = inputItems[ui.IndexInArc];

    AString symLink;
    if (ui.NewData || ui.NewProps)
    {
      RINOK(GetPropString(updateCallback, ui.IndexInClient, kpidSymLink, symLink, codePage, true));
      if (!symLink.IsEmpty())
      {
        item.LinkFlag = NFileHeader::NLinkFlag::kSymLink;
        item.LinkName = symLink;
      }
    }

    if (ui.NewData)
    {
      item.SparseBlocks.Clear();
      item.PackSize = ui.Size;
      item.Size = ui.Size;
      if (ui.Size == (UInt64)(Int64)-1)
        return E_INVALIDARG;

      CMyComPtr<ISequentialInStream> fileInStream;

      bool needWrite = true;
      
      if (!symLink.IsEmpty())
      {
        item.PackSize = 0;
        item.Size = 0;
      }
      else
      {
        HRESULT res = updateCallback->GetStream(ui.IndexInClient, &fileInStream);
        
        if (res == S_FALSE)
          needWrite = false;
        else
        {
          RINOK(res);
          
          if (fileInStream)
          {
            CMyComPtr<IStreamGetProps> getProps;
            fileInStream->QueryInterface(IID_IStreamGetProps, (void **)&getProps);
            if (getProps)
            {
              FILETIME mTime;
              UInt64 size2;
              if (getProps->GetProps(&size2, NULL, NULL, &mTime, NULL) == S_OK)
              {
                item.PackSize = size2;
                item.Size = size2;
                item.MTime = NWindows::NTime::FileTimeToUnixTime64(mTime);;
              }
            }
          }
          else
          {
            item.PackSize = 0;
            item.Size = 0;
          }

          {
            AString hardLink;
            RINOK(GetPropString(updateCallback, ui.IndexInClient, kpidHardLink, hardLink, codePage, true));
            if (!hardLink.IsEmpty())
            {
              item.LinkFlag = NFileHeader::NLinkFlag::kHardLink;
              item.LinkName = hardLink;
              item.PackSize = 0;
              item.Size = 0;
              fileInStream.Release();
            }
          }
        }
      }

      if (needWrite)
      {
        UInt64 fileHeaderStartPos = outArchive.Pos;
        RINOK(outArchive.WriteHeader(item));
        if (fileInStream)
        {
          RINOK(copyCoder->Code(fileInStream, outStream, NULL, NULL, progress));
          outArchive.Pos += copyCoderSpec->TotalSize;
          if (copyCoderSpec->TotalSize != item.PackSize)
          {
            if (!outSeekStream)
              return E_FAIL;
            UInt64 backOffset = outArchive.Pos - fileHeaderStartPos;
            RINOK(outSeekStream->Seek(-(Int64)backOffset, STREAM_SEEK_CUR, NULL));
            outArchive.Pos = fileHeaderStartPos;
            item.PackSize = copyCoderSpec->TotalSize;
            RINOK(outArchive.WriteHeader(item));
            RINOK(outSeekStream->Seek(item.PackSize, STREAM_SEEK_CUR, NULL));
            outArchive.Pos += item.PackSize;
          }
          RINOK(outArchive.FillDataResidual(item.PackSize));
        }
      }
      
      complexity += item.PackSize;
      RINOK(updateCallback->SetOperationResult(NArchive::NUpdate::NOperationResult::kOK));
    }
    else
    {
      const CItemEx &existItem = inputItems[ui.IndexInArc];
      UInt64 size;
      
      if (ui.NewProps)
      {
        // memcpy(item.Magic, NFileHeader::NMagic::kEmpty, 8);
        
        if (!symLink.IsEmpty())
        {
          item.PackSize = 0;
          item.Size = 0;
        }
        else
        {
          if (ui.IsDir == existItem.IsDir())
            item.LinkFlag = existItem.LinkFlag;
        
          item.SparseBlocks = existItem.SparseBlocks;
          item.Size = existItem.Size;
          item.PackSize = existItem.PackSize;
        }
        
        item.DeviceMajorDefined = existItem.DeviceMajorDefined;
        item.DeviceMinorDefined = existItem.DeviceMinorDefined;
        item.DeviceMajor = existItem.DeviceMajor;
        item.DeviceMinor = existItem.DeviceMinor;
        item.UID = existItem.UID;
        item.GID = existItem.GID;
        
        RINOK(outArchive.WriteHeader(item));
        RINOK(inStream->Seek(existItem.GetDataPosition(), STREAM_SEEK_SET, NULL));
        size = existItem.PackSize;
      }
      else
      {
        RINOK(inStream->Seek(existItem.HeaderPos, STREAM_SEEK_SET, NULL));
        size = existItem.GetFullSize();
      }
      
      streamSpec->Init(size);

      if (opCallback)
      {
        RINOK(opCallback->ReportOperation(
            NEventIndexType::kInArcIndex, (UInt32)ui.IndexInArc,
            NUpdateNotifyOp::kReplicate))
      }

      RINOK(copyCoder->Code(inStreamLimited, outStream, NULL, NULL, progress));
      if (copyCoderSpec->TotalSize != size)
        return E_FAIL;
      outArchive.Pos += size;
      RINOK(outArchive.FillDataResidual(existItem.PackSize));
      complexity += size;
    }
  }
  
  lps->InSize = lps->OutSize = complexity;
  RINOK(lps->SetCur());
  return outArchive.WriteFinishHeader();
}

}}
// TarUpdate.h

#ifndef __TAR_UPDATE_H
#define __TAR_UPDATE_H

#include "../IArchive.h"

#include "TarItem.h"

namespace NArchive {
namespace NTar {

struct CUpdateItem
{
  int IndexInArc;
  int IndexInClient;
  UInt64 Size;
  Int64 MTime;
  UInt32 Mode;
  bool NewData;
  bool NewProps;
  bool IsDir;
  AString Name;
  AString User;
  AString Group;

  CUpdateItem(): Size(0), IsDir(false) {}
};

HRESULT UpdateArchive(IInStream *inStream, ISequentialOutStream *outStream,
    const CObjectVector<CItemEx> &inputItems,
    const CObjectVector<CUpdateItem> &updateItems,
    UINT codePage,
    IArchiveUpdateCallback *updateCallback);

}}

#endif
// UdfHandler.cpp

#include "StdAfx.h"

#include "../../../Common/ComTry.h"

#include "../../../Windows/PropVariant.h"
#include "../../../Windows/TimeUtils.h"

#include "../../Common/LimitedStreams.h"
#include "../../Common/ProgressUtils.h"
#include "../../Common/RegisterArc.h"
#include "../../Common/StreamObjects.h"

#include "../../Compress/CopyCoder.h"

#include "UdfHandler.h"

namespace NArchive {
namespace NUdf {

static void UdfTimeToFileTime(const CTime &t, NWindows::NCOM::CPropVariant &prop)
{
  UInt64 numSecs;
  const Byte *d = t.Data;
  if (!NWindows::NTime::GetSecondsSince1601(t.GetYear(), d[4], d[5], d[6], d[7], d[8], numSecs))
    return;
  if (t.IsLocal())
    numSecs -= (Int64)((Int32)t.GetMinutesOffset() * 60);
  FILETIME ft;
  UInt64 v = (((numSecs * 100 + d[9]) * 100 + d[10]) * 100 + d[11]) * 10;
  ft.dwLowDateTime = (UInt32)v;
  ft.dwHighDateTime = (UInt32)(v >> 32);
  prop = ft;
}

static const Byte kProps[] =
{
  kpidPath,
  kpidIsDir,
  kpidSize,
  kpidPackSize,
  kpidMTime,
  kpidATime
};

static const Byte kArcProps[] =
{
  kpidComment,
  kpidClusterSize,
  kpidCTime
};

IMP_IInArchive_Props
IMP_IInArchive_ArcProps

STDMETHODIMP CHandler::GetArchiveProperty(PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NWindows::NCOM::CPropVariant prop;
  switch (propID)
  {
    case kpidPhySize: prop = _archive.PhySize; break;

    case kpidComment:
    {
      UString comment = _archive.GetComment();
      if (!comment.IsEmpty())
        prop = comment;
      break;
    }

    case kpidClusterSize:
      if (_archive.LogVols.Size() > 0)
      {
        UInt32 blockSize = _archive.LogVols[0].BlockSize;
        unsigned i;
        for (i = 1; i < _archive.LogVols.Size(); i++)
          if (_archive.LogVols[i].BlockSize != blockSize)
            break;
        if (i == _archive.LogVols.Size())
          prop = blockSize;
      }
      break;

    case kpidCTime:
      if (_archive.LogVols.Size() == 1)
      {
        const CLogVol &vol = _archive.LogVols[0];
        if (vol.FileSets.Size() >= 1)
          UdfTimeToFileTime(vol.FileSets[0].RecodringTime, prop);
      }
      break;

    case kpidErrorFlags:
    {
      UInt32 v = 0;
      if (!_archive.IsArc) v |= kpv_ErrorFlags_IsNotArc;
      if (_archive.Unsupported) v |= kpv_ErrorFlags_UnsupportedFeature;
      if (_archive.UnexpectedEnd) v |= kpv_ErrorFlags_UnexpectedEnd;
      if (_archive.NoEndAnchor) v |= kpv_ErrorFlags_HeadersError;
      prop = v;
      break;
    }
  }
  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}

class CProgressImp: public CProgressVirt
{
  CMyComPtr<IArchiveOpenCallback> _callback;
  UInt64 _numFiles;
  UInt64 _numBytes;
public:
  HRESULT SetTotal(UInt64 numBytes);
  HRESULT SetCompleted(UInt64 numFiles, UInt64 numBytes);
  HRESULT SetCompleted();
  CProgressImp(IArchiveOpenCallback *callback): _callback(callback), _numFiles(0), _numBytes(0) {}
};

HRESULT CProgressImp::SetTotal(UInt64 numBytes)
{
  if (_callback)
    return _callback->SetTotal(NULL, &numBytes);
  return S_OK;
}

HRESULT CProgressImp::SetCompleted(UInt64 numFiles, UInt64 numBytes)
{
  _numFiles = numFiles;
  _numBytes = numBytes;
  return SetCompleted();
}

HRESULT CProgressImp::SetCompleted()
{
  if (_callback)
    return _callback->SetCompleted(&_numFiles, &_numBytes);
  return S_OK;
}

STDMETHODIMP CHandler::Open(IInStream *stream, const UInt64 *, IArchiveOpenCallback *callback)
{
  COM_TRY_BEGIN
  {
    Close();
    CProgressImp progressImp(callback);
    RINOK(_archive.Open(stream, &progressImp));
    bool showVolName = (_archive.LogVols.Size() > 1);
    FOR_VECTOR (volIndex, _archive.LogVols)
    {
      const CLogVol &vol = _archive.LogVols[volIndex];
      bool showFileSetName = (vol.FileSets.Size() > 1);
      FOR_VECTOR (fsIndex, vol.FileSets)
      {
        const CFileSet &fs = vol.FileSets[fsIndex];
        for (unsigned i = ((showVolName || showFileSetName) ? 0 : 1); i < fs.Refs.Size(); i++)
        {
          CRef2 ref2;
          ref2.Vol = volIndex;
          ref2.Fs = fsIndex;
          ref2.Ref = i;
          _refs2.Add(ref2);
        }
      }
    }
    _inStream = stream;
  }
  return S_OK;
  COM_TRY_END
}

STDMETHODIMP CHandler::Close()
{
  _inStream.Release();
  _archive.Clear();
  _refs2.Clear();
  return S_OK;
}

STDMETHODIMP CHandler::GetNumberOfItems(UInt32 *numItems)
{
  *numItems = _refs2.Size();
  return S_OK;
}

STDMETHODIMP CHandler::GetProperty(UInt32 index, PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NWindows::NCOM::CPropVariant prop;
  {
    const CRef2 &ref2 = _refs2[index];
    const CLogVol &vol = _archive.LogVols[ref2.Vol];
    const CRef &ref = vol.FileSets[ref2.Fs].Refs[ref2.Ref];
    const CFile &file = _archive.Files[ref.FileIndex];
    const CItem &item = _archive.Items[file.ItemIndex];
    switch (propID)
    {
      case kpidPath:  prop = _archive.GetItemPath(ref2.Vol, ref2.Fs, ref2.Ref,
            _archive.LogVols.Size() > 1, vol.FileSets.Size() > 1); break;
      case kpidIsDir:  prop = item.IsDir(); break;
      case kpidSize:      if (!item.IsDir()) prop = (UInt64)item.Size; break;
      case kpidPackSize:  if (!item.IsDir()) prop = (UInt64)item.NumLogBlockRecorded * vol.BlockSize; break;
      case kpidMTime:  UdfTimeToFileTime(item.MTime, prop); break;
      case kpidATime:  UdfTimeToFileTime(item.ATime, prop); break;
    }
  }
  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}

STDMETHODIMP CHandler::GetStream(UInt32 index, ISequentialInStream **stream)
{
  *stream = 0;

  const CRef2 &ref2 = _refs2[index];
  const CLogVol &vol = _archive.LogVols[ref2.Vol];
  const CRef &ref = vol.FileSets[ref2.Fs].Refs[ref2.Ref];
  const CFile &file = _archive.Files[ref.FileIndex];
  const CItem &item = _archive.Items[file.ItemIndex];
  UInt64 size = item.Size;

  if (!item.IsRecAndAlloc() || !item.CheckChunkSizes() || ! _archive.CheckItemExtents(ref2.Vol, item))
    return E_NOTIMPL;

  if (item.IsInline)
  {
    Create_BufInStream_WithNewBuffer(item.InlineData, stream);
    return S_OK;
  }

  CExtentsStream *extentStreamSpec = new CExtentsStream();
  CMyComPtr<ISequentialInStream> extentStream = extentStreamSpec;
  
  extentStreamSpec->Stream = _inStream;

  UInt64 virtOffset = 0;
  FOR_VECTOR (extentIndex, item.Extents)
  {
    const CMyExtent &extent = item.Extents[extentIndex];
    UInt32 len = extent.GetLen();
    if (len == 0)
      continue;
    if (size < len)
      return S_FALSE;
      
    int partitionIndex = vol.PartitionMaps[extent.PartitionRef].PartitionIndex;
    UInt32 logBlockNumber = extent.Pos;
    const CPartition &partition = _archive.Partitions[partitionIndex];
    UInt64 offset = ((UInt64)partition.Pos << _archive.SecLogSize) +
      (UInt64)logBlockNumber * vol.BlockSize;
      
    CSeekExtent se;
    se.Phy = offset;
    se.Virt = virtOffset;
    virtOffset += len;
    extentStreamSpec->Extents.Add(se);

    size -= len;
  }
  if (size != 0)
    return S_FALSE;
  CSeekExtent se;
  se.Phy = 0;
  se.Virt = virtOffset;
  extentStreamSpec->Extents.Add(se);
  extentStreamSpec->Init();
  *stream = extentStream.Detach();
  return S_OK;
}

STDMETHODIMP CHandler::Extract(const UInt32 *indices, UInt32 numItems,
    Int32 testMode, IArchiveExtractCallback *extractCallback)
{
  COM_TRY_BEGIN
  bool allFilesMode = (numItems == (UInt32)(Int32)-1);
  if (allFilesMode)
    numItems = _refs2.Size();
  if (numItems == 0)
    return S_OK;
  UInt64 totalSize = 0;
  UInt32 i;

  for (i = 0; i < numItems; i++)
  {
    UInt32 index = (allFilesMode ? i : indices[i]);
    const CRef2 &ref2 = _refs2[index];
    const CRef &ref = _archive.LogVols[ref2.Vol].FileSets[ref2.Fs].Refs[ref2.Ref];
    const CFile &file = _archive.Files[ref.FileIndex];
    const CItem &item = _archive.Items[file.ItemIndex];
    if (!item.IsDir())
      totalSize += item.Size;
  }
  extractCallback->SetTotal(totalSize);

  UInt64 currentTotalSize = 0;
  
  NCompress::CCopyCoder *copyCoderSpec = new NCompress::CCopyCoder();
  CMyComPtr<ICompressCoder> copyCoder = copyCoderSpec;

  CLocalProgress *lps = new CLocalProgress;
  CMyComPtr<ICompressProgressInfo> progress = lps;
  lps->Init(extractCallback, false);

  CLimitedSequentialOutStream *outStreamSpec = new CLimitedSequentialOutStream;
  CMyComPtr<ISequentialOutStream> outStream(outStreamSpec);

  for (i = 0; i < numItems; i++)
  {
    lps->InSize = lps->OutSize = currentTotalSize;
    RINOK(lps->SetCur());
    CMyComPtr<ISequentialOutStream> realOutStream;
    Int32 askMode = testMode ?
        NExtract::NAskMode::kTest :
        NExtract::NAskMode::kExtract;
    UInt32 index = allFilesMode ? i : indices[i];
    
    RINOK(extractCallback->GetStream(index, &realOutStream, askMode));

    const CRef2 &ref2 = _refs2[index];
    const CRef &ref = _archive.LogVols[ref2.Vol].FileSets[ref2.Fs].Refs[ref2.Ref];
    const CFile &file = _archive.Files[ref.FileIndex];
    const CItem &item = _archive.Items[file.ItemIndex];

    if (item.IsDir())
    {
      RINOK(extractCallback->PrepareOperation(askMode));
      RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK));
      continue;
    }
    currentTotalSize += item.Size;

    if (!testMode && !realOutStream)
      continue;

    RINOK(extractCallback->PrepareOperation(askMode));
    outStreamSpec->SetStream(realOutStream);
    realOutStream.Release();
    outStreamSpec->Init(item.Size);
    Int32 opRes;
    CMyComPtr<ISequentialInStream> udfInStream;
    HRESULT res = GetStream(index, &udfInStream);
    if (res == E_NOTIMPL)
      opRes = NExtract::NOperationResult::kUnsupportedMethod;
    else if (res != S_OK)
      opRes = NExtract::NOperationResult::kDataError;
    else
    {
      RINOK(copyCoder->Code(udfInStream, outStream, NULL, NULL, progress));
      opRes = outStreamSpec->IsFinishedOK() ?
        NExtract::NOperationResult::kOK:
        NExtract::NOperationResult::kDataError;
    }
    outStreamSpec->ReleaseStream();
    RINOK(extractCallback->SetOperationResult(opRes));
  }
  return S_OK;
  COM_TRY_END
}

static const UInt32 kIsoStartPos = 0x8000;

//  5, { 0, 'N', 'S', 'R', '0' },
static const Byte k_Signature[] = { 1, 'C', 'D', '0', '0', '1' };

REGISTER_ARC_I(
  "Udf", "udf iso img", 0, 0xE0,
  k_Signature,
  kIsoStartPos,
  NArcInfoFlags::kStartOpen,
  IsArc_Udf)

}}
// UdfHandler.h

#ifndef __UDF_HANDLER_H
#define __UDF_HANDLER_H

#include "../../../Common/MyCom.h"

#include "../IArchive.h"

#include "UdfIn.h"

namespace NArchive {
namespace NUdf {

struct CRef2
{
  unsigned Vol;
  unsigned Fs;
  unsigned Ref;
};

class CHandler:
  public IInArchive,
  public IInArchiveGetStream,
  public CMyUnknownImp
{
  CMyComPtr<IInStream> _inStream;
  CInArchive _archive;
  CRecordVector<CRef2> _refs2;
public:
  MY_UNKNOWN_IMP2(IInArchive, IInArchiveGetStream)
  INTERFACE_IInArchive(;)
  STDMETHOD(GetStream)(UInt32 index, ISequentialInStream **stream);
};

}}

#endif
// Archive/UdfIn.cpp

#include "StdAfx.h"

// #define SHOW_DEBUG_INFO

#ifdef SHOW_DEBUG_INFO
#include <stdio.h>
#endif

#include "../../../../C/CpuArch.h"

#include "../../Common/RegisterArc.h"
#include "../../Common/StreamUtils.h"

#include "UdfIn.h"

#ifdef SHOW_DEBUG_INFO
#define PRF(x) x
#else
#define PRF(x)
#endif

#define Get16(p) GetUi16(p)
#define Get32(p) GetUi32(p)
#define Get64(p) GetUi64(p)

namespace NArchive {
namespace NUdf {

static const unsigned kNumPartitionsMax = 64;
static const unsigned kNumLogVolumesMax = 64;
static const unsigned kNumRecursionLevelsMax = 1 << 10;
static const unsigned kNumItemsMax = 1 << 27;
static const unsigned kNumFilesMax = 1 << 28;
static const unsigned kNumRefsMax = 1 << 28;
static const UInt32 kNumExtentsMax = (UInt32)1 << 30;
static const UInt64 kFileNameLengthTotalMax = (UInt64)1 << 33;
static const UInt64 kInlineExtentsSizeMax = (UInt64)1 << 33;

#define CRC16_INIT_VAL 0
#define CRC16_GET_DIGEST(crc) (crc)
#define CRC16_UPDATE_BYTE(crc, b) ((UInt16)(g_Crc16Table[(((crc) >> 8) ^ (b)) & 0xFF] ^ ((crc) << 8)))

#define kCrc16Poly 0x1021
static UInt16 g_Crc16Table[256];

void MY_FAST_CALL Crc16GenerateTable(void)
{
  UInt32 i;
  for (i = 0; i < 256; i++)
  {
    UInt32 r = (i << 8);
    for (int j = 8; j > 0; j--)
      r = ((r & 0x8000) ? ((r << 1) ^ kCrc16Poly) : (r << 1)) & 0xFFFF;
    g_Crc16Table[i] = (UInt16)r;
  }
}

UInt16 MY_FAST_CALL Crc16_Update(UInt16 v, const void *data, size_t size)
{
  const Byte *p = (const Byte *)data;
  for (; size > 0 ; size--, p++)
    v = CRC16_UPDATE_BYTE(v, *p);
  return v;
}

UInt16 MY_FAST_CALL Crc16Calc(const void *data, size_t size)
{
  return Crc16_Update(CRC16_INIT_VAL, data, size);
}

struct CCrc16TableInit { CCrc16TableInit() { Crc16GenerateTable(); } } g_Crc16TableInit;



void CDString::Parse(const Byte *p, unsigned size)
{
  Data.CopyFrom(p, size);
}

static UString ParseDString(const Byte *data, unsigned size)
{
  UString res;
  if (size > 0)
  {
    wchar_t *p;
    Byte type = data[0];
    if (type == 8)
    {
      p = res.GetBuf(size);
      for (unsigned i = 1; i < size; i++)
      {
        wchar_t c = data[i];
        if (c == 0)
          break;
        *p++ = c;
      }
    }
    else if (type == 16)
    {
      p = res.GetBuf(size / 2);
      for (unsigned i = 1; i + 2 <= size; i += 2)
      {
        wchar_t c = GetBe16(data + i);
        if (c == 0)
          break;
        *p++ = c;
      }
    }
    else
      return L"[unknow]";
    *p = 0;
    res.ReleaseBuf_SetLen((unsigned)(p - (const wchar_t *)res));
  }
  return res;
}

UString CDString128::GetString() const
{
  unsigned size = Data[sizeof(Data) - 1];
  return ParseDString(Data, MyMin(size, (unsigned)(sizeof(Data) - 1)));
}

UString CDString::GetString() const { return ParseDString(Data, (unsigned)Data.Size()); }

void CTime::Parse(const Byte *buf) { memcpy(Data, buf, sizeof(Data)); }

/*
void CRegId::Parse(const Byte *buf)
{
  Flags = buf[0];
  memcpy(Id, buf + 1, sizeof(Id));
  memcpy(Suffix, buf + 24, sizeof(Suffix));
}
*/

// ECMA 3/7.1

struct CExtent
{
  UInt32 Len;
  UInt32 Pos;

  void Parse(const Byte *buf);
};

void CExtent::Parse(const Byte *buf)
{
  Len = Get32(buf);
  Pos = Get32(buf + 4);
}

// ECMA 3/7.2

struct CTag
{
  UInt16 Id;
  UInt16 Version;
  // Byte Checksum;
  // UInt16 SerialNumber;
  // UInt16 Crc;
  // UInt16 CrcLen;
  // UInt32 TagLocation;
  
  HRESULT Parse(const Byte *buf, size_t size);
};

HRESULT CTag::Parse(const Byte *buf, size_t size)
{
  if (size < 16)
    return S_FALSE;
  Byte sum = 0;
  int i;
  for (i = 0; i <  4; i++) sum = (Byte)(sum + buf[i]);
  for (i = 5; i < 16; i++) sum = (Byte)(sum + buf[i]);
  if (sum != buf[4] || buf[5] != 0) return S_FALSE;

  Id = Get16(buf);
  Version = Get16(buf + 2);
  // SerialNumber = Get16(buf + 6);
  UInt16 crc = Get16(buf + 8);
  UInt16 crcLen = Get16(buf + 10);
  // TagLocation = Get32(buf + 12);

  if (size >= 16 + (size_t)crcLen)
    if (crc == Crc16Calc(buf + 16, crcLen))
      return S_OK;
  return S_FALSE;
}

// ECMA 3/7.2.1

enum EDescriptorType
{
  DESC_TYPE_SpoaringTable       = 0, // UDF
  DESC_TYPE_PrimVol             = 1,
  DESC_TYPE_AnchorVolPtr        = 2,
  DESC_TYPE_VolPtr              = 3,
  DESC_TYPE_ImplUseVol          = 4,
  DESC_TYPE_Partition           = 5,
  DESC_TYPE_LogicalVol          = 6,
  DESC_TYPE_UnallocSpace        = 7,
  DESC_TYPE_Terminating         = 8,
  DESC_TYPE_LogicalVolIntegrity = 9,
  DESC_TYPE_FileSet             = 256,
  DESC_TYPE_FileId              = 257,
  DESC_TYPE_AllocationExtent    = 258,
  DESC_TYPE_Indirect            = 259,
  DESC_TYPE_Terminal            = 260,
  DESC_TYPE_File                = 261,
  DESC_TYPE_ExtendedAttrHeader  = 262,
  DESC_TYPE_UnallocatedSpace    = 263,
  DESC_TYPE_SpaceBitmap         = 264,
  DESC_TYPE_PartitionIntegrity  = 265,
  DESC_TYPE_ExtendedFile        = 266
};


void CLogBlockAddr::Parse(const Byte *buf)
{
  Pos = Get32(buf);
  PartitionRef = Get16(buf + 4);
}

void CShortAllocDesc::Parse(const Byte *buf)
{
  Len = Get32(buf);
  Pos = Get32(buf + 4);
}

/*
void CADImpUse::Parse(const Byte *buf)
{
  Flags = Get16(buf);
  UdfUniqueId = Get32(buf + 2);
}
*/

void CLongAllocDesc::Parse(const Byte *buf)
{
  Len = Get32(buf);
  Location.Parse(buf + 4);
  // memcpy(ImplUse, buf + 10, sizeof(ImplUse));
  // adImpUse.Parse(ImplUse);
}

bool CInArchive::CheckExtent(int volIndex, int partitionRef, UInt32 blockPos, UInt32 len) const
{
  const CLogVol &vol = LogVols[volIndex];
  if (partitionRef >= (int)vol.PartitionMaps.Size())
    return false;
  const CPartition &partition = Partitions[vol.PartitionMaps[partitionRef].PartitionIndex];
  UInt64 offset = ((UInt64)partition.Pos << SecLogSize) + (UInt64)blockPos * vol.BlockSize;
  return (offset + len) <= (((UInt64)partition.Pos + partition.Len) << SecLogSize);
}

bool CInArchive::CheckItemExtents(int volIndex, const CItem &item) const
{
  FOR_VECTOR (i, item.Extents)
  {
    const CMyExtent &e = item.Extents[i];
    if (!CheckExtent(volIndex, e.PartitionRef, e.Pos, e.GetLen()))
      return false;
  }
  return true;
}

HRESULT CInArchive::Read(int volIndex, int partitionRef, UInt32 blockPos, UInt32 len, Byte *buf)
{
  if (!CheckExtent(volIndex, partitionRef, blockPos, len))
    return S_FALSE;
  const CLogVol &vol = LogVols[volIndex];
  const CPartition &partition = Partitions[vol.PartitionMaps[partitionRef].PartitionIndex];
  UInt64 offset = ((UInt64)partition.Pos << SecLogSize) + (UInt64)blockPos * vol.BlockSize;
  RINOK(_stream->Seek(offset, STREAM_SEEK_SET, NULL));
  HRESULT res = ReadStream_FALSE(_stream, buf, len);
  if (res == S_FALSE && offset + len > FileSize)
    UnexpectedEnd = true;
  RINOK(res);
  UpdatePhySize(offset + len);
  return S_OK;
}

HRESULT CInArchive::Read(int volIndex, const CLongAllocDesc &lad, Byte *buf)
{
  return Read(volIndex, lad.Location.PartitionRef, lad.Location.Pos, lad.GetLen(), (Byte *)buf);
}

HRESULT CInArchive::ReadFromFile(int volIndex, const CItem &item, CByteBuffer &buf)
{
  if (item.Size >= (UInt32)1 << 30)
    return S_FALSE;
  if (item.IsInline)
  {
    buf = item.InlineData;
    return S_OK;
  }
  buf.Alloc((size_t)item.Size);
  size_t pos = 0;
  FOR_VECTOR (i, item.Extents)
  {
    const CMyExtent &e = item.Extents[i];
    UInt32 len = e.GetLen();
    RINOK(Read(volIndex, e.PartitionRef, e.Pos, len, (Byte *)buf + pos));
    pos += len;
  }
  return S_OK;
}


void CIcbTag::Parse(const Byte *p)
{
  // PriorDirectNum = Get32(p);
  // StrategyType = Get16(p + 4);
  // StrategyParam = Get16(p + 6);
  // MaxNumOfEntries = Get16(p + 8);
  FileType = p[11];
  // ParentIcb.Parse(p + 12);
  Flags = Get16(p + 18);
}

void CItem::Parse(const Byte *p)
{
  // Uid = Get32(p + 36);
  // Gid = Get32(p + 40);
  // Permissions = Get32(p + 44);
  // FileLinkCount = Get16(p + 48);
  // RecordFormat = p[50];
  // RecordDisplayAttr = p[51];
  // RecordLen = Get32(p + 52);
  Size = Get64(p + 56);
  NumLogBlockRecorded = Get64(p + 64);
  ATime.Parse(p + 72);
  MTime.Parse(p + 84);
  // AttrtTime.Parse(p + 96);
  // CheckPoint = Get32(p + 108);
  // ExtendedAttrIcb.Parse(p + 112);
  // ImplId.Parse(p + 128);
  // UniqueId = Get64(p + 160);
}

// 4/14.4
struct CFileId
{
  // UInt16 FileVersion;
  Byte FileCharacteristics;
  // CByteBuffer ImplUse;
  CDString Id;
  CLongAllocDesc Icb;

  bool IsItLinkParent() const { return (FileCharacteristics & FILEID_CHARACS_Parent) != 0; }
  HRESULT Parse(const Byte *p, size_t size, size_t &processed);
};

HRESULT CFileId::Parse(const Byte *p, size_t size, size_t &processed)
{
  processed = 0;
  if (size < 38)
    return S_FALSE;
  CTag tag;
  RINOK(tag.Parse(p, size));
  if (tag.Id != DESC_TYPE_FileId)
    return S_FALSE;
  // FileVersion = Get16(p + 16);
  FileCharacteristics = p[18];
  unsigned idLen = p[19];
  Icb.Parse(p + 20);
  unsigned impLen = Get16(p + 36);
  if (size < 38 + idLen + impLen)
    return S_FALSE;
  // ImplUse.SetCapacity(impLen);
  processed = 38;
  // memcpy(ImplUse, p + processed, impLen);
  processed += impLen;
  Id.Parse(p + processed, idLen);
  processed += idLen;
  for (;(processed & 3) != 0; processed++)
    if (p[processed] != 0)
      return S_FALSE;
  return (processed <= size) ? S_OK : S_FALSE;
}

HRESULT CInArchive::ReadFileItem(int volIndex, int fsIndex, const CLongAllocDesc &lad, int numRecurseAllowed)
{
  if (Files.Size() % 100 == 0)
    RINOK(_progress->SetCompleted(Files.Size(), _processedProgressBytes));
  if (numRecurseAllowed-- == 0)
    return S_FALSE;
  CFile &file = Files.Back();
  const CLogVol &vol = LogVols[volIndex];
  unsigned partitionRef = lad.Location.PartitionRef;
  if (partitionRef >= vol.PartitionMaps.Size())
    return S_FALSE;
  CPartition &partition = Partitions[vol.PartitionMaps[partitionRef].PartitionIndex];

  UInt32 key = lad.Location.Pos;
  UInt32 value;
  const UInt32 kRecursedErrorValue = (UInt32)(Int32)-1;
  if (partition.Map.Find(key, value))
  {
    if (value == kRecursedErrorValue)
      return S_FALSE;
    file.ItemIndex = value;
  }
  else
  {
    value = Items.Size();
    file.ItemIndex = (int)value;
    if (partition.Map.Set(key, kRecursedErrorValue))
      return S_FALSE;
    RINOK(ReadItem(volIndex, fsIndex, lad, numRecurseAllowed));
    if (!partition.Map.Set(key, value))
      return S_FALSE;
  }
  return S_OK;
}

HRESULT CInArchive::ReadItem(int volIndex, int fsIndex, const CLongAllocDesc &lad, int numRecurseAllowed)
{
  if (Items.Size() > kNumItemsMax)
    return S_FALSE;
  Items.Add(CItem());
  CItem &item = Items.Back();
  
  const CLogVol &vol = LogVols[volIndex];
 
  if (lad.GetLen() != vol.BlockSize)
    return S_FALSE;

  const size_t size = lad.GetLen();
  CByteBuffer buf(size);
  RINOK(Read(volIndex, lad, buf));

  CTag tag;
  const Byte *p = buf;
  RINOK(tag.Parse(p, size));
  if (size < 176)
    return S_FALSE;
  if (tag.Id != DESC_TYPE_File)
    return S_FALSE;

  item.IcbTag.Parse(p + 16);
  if (item.IcbTag.FileType != ICB_FILE_TYPE_DIR &&
      item.IcbTag.FileType != ICB_FILE_TYPE_FILE)
    return S_FALSE;

  item.Parse(p);

  _processedProgressBytes += (UInt64)item.NumLogBlockRecorded * vol.BlockSize + size;

  UInt32 extendedAttrLen = Get32(p + 168);
  UInt32 allocDescriptorsLen = Get32(p + 172);

  if ((extendedAttrLen & 3) != 0)
    return S_FALSE;
  size_t pos = 176;
  if (extendedAttrLen > size - pos)
    return S_FALSE;
  /*
  if (extendedAttrLen != 16)
  {
    if (extendedAttrLen < 24)
      return S_FALSE;
    CTag attrTag;
    RINOK(attrTag.Parse(p + pos, size));
    if (attrTag.Id != DESC_TYPE_ExtendedAttrHeader)
      return S_FALSE;
    // UInt32 implAttrLocation = Get32(p + pos + 16);
    // UInt32 applicationlAttrLocation = Get32(p + pos + 20);
  }
  */
  pos += extendedAttrLen;

  int desctType = item.IcbTag.GetDescriptorType();
  if (allocDescriptorsLen > size - pos)
    return S_FALSE;
  if (desctType == ICB_DESC_TYPE_INLINE)
  {
    item.IsInline = true;
    item.InlineData.CopyFrom(p + pos, allocDescriptorsLen);
  }
  else
  {
    item.IsInline = false;
    if (desctType != ICB_DESC_TYPE_SHORT && desctType != ICB_DESC_TYPE_LONG)
      return S_FALSE;
    for (UInt32 i = 0; i < allocDescriptorsLen;)
    {
      CMyExtent e;
      if (desctType == ICB_DESC_TYPE_SHORT)
      {
        if (i + 8 > allocDescriptorsLen)
          return S_FALSE;
        CShortAllocDesc sad;
        sad.Parse(p + pos + i);
        e.Pos = sad.Pos;
        e.Len = sad.Len;
        e.PartitionRef = lad.Location.PartitionRef;
        i += 8;
      }
      else
      {
        if (i + 16 > allocDescriptorsLen)
          return S_FALSE;
        CLongAllocDesc ladNew;
        ladNew.Parse(p + pos + i);
        e.Pos = ladNew.Location.Pos;
        e.PartitionRef = ladNew.Location.PartitionRef;
        e.Len = ladNew.Len;
        i += 16;
      }
      item.Extents.Add(e);
    }
  }

  if (item.IcbTag.IsDir())
  {
    if (!item.CheckChunkSizes() || !CheckItemExtents(volIndex, item))
      return S_FALSE;
    CByteBuffer buf2;
    RINOK(ReadFromFile(volIndex, item, buf2));
    item.Size = 0;
    item.Extents.ClearAndFree();
    item.InlineData.Free();

    const Byte *p2 = buf2;
    const size_t size2 = buf2.Size();
    size_t processedTotal = 0;
    for (; processedTotal < size2;)
    {
      size_t processedCur;
      CFileId fileId;
      RINOK(fileId.Parse(p2 + processedTotal, size2 - processedTotal, processedCur));
      if (!fileId.IsItLinkParent())
      {
        CFile file;
        // file.FileVersion = fileId.FileVersion;
        // file.FileCharacteristics = fileId.FileCharacteristics;
        // file.ImplUse = fileId.ImplUse;
        file.Id = fileId.Id;
        
        _fileNameLengthTotal += file.Id.Data.Size();
        if (_fileNameLengthTotal > kFileNameLengthTotalMax)
          return S_FALSE;
        
        item.SubFiles.Add(Files.Size());
        if (Files.Size() > kNumFilesMax)
          return S_FALSE;
        Files.Add(file);
        RINOK(ReadFileItem(volIndex, fsIndex, fileId.Icb, numRecurseAllowed));
      }
      processedTotal += processedCur;
    }
  }
  else
  {
    if ((UInt32)item.Extents.Size() > kNumExtentsMax - _numExtents)
      return S_FALSE;
    _numExtents += item.Extents.Size();

    if (item.InlineData.Size() > kInlineExtentsSizeMax - _inlineExtentsSize)
      return S_FALSE;
    _inlineExtentsSize += item.InlineData.Size();
  }

  return S_OK;
}

HRESULT CInArchive::FillRefs(CFileSet &fs, unsigned fileIndex, int parent, int numRecurseAllowed)
{
  if ((_numRefs & 0xFFF) == 0)
  {
    RINOK(_progress->SetCompleted());
  }
  if (numRecurseAllowed-- == 0)
    return S_FALSE;
  if (_numRefs >= kNumRefsMax)
    return S_FALSE;
  _numRefs++;
  CRef ref;
  ref.FileIndex = fileIndex;
  ref.Parent = parent;
  parent = fs.Refs.Size();
  fs.Refs.Add(ref);
  const CItem &item = Items[Files[fileIndex].ItemIndex];
  FOR_VECTOR (i, item.SubFiles)
  {
    RINOK(FillRefs(fs, item.SubFiles[i], parent, numRecurseAllowed));
  }
  return S_OK;
}

API_FUNC_IsArc IsArc_Udf(const Byte *p, size_t size)
{
  UInt32 res = k_IsArc_Res_NO;
  unsigned SecLogSize;
  for (SecLogSize = 11;; SecLogSize -= 3)
  {
    if (SecLogSize < 8)
      return res;
    const UInt32 offset = (UInt32)256 << SecLogSize;
    const UInt32 bufSize = (UInt32)1 << SecLogSize;
    if (offset + bufSize > size)
      res = k_IsArc_Res_NEED_MORE;
    else
    {
      CTag tag;
      if (tag.Parse(p + offset, bufSize) == S_OK)
        if (tag.Id == DESC_TYPE_AnchorVolPtr)
          return k_IsArc_Res_YES;
    }
  }
}


HRESULT CInArchive::Open2()
{
  Clear();
  UInt64 fileSize;
  RINOK(_stream->Seek(0, STREAM_SEEK_END, &fileSize));
  FileSize = fileSize;

  // Some UDFs contain additional pad zeros (2 KB).
  // Seek to STREAM_SEEK_END for direct DVD reading can return 8 KB more, so we check last 16 KB.
  // And when we read last block, result read size can be smaller than required size.

  /*
  const size_t kBufSize = 1 << 14;
  Byte buf[kBufSize];
  size_t readSize = (fileSize < kBufSize) ? (size_t)fileSize : kBufSize;
  RINOK(_stream->Seek(fileSize - readSize, STREAM_SEEK_SET, NULL));
  RINOK(ReadStream(_stream, buf, &readSize));
  size_t i = readSize;
  for (;;)
  {
    const size_t kSecSizeMin = 1 << 8;
    if (i < kSecSizeMin)
      return S_FALSE;
    i -= kSecSizeMin;
    SecLogSize = (readSize - i < ((size_t)1 << 11)) ? 8 : 11;
    CTag tag;
    if (tag.Parse(buf + i, (1 << SecLogSize)) == S_OK)
      if (tag.Id == DESC_TYPE_AnchorVolPtr)
        break;
  }
  PhySize = fileSize;
  CExtent extentVDS;
  extentVDS.Parse(buf + i + 16);
  */

  const size_t kBufSize = 1 << 11;
  Byte buf[kBufSize];
  
  for (SecLogSize = 11;; SecLogSize -= 3)
  {
    if (SecLogSize < 8)
      return S_FALSE;
    UInt32 offset = (UInt32)256 << SecLogSize;
    if (offset >= fileSize)
      continue;
    RINOK(_stream->Seek(offset, STREAM_SEEK_SET, NULL));
    const size_t bufSize = (size_t)1 << SecLogSize;
    size_t readSize = bufSize;
    RINOK(ReadStream(_stream, buf, &readSize));
    if (readSize == bufSize)
    {
      CTag tag;
      if (tag.Parse(buf, readSize) == S_OK)
        if (tag.Id == DESC_TYPE_AnchorVolPtr)
          break;
    }
  }
  
  PhySize = (UInt32)(256 + 1) << SecLogSize;
  IsArc = true;

  CExtent extentVDS;
  extentVDS.Parse(buf + 16);
  {
    CExtent extentVDS2;
    extentVDS2.Parse(buf + 24);
    UpdatePhySize(((UInt64)extentVDS.Pos << SecLogSize) + extentVDS.Len);
    UpdatePhySize(((UInt64)extentVDS2.Pos << SecLogSize) + extentVDS2.Len);
  }

  for (UInt32 location = 0; ; location++)
  {
    const size_t bufSize = (size_t)1 << SecLogSize;
    if (((UInt64)(location + 1) << SecLogSize) > extentVDS.Len)
      return S_FALSE;

    UInt64 offs = (UInt64)(extentVDS.Pos + location) << SecLogSize;
    RINOK(_stream->Seek(offs, STREAM_SEEK_SET, NULL));
    HRESULT res = ReadStream_FALSE(_stream, buf, bufSize);
    if (res == S_FALSE && offs + bufSize > FileSize)
      UnexpectedEnd = true;
    RINOK(res);


    CTag tag;
    {
      const size_t pos = 0;
      RINOK(tag.Parse(buf + pos, bufSize - pos));
    }
    if (tag.Id == DESC_TYPE_Terminating)
      break;
    
    if (tag.Id == DESC_TYPE_Partition)
    {
      // Partition Descriptor
      // ECMA 167 3/10.5
      // UDF / 2.2.14

      if (Partitions.Size() >= kNumPartitionsMax)
        return S_FALSE;
      CPartition partition;
      // UInt32 volDescSeqNumer = Get32(buf + 16);
      // partition.Flags = Get16(buf + 20);
      partition.Number = Get16(buf + 22);
      // partition.ContentsId.Parse(buf + 24);
      
      // memcpy(partition.ContentsUse, buf + 56, sizeof(partition.ContentsUse));
      // ContentsUse is Partition Header Description.

      // partition.AccessType = Get32(buf + 184);
      partition.Pos = Get32(buf + 188);
      partition.Len = Get32(buf + 192);
      // partition.ImplId.Parse(buf + 196);
      // memcpy(partition.ImplUse, buf + 228, sizeof(partition.ImplUse));

      PRF(printf("\nPartition number = %2d   pos = %d   len = %d", partition.Number, partition.Pos, partition.Len));
      Partitions.Add(partition);
    }
    else if (tag.Id == DESC_TYPE_LogicalVol)
    {
      /* Logical Volume Descriptor
          ECMA 3/10.6
          UDF 2.60 2.2.4 */

      if (LogVols.Size() >= kNumLogVolumesMax)
        return S_FALSE;
      CLogVol vol;
      vol.Id.Parse(buf + 84);
      vol.BlockSize = Get32(buf + 212);
      // vol.DomainId.Parse(buf + 216);

      if (vol.BlockSize < 512 || vol.BlockSize > ((UInt32)1 << 30))
        return S_FALSE;
      
      // memcpy(vol.ContentsUse, buf + 248, sizeof(vol.ContentsUse));
      vol.FileSetLocation.Parse(buf + 248);
      /* the extent in which the first File Set Descriptor Sequence
         of the logical volume is recorded */

      // UInt32 mapTableLength = Get32(buf + 264);
      UInt32 numPartitionMaps = Get32(buf + 268);
      if (numPartitionMaps > kNumPartitionsMax)
        return S_FALSE;
      // vol.ImplId.Parse(buf + 272);
      // memcpy(vol.ImplUse, buf + 128, sizeof(vol.ImplUse));

      PRF(printf("\nLogicalVol numPartitionMaps = %2d", numPartitionMaps));
      size_t pos = 440;
      for (UInt32 i = 0; i < numPartitionMaps; i++)
      {
        if (pos + 2 > bufSize)
          return S_FALSE;
        CPartitionMap pm;
        pm.Type = buf[pos];
        // pm.Length = buf[pos + 1];
        Byte len = buf[pos + 1];

        if (pos + len > bufSize)
          return S_FALSE;
        
        // memcpy(pm.Data, buf + pos + 2, pm.Length - 2);
        if (pm.Type == 1)
        {
          if (len != 6) // < 6
            return S_FALSE;
          // pm.VolSeqNumber = Get16(buf + pos + 2);
          pm.PartitionNumber = Get16(buf + pos + 4);
          PRF(printf("\nPartitionMap type 1 PartitionNumber = %2d", pm.PartitionNumber));
        }
        else if (pm.Type == 2)
        {
          if (len != 64)
            return S_FALSE;
          /* ECMA 10.7.3 / Type 2 Partition Map
             62 bytes: Partition Identifier. */

          /* UDF 2.6
             2.2.8 Virtual Partition Map
             This is an extension of ECMA 167 to expand its scope to include
             sequentially written media (eg. CD-R).  This extension is for a
             Partition Map entry to describe a virtual space.   */

          // It's not implemented still.
          if (Get16(buf + pos + 2) != 0)
            return S_FALSE;
          // pm.VolSeqNumber = Get16(buf + pos + 36);
          pm.PartitionNumber = Get16(buf + pos + 38);
          PRF(printf("\nPartitionMap type 2 PartitionNumber = %2d", pm.PartitionNumber));
          // Unsupported = true;
          return S_FALSE;
        }
        else
          return S_FALSE;
        pos += len;
        vol.PartitionMaps.Add(pm);
      }
      LogVols.Add(vol);
    }
  }

  UInt64 totalSize = 0;

  unsigned volIndex;
  for (volIndex = 0; volIndex < LogVols.Size(); volIndex++)
  {
    CLogVol &vol = LogVols[volIndex];
    FOR_VECTOR (pmIndex, vol.PartitionMaps)
    {
      CPartitionMap &pm = vol.PartitionMaps[pmIndex];
      unsigned i;
      for (i = 0; i < Partitions.Size(); i++)
      {
        CPartition &part = Partitions[i];
        if (part.Number == pm.PartitionNumber)
        {
          if (part.VolIndex >= 0)
          {
            // it's for 2.60. Fix it
            if (part.VolIndex != (int)volIndex)
              return S_FALSE;
            // return S_FALSE;
          }
          pm.PartitionIndex = i;
          part.VolIndex = volIndex;

          totalSize += (UInt64)part.Len << SecLogSize;
          break;
        }
      }
      if (i == Partitions.Size())
        return S_FALSE;
    }
  }

  RINOK(_progress->SetTotal(totalSize));

  PRF(printf("\n Read files"));

  for (volIndex = 0; volIndex < LogVols.Size(); volIndex++)
  {
    CLogVol &vol = LogVols[volIndex];

    PRF(printf("\nLogVol %2d", volIndex));

    CLongAllocDesc nextExtent = vol.FileSetLocation;
    // while (nextExtent.ExtentLen != 0)
    // for (int i = 0; i < 1; i++)
    {
      if (nextExtent.GetLen() < 512)
        return S_FALSE;
      CByteBuffer buf2(nextExtent.GetLen());
      RINOK(Read(volIndex, nextExtent, buf2));
      const Byte *p = buf2;
      size_t size = nextExtent.GetLen();

      CTag tag;
      RINOK(tag.Parse(p, size));

      if (tag.Id == DESC_TYPE_ExtendedFile)
      {
        // ECMA 4 / 14.17
        // 2.60 ??
        return S_FALSE;
      }

      if (tag.Id != DESC_TYPE_FileSet)
        return S_FALSE;
      
      PRF(printf("\n FileSet", volIndex));
      CFileSet fs;
      fs.RecodringTime.Parse(p + 16);
      // fs.InterchangeLevel = Get16(p + 18);
      // fs.MaxInterchangeLevel = Get16(p + 20);
      // fs.FileSetNumber = Get32(p + 40);
      // fs.FileSetDescNumber = Get32(p + 44);
      
      // fs.Id.Parse(p + 304);
      // fs.CopyrightId.Parse(p + 336);
      // fs.AbstractId.Parse(p + 368);
      
      fs.RootDirICB.Parse(p + 400);
      // fs.DomainId.Parse(p + 416);
      
      // fs.SystemStreamDirICB.Parse(p + 464);
      
      vol.FileSets.Add(fs);

      // nextExtent.Parse(p + 448);
    }

    FOR_VECTOR (fsIndex, vol.FileSets)
    {
      CFileSet &fs = vol.FileSets[fsIndex];
      unsigned fileIndex = Files.Size();
      Files.AddNew();
      RINOK(ReadFileItem(volIndex, fsIndex, fs.RootDirICB, kNumRecursionLevelsMax));
      RINOK(FillRefs(fs, fileIndex, -1, kNumRecursionLevelsMax));
    }
  }


  for (volIndex = 0; volIndex < LogVols.Size(); volIndex++)
  {
    const CLogVol &vol = LogVols[volIndex];
    // bool showFileSetName = (vol.FileSets.Size() > 1);
    FOR_VECTOR (fsIndex, vol.FileSets)
    {
      const CFileSet &fs = vol.FileSets[fsIndex];
      for (unsigned i =
          // ((showVolName || showFileSetName) ? 0 : 1)
            0; i < fs.Refs.Size(); i++)
      {
        const CRef &ref = vol.FileSets[fsIndex].Refs[i];
        const CFile &file = Files[ref.FileIndex];
        const CItem &item = Items[file.ItemIndex];
        UInt64 size = item.Size;

        if (!item.IsRecAndAlloc() || !item.CheckChunkSizes() || !CheckItemExtents(volIndex, item))
          continue;

        FOR_VECTOR (extentIndex, item.Extents)
        {
          const CMyExtent &extent = item.Extents[extentIndex];
          UInt32 len = extent.GetLen();
          if (len == 0)
            continue;
          if (size < len)
            break;
          
          int partitionIndex = vol.PartitionMaps[extent.PartitionRef].PartitionIndex;
          UInt32 logBlockNumber = extent.Pos;
          const CPartition &partition = Partitions[partitionIndex];
          UInt64 offset = ((UInt64)partition.Pos << SecLogSize) +
              (UInt64)logBlockNumber * vol.BlockSize;
          UpdatePhySize(offset + len);
        }
      }
    }
  }

  {
    const UInt32 secMask = ((UInt32)1 << SecLogSize) - 1;
    PhySize = (PhySize + secMask) & ~(UInt64)secMask;
  }
  
  NoEndAnchor = true;

  if (PhySize < fileSize)
  {
    UInt64 rem = fileSize - PhySize;
    const size_t secSize = (size_t)1 << SecLogSize;

    RINOK(_stream->Seek(PhySize, STREAM_SEEK_SET, NULL));

    // some UDF images contain ZEROs before "Anchor Volume Descriptor Pointer" at the end

    for (unsigned sec = 0; sec < 1024; sec++)
    {
      if (rem == 0)
        break;
      
      size_t readSize = secSize;
      if (readSize > rem)
        readSize = (size_t)rem;
      
      RINOK(ReadStream(_stream, buf, &readSize));
      
      if (readSize == 0)
        break;
      
      if (readSize == secSize && NoEndAnchor)
      {
        CTag tag;
        if (tag.Parse(buf, readSize) == S_OK &&
            tag.Id == DESC_TYPE_AnchorVolPtr)
        {
          NoEndAnchor = false;
          rem -= readSize;
          PhySize = fileSize - rem;
          continue;
        }
      }
      
      size_t i;
      for (i = 0; i < readSize && buf[i] == 0; i++);
      if (i != readSize)
        break;
      rem -= readSize;
    }

    if (rem == 0)
      PhySize = fileSize;
  }

  return S_OK;
}


HRESULT CInArchive::Open(IInStream *inStream, CProgressVirt *progress)
{
  _progress = progress;
  _stream = inStream;
  HRESULT res = Open2();
  if (res == S_FALSE && IsArc && !UnexpectedEnd)
    Unsupported = true;
  return res;

  /*
  HRESULT res;
  try
  {
    res = Open2();
  }
  catch(...)
  {
    // Clear();
    // res = S_FALSE;
    _stream.Release();
    throw;
  }
  _stream.Release();
  return res;
  */
}

void CInArchive::Clear()
{
  IsArc = false;
  Unsupported = false;
  UnexpectedEnd = false;
  NoEndAnchor = false;

  PhySize = 0;
  FileSize = 0;

  Partitions.Clear();
  LogVols.Clear();
  Items.Clear();
  Files.Clear();
  _fileNameLengthTotal = 0;
  _numRefs = 0;
  _numExtents = 0;
  _inlineExtentsSize = 0;
  _processedProgressBytes = 0;
}

UString CInArchive::GetComment() const
{
  UString res;
  FOR_VECTOR (i, LogVols)
  {
    if (i != 0)
      res.Add_Space();
    res += LogVols[i].GetName();
  }
  return res;
}

static UString GetSpecName(const UString &name)
{
  UString name2 = name;
  name2.Trim();
  if (name2.IsEmpty())
  {
    /*
    wchar_t s[32];
    ConvertUInt64ToString(id, s);
    return L"[" + (UString)s + L"]";
    */
    return L"[]";
  }
  return name;
}

static void UpdateWithName(UString &res, const UString &addString)
{
  if (res.IsEmpty())
    res = addString;
  else
    res.Insert(0, addString + WCHAR_PATH_SEPARATOR);
}

UString CInArchive::GetItemPath(int volIndex, int fsIndex, int refIndex,
    bool showVolName, bool showFsName) const
{
  // showVolName = true;
  const CLogVol &vol = LogVols[volIndex];
  const CFileSet &fs = vol.FileSets[fsIndex];

  UString name;

  for (;;)
  {
    const CRef &ref = fs.Refs[refIndex];
    refIndex = ref.Parent;
    if (refIndex < 0)
      break;
    UpdateWithName(name, GetSpecName(Files[ref.FileIndex].GetName()));
  }

  if (showFsName)
  {
    wchar_t s[32];
    ConvertUInt32ToString(fsIndex, s);
    UString newName = L"File Set ";
    newName += s;
    UpdateWithName(name, newName);
  }

  if (showVolName)
  {
    wchar_t s[32];
    ConvertUInt32ToString(volIndex, s);
    UString newName = s;
    UString newName2 = vol.GetName();
    if (newName2.IsEmpty())
      newName2 = L"Volume";
    newName += L'-';
    newName += newName2;
    UpdateWithName(name, newName);
  }
  return name;
}

}}
// Archive/UdfIn.h -- UDF / ECMA-167

#ifndef __ARCHIVE_UDF_IN_H
#define __ARCHIVE_UDF_IN_H

#include "../../../Common/IntToString.h"
#include "../../../Common/MyBuffer.h"
#include "../../../Common/MyCom.h"
#include "../../../Common/MyMap.h"
#include "../../../Common/MyString.h"

#include "../../IStream.h"

namespace NArchive {
namespace NUdf {

// ---------- ECMA Part 1 ----------

// ECMA 1/7.2.12

/*
struct CDString32
{
  Byte Data[32];
  
  void Parse(const Byte *buf);
  // UString GetString() const;
};
*/

struct CDString128
{
  Byte Data[128];
  
  void Parse(const Byte *buf) { memcpy(Data, buf, sizeof(Data)); }
  UString GetString() const;
};

struct CDString
{
  CByteBuffer Data;
  
  void Parse(const Byte *p, unsigned size);
  UString GetString() const;
};


// ECMA 1/7.3

struct CTime
{
  Byte Data[12];

  unsigned GetType() const { return Data[1] >> 4; }
  bool IsLocal() const { return GetType() == 1; }
  int GetMinutesOffset() const
  {
    int t = (Data[0] | ((unsigned)Data[1] << 8)) & 0xFFF;
    if ((t >> 11) != 0)
      t -= (1 << 12);
    return (t > (60 * 24) || t < -(60 * 24)) ? 0 : t;
  }
  unsigned GetYear() const { return (Data[2] | ((unsigned)Data[3] << 8)); }
  void Parse(const Byte *buf);
};


// ECMA 1/7.4

/*
struct CRegId
{
  Byte Flags;
  char Id[23];
  char Suffix[8];

  void Parse(const Byte *buf);
};
*/

// ---------- ECMA Part 3: Volume Structure ----------

// ECMA 3/10.5

struct CPartition
{
  // UInt16 Flags;
  UInt16 Number;
  // CRegId ContentsId;
  // Byte ContentsUse[128];
  // UInt32 AccessType;

  UInt32 Pos;
  UInt32 Len;

  // CRegId ImplId;
  // Byte ImplUse[128];

  int VolIndex;
  CMap32 Map;

  CPartition(): VolIndex(-1) {}

  // bool IsNsr() const { return (strncmp(ContentsId.Id, "+NSR0", 5) == 0); }
  // bool IsAllocated() const { return ((Flags & 1) != 0); }
};

struct CLogBlockAddr
{
  UInt32 Pos;
  UInt16 PartitionRef;
  
  void Parse(const Byte *buf);
};

enum EShortAllocDescType
{
  SHORT_ALLOC_DESC_TYPE_RecordedAndAllocated = 0,
  SHORT_ALLOC_DESC_TYPE_NotRecordedButAllocated = 1,
  SHORT_ALLOC_DESC_TYPE_NotRecordedAndNotAllocated = 2,
  SHORT_ALLOC_DESC_TYPE_NextExtent = 3
};

struct CShortAllocDesc
{
  UInt32 Len;
  UInt32 Pos;

  // 4/14.14.1
  // UInt32 GetLen() const { return Len & 0x3FFFFFFF; }
  // UInt32 GetType() const { return Len >> 30; }
  // bool IsRecAndAlloc() const { return GetType() == SHORT_ALLOC_DESC_TYPE_RecordedAndAllocated; }
  void Parse(const Byte *buf);
};

/*
struct CADImpUse
{
  UInt16 Flags;
  UInt32 UdfUniqueId;
  void Parse(const Byte *buf);
};
*/

struct CLongAllocDesc
{
  UInt32 Len;
  CLogBlockAddr Location;
  
  // Byte ImplUse[6];
  // CADImpUse adImpUse; // UDF
  
  UInt32 GetLen() const { return Len & 0x3FFFFFFF; }
  UInt32 GetType() const { return Len >> 30; }
  bool IsRecAndAlloc() const { return GetType() == SHORT_ALLOC_DESC_TYPE_RecordedAndAllocated; }
  void Parse(const Byte *buf);
};

struct CPartitionMap
{
  Byte Type;
  // Byte Len;

  // Type - 1
  // UInt16 VolSeqNumber;
  UInt16 PartitionNumber;

  // Byte Data[256];

  int PartitionIndex;
};

// ECMA 4/14.6

enum EIcbFileType
{
  ICB_FILE_TYPE_DIR = 4,
  ICB_FILE_TYPE_FILE = 5
};

enum EIcbDescriptorType
{
  ICB_DESC_TYPE_SHORT = 0,
  ICB_DESC_TYPE_LONG = 1,
  ICB_DESC_TYPE_EXTENDED = 2,
  ICB_DESC_TYPE_INLINE = 3
};

struct CIcbTag
{
  // UInt32 PriorDirectNum;
  // UInt16 StrategyType;
  // UInt16 StrategyParam;
  // UInt16 MaxNumOfEntries;
  Byte FileType;
  // CLogBlockAddr ParentIcb;
  UInt16 Flags;

  bool IsDir() const { return FileType == ICB_FILE_TYPE_DIR; }
  int GetDescriptorType() const { return Flags & 3; }
  void Parse(const Byte *p);
};

// const Byte FILEID_CHARACS_Existance = (1 << 0);
const Byte FILEID_CHARACS_Parent = (1 << 3);

struct CFile
{
  // UInt16 FileVersion;
  // Byte FileCharacteristics;
  // CByteBuffer ImplUse;
  CDString Id;

  int ItemIndex;

  CFile(): /* FileVersion(0), FileCharacteristics(0), */ ItemIndex(-1) {}
  UString GetName() const { return Id.GetString(); }
};

struct CMyExtent
{
  UInt32 Pos;
  UInt32 Len;
  unsigned PartitionRef;
  
  UInt32 GetLen() const { return Len & 0x3FFFFFFF; }
  UInt32 GetType() const { return Len >> 30; }
  bool IsRecAndAlloc() const { return GetType() == SHORT_ALLOC_DESC_TYPE_RecordedAndAllocated; }
};

struct CItem
{
  CIcbTag IcbTag;

  // UInt32 Uid;
  // UInt32 Gid;
  // UInt32 Permissions;
  // UInt16 FileLinkCount;
  // Byte RecordFormat;
  // Byte RecordDisplayAttr;
  // UInt32 RecordLen;
  UInt64 Size;
  UInt64 NumLogBlockRecorded;
  CTime ATime;
  CTime MTime;
  // CTime AttrtTime;
  // UInt32 CheckPoint;
  // CLongAllocDesc ExtendedAttrIcb;
  // CRegId ImplId;
  // UInt64 UniqueId;

  bool IsInline;
  CByteBuffer InlineData;
  CRecordVector<CMyExtent> Extents;
  CUIntVector SubFiles;

  void Parse(const Byte *buf);

  bool IsRecAndAlloc() const
  {
    FOR_VECTOR (i, Extents)
      if (!Extents[i].IsRecAndAlloc())
        return false;
    return true;
  }

  UInt64 GetChunksSumSize() const
  {
    if (IsInline)
      return InlineData.Size();
    UInt64 size = 0;
    FOR_VECTOR (i, Extents)
      size += Extents[i].GetLen();
    return size;
  }

  bool CheckChunkSizes() const  {  return GetChunksSumSize() == Size; }

  bool IsDir() const { return IcbTag.IsDir(); }
};
 
struct CRef
{
  int Parent;
  unsigned FileIndex;
};


// ECMA 4 / 14.1
struct CFileSet
{
  CTime RecodringTime;
  // UInt16 InterchangeLevel;
  // UInt16 MaxInterchangeLevel;
  // UInt32 FileSetNumber;
  // UInt32 FileSetDescNumber;
  // CDString32 Id;
  // CDString32 CopyrightId;
  // CDString32 AbstractId;

  CLongAllocDesc RootDirICB;
  // CRegId DomainId;
  // CLongAllocDesc SystemStreamDirICB;

  CRecordVector<CRef> Refs;
};


// ECMA 3/10.6

struct CLogVol
{
  CDString128 Id;
  UInt32 BlockSize;
  // CRegId DomainId;
  
  // Byte ContentsUse[16];
  CLongAllocDesc FileSetLocation; // UDF

  // CRegId ImplId;
  // Byte ImplUse[128];

  CObjectVector<CPartitionMap> PartitionMaps;
  CObjectVector<CFileSet> FileSets;

  UString GetName() const { return Id.GetString(); }
};

struct CProgressVirt
{
  virtual HRESULT SetTotal(UInt64 numBytes) PURE;
  virtual HRESULT SetCompleted(UInt64 numFiles, UInt64 numBytes) PURE;
  virtual HRESULT SetCompleted() PURE;
};

class CInArchive
{
  IInStream *_stream;
  CProgressVirt *_progress;

  HRESULT Read(int volIndex, int partitionRef, UInt32 blockPos, UInt32 len, Byte *buf);
  HRESULT Read(int volIndex, const CLongAllocDesc &lad, Byte *buf);
  HRESULT ReadFromFile(int volIndex, const CItem &item, CByteBuffer &buf);

  HRESULT ReadFileItem(int volIndex, int fsIndex, const CLongAllocDesc &lad, int numRecurseAllowed);
  HRESULT ReadItem(int volIndex, int fsIndex, const CLongAllocDesc &lad, int numRecurseAllowed);

  HRESULT Open2();
  HRESULT FillRefs(CFileSet &fs, unsigned fileIndex, int parent, int numRecurseAllowed);

  UInt64 _processedProgressBytes;

  UInt64 _fileNameLengthTotal;
  int _numRefs;
  UInt32 _numExtents;
  UInt64 _inlineExtentsSize;
  bool CheckExtent(int volIndex, int partitionRef, UInt32 blockPos, UInt32 len) const;

public:
  CObjectVector<CPartition> Partitions;
  CObjectVector<CLogVol> LogVols;

  CObjectVector<CItem> Items;
  CObjectVector<CFile> Files;

  unsigned SecLogSize;
  UInt64 PhySize;
  UInt64 FileSize;

  bool IsArc;
  bool Unsupported;
  bool UnexpectedEnd;
  bool NoEndAnchor;

  void UpdatePhySize(UInt64 val)
  {
    if (PhySize < val)
      PhySize = val;
  }
  HRESULT Open(IInStream *inStream, CProgressVirt *progress);
  void Clear();

  UString GetComment() const;
  UString GetItemPath(int volIndex, int fsIndex, int refIndex,
      bool showVolName, bool showFsName) const;

  bool CheckItemExtents(int volIndex, const CItem &item) const;
};

API_FUNC_IsArc IsArc_Udf(const Byte *p, size_t size);

}}
  
#endif
// WimHandler.cpp

#include "StdAfx.h"

#include "../../../../C/CpuArch.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/IntToString.h"

#include "../../Common/MethodProps.h"
#include "../../Common/ProgressUtils.h"
#include "../../Common/StreamUtils.h"

#include "WimHandler.h"

#define Get16(p) GetUi16(p)
#define Get32(p) GetUi32(p)
#define Get64(p) GetUi64(p)

using namespace NWindows;

namespace NArchive {
namespace NWim {

#define FILES_DIR_NAME "[DELETED]"

// #define WIM_DETAILS

static const Byte kProps[] =
{
  kpidPath,
  kpidIsDir,
  kpidSize,
  kpidPackSize,
  kpidMTime,
  kpidCTime,
  kpidATime,
  kpidAttrib,
  kpidMethod,
  kpidSolid,
  kpidShortName,
  kpidINode,
  kpidLinks,
  kpidIsAltStream,
  kpidNumAltStreams,
  
  #ifdef WIM_DETAILS
  , kpidVolume
  , kpidOffset
  #endif
};

enum
{
  kpidNumImages = kpidUserDefined,
  kpidBootImage
};

static const CStatProp kArcProps[] =
{
  { NULL, kpidSize, VT_UI8},
  { NULL, kpidPackSize, VT_UI8},
  { NULL, kpidMethod, VT_BSTR},
  { NULL, kpidClusterSize, VT_UI4},
  { NULL, kpidCTime, VT_FILETIME},
  { NULL, kpidMTime, VT_FILETIME},
  { NULL, kpidComment, VT_BSTR},
  { NULL, kpidUnpackVer, VT_BSTR},
  { NULL, kpidIsVolume, VT_BOOL},
  { NULL, kpidVolume, VT_UI4},
  { NULL, kpidNumVolumes, VT_UI4},
  { "Images", kpidNumImages, VT_UI4},
  { "Boot Image", kpidBootImage, VT_UI4}
};


static const char * const k_Methods[] =
{
    "Copy"
  , "XPress"
  , "LZX"
  , "LZMS"
};



IMP_IInArchive_Props
IMP_IInArchive_ArcProps_WITH_NAME

static void AddErrorMessage(AString &s, const char *message)
{
  if (!s.IsEmpty())
    s += ". ";
  s += message;
}

static void ConvertByteToHex(unsigned value, char *s)
{
  for (int i = 0; i < 2; i++)
  {
    unsigned t = value & 0xF;
    value >>= 4;
    s[1 - i] = (char)((t < 10) ? ('0' + t) : ('A' + (t - 10)));
  }
}

STDMETHODIMP CHandler::GetArchiveProperty(PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NCOM::CPropVariant prop;

  const CImageInfo *image = NULL;
  if (_xmls.Size() == 1)
  {
    const CWimXml &xml = _xmls[0];
    if (xml.Images.Size() == 1)
      image = &xml.Images[0];
  }

  switch (propID)
  {
    case kpidPhySize:  prop = _phySize; break;
    case kpidSize: prop = _db.GetUnpackSize(); break;
    case kpidPackSize: prop = _db.GetPackSize(); break;
    
    case kpidCTime:
      if (_xmls.Size() == 1)
      {
        const CWimXml &xml = _xmls[0];
        int index = -1;
        FOR_VECTOR (i, xml.Images)
        {
          const CImageInfo &image2 = xml.Images[i];
          if (image2.CTimeDefined)
            if (index < 0 || ::CompareFileTime(&image2.CTime, &xml.Images[index].CTime) < 0)
              index = i;
        }
        if (index >= 0)
          prop = xml.Images[index].CTime;
      }
      break;

    case kpidMTime:
      if (_xmls.Size() == 1)
      {
        const CWimXml &xml = _xmls[0];
        int index = -1;
        FOR_VECTOR (i, xml.Images)
        {
          const CImageInfo &image2 = xml.Images[i];
          if (image2.MTimeDefined)
            if (index < 0 || ::CompareFileTime(&image2.MTime, &xml.Images[index].MTime) > 0)
              index = i;
        }
        if (index >= 0)
          prop = xml.Images[index].MTime;
      }
      break;

    case kpidComment:
      if (image)
      {
        if (_xmlInComments)
        {
          UString s;
          _xmls[0].ToUnicode(s);
          prop = s;
        }
        else if (image->NameDefined)
          prop = image->Name;
      }
      break;

    case kpidUnpackVer:
    {
      UInt32 ver1 = _version >> 16;
      UInt32 ver2 = (_version >> 8) & 0xFF;
      UInt32 ver3 = (_version) & 0xFF;

      char s[16];
      ConvertUInt32ToString(ver1, s);
      AString res = s;
      res += '.';
      ConvertUInt32ToString(ver2, s);
      res += s;
      if (ver3 != 0)
      {
        res += '.';
        ConvertUInt32ToString(ver3, s);
        res += s;
      }
      prop = res;
      break;
    }

    case kpidIsVolume:
      if (_xmls.Size() > 0)
      {
        UInt16 volIndex = _xmls[0].VolIndex;
        if (volIndex < _volumes.Size())
          prop = (_volumes[volIndex].Header.NumParts > 1);
      }
      break;
    case kpidVolume:
      if (_xmls.Size() > 0)
      {
        UInt16 volIndex = _xmls[0].VolIndex;
        if (volIndex < _volumes.Size())
          prop = (UInt32)_volumes[volIndex].Header.PartNumber;
      }
      break;
    case kpidNumVolumes: if (_volumes.Size() > 0) prop = (UInt32)(_volumes.Size() - 1); break;
    
    case kpidClusterSize:
      if (_xmls.Size() > 0)
      {
        UInt16 volIndex = _xmls[0].VolIndex;
        if (volIndex < _volumes.Size())
        {
          const CHeader &h = _volumes[volIndex].Header;
          prop = (UInt32)1 << h.ChunkSizeBits;
        }
      }
      break;

    case kpidName:
      if (_firstVolumeIndex >= 0)
      {
        const CHeader &h = _volumes[_firstVolumeIndex].Header;
        if (GetUi32(h.Guid) != 0)
        {
          char temp[16 * 2 + 4];
          int i;
          for (i = 0; i < 4; i++)
            ConvertByteToHex(h.Guid[i], temp + i * 2);
          temp[i * 2] = 0;
          AString s = temp;
          const char *ext = ".wim";
          if (h.NumParts != 1)
          {
            s += '_';
            if (h.PartNumber != 1)
            {
              char sz[16];
              ConvertUInt32ToString(h.PartNumber, sz);
              s += sz;
            }
            ext = ".swm";
          }
          s += ext;
          prop = s;
        }
      }
      break;

    case kpidExtension:
      if (_firstVolumeIndex >= 0)
      {
        const CHeader &h = _volumes[_firstVolumeIndex].Header;
        if (h.NumParts > 1)
        {
          AString s;
          if (h.PartNumber != 1)
          {
            char sz[16];
            ConvertUInt32ToString(h.PartNumber, sz);
            s = sz;
            s += '.';
          }
          s += "swm";
          prop = s;
        }
      }
      break;

    case kpidNumImages: prop = (UInt32)_db.Images.Size(); break;
    case kpidBootImage: if (_bootIndex != 0) prop = (UInt32)_bootIndex; break;
    
    case kpidMethod:
    {
      UInt32 methodUnknown = 0;
      UInt32 methodMask = 0;
      unsigned chunkSizeBits = 0;
      
      {
        FOR_VECTOR (i, _xmls)
        {
          const CHeader &header = _volumes[_xmls[i].VolIndex].Header;
          unsigned method = header.GetMethod();
          if (method < ARRAY_SIZE(k_Methods))
            methodMask |= ((UInt32)1 << method);
          else
            methodUnknown = method;
          if (chunkSizeBits < header.ChunkSizeBits)
            chunkSizeBits = header.ChunkSizeBits;
        }
      }

      AString res;

      bool numMethods = 0;
      for (unsigned i = 0; i < ARRAY_SIZE(k_Methods); i++)
      {
        if (methodMask & ((UInt32)1 << i))
        {
          res.Add_Space_if_NotEmpty();
          res += k_Methods[i];
          numMethods++;
        }
      }

      if (methodUnknown != 0)
      {
        char temp[32];
        ConvertUInt32ToString(methodUnknown, temp);
        res.Add_Space_if_NotEmpty();
        res += temp;
        numMethods++;
      }

      if (numMethods == 1 && chunkSizeBits != 0)
      {
        char temp[32];
        temp[0] = ':';
        ConvertUInt32ToString((UInt32)chunkSizeBits, temp + 1);
        res += temp;
      }

      prop = res;
      break;
    }
    
    case kpidIsTree: prop = true; break;
    case kpidIsAltStream: prop = _db.ThereAreAltStreams; break;
    case kpidIsAux: prop = true; break;
    // WIM uses special prefix to represent deleted items
    // case kpidIsDeleted: prop = _db.ThereAreDeletedStreams; break;
    case kpidINode: prop = true; break;

    case kpidErrorFlags:
    {
      UInt32 flags = 0;
      if (!_isArc) flags |= kpv_ErrorFlags_IsNotArc;
      if (_db.HeadersError) flags |= kpv_ErrorFlags_HeadersError;
      if (_unsupported) flags |= kpv_ErrorFlags_UnsupportedMethod;
      prop = flags;
      break;
    }

    case kpidWarning:
    {
      AString s;
      if (_xmlError)
        AddErrorMessage(s, "XML error");
      if (_db.RefCountError)
        AddErrorMessage(s, "Some files have incorrect reference count");
      if (!s.IsEmpty())
        prop = s;
      break;
    }

    case kpidReadOnly:
    {
      bool readOnly = !IsUpdateSupported();
      if (readOnly)
        prop = readOnly;
      break;
    }
  }

  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}

void GetFileTime(const Byte *p, NCOM::CPropVariant &prop)
{
  prop.vt = VT_FILETIME;
  prop.filetime.dwLowDateTime = Get32(p);
  prop.filetime.dwHighDateTime = Get32(p + 4);
}


static void MethodToProp(int method, int chunksSizeBits, NCOM::CPropVariant &prop)
{
  if (method >= 0)
  {
    char temp[32];
    
    if ((unsigned)method < ARRAY_SIZE(k_Methods))
      strcpy(temp, k_Methods[(unsigned)method]);
    else
      ConvertUInt32ToString((unsigned)method, temp);
    
    if (chunksSizeBits >= 0)
    {
      size_t pos = strlen(temp);
      temp[pos++] = ':';
      ConvertUInt32ToString((unsigned)chunksSizeBits, temp + pos);
    }
    
    prop = temp;
  }
}


STDMETHODIMP CHandler::GetProperty(UInt32 index, PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NCOM::CPropVariant prop;

  if (index < _db.SortedItems.Size())
  {
    unsigned realIndex = _db.SortedItems[index];
    const CItem &item = _db.Items[realIndex];
    const CStreamInfo *si = NULL;
    const CVolume *vol = NULL;
    if (item.StreamIndex >= 0)
    {
      si = &_db.DataStreams[item.StreamIndex];
      vol = &_volumes[si->PartNumber];
    }

    const CItem *mainItem = &item;
    if (item.IsAltStream)
      mainItem = &_db.Items[item.Parent];
    const Byte *metadata = NULL;
    if (mainItem->ImageIndex >= 0)
      metadata = _db.Images[mainItem->ImageIndex].Meta + mainItem->Offset;

    switch (propID)
    {
      case kpidPath:
        if (item.ImageIndex >= 0)
          _db.GetItemPath(realIndex, _showImageNumber, prop);
        else
        {
          char sz[16];
          ConvertUInt32ToString(item.StreamIndex, sz);
          AString s = sz;
          /*
          while (s.Len() < _nameLenForStreams)
            s = '0' + s;
          */
          /*
          if (si->Resource.IsFree())
            s = (AString)("[Free]" STRING_PATH_SEPARATOR) + sz;
          else
          */
          s = (AString)(FILES_DIR_NAME STRING_PATH_SEPARATOR) + sz;
          prop = s;
        }
        break;
      
      case kpidName:
        if (item.ImageIndex >= 0)
          _db.GetItemName(realIndex, prop);
        else
        {
          char sz[16];
          ConvertUInt32ToString(item.StreamIndex, sz);
          /*
          AString s = sz;
          while (s.Len() < _nameLenForStreams)
            s = '0' + s;
          */
          prop = sz;
        }
        break;

      case kpidShortName:
        if (item.ImageIndex >= 0 && !item.IsAltStream)
          _db.GetShortName(realIndex, prop);
        break;

      case kpidPackSize:
      {
        if (si)
        {
          if (!si->Resource.IsSolidSmall())
            prop = si->Resource.PackSize;
          else
          {
            if (si->Resource.SolidIndex >= 0)
            {
              const CSolid &ss = _db.Solids[(unsigned)si->Resource.SolidIndex];
              if (ss.FirstSmallStream == item.StreamIndex)
                prop = _db.DataStreams[ss.StreamIndex].Resource.PackSize;
            }
          }
        }
        else if (!item.IsDir)
          prop = (UInt64)0;

        break;
      }

      case kpidSize:
      {
        if (si)
        {
          if (si->Resource.IsSolid())
          {
            if (si->Resource.IsSolidBig())
            {
              if (si->Resource.SolidIndex >= 0)
              {
                const CSolid &ss = _db.Solids[(unsigned)si->Resource.SolidIndex];
                prop = ss.UnpackSize;
              }
            }
            else
              prop = si->Resource.PackSize;
          }
          else
            prop = si->Resource.UnpackSize;
        }
        else if (!item.IsDir)
          prop = (UInt64)0;

        break;
      }
      
      case kpidIsDir: prop = item.IsDir; break;
      case kpidIsAltStream: prop = item.IsAltStream; break;
      case kpidNumAltStreams:
      {
        if (!item.IsAltStream && mainItem->HasMetadata())
        {
          UInt32 dirRecordSize = _db.IsOldVersion ? kDirRecordSizeOld : kDirRecordSize;
          UInt32 numAltStreams = Get16(metadata + dirRecordSize - 6);
          if (numAltStreams != 0)
          {
            if (!item.IsDir)
              numAltStreams--;
            prop = numAltStreams;
          }
        }
        break;
      }

      case kpidAttrib:
        if (!item.IsAltStream && mainItem->ImageIndex >= 0)
        {
          /*
          if (fileNameLen == 0 && isDir && !item.HasStream())
            item.Attrib = 0x10; // some swm archives have system/hidden attributes for root
          */
          prop = (UInt32)Get32(metadata + 8);
        }
        break;
      case kpidCTime: if (mainItem->HasMetadata()) GetFileTime(metadata + (_db.IsOldVersion ? 0x18: 0x28), prop); break;
      case kpidATime: if (mainItem->HasMetadata()) GetFileTime(metadata + (_db.IsOldVersion ? 0x20: 0x30), prop); break;
      case kpidMTime: if (mainItem->HasMetadata()) GetFileTime(metadata + (_db.IsOldVersion ? 0x28: 0x38), prop); break;

      case kpidINode:
        if (mainItem->HasMetadata() && !_isOldVersion)
        {
          UInt32 attrib = (UInt32)Get32(metadata + 8);
          if ((attrib & FILE_ATTRIBUTE_REPARSE_POINT) == 0)
          {
            // we don't know about that field in OLD WIM format
            unsigned offset = 0x58; // (_db.IsOldVersion ? 0x30: 0x58);
            UInt64 val = Get64(metadata + offset);
            if (val != 0)
              prop = val;
          }
        }
        break;

      case kpidStreamId:
        if (item.StreamIndex >= 0)
          prop = (UInt32)item.StreamIndex;
        break;

      case kpidMethod:
          if (si)
          {
            const CResource &r = si->Resource;
            if (r.IsSolid())
            {
              if (r.SolidIndex >= 0)
              {
                CSolid &ss = _db.Solids[r.SolidIndex];
                MethodToProp(ss.Method, ss.ChunkSizeBits, prop);
              }
            }
            else
            {
              int method = 0;
              int chunkSizeBits = -1;
              if (r.IsCompressed())
              {
                method = vol->Header.GetMethod();
                chunkSizeBits = vol->Header.ChunkSizeBits;
              }
              MethodToProp(method, chunkSizeBits, prop);
            }
          }
          break;

      case kpidSolid: if (si) prop = si->Resource.IsSolid(); break;
      case kpidLinks: if (si) prop = (UInt32)si->RefCount; break;
      #ifdef WIM_DETAILS
      case kpidVolume: if (si) prop = (UInt32)si->PartNumber; break;
      case kpidOffset: if (si)  prop = (UInt64)si->Resource.Offset; break;
      #endif
    }
  }
  else
  {
    index -= _db.SortedItems.Size();
    if (index < _numXmlItems)
    {
      switch (propID)
      {
        case kpidPath:
        case kpidName: prop = _xmls[index].FileName; break;
        case kpidIsDir: prop = false; break;
        case kpidPackSize:
        case kpidSize: prop = (UInt64)_xmls[index].Data.Size(); break;
        case kpidMethod: /* prop = k_Method_Copy; */ break;
      }
    }
    else
    {
      index -= _numXmlItems;
      switch (propID)
      {
        case kpidPath:
        case kpidName:
          if (index < (UInt32)_db.VirtualRoots.Size())
            prop = _db.Images[_db.VirtualRoots[index]].RootName;
          else
            prop = FILES_DIR_NAME;
          break;
        case kpidIsDir: prop = true; break;
        case kpidIsAux: prop = true; break;
      }
    }
  }
  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}

STDMETHODIMP CHandler::GetRootProp(PROPID propID, PROPVARIANT *value)
{
  // COM_TRY_BEGIN
  NCOM::CPropVariant prop;
  if (_db.Images.Size() != 0 && _db.NumExcludededItems != 0)
  {
    const CImage &image = _db.Images[_db.IndexOfUserImage];
    const CItem &item = _db.Items[image.StartItem];
    if (!item.IsDir || item.ImageIndex != _db.IndexOfUserImage)
      return E_FAIL;
    const Byte *metadata = image.Meta + item.Offset;

    switch (propID)
    {
      case kpidIsDir: prop = true; break;
      case kpidAttrib: prop = (UInt32)Get32(metadata + 8); break;
      case kpidCTime: GetFileTime(metadata + (_db.IsOldVersion ? 0x18: 0x28), prop); break;
      case kpidATime: GetFileTime(metadata + (_db.IsOldVersion ? 0x20: 0x30), prop); break;
      case kpidMTime: GetFileTime(metadata + (_db.IsOldVersion ? 0x28: 0x38), prop); break;
    }
  }
  prop.Detach(value);
  return S_OK;
  // COM_TRY_END
}

HRESULT CHandler::GetSecurity(UInt32 realIndex, const void **data, UInt32 *dataSize, UInt32 *propType)
{
  const CItem &item = _db.Items[realIndex];
  if (item.IsAltStream || item.ImageIndex < 0)
    return S_OK;
  const CImage &image = _db.Images[item.ImageIndex];
  const Byte *metadata = image.Meta + item.Offset;
  UInt32 securityId = Get32(metadata + 0xC);
  if (securityId == (UInt32)(Int32)-1)
    return S_OK;
  if (securityId >= (UInt32)image.SecurOffsets.Size())
    return E_FAIL;
  UInt32 offs = image.SecurOffsets[securityId];
  UInt32 len = image.SecurOffsets[securityId + 1] - offs;
  const CByteBuffer &buf = image.Meta;
  if (offs <= buf.Size() && buf.Size() - offs >= len)
  {
    *data = buf + offs;
    *dataSize = len;
    *propType = NPropDataType::kRaw;
  }
  return S_OK;
}

STDMETHODIMP CHandler::GetRootRawProp(PROPID propID, const void **data, UInt32 *dataSize, UInt32 *propType)
{
  *data = 0;
  *dataSize = 0;
  *propType = 0;
  if (propID == kpidNtSecure && _db.Images.Size() != 0 && _db.NumExcludededItems != 0)
  {
    const CImage &image = _db.Images[_db.IndexOfUserImage];
    const CItem &item = _db.Items[image.StartItem];
    if (!item.IsDir || item.ImageIndex != _db.IndexOfUserImage)
      return E_FAIL;
    return GetSecurity(image.StartItem, data, dataSize, propType);
  }
  return S_OK;
}

static const Byte kRawProps[] =
{
  kpidSha1,
  kpidNtReparse,
  kpidNtSecure
};


STDMETHODIMP CHandler::GetNumRawProps(UInt32 *numProps)
{
  *numProps = ARRAY_SIZE(kRawProps);
  return S_OK;
}

STDMETHODIMP CHandler::GetRawPropInfo(UInt32 index, BSTR *name, PROPID *propID)
{
  *propID = kRawProps[index];
  *name = 0;
  return S_OK;
}

STDMETHODIMP CHandler::GetParent(UInt32 index, UInt32 *parent, UInt32 *parentType)
{
  *parentType = NParentType::kDir;
  *parent = (UInt32)(Int32)-1;
  if (index >= _db.SortedItems.Size())
    return S_OK;

  const CItem &item = _db.Items[_db.SortedItems[index]];
  
  if (item.ImageIndex >= 0)
  {
    *parentType = item.IsAltStream ? NParentType::kAltStream : NParentType::kDir;
    if (item.Parent >= 0)
    {
      if (_db.ExludedItem != item.Parent)
        *parent = _db.Items[item.Parent].IndexInSorted;
    }
    else
    {
      CImage &image = _db.Images[item.ImageIndex];
      if (image.VirtualRootIndex >= 0)
        *parent = _db.SortedItems.Size() + _numXmlItems + image.VirtualRootIndex;
    }
  }
  else
    *parent = _db.SortedItems.Size() + _numXmlItems + _db.VirtualRoots.Size();
  return S_OK;
}

STDMETHODIMP CHandler::GetRawProp(UInt32 index, PROPID propID, const void **data, UInt32 *dataSize, UInt32 *propType)
{
  *data = NULL;
  *dataSize = 0;
  *propType = 0;

  if (propID == kpidName)
  {
    if (index < _db.SortedItems.Size())
    {
      const CItem &item = _db.Items[_db.SortedItems[index]];
      if (item.ImageIndex < 0)
        return S_OK;
      const CImage &image = _db.Images[item.ImageIndex];
      *propType = NPropDataType::kUtf16z;
      if (image.NumEmptyRootItems != 0 && item.Parent < 0)
      {
        const CByteBuffer &buf = _db.Images[item.ImageIndex].RootNameBuf;
        *data = (void *)(const Byte *)buf;
        *dataSize = (UInt32)buf.Size();
        return S_OK;
      }
      const Byte *meta = image.Meta + item.Offset +
          (item.IsAltStream ?
          (_isOldVersion ? 0x10 : 0x24) :
          (_isOldVersion ? kDirRecordSizeOld - 2 : kDirRecordSize - 2));
      *data = (const void *)(meta + 2);
      *dataSize = (UInt32)Get16(meta) + 2;
      return S_OK;
    }
    {
      index -= _db.SortedItems.Size();
      if (index < _numXmlItems)
        return S_OK;
      index -= _numXmlItems;
      if (index >= (UInt32)_db.VirtualRoots.Size())
        return S_OK;
      const CByteBuffer &buf = _db.Images[_db.VirtualRoots[index]].RootNameBuf;
      *data = (void *)(const Byte *)buf;
      *dataSize = (UInt32)buf.Size();
      *propType = NPropDataType::kUtf16z;
      return S_OK;
    }
  }

  if (index >= _db.SortedItems.Size())
    return S_OK;

  unsigned index2 = _db.SortedItems[index];
  
  if (propID == kpidNtSecure)
  {
    return GetSecurity(index2, data, dataSize, propType);
  }
  
  const CItem &item = _db.Items[index2];
  if (propID == kpidSha1)
  {
    if (item.StreamIndex >= 0)
      *data = _db.DataStreams[item.StreamIndex].Hash;
    else
    {
      if (_isOldVersion)
        return S_OK;
      const Byte *sha1 = _db.Images[item.ImageIndex].Meta + item.Offset + (item.IsAltStream ? 0x10 : 0x40);
      if (IsEmptySha(sha1))
        return S_OK;
      *data = sha1;
    }
    *dataSize = kHashSize;
    *propType = NPropDataType::kRaw;
    return S_OK;
  }
  
  if (propID == kpidNtReparse && !_isOldVersion)
  {
    // we don't know about Reparse field in OLD WIM format

    if (item.StreamIndex < 0)
      return S_OK;
    if (index2 >= _db.ItemToReparse.Size())
      return S_OK;
    int reparseIndex = _db.ItemToReparse[index2];
    if (reparseIndex < 0)
      return S_OK;
    const CByteBuffer &buf = _db.ReparseItems[reparseIndex];
    if (buf.Size() == 0)
      return S_OK;
    *data = buf;
    *dataSize = (UInt32)buf.Size();
    *propType = NPropDataType::kRaw;
    return S_OK;
  }

  return S_OK;
}

class CVolumeName
{
  UString _before;
  UString _after;
public:
  void InitName(const UString &name)
  {
    int dotPos = name.ReverseFind_Dot();
    if (dotPos < 0)
      dotPos = name.Len();
    _before = name.Left(dotPos);
    _after = name.Ptr(dotPos);
  }

  UString GetNextName(UInt32 index) const
  {
    wchar_t s[16];
    ConvertUInt32ToString(index, s);
    return _before + (UString)s + _after;
  }
};

STDMETHODIMP CHandler::Open(IInStream *inStream, const UInt64 *, IArchiveOpenCallback *callback)
{
  COM_TRY_BEGIN

  Close();
  {
    CMyComPtr<IArchiveOpenVolumeCallback> openVolumeCallback;
    
    CVolumeName seqName;
    if (callback)
      callback->QueryInterface(IID_IArchiveOpenVolumeCallback, (void **)&openVolumeCallback);

    UInt32 numVolumes = 1;
    
    for (UInt32 i = 1; i <= numVolumes; i++)
    {
      CMyComPtr<IInStream> curStream;
      
      if (i == 1)
        curStream = inStream;
      else
      {
        UString fullName = seqName.GetNextName(i);
        HRESULT result = openVolumeCallback->GetStream(fullName, &curStream);
        if (result == S_FALSE)
          continue;
        if (result != S_OK)
          return result;
        if (!curStream)
          break;
      }
      
      CHeader header;
      HRESULT res = NWim::ReadHeader(curStream, header, _phySize);
      
      if (res != S_OK)
      {
        if (i != 1 && res == S_FALSE)
          continue;
        return res;
      }
      
      _isArc = true;
      _bootIndex = header.BootIndex;
      _version = header.Version;
      _isOldVersion = header.IsOldVersion();
      if (_firstVolumeIndex >= 0)
        if (!header.AreFromOnArchive(_volumes[_firstVolumeIndex].Header))
          break;
      if (_volumes.Size() > header.PartNumber && _volumes[header.PartNumber].Stream)
        break;
      CWimXml xml;
      xml.VolIndex = header.PartNumber;
      res = _db.OpenXml(curStream, header, xml.Data);
      
      if (res == S_OK)
      {
        if (!xml.Parse())
          _xmlError = true;

        if (xml.IsEncrypted)
        {
          _unsupported = true;
          return S_FALSE;
        }

        UInt64 totalFiles = xml.GetTotalFilesAndDirs() + xml.Images.Size();
        totalFiles += 16 + xml.Images.Size() * 4; // we reserve some additional items
        if (totalFiles >= ((UInt32)1 << 30))
          totalFiles = 0;
        res = _db.Open(curStream, header, (unsigned)totalFiles, callback);
      }
      
      if (res != S_OK)
      {
        if (i != 1 && res == S_FALSE)
          continue;
        return res;
      }
      
      while (_volumes.Size() <= header.PartNumber)
        _volumes.AddNew();
      CVolume &volume = _volumes[header.PartNumber];
      volume.Header = header;
      volume.Stream = curStream;
      
      _firstVolumeIndex = header.PartNumber;
      
      if (_xmls.IsEmpty() || xml.Data != _xmls[0].Data)
      {
        char sz[16];
        ConvertUInt32ToString(xml.VolIndex, sz);
        xml.FileName = L'[';
        xml.FileName.AddAscii(sz);
        xml.FileName.AddAscii("].xml");
        _xmls.Add(xml);
      }
      
      if (i == 1)
      {
        if (header.PartNumber != 1)
          break;
        if (!openVolumeCallback)
          break;
        numVolumes = header.NumParts;
        {
          NCOM::CPropVariant prop;
          RINOK(openVolumeCallback->GetProperty(kpidName, &prop));
          if (prop.vt != VT_BSTR)
            break;
          seqName.InitName(prop.bstrVal);
        }
      }
    }

    RINOK(_db.FillAndCheck(_volumes));
    int defaultImageIndex = (int)_defaultImageNumber - 1;
    
    bool showImageNumber = (_db.Images.Size() != 1 && defaultImageIndex < 0);
    if (!showImageNumber && _set_use_ShowImageNumber)
      showImageNumber = _set_showImageNumber;

    if (!showImageNumber && _keepMode_ShowImageNumber)
      showImageNumber = true;

    _showImageNumber = showImageNumber;

    RINOK(_db.GenerateSortedItems(defaultImageIndex, showImageNumber));
    RINOK(_db.ExtractReparseStreams(_volumes, callback));

    /*
    wchar_t sz[16];
    ConvertUInt32ToString(_db.DataStreams.Size(), sz);
    _nameLenForStreams = MyStringLen(sz);
    */

    _xmlInComments = !_showImageNumber;
    _numXmlItems = (_xmlInComments ? 0 : _xmls.Size());
    _numIgnoreItems = _db.ThereAreDeletedStreams ? 1 : 0;
  }
  return S_OK;
  COM_TRY_END
}


STDMETHODIMP CHandler::Close()
{
  _firstVolumeIndex = -1;
  _phySize = 0;
  _db.Clear();
  _volumes.Clear();
  _xmls.Clear();
  // _nameLenForStreams = 0;
  _xmlInComments = false;
  _numXmlItems = 0;
  _numIgnoreItems = 0;
  _xmlError = false;
  _isArc = false;
  _unsupported = false;
  return S_OK;
}


STDMETHODIMP CHandler::Extract(const UInt32 *indices, UInt32 numItems,
    Int32 testMode, IArchiveExtractCallback *extractCallback)
{
  COM_TRY_BEGIN
  bool allFilesMode = (numItems == (UInt32)(Int32)-1);

  if (allFilesMode)
    numItems = _db.SortedItems.Size() + _numXmlItems + _db.VirtualRoots.Size() + _numIgnoreItems;
  if (numItems == 0)
    return S_OK;

  UInt32 i;
  UInt64 totalSize = 0;

  for (i = 0; i < numItems; i++)
  {
    UInt32 index = allFilesMode ? i : indices[i];
    if (index < _db.SortedItems.Size())
    {
      int streamIndex = _db.Items[_db.SortedItems[index]].StreamIndex;
      if (streamIndex >= 0)
      {
        const CStreamInfo &si = _db.DataStreams[streamIndex];
        totalSize += _db.Get_UnpackSize_of_Resource(si.Resource);
      }
    }
    else
    {
      index -= _db.SortedItems.Size();
      if (index < (UInt32)_numXmlItems)
        totalSize += _xmls[index].Data.Size();
    }
  }

  RINOK(extractCallback->SetTotal(totalSize));

  UInt64 currentTotalUnPacked = 0;
  UInt64 currentItemUnPacked;
  
  int prevSuccessStreamIndex = -1;

  CUnpacker unpacker;

  CLocalProgress *lps = new CLocalProgress;
  CMyComPtr<ICompressProgressInfo> progress = lps;
  lps->Init(extractCallback, false);

  for (i = 0;; i++,
      currentTotalUnPacked += currentItemUnPacked)
  {
    currentItemUnPacked = 0;

    lps->InSize = unpacker.TotalPacked;
    lps->OutSize = currentTotalUnPacked;

    RINOK(lps->SetCur());

    if (i >= numItems)
      break;

    UInt32 index = allFilesMode ? i : indices[i];
    Int32 askMode = testMode ?
        NExtract::NAskMode::kTest :
        NExtract::NAskMode::kExtract;

    CMyComPtr<ISequentialOutStream> realOutStream;
    RINOK(extractCallback->GetStream(index, &realOutStream, askMode));

    if (index >= _db.SortedItems.Size())
    {
      if (!testMode && !realOutStream)
        continue;
      RINOK(extractCallback->PrepareOperation(askMode));
      index -= _db.SortedItems.Size();
      if (index < (UInt32)_numXmlItems)
      {
        const CByteBuffer &data = _xmls[index].Data;
        currentItemUnPacked = data.Size();
        if (realOutStream)
        {
          RINOK(WriteStream(realOutStream, (const Byte *)data, data.Size()));
          realOutStream.Release();
        }
      }
      RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK));
      continue;
    }

    const CItem &item = _db.Items[_db.SortedItems[index]];
    int streamIndex = item.StreamIndex;
    if (streamIndex < 0)
    {
      if (!item.IsDir)
        if (!testMode && !realOutStream)
          continue;
      RINOK(extractCallback->PrepareOperation(askMode));
      realOutStream.Release();
      RINOK(extractCallback->SetOperationResult(!item.IsDir && _db.ItemHasStream(item) ?
          NExtract::NOperationResult::kDataError :
          NExtract::NOperationResult::kOK));
      continue;
    }

    const CStreamInfo &si = _db.DataStreams[streamIndex];
    currentItemUnPacked = _db.Get_UnpackSize_of_Resource(si.Resource);
    // currentItemPacked = _db.Get_PackSize_of_Resource(streamIndex);

    if (!testMode && !realOutStream)
      continue;
    RINOK(extractCallback->PrepareOperation(askMode));
    Int32 opRes = NExtract::NOperationResult::kOK;
    
    if (streamIndex != prevSuccessStreamIndex || realOutStream)
    {
      Byte digest[kHashSize];
      const CVolume &vol = _volumes[si.PartNumber];
      bool needDigest = !si.IsEmptyHash();
      
      HRESULT res = unpacker.Unpack(vol.Stream, si.Resource, vol.Header, &_db,
          realOutStream, progress, needDigest ? digest : NULL);
      
      if (res == S_OK)
      {
        if (!needDigest || memcmp(digest, si.Hash, kHashSize) == 0)
          prevSuccessStreamIndex = streamIndex;
        else
          opRes = NExtract::NOperationResult::kCRCError;
      }
      else if (res == S_FALSE)
        opRes = NExtract::NOperationResult::kDataError;
      else if (res == E_NOTIMPL)
        opRes = NExtract::NOperationResult::kUnsupportedMethod;
      else
        return res;
    }
    
    realOutStream.Release();
    RINOK(extractCallback->SetOperationResult(opRes));
  }
  
  return S_OK;
  COM_TRY_END
}


STDMETHODIMP CHandler::GetNumberOfItems(UInt32 *numItems)
{
  *numItems = _db.SortedItems.Size() +
      _numXmlItems +
      _db.VirtualRoots.Size() +
      _numIgnoreItems;
  return S_OK;
}

CHandler::CHandler()
{
  _keepMode_ShowImageNumber = false;
  InitDefaults();
  _xmlError = false;
}

STDMETHODIMP CHandler::SetProperties(const wchar_t * const *names, const PROPVARIANT *values, UInt32 numProps)
{
  InitDefaults();

  for (UInt32 i = 0; i < numProps; i++)
  {
    UString name = names[i];
    name.MakeLower_Ascii();
    if (name.IsEmpty())
      return E_INVALIDARG;

    const PROPVARIANT &prop = values[i];

    if (name[0] == L'x')
    {
      // some clients write 'x' property. So we support it
      UInt32 level = 0;
      RINOK(ParsePropToUInt32(name.Ptr(1), prop, level));
    }
    else if (name.IsEqualTo("is"))
    {
      RINOK(PROPVARIANT_to_bool(prop, _set_showImageNumber));
      _set_use_ShowImageNumber = true;
    }
    else if (name.IsEqualTo("im"))
    {
      UInt32 image = 9;
      RINOK(ParsePropToUInt32(L"", prop, image));
      _defaultImageNumber = image;
    }
    else
      return E_INVALIDARG;
  }
  return S_OK;
}

STDMETHODIMP CHandler::KeepModeForNextOpen()
{
  _keepMode_ShowImageNumber = _showImageNumber;
  return S_OK;
}

}}
// WimHandler.h

#ifndef __ARCHIVE_WIM_HANDLER_H
#define __ARCHIVE_WIM_HANDLER_H

#include "../../../Common/MyCom.h"

#include "WimIn.h"

namespace NArchive {
namespace NWim {

static const Int32 kNumImagesMaxUpdate = (1 << 10);

class CHandler:
  public IInArchive,
  public IArchiveGetRawProps,
  public IArchiveGetRootProps,
  public IArchiveKeepModeForNextOpen,
  public ISetProperties,
  public IOutArchive,
  public CMyUnknownImp
{
  CDatabase _db;
  UInt32 _version;
  bool _isOldVersion;
  UInt32 _bootIndex;

  CObjectVector<CVolume> _volumes;
  CObjectVector<CWimXml> _xmls;
  // unsigned _nameLenForStreams;
  bool _xmlInComments;
  
  unsigned _numXmlItems;
  unsigned _numIgnoreItems;

  bool _xmlError;
  bool _isArc;
  bool _unsupported;

  bool _set_use_ShowImageNumber;
  bool _set_showImageNumber;
  int _defaultImageNumber;

  bool _showImageNumber;

  bool _keepMode_ShowImageNumber;

  UInt64 _phySize;
  int _firstVolumeIndex;

  void InitDefaults()
  {
    _set_use_ShowImageNumber = false;
    _set_showImageNumber = false;
    _defaultImageNumber = -1;
  }

  bool IsUpdateSupported() const
  {
    if (ThereIsError()) return false;
    if (_db.Images.Size() > kNumImagesMaxUpdate) return false;

    // Solid format is complicated. So we disable updating now.
    if (!_db.Solids.IsEmpty()) return false;

    if (_volumes.Size() == 0)
      return true;
    
    if (_volumes.Size() != 2) return false;
    if (_volumes[0].Stream) return false;
    if (_version != k_Version_NonSolid
        // && _version != k_Version_Solid
        ) return false;
    
    return true;
  }

  bool ThereIsError() const { return _xmlError || _db.ThereIsError(); }
  HRESULT GetSecurity(UInt32 realIndex, const void **data, UInt32 *dataSize, UInt32 *propType);

  HRESULT GetOutProperty(IArchiveUpdateCallback *callback, UInt32 callbackIndex, Int32 arcIndex, PROPID propID, PROPVARIANT *value);
  HRESULT        GetTime(IArchiveUpdateCallback *callback, UInt32 callbackIndex, Int32 arcIndex, PROPID propID, FILETIME &ft);
public:
  CHandler();
  MY_UNKNOWN_IMP6(
      IInArchive,
      IArchiveGetRawProps,
      IArchiveGetRootProps,
      IArchiveKeepModeForNextOpen,
      ISetProperties,
      IOutArchive)
  INTERFACE_IInArchive(;)
  INTERFACE_IArchiveGetRawProps(;)
  INTERFACE_IArchiveGetRootProps(;)
  STDMETHOD(SetProperties)(const wchar_t * const *names, const PROPVARIANT *values, UInt32 numProps);
  STDMETHOD(KeepModeForNextOpen)();
  INTERFACE_IOutArchive(;)
};

}}

#endif
// WimHandlerOut.cpp

#include "StdAfx.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/IntToString.h"
#include "../../../Common/StringToInt.h"
#include "../../../Common/UTFConvert.h"
#include "../../../Common/Wildcard.h"

#include "../../../Windows/PropVariant.h"
#include "../../../Windows/TimeUtils.h"

#include "../../Common/LimitedStreams.h"
#include "../../Common/ProgressUtils.h"
#include "../../Common/StreamUtils.h"
#include "../../Common/UniqBlocks.h"

#include "../../Crypto/RandGen.h"
#include "../../Crypto/Sha1Cls.h"

#include "WimHandler.h"

using namespace NWindows;

namespace NArchive {
namespace NWim {

static int AddUniqHash(const CStreamInfo *streams, CUIntVector &sorted, const Byte *h, int streamIndexForInsert)
{
  unsigned left = 0, right = sorted.Size();
  while (left != right)
  {
    unsigned mid = (left + right) / 2;
    unsigned index = sorted[mid];
    const Byte *hash2 = streams[index].Hash;
    
    unsigned i;
    for (i = 0; i < kHashSize; i++)
      if (h[i] != hash2[i])
        break;
    
    if (i == kHashSize)
      return index;
  
    if (h[i] < hash2[i])
      right = mid;
    else
      left = mid + 1;
  }

  if (streamIndexForInsert >= 0)
    sorted.Insert(left, streamIndexForInsert);
 
  return -1;
}


struct CAltStream
{
  int UpdateIndex;
  int HashIndex;
  UInt64 Size;
  UString Name;
  bool Skip;

  CAltStream(): UpdateIndex(-1), HashIndex(-1), Skip(false) {}
};


struct CMetaItem
{
  int UpdateIndex;
  int HashIndex;
  
  UInt64 Size;
  FILETIME CTime;
  FILETIME ATime;
  FILETIME MTime;
  UInt32 Attrib;
  UInt64 FileID;
  UInt64 VolID;

  UString Name;
  UString ShortName;

  int SecurityId;       // -1: means no secutity ID
  bool IsDir;
  bool Skip;
  unsigned NumSkipAltStreams;
  CObjectVector<CAltStream> AltStreams;

  CByteBuffer Reparse;

  unsigned GetNumAltStreams() const { return AltStreams.Size() - NumSkipAltStreams; }
  CMetaItem(): UpdateIndex(-1), HashIndex(-1), SecurityId(-1),
      FileID(0), VolID(0),
      Skip(false), NumSkipAltStreams(0) {}
};


static int Compare_HardLink_MetaItems(const CMetaItem &a1, const CMetaItem &a2)
{
  if (a1.VolID < a2.VolID) return -1;
  if (a1.VolID > a2.VolID) return 1;
  if (a1.FileID < a2.FileID) return -1;
  if (a1.FileID > a2.FileID) return 1;
  if (a1.Size < a2.Size) return -1;
  if (a1.Size > a2.Size) return 1;
  return ::CompareFileTime(&a1.MTime, &a2.MTime);
}


static int AddToHardLinkList(const CObjectVector<CMetaItem> &metaItems, unsigned indexOfItem, CUIntVector &indexes)
{
  const CMetaItem &mi = metaItems[indexOfItem];
  unsigned left = 0, right = indexes.Size();
  while (left != right)
  {
    unsigned mid = (left + right) / 2;
    unsigned index = indexes[mid];
    int comp = Compare_HardLink_MetaItems(mi, metaItems[index]);
    if (comp == 0)
      return index;
    if (comp < 0)
      right = mid;
    else
      left = mid + 1;
  }
  indexes.Insert(left, indexOfItem);
  return -1;
}


struct CUpdateItem
{
  unsigned CallbackIndex; // index in callback
  
  int MetaIndex;          // index in in MetaItems[]
  
  int AltStreamIndex;     // index in CMetaItem::AltStreams vector
                          // -1: if not alt stream?
  
  int InArcIndex;         // >= 0, if we use OLD Data
                          //   -1, if we use NEW Data
 
  CUpdateItem(): MetaIndex(-1), AltStreamIndex(-1), InArcIndex(-1) {}
};


struct CDir
{
  int MetaIndex;
  CObjectVector<CDir> Dirs;
  CUIntVector Files; // indexes in MetaItems[]

  CDir(): MetaIndex(-1) {}
  unsigned GetNumDirs() const;
  unsigned GetNumFiles() const;
  UInt64 GetTotalSize(const CObjectVector<CMetaItem> &metaItems) const;
  bool FindDir(const CObjectVector<CMetaItem> &items, const UString &name, unsigned &index);
};

/* imagex counts Junctions as files (not as dirs).
   We suppose that it's not correct */

unsigned CDir::GetNumDirs() const
{
  unsigned num = Dirs.Size();
  FOR_VECTOR (i, Dirs)
    num += Dirs[i].GetNumDirs();
  return num;
}

unsigned CDir::GetNumFiles() const
{
  unsigned num = Files.Size();
  FOR_VECTOR (i, Dirs)
    num += Dirs[i].GetNumFiles();
  return num;
}

UInt64 CDir::GetTotalSize(const CObjectVector<CMetaItem> &metaItems) const
{
  UInt64 sum = 0;
  unsigned i;
  for (i = 0; i < Files.Size(); i++)
    sum += metaItems[Files[i]].Size;
  for (i = 0; i < Dirs.Size(); i++)
    sum += Dirs[i].GetTotalSize(metaItems);
  return sum;
}

bool CDir::FindDir(const CObjectVector<CMetaItem> &items, const UString &name, unsigned &index)
{
  unsigned left = 0, right = Dirs.Size();
  while (left != right)
  {
    unsigned mid = (left + right) / 2;
    int comp = CompareFileNames(name, items[Dirs[mid].MetaIndex].Name);
    if (comp == 0)
    {
      index = mid;
      return true;
    }
    if (comp < 0)
      right = mid;
    else
      left = mid + 1;
  }
  index = left;
  return false;
}


STDMETHODIMP CHandler::GetFileTimeType(UInt32 *type)
{
  *type = NFileTimeType::kWindows;
  return S_OK;
}


HRESULT CHandler::GetOutProperty(IArchiveUpdateCallback *callback, UInt32 callbackIndex, Int32 arcIndex, PROPID propID, PROPVARIANT *value)
{
  if (arcIndex >= 0)
    return GetProperty(arcIndex, propID, value);
  return callback->GetProperty(callbackIndex, propID, value);
}


HRESULT CHandler::GetTime(IArchiveUpdateCallback *callback, UInt32 callbackIndex, Int32 arcIndex, PROPID propID, FILETIME &ft)
{
  ft.dwLowDateTime = ft.dwHighDateTime = 0;
  NCOM::CPropVariant prop;
  RINOK(GetOutProperty(callback, callbackIndex, arcIndex, propID, &prop));
  if (prop.vt == VT_FILETIME)
    ft = prop.filetime;
  else if (prop.vt != VT_EMPTY)
    return E_INVALIDARG;
  return S_OK;
}


static HRESULT GetRootTime(
    IArchiveGetRootProps *callback,
    IArchiveGetRootProps *arcRoot,
    PROPID propID, FILETIME &ft)
{
  NCOM::CPropVariant prop;
  if (callback)
  {
    RINOK(callback->GetRootProp(propID, &prop));
    if (prop.vt == VT_FILETIME)
    {
      ft = prop.filetime;
      return S_OK;
    }
    if (prop.vt != VT_EMPTY)
      return E_INVALIDARG;
  }
  if (arcRoot)
  {
    RINOK(arcRoot->GetRootProp(propID, &prop));
    if (prop.vt == VT_FILETIME)
    {
      ft = prop.filetime;
      return S_OK;
    }
    if (prop.vt != VT_EMPTY)
      return E_INVALIDARG;
  }
  return S_OK;
}

#define Set16(p, d) SetUi16(p, d)
#define Set32(p, d) SetUi32(p, d)
#define Set64(p, d) SetUi64(p, d)

void CResource::WriteTo(Byte *p) const
{
  Set64(p, PackSize);
  p[7] = Flags;
  Set64(p + 8, Offset);
  Set64(p + 16, UnpackSize);
}


void CHeader::WriteTo(Byte *p) const
{
  memcpy(p, kSignature, kSignatureSize);
  Set32(p + 8, kHeaderSizeMax);
  Set32(p + 0xC, Version);
  Set32(p + 0x10, Flags);
  Set32(p + 0x14, ChunkSize);
  memcpy(p + 0x18, Guid, 16);
  Set16(p + 0x28, PartNumber);
  Set16(p + 0x2A, NumParts);
  Set32(p + 0x2C, NumImages);
  OffsetResource.WriteTo(p + 0x30);
  XmlResource.WriteTo(p + 0x48);
  MetadataResource.WriteTo(p + 0x60);
  IntegrityResource.WriteTo(p + 0x7C);
  Set32(p + 0x78, BootIndex);
  memset(p + 0x94, 0, 60);
}


void CStreamInfo::WriteTo(Byte *p) const
{
  Resource.WriteTo(p);
  Set16(p + 0x18, PartNumber);
  Set32(p + 0x1A, RefCount);
  memcpy(p + 0x1E, Hash, kHashSize);
}


class CInStreamWithSha1:
  public ISequentialInStream,
  public CMyUnknownImp
{
  CMyComPtr<ISequentialInStream> _stream;
  UInt64 _size;
  NCrypto::NSha1::CContext _sha;
public:
  MY_UNKNOWN_IMP1(IInStream)
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);

  void SetStream(ISequentialInStream *stream) { _stream = stream;  }
  void Init()
  {
    _size = 0;
    _sha.Init();
  }
  void ReleaseStream() { _stream.Release(); }
  UInt64 GetSize() const { return _size; }
  void Final(Byte *digest) { _sha.Final(digest); }
};

STDMETHODIMP CInStreamWithSha1::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  UInt32 realProcessedSize;
  HRESULT result = _stream->Read(data, size, &realProcessedSize);
  _size += realProcessedSize;
  _sha.Update((const Byte *)data, realProcessedSize);
  if (processedSize)
    *processedSize = realProcessedSize;
  return result;
}


static void SetFileTimeToMem(Byte *p, const FILETIME &ft)
{
  Set32(p, ft.dwLowDateTime);
  Set32(p + 4, ft.dwHighDateTime);
}

static size_t WriteItem_Dummy(const CMetaItem &item)
{
  if (item.Skip)
    return 0;
  unsigned fileNameLen = item.Name.Len() * 2;
  // we write fileNameLen + 2 + 2 to be same as original WIM.
  unsigned fileNameLen2 = (fileNameLen == 0 ? 0 : fileNameLen + 2);

  unsigned shortNameLen = item.ShortName.Len() * 2;
  unsigned shortNameLen2 = (shortNameLen == 0 ? 2 : shortNameLen + 4);

  size_t totalLen = ((kDirRecordSize + fileNameLen2 + shortNameLen2 + 6) & ~7);
  if (item.GetNumAltStreams() != 0)
  {
    if (!item.IsDir)
    {
      UInt32 curLen = (((0x26 + 0) + 6) & ~7);
      totalLen += curLen;
    }
    FOR_VECTOR (i, item.AltStreams)
    {
      const CAltStream &ss = item.AltStreams[i];
      if (ss.Skip)
        continue;
      fileNameLen = ss.Name.Len() * 2;
      fileNameLen2 = (fileNameLen == 0 ? 0 : fileNameLen + 2 + 2);
      UInt32 curLen = (((0x26 + fileNameLen2) + 6) & ~7);
      totalLen += curLen;
    }
  }
  return totalLen;
}


static size_t WriteItem(const CStreamInfo *streams, const CMetaItem &item, Byte *p)
{
  if (item.Skip)
    return 0;
  unsigned fileNameLen = item.Name.Len() * 2;
  unsigned fileNameLen2 = (fileNameLen == 0 ? 0 : fileNameLen + 2);
  unsigned shortNameLen = item.ShortName.Len() * 2;
  unsigned shortNameLen2 = (shortNameLen == 0 ? 2 : shortNameLen + 4);

  size_t totalLen = ((kDirRecordSize + fileNameLen2 + shortNameLen2 + 6) & ~7);
  
  memset(p, 0, totalLen);
  Set64(p, totalLen);
  Set64(p + 8, item.Attrib);
  Set32(p + 0xC, (Int32)item.SecurityId);
  SetFileTimeToMem(p + 0x28, item.CTime);
  SetFileTimeToMem(p + 0x30, item.ATime);
  SetFileTimeToMem(p + 0x38, item.MTime);
  
  /* WIM format probably doesn't support hard links to symbolic links.
     In these cases it just stores symbolic links (REPARSE TAGS).
     Check it in new versions of WIM software form MS !!!
     We also follow that scheme */

  if (item.Reparse.Size() != 0)
  {
    UInt32 tag = GetUi32(item.Reparse);
    Set32(p + 0x58, tag);
    // Set32(p + 0x5C, 0); // probably it's always ZERO
  }
  else if (item.FileID != 0)
  {
    Set64(p + 0x58, item.FileID);
  }
  
  Set16(p + 0x62, (UInt16)shortNameLen);
  Set16(p + 0x64, (UInt16)fileNameLen);
  unsigned i;
  for (i = 0; i * 2 < fileNameLen; i++)
    Set16(p + kDirRecordSize + i * 2, item.Name[i]);
  for (i = 0; i * 2 < shortNameLen; i++)
    Set16(p + kDirRecordSize + fileNameLen2 + i * 2, item.ShortName[i]);
  
  if (item.GetNumAltStreams() == 0)
  {
    if (item.HashIndex >= 0)
      memcpy(p + 0x40, streams[item.HashIndex].Hash, kHashSize);
  }
  else
  {
    Set16(p + 0x60, (UInt16)(item.GetNumAltStreams() + (item.IsDir ? 0 : 1)));
    p += totalLen;
    
    if (!item.IsDir)
    {
      UInt32 curLen = (((0x26 + 0) + 6) & ~7);
      memset(p, 0, curLen);
      Set64(p, curLen);
      if (item.HashIndex >= 0)
        memcpy(p + 0x10, streams[item.HashIndex].Hash, kHashSize);
      totalLen += curLen;
      p += curLen;
    }
    
    FOR_VECTOR (si, item.AltStreams)
    {
      const CAltStream &ss = item.AltStreams[si];
      if (ss.Skip)
        continue;
      
      fileNameLen = ss.Name.Len() * 2;
      fileNameLen2 = (fileNameLen == 0 ? 0 : fileNameLen + 2 + 2);
      UInt32 curLen = (((0x26 + fileNameLen2) + 6) & ~7);
      memset(p, 0, curLen);
      
      Set64(p, curLen);
      if (ss.HashIndex >= 0)
        memcpy(p + 0x10, streams[ss.HashIndex].Hash, kHashSize);
      Set16(p + 0x24, (UInt16)fileNameLen);
      for (i = 0; i * 2 < fileNameLen; i++)
        Set16(p + 0x26 + i * 2, ss.Name[i]);
      totalLen += curLen;
      p += curLen;
    }
  }
  
  return totalLen;
}


struct CDb
{
  CMetaItem DefaultDirItem;
  const CStreamInfo *Hashes;
  CObjectVector<CMetaItem> MetaItems;
  CRecordVector<CUpdateItem> UpdateItems;
  CUIntVector UpdateIndexes; /* indexes in UpdateItems in order of writing data streams
                                to disk (the order of tree items). */

  size_t WriteTree_Dummy(const CDir &tree) const;
  void WriteTree(const CDir &tree, Byte *dest, size_t &pos)  const;
  void WriteOrderList(const CDir &tree);
};


size_t CDb::WriteTree_Dummy(const CDir &tree) const
{
  unsigned i;
  size_t pos = 0;
  for (i = 0; i < tree.Files.Size(); i++)
    pos += WriteItem_Dummy(MetaItems[tree.Files[i]]);
  for (i = 0; i < tree.Dirs.Size(); i++)
  {
    const CDir &subDir = tree.Dirs[i];
    pos += WriteItem_Dummy(MetaItems[subDir.MetaIndex]);
    pos += WriteTree_Dummy(subDir);
  }
  return pos + 8;
}


void CDb::WriteTree(const CDir &tree, Byte *dest, size_t &pos) const
{
  unsigned i;
  for (i = 0; i < tree.Files.Size(); i++)
    pos += WriteItem(Hashes, MetaItems[tree.Files[i]], dest + pos);

  size_t posStart = pos;
  for (i = 0; i < tree.Dirs.Size(); i++)
    pos += WriteItem_Dummy(MetaItems[tree.Dirs[i].MetaIndex]);

  Set64(dest + pos, 0);

  pos += 8;

  for (i = 0; i < tree.Dirs.Size(); i++)
  {
    const CDir &subDir = tree.Dirs[i];
    const CMetaItem &metaItem = MetaItems[subDir.MetaIndex];
    bool needCreateTree = (metaItem.Reparse.Size() == 0)
        || !subDir.Files.IsEmpty()
        || !subDir.Dirs.IsEmpty();
    size_t len = WriteItem(Hashes, metaItem, dest + posStart);
    posStart += len;
    if (needCreateTree)
    {
      Set64(dest + posStart - len + 0x10, pos); // subdirOffset
      WriteTree(subDir, dest, pos);
    }
  }
}


void CDb::WriteOrderList(const CDir &tree)
{
  if (tree.MetaIndex >= 0)
  {
    const CMetaItem &mi = MetaItems[tree.MetaIndex];
    if (mi.UpdateIndex >= 0)
      UpdateIndexes.Add(mi.UpdateIndex);
    FOR_VECTOR (si, mi.AltStreams)
      UpdateIndexes.Add(mi.AltStreams[si].UpdateIndex);
  }

  unsigned i;
  for (i = 0; i < tree.Files.Size(); i++)
  {
    const CMetaItem &mi = MetaItems[tree.Files[i]];
    UpdateIndexes.Add(mi.UpdateIndex);
    FOR_VECTOR (si, mi.AltStreams)
      UpdateIndexes.Add(mi.AltStreams[si].UpdateIndex);
  }

  for (i = 0; i < tree.Dirs.Size(); i++)
    WriteOrderList(tree.Dirs[i]);
}


static void AddTag_ToString(AString &s, const char *name, const char *value)
{
  s += '<';
  s += name;
  s += '>';
  s += value;
  s += '<';
  s += '/';
  s += name;
  s += '>';
}


static void AddTagUInt64_ToString(AString &s, const char *name, UInt64 value)
{
  char temp[32];
  ConvertUInt64ToString(value, temp);
  AddTag_ToString(s, name, temp);
}


static CXmlItem &AddUniqueTag(CXmlItem &parentItem, const char *name)
{
  int index = parentItem.FindSubTag(name);
  if (index < 0)
  {
    CXmlItem &subItem = parentItem.SubItems.AddNew();
    subItem.IsTag = true;
    subItem.Name = name;
    return subItem;
  }
  CXmlItem &subItem = parentItem.SubItems[index];
  subItem.SubItems.Clear();
  return subItem;
}


static void AddTag_UInt64_2(CXmlItem &item, UInt64 value)
{
  CXmlItem &subItem = item.SubItems.AddNew();
  subItem.IsTag = false;
  char temp[32];
  ConvertUInt64ToString(value, temp);
  subItem.Name = temp;
}


static void AddTag_UInt64(CXmlItem &parentItem, const char *name, UInt64 value)
{
  AddTag_UInt64_2(AddUniqueTag(parentItem, name), value);
}


static void AddTag_Hex(CXmlItem &item, const char *name, UInt32 value)
{
  item.IsTag = true;
  item.Name = name;
  char temp[16];
  temp[0] = '0';
  temp[1] = 'x';
  ConvertUInt32ToHex8Digits(value, temp + 2);
  CXmlItem &subItem = item.SubItems.AddNew();
  subItem.IsTag = false;
  subItem.Name = temp;
}


static void AddTag_Time_2(CXmlItem &item, const FILETIME &ft)
{
  AddTag_Hex(item.SubItems.AddNew(), "HIGHPART", ft.dwHighDateTime);
  AddTag_Hex(item.SubItems.AddNew(), "LOWPART", ft.dwLowDateTime);
}


static void AddTag_Time(CXmlItem &parentItem, const char *name, const FILETIME &ft)
{
  AddTag_Time_2(AddUniqueTag(parentItem, name), ft);
}


static void AddTag_String_IfEmpty(CXmlItem &parentItem, const char *name, const char *value)
{
  int index = parentItem.FindSubTag(name);
  if (index >= 0)
    return;
  CXmlItem &tag = parentItem.SubItems.AddNew();
  tag.IsTag = true;
  tag.Name = name;
  CXmlItem &subItem = tag.SubItems.AddNew();
  subItem.IsTag = false;
  subItem.Name = value;
}


void CHeader::SetDefaultFields(bool useLZX)
{
  Version = k_Version_NonSolid;
  Flags = NHeaderFlags::kReparsePointFixup;
  ChunkSize = 0;
  if (useLZX)
  {
    Flags |= NHeaderFlags::kCompression | NHeaderFlags::kLZX;
    ChunkSize = kChunkSize;
    ChunkSizeBits = kChunkSizeBits;
  }
  g_RandomGenerator.Generate(Guid, 16);
  PartNumber = 1;
  NumParts = 1;
  NumImages = 1;
  BootIndex = 0;
  OffsetResource.Clear();
  XmlResource.Clear();
  MetadataResource.Clear();
  IntegrityResource.Clear();
}


static void AddTrees(CObjectVector<CDir> &trees, CObjectVector<CMetaItem> &metaItems, const CMetaItem &ri, int curTreeIndex)
{
  while (curTreeIndex >= (int)trees.Size())
    trees.AddNew().Dirs.AddNew().MetaIndex = metaItems.Add(ri);
}


#define IS_LETTER_CHAR(c) ((c) >= 'a' && (c) <= 'z' || (c) >= 'A' && (c) <= 'Z')



STDMETHODIMP CHandler::UpdateItems(ISequentialOutStream *outSeqStream, UInt32 numItems, IArchiveUpdateCallback *callback)
{
  COM_TRY_BEGIN

  if (!IsUpdateSupported())
    return E_NOTIMPL;

  bool isUpdate = (_volumes.Size() != 0);
  int defaultImageIndex = _defaultImageNumber - 1;
  bool showImageNumber;

  if (isUpdate)
  {
    showImageNumber = _showImageNumber;
    if (!showImageNumber)
      defaultImageIndex = _db.IndexOfUserImage;
  }
  else
  {
    showImageNumber = (_set_use_ShowImageNumber && _set_showImageNumber);
    if (!showImageNumber)
      defaultImageIndex = 0;
  }

  if (defaultImageIndex >= kNumImagesMaxUpdate)
    return E_NOTIMPL;

  CMyComPtr<IOutStream> outStream;
  RINOK(outSeqStream->QueryInterface(IID_IOutStream, (void **)&outStream));
  if (!outStream)
    return E_NOTIMPL;
  if (!callback)
    return E_FAIL;

  CDb db;
  CObjectVector<CDir> trees;

  CMetaItem ri; // default DIR item
  FILETIME ftCur;
  NTime::GetCurUtcFileTime(ftCur);
  ri.MTime = ri.ATime = ri.CTime = ftCur;
  ri.Attrib = FILE_ATTRIBUTE_DIRECTORY;
  ri.IsDir = true;


  // ---------- Detect changed images ----------

  unsigned i;
  CBoolVector isChangedImage;
  {
    CUIntVector numUnchangedItemsInImage;
    for (i = 0; i < _db.Images.Size(); i++)
    {
      numUnchangedItemsInImage.Add(0);
      isChangedImage.Add(false);
    }
    
    for (i = 0; i < numItems; i++)
    {
      UInt32 indexInArchive;
      Int32 newData, newProps;
      RINOK(callback->GetUpdateItemInfo(i, &newData, &newProps, &indexInArchive));
      if (newProps == 0)
      {
        if (indexInArchive >= _db.SortedItems.Size())
          continue;
        const CItem &item = _db.Items[_db.SortedItems[indexInArchive]];
        if (newData == 0)
        {
          if (item.ImageIndex >= 0)
            numUnchangedItemsInImage[item.ImageIndex]++;
        }
        else
        {
          // oldProps & newData. Current version of 7-Zip doesn't use it
          if (item.ImageIndex >= 0)
            isChangedImage[item.ImageIndex] = true;
        }
      }
      else if (!showImageNumber)
      {
        if (defaultImageIndex >= 0 && defaultImageIndex < (int)isChangedImage.Size())
          isChangedImage[defaultImageIndex] = true;
      }
      else
      {
        NCOM::CPropVariant prop;
        RINOK(callback->GetProperty(i, kpidPath, &prop));
        
        if (prop.vt != VT_BSTR)
          return E_INVALIDARG;
        const wchar_t *path = prop.bstrVal;
        if (!path)
          return E_INVALIDARG;

        const wchar_t *end;
        UInt64 val = ConvertStringToUInt64(path, &end);
        if (end == path)
          return E_INVALIDARG;
        if (val == 0 || val > kNumImagesMaxUpdate)
          return E_INVALIDARG;
        wchar_t c = *end;
        if (c != 0 && c != ':' && c != L'/' && c != WCHAR_PATH_SEPARATOR)
          return E_INVALIDARG;
        unsigned imageIndex = (unsigned)val - 1;
        if (imageIndex < _db.Images.Size())
          isChangedImage[imageIndex] = true;
        if (_defaultImageNumber > 0 && val != (unsigned)_defaultImageNumber)
          return E_INVALIDARG;
      }
    }
    
    for (i = 0; i < _db.Images.Size(); i++)
      if (!isChangedImage[i])
        isChangedImage[i] = _db.GetNumUserItemsInImage(i) != numUnchangedItemsInImage[i];
  }

  if (defaultImageIndex >= 0)
  {
    for (i = 0; i < _db.Images.Size(); i++)
      if ((int)i != defaultImageIndex)
        isChangedImage[i] = false;
  }

  CMyComPtr<IArchiveGetRawProps> getRawProps;
  callback->QueryInterface(IID_IArchiveGetRawProps, (void **)&getRawProps);

  CMyComPtr<IArchiveGetRootProps> getRootProps;
  callback->QueryInterface(IID_IArchiveGetRootProps, (void **)&getRootProps);

  CObjectVector<CUniqBlocks> secureBlocks;

  if (!showImageNumber && (getRootProps || isUpdate) &&
      (
        defaultImageIndex >= (int)isChangedImage.Size()
        || defaultImageIndex < 0 // test it
        || isChangedImage[defaultImageIndex]
      ))
  {
    // Fill Root Item: Metadata and security
    CMetaItem rootItem = ri;
    {
      const void *data = NULL;
      UInt32 dataSize = 0;
      UInt32 propType = 0;
      if (getRootProps)
      {
        RINOK(getRootProps->GetRootRawProp(kpidNtSecure, &data, &dataSize, &propType));
      }
      if (dataSize == 0 && isUpdate)
      {
        RINOK(GetRootRawProp(kpidNtSecure, &data, &dataSize, &propType));
      }
      if (dataSize != 0)
      {
        if (propType != NPropDataType::kRaw)
          return E_FAIL;
        while (defaultImageIndex >= (int)secureBlocks.Size())
          secureBlocks.AddNew();
        CUniqBlocks &secUniqBlocks = secureBlocks[defaultImageIndex];
        rootItem.SecurityId = secUniqBlocks.AddUniq((const Byte *)data, dataSize);
      }
    }
    
    IArchiveGetRootProps *thisGetRoot = isUpdate ? this : NULL;
    
    RINOK(GetRootTime(getRootProps, thisGetRoot, kpidCTime, rootItem.CTime));
    RINOK(GetRootTime(getRootProps, thisGetRoot, kpidATime, rootItem.ATime));
    RINOK(GetRootTime(getRootProps, thisGetRoot, kpidMTime, rootItem.MTime));
    
    {
      NCOM::CPropVariant prop;
      if (getRootProps)
      {
        RINOK(getRootProps->GetRootProp(kpidAttrib, &prop));
        if (prop.vt == VT_UI4)
          rootItem.Attrib = prop.ulVal;
        else if (prop.vt != VT_EMPTY)
          return E_INVALIDARG;
      }
      if (prop.vt == VT_EMPTY && thisGetRoot)
      {
        RINOK(GetRootProp(kpidAttrib, &prop));
        if (prop.vt == VT_UI4)
          rootItem.Attrib = prop.ulVal;
        else if (prop.vt != VT_EMPTY)
          return E_INVALIDARG;
      }
      rootItem.Attrib |= FILE_ATTRIBUTE_DIRECTORY;
    }
    
    AddTrees(trees, db.MetaItems, ri, defaultImageIndex);
    db.MetaItems[trees[defaultImageIndex].Dirs[0].MetaIndex] = rootItem;
  }

  // ---------- Request Metadata for changed items ----------

  UString fileName;
  
  for (i = 0; i < numItems; i++)
  {
    CUpdateItem ui;
    UInt32 indexInArchive;
    Int32 newData, newProps;
    RINOK(callback->GetUpdateItemInfo(i, &newData, &newProps, &indexInArchive));

    if (newData == 0 || newProps == 0)
    {
      if (indexInArchive >= _db.SortedItems.Size())
        continue;
      
      const CItem &item = _db.Items[_db.SortedItems[indexInArchive]];
      
      if (item.ImageIndex >= 0)
      {
        if (!isChangedImage[item.ImageIndex])
        {
          if (newData == 0 && newProps == 0)
            continue;
          return E_FAIL;
        }
      }
      else
      {
        // if deleted item was not renamed, we just skip it
        if (newProps == 0)
          continue;
        if (item.StreamIndex >= 0)
        {
          // we don't support property change for SolidBig streams
          if (_db.DataStreams[item.StreamIndex].Resource.IsSolidBig())
            return E_NOTIMPL;
        }
      }
    
      if (newData == 0)
        ui.InArcIndex = indexInArchive;
    }

    // we set arcIndex only if we must use old props
    Int32 arcIndex = (newProps ? -1 : indexInArchive);

    bool isDir = false;
    {
      NCOM::CPropVariant prop;
      RINOK(GetOutProperty(callback, i, arcIndex, kpidIsDir, &prop));
      if (prop.vt == VT_BOOL)
        isDir = (prop.boolVal != VARIANT_FALSE);
      else if (prop.vt != VT_EMPTY)
        return E_INVALIDARG;
    }

    bool isAltStream = false;
    {
      NCOM::CPropVariant prop;
      RINOK(GetOutProperty(callback, i, arcIndex, kpidIsAltStream, &prop));
      if (prop.vt == VT_BOOL)
        isAltStream = (prop.boolVal != VARIANT_FALSE);
      else if (prop.vt != VT_EMPTY)
        return E_INVALIDARG;
    }

    if (isDir && isAltStream)
      return E_INVALIDARG;

    UInt64 size = 0;
    UInt64 iNode = 0;

    if (!isDir)
    {
      if (!newData)
      {
        NCOM::CPropVariant prop;
        GetProperty(indexInArchive, kpidINode, &prop);
        if (prop.vt == VT_UI8)
          iNode = prop.uhVal.QuadPart;
      }

      NCOM::CPropVariant prop;
      
      if (newData)
      {
        RINOK(callback->GetProperty(i, kpidSize, &prop));
      }
      else
      {
        RINOK(GetProperty(indexInArchive, kpidSize, &prop));
      }
     
      if (prop.vt == VT_UI8)
        size = prop.uhVal.QuadPart;
      else if (prop.vt != VT_EMPTY)
        return E_INVALIDARG;
    }

    {
      NCOM::CPropVariant propPath;
      const wchar_t *path = NULL;
      RINOK(GetOutProperty(callback, i, arcIndex, kpidPath, &propPath));
      if (propPath.vt == VT_BSTR)
        path = propPath.bstrVal;
      else if (propPath.vt != VT_EMPTY)
        return E_INVALIDARG;
    
    if (!path)
      return E_INVALIDARG;

    CDir *curItem = NULL;
    bool isRootImageDir = false;
    fileName.Empty();

    int imageIndex;
    
    if (!showImageNumber)
    {
      imageIndex = defaultImageIndex;
      AddTrees(trees, db.MetaItems, ri, imageIndex);
      curItem = &trees[imageIndex].Dirs[0];
    }
    else
    {
      const wchar_t *end;
      UInt64 val = ConvertStringToUInt64(path, &end);
      if (end == path)
        return E_INVALIDARG;
      if (val == 0 || val > kNumImagesMaxUpdate)
        return E_INVALIDARG;
      
      imageIndex = (int)val - 1;
      if (imageIndex < (int)isChangedImage.Size())
        if (!isChangedImage[imageIndex])
          return E_FAIL;

      AddTrees(trees, db.MetaItems, ri, imageIndex);
      curItem = &trees[imageIndex].Dirs[0];
      wchar_t c = *end;
      
      if (c == 0)
      {
        if (!isDir || isAltStream)
          return E_INVALIDARG;
        ui.MetaIndex = curItem->MetaIndex;
        isRootImageDir = true;
      }
      else if (c == ':')
      {
        if (isDir || !isAltStream)
          return E_INVALIDARG;
        ui.MetaIndex = curItem->MetaIndex;
        CAltStream ss;
        ss.Size = size;
        ss.Name = end + 1;
        ss.UpdateIndex = db.UpdateItems.Size();
        ui.AltStreamIndex = db.MetaItems[ui.MetaIndex].AltStreams.Add(ss);
      }
      else if (c == WCHAR_PATH_SEPARATOR || c == L'/')
      {
        path = end + 1;
        if (*path == 0)
          return E_INVALIDARG;
      }
      else
        return E_INVALIDARG;
    }
      
    if (ui.MetaIndex < 0)
    {
      for (;;)
      {
        wchar_t c = *path++;
        if (c == 0)
          break;
        if (c == WCHAR_PATH_SEPARATOR || c == L'/')
        {
          unsigned indexOfDir;
          if (!curItem->FindDir(db.MetaItems, fileName, indexOfDir))
          {
            CDir &dir = curItem->Dirs.InsertNew(indexOfDir);
            dir.MetaIndex = db.MetaItems.Add(ri);
            db.MetaItems.Back().Name = fileName;
          }
          curItem = &curItem->Dirs[indexOfDir];
          fileName.Empty();
        }
        else
          fileName += c;
      }

      if (isAltStream)
      {
        int colonPos = fileName.Find(L':');
        if (colonPos < 0)
          return E_INVALIDARG;
        
        // we want to support cases of c::substream, where c: is drive name
        if (colonPos == 1 && fileName[2] == L':' && IS_LETTER_CHAR(fileName[0]))
          colonPos = 2;
        const UString mainName = fileName.Left(colonPos);
        unsigned indexOfDir;
        
        if (mainName.IsEmpty())
          ui.MetaIndex = curItem->MetaIndex;
        else if (curItem->FindDir(db.MetaItems, mainName, indexOfDir))
          ui.MetaIndex = curItem->Dirs[indexOfDir].MetaIndex;
        else
        {
          for (int j = (int)curItem->Files.Size() - 1; j >= 0; j--)
          {
            int metaIndex = curItem->Files[j];
            const CMetaItem &mi = db.MetaItems[metaIndex];
            if (CompareFileNames(mainName, mi.Name) == 0)
            {
              ui.MetaIndex = metaIndex;
              break;
            }
          }
        }
        
        if (ui.MetaIndex >= 0)
        {
          CAltStream ss;
          ss.Size = size;
          ss.Name = fileName.Ptr(colonPos + 1);
          ss.UpdateIndex = db.UpdateItems.Size();
          ui.AltStreamIndex = db.MetaItems[ui.MetaIndex].AltStreams.Add(ss);
        }
      }
    }


    if (ui.MetaIndex < 0 || isRootImageDir)
    {
      if (!isRootImageDir)
      {
        ui.MetaIndex = db.MetaItems.Size();
        db.MetaItems.AddNew();
      }
    
      CMetaItem &mi = db.MetaItems[ui.MetaIndex];
      mi.Size = size;
      mi.IsDir = isDir;
      mi.Name = fileName;
      mi.UpdateIndex = db.UpdateItems.Size();
      {
        NCOM::CPropVariant prop;
        RINOK(GetOutProperty(callback, i, arcIndex, kpidAttrib, &prop));
        if (prop.vt == VT_EMPTY)
          mi.Attrib = 0;
        else if (prop.vt == VT_UI4)
          mi.Attrib = prop.ulVal;
        else
          return E_INVALIDARG;
        if (isDir)
          mi.Attrib |= FILE_ATTRIBUTE_DIRECTORY;
      }
      RINOK(GetTime(callback, i, arcIndex, kpidCTime, mi.CTime));
      RINOK(GetTime(callback, i, arcIndex, kpidATime, mi.ATime));
      RINOK(GetTime(callback, i, arcIndex, kpidMTime, mi.MTime));

      {
        NCOM::CPropVariant prop;
        RINOK(GetOutProperty(callback, i, arcIndex, kpidShortName, &prop));
        if (prop.vt == VT_BSTR)
          mi.ShortName.SetFromBstr(prop.bstrVal);
        else if (prop.vt != VT_EMPTY)
          return E_INVALIDARG;
      }

      while (imageIndex >= (int)secureBlocks.Size())
        secureBlocks.AddNew();
      
      if (!isAltStream && (getRawProps || arcIndex >= 0))
      {
        CUniqBlocks &secUniqBlocks = secureBlocks[imageIndex];
        const void *data;
        UInt32 dataSize;
        UInt32 propType;
        
        data = NULL;
        dataSize = 0;
        propType = 0;
        
        if (arcIndex >= 0)
        {
          GetRawProp(arcIndex, kpidNtSecure, &data, &dataSize, &propType);
        }
        else
        {
          getRawProps->GetRawProp(i, kpidNtSecure, &data, &dataSize, &propType);
        }
        
        if (dataSize != 0)
        {
          if (propType != NPropDataType::kRaw)
            return E_FAIL;
          mi.SecurityId = secUniqBlocks.AddUniq((const Byte *)data, dataSize);
        }

        data = NULL;
        dataSize = 0;
        propType = 0;
        
        if (arcIndex >= 0)
        {
          GetRawProp(arcIndex, kpidNtReparse, &data, &dataSize, &propType);
        }
        else
        {
          getRawProps->GetRawProp(i, kpidNtReparse, &data, &dataSize, &propType);
        }
      
        if (dataSize != 0)
        {
          if (propType != NPropDataType::kRaw)
            return E_FAIL;
          mi.Reparse.CopyFrom((const Byte *)data, dataSize);
        }
      }

      if (!isRootImageDir)
      {
        if (isDir)
        {
          unsigned indexOfDir;
          if (curItem->FindDir(db.MetaItems, fileName, indexOfDir))
            curItem->Dirs[indexOfDir].MetaIndex = ui.MetaIndex;
          else
            curItem->Dirs.InsertNew(indexOfDir).MetaIndex = ui.MetaIndex;
        }
        else
          curItem->Files.Add(ui.MetaIndex);
      }
    }
    
    }
    
    if (iNode != 0 && ui.MetaIndex >= 0 && ui.AltStreamIndex < 0)
      db.MetaItems[ui.MetaIndex].FileID = iNode;

    ui.CallbackIndex = i;
    db.UpdateItems.Add(ui);
  }

  unsigned numNewImages = trees.Size();
  for (i = numNewImages; i < isChangedImage.Size(); i++)
    if (!isChangedImage[i])
      numNewImages = i + 1;

  AddTrees(trees, db.MetaItems, ri, numNewImages - 1);

  for (i = 0; i < trees.Size(); i++)
    if (i >= isChangedImage.Size() || isChangedImage[i])
      db.WriteOrderList(trees[i]);


  UInt64 complexity = 0;

  unsigned numDataStreams = _db.DataStreams.Size();
  CUIntArr streamsRefs(numDataStreams);
  for (i = 0; i < numDataStreams; i++)
    streamsRefs[i] = 0;

  // ---------- Calculate Streams Refs Counts in unchanged images

  for (i = 0; i < _db.Images.Size(); i++)
  {
    if (isChangedImage[i])
      continue;
    complexity += _db.MetaStreams[i].Resource.PackSize;
    const CImage &image = _db.Images[i];
    unsigned endItem = image.StartItem + image.NumItems;
    for (unsigned k = image.StartItem; k < endItem; k++)
    {
      const CItem &item = _db.Items[k];
      if (item.StreamIndex >= 0)
        streamsRefs[(unsigned)item.StreamIndex]++;
    }
  }


  // ---------- Update Streams Refs Counts in changed images

  for (i = 0; i < db.UpdateIndexes.Size(); i++)
  {
    const CUpdateItem &ui = db.UpdateItems[db.UpdateIndexes[i]];
    
    if (ui.InArcIndex >= 0)
    {
      if ((unsigned)ui.InArcIndex >= _db.SortedItems.Size())
        continue;
      const CItem &item = _db.Items[_db.SortedItems[ui.InArcIndex]];
      if (item.StreamIndex >= 0)
        streamsRefs[(unsigned)item.StreamIndex]++;
    }
    else
    {
      const CMetaItem &mi = db.MetaItems[ui.MetaIndex];
      UInt64 size;
      if (ui.AltStreamIndex < 0)
        size = mi.Size;
      else
        size = mi.AltStreams[ui.AltStreamIndex].Size;
      complexity += size;
    }
  }

  // Clear ref counts for SolidBig streams
  
  for (i = 0; i < _db.DataStreams.Size(); i++)
    if (_db.DataStreams[i].Resource.IsSolidBig())
      streamsRefs[i] = 0;

  // Set ref counts for SolidBig streams
  
  for (i = 0; i < _db.DataStreams.Size(); i++)
    if (streamsRefs[i] != 0)
    {
      const CResource &rs = _db.DataStreams[i].Resource;
      if (rs.IsSolidSmall())
        streamsRefs[_db.Solids[rs.SolidIndex].StreamIndex] = 1;
    }

  for (i = 0; i < _db.DataStreams.Size(); i++)
    if (streamsRefs[i] != 0)
    {
      const CResource &rs = _db.DataStreams[i].Resource;
      if (!rs.IsSolidSmall())
        complexity += rs.PackSize;
    }
      
  RINOK(callback->SetTotal(complexity));
  UInt64 totalComplexity = complexity;

  NCompress::CCopyCoder *copyCoderSpec = new NCompress::CCopyCoder;
  CMyComPtr<ICompressCoder> copyCoder = copyCoderSpec;

  CLocalProgress *lps = new CLocalProgress;
  CMyComPtr<ICompressProgressInfo> progress = lps;
  lps->Init(callback, true);

  complexity = 0;

  // bool useResourceCompression = false;
  // use useResourceCompression only if CHeader::Flags compression is also set

  CHeader header;
  header.SetDefaultFields(false);

  if (isUpdate)
  {
    const CHeader &srcHeader = _volumes[1].Header;
    header.Flags = srcHeader.Flags;
    header.Version = srcHeader.Version;
    header.ChunkSize = srcHeader.ChunkSize;
    header.ChunkSizeBits = srcHeader.ChunkSizeBits;
  }

  {
    Byte buf[kHeaderSizeMax];
    header.WriteTo(buf);
    RINOK(WriteStream(outStream, buf, kHeaderSizeMax));
  }

  UInt64 curPos = kHeaderSizeMax;

  CInStreamWithSha1 *inShaStreamSpec = new CInStreamWithSha1;
  CMyComPtr<ISequentialInStream> inShaStream = inShaStreamSpec;

  CLimitedSequentialInStream *inStreamLimitedSpec = NULL;
  CMyComPtr<CLimitedSequentialInStream> inStreamLimited;
  if (_volumes.Size() == 2)
  {
    inStreamLimitedSpec = new CLimitedSequentialInStream;
    inStreamLimited = inStreamLimitedSpec;
    inStreamLimitedSpec->SetStream(_volumes[1].Stream);
  }

  
  CRecordVector<CStreamInfo> streams;
  CUIntVector sortedHashes; // indexes to streams, sorted by SHA1
  
  // ---------- Copy unchanged data streams ----------

  UInt64 solidRunOffset = 0;
  UInt64 curSolidSize = 0;

  for (i = 0; i < _db.DataStreams.Size(); i++)
  {
    const CStreamInfo &siOld = _db.DataStreams[i];
    const CResource &rs = siOld.Resource;
    
    unsigned numRefs = streamsRefs[i];

    if (numRefs == 0)
    {
      if (!rs.IsSolidSmall())
        continue;
      if (streamsRefs[_db.Solids[rs.SolidIndex].StreamIndex] == 0)
        continue;
    }

    lps->InSize = lps->OutSize = complexity;
    RINOK(lps->SetCur());

    int streamIndex = streams.Size();
    CStreamInfo s;
    s.Resource = rs;
    s.PartNumber = 1;
    s.RefCount = numRefs;

    memcpy(s.Hash, siOld.Hash, kHashSize);

    if (rs.IsSolid())
    {
      CSolid &ss = _db.Solids[rs.SolidIndex];
      if (rs.IsSolidSmall())
      {
        UInt64 oldOffset = ss.SolidOffset;
        if (rs.Offset < oldOffset)
          return E_FAIL;
        UInt64 relatOffset = rs.Offset - oldOffset;
        s.Resource.Offset = solidRunOffset + relatOffset;
      }
      else
      {
        // IsSolidBig
        solidRunOffset += curSolidSize;
        curSolidSize = ss.UnpackSize;
      }
    }
    else
    {
      solidRunOffset = 0;
      curSolidSize = 0;
    }
     
    if (!rs.IsSolid() || rs.IsSolidSmall())
    {
      int find = AddUniqHash(&streams.Front(), sortedHashes, siOld.Hash, streamIndex);
      if (find >= 0)
        return E_FAIL; // two streams with same SHA-1
    }
   
    if (!rs.IsSolid() || rs.IsSolidBig())
    {
      RINOK(_volumes[siOld.PartNumber].Stream->Seek(rs.Offset, STREAM_SEEK_SET, NULL));
      inStreamLimitedSpec->Init(rs.PackSize);
      RINOK(copyCoder->Code(inStreamLimited, outStream, NULL, NULL, progress));
      if (copyCoderSpec->TotalSize != rs.PackSize)
        return E_FAIL;
      s.Resource.Offset = curPos;
      curPos += rs.PackSize;
      lps->ProgressOffset += rs.PackSize;
    }

    streams.Add(s);
  }

  
  // ---------- Write new items ----------

  CUIntVector hlIndexes; // sorted indexes for hard link items

  for (i = 0; i < db.UpdateIndexes.Size(); i++)
  {
    lps->InSize = lps->OutSize = complexity;
    RINOK(lps->SetCur());
    const CUpdateItem &ui = db.UpdateItems[db.UpdateIndexes[i]];
    CMetaItem &mi = db.MetaItems[ui.MetaIndex];
    UInt64 size = 0;
    
    if (ui.AltStreamIndex >= 0)
    {
      if (mi.Skip)
        continue;
      size = mi.AltStreams[ui.AltStreamIndex].Size;
    }
    else
    {
      size = mi.Size;
      if (mi.IsDir)
      {
        // we support LINK files here
        if (mi.Reparse.Size() == 0)
          continue;
      }
    }

    if (ui.InArcIndex >= 0)
    {
      // data streams with OLD Data were written already
      // we just need to find HashIndex in hashes.

      if ((unsigned)ui.InArcIndex >= _db.SortedItems.Size())
        return E_FAIL;
      
      const CItem &item = _db.Items[_db.SortedItems[ui.InArcIndex]];
      
      if (item.StreamIndex < 0)
      {
        if (size == 0)
          continue;
        // if (_db.ItemHasStream(item))
        return E_FAIL;
      }

      // We support empty file (size = 0, but with stream and SHA-1) from old archive
      
      const CStreamInfo &siOld = _db.DataStreams[item.StreamIndex];

      int index = AddUniqHash(&streams.Front(), sortedHashes, siOld.Hash, -1);
      // we must have written that stream already
      if (index < 0)
        return E_FAIL;

      if (ui.AltStreamIndex < 0)
        mi.HashIndex = index;
      else
        mi.AltStreams[ui.AltStreamIndex].HashIndex = index;
      
      continue;
    }

    CMyComPtr<ISequentialInStream> fileInStream;
    HRESULT res = callback->GetStream(ui.CallbackIndex, &fileInStream);
    
    if (res == S_FALSE)
    {
      if (ui.AltStreamIndex >= 0)
      {
        mi.NumSkipAltStreams++;
        mi.AltStreams[ui.AltStreamIndex].Skip = true;
      }
      else
        mi.Skip = true;
    }
    else
    {
      RINOK(res);

      int miIndex = -1;
      
      if (!fileInStream)
      {
        if (!mi.IsDir)
          return E_INVALIDARG;
      }
      else if (ui.AltStreamIndex < 0)
      {
        CMyComPtr<IStreamGetProps2> getProps2;
        fileInStream->QueryInterface(IID_IStreamGetProps2, (void **)&getProps2);
        if (getProps2)
        {
          CStreamFileProps props;
          if (getProps2->GetProps2(&props) == S_OK)
          {
            mi.Attrib = props.Attrib;
            mi.CTime = props.CTime;
            mi.ATime = props.ATime;
            mi.MTime = props.MTime;
            mi.FileID = props.FileID_Low;
            if (props.NumLinks <= 1)
              mi.FileID = 0;
            mi.VolID = props.VolID;
            if (mi.FileID != 0)
              miIndex = AddToHardLinkList(db.MetaItems, ui.MetaIndex, hlIndexes);

            if (props.Size != size && props.Size != (UInt64)(Int64)-1)
            {
              Int64 delta = (Int64)props.Size - (Int64)size;
              Int64 newComplexity = totalComplexity + delta;
              if (newComplexity > 0)
              {
                totalComplexity = newComplexity;
                callback->SetTotal(totalComplexity);
              }
              mi.Size = props.Size;
              size = props.Size;
            }
          }
        }
      }
      
      if (miIndex >= 0)
      {
        mi.HashIndex = db.MetaItems[miIndex].HashIndex;
        if (mi.HashIndex >= 0)
          streams[mi.HashIndex].RefCount++;
        // fix for future: maybe we need to check also that real size is equal to size from IStreamGetProps2
      }
      else if (ui.AltStreamIndex < 0 && mi.Reparse.Size() != 0)
      {
        if (mi.Reparse.Size() < 8)
          return E_FAIL;
        NCrypto::NSha1::CContext sha1;
        sha1.Init();
        size_t packSize = mi.Reparse.Size() - 8;
        sha1.Update((const Byte *)mi.Reparse + 8, packSize);
        Byte hash[kHashSize];
        sha1.Final(hash);
        
        int index = AddUniqHash(&streams.Front(), sortedHashes, hash, streams.Size());

        if (index >= 0)
          streams[index].RefCount++;
        else
        {
          index = streams.Size();
          RINOK(WriteStream(outStream, (const Byte *)mi.Reparse + 8, packSize));
          CStreamInfo s;
          s.Resource.PackSize = packSize;
          s.Resource.Offset = curPos;
          s.Resource.UnpackSize = packSize;
          s.Resource.Flags = 0; // check it
          /*
            if (useResourceCompression)
              s.Resource.Flags = NResourceFlags::Compressed;
          */
          s.PartNumber = 1;
          s.RefCount = 1;
          memcpy(s.Hash, hash, kHashSize);
          curPos += packSize;

          streams.Add(s);
        }
        
        mi.HashIndex = index;
      }
      else
      {
        inShaStreamSpec->SetStream(fileInStream);
        fileInStream.Release();
        inShaStreamSpec->Init();
        UInt64 offsetBlockSize = 0;
        /*
        if (useResourceCompression)
        {
          for (UInt64 t = kChunkSize; t < size; t += kChunkSize)
          {
            Byte buf[8];
            SetUi32(buf, (UInt32)t);
            RINOK(WriteStream(outStream, buf, 4));
            offsetBlockSize += 4;
          }
        }
        */
        
        RINOK(copyCoder->Code(inShaStream, outStream, NULL, NULL, progress));
        size = copyCoderSpec->TotalSize;
       
        if (size != 0)
        {
          Byte hash[kHashSize];
          UInt64 packSize = offsetBlockSize + size;
          inShaStreamSpec->Final(hash);

          int index = AddUniqHash(&streams.Front(), sortedHashes, hash, streams.Size());

          if (index >= 0)
          {
            streams[index].RefCount++;
            outStream->Seek(-(Int64)packSize, STREAM_SEEK_CUR, &curPos);
            outStream->SetSize(curPos);
          }
          else
          {
            index = streams.Size();
            CStreamInfo s;
            s.Resource.PackSize = packSize;
            s.Resource.Offset = curPos;
            s.Resource.UnpackSize = size;
            s.Resource.Flags = 0;
            /*
            if (useResourceCompression)
            s.Resource.Flags = NResourceFlags::Compressed;
            */
            s.PartNumber = 1;
            s.RefCount = 1;
            memcpy(s.Hash, hash, kHashSize);
            curPos += packSize;

            streams.Add(s);
          }
          
          if (ui.AltStreamIndex < 0)
            mi.HashIndex = index;
          else
            mi.AltStreams[ui.AltStreamIndex].HashIndex = index;
        }
      }
    }
    fileInStream.Release();
    complexity += size;
    RINOK(callback->SetOperationResult(NArchive::NUpdate::NOperationResult::kOK));
  }

  while (secureBlocks.Size() < numNewImages)
    secureBlocks.AddNew();

  
  
  // ---------- Write Images ----------

  for (i = 0; i < numNewImages; i++)
  {
    lps->InSize = lps->OutSize = complexity;
    RINOK(lps->SetCur());
    if (i < isChangedImage.Size() && !isChangedImage[i])
    {
      CStreamInfo s = _db.MetaStreams[i];
      
      RINOK(_volumes[1].Stream->Seek(s.Resource.Offset, STREAM_SEEK_SET, NULL));
      inStreamLimitedSpec->Init(s.Resource.PackSize);
      RINOK(copyCoder->Code(inStreamLimited, outStream, NULL, NULL, progress));
      if (copyCoderSpec->TotalSize != s.Resource.PackSize)
        return E_FAIL;

      s.Resource.Offset = curPos;
      s.PartNumber = 1;
      s.RefCount = 1;
      streams.Add(s);

      if (_bootIndex != 0 && _bootIndex == (UInt32)i + 1)
      {
        header.MetadataResource = s.Resource;
        header.BootIndex = _bootIndex;
      }

      lps->ProgressOffset += s.Resource.PackSize;
      curPos += s.Resource.PackSize;
      // printf("\nWrite old image %x\n", i + 1);
      continue;
    }

    const CDir &tree = trees[i];
    const UInt32 kSecuritySize = 8;
    
    size_t pos = kSecuritySize;

    const CUniqBlocks &secUniqBlocks = secureBlocks[i];
    const CObjectVector<CByteBuffer> &secBufs = secUniqBlocks.Bufs;
    pos += (size_t)secUniqBlocks.GetTotalSizeInBytes();
    pos += secBufs.Size() * 8;
    pos = (pos + 7) & ~(size_t)7;
    
    db.DefaultDirItem = ri;
    pos += db.WriteTree_Dummy(tree);
    
    CByteArr meta(pos);
    
    Set32((Byte *)meta + 4, secBufs.Size()); // num security entries
    pos = kSecuritySize;
    
    if (secBufs.Size() == 0)
    {
      // we can write 0 here only if there is no security data, imageX does it,
      // but some programs expect size = 8
      Set32((Byte *)meta, 8); // size of security data
      // Set32((Byte *)meta, 0);
    }
    else
    {
      unsigned k;
      for (k = 0; k < secBufs.Size(); k++, pos += 8)
      {
        Set64(meta + pos, secBufs[k].Size());
      }
      for (k = 0; k < secBufs.Size(); k++)
      {
        const CByteBuffer &buf = secBufs[k];
        size_t size = buf.Size();
        if (size != 0)
        {
          memcpy(meta + pos, buf, size);
          pos += size;
        }
      }
      while ((pos & 7) != 0)
        meta[pos++] = 0;
      Set32((Byte *)meta, (UInt32)pos); // size of security data
    }
    
    db.Hashes = &streams.Front();
    db.WriteTree(tree, (Byte *)meta, pos);

    {
      NCrypto::NSha1::CContext sha;
      sha.Init();
      sha.Update((const Byte *)meta, pos);

      Byte digest[kHashSize];
      sha.Final(digest);
      
      CStreamInfo s;
      s.Resource.PackSize = pos;
      s.Resource.Offset = curPos;
      s.Resource.UnpackSize = pos;
      s.Resource.Flags = NResourceFlags::kMetadata;
      s.PartNumber = 1;
      s.RefCount = 1;
      memcpy(s.Hash, digest, kHashSize);
      streams.Add(s);

      if (_bootIndex != 0 && _bootIndex == (UInt32)i + 1)
      {
        header.MetadataResource = s.Resource;
        header.BootIndex = _bootIndex;
      }

      RINOK(WriteStream(outStream, (const Byte *)meta, pos));
      meta.Free();
      curPos += pos;
    }
  }

  lps->InSize = lps->OutSize = complexity;
  RINOK(lps->SetCur());

  header.OffsetResource.UnpackSize = header.OffsetResource.PackSize = (UInt64)streams.Size() * kStreamInfoSize;
  header.OffsetResource.Offset = curPos;
  header.OffsetResource.Flags = NResourceFlags::kMetadata;

  
  
  // ---------- Write Streams Info Tables ----------

  for (i = 0; i < streams.Size(); i++)
  {
    Byte buf[kStreamInfoSize];
    streams[i].WriteTo(buf);
    RINOK(WriteStream(outStream, buf, kStreamInfoSize));
    curPos += kStreamInfoSize;
  }

  AString xml = "<WIM>";
  AddTagUInt64_ToString(xml, "TOTALBYTES", curPos);
  for (i = 0; i < trees.Size(); i++)
  {
    CDir &tree = trees[i];

    CXmlItem item;
    if (_xmls.Size() == 1)
    {
      const CWimXml &_oldXml = _xmls[0];
      if ((int)i < _oldXml.Images.Size())
      {
        // int ttt = _oldXml.Images[i].ItemIndexInXml;
        item = _oldXml.Xml.Root.SubItems[_oldXml.Images[i].ItemIndexInXml];
      }
    }
    if (i >= isChangedImage.Size() || isChangedImage[i])
    {
      char temp[16];
      if (item.Name.IsEmpty())
      {
        ConvertUInt32ToString(i + 1, temp);
        item.Name = "IMAGE";
        item.IsTag = true;
        CXmlProp &prop = item.Props.AddNew();
        prop.Name = "INDEX";
        prop.Value = temp;
      }
      
      AddTag_String_IfEmpty(item, "NAME", temp);
      AddTag_UInt64(item, "DIRCOUNT", tree.GetNumDirs() - 1);
      AddTag_UInt64(item, "FILECOUNT", tree.GetNumFiles());
      AddTag_UInt64(item, "TOTALBYTES", tree.GetTotalSize(db.MetaItems));
      
      AddTag_Time(item, "CREATIONTIME", ftCur);
      AddTag_Time(item, "LASTMODIFICATIONTIME", ftCur);
    }

    item.AppendTo(xml);
  }
  xml += "</WIM>";

  size_t xmlSize;
  {
    UString utf16;
    if (!ConvertUTF8ToUnicode(xml, utf16))
      return S_FALSE;
    xmlSize = (utf16.Len() + 1) * 2;

    CByteArr xmlBuf(xmlSize);
    Set16((Byte *)xmlBuf, 0xFEFF);
    for (i = 0; i < (unsigned)utf16.Len(); i++)
      Set16((Byte *)xmlBuf + 2 + i * 2, utf16[i]);
    RINOK(WriteStream(outStream, (const Byte *)xmlBuf, xmlSize));
  }
  
  header.XmlResource.UnpackSize = header.XmlResource.PackSize = xmlSize;
  header.XmlResource.Offset = curPos;
  header.XmlResource.Flags = NResourceFlags::kMetadata;

  outStream->Seek(0, STREAM_SEEK_SET, NULL);
  header.NumImages = trees.Size();
  {
    Byte buf[kHeaderSizeMax];
    header.WriteTo(buf);
    return WriteStream(outStream, buf, kHeaderSizeMax);
  }

  COM_TRY_END
}

}}
// Archive/WimIn.cpp

#include "StdAfx.h"

// #define SHOW_DEBUG_INFO

#ifdef SHOW_DEBUG_INFO
#include <stdio.h>
#define PRF(x) x
#else
#define PRF(x)
#endif

#include "../../../../C/CpuArch.h"

#include "../../../Common/IntToString.h"
#include "../../../Common/StringToInt.h"
#include "../../../Common/UTFConvert.h"

#include "../../Common/LimitedStreams.h"
#include "../../Common/StreamObjects.h"
#include "../../Common/StreamUtils.h"

#include "../../Compress/XpressDecoder.h"

#include "../Common/OutStreamWithSha1.h"

#include "WimIn.h"

#define Get16(p) GetUi16(p)
#define Get32(p) GetUi32(p)
#define Get64(p) GetUi64(p)

namespace NArchive {
namespace NWim {

static int inline GetLog(UInt32 num)
{
  for (int i = 0; i < 32; i++)
    if (((UInt32)1 << i) == num)
      return i;
  return -1;
}


CUnpacker::~CUnpacker()
{
  if (lzmsDecoder)
    delete lzmsDecoder;
}


HRESULT CUnpacker::UnpackChunk(
    ISequentialInStream *inStream,
    unsigned method, unsigned chunkSizeBits,
    size_t inSize, size_t outSize,
    ISequentialOutStream *outStream)
{
  if (inSize == outSize)
  {
  }
  else if (method == NMethod::kXPRESS)
  {
  }
  else if (method == NMethod::kLZX)
  {
    if (!lzxDecoder)
    {
      lzxDecoderSpec = new NCompress::NLzx::CDecoder(true);
      lzxDecoder = lzxDecoderSpec;
    }
  }
  else if (method == NMethod::kLZMS)
  {
    if (!lzmsDecoder)
      lzmsDecoder = new NCompress::NLzms::CDecoder();
  }
  else
    return E_NOTIMPL;

  const size_t chunkSize = (size_t)1 << chunkSizeBits;
  
  unpackBuf.EnsureCapacity(chunkSize);
  if (!unpackBuf.Data)
    return E_OUTOFMEMORY;
  
  HRESULT res = S_FALSE;
  size_t unpackedSize = 0;
  
  if (inSize == outSize)
  {
    unpackedSize = outSize;
    res = ReadStream(inStream, unpackBuf.Data, &unpackedSize);
    TotalPacked += unpackedSize;
  }
  else if (inSize < chunkSize)
  {
    packBuf.EnsureCapacity(chunkSize);
    if (!packBuf.Data)
      return E_OUTOFMEMORY;
    
    RINOK(ReadStream_FALSE(inStream, packBuf.Data, inSize));

    TotalPacked += inSize;
    
    if (method == NMethod::kXPRESS)
    {
      res = NCompress::NXpress::Decode(packBuf.Data, inSize, unpackBuf.Data, outSize);
      if (res == S_OK)
        unpackedSize = outSize;
    }
    else if (method == NMethod::kLZX)
    {
      lzxDecoderSpec->SetExternalWindow(unpackBuf.Data, chunkSizeBits);
      lzxDecoderSpec->KeepHistoryForNext = false;
      lzxDecoderSpec->SetKeepHistory(false);
      res = lzxDecoderSpec->Code(packBuf.Data, inSize, (UInt32)outSize);
      unpackedSize = lzxDecoderSpec->GetUnpackSize();
      if (res == S_OK && !lzxDecoderSpec->WasBlockFinished())
        res = S_FALSE;
    }
    else
    {
      res = lzmsDecoder->Code(packBuf.Data, inSize, unpackBuf.Data, outSize);
      unpackedSize = lzmsDecoder->GetUnpackSize();;
    }
  }
  
  if (unpackedSize != outSize)
  {
    if (res == S_OK)
      res = S_FALSE;
    
    if (unpackedSize > outSize)
      res = S_FALSE;
    else
      memset(unpackBuf.Data + unpackedSize, 0, outSize - unpackedSize);
  }
  
  if (outStream)
  {
    RINOK(WriteStream(outStream, unpackBuf.Data, outSize));
  }
  
  return res;
}


HRESULT CUnpacker::Unpack2(
    IInStream *inStream,
    const CResource &resource,
    const CHeader &header,
    const CDatabase *db,
    ISequentialOutStream *outStream,
    ICompressProgressInfo *progress)
{
  if (!resource.IsCompressed() && !resource.IsSolid())
  {
    if (!copyCoder)
    {
      copyCoderSpec = new NCompress::CCopyCoder;
      copyCoder = copyCoderSpec;
    }

    CLimitedSequentialInStream *limitedStreamSpec = new CLimitedSequentialInStream();
    CMyComPtr<ISequentialInStream> limitedStream = limitedStreamSpec;
    limitedStreamSpec->SetStream(inStream);
    
    RINOK(inStream->Seek(resource.Offset, STREAM_SEEK_SET, NULL));
    if (resource.PackSize != resource.UnpackSize)
      return S_FALSE;

    limitedStreamSpec->Init(resource.PackSize);
    TotalPacked += resource.PackSize;
    
    HRESULT res = copyCoder->Code(limitedStream, outStream, NULL, NULL, progress);
    
    if (res == S_OK && copyCoderSpec->TotalSize != resource.UnpackSize)
      res = S_FALSE;
    return res;
  }
  
  if (resource.IsSolid())
  {
    if (!db || resource.SolidIndex < 0)
      return E_NOTIMPL;
    if (resource.IsCompressed())
      return E_NOTIMPL;

    const CSolid &ss = db->Solids[resource.SolidIndex];
    
    const unsigned chunkSizeBits = ss.ChunkSizeBits;
    const size_t chunkSize = (size_t)1 << chunkSizeBits;
    
    size_t chunkIndex = 0;
    UInt64 rem = ss.UnpackSize;
    size_t offsetInChunk = 0;
    
    if (resource.IsSolidSmall())
    {
      UInt64 offs = resource.Offset;
      if (offs < ss.SolidOffset)
        return E_NOTIMPL;
      offs -= ss.SolidOffset;
      if (offs > ss.UnpackSize)
        return E_NOTIMPL;
      rem = resource.PackSize;
      if (rem > ss.UnpackSize - offs)
        return E_NOTIMPL;
      chunkIndex = (size_t)(offs >> chunkSizeBits);
      offsetInChunk = (size_t)offs & (chunkSize - 1);
    }
    
    UInt64 packProcessed = 0;
    UInt64 outProcessed = 0;
    
    if (_solidIndex == resource.SolidIndex && _unpackedChunkIndex == chunkIndex)
    {
      size_t cur = chunkSize - offsetInChunk;
      if (cur > rem)
        cur = (size_t)rem;
      RINOK(WriteStream(outStream, unpackBuf.Data + offsetInChunk, cur));
      outProcessed += cur;
      rem -= cur;
      offsetInChunk = 0;
      chunkIndex++;
    }
    
    for (;;)
    {
      if (rem == 0)
        return S_OK;
    
      UInt64 offset = ss.Chunks[chunkIndex];
      UInt64 packSize = ss.GetChunkPackSize(chunkIndex);
      const CResource &rs = db->DataStreams[ss.StreamIndex].Resource;
      RINOK(inStream->Seek(rs.Offset + ss.HeadersSize + offset, STREAM_SEEK_SET, NULL));
      
      size_t cur = chunkSize;
      UInt64 unpackRem = ss.UnpackSize - ((UInt64)chunkIndex << chunkSizeBits);
      if (cur > unpackRem)
        cur = (size_t)unpackRem;
      
      _solidIndex = -1;
      _unpackedChunkIndex = 0;
      
      HRESULT res = UnpackChunk(inStream, ss.Method, chunkSizeBits, (size_t)packSize, cur, NULL);
      
      if (res != S_OK)
      {
        // We ignore data errors in solid stream. SHA will show what files are bad.
        if (res != S_FALSE)
          return res;
      }
      
      _solidIndex = resource.SolidIndex;
      _unpackedChunkIndex = chunkIndex;

      if (cur < offsetInChunk)
        return E_FAIL;
      
      cur -= offsetInChunk;
        
      if (cur > rem)
        cur = (size_t)rem;
      
      RINOK(WriteStream(outStream, unpackBuf.Data + offsetInChunk, cur));
      
      if (progress)
      {
        RINOK(progress->SetRatioInfo(&packProcessed, &outProcessed));
        packProcessed += packSize;
        outProcessed += cur;
      }
      
      rem -= cur;
      offsetInChunk = 0;
      chunkIndex++;
    }
  }


  // ---------- NON Solid ----------

  const UInt64 unpackSize = resource.UnpackSize;
  if (unpackSize == 0)
  {
    if (resource.PackSize == 0)
      return S_OK;
    return S_FALSE;
  }

  if (unpackSize > ((UInt64)1 << 63))
    return E_NOTIMPL;

  const unsigned chunkSizeBits = header.ChunkSizeBits;
  const unsigned entrySizeShifts = (resource.UnpackSize < ((UInt64)1 << 32) ? 2 : 3);

  UInt64 baseOffset = resource.Offset;
  UInt64 packDataSize;
  size_t numChunks;
  {
    UInt64 numChunks64 = (unpackSize + (((UInt32)1 << chunkSizeBits) - 1)) >> chunkSizeBits;
    UInt64 sizesBufSize64 = (numChunks64 - 1) << entrySizeShifts;
    if (sizesBufSize64 > resource.PackSize)
      return S_FALSE;
    packDataSize = resource.PackSize - sizesBufSize64;
    size_t sizesBufSize = (size_t)sizesBufSize64;
    if (sizesBufSize != sizesBufSize64)
      return E_OUTOFMEMORY;
    sizesBuf.AllocAtLeast(sizesBufSize);
    RINOK(inStream->Seek(baseOffset, STREAM_SEEK_SET, NULL));
    RINOK(ReadStream_FALSE(inStream, sizesBuf, sizesBufSize));
    baseOffset += sizesBufSize64;
    numChunks = (size_t)numChunks64;
  }

  _solidIndex = -1;
  _unpackedChunkIndex = 0;

  UInt64 outProcessed = 0;
  UInt64 offset = 0;
  
  for (size_t i = 0; i < numChunks; i++)
  {
    UInt64 nextOffset = packDataSize;
    
    if (i + 1 < numChunks)
    {
      const Byte *p = (const Byte *)sizesBuf + (i << entrySizeShifts);
      nextOffset = (entrySizeShifts == 2) ? Get32(p): Get64(p);
    }
    
    if (nextOffset < offset)
      return S_FALSE;

    UInt64 inSize64 = nextOffset - offset;
    size_t inSize = (size_t)inSize64;
    if (inSize != inSize64)
      return S_FALSE;

    RINOK(inStream->Seek(baseOffset + offset, STREAM_SEEK_SET, NULL));

    if (progress)
    {
      RINOK(progress->SetRatioInfo(&offset, &outProcessed));
    }
    
    size_t outSize = (size_t)1 << chunkSizeBits;
    const UInt64 rem = unpackSize - outProcessed;
    if (outSize > rem)
      outSize = (size_t)rem;

    RINOK(UnpackChunk(inStream, header.GetMethod(), chunkSizeBits, inSize, outSize, outStream));

    outProcessed += outSize;
    offset = nextOffset;
  }
  
  return S_OK;
}


HRESULT CUnpacker::Unpack(IInStream *inStream, const CResource &resource, const CHeader &header, const CDatabase *db,
    ISequentialOutStream *outStream, ICompressProgressInfo *progress, Byte *digest)
{
  COutStreamWithSha1 *shaStreamSpec = NULL;
  CMyComPtr<ISequentialOutStream> shaStream;
  
  // outStream can be NULL, so we use COutStreamWithSha1 even if sha1 is not required
  // if (digest)
  {
    shaStreamSpec = new COutStreamWithSha1();
    shaStream = shaStreamSpec;
    shaStreamSpec->SetStream(outStream);
    shaStreamSpec->Init(digest != NULL);
    outStream = shaStream;
  }
  
  HRESULT res = Unpack2(inStream, resource, header, db, outStream, progress);
  
  if (digest)
    shaStreamSpec->Final(digest);
  
  return res;
}


HRESULT CUnpacker::UnpackData(IInStream *inStream,
    const CResource &resource, const CHeader &header,
    const CDatabase *db,
    CByteBuffer &buf, Byte *digest)
{
  // if (resource.IsSolid()) return E_NOTIMPL;

  UInt64 unpackSize64 = resource.UnpackSize;
  if (db)
    unpackSize64 = db->Get_UnpackSize_of_Resource(resource);

  size_t size = (size_t)unpackSize64;
  if (size != unpackSize64)
    return E_OUTOFMEMORY;

  buf.Alloc(size);

  CBufPtrSeqOutStream *outStreamSpec = new CBufPtrSeqOutStream();
  CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
  outStreamSpec->Init((Byte *)buf, size);

  return Unpack(inStream, resource, header, db, outStream, NULL, digest);
}


void CResource::Parse(const Byte *p)
{
  Flags = p[7];
  PackSize = Get64(p) & (((UInt64)1 << 56) - 1);
  Offset = Get64(p + 8);
  UnpackSize = Get64(p + 16);
  KeepSolid = false;
  SolidIndex = -1;
}

#define GET_RESOURCE(_p_, res) res.ParseAndUpdatePhySize(_p_, phySize)

static inline void ParseStream(bool oldVersion, const Byte *p, CStreamInfo &s)
{
  s.Resource.Parse(p);
  if (oldVersion)
  {
    s.PartNumber = 1;
    s.Id = Get32(p + 24);
    p += 28;
  }
  else
  {
    s.PartNumber = Get16(p + 24);
    p += 26;
  }
  s.RefCount = Get32(p);
  memcpy(s.Hash, p + 4, kHashSize);
}


static const char *kLongPath = "[LongPath]";

void CDatabase::GetShortName(unsigned index, NWindows::NCOM::CPropVariant &name) const
{
  const CItem &item = Items[index];
  const CImage &image = Images[item.ImageIndex];
  if (item.Parent < 0 && image.NumEmptyRootItems != 0)
  {
    name.Clear();
    return;
  }
  const Byte *meta = image.Meta + item.Offset +
      (IsOldVersion ? kDirRecordSizeOld : kDirRecordSize);
  UInt32 fileNameLen = Get16(meta - 2);
  UInt32 shortLen = Get16(meta - 4) / 2;
  wchar_t *s = name.AllocBstr(shortLen);
  if (fileNameLen != 0)
    meta += fileNameLen + 2;
  for (UInt32 i = 0; i < shortLen; i++)
    s[i] = Get16(meta + i * 2);
  s[shortLen] = 0;
  // empty shortName has no ZERO at the end ?
}


void CDatabase::GetItemName(unsigned index, NWindows::NCOM::CPropVariant &name) const
{
  const CItem &item = Items[index];
  const CImage &image = Images[item.ImageIndex];
  if (item.Parent < 0 && image.NumEmptyRootItems != 0)
  {
    name = image.RootName;
    return;
  }
  const Byte *meta = image.Meta + item.Offset +
      (item.IsAltStream ?
      (IsOldVersion ? 0x10 : 0x24) :
      (IsOldVersion ? kDirRecordSizeOld - 2 : kDirRecordSize - 2));
  UInt32 len = Get16(meta) / 2;
  wchar_t *s = name.AllocBstr(len);
  meta += 2;
  len++;
  for (UInt32 i = 0; i < len; i++)
    s[i] = Get16(meta + i * 2);
}


void CDatabase::GetItemPath(unsigned index1, bool showImageNumber, NWindows::NCOM::CPropVariant &path) const
{
  unsigned size = 0;
  int index = index1;
  int imageIndex = Items[index].ImageIndex;
  const CImage &image = Images[imageIndex];
  
  unsigned newLevel = 0;
  bool needColon = false;

  for (;;)
  {
    const CItem &item = Items[index];
    index = item.Parent;
    if (index >= 0 || image.NumEmptyRootItems == 0)
    {
      const Byte *meta = image.Meta + item.Offset;
      meta += item.IsAltStream ?
          (IsOldVersion ? 0x10 : 0x24) :
          (IsOldVersion ? kDirRecordSizeOld - 2 : kDirRecordSize - 2);
      needColon = item.IsAltStream;
      size += Get16(meta) / 2;
      size += newLevel;
      newLevel = 1;
      if (size >= ((UInt32)1 << 15))
      {
        path = kLongPath;
        return;
      }
    }
    if (index < 0)
      break;
  }

  if (showImageNumber)
  {
    size += image.RootName.Len();
    size += newLevel;
  }
  else if (needColon)
    size++;

  wchar_t *s = path.AllocBstr(size);
  s[size] = 0;
  
  if (showImageNumber)
  {
    MyStringCopy(s, (const wchar_t *)image.RootName);
    if (newLevel)
      s[image.RootName.Len()] = (wchar_t)(needColon ? L':' : WCHAR_PATH_SEPARATOR);
  }
  else if (needColon)
    s[0] = L':';

  index = index1;
  wchar_t separator = 0;
  
  for (;;)
  {
    const CItem &item = Items[index];
    index = item.Parent;
    if (index >= 0 || image.NumEmptyRootItems == 0)
    {
      if (separator != 0)
        s[--size] = separator;
      const Byte *meta = image.Meta + item.Offset;
      meta += (item.IsAltStream) ?
          (IsOldVersion ? 0x10: 0x24) :
          (IsOldVersion ? kDirRecordSizeOld - 2 : kDirRecordSize - 2);
      unsigned len = Get16(meta) / 2;
      size -= len;
      wchar_t *dest = s + size;
      meta += 2;
      for (unsigned i = 0; i < len; i++)
        dest[i] = Get16(meta + i * 2);
    }
    if (index < 0)
      return;
    separator = item.IsAltStream ? L':' : WCHAR_PATH_SEPARATOR;
  }
}


// if (ver <= 1.10), root folder contains real items.
// if (ver >= 1.12), root folder contains only one folder with empty name.

HRESULT CDatabase::ParseDirItem(size_t pos, int parent)
{
  const unsigned align = GetDirAlignMask();
  if ((pos & align) != 0)
    return S_FALSE;

  for (unsigned numItems = 0;; numItems++)
  {
    if (OpenCallback && (Items.Size() & 0xFFFF) == 0)
    {
      UInt64 numFiles = Items.Size();
      RINOK(OpenCallback->SetCompleted(&numFiles, NULL));
    }
    
    const size_t rem = DirSize - pos;
    if (pos < DirStartOffset || pos > DirSize || rem < 8)
      return S_FALSE;

    const Byte *p = DirData + pos;

    UInt64 len = Get64(p);
    if (len == 0)
    {
      DirProcessed += 8;
      return S_OK;
    }
    
    if ((len & align) != 0 || rem < len)
      return S_FALSE;
    
    DirProcessed += (size_t)len;
    if (DirProcessed > DirSize)
      return S_FALSE;

    const unsigned dirRecordSize = IsOldVersion ? kDirRecordSizeOld : kDirRecordSize;
    if (len < dirRecordSize)
      return S_FALSE;

    CItem item;
    UInt32 attrib = Get32(p + 8);
    item.IsDir = ((attrib & 0x10) != 0);
    UInt64 subdirOffset = Get64(p + 0x10);

    const UInt32 numAltStreams = Get16(p + dirRecordSize - 6);
    const UInt32 shortNameLen = Get16(p + dirRecordSize - 4);
    const UInt32 fileNameLen = Get16(p + dirRecordSize - 2);
    if ((shortNameLen & 1) != 0 || (fileNameLen & 1) != 0)
      return S_FALSE;
    const UInt32 shortNameLen2 = (shortNameLen == 0 ? shortNameLen : shortNameLen + 2);
    const UInt32 fileNameLen2 = (fileNameLen == 0 ? fileNameLen : fileNameLen + 2);
    if (((dirRecordSize + fileNameLen2 + shortNameLen2 + align) & ~align) > len)
      return S_FALSE;
    
    p += dirRecordSize;
    
    {
      if (*(const UInt16 *)(p + fileNameLen) != 0)
        return S_FALSE;
      for (UInt32 j = 0; j < fileNameLen; j += 2)
        if (*(const UInt16 *)(p + j) == 0)
          return S_FALSE;
    }

    // PRF(printf("\n%S", p));

    if (shortNameLen != 0)
    {
      // empty shortName has no ZERO at the end ?
      const Byte *p2 = p + fileNameLen2;
      if (*(const UInt16 *)(p2 + shortNameLen) != 0)
        return S_FALSE;
      for (UInt32 j = 0; j < shortNameLen; j += 2)
        if (*(const UInt16 *)(p2 + j) == 0)
          return S_FALSE;
    }
      
    item.Offset = pos;
    item.Parent = parent;
    item.ImageIndex = Images.Size() - 1;
    
    const unsigned prevIndex = Items.Add(item);

    pos += (size_t)len;

    for (UInt32 i = 0; i < numAltStreams; i++)
    {
      const size_t rem2 = DirSize - pos;
      if (pos < DirStartOffset || pos > DirSize || rem2 < 8)
        return S_FALSE;
      const Byte *p2 = DirData + pos;
      const UInt64 len2 = Get64(p2);
      if ((len2 & align) != 0 || rem2 < len2 || len2 < (IsOldVersion ? 0x18 : 0x28))
        return S_FALSE;
     
      DirProcessed += (size_t)len2;
      if (DirProcessed > DirSize)
        return S_FALSE;

      unsigned extraOffset = 0;
      
      if (IsOldVersion)
        extraOffset = 0x10;
      else
      {
        if (Get64(p2 + 8) != 0)
          return S_FALSE;
        extraOffset = 0x24;
      }
      
      const UInt32 fileNameLen111 = Get16(p2 + extraOffset);
      if ((fileNameLen111 & 1) != 0)
        return S_FALSE;
      /* Probably different versions of ImageX can use different number of
         additional ZEROs. So we don't use exact check. */
      const UInt32 fileNameLen222 = (fileNameLen111 == 0 ? fileNameLen111 : fileNameLen111 + 2);
      if (((extraOffset + 2 + fileNameLen222 + align) & ~align) > len2)
        return S_FALSE;
      
      {
        const Byte *p3 = p2 + extraOffset + 2;
        if (*(const UInt16 *)(p3 + fileNameLen111) != 0)
          return S_FALSE;
        for (UInt32 j = 0; j < fileNameLen111; j += 2)
          if (*(const UInt16 *)(p3 + j) == 0)
            return S_FALSE;
  
        // PRF(printf("\n  %S", p3));
      }


      /* wim uses alt sreams list, if there is at least one alt stream.
         And alt stream without name is main stream. */

      // Why wimlib writes two alt streams for REPARSE_POINT, with empty second alt stream?
      
      Byte *prevMeta = DirData + item.Offset;

      if (fileNameLen111 == 0 &&
          ((attrib & FILE_ATTRIBUTE_REPARSE_POINT) || !item.IsDir)
          && (IsOldVersion || IsEmptySha(prevMeta + 0x40)))
      {
        if (IsOldVersion)
          memcpy(prevMeta + 0x10, p2 + 8, 4); // It's 32-bit Id
        else if (!IsEmptySha(p2 + 0x10))
        {
          // if (IsEmptySha(prevMeta + 0x40))
            memcpy(prevMeta + 0x40, p2 + 0x10, kHashSize);
          // else HeadersError = true;
        }
      }
      else
      {
        ThereAreAltStreams = true;
        CItem item2;
        item2.Offset = pos;
        item2.IsAltStream = true;
        item2.Parent = prevIndex;
        item2.ImageIndex = Images.Size() - 1;
        Items.Add(item2);
      }

      pos += (size_t)len2;
    }

    if (parent < 0 && numItems == 0 && shortNameLen == 0 && fileNameLen == 0 && item.IsDir)
    {
      const Byte *p2 = DirData + pos;
      if (DirSize - pos >= 8 && Get64(p2) == 0)
      {
        CImage &image = Images.Back();
        image.NumEmptyRootItems = 1;

        if (subdirOffset != 0
            && DirSize - pos >= 16
            && Get64(p2 + 8) != 0
            && pos + 8 < subdirOffset)
        {
          // Longhorn.4093 contains hidden files after empty root folder and before items of next folder. Why?
          // That code shows them. If we want to ignore them, we need to update DirProcessed.
          // DirProcessed += (size_t)(subdirOffset - (pos + 8));
          // printf("\ndirOffset = %5d hiddenOffset = %5d\n", (int)subdirOffset, (int)pos + 8);
          subdirOffset = pos + 8;
          // return S_FALSE;
        }
      }
    }

    if (item.IsDir && subdirOffset != 0)
    {
      RINOK(ParseDirItem((size_t)subdirOffset, prevIndex));
    }
  }
}


HRESULT CDatabase::ParseImageDirs(CByteBuffer &buf, int parent)
{
  DirData = buf;
  DirSize = buf.Size();
  if (DirSize < 8)
    return S_FALSE;
  const Byte *p = DirData;
  size_t pos = 0;
  CImage &image = Images.Back();

  if (IsOldVersion)
  {
    UInt32 numEntries = Get32(p + 4);

    if (numEntries > (1 << 28) ||
        numEntries > (DirSize >> 3))
      return S_FALSE;

    UInt32 sum = 8;
    if (numEntries != 0)
      sum = numEntries * 8;

    image.SecurOffsets.ClearAndReserve(numEntries + 1);
    image.SecurOffsets.AddInReserved(sum);

    for (UInt32 i = 0; i < numEntries; i++)
    {
      const Byte *pp = p + (size_t)i * 8;
      UInt32 len = Get32(pp);
      if (i != 0 && Get32(pp + 4) != 0)
        return S_FALSE;
      if (len > DirSize - sum)
        return S_FALSE;
      sum += len;
      if (sum < len)
        return S_FALSE;
      image.SecurOffsets.AddInReserved(sum);
    }

    pos = sum;

    const size_t align = GetDirAlignMask();
    pos = (pos + align) & ~(size_t)align;
  }
  else
  {
    UInt32 totalLen = Get32(p);
    if (totalLen == 0)
      pos = 8;
    else
    {
      if (totalLen < 8)
        return S_FALSE;
      UInt32 numEntries = Get32(p + 4);
      pos = 8;
      if (totalLen > DirSize || numEntries > ((totalLen - 8) >> 3))
        return S_FALSE;
      UInt32 sum = (UInt32)pos + numEntries * 8;
      image.SecurOffsets.ClearAndReserve(numEntries + 1);
      image.SecurOffsets.AddInReserved(sum);
      
      for (UInt32 i = 0; i < numEntries; i++, pos += 8)
      {
        UInt64 len = Get64(p + pos);
        if (len > totalLen - sum)
          return S_FALSE;
        sum += (UInt32)len;
        image.SecurOffsets.AddInReserved(sum);
      }
      
      pos = sum;
      pos = (pos + 7) & ~(size_t)7;
      if (pos != (((size_t)totalLen + 7) & ~(size_t)7))
        return S_FALSE;
    }
  }
  
  if (pos > DirSize)
    return S_FALSE;
  
  DirStartOffset = DirProcessed = pos;
  image.StartItem = Items.Size();

  RINOK(ParseDirItem(pos, parent));
  
  image.NumItems = Items.Size() - image.StartItem;
  if (DirProcessed == DirSize)
    return S_OK;

  /* Original program writes additional 8 bytes (END_OF_ROOT_FOLDER),
     but the reference to that folder is empty */

  // we can't use DirProcessed - DirStartOffset == 112 check if there is alt stream in root
  if (DirProcessed == DirSize - 8 && Get64(p + DirSize - 8) != 0)
    return S_OK;

  return S_FALSE;
}


HRESULT CHeader::Parse(const Byte *p, UInt64 &phySize)
{
  UInt32 headerSize = Get32(p + 8);
  phySize = headerSize;
  Version = Get32(p + 0x0C);
  Flags = Get32(p + 0x10);
  if (!IsSupported())
    return S_FALSE;
  
  {
    ChunkSize = Get32(p + 0x14);
    ChunkSizeBits = kChunkSizeBits;
    if (ChunkSize != 0)
    {
      int log = GetLog(ChunkSize);
      if (log < 12)
        return S_FALSE;
      ChunkSizeBits = log;
    }
  }

  _IsOldVersion = false;
  _IsNewVersion = false;
  
  if (IsSolidVersion())
    _IsNewVersion = true;
  else
  {
    if (Version < 0x010900)
      return S_FALSE;
    _IsOldVersion = (Version <= 0x010A00);
    // We don't know details about 1.11 version. So we use headerSize to guess exact features.
    if (Version == 0x010B00 && headerSize == 0x60)
      _IsOldVersion = true;
    _IsNewVersion = (Version >= 0x010D00);
  }

  unsigned offset;
  
  if (IsOldVersion())
  {
    if (headerSize != 0x60)
      return S_FALSE;
    memset(Guid, 0, 16);
    offset = 0x18;
    PartNumber = 1;
    NumParts = 1;
  }
  else
  {
    if (headerSize < 0x74)
      return S_FALSE;
    memcpy(Guid, p + 0x18, 16);
    PartNumber = Get16(p + 0x28);
    NumParts = Get16(p + 0x2A);
    if (PartNumber == 0 || PartNumber > NumParts)
      return S_FALSE;
    offset = 0x2C;
    if (IsNewVersion())
    {
      // if (headerSize < 0xD0)
      if (headerSize != 0xD0)
        return S_FALSE;
      NumImages = Get32(p + offset);
      offset += 4;
    }
  }
  
  GET_RESOURCE(p + offset       , OffsetResource);
  GET_RESOURCE(p + offset + 0x18, XmlResource);
  GET_RESOURCE(p + offset + 0x30, MetadataResource);
  BootIndex = 0;
  
  if (IsNewVersion())
  {
    BootIndex = Get32(p + offset + 0x48);
    GET_RESOURCE(p + offset + 0x4C, IntegrityResource);
  }

  return S_OK;
}


const Byte kSignature[kSignatureSize] = { 'M', 'S', 'W', 'I', 'M', 0, 0, 0 };

HRESULT ReadHeader(IInStream *inStream, CHeader &h, UInt64 &phySize)
{
  Byte p[kHeaderSizeMax];
  RINOK(ReadStream_FALSE(inStream, p, kHeaderSizeMax));
  if (memcmp(p, kSignature, kSignatureSize) != 0)
    return S_FALSE;
  return h.Parse(p, phySize);
}


static HRESULT ReadStreams(IInStream *inStream, const CHeader &h, CDatabase &db)
{
  CByteBuffer offsetBuf;
  
  CUnpacker unpacker;
  RINOK(unpacker.UnpackData(inStream, h.OffsetResource, h, NULL, offsetBuf, NULL));
  
  const size_t streamInfoSize = h.IsOldVersion() ? kStreamInfoSize + 2 : kStreamInfoSize;
  {
    const unsigned numItems = (unsigned)(offsetBuf.Size() / streamInfoSize);
    if ((size_t)numItems * streamInfoSize != offsetBuf.Size())
      return S_FALSE;
    const unsigned numItems2 = db.DataStreams.Size() + numItems;
    if (numItems2 < numItems)
      return S_FALSE;
    db.DataStreams.Reserve(numItems2);
  }

  bool keepSolid = false;

  for (size_t i = 0; i < offsetBuf.Size(); i += streamInfoSize)
  {
    CStreamInfo s;
    ParseStream(h.IsOldVersion(), (const Byte *)offsetBuf + i, s);

    PRF(printf("\n"));
    PRF(printf(s.Resource.IsMetadata() ? "### META" : "    DATA"));
    PRF(printf(" %2X", s.Resource.Flags));
    PRF(printf(" %9I64X", s.Resource.Offset));
    PRF(printf(" %9I64X", s.Resource.PackSize));
    PRF(printf(" %9I64X", s.Resource.UnpackSize));
    PRF(printf(" %d", s.RefCount));
    
    if (s.PartNumber != h.PartNumber)
      continue;

    if (s.Resource.IsSolid())
    {
      s.Resource.KeepSolid = keepSolid;
      keepSolid = true;
    }
    else
    {
      s.Resource.KeepSolid = false;
      keepSolid = false;
    }

    if (!s.Resource.IsMetadata())
      db.DataStreams.AddInReserved(s);
    else
    {
      if (s.Resource.IsSolid())
        return E_NOTIMPL;
      if (s.RefCount == 0)
      {
        // some wims have such (deleted?) metadata stream.
        // examples: boot.wim in VistaBeta2, WinPE.wim from WAIK.
        // db.DataStreams.Add(s);
        // we can show these delete images, if we comment "continue" command;
        continue;
      }
      
      if (s.RefCount > 1)
      {
        return S_FALSE;
        // s.RefCount--;
        // db.DataStreams.Add(s);
      }

      db.MetaStreams.Add(s);
    }
  }
  
  PRF(printf("\n"));
  
  return S_OK;
}


HRESULT CDatabase::OpenXml(IInStream *inStream, const CHeader &h, CByteBuffer &xml)
{
  CUnpacker unpacker;
  return unpacker.UnpackData(inStream, h.XmlResource, h, this, xml, NULL);
}

static void SetRootNames(CImage &image, unsigned value)
{
  wchar_t temp[16];
  ConvertUInt32ToString(value, temp);
  image.RootName = temp;
  image.RootNameBuf.Alloc(image.RootName.Len() * 2 + 2);
  Byte *p = image.RootNameBuf;
  unsigned len = image.RootName.Len() + 1;
  for (unsigned k = 0; k < len; k++)
  {
    p[k * 2] = (Byte)temp[k];
    p[k * 2 + 1] = 0;
  }
}


HRESULT CDatabase::Open(IInStream *inStream, const CHeader &h, unsigned numItemsReserve, IArchiveOpenCallback *openCallback)
{
  OpenCallback = openCallback;
  IsOldVersion = h.IsOldVersion();
  IsOldVersion9 = (h.Version == 0x10900);

  RINOK(ReadStreams(inStream, h, *this));

  bool needBootMetadata = !h.MetadataResource.IsEmpty();
  unsigned numNonDeletedImages = 0;

  CUnpacker unpacker;

  FOR_VECTOR (i, MetaStreams)
  {
    const CStreamInfo &si = MetaStreams[i];

    if (h.PartNumber != 1 || si.PartNumber != h.PartNumber)
      continue;

    const int userImage = Images.Size() + GetStartImageIndex();
    CImage &image = Images.AddNew();
    SetRootNames(image, userImage);
    
    CByteBuffer &metadata = image.Meta;
    Byte hash[kHashSize];
    
    RINOK(unpacker.UnpackData(inStream, si.Resource, h, this, metadata, hash));
   
    if (memcmp(hash, si.Hash, kHashSize) != 0 &&
        !(h.IsOldVersion() && IsEmptySha(si.Hash)))
      return S_FALSE;
    
    image.NumEmptyRootItems = 0;
    
    if (Items.IsEmpty())
      Items.ClearAndReserve(numItemsReserve);

    RINOK(ParseImageDirs(metadata, -1));
    
    if (needBootMetadata)
    {
      bool sameRes = (h.MetadataResource.Offset == si.Resource.Offset);
      if (sameRes)
        needBootMetadata = false;
      if (h.IsNewVersion())
      {
        if (si.RefCount == 1)
        {
          numNonDeletedImages++;
          bool isBootIndex = (h.BootIndex == numNonDeletedImages);
          if (sameRes && !isBootIndex)
            return S_FALSE;
          if (isBootIndex && !sameRes)
            return S_FALSE;
        }
      }
    }
  }
  
  if (needBootMetadata)
    return S_FALSE;
  return S_OK;
}


bool CDatabase::ItemHasStream(const CItem &item) const
{
  if (item.ImageIndex < 0)
    return true;
  const Byte *meta = Images[item.ImageIndex].Meta + item.Offset;
  if (IsOldVersion)
  {
    // old wim use same field for file_id and dir_offset;
    if (item.IsDir)
      return false;
    meta += (item.IsAltStream ? 0x8 : 0x10);
    UInt32 id = GetUi32(meta);
    return id != 0;
  }
  meta += (item.IsAltStream ? 0x10 : 0x40);
  return !IsEmptySha(meta);
}


#define RINOZ(x) { int __tt = (x); if (__tt != 0) return __tt; }

static int CompareStreamsByPos(const CStreamInfo *p1, const CStreamInfo *p2, void * /* param */)
{
  RINOZ(MyCompare(p1->PartNumber, p2->PartNumber));
  RINOZ(MyCompare(p1->Resource.Offset, p2->Resource.Offset));
  return MyCompare(p1->Resource.PackSize, p2->Resource.PackSize);
}

static int CompareIDs(const unsigned *p1, const unsigned *p2, void *param)
{
  const CStreamInfo *streams = (const CStreamInfo *)param;
  return MyCompare(streams[*p1].Id, streams[*p2].Id);
}

static int CompareHashRefs(const unsigned *p1, const unsigned *p2, void *param)
{
  const CStreamInfo *streams = (const CStreamInfo *)param;
  return memcmp(streams[*p1].Hash, streams[*p2].Hash, kHashSize);
}

static int FindId(const CStreamInfo *streams, const CUIntVector &sorted, UInt32 id)
{
  unsigned left = 0, right = sorted.Size();
  while (left != right)
  {
    unsigned mid = (left + right) / 2;
    unsigned streamIndex = sorted[mid];
    UInt32 id2 = streams[streamIndex].Id;
    if (id == id2)
      return streamIndex;
    if (id < id2)
      right = mid;
    else
      left = mid + 1;
  }
  return -1;
}

static int FindHash(const CStreamInfo *streams, const CUIntVector &sorted, const Byte *hash)
{
  unsigned left = 0, right = sorted.Size();
  while (left != right)
  {
    unsigned mid = (left + right) / 2;
    unsigned streamIndex = sorted[mid];
    const Byte *hash2 = streams[streamIndex].Hash;
    unsigned i;
    for (i = 0; i < kHashSize; i++)
      if (hash[i] != hash2[i])
        break;
    if (i == kHashSize)
      return streamIndex;
    if (hash[i] < hash2[i])
      right = mid;
    else
      left = mid + 1;
  }
  return -1;
}

static int CompareItems(const unsigned *a1, const unsigned *a2, void *param)
{
  const CRecordVector<CItem> &items = ((CDatabase *)param)->Items;
  const CItem &i1 = items[*a1];
  const CItem &i2 = items[*a2];

  if (i1.IsDir != i2.IsDir)
    return i1.IsDir ? -1 : 1;
  if (i1.IsAltStream != i2.IsAltStream)
    return i1.IsAltStream ? 1 : -1;
  RINOZ(MyCompare(i1.StreamIndex, i2.StreamIndex));
  RINOZ(MyCompare(i1.ImageIndex, i2.ImageIndex));
  return MyCompare(i1.Offset, i2.Offset);
}


HRESULT CDatabase::FillAndCheck(const CObjectVector<CVolume> &volumes)
{
  CUIntVector sortedByHash;
  sortedByHash.Reserve(DataStreams.Size());
  {
    CByteBuffer sizesBuf;

    for (unsigned iii = 0; iii < DataStreams.Size();)
    {
      {
        const CResource &r = DataStreams[iii].Resource;
        if (!r.IsSolid())
        {
          sortedByHash.AddInReserved(iii++);
          continue;
        }
      }

      UInt64 solidRunOffset = 0;
      unsigned k;
      unsigned numSolidsStart = Solids.Size();

      for (k = iii; k < DataStreams.Size(); k++)
      {
        CStreamInfo &si = DataStreams[k];
        CResource &r = si.Resource;

        if (!r.IsSolid())
          break;
        if (!r.KeepSolid && k != iii)
          break;

        if (r.Flags != NResourceFlags::kSolid)
          return S_FALSE;

        if (!r.IsSolidBig())
          continue;

        if (!si.IsEmptyHash())
          return S_FALSE;
        if (si.RefCount != 1)
          return S_FALSE;

        r.SolidIndex = Solids.Size();

        CSolid &ss = Solids.AddNew();
        ss.StreamIndex = k;
        ss.SolidOffset = solidRunOffset;
        {
          const size_t kSolidHeaderSize = 8 + 4 + 4;
          Byte header[kSolidHeaderSize];

          if (si.PartNumber >= volumes.Size())
            return S_FALSE;

          const CVolume &vol = volumes[si.PartNumber];
          IInStream *inStream = vol.Stream;
          RINOK(inStream->Seek(r.Offset, STREAM_SEEK_SET, NULL));
          RINOK(ReadStream_FALSE(inStream, (Byte *)header, kSolidHeaderSize));
          
          ss.UnpackSize = GetUi64(header);

          if (ss.UnpackSize > ((UInt64)1 << 63))
            return S_FALSE;

          solidRunOffset += ss.UnpackSize;
          if (solidRunOffset < ss.UnpackSize)
            return S_FALSE;

          const UInt32 solidChunkSize = GetUi32(header + 8);
          int log = GetLog(solidChunkSize);
          if (log < 8 || log > 31)
            return S_FALSE;
          ss.ChunkSizeBits = log;
          ss.Method = GetUi32(header + 12);
          
          UInt64 numChunks64 = (ss.UnpackSize + (((UInt32)1 << ss.ChunkSizeBits) - 1)) >> ss.ChunkSizeBits;
          UInt64 sizesBufSize64 = 4 * numChunks64;
          ss.HeadersSize = kSolidHeaderSize + sizesBufSize64;
          size_t sizesBufSize = (size_t)sizesBufSize64;
          if (sizesBufSize != sizesBufSize64)
            return E_OUTOFMEMORY;
          sizesBuf.AllocAtLeast(sizesBufSize);
          
          RINOK(ReadStream_FALSE(inStream, sizesBuf, sizesBufSize));
          
          size_t numChunks = (size_t)numChunks64;
          ss.Chunks.Alloc(numChunks + 1);

          UInt64 offset = 0;
          
          size_t c;
          for (c = 0; c < numChunks; c++)
          {
            ss.Chunks[c] = offset;
            UInt32 packSize = GetUi32((const Byte *)sizesBuf + c * 4);
            offset += packSize;
            if (offset < packSize)
              return S_FALSE;
          }
          ss.Chunks[c] = offset;

          if (ss.Chunks[0] != 0)
            return S_FALSE;
          if (ss.HeadersSize + offset != r.PackSize)
            return S_FALSE;
        }
      }
      
      unsigned solidLim = k;

      for (k = iii; k < solidLim; k++)
      {
        CStreamInfo &si = DataStreams[k];
        CResource &r = si.Resource;

        if (!r.IsSolidSmall())
          continue;

        if (si.IsEmptyHash())
          return S_FALSE;

        unsigned solidIndex;
        {
          UInt64 offset = r.Offset;
          for (solidIndex = numSolidsStart;; solidIndex++)
          {
            if (solidIndex == Solids.Size())
              return S_FALSE;
            UInt64 unpackSize = Solids[solidIndex].UnpackSize;
            if (offset < unpackSize)
              break;
            offset -= unpackSize;
          }
        }
        CSolid &ss = Solids[solidIndex];
        if (r.Offset < ss.SolidOffset)
          return S_FALSE;
        UInt64 relat = r.Offset - ss.SolidOffset;
        if (relat > ss.UnpackSize)
          return S_FALSE;
        if (r.PackSize > ss.UnpackSize - relat)
          return S_FALSE;
        r.SolidIndex = solidIndex;
        if (ss.FirstSmallStream < 0)
          ss.FirstSmallStream = k;

        sortedByHash.AddInReserved(k);
        // ss.NumRefs++;
      }
      
      iii = solidLim;
    }
  }

  if (Solids.IsEmpty())
  {
    /* We want to check that streams layout is OK.
       So we need resources sorted by offset.
       Another code can work with non-sorted streams.
       NOTE: all WIM programs probably create wim archives with
         sorted data streams. So it doesn't call Sort() here. */
       
    {
      unsigned i;
      for (i = 1; i < DataStreams.Size(); i++)
      {
        const CStreamInfo &s0 = DataStreams[i - 1];
        const CStreamInfo &s1 = DataStreams[i];
        if (s0.PartNumber < s1.PartNumber) continue;
        if (s0.PartNumber > s1.PartNumber) break;
        if (s0.Resource.Offset < s1.Resource.Offset) continue;
        if (s0.Resource.Offset > s1.Resource.Offset) break;
        if (s0.Resource.PackSize > s1.Resource.PackSize) break;
      }
      
      if (i < DataStreams.Size())
      {
        // return E_FAIL;
        DataStreams.Sort(CompareStreamsByPos, NULL);
      }
    }

    for (unsigned i = 1; i < DataStreams.Size(); i++)
    {
      const CStreamInfo &s0 = DataStreams[i - 1];
      const CStreamInfo &s1 = DataStreams[i];
      if (s0.PartNumber == s1.PartNumber)
        if (s0.Resource.GetEndLimit() > s1.Resource.Offset)
          return S_FALSE;
    }
  }
  
  {
    {
      const CStreamInfo *streams = &DataStreams.Front();

      if (IsOldVersion)
      {
        sortedByHash.Sort(CompareIDs, (void *)streams);
        
        for (unsigned i = 1; i < sortedByHash.Size(); i++)
          if (streams[sortedByHash[i - 1]].Id >=
              streams[sortedByHash[i]].Id)
            return S_FALSE;
      }
      else
      {
        sortedByHash.Sort(CompareHashRefs, (void *)streams);

        if (!sortedByHash.IsEmpty())
        {
          if (IsEmptySha(streams[sortedByHash[0]].Hash))
            HeadersError = true;
          
          for (unsigned i = 1; i < sortedByHash.Size(); i++)
            if (memcmp(
                streams[sortedByHash[i - 1]].Hash,
                streams[sortedByHash[i]].Hash,
                kHashSize) >= 0)
              return S_FALSE;
        }
      }
    }
    
    FOR_VECTOR (i, Items)
    {
      CItem &item = Items[i];
      item.StreamIndex = -1;
      const Byte *hash = Images[item.ImageIndex].Meta + item.Offset;
      if (IsOldVersion)
      {
        if (!item.IsDir)
        {
          hash += (item.IsAltStream ? 0x8 : 0x10);
          UInt32 id = GetUi32(hash);
          if (id != 0)
            item.StreamIndex = FindId(&DataStreams.Front(), sortedByHash, id);
        }
      }
      /*
      else if (item.IsDir)
      {
        // reparse points can have dirs some dir
      }
      */
      else
      {
        hash += (item.IsAltStream ? 0x10 : 0x40);
        if (!IsEmptySha(hash))
        {
          item.StreamIndex = FindHash(&DataStreams.Front(), sortedByHash, hash);
        }
      }
    }
  }
  {
    CUIntVector refCounts;
    refCounts.ClearAndSetSize(DataStreams.Size());
    unsigned i;

    for (i = 0; i < DataStreams.Size(); i++)
    {
      UInt32 startVal = 0;
      // const CStreamInfo &s = DataStreams[i];
      /*
      if (s.Resource.IsMetadata() && s.PartNumber == 1)
        startVal = 1;
      */
      refCounts[i] = startVal;
    }
    
    for (i = 0; i < Items.Size(); i++)
    {
      int streamIndex = Items[i].StreamIndex;
      if (streamIndex >= 0)
        refCounts[streamIndex]++;
    }
    
    for (i = 0; i < DataStreams.Size(); i++)
    {
      const CStreamInfo &s = DataStreams[i];
      if (s.RefCount != refCounts[i]
          && !s.Resource.IsSolidBig())
      {
        /*
        printf("\ni=%5d  si.Ref=%2d  realRefs=%2d size=%8d offset=%8x id=%4d ",
          i, s.RefCount, refCounts[i], (unsigned)s.Resource.UnpackSize, (unsigned)s.Resource.Offset, s.Id);
        */
        RefCountError = true;
      }
      
      if (refCounts[i] == 0)
      {
        const CResource &r = DataStreams[i].Resource;
        if (!r.IsSolidBig() || Solids[r.SolidIndex].FirstSmallStream < 0)
        {
          CItem item;
          item.Offset = 0;
          item.StreamIndex = i;
          item.ImageIndex = -1;
          Items.Add(item);
          ThereAreDeletedStreams = true;
        }
      }
    }
  }

  return S_OK;
}


HRESULT CDatabase::GenerateSortedItems(int imageIndex, bool showImageNumber)
{
  SortedItems.Clear();
  VirtualRoots.Clear();
  IndexOfUserImage = imageIndex;
  NumExcludededItems = 0;
  ExludedItem = -1;

  if (Images.Size() != 1 && imageIndex < 0)
    showImageNumber = true;

  unsigned startItem = 0;
  unsigned endItem = 0;
  
  if (imageIndex < 0)
  {
    endItem = Items.Size();
    if (Images.Size() == 1)
    {
      IndexOfUserImage = 0;
      const CImage &image = Images[0];
      if (!showImageNumber)
        NumExcludededItems = image.NumEmptyRootItems;
    }
  }
  else if ((unsigned)imageIndex < Images.Size())
  {
    const CImage &image = Images[imageIndex];
    startItem = image.StartItem;
    endItem = startItem + image.NumItems;
    if (!showImageNumber)
      NumExcludededItems = image.NumEmptyRootItems;
  }
  
  if (NumExcludededItems != 0)
  {
    ExludedItem = startItem;
    startItem += NumExcludededItems;
  }

  unsigned num = endItem - startItem;
  SortedItems.ClearAndSetSize(num);
  unsigned i;
  for (i = 0; i < num; i++)
    SortedItems[i] = startItem + i;

  SortedItems.Sort(CompareItems, this);
  for (i = 0; i < SortedItems.Size(); i++)
    Items[SortedItems[i]].IndexInSorted = i;

  if (showImageNumber)
    for (i = 0; i < Images.Size(); i++)
    {
      CImage &image = Images[i];
      if (image.NumEmptyRootItems != 0)
        continue;
      image.VirtualRootIndex = VirtualRoots.Size();
      VirtualRoots.Add(i);
    }

  return S_OK;
}


static void IntVector_SetMinusOne_IfNeed(CIntVector &v, unsigned size)
{
  if (v.Size() == size)
    return;
  v.ClearAndSetSize(size);
  int *vals = &v[0];
  for (unsigned i = 0; i < size; i++)
    vals[i] = -1;
}


HRESULT CDatabase::ExtractReparseStreams(const CObjectVector<CVolume> &volumes, IArchiveOpenCallback *openCallback)
{
  ItemToReparse.Clear();
  ReparseItems.Clear();
  
  // we don't know about Reparse field for OLD WIM format
  if (IsOldVersion)
    return S_OK;

  CIntVector streamToReparse;
  CUnpacker unpacker;
  UInt64 totalPackedPrev = 0;

  FOR_VECTOR(indexInSorted, SortedItems)
  {
    // we use sorted items for faster access
    unsigned itemIndex = SortedItems[indexInSorted];
    const CItem &item = Items[itemIndex];
    
    if (!item.HasMetadata() || item.IsAltStream)
      continue;
    
    if (item.ImageIndex < 0)
      continue;
    
    const Byte *metadata = Images[item.ImageIndex].Meta + item.Offset;
    
    const UInt32 attrib = Get32(metadata + 8);
    if ((attrib & FILE_ATTRIBUTE_REPARSE_POINT) == 0)
      continue;
    
    if (item.StreamIndex < 0)
      continue; // it's ERROR
    
    const CStreamInfo &si = DataStreams[item.StreamIndex];
    if (si.Resource.UnpackSize >= (1 << 16))
      continue; // reparse data can not be larger than 64 KB

    IntVector_SetMinusOne_IfNeed(streamToReparse, DataStreams.Size());
    IntVector_SetMinusOne_IfNeed(ItemToReparse, Items.Size());
    
    const unsigned offset = 0x58; // we don't know about Reparse field for OLD WIM format
    UInt32 tag = Get32(metadata + offset);
    int reparseIndex = streamToReparse[item.StreamIndex];
    CByteBuffer buf;

    if (openCallback)
    {
      if ((unpacker.TotalPacked - totalPackedPrev) >= ((UInt32)1 << 16))
      {
        UInt64 numFiles = Items.Size();
        RINOK(openCallback->SetCompleted(&numFiles, &unpacker.TotalPacked));
        totalPackedPrev = unpacker.TotalPacked;
      }
    }

    if (reparseIndex >= 0)
    {
      const CByteBuffer &reparse = ReparseItems[reparseIndex];
      if (tag == Get32(reparse))
      {
        ItemToReparse[itemIndex] = reparseIndex;
        continue;
      }
      buf = reparse;
      // we support that strange and unusual situation with different tags and same reparse data.
    }
    else
    {
      /*
      if (si.PartNumber >= volumes.Size())
        continue;
      */
      const CVolume &vol = volumes[si.PartNumber];
      /*
      if (!vol.Stream)
        continue;
      */
      
      Byte digest[kHashSize];
      HRESULT res = unpacker.UnpackData(vol.Stream, si.Resource, vol.Header, this, buf, digest);

      if (res == S_FALSE)
        continue;

      RINOK(res);
      
      if (memcmp(digest, si.Hash, kHashSize) != 0
        // && !(h.IsOldVersion() && IsEmptySha(si.Hash))
        )
      {
        // setErrorStatus;
        continue;
      }
    }
    
    CByteBuffer &reparse = ReparseItems.AddNew();
    reparse.Alloc(8 + buf.Size());
    Byte *dest = (Byte *)reparse;
    SetUi32(dest, tag);
    SetUi32(dest + 4, (UInt32)buf.Size());
    if (buf.Size() != 0)
      memcpy(dest + 8, buf, buf.Size());
    ItemToReparse[itemIndex] = ReparseItems.Size() - 1;
  }

  return S_OK;
}



static bool ParseNumber64(const AString &s, UInt64 &res)
{
  const char *end;
  if (s.IsPrefixedBy("0x"))
  {
    if (s.Len() == 2)
      return false;
    res = ConvertHexStringToUInt64(s.Ptr(2), &end);
  }
  else
  {
    if (s.IsEmpty())
      return false;
    res = ConvertStringToUInt64(s, &end);
  }
  return *end == 0;
}


static bool ParseNumber32(const AString &s, UInt32 &res)
{
  UInt64 res64;
  if (!ParseNumber64(s, res64) || res64 >= ((UInt64)1 << 32))
    return false;
  res = (UInt32)res64;
  return true;
}


static bool ParseTime(const CXmlItem &item, FILETIME &ft, const char *tag)
{
  int index = item.FindSubTag(tag);
  if (index >= 0)
  {
    const CXmlItem &timeItem = item.SubItems[index];
    UInt32 low = 0, high = 0;
    if (ParseNumber32(timeItem.GetSubStringForTag("LOWPART"), low) &&
        ParseNumber32(timeItem.GetSubStringForTag("HIGHPART"), high))
    {
      ft.dwLowDateTime = low;
      ft.dwHighDateTime = high;
      return true;
    }
  }
  return false;
}


void CImageInfo::Parse(const CXmlItem &item)
{
  CTimeDefined = ParseTime(item, CTime, "CREATIONTIME");
  MTimeDefined = ParseTime(item, MTime, "LASTMODIFICATIONTIME");
  NameDefined = ConvertUTF8ToUnicode(item.GetSubStringForTag("NAME"), Name);

  ParseNumber64(item.GetSubStringForTag("DIRCOUNT"), DirCount);
  ParseNumber64(item.GetSubStringForTag("FILECOUNT"), FileCount);
  IndexDefined = ParseNumber32(item.GetPropVal("INDEX"), Index);
}

void CWimXml::ToUnicode(UString &s)
{
  size_t size = Data.Size();
  if (size < 2 || (size & 1) != 0 || size > (1 << 24))
    return;
  const Byte *p = Data;
  if (Get16(p) != 0xFEFF)
    return;
  wchar_t *chars = s.GetBuf((unsigned)(size / 2));
  for (size_t i = 2; i < size; i += 2)
  {
    wchar_t c = Get16(p + i);
    if (c == 0)
      break;
    *chars++ = c;
  }
  *chars = 0;
  s.ReleaseBuf_SetLen((unsigned)(chars - (const wchar_t *)s));
}


bool CWimXml::Parse()
{
  IsEncrypted = false;
  AString utf;
  {
    UString s;
    ToUnicode(s);
    // if (!ConvertUnicodeToUTF8(s, utf)) return false;
    ConvertUnicodeToUTF8(s, utf);
  }

  if (!Xml.Parse(utf))
    return false;
  if (Xml.Root.Name != "WIM")
    return false;

  FOR_VECTOR (i, Xml.Root.SubItems)
  {
    const CXmlItem &item = Xml.Root.SubItems[i];
    
    if (item.IsTagged("IMAGE"))
    {
      CImageInfo imageInfo;
      imageInfo.Parse(item);
      if (!imageInfo.IndexDefined)
        return false;

      if (imageInfo.Index != (UInt32)Images.Size() + 1)
      {
        // old wim (1.09) uses zero based image index
        if (imageInfo.Index != (UInt32)Images.Size())
          return false;
      }

      imageInfo.ItemIndexInXml = i;
      Images.Add(imageInfo);
    }

    if (item.IsTagged("ESD"))
    {
      FOR_VECTOR (k, item.SubItems)
      {
        const CXmlItem &item2 = item.SubItems[k];
        if (item2.IsTagged("ENCRYPTED"))
          IsEncrypted = true;
      }
    }
  }

  return true;
}

}}
// Archive/WimIn.h

#ifndef __ARCHIVE_WIM_IN_H
#define __ARCHIVE_WIM_IN_H

#include "../../../../C/Alloc.h"

#include "../../../Common/MyBuffer.h"
#include "../../../Common/MyXml.h"

#include "../../../Windows/PropVariant.h"

#include "../../Compress/CopyCoder.h"
#include "../../Compress/LzmsDecoder.h"
#include "../../Compress/LzxDecoder.h"

#include "../IArchive.h"

namespace NArchive {
namespace NWim {

/*
WIM versions:
hexVer : headerSize : ver
 : 1.07.01 - 1.08.01 : Longhorn.4001-4015 - another header, no signature, CAB compression
10900 : 60 : 1.09 : Longhorn.4029-4039 (2003)
10A00 : 60 : 1.10 : Longhorn.4083 (2004) image starting from 1
10B00 : ?? : 1.11 : ??
10C00 : 74 : 1.12 : Longhorn.4093 - VistaBeta1.5112 (2005) - (Multi-Part, SHA1)
10D00 : D0 : 1.13 : VistaBeta2 - Win10, (NumImages, BootIndex, IntegrityResource)
00E00 : D0 : 0.14 : LZMS, solid, esd, dism
*/

const unsigned kDirRecordSizeOld = 62;
const unsigned kDirRecordSize = 102;

/*
  There is error in WIM specification about dwReparseTag, dwReparseReserved and liHardLink fields.

  Correct DIRENTRY structure:
  {
    hex offset
     0    UInt64  Len;
     8    UInt32  Attrib;
     C    UInt32  SecurityId;
    
    10    UInt64  SubdirOffset; // = 0 for files

    18    UInt64  unused1; // = 0?
    20    UInt64  unused2; // = 0?
    
    28    UInt64  CTime;
    30    UInt64  ATime;
    38    UInt64  MTime;
    
    40    Byte    Sha1[20];
    
    54    UInt32  Unknown1; // is it 0 always?

       
    union
    {
    58    UInt64  NtNodeId;
        {
    58    UInt32  ReparseTag;
    5C    UInt32  ReparseFlags; // is it 0 always? Check with new imagex.
        }
    }

    60    UInt16  Streams;
    
    62    UInt16  ShortNameLen;
    64    UInt16  FileNameLen;
    
    66    UInt16  Name[];
          UInt16  ShortName[];
  }

  // DIRENTRY for WIM_VERSION <= 1.10
  DIRENTRY_OLD structure:
  {
    hex offset
     0    UInt64  Len;
     8    UInt32  Attrib;
     C    UInt32  SecurityId;

    union
    {
    10    UInt64  SubdirOffset; //

    10    UInt32  OldWimFileId; // used for files in old WIMs
    14    UInt32  OldWimFileId_Reserved; // = 0
    }

    18    UInt64  CTime;
    20    UInt64  ATime;
    28    UInt64  MTime;
    
    30    UInt64  Unknown; // NtNodeId ?

    38    UInt16  Streams;
    3A    UInt16  ShortNameLen;
    3C    UInt16  FileNameLen;
    3E    UInt16  FileName[];
          UInt16  ShortName[];
  }

  ALT_STREAM structure:
  {
    hex offset
     0    UInt64  Len;
     8    UInt64  Unused;
    10    Byte    Sha1[20];
    24    UInt16  FileNameLen;
    26    UInt16  FileName[];
  }

  ALT_STREAM_OLD structure:
  {
    hex offset
     0    UInt64  Len;
     8    UInt64  StreamId; // 32-bit value
    10    UInt16  FileNameLen;
    12    UInt16  FileName[];
  }

  If item is file (not Directory) and there are alternative streams,
  there is additional ALT_STREAM item of main "unnamed" stream in Streams array.

*/


namespace NResourceFlags
{
  // const Byte kFree = 1 << 0;
  const Byte kMetadata = 1 << 1;
  const Byte kCompressed = 1 << 2;
  // const Byte kSpanned = 1 << 3;
  const Byte kSolid = 1 << 4;
}

const UInt64 k_SolidBig_Resource_Marker = (UInt64)1 << 32;

struct CResource
{
  UInt64 PackSize;
  UInt64 Offset;
  UInt64 UnpackSize;
  Byte Flags;
  bool KeepSolid;
  int SolidIndex;

  void Clear()
  {
    PackSize = 0;
    Offset = 0;
    UnpackSize = 0;
    Flags = 0;
    KeepSolid = false;
    SolidIndex = -1;
  }

  UInt64 GetEndLimit() const { return Offset + PackSize; }
  void Parse(const Byte *p);
  void ParseAndUpdatePhySize(const Byte *p, UInt64 &phySize)
  {
    Parse(p);
    UInt64 v = GetEndLimit();
    if (phySize < v)
      phySize = v;
  }

  void WriteTo(Byte *p) const;

  bool IsMetadata() const { return (Flags & NResourceFlags::kMetadata) != 0; }
  bool IsCompressed() const { return (Flags & NResourceFlags::kCompressed) != 0; }
  bool IsSolid() const { return (Flags & NResourceFlags::kSolid) != 0; }
  bool IsSolidBig() const { return IsSolid() && UnpackSize == k_SolidBig_Resource_Marker; }
  bool IsSolidSmall() const { return IsSolid() && UnpackSize == 0; }

  bool IsEmpty() const { return (UnpackSize == 0); }
};


struct CSolid
{
  unsigned StreamIndex;
  // unsigned NumRefs;
  int FirstSmallStream;
  
  UInt64 SolidOffset;
  
  UInt64 UnpackSize;
  int Method;
  int ChunkSizeBits;

  UInt64 HeadersSize;
  // size_t NumChunks;
  CObjArray<UInt64> Chunks; // [NumChunks + 1] (start offset)

  UInt64 GetChunkPackSize(size_t chunkIndex) const { return Chunks[chunkIndex + 1] - Chunks[chunkIndex]; }

  CSolid():
      FirstSmallStream(-1),
      // NumRefs(0),
      Method(-1)
      {}
};


namespace NHeaderFlags
{
  const UInt32 kCompression  = 1 << 1;
  const UInt32 kReadOnly     = 1 << 2;
  const UInt32 kSpanned      = 1 << 3;
  const UInt32 kResourceOnly = 1 << 4;
  const UInt32 kMetadataOnly = 1 << 5;
  const UInt32 kWriteInProgress = 1 << 6;
  const UInt32 kReparsePointFixup = 1 << 7;
  
  const UInt32 kXPRESS       = (UInt32)1 << 17;
  const UInt32 kLZX          = (UInt32)1 << 18;
  const UInt32 kLZMS         = (UInt32)1 << 19;
  const UInt32 kXPRESS2      = (UInt32)1 << 21; // XPRESS with nonstandard chunk size ?

  const UInt32 kMethodMask   = 0xFFFE0000;
}


namespace NMethod
{
  const UInt32 kXPRESS = 1;
  const UInt32 kLZX    = 2;
  const UInt32 kLZMS   = 3;
}


const UInt32 k_Version_NonSolid = 0x10D00;
const UInt32 k_Version_Solid = 0xE00;

const unsigned kHeaderSizeMax = 0xD0;
const unsigned kSignatureSize = 8;
extern const Byte kSignature[kSignatureSize];

const unsigned kChunkSizeBits = 15;
const UInt32 kChunkSize = (UInt32)1 << kChunkSizeBits;


struct CHeader
{
  UInt32 Version;
  UInt32 Flags;
  UInt32 ChunkSize;
  unsigned ChunkSizeBits;
  Byte Guid[16];
  UInt16 PartNumber;
  UInt16 NumParts;
  UInt32 NumImages;
  UInt32 BootIndex;

  bool _IsOldVersion; // 1.10-
  bool _IsNewVersion; // 1.13+ or 0.14

  CResource OffsetResource;
  CResource XmlResource;
  CResource MetadataResource;
  CResource IntegrityResource;

  void SetDefaultFields(bool useLZX);

  void WriteTo(Byte *p) const;
  HRESULT Parse(const Byte *p, UInt64 &phySize);
  
  bool IsCompressed() const { return (Flags & NHeaderFlags::kCompression) != 0; }
  
  bool IsSupported() const
  {
    return (!IsCompressed()
        || (Flags & NHeaderFlags::kLZX) != 0
        || (Flags & NHeaderFlags::kXPRESS) != 0
        || (Flags & NHeaderFlags::kLZMS) != 0
        || (Flags & NHeaderFlags::kXPRESS2) != 0);
  }
  
  unsigned GetMethod() const
  {
    if (!IsCompressed())
      return 0;
    UInt32 mask = (Flags & NHeaderFlags::kMethodMask);
    if (mask == 0) return 0;
    if (mask == NHeaderFlags::kXPRESS) return NMethod::kXPRESS;
    if (mask == NHeaderFlags::kLZX) return NMethod::kLZX;
    if (mask == NHeaderFlags::kLZMS) return NMethod::kLZMS;
    if (mask == NHeaderFlags::kXPRESS2) return NMethod::kXPRESS;
    return mask;
  }

  bool IsOldVersion() const { return _IsOldVersion; }
  bool IsNewVersion() const { return _IsNewVersion; }
  bool IsSolidVersion() const { return (Version == k_Version_Solid); }

  bool AreFromOnArchive(const CHeader &h)
  {
    return (memcmp(Guid, h.Guid, sizeof(Guid)) == 0) && (h.NumParts == NumParts);
  }
};


const unsigned kHashSize = 20;

inline bool IsEmptySha(const Byte *data)
{
  for (unsigned i = 0; i < kHashSize; i++)
    if (data[i] != 0)
      return false;
  return true;
}

const unsigned kStreamInfoSize = 24 + 2 + 4 + kHashSize;

struct CStreamInfo
{
  CResource Resource;
  UInt16 PartNumber;      // for NEW WIM format, we set it to 1 for OLD WIM format
  UInt32 RefCount;
  UInt32 Id;              // for OLD WIM format
  Byte Hash[kHashSize];

  bool IsEmptyHash() const { return IsEmptySha(Hash); }
  
  void WriteTo(Byte *p) const;
};


struct CItem
{
  size_t Offset;
  int IndexInSorted;
  int StreamIndex;
  int Parent;
  int ImageIndex; // -1 means that file is unreferenced in Images (deleted item?)
  bool IsDir;
  bool IsAltStream;

  bool HasMetadata() const { return ImageIndex >= 0; }

  CItem():
    IndexInSorted(-1),
    StreamIndex(-1),
    Parent(-1),
    IsDir(false),
    IsAltStream(false)
    {}
};

struct CImage
{
  CByteBuffer Meta;
  CRecordVector<UInt32> SecurOffsets;
  unsigned StartItem;
  unsigned NumItems;
  unsigned NumEmptyRootItems;
  int VirtualRootIndex; // index in CDatabase::VirtualRoots[]
  UString RootName;
  CByteBuffer RootNameBuf;

  CImage(): VirtualRootIndex(-1) {}
};


struct CImageInfo
{
  bool CTimeDefined;
  bool MTimeDefined;
  bool NameDefined;
  bool IndexDefined;
  
  FILETIME CTime;
  FILETIME MTime;
  UString Name;

  UInt64 DirCount;
  UInt64 FileCount;
  UInt32 Index;

  int ItemIndexInXml;

  UInt64 GetTotalFilesAndDirs() const { return DirCount + FileCount; }
  
  CImageInfo(): CTimeDefined(false), MTimeDefined(false), NameDefined(false),
      IndexDefined(false), ItemIndexInXml(-1) {}
  void Parse(const CXmlItem &item);
};


struct CWimXml
{
  CByteBuffer Data;
  CXml Xml;

  UInt16 VolIndex;
  CObjectVector<CImageInfo> Images;

  UString FileName;
  bool IsEncrypted;

  UInt64 GetTotalFilesAndDirs() const
  {
    UInt64 sum = 0;
    FOR_VECTOR (i, Images)
      sum += Images[i].GetTotalFilesAndDirs();
    return sum;
  }

  void ToUnicode(UString &s);
  bool Parse();

  CWimXml(): IsEncrypted(false) {}
};


struct CVolume
{
  CHeader Header;
  CMyComPtr<IInStream> Stream;
};


class CDatabase
{
  Byte *DirData;
  size_t DirSize;
  size_t DirProcessed;
  size_t DirStartOffset;
  IArchiveOpenCallback *OpenCallback;

  HRESULT ParseDirItem(size_t pos, int parent);
  HRESULT ParseImageDirs(CByteBuffer &buf, int parent);

public:
  CRecordVector<CStreamInfo> DataStreams;
  CRecordVector<CStreamInfo> MetaStreams;

  CObjectVector<CSolid> Solids;
  
  CRecordVector<CItem> Items;
  CObjectVector<CByteBuffer> ReparseItems;
  CIntVector ItemToReparse; // from index_in_Items to index_in_ReparseItems
                            // -1 means no reparse;
  
  CObjectVector<CImage> Images;
  
  bool IsOldVersion9;
  bool IsOldVersion;
  bool ThereAreDeletedStreams;
  bool ThereAreAltStreams;
  bool RefCountError;
  bool HeadersError;

  bool GetStartImageIndex() const { return IsOldVersion9 ? 0 : 1; }
  unsigned GetDirAlignMask() const { return IsOldVersion9 ? 3 : 7; }
  
  // User Items can contain all images or just one image from all.
  CUIntVector SortedItems;
  int IndexOfUserImage;    // -1 : if more than one images was filled to Sorted Items
  
  unsigned NumExcludededItems;
  int ExludedItem;          // -1 : if there are no exclude items
  CUIntVector VirtualRoots; // we use them for old 1.10 WIM archives

  bool ThereIsError() const { return RefCountError; }

  unsigned GetNumUserItemsInImage(unsigned imageIndex) const
  {
    if (IndexOfUserImage >= 0 && imageIndex != (unsigned)IndexOfUserImage)
      return 0;
    if (imageIndex >= Images.Size())
      return 0;
    return Images[imageIndex].NumItems - NumExcludededItems;
  }

  bool ItemHasStream(const CItem &item) const;

  UInt64 Get_UnpackSize_of_Resource(const CResource &r) const
  {
    if (!r.IsSolid())
      return r.UnpackSize;
    if (r.IsSolidSmall())
      return r.PackSize;
    if (r.IsSolidBig() && r.SolidIndex >= 0)
      return Solids[(unsigned)r.SolidIndex].UnpackSize;
    return 0;
  }

  UInt64 Get_PackSize_of_Resource(unsigned streamIndex) const
  {
    const CResource &r = DataStreams[streamIndex].Resource;
    if (!r.IsSolidSmall())
      return r.PackSize;
    if (r.SolidIndex >= 0)
    {
      const CSolid &ss = Solids[(unsigned)r.SolidIndex];
      if (ss.FirstSmallStream == (int)streamIndex)
        return DataStreams[ss.StreamIndex].Resource.PackSize;
    }
    return 0;
  }

  UInt64 GetUnpackSize() const
  {
    UInt64 res = 0;
    FOR_VECTOR (i, DataStreams)
      res += DataStreams[i].Resource.UnpackSize;
    return res;
  }

  UInt64 GetPackSize() const
  {
    UInt64 res = 0;
    FOR_VECTOR (i, DataStreams)
      res += DataStreams[i].Resource.PackSize;
    return res;
  }

  void Clear()
  {
    DataStreams.Clear();
    MetaStreams.Clear();
    Solids.Clear();
    
    Items.Clear();
    ReparseItems.Clear();
    ItemToReparse.Clear();

    SortedItems.Clear();
    
    Images.Clear();
    VirtualRoots.Clear();

    IsOldVersion = false;
    ThereAreDeletedStreams = false;
    ThereAreAltStreams = false;
    RefCountError = false;
    HeadersError = false;
  }

  CDatabase(): RefCountError(false) {}

  void GetShortName(unsigned index, NWindows::NCOM::CPropVariant &res) const;
  void GetItemName(unsigned index1, NWindows::NCOM::CPropVariant &res) const;
  void GetItemPath(unsigned index, bool showImageNumber, NWindows::NCOM::CPropVariant &res) const;

  HRESULT OpenXml(IInStream *inStream, const CHeader &h, CByteBuffer &xml);
  HRESULT Open(IInStream *inStream, const CHeader &h, unsigned numItemsReserve, IArchiveOpenCallback *openCallback);
  HRESULT FillAndCheck(const CObjectVector<CVolume> &volumes);

  /*
    imageIndex showImageNumber NumImages
         *        true           *       Show Image_Number
        -1           *          >1       Show Image_Number
        -1        false          1       Don't show Image_Number
         N        false          *       Don't show Image_Number
  */
  HRESULT GenerateSortedItems(int imageIndex, bool showImageNumber);

  HRESULT ExtractReparseStreams(const CObjectVector<CVolume> &volumes, IArchiveOpenCallback *openCallback);
};

HRESULT ReadHeader(IInStream *inStream, CHeader &header, UInt64 &phySize);


struct CMidBuf
{
  Byte *Data;
  size_t _size;

  CMidBuf(): Data(NULL), _size(0) {}

  void EnsureCapacity(size_t size)
  {
    if (size > _size)
    {
      ::MidFree(Data);
      _size = 0;
      Data = (Byte *)::MidAlloc(size);
      if (Data)
        _size = size;
    }
  }

  ~CMidBuf() { ::MidFree(Data); }
};


class CUnpacker
{
  NCompress::CCopyCoder *copyCoderSpec;
  CMyComPtr<ICompressCoder> copyCoder;

  NCompress::NLzx::CDecoder *lzxDecoderSpec;
  CMyComPtr<IUnknown> lzxDecoder;

  NCompress::NLzms::CDecoder *lzmsDecoder;

  CByteBuffer sizesBuf;

  CMidBuf packBuf;
  CMidBuf unpackBuf;

  // solid resource
  int _solidIndex;
  size_t _unpackedChunkIndex;

  HRESULT UnpackChunk(
      ISequentialInStream *inStream,
      unsigned method, unsigned chunkSizeBits,
      size_t inSize, size_t outSize,
      ISequentialOutStream *outStream);

  HRESULT Unpack2(
      IInStream *inStream,
      const CResource &res,
      const CHeader &header,
      const CDatabase *db,
      ISequentialOutStream *outStream,
      ICompressProgressInfo *progress);

public:
  UInt64 TotalPacked;

  CUnpacker():
      lzmsDecoder(NULL),
      _solidIndex(-1),
      _unpackedChunkIndex(0),
      TotalPacked(0)
      {}
  ~CUnpacker();

  HRESULT Unpack(
      IInStream *inStream,
      const CResource &res,
      const CHeader &header,
      const CDatabase *db,
      ISequentialOutStream *outStream,
      ICompressProgressInfo *progress,
      Byte *digest);

  HRESULT UnpackData(IInStream *inStream,
      const CResource &resource, const CHeader &header,
      const CDatabase *db,
      CByteBuffer &buf, Byte *digest);
};

}}
  
#endif
// WimRegister.cpp

#include "StdAfx.h"

#include "../../Common/RegisterArc.h"

#include "WimHandler.h"

namespace NArchive {
namespace NWim {

REGISTER_ARC_IO(
  "wim", "wim swm esd", 0, 0xE6,
  kSignature,
  0,
  NArcInfoFlags::kAltStreams |
  NArcInfoFlags::kNtSecure |
  NArcInfoFlags::kSymLinks |
  NArcInfoFlags::kHardLinks
  , NULL)

}}
// ZipAddCommon.cpp

#include "StdAfx.h"

#include "../../../../C/7zCrc.h"
#include "../../../../C/Alloc.h"

#include "../../../Windows/PropVariant.h"

#include "../../ICoder.h"
#include "../../IPassword.h"
#include "../../MyVersion.h"

#include "../../Common/CreateCoder.h"
#include "../../Common/StreamObjects.h"
#include "../../Common/StreamUtils.h"

#include "../../Compress/LzmaEncoder.h"
#include "../../Compress/PpmdZip.h"

#include "../Common/InStreamWithCRC.h"

#include "ZipAddCommon.h"
#include "ZipHeader.h"

namespace NArchive {
namespace NZip {

static const CMethodId kMethodId_ZipBase   = 0x040100;
static const CMethodId kMethodId_BZip2     = 0x040202;

static const UInt32 kLzmaPropsSize = 5;
static const UInt32 kLzmaHeaderSize = 4 + kLzmaPropsSize;

class CLzmaEncoder:
  public ICompressCoder,
  public ICompressSetCoderProperties,
  public CMyUnknownImp
{
  NCompress::NLzma::CEncoder *EncoderSpec;
  CMyComPtr<ICompressCoder> Encoder;
  Byte Header[kLzmaHeaderSize];
public:
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);

  MY_UNKNOWN_IMP1(ICompressSetCoderProperties)
};

STDMETHODIMP CLzmaEncoder::SetCoderProperties(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps)
{
  if (!Encoder)
  {
    EncoderSpec = new NCompress::NLzma::CEncoder;
    Encoder = EncoderSpec;
  }
  CBufPtrSeqOutStream *outStreamSpec = new CBufPtrSeqOutStream;
  CMyComPtr<ISequentialOutStream> outStream(outStreamSpec);
  outStreamSpec->Init(Header + 4, kLzmaPropsSize);
  RINOK(EncoderSpec->SetCoderProperties(propIDs, props, numProps));
  RINOK(EncoderSpec->WriteCoderProperties(outStream));
  if (outStreamSpec->GetPos() != kLzmaPropsSize)
    return E_FAIL;
  Header[0] = MY_VER_MAJOR;
  Header[1] = MY_VER_MINOR;
  Header[2] = kLzmaPropsSize;
  Header[3] = 0;
  return S_OK;
}

STDMETHODIMP CLzmaEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  RINOK(WriteStream(outStream, Header, kLzmaHeaderSize));
  return Encoder->Code(inStream, outStream, inSize, outSize, progress);
}


CAddCommon::CAddCommon(const CCompressionMethodMode &options):
    _options(options),
    _copyCoderSpec(NULL),
    _cryptoStreamSpec(NULL),
    _buf(NULL)
    {}

CAddCommon::~CAddCommon()
{
  MidFree(_buf);
}

static const UInt32 kBufSize = ((UInt32)1 << 16);

HRESULT CAddCommon::CalcStreamCRC(ISequentialInStream *inStream, UInt32 &resultCRC)
{
  if (!_buf)
  {
    _buf = (Byte *)MidAlloc(kBufSize);
    if (!_buf)
      return E_OUTOFMEMORY;
  }

  UInt32 crc = CRC_INIT_VAL;
  for (;;)
  {
    UInt32 processed;
    RINOK(inStream->Read(_buf, kBufSize, &processed));
    if (processed == 0)
    {
      resultCRC = CRC_GET_DIGEST(crc);
      return S_OK;
    }
    crc = CrcUpdate(crc, _buf, (size_t)processed);
  }
}

HRESULT CAddCommon::Compress(
    DECL_EXTERNAL_CODECS_LOC_VARS
    ISequentialInStream *inStream, IOutStream *outStream,
    UInt32 /* fileTime */,
    ICompressProgressInfo *progress, CCompressingResult &opRes)
{
  if (!inStream)
  {
    // We can create empty stream here. But it was already implemented in caller code in 9.33+
    return E_INVALIDARG;
  }

  // CSequentialInStreamWithCRC *inSecCrcStreamSpec = NULL;
  CInStreamWithCRC *inCrcStreamSpec = NULL;
  CMyComPtr<ISequentialInStream> inCrcStream;
  {
    CMyComPtr<IInStream> inStream2;
    
    inStream->QueryInterface(IID_IInStream, (void **)&inStream2);

    if (inStream2)
    {
      inCrcStreamSpec = new CInStreamWithCRC;
      inCrcStream = inCrcStreamSpec;
      inCrcStreamSpec->SetStream(inStream2);
      inCrcStreamSpec->Init();
    }
    else
    {
      // we don't support stdin, since stream from stdin can require 64-bit size header
      return E_NOTIMPL;
      /*
      inSecCrcStreamSpec = new CSequentialInStreamWithCRC;
      inCrcStream = inSecCrcStreamSpec;
      inSecCrcStreamSpec->SetStream(inStream);
      inSecCrcStreamSpec->Init();
      */
    }
  }

  unsigned numTestMethods = _options.MethodSequence.Size();
  
  if (numTestMethods > 1 && !inCrcStreamSpec)
    numTestMethods = 1;

  UInt32 crc = 0;
  bool crc_IsCalculated = false;
  
  Byte method = 0;
  CFilterCoder::C_OutStream_Releaser outStreamReleaser;
  opRes.ExtractVersion = NFileHeader::NCompressionMethod::kExtractVersion_Default;
  opRes.FileTimeWasUsed = false;
  
  for (unsigned i = 0; i < numTestMethods; i++)
  {
    opRes.ExtractVersion = NFileHeader::NCompressionMethod::kExtractVersion_Default;
    if (inCrcStreamSpec)
      RINOK(inCrcStreamSpec->Seek(0, STREAM_SEEK_SET, NULL));
    RINOK(outStream->SetSize(0));
    RINOK(outStream->Seek(0, STREAM_SEEK_SET, NULL));
    
    if (_options.PasswordIsDefined)
    {
      opRes.ExtractVersion = NFileHeader::NCompressionMethod::kExtractVersion_ZipCrypto;

      if (!_cryptoStream)
      {
        _cryptoStreamSpec = new CFilterCoder(true);
        _cryptoStream = _cryptoStreamSpec;
      }
      
      if (_options.IsAesMode)
      {
        opRes.ExtractVersion = NFileHeader::NCompressionMethod::kExtractVersion_Aes;
        if (!_cryptoStreamSpec->Filter)
        {
          _cryptoStreamSpec->Filter = _filterAesSpec = new NCrypto::NWzAes::CEncoder;
          _filterAesSpec->SetKeyMode(_options.AesKeyMode);
          RINOK(_filterAesSpec->CryptoSetPassword((const Byte *)(const char *)_options.Password, _options.Password.Len()));
        }
        RINOK(_filterAesSpec->WriteHeader(outStream));
      }
      else
      {
        if (!_cryptoStreamSpec->Filter)
        {
          _cryptoStreamSpec->Filter = _filterSpec = new NCrypto::NZip::CEncoder;
          _filterSpec->CryptoSetPassword((const Byte *)(const char *)_options.Password, _options.Password.Len());
        }
        
        UInt32 check;
        
        // if (inCrcStreamSpec)
        {
          if (!crc_IsCalculated)
          {
            RINOK(CalcStreamCRC(inStream, crc));
            crc_IsCalculated = true;
            RINOK(inCrcStreamSpec->Seek(0, STREAM_SEEK_SET, NULL));
          }
          check = (crc >> 16);
        }
        /*
        else
        {
          opRes.FileTimeWasUsed = true;
          check = (fileTime & 0xFFFF);
        }
        */
        
        RINOK(_filterSpec->WriteHeader_Check16(outStream, (UInt16)check));
      }
      
      RINOK(_cryptoStreamSpec->SetOutStream(outStream));
      RINOK(_cryptoStreamSpec->InitEncoder());
      outStreamReleaser.FilterCoder = _cryptoStreamSpec;
    }

    method = _options.MethodSequence[i];
    
    switch (method)
    {
      case NFileHeader::NCompressionMethod::kStored:
      {
        if (_copyCoderSpec == NULL)
        {
          _copyCoderSpec = new NCompress::CCopyCoder;
          _copyCoder = _copyCoderSpec;
        }
        CMyComPtr<ISequentialOutStream> outStreamNew;
        if (_options.PasswordIsDefined)
          outStreamNew = _cryptoStream;
        else
          outStreamNew = outStream;
        RINOK(_copyCoder->Code(inCrcStream, outStreamNew, NULL, NULL, progress));
        break;
      }
      
      default:
      {
        if (!_compressEncoder)
        {
          if (method == NFileHeader::NCompressionMethod::kLZMA)
          {
            _compressExtractVersion = NFileHeader::NCompressionMethod::kExtractVersion_LZMA;
            CLzmaEncoder *_lzmaEncoder = new CLzmaEncoder();
            _compressEncoder = _lzmaEncoder;
          }
          else if (method == NFileHeader::NCompressionMethod::kPPMd)
          {
            _compressExtractVersion = NFileHeader::NCompressionMethod::kExtractVersion_PPMd;
            NCompress::NPpmdZip::CEncoder *encoder = new NCompress::NPpmdZip::CEncoder();
            _compressEncoder = encoder;
          }
          else
          {
          CMethodId methodId;
          switch (method)
          {
            case NFileHeader::NCompressionMethod::kBZip2:
              methodId = kMethodId_BZip2;
              _compressExtractVersion = NFileHeader::NCompressionMethod::kExtractVersion_BZip2;
              break;
            default:
              _compressExtractVersion = ((method == NFileHeader::NCompressionMethod::kDeflated64) ?
                  NFileHeader::NCompressionMethod::kExtractVersion_Deflate64 :
                  NFileHeader::NCompressionMethod::kExtractVersion_Deflate);
              methodId = kMethodId_ZipBase + method;
              break;
          }
          RINOK(CreateCoder(
              EXTERNAL_CODECS_LOC_VARS
              methodId, true, _compressEncoder));
          if (!_compressEncoder)
            return E_NOTIMPL;

          if (method == NFileHeader::NCompressionMethod::kDeflated ||
              method == NFileHeader::NCompressionMethod::kDeflated64)
          {
          }
          else if (method == NFileHeader::NCompressionMethod::kBZip2)
          {
          }
          }
          {
            CMyComPtr<ICompressSetCoderProperties> setCoderProps;
            _compressEncoder.QueryInterface(IID_ICompressSetCoderProperties, &setCoderProps);
            if (setCoderProps)
            {
              RINOK(_options.MethodInfo.SetCoderProps(setCoderProps,
                  _options._dataSizeReduceDefined ? &_options._dataSizeReduce : NULL));
            }
          }
        }
        CMyComPtr<ISequentialOutStream> outStreamNew;
        if (_options.PasswordIsDefined)
          outStreamNew = _cryptoStream;
        else
          outStreamNew = outStream;
        if (_compressExtractVersion > opRes.ExtractVersion)
          opRes.ExtractVersion = _compressExtractVersion;
        RINOK(_compressEncoder->Code(inCrcStream, outStreamNew, NULL, NULL, progress));
        break;
      }
    }

    if (_options.PasswordIsDefined)
    {
      RINOK(_cryptoStreamSpec->OutStreamFinish());
      
      if (_options.IsAesMode)
      {
        RINOK(_filterAesSpec->WriteFooter(outStream));
      }
    }
    
    RINOK(outStream->Seek(0, STREAM_SEEK_CUR, &opRes.PackSize));

    // if (inCrcStreamSpec)
    {
      opRes.CRC = inCrcStreamSpec->GetCRC();
      opRes.UnpackSize = inCrcStreamSpec->GetSize();
    }
    /*
    else
    {
      opRes.CRC = inSecCrcStreamSpec->GetCRC();
      opRes.UnpackSize = inSecCrcStreamSpec->GetSize();
    }
    */

    if (_options.PasswordIsDefined)
    {
      if (opRes.PackSize < opRes.UnpackSize +
          (_options.IsAesMode ? _filterAesSpec->GetAddPackSize() : NCrypto::NZip::kHeaderSize))
        break;
    }
    else if (opRes.PackSize < opRes.UnpackSize)
      break;
  }


  opRes.Method = method;
  return S_OK;
}

}}
// ZipAddCommon.h

#ifndef __ZIP_ADD_COMMON_H
#define __ZIP_ADD_COMMON_H

#include "../../ICoder.h"
#include "../../IProgress.h"

#include "../../Common/CreateCoder.h"
#include "../../Common/FilterCoder.h"

#include "../../Compress/CopyCoder.h"

#include "../../Crypto/ZipCrypto.h"
#include "../../Crypto/WzAes.h"

#include "ZipCompressionMode.h"

namespace NArchive {
namespace NZip {

struct CCompressingResult
{
  UInt64 UnpackSize;
  UInt64 PackSize;
  UInt32 CRC;
  UInt16 Method;
  Byte ExtractVersion;
  bool FileTimeWasUsed;
};

class CAddCommon
{
  CCompressionMethodMode _options;
  NCompress::CCopyCoder *_copyCoderSpec;
  CMyComPtr<ICompressCoder> _copyCoder;

  CMyComPtr<ICompressCoder> _compressEncoder;
  Byte _compressExtractVersion;

  CFilterCoder *_cryptoStreamSpec;
  CMyComPtr<ISequentialOutStream> _cryptoStream;

  NCrypto::NZip::CEncoder *_filterSpec;
  NCrypto::NWzAes::CEncoder *_filterAesSpec;

  Byte *_buf;
  
  HRESULT CalcStreamCRC(ISequentialInStream *inStream, UInt32 &resultCRC);
public:
  CAddCommon(const CCompressionMethodMode &options);
  ~CAddCommon();
  HRESULT Compress(
      DECL_EXTERNAL_CODECS_LOC_VARS
      ISequentialInStream *inStream, IOutStream *outStream,
      UInt32 fileTime,
      ICompressProgressInfo *progress, CCompressingResult &operationResult);
};

}}

#endif
// CompressionMode.h

#ifndef __ZIP_COMPRESSION_MODE_H
#define __ZIP_COMPRESSION_MODE_H

#include "../../../Common/MyString.h"

#ifndef _7ZIP_ST
#include "../../../Windows/System.h"
#endif

#include "../Common/HandlerOut.h"

namespace NArchive {
namespace NZip {

struct CBaseProps
{
  CMethodProps MethodInfo;
  Int32 Level;

  #ifndef _7ZIP_ST
  UInt32 NumThreads;
  bool NumThreadsWasChanged;
  #endif
  bool IsAesMode;
  Byte AesKeyMode;

  void Init()
  {
    MethodInfo.Clear();
    Level = -1;
    #ifndef _7ZIP_ST
    NumThreads = NWindows::NSystem::GetNumberOfProcessors();;
    NumThreadsWasChanged = false;
    #endif
    IsAesMode = false;
    AesKeyMode = 3;
  }
};

struct CCompressionMethodMode: public CBaseProps
{
  CRecordVector<Byte> MethodSequence;
  bool PasswordIsDefined;
  AString Password;

  UInt64 _dataSizeReduce;
  bool _dataSizeReduceDefined;
  
  bool IsRealAesMode() const { return PasswordIsDefined && IsAesMode; }

  CCompressionMethodMode(): PasswordIsDefined(false)
  {
    _dataSizeReduceDefined = false;
    _dataSizeReduce = 0;
  }
};

}}

#endif
// ZipHandler.cpp

#include "StdAfx.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/IntToString.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/PropVariant.h"
#include "../../../Windows/TimeUtils.h"

#include "../../IPassword.h"

#include "../../Common/FilterCoder.h"
#include "../../Common/LimitedStreams.h"
#include "../../Common/ProgressUtils.h"
#include "../../Common/StreamObjects.h"
#include "../../Common/StreamUtils.h"

#include "../../Compress/CopyCoder.h"
#include "../../Compress/LzmaDecoder.h"
#include "../../Compress/ImplodeDecoder.h"
#include "../../Compress/PpmdZip.h"
#include "../../Compress/ShrinkDecoder.h"

#include "../../Crypto/WzAes.h"
#include "../../Crypto/ZipCrypto.h"
#include "../../Crypto/ZipStrong.h"

#include "../Common/ItemNameUtils.h"
#include "../Common/OutStreamWithCRC.h"

#include "../XzHandler.h"

#include "ZipHandler.h"

using namespace NWindows;

namespace NArchive {
namespace NZip {

static const CMethodId kMethodId_ZipBase = 0x040100;
static const CMethodId kMethodId_BZip2 = 0x040202;

static const char * const kHostOS[] =
{
    "FAT"
  , "AMIGA"
  , "VMS"
  , "Unix"
  , "VM/CMS"
  , "Atari"
  , "HPFS"
  , "Macintosh"
  , "Z-System"
  , "CP/M"
  , "TOPS-20"
  , "NTFS"
  , "SMS/QDOS"
  , "Acorn"
  , "VFAT"
  , "MVS"
  , "BeOS"
  , "Tandem"
  , "OS/400"
  , "OS/X"
};

static const char * const kMethods[] =
{
    "Store"
  , "Shrink"
  , "Reduced1"
  , "Reduced2"
  , "Reduced3"
  , "Reduced4"
  , "Implode"
  , "Tokenizing"
  , "Deflate"
  , "Deflate64"
  , "PKImploding"
};

static const char *kMethod_AES = "AES";
static const char *kMethod_ZipCrypto = "ZipCrypto";
static const char *kMethod_StrongCrypto = "StrongCrypto";

struct CIdToNamePair
{
  unsigned Id;
  const char *Name;
};

static const CIdToNamePair k_MethodIdNamePairs[] =
{
  { NFileHeader::NCompressionMethod::kBZip2, "BZip2" },
  { NFileHeader::NCompressionMethod::kLZMA, "LZMA" },
  { NFileHeader::NCompressionMethod::kXz, "xz" },
  { NFileHeader::NCompressionMethod::kJpeg, "Jpeg" },
  { NFileHeader::NCompressionMethod::kWavPack, "WavPack" },
  { NFileHeader::NCompressionMethod::kPPMd, "PPMd" }
};

static const CIdToNamePair k_StrongCryptoPairs[] =
{
  { NStrongCrypto_AlgId::kDES, "DES" },
  { NStrongCrypto_AlgId::kRC2old, "RC2a" },
  { NStrongCrypto_AlgId::k3DES168, "3DES-168" },
  { NStrongCrypto_AlgId::k3DES112, "3DES-112" },
  { NStrongCrypto_AlgId::kAES128, "pkAES-128" },
  { NStrongCrypto_AlgId::kAES192, "pkAES-192" },
  { NStrongCrypto_AlgId::kAES256, "pkAES-256" },
  { NStrongCrypto_AlgId::kRC2, "RC2" },
  { NStrongCrypto_AlgId::kBlowfish, "Blowfish" },
  { NStrongCrypto_AlgId::kTwofish, "Twofish" },
  { NStrongCrypto_AlgId::kRC4, "RC4" }
};

const char *FindNameForId(const CIdToNamePair *pairs, unsigned num, unsigned id)
{
  for (unsigned i = 0; i < num; i++)
  {
    const CIdToNamePair &pair = pairs[i];
    if (id == pair.Id)
      return pair.Name;
  }
  return NULL;
}

static const Byte kProps[] =
{
  kpidPath,
  kpidIsDir,
  kpidSize,
  kpidPackSize,
  kpidMTime,
  kpidCTime,
  kpidATime,
  kpidAttrib,
  // kpidPosixAttrib,
  kpidEncrypted,
  kpidComment,
  kpidCRC,
  kpidMethod,
  kpidHostOS,
  kpidUnpackVer,
  kpidVolumeIndex
};

static const Byte kArcProps[] =
{
  kpidEmbeddedStubSize,
  kpidBit64,
  kpidComment,
  kpidTotalPhySize,
  kpidIsVolume,
  kpidVolumeIndex,
  kpidNumVolumes
};

CHandler::CHandler()
{
  InitMethodProps();
}

static AString BytesToString(const CByteBuffer &data)
{
  AString s;
  s.SetFrom_CalcLen((const char *)(const Byte *)data, (unsigned)data.Size());
  return s;
}

IMP_IInArchive_Props
IMP_IInArchive_ArcProps

STDMETHODIMP CHandler::GetArchiveProperty(PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NWindows::NCOM::CPropVariant prop;
  switch (propID)
  {
    case kpidBit64:  if (m_Archive.IsZip64) prop = m_Archive.IsZip64; break;
    case kpidComment:  if (m_Archive.ArcInfo.Comment.Size() != 0) prop = MultiByteToUnicodeString(BytesToString(m_Archive.ArcInfo.Comment), CP_ACP); break;

    case kpidPhySize:  prop = m_Archive.GetPhySize(); break;
    case kpidOffset:  prop = m_Archive.GetOffset(); break;

    case kpidEmbeddedStubSize:
    {
      UInt64 stubSize = m_Archive.GetEmbeddedStubSize();
      if (stubSize != 0)
        prop = stubSize;
      break;
    }

    case kpidTotalPhySize: if (m_Archive.IsMultiVol) prop = m_Archive.Vols.GetTotalSize(); break;
    case kpidVolumeIndex: if (m_Archive.IsMultiVol) prop = (UInt32)m_Archive.Vols.StartVolIndex; break;
    case kpidIsVolume: if (m_Archive.IsMultiVol) prop = true; break;
    case kpidNumVolumes: if (m_Archive.IsMultiVol) prop = (UInt32)m_Archive.Vols.Streams.Size(); break;

    case kpidWarningFlags:
    {
      UInt32 v = 0;
      // if (m_Archive.ExtraMinorError) v |= kpv_ErrorFlags_HeadersError;
      if (m_Archive.HeadersWarning) v |= kpv_ErrorFlags_HeadersError;
      if (v != 0)
        prop = v;
      break;
    }

    case kpidError:
    {
      if (!m_Archive.Vols.MissingName.IsEmpty())
      {
        UString s;
        s.SetFromAscii("Missing volume : ");
        s += m_Archive.Vols.MissingName;
        prop = s;
      }
      break;
    }

    case kpidErrorFlags:
    {
      UInt32 v = 0;
      if (!m_Archive.IsArc) v |= kpv_ErrorFlags_IsNotArc;
      if (m_Archive.HeadersError) v |= kpv_ErrorFlags_HeadersError;
      if (m_Archive.UnexpectedEnd) v |= kpv_ErrorFlags_UnexpectedEnd;
      if (m_Archive.ArcInfo.Base < 0)
      {
        /* We try to support case when we have sfx-zip with embedded stub,
           but the stream has access only to zip part.
           In that case we ignore UnavailableStart error.
           maybe we must show warning in that case. */
        UInt64 stubSize = m_Archive.GetEmbeddedStubSize();
        if (stubSize < (UInt64)-m_Archive.ArcInfo.Base)
          v |= kpv_ErrorFlags_UnavailableStart;
      }
      if (m_Archive.NoCentralDir) v |= kpv_ErrorFlags_UnconfirmedStart;
      prop = v;
      break;
    }

    case kpidReadOnly:
    {
      if (m_Archive.IsOpen())
        if (!m_Archive.CanUpdate())
          prop = true;
      break;
    }
  }
  prop.Detach(value);
  COM_TRY_END
  return S_OK;
}

STDMETHODIMP CHandler::GetNumberOfItems(UInt32 *numItems)
{
  *numItems = m_Items.Size();
  return S_OK;
}

STDMETHODIMP CHandler::GetProperty(UInt32 index, PROPID propID, PROPVARIANT *value)
{
  COM_TRY_BEGIN
  NWindows::NCOM::CPropVariant prop;
  const CItemEx &item = m_Items[index];
  const CExtraBlock &extra = item.GetMainExtra();
  
  switch (propID)
  {
    case kpidPath:
    {
      UString res;
      item.GetUnicodeString(res, item.Name, false, _forceCodePage, _specifiedCodePage);
      NItemName::ConvertToOSName2(res);
      prop = res;
      break;
    }
    
    case kpidIsDir:  prop = item.IsDir(); break;
    case kpidSize:  prop = item.Size; break;
    case kpidPackSize:  prop = item.PackSize; break;
    
    case kpidTimeType:
    {
      FILETIME ft;
      UInt32 unixTime;
      UInt32 type;
      if (extra.GetNtfsTime(NFileHeader::NNtfsExtra::kMTime, ft))
        type = NFileTimeType::kWindows;
      else if (extra.GetUnixTime(true, NFileHeader::NUnixTime::kMTime, unixTime))
        type = NFileTimeType::kUnix;
      else
        type = NFileTimeType::kDOS;
      prop = type;
      break;
    }
    
    case kpidCTime:
    {
      FILETIME ft;
      if (extra.GetNtfsTime(NFileHeader::NNtfsExtra::kCTime, ft))
        prop = ft;
      break;
    }
    
    case kpidATime:
    {
      FILETIME ft;
      if (extra.GetNtfsTime(NFileHeader::NNtfsExtra::kATime, ft))
        prop = ft;
      break;
    }
    
    case kpidMTime:
    {
      FILETIME utc;
      bool defined = true;
      if (!extra.GetNtfsTime(NFileHeader::NNtfsExtra::kMTime, utc))
      {
        UInt32 unixTime = 0;
        if (extra.GetUnixTime(true, NFileHeader::NUnixTime::kMTime, unixTime))
          NTime::UnixTimeToFileTime(unixTime, utc);
        else
        {
          FILETIME localFileTime;
          if (item.Time == 0)
            defined = false;
          else if (!NTime::DosTimeToFileTime(item.Time, localFileTime) ||
              !LocalFileTimeToFileTime(&localFileTime, &utc))
            utc.dwHighDateTime = utc.dwLowDateTime = 0;
        }
      }
      if (defined)
        prop = utc;
      break;
    }
    
    case kpidAttrib:  prop = item.GetWinAttrib(); break;
    
    case kpidPosixAttrib:
    {
      UInt32 attrib;
      if (item.GetPosixAttrib(attrib))
        prop = attrib;
      break;
    }
    
    case kpidEncrypted:  prop = item.IsEncrypted(); break;
    
    case kpidComment:
    {
      if (item.Comment.Size() != 0)
      {
        UString res;
        item.GetUnicodeString(res, BytesToString(item.Comment), true, _forceCodePage, _specifiedCodePage);
        prop = res;
      }
      break;
    }
    
    case kpidCRC:  if (item.IsThereCrc()) prop = item.Crc; break;
    
    case kpidMethod:
    {
      unsigned id = item.Method;
      AString m;
      
      if (item.IsEncrypted())
      {
        if (id == NFileHeader::NCompressionMethod::kWzAES)
        {
          m += kMethod_AES;
          CWzAesExtra aesField;
          if (extra.GetWzAes(aesField))
          {
            char s[16];
            s[0] = '-';
            ConvertUInt32ToString(((unsigned)aesField.Strength + 1) * 64 , s + 1);
            m += s;
            id = aesField.Method;
          }
        }
        else if (item.IsStrongEncrypted())
        {
          CStrongCryptoExtra f;
          f.AlgId = 0;
          if (extra.GetStrongCrypto(f))
          {
            const char *s = FindNameForId(k_StrongCryptoPairs, ARRAY_SIZE(k_StrongCryptoPairs), f.AlgId);
            if (s)
              m += s;
            else
            {
              m += kMethod_StrongCrypto;
              char temp[16];
              temp[0] = ':';
              ConvertUInt32ToString(f.AlgId, temp + 1);
              m += temp;
            }
            if (f.CertificateIsUsed())
              m += "-Cert";
          }
          else
            m += kMethod_StrongCrypto;
        }
        else
          m += kMethod_ZipCrypto;
        m += ' ';
      }
      
      {
        char temp[16];
        const char *s = NULL;
        if (id < ARRAY_SIZE(kMethods))
          s = kMethods[id];
        else
        {
          s = FindNameForId(k_MethodIdNamePairs, ARRAY_SIZE(k_MethodIdNamePairs), id);
          if (!s)
          {
            ConvertUInt32ToString(id, temp);
            s = temp;
          }
        }
        m += s;
        if (id == NFileHeader::NCompressionMethod::kLZMA && item.IsLzmaEOS())
          m += ":EOS";
      }
      
      prop = m;
      break;
    }

    case kpidHostOS:
    {
      Byte hostOS = item.GetHostOS();
      char temp[16];
      const char *s = NULL;
      if (hostOS < ARRAY_SIZE(kHostOS))
        s = kHostOS[hostOS];
      else
      {
        ConvertUInt32ToString(hostOS, temp);
        s = temp;
      }
      prop = s;
      break;
    }
    
    case kpidUnpackVer:
      prop = (UInt32)item.ExtractVersion.Version;
      break;

    case kpidVolumeIndex:
      prop = item.Disk;
      break;
  }
  
  prop.Detach(value);
  return S_OK;
  COM_TRY_END
}


STDMETHODIMP CHandler::Open(IInStream *inStream,
    const UInt64 *maxCheckStartPosition, IArchiveOpenCallback *callback)
{
  COM_TRY_BEGIN
  try
  {
    Close();
    HRESULT res = m_Archive.Open(inStream, maxCheckStartPosition, callback, m_Items);
    if (res != S_OK)
    {
      m_Items.Clear();
      m_Archive.ClearRefs();
    }
    return res;
  }
  catch(...) { Close(); throw; }
  COM_TRY_END
}

STDMETHODIMP CHandler::Close()
{
  m_Items.Clear();
  m_Archive.Close();
  return S_OK;
}


class CLzmaDecoder:
  public ICompressCoder,
  public CMyUnknownImp
{
  NCompress::NLzma::CDecoder *DecoderSpec;
  CMyComPtr<ICompressCoder> Decoder;
public:
  CLzmaDecoder();
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  MY_UNKNOWN_IMP
};

CLzmaDecoder::CLzmaDecoder()
{
  DecoderSpec = new NCompress::NLzma::CDecoder;
  Decoder = DecoderSpec;
}

HRESULT CLzmaDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  Byte buf[9];
  RINOK(ReadStream_FALSE(inStream, buf, 9));
  if (buf[2] != 5 || buf[3] != 0)
    return E_NOTIMPL;
  RINOK(DecoderSpec->SetDecoderProperties2(buf + 4, 5));
  return Decoder->Code(inStream, outStream, NULL, outSize, progress);
}


class CXzDecoder:
  public ICompressCoder,
  public CMyUnknownImp
{
  NArchive::NXz::CDecoder _decoder;
public:

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  MY_UNKNOWN_IMP
};

HRESULT CXzDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  RINOK(_decoder.Decode(inStream, outStream, progress));
  Int32 opRes = _decoder.Get_Extract_OperationResult();
  if (opRes == NExtract::NOperationResult::kUnsupportedMethod)
    return E_NOTIMPL;
  if (opRes != NExtract::NOperationResult::kOK)
    return S_FALSE;
  return S_OK;
}


struct CMethodItem
{
  unsigned ZipMethod;
  CMyComPtr<ICompressCoder> Coder;
};



class CZipDecoder
{
  NCrypto::NZip::CDecoder *_zipCryptoDecoderSpec;
  NCrypto::NZipStrong::CDecoder *_pkAesDecoderSpec;
  NCrypto::NWzAes::CDecoder *_wzAesDecoderSpec;

  CMyComPtr<ICompressFilter> _zipCryptoDecoder;
  CMyComPtr<ICompressFilter> _pkAesDecoder;
  CMyComPtr<ICompressFilter> _wzAesDecoder;

  CFilterCoder *filterStreamSpec;
  CMyComPtr<ISequentialInStream> filterStream;
  CMyComPtr<ICryptoGetTextPassword> getTextPassword;
  CObjectVector<CMethodItem> methodItems;

public:
  CZipDecoder():
      _zipCryptoDecoderSpec(0),
      _pkAesDecoderSpec(0),
      _wzAesDecoderSpec(0),
      filterStreamSpec(0) {}

  HRESULT Decode(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CInArchive &archive, const CItemEx &item,
    ISequentialOutStream *realOutStream,
    IArchiveExtractCallback *extractCallback,
    ICompressProgressInfo *compressProgress,
    #ifndef _7ZIP_ST
    UInt32 numThreads,
    #endif
    Int32 &res);
};


static HRESULT SkipStreamData(ISequentialInStream *stream, UInt64 size)
{
  const size_t kBufSize = 1 << 12;
  Byte buf[kBufSize];
  for (;;)
  {
    if (size == 0)
      return S_OK;
    size_t curSize = kBufSize;
    if (curSize > size)
      curSize = (size_t)size;
    RINOK(ReadStream_FALSE(stream, buf, curSize));
    size -= curSize;
  }
}


HRESULT CZipDecoder::Decode(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CInArchive &archive, const CItemEx &item,
    ISequentialOutStream *realOutStream,
    IArchiveExtractCallback *extractCallback,
    ICompressProgressInfo *compressProgress,
    #ifndef _7ZIP_ST
    UInt32 numThreads,
    #endif
    Int32 &res)
{
  res = NExtract::NOperationResult::kDataError;
  CFilterCoder::C_InStream_Releaser inStreamReleaser;

  bool needCRC = true;
  bool wzAesMode = false;
  bool pkAesMode = false;
  unsigned id = item.Method;

  if (item.IsEncrypted())
  {
    if (item.IsStrongEncrypted())
    {
      CStrongCryptoExtra f;
      if (item.CentralExtra.GetStrongCrypto(f))
      {
        pkAesMode = true;
      }
      if (!pkAesMode)
      {
        res = NExtract::NOperationResult::kUnsupportedMethod;
        return S_OK;
      }
    }
    if (!pkAesMode && id == NFileHeader::NCompressionMethod::kWzAES)
    {
      CWzAesExtra aesField;
      if (item.GetMainExtra().GetWzAes(aesField))
      {
        wzAesMode = true;
        needCRC = aesField.NeedCrc();
      }
    }
  }
    
  COutStreamWithCRC *outStreamSpec = new COutStreamWithCRC;
  CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
  outStreamSpec->SetStream(realOutStream);
  outStreamSpec->Init(needCRC);
  
  CMyComPtr<ISequentialInStream> packStream;

  CLimitedSequentialInStream *limitedStreamSpec = new CLimitedSequentialInStream;
  CMyComPtr<ISequentialInStream> inStream(limitedStreamSpec);

  {
    UInt64 packSize = item.PackSize;
    if (wzAesMode)
    {
      if (packSize < NCrypto::NWzAes::kMacSize)
        return S_OK;
      packSize -= NCrypto::NWzAes::kMacSize;
    }
    RINOK(archive.GetItemStream(item, true, packStream));
    if (!packStream)
    {
      res = NExtract::NOperationResult::kUnavailable;
      return S_OK;
    }
    limitedStreamSpec->SetStream(packStream);
    limitedStreamSpec->Init(packSize);
  }
  
  CMyComPtr<ICompressFilter> cryptoFilter;
  
  if (item.IsEncrypted())
  {
    if (wzAesMode)
    {
      CWzAesExtra aesField;
      if (!item.GetMainExtra().GetWzAes(aesField))
        return S_OK;
      id = aesField.Method;
      if (!_wzAesDecoder)
      {
        _wzAesDecoderSpec = new NCrypto::NWzAes::CDecoder;
        _wzAesDecoder = _wzAesDecoderSpec;
      }
      cryptoFilter = _wzAesDecoder;
      if (!_wzAesDecoderSpec->SetKeyMode(aesField.Strength))
      {
        res = NExtract::NOperationResult::kUnsupportedMethod;
        return S_OK;
      }
    }
    else if (pkAesMode)
    {
      if (!_pkAesDecoder)
      {
        _pkAesDecoderSpec = new NCrypto::NZipStrong::CDecoder;
        _pkAesDecoder = _pkAesDecoderSpec;
      }
      cryptoFilter = _pkAesDecoder;
    }
    else
    {
      if (!_zipCryptoDecoder)
      {
        _zipCryptoDecoderSpec = new NCrypto::NZip::CDecoder;
        _zipCryptoDecoder = _zipCryptoDecoderSpec;
      }
      cryptoFilter = _zipCryptoDecoder;
    }
    
    CMyComPtr<ICryptoSetPassword> cryptoSetPassword;
    RINOK(cryptoFilter.QueryInterface(IID_ICryptoSetPassword, &cryptoSetPassword));
    
    if (!getTextPassword)
      extractCallback->QueryInterface(IID_ICryptoGetTextPassword, (void **)&getTextPassword);
    
    if (getTextPassword)
    {
      CMyComBSTR password;
      RINOK(getTextPassword->CryptoGetTextPassword(&password));
      AString charPassword;
      if (password)
      {
        if (wzAesMode || pkAesMode)
        {
          charPassword = UnicodeStringToMultiByte((const wchar_t *)password, CP_ACP);
          /*
          for (unsigned i = 0;; i++)
          {
            wchar_t c = password[i];
            if (c == 0)
              break;
            if (c >= 0x80)
            {
              res = NExtract::NOperationResult::kDataError;
              return S_OK;
            }
            charPassword += (char)c;
          }
          */
        }
        else
        {
          /* pkzip25 / WinZip / Windows probably use ANSI for some files
             We use OEM for compatibility with previous versions of 7-Zip? */
          charPassword = UnicodeStringToMultiByte((const wchar_t *)password, CP_OEMCP);
        }
      }
      HRESULT result = cryptoSetPassword->CryptoSetPassword(
        (const Byte *)(const char *)charPassword, charPassword.Len());
      if (result != S_OK)
        return S_OK;
    }
    else
    {
      RINOK(cryptoSetPassword->CryptoSetPassword(0, 0));
    }
  }
  
  unsigned m;
  for (m = 0; m < methodItems.Size(); m++)
    if (methodItems[m].ZipMethod == id)
      break;

  if (m == methodItems.Size())
  {
    CMethodItem mi;
    mi.ZipMethod = id;
    if (id == NFileHeader::NCompressionMethod::kStored)
      mi.Coder = new NCompress::CCopyCoder;
    else if (id == NFileHeader::NCompressionMethod::kShrunk)
      mi.Coder = new NCompress::NShrink::CDecoder;
    else if (id == NFileHeader::NCompressionMethod::kImploded)
      mi.Coder = new NCompress::NImplode::NDecoder::CCoder;
    else if (id == NFileHeader::NCompressionMethod::kLZMA)
      mi.Coder = new CLzmaDecoder;
    else if (id == NFileHeader::NCompressionMethod::kXz)
      mi.Coder = new CXzDecoder;
    else if (id == NFileHeader::NCompressionMethod::kPPMd)
      mi.Coder = new NCompress::NPpmdZip::CDecoder(true);
    else
    {
      CMethodId szMethodID;
      if (id == NFileHeader::NCompressionMethod::kBZip2)
        szMethodID = kMethodId_BZip2;
      else
      {
        if (id > 0xFF)
        {
          res = NExtract::NOperationResult::kUnsupportedMethod;
          return S_OK;
        }
        szMethodID = kMethodId_ZipBase + (Byte)id;
      }

      RINOK(CreateCoder(EXTERNAL_CODECS_LOC_VARS szMethodID, false, mi.Coder));

      if (mi.Coder == 0)
      {
        res = NExtract::NOperationResult::kUnsupportedMethod;
        return S_OK;
      }
    }
    m = methodItems.Add(mi);
  }

  ICompressCoder *coder = methodItems[m].Coder;
  
  {
    CMyComPtr<ICompressSetDecoderProperties2> setDecoderProperties;
    coder->QueryInterface(IID_ICompressSetDecoderProperties2, (void **)&setDecoderProperties);
    if (setDecoderProperties)
    {
      Byte properties = (Byte)item.Flags;
      RINOK(setDecoderProperties->SetDecoderProperties2(&properties, 1));
    }
  }
  
  #ifndef _7ZIP_ST
  {
    CMyComPtr<ICompressSetCoderMt> setCoderMt;
    coder->QueryInterface(IID_ICompressSetCoderMt, (void **)&setCoderMt);
    if (setCoderMt)
    {
      RINOK(setCoderMt->SetNumberOfThreads(numThreads));
    }
  }
  #endif
  
  {
    HRESULT result = S_OK;
    CMyComPtr<ISequentialInStream> inStreamNew;
    if (item.IsEncrypted())
    {
      if (!filterStream)
      {
        filterStreamSpec = new CFilterCoder(false);
        filterStream = filterStreamSpec;
      }
     
      filterStreamSpec->Filter = cryptoFilter;
      
      if (wzAesMode)
      {
        result = _wzAesDecoderSpec->ReadHeader(inStream);
        if (result == S_OK)
        {
          if (!_wzAesDecoderSpec->Init_and_CheckPassword())
          {
            res = NExtract::NOperationResult::kWrongPassword;
            return S_OK;
          }
        }
      }
      else if (pkAesMode)
      {
        result =_pkAesDecoderSpec->ReadHeader(inStream, item.Crc, item.Size);
        if (result == S_OK)
        {
          bool passwOK;
          result = _pkAesDecoderSpec->Init_and_CheckPassword(passwOK);
          if (result == S_OK && !passwOK)
          {
            res = NExtract::NOperationResult::kWrongPassword;
            return S_OK;
          }
        }
      }
      else
      {
        result = _zipCryptoDecoderSpec->ReadHeader(inStream);
        if (result == S_OK)
        {
          _zipCryptoDecoderSpec->Init_BeforeDecode();
          
          /* Info-ZIP modification to ZipCrypto format:
               if bit 3 of the general purpose bit flag is set,
               it uses high byte of 16-bit File Time.
             Info-ZIP code probably writes 2 bytes of File Time.
             We check only 1 byte. */

          // UInt32 v1 = GetUi16(_zipCryptoDecoderSpec->_header + NCrypto::NZip::kHeaderSize - 2);
          // UInt32 v2 = (item.HasDescriptor() ? (item.Time & 0xFFFF) : (item.Crc >> 16));

          Byte v1 = _zipCryptoDecoderSpec->_header[NCrypto::NZip::kHeaderSize - 1];
          Byte v2 = (Byte)(item.HasDescriptor() ? (item.Time >> 8) : (item.Crc >> 24));

          if (v1 != v2)
          {
            res = NExtract::NOperationResult::kWrongPassword;
            return S_OK;
          }
        }
      }

      if (result == S_OK)
      {
        inStreamReleaser.FilterCoder = filterStreamSpec;
        RINOK(filterStreamSpec->SetInStream(inStream));
        
        /* IFilter::Init() does nothing in all zip crypto filters.
           So we can call any Initialize function in CFilterCoder. */

        RINOK(filterStreamSpec->Init_NoSubFilterInit());
        // RINOK(filterStreamSpec->SetOutStreamSize(NULL));
      
        inStreamNew = filterStream;
      }
    }
    else
      inStreamNew = inStream;

    if (result == S_OK)
      result = coder->Code(inStreamNew, outStream, NULL, &item.Size, compressProgress);
    
    if (result == S_FALSE)
      return S_OK;
    
    if (result == E_NOTIMPL)
    {
      res = NExtract::NOperationResult::kUnsupportedMethod;
      return S_OK;
    }

    RINOK(result);
  }

  bool crcOK = true;
  bool authOk = true;
  if (needCRC)
    crcOK = (outStreamSpec->GetCRC() == item.Crc);
  
  if (wzAesMode)
  {
    const UInt64 rem = limitedStreamSpec->GetRem();
    if (rem != 0)
      if (SkipStreamData(inStream, rem) != S_OK)
        authOk = false;

    limitedStreamSpec->Init(NCrypto::NWzAes::kMacSize);
    if (_wzAesDecoderSpec->CheckMac(inStream, authOk) != S_OK)
      authOk = false;
  }
  
  res = ((crcOK && authOk) ?
    NExtract::NOperationResult::kOK :
    NExtract::NOperationResult::kCRCError);
  return S_OK;
}


STDMETHODIMP CHandler::Extract(const UInt32 *indices, UInt32 numItems,
    Int32 testMode, IArchiveExtractCallback *extractCallback)
{
  COM_TRY_BEGIN
  CZipDecoder myDecoder;
  UInt64 totalUnPacked = 0, totalPacked = 0;
  bool allFilesMode = (numItems == (UInt32)(Int32)-1);
  if (allFilesMode)
    numItems = m_Items.Size();
  if (numItems == 0)
    return S_OK;
  UInt32 i;
  for (i = 0; i < numItems; i++)
  {
    const CItemEx &item = m_Items[allFilesMode ? i : indices[i]];
    totalUnPacked += item.Size;
    totalPacked += item.PackSize;
  }
  RINOK(extractCallback->SetTotal(totalUnPacked));

  UInt64 currentTotalUnPacked = 0, currentTotalPacked = 0;
  UInt64 currentItemUnPacked, currentItemPacked;
  
  CLocalProgress *lps = new CLocalProgress;
  CMyComPtr<ICompressProgressInfo> progress = lps;
  lps->Init(extractCallback, false);

  for (i = 0; i < numItems; i++,
      currentTotalUnPacked += currentItemUnPacked,
      currentTotalPacked += currentItemPacked)
  {
    currentItemUnPacked = 0;
    currentItemPacked = 0;

    lps->InSize = currentTotalPacked;
    lps->OutSize = currentTotalUnPacked;
    RINOK(lps->SetCur());

    CMyComPtr<ISequentialOutStream> realOutStream;
    Int32 askMode = testMode ?
        NExtract::NAskMode::kTest :
        NExtract::NAskMode::kExtract;
    UInt32 index = allFilesMode ? i : indices[i];

    CItemEx item = m_Items[index];
    bool isLocalOffsetOK = m_Archive.IsLocalOffsetOK(item);
    bool skip = !isLocalOffsetOK && !item.IsDir();
    if (skip)
      askMode = NExtract::NAskMode::kSkip;

    currentItemUnPacked = item.Size;
    currentItemPacked = item.PackSize;

    RINOK(extractCallback->GetStream(index, &realOutStream, askMode));

    if (!isLocalOffsetOK)
    {
      RINOK(extractCallback->PrepareOperation(askMode));
      realOutStream.Release();
      RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kUnavailable));
      continue;
    }
    
    if (!item.FromLocal)
    {
      bool isAvail = true;
      HRESULT res = m_Archive.ReadLocalItemAfterCdItem(item, isAvail);
      if (res == S_FALSE)
      {
        if (item.IsDir() || realOutStream || testMode)
        {
          RINOK(extractCallback->PrepareOperation(askMode));
          realOutStream.Release();
          RINOK(extractCallback->SetOperationResult(
              isAvail ?
                NExtract::NOperationResult::kHeadersError :
                NExtract::NOperationResult::kUnavailable));
        }
        continue;
      }
      RINOK(res);
    }

    if (item.IsDir())
    {
      // if (!testMode)
      {
        RINOK(extractCallback->PrepareOperation(askMode));
        realOutStream.Release();
        RINOK(extractCallback->SetOperationResult(NExtract::NOperationResult::kOK));
      }
      continue;
    }

    if (!testMode && !realOutStream)
      continue;

    RINOK(extractCallback->PrepareOperation(askMode));

    Int32 res;
    HRESULT hres = myDecoder.Decode(
        EXTERNAL_CODECS_VARS
        m_Archive, item, realOutStream, extractCallback,
        progress,
        #ifndef _7ZIP_ST
        _props.NumThreads,
        #endif
        res);
    RINOK(hres);
    realOutStream.Release();
    
    RINOK(extractCallback->SetOperationResult(res))
  }
  
  lps->InSize = currentTotalPacked;
  lps->OutSize = currentTotalUnPacked;
  return lps->SetCur();
  COM_TRY_END
}

IMPL_ISetCompressCodecsInfo

}}
// Zip/Handler.h

#ifndef __ZIP_HANDLER_H
#define __ZIP_HANDLER_H

#include "../../../Common/DynamicBuffer.h"
#include "../../ICoder.h"
#include "../IArchive.h"

#include "../../Common/CreateCoder.h"

#include "ZipIn.h"
#include "ZipCompressionMode.h"

namespace NArchive {
namespace NZip {

class CHandler:
  public IInArchive,
  public IOutArchive,
  public ISetProperties,
  PUBLIC_ISetCompressCodecsInfo
  public CMyUnknownImp
{
public:
  MY_QUERYINTERFACE_BEGIN2(IInArchive)
  MY_QUERYINTERFACE_ENTRY(IOutArchive)
  MY_QUERYINTERFACE_ENTRY(ISetProperties)
  QUERY_ENTRY_ISetCompressCodecsInfo
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE

  INTERFACE_IInArchive(;)
  INTERFACE_IOutArchive(;)

  STDMETHOD(SetProperties)(const wchar_t * const *names, const PROPVARIANT *values, UInt32 numProps);

  DECL_ISetCompressCodecsInfo

  CHandler();
private:
  CObjectVector<CItemEx> m_Items;
  CInArchive m_Archive;

  CBaseProps _props;

  int m_MainMethod;
  bool m_ForceAesMode;
  bool m_WriteNtfsTimeExtra;
  bool _removeSfxBlock;
  bool m_ForceLocal;
  bool m_ForceUtf8;
  bool _forceCodePage;
  UInt32 _specifiedCodePage;

  DECL_EXTERNAL_CODECS_VARS

  void InitMethodProps()
  {
    _props.Init();
    m_MainMethod = -1;
    m_ForceAesMode = false;
    m_WriteNtfsTimeExtra = true;
    _removeSfxBlock = false;
    m_ForceLocal = false;
    m_ForceUtf8 = false;
    _forceCodePage = false;
    _specifiedCodePage = CP_OEMCP;
  }
};

}}

#endif
// ZipHandlerOut.cpp

#include "StdAfx.h"

#include "../../../Common/ComTry.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/StringToInt.h"

#include "../../../Windows/PropVariant.h"
#include "../../../Windows/TimeUtils.h"

#include "../../IPassword.h"

#include "../../Common/OutBuffer.h"

#include "../../Crypto/WzAes.h"

#include "../Common/ItemNameUtils.h"
#include "../Common/ParseProperties.h"

#include "ZipHandler.h"
#include "ZipUpdate.h"

using namespace NWindows;
using namespace NCOM;
using namespace NTime;

namespace NArchive {
namespace NZip {

STDMETHODIMP CHandler::GetFileTimeType(UInt32 *timeType)
{
  *timeType = NFileTimeType::kDOS;
  return S_OK;
}

static bool IsSimpleAsciiString(const wchar_t *s)
{
  for (;;)
  {
    wchar_t c = *s++;
    if (c == 0)
      return true;
    if (c < 0x20 || c > 0x7F)
      return false;
  }
}

#define COM_TRY_BEGIN2 try {
#define COM_TRY_END2 } \
catch(const CSystemException &e) { return e.ErrorCode; } \
catch(...) { return E_OUTOFMEMORY; }

static HRESULT GetTime(IArchiveUpdateCallback *callback, int index, PROPID propID, FILETIME &filetime)
{
  filetime.dwHighDateTime = filetime.dwLowDateTime = 0;
  NCOM::CPropVariant prop;
  RINOK(callback->GetProperty(index, propID, &prop));
  if (prop.vt == VT_FILETIME)
    filetime = prop.filetime;
  else if (prop.vt != VT_EMPTY)
    return E_INVALIDARG;
  return S_OK;
}

STDMETHODIMP CHandler::UpdateItems(ISequentialOutStream *outStream, UInt32 numItems,
    IArchiveUpdateCallback *callback)
{
  COM_TRY_BEGIN2
  
  if (m_Archive.IsOpen())
  {
    if (!m_Archive.CanUpdate())
      return E_NOTIMPL;
  }

  CObjectVector<CUpdateItem> updateItems;
  bool thereAreAesUpdates = false;
  UInt64 largestSize = 0;
  bool largestSizeDefined = false;

  for (UInt32 i = 0; i < numItems; i++)
  {
    CUpdateItem ui;
    Int32 newData;
    Int32 newProps;
    UInt32 indexInArchive;
    if (!callback)
      return E_FAIL;
    RINOK(callback->GetUpdateItemInfo(i, &newData, &newProps, &indexInArchive));
    ui.NewProps = IntToBool(newProps);
    ui.NewData = IntToBool(newData);
    ui.IndexInArc = indexInArchive;
    ui.IndexInClient = i;
    bool existInArchive = (indexInArchive != (UInt32)(Int32)-1);
    if (existInArchive && newData)
      if (m_Items[indexInArchive].IsAesEncrypted())
        thereAreAesUpdates = true;

    if (IntToBool(newProps))
    {
      UString name;
      {
        NCOM::CPropVariant prop;
        RINOK(callback->GetProperty(i, kpidAttrib, &prop));
        if (prop.vt == VT_EMPTY)
          ui.Attrib = 0;
        else if (prop.vt != VT_UI4)
          return E_INVALIDARG;
        else
          ui.Attrib = prop.ulVal;
      }

      {
        NCOM::CPropVariant prop;
        RINOK(callback->GetProperty(i, kpidPath, &prop));
        if (prop.vt == VT_EMPTY)
          name.Empty();
        else if (prop.vt != VT_BSTR)
          return E_INVALIDARG;
        else
          name = prop.bstrVal;
      }
      {
        NCOM::CPropVariant prop;
        RINOK(callback->GetProperty(i, kpidIsDir, &prop));
        if (prop.vt == VT_EMPTY)
          ui.IsDir = false;
        else if (prop.vt != VT_BOOL)
          return E_INVALIDARG;
        else
          ui.IsDir = (prop.boolVal != VARIANT_FALSE);
      }

      {
        CPropVariant prop;
        RINOK(callback->GetProperty(i, kpidTimeType, &prop));
        if (prop.vt == VT_UI4)
          ui.NtfsTimeIsDefined = (prop.ulVal == NFileTimeType::kWindows);
        else
          ui.NtfsTimeIsDefined = m_WriteNtfsTimeExtra;
      }
      RINOK(GetTime(callback, i, kpidMTime, ui.Ntfs_MTime));
      RINOK(GetTime(callback, i, kpidATime, ui.Ntfs_ATime));
      RINOK(GetTime(callback, i, kpidCTime, ui.Ntfs_CTime));

      {
        FILETIME localFileTime = { 0, 0 };
        if (ui.Ntfs_MTime.dwHighDateTime != 0 ||
            ui.Ntfs_MTime.dwLowDateTime != 0)
          if (!FileTimeToLocalFileTime(&ui.Ntfs_MTime, &localFileTime))
            return E_INVALIDARG;
        FileTimeToDosTime(localFileTime, ui.Time);
      }

      name = NItemName::MakeLegalName(name);
      bool needSlash = ui.IsDir;
      const wchar_t kSlash = L'/';
      if (!name.IsEmpty())
      {
        if (name.Back() == kSlash)
        {
          if (!ui.IsDir)
            return E_INVALIDARG;
          needSlash = false;
        }
      }
      if (needSlash)
        name += kSlash;

      UINT codePage = _forceCodePage ? _specifiedCodePage : CP_OEMCP;

      bool tryUtf8 = true;
      if ((m_ForceLocal || !m_ForceUtf8) && codePage != CP_UTF8)
      {
#ifdef _WIN32
        bool defaultCharWasUsed;
        ui.Name = UnicodeStringToMultiByte(name, codePage, '_', defaultCharWasUsed);
        tryUtf8 = (!m_ForceLocal && (defaultCharWasUsed ||
          MultiByteToUnicodeString(ui.Name, codePage) != name));
#else
	// FIXME
        ui.Name = UnicodeStringToMultiByte(name, CP_OEMCP);
        tryUtf8 = (!m_ForceLocal);
#endif
      }

      if (tryUtf8)
      {
        ui.IsUtf8 = !name.IsAscii();
        ConvertUnicodeToUTF8(name, ui.Name);
      }

      if (ui.Name.Len() >= (1 << 16))
        return E_INVALIDARG;

      ui.IndexInClient = i;
      /*
      if (existInArchive)
      {
        const CItemEx &itemInfo = m_Items[indexInArchive];
        // ui.Commented = itemInfo.IsCommented();
        ui.Commented = false;
        if (ui.Commented)
        {
          ui.CommentRange.Position = itemInfo.GetCommentPosition();
          ui.CommentRange.Size  = itemInfo.CommentSize;
        }
      }
      else
        ui.Commented = false;
      */
    }
    if (IntToBool(newData))
    {
      UInt64 size = 0;
      if (!ui.IsDir)
      {
        NCOM::CPropVariant prop;
        RINOK(callback->GetProperty(i, kpidSize, &prop));
        if (prop.vt != VT_UI8)
          return E_INVALIDARG;
        size = prop.uhVal.QuadPart;
        if (largestSize < size)
          largestSize = size;
        largestSizeDefined = true;
      }
      ui.Size = size;

      // ui.Size -= ui.Size / 2;
    }
    updateItems.Add(ui);
  }

  CMyComPtr<ICryptoGetTextPassword2> getTextPassword;
  {
    CMyComPtr<IArchiveUpdateCallback> udateCallBack2(callback);
    udateCallBack2.QueryInterface(IID_ICryptoGetTextPassword2, &getTextPassword);
  }
  CCompressionMethodMode options;
  (CBaseProps &)options = _props;
  options._dataSizeReduce = largestSize;
  options._dataSizeReduceDefined = largestSizeDefined;

  options.PasswordIsDefined = false;
  options.Password.Empty();
  if (getTextPassword)
  {
    CMyComBSTR password;
    Int32 passwordIsDefined;
    RINOK(getTextPassword->CryptoGetTextPassword2(&passwordIsDefined, &password));
    options.PasswordIsDefined = IntToBool(passwordIsDefined);
    if (options.PasswordIsDefined)
    {
      if (!m_ForceAesMode)
        options.IsAesMode = thereAreAesUpdates;

      if (!IsSimpleAsciiString(password))
        return E_INVALIDARG;
      if (password)
        options.Password = UnicodeStringToMultiByte((LPCOLESTR)password, CP_OEMCP);
      if (options.IsAesMode)
      {
        if (options.Password.Len() > NCrypto::NWzAes::kPasswordSizeMax)
          return E_INVALIDARG;
      }
    }
  }

  Byte mainMethod;
  if (m_MainMethod < 0)
    mainMethod = (Byte)(((_props.Level == 0) ?
        NFileHeader::NCompressionMethod::kStored :
        NFileHeader::NCompressionMethod::kDeflated));
  else
    mainMethod = (Byte)m_MainMethod;
  options.MethodSequence.Add(mainMethod);
  if (mainMethod != NFileHeader::NCompressionMethod::kStored)
    options.MethodSequence.Add(NFileHeader::NCompressionMethod::kStored);

  return Update(
      EXTERNAL_CODECS_VARS
      m_Items, updateItems, outStream,
      m_Archive.IsOpen() ? &m_Archive : NULL, _removeSfxBlock,
      &options, callback);
 
  COM_TRY_END2
}

struct CMethodIndexToName
{
  unsigned Method;
  const char *Name;
};

static const CMethodIndexToName k_SupportedMethods[] =
{
  { NFileHeader::NCompressionMethod::kStored, "copy" },
  { NFileHeader::NCompressionMethod::kDeflated, "deflate" },
  { NFileHeader::NCompressionMethod::kDeflated64, "deflate64" },
  { NFileHeader::NCompressionMethod::kBZip2, "bzip2" },
  { NFileHeader::NCompressionMethod::kLZMA, "lzma" },
  { NFileHeader::NCompressionMethod::kPPMd, "ppmd" }
};

STDMETHODIMP CHandler::SetProperties(const wchar_t * const *names, const PROPVARIANT *values, UInt32 numProps)
{
  InitMethodProps();
  #ifndef _7ZIP_ST
  const UInt32 numProcessors = _props.NumThreads;
  #endif
  
  for (UInt32 i = 0; i < numProps; i++)
  {
    UString name = names[i];
    name.MakeLower_Ascii();
    if (name.IsEmpty())
      return E_INVALIDARG;

    const PROPVARIANT &prop = values[i];

    if (name[0] == L'x')
    {
      UInt32 level = 9;
      RINOK(ParsePropToUInt32(name.Ptr(1), prop, level));
      _props.Level = level;
      _props.MethodInfo.AddProp_Level(level);
    }
    else if (name == L"m")
    {
      if (prop.vt == VT_BSTR)
      {
        UString m = prop.bstrVal, m2;
        m.MakeLower_Ascii();
        int colonPos = m.Find(L':');
        if (colonPos >= 0)
        {
          m2 = m.Ptr(colonPos + 1);
          m.DeleteFrom(colonPos);
        }
        unsigned k;
        for (k = 0; k < ARRAY_SIZE(k_SupportedMethods); k++)
        {
          const CMethodIndexToName &pair = k_SupportedMethods[k];
          if (m.IsEqualTo(pair.Name))
          {
            if (!m2.IsEmpty())
            {
              RINOK(_props.MethodInfo.ParseParamsFromString(m2));
            }
            m_MainMethod = pair.Method;
            break;
          }
        }
        if (k == ARRAY_SIZE(k_SupportedMethods))
          return E_INVALIDARG;
      }
      else if (prop.vt == VT_UI4)
      {
        unsigned k;
        for (k = 0; k < ARRAY_SIZE(k_SupportedMethods); k++)
        {
          unsigned method = k_SupportedMethods[k].Method;
          if (prop.ulVal == method)
          {
            m_MainMethod = method;
            break;
          }
        }
        if (k == ARRAY_SIZE(k_SupportedMethods))
          return E_INVALIDARG;
      }
      else
        return E_INVALIDARG;
    }
    else if (name.IsPrefixedBy(L"em"))
    {
      if (prop.vt != VT_BSTR)
        return E_INVALIDARG;
      {
        UString m = prop.bstrVal;
        m.MakeLower_Ascii();
        if (m.IsPrefixedBy(L"aes"))
        {
          m.DeleteFrontal(3);
          if (m == L"128")
            _props.AesKeyMode = 1;
          else if (m == L"192")
            _props.AesKeyMode = 2;
          else if (m == L"256" || m.IsEmpty())
            _props.AesKeyMode = 3;
          else
            return E_INVALIDARG;
          _props.IsAesMode = true;
          m_ForceAesMode = true;
        }
        else if (m == L"zipcrypto")
        {
          _props.IsAesMode = false;
          m_ForceAesMode = true;
        }
        else
          return E_INVALIDARG;
      }
    }
    else if (name.IsPrefixedBy(L"mt"))
    {
      #ifndef _7ZIP_ST
      RINOK(ParseMtProp(name.Ptr(2), prop, numProcessors, _props.NumThreads));
      _props.NumThreadsWasChanged = true;
      #endif
    }
    else if (name.IsEqualTo("tc"))
    {
      RINOK(PROPVARIANT_to_bool(prop, m_WriteNtfsTimeExtra));
    }
    else if (name.IsEqualTo("cl"))
    {
      RINOK(PROPVARIANT_to_bool(prop, m_ForceLocal));
      if (m_ForceLocal)
        m_ForceUtf8 = false;
    }
    else if (name.IsEqualTo("cu"))
    {
      RINOK(PROPVARIANT_to_bool(prop, m_ForceUtf8));
      if (m_ForceUtf8)
        m_ForceLocal = false;
    }
    else if (name.IsEqualTo("cp"))
    {
      UInt32 cp = CP_OEMCP;
      RINOK(ParsePropToUInt32(L"", prop, cp));
      _forceCodePage = true;
      _specifiedCodePage = cp;
    }
    else if (name.IsEqualTo("rsfx"))
    {
      RINOK(PROPVARIANT_to_bool(prop, _removeSfxBlock));
    }
    else
    {
      RINOK(_props.MethodInfo.ParseParamsFromPROPVARIANT(name, prop));
    }
  }
  return S_OK;
}

}}
// ZipHeader.h

#ifndef __ARCHIVE_ZIP_HEADER_H
#define __ARCHIVE_ZIP_HEADER_H

#include "../../../Common/MyTypes.h"

namespace NArchive {
namespace NZip {

const unsigned kMarkerSize = 4;

namespace NSignature
{
  const UInt32 kLocalFileHeader   = 0x04034B50;
  const UInt32 kDataDescriptor    = 0x08074B50;
  const UInt32 kCentralFileHeader = 0x02014B50;
  const UInt32 kEcd               = 0x06054B50;
  const UInt32 kEcd64             = 0x06064B50;
  const UInt32 kEcd64Locator      = 0x07064B50;
  const UInt32 kSpan              = 0x08074B50;
  const UInt32 kNoSpan            = 0x30304B50; // PK00, replaces kSpan, if there is only 1 segment
}

const unsigned kLocalHeaderSize = 4 + 26; // including signature
const unsigned kDataDescriptorSize = 4 + 12;  // including signature
const unsigned kCentralHeaderSize = 4 + 42; // including signature

const unsigned kEcdSize = 22; // including signature
const unsigned kEcd64_MainSize = 44;
const unsigned kEcd64_FullSize = 12 + kEcd64_MainSize;
const unsigned kEcd64Locator_Size = 20;

namespace NFileHeader
{
  namespace NCompressionMethod
  {
    enum EType
    {
      kStored = 0,
      kShrunk = 1,
      kReduced1 = 2,
      kReduced2 = 3,
      kReduced3 = 4,
      kReduced4 = 5,
      kImploded = 6,
      kReservedTokenizing = 7, // reserved for tokenizing
      kDeflated = 8,
      kDeflated64 = 9,
      kPKImploding = 10,
      
      kBZip2 = 12,
      kLZMA = 14,
      kTerse = 18,
      kLz77 = 19,
      
      kXz = 0x5F,
      kJpeg = 0x60,
      kWavPack = 0x61,
      kPPMd = 0x62,
      kWzAES = 0x63
    };

    const Byte kMadeByProgramVersion = 63;
    
    const Byte kExtractVersion_Default = 10;
    const Byte kExtractVersion_Dir = 20;
    const Byte kExtractVersion_ZipCrypto = 20;
    const Byte kExtractVersion_Deflate = 20;
    const Byte kExtractVersion_Deflate64 = 21;
    const Byte kExtractVersion_Zip64 = 45;
    const Byte kExtractVersion_BZip2 = 46;
    const Byte kExtractVersion_Aes = 51;
    const Byte kExtractVersion_LZMA = 63;
    const Byte kExtractVersion_PPMd = 63;
  }

  namespace NExtraID
  {
    enum
    {
      kZip64 = 0x01,
      kNTFS = 0x0A,
      kStrongEncrypt = 0x17,
      kUnixTime = 0x5455,
      kIzUnicodeComment = 0x6375,
      kIzUnicodeName = 0x7075,
      kWzAES = 0x9901
    };
  }

  namespace NNtfsExtra
  {
    const UInt16 kTagTime = 1;
    enum
    {
      kMTime = 0,
      kATime,
      kCTime
    };
  }

  namespace NUnixTime
  {
    enum
    {
      kMTime = 0,
      kATime,
      kCTime
    };
  }

  namespace NFlags
  {
    const unsigned kEncrypted = 1 << 0;
    const unsigned kLzmaEOS = 1 << 1;
    const unsigned kDescriptorUsedMask = 1 << 3;
    const unsigned kStrongEncrypted = 1 << 6;
    const unsigned kUtf8 = 1 << 11;

    const unsigned kImplodeDictionarySizeMask = 1 << 1;
    const unsigned kImplodeLiteralsOnMask     = 1 << 2;
    
    const unsigned kDeflateTypeBitStart = 1;
    const unsigned kNumDeflateTypeBits = 2;
    const unsigned kNumDeflateTypes = (1 << kNumDeflateTypeBits);
    const unsigned kDeflateTypeMask = (1 << kNumDeflateTypeBits) - 1;
  }
  
  namespace NHostOS
  {
    enum EEnum
    {
      kFAT      =  0,
      kAMIGA    =  1,
      kVMS      =  2,  // VAX/VMS
      kUnix     =  3,
      kVM_CMS   =  4,
      kAtari    =  5,  // what if it's a minix filesystem? [cjh]
      kHPFS     =  6,  // filesystem used by OS/2 (and NT 3.x)
      kMac      =  7,
      kZ_System =  8,
      kCPM      =  9,
      kTOPS20   = 10,  // pkzip 2.50 NTFS
      kNTFS     = 11,  // filesystem used by Windows NT
      kQDOS     = 12,  // SMS/QDOS
      kAcorn    = 13,  // Archimedes Acorn RISC OS
      kVFAT     = 14,  // filesystem used by Windows 95, NT
      kMVS      = 15,
      kBeOS     = 16,  // hybrid POSIX/database filesystem
      kTandem   = 17,
      kOS400    = 18,
      kOSX      = 19
    };
  }


  namespace NAmigaAttrib
  {
    const UInt32 kIFMT     = 06000;    // Amiga file type mask
    const UInt32 kIFDIR    = 04000;    // Amiga directory
    const UInt32 kIFREG    = 02000;    // Amiga regular file
    const UInt32 kIHIDDEN  = 00200;    // to be supported in AmigaDOS 3.x
    const UInt32 kISCRIPT  = 00100;    // executable script (text command file)
    const UInt32 kIPURE    = 00040;    // allow loading into resident memory
    const UInt32 kIARCHIVE = 00020;    // not modified since bit was last set
    const UInt32 kIREAD    = 00010;    // can be opened for reading
    const UInt32 kIWRITE   = 00004;    // can be opened for writing
    const UInt32 kIEXECUTE = 00002;    // executable image, a loadable runfile
    const UInt32 kIDELETE  = 00001;    // can be deleted
  }
}

}}

#endif
// Archive/ZipIn.cpp

#include "StdAfx.h"

// #include <stdio.h>

#include "../../../Common/DynamicBuffer.h"
#include "../../../Common/IntToString.h"
#include "../../../Common/StringToInt.h"

#include "../../../Windows/PropVariant.h"

#include "../../Common/StreamUtils.h"

#include "../IArchive.h"

#include "ZipIn.h"

#define Get16(p) GetUi16(p)
#define Get32(p) GetUi32(p)
#define Get64(p) GetUi64(p)

#define G16(offs, v) v = Get16(p + (offs))
#define G32(offs, v) v = Get32(p + (offs))
#define G64(offs, v) v = Get64(p + (offs))

namespace NArchive {
namespace NZip {

struct CEcd
{
  UInt16 ThisDisk;
  UInt16 CdDisk;
  UInt16 NumEntries_in_ThisDisk;
  UInt16 NumEntries;
  UInt32 Size;
  UInt32 Offset;
  UInt16 CommentSize;
  
  bool IsEmptyArc() const
  {
    return ThisDisk == 0
        && CdDisk == 0
        && NumEntries_in_ThisDisk == 0
        && NumEntries == 0
        && Size == 0
        && Offset == 0 // test it
    ;
  }

  void Parse(const Byte *p); // (p) doesn't include signature
};

void CEcd::Parse(const Byte *p)
{
  // (p) doesn't include signature
  G16(0, ThisDisk);
  G16(2, CdDisk);
  G16(4, NumEntries_in_ThisDisk);
  G16(6, NumEntries);
  G32(8, Size);
  G32(12, Offset);
  G16(16, CommentSize);
}


void CCdInfo::ParseEcd32(const Byte *p)
{
  // (p) includes signature
  p += 4;
  G16(0, ThisDisk);
  G16(2, CdDisk);
  G16(4, NumEntries_in_ThisDisk);
  G16(6, NumEntries);
  G32(8, Size);
  G32(12, Offset);
  G16(16, CommentSize);
}

void CCdInfo::ParseEcd64e(const Byte *p)
{
  // (p) exclude signature
  G16(0, VersionMade);
  G16(2, VersionNeedExtract);
  G32(4, ThisDisk);
  G32(8, CdDisk);

  G64(12, NumEntries_in_ThisDisk);
  G64(20, NumEntries);
  G64(28, Size);
  G64(36, Offset);
}


struct CLocator
{
  UInt32 Ecd64Disk;
  UInt32 NumDisks;
  UInt64 Ecd64Offset;
  
  CLocator(): Ecd64Disk(0), NumDisks(0), Ecd64Offset(0) {}

  void Parse(const Byte *p)
  {
    G32(0, Ecd64Disk);
    G64(4, Ecd64Offset);
    G32(12, NumDisks);
  }
};




void CInArchive::ClearRefs()
{
  StreamRef.Release();
  Stream = NULL;
  StartStream = NULL;
  Callback = NULL;

  Vols.Clear();
}

void CInArchive::Close()
{
  _processedCnt = 0;
  IsArc = false;
  IsArcOpen = false;
  IsMultiVol = false;
  UseDisk_in_SingleVol = false;
  EcdVolIndex = 0;
  HeadersError = false;
  HeadersWarning = false;
  ExtraMinorError = false;
  UnexpectedEnd = false;
  NoCentralDir = false;
  IsZip64 = false;
  MarkerIsFound = false;
  
  ClearRefs();
}


HRESULT CInArchive::Seek(UInt64 offset)
{
  return Stream->Seek(offset, STREAM_SEEK_SET, NULL);
}


static bool CheckDosTime(UInt32 dosTime)
{
  if (dosTime == 0)
    return true;
  unsigned month = (dosTime >> 21) & 0xF;
  unsigned day = (dosTime >> 16) & 0x1F;
  unsigned hour = (dosTime >> 11) & 0x1F;
  unsigned min = (dosTime >> 5) & 0x3F;
  unsigned sec = (dosTime & 0x1F) * 2;
  if (month < 1 || month > 12 || day < 1 || day > 31 || hour > 23 || min > 59 || sec > 59)
    return false;
  return true;
}

API_FUNC_IsArc IsArc_Zip(const Byte *p, size_t size)
{
  if (size < 8)
    return k_IsArc_Res_NEED_MORE;
  if (p[0] != 'P')
    return k_IsArc_Res_NO;

  UInt32 value = Get32(p);

  if (value == NSignature::kNoSpan
     || value == NSignature::kSpan)
  {
    p += 4;
    size -= 4;
  }

  value = Get32(p);

  if (value == NSignature::kEcd)
  {
    if (size < kEcdSize)
      return k_IsArc_Res_NEED_MORE;
    CEcd ecd;
    ecd.Parse(p + 4);
    // if (ecd.cdSize != 0)
    if (!ecd.IsEmptyArc())
      return k_IsArc_Res_NO;
    return k_IsArc_Res_YES; // k_IsArc_Res_YES_2;
  }
  
  if (value != NSignature::kLocalFileHeader)
    return k_IsArc_Res_NO;

  if (size < kLocalHeaderSize)
    return k_IsArc_Res_NEED_MORE;
  
  p += 4;

  {
    const unsigned kPureHeaderSize = kLocalHeaderSize - 4;
    unsigned i;
    for (i = 0; i < kPureHeaderSize && p[i] == 0; i++);
    if (i == kPureHeaderSize)
      return k_IsArc_Res_NEED_MORE;
  }

  /*
  if (p[0] >= 128) // ExtractVersion.Version;
    return k_IsArc_Res_NO;
  */

  // ExtractVersion.Version = p[0];
  // ExtractVersion.HostOS = p[1];
  // Flags = Get16(p + 2);
  // Method = Get16(p + 4);
  /*
  // 9.33: some zip archives contain incorrect value in timestamp. So we don't check it now
  UInt32 dosTime = Get32(p + 6);
  if (!CheckDosTime(dosTime))
    return k_IsArc_Res_NO;
  */
  // Crc = Get32(p + 10);
  // PackSize = Get32(p + 14);
  // Size = Get32(p + 18);
  const unsigned nameSize = Get16(p + 22);
  unsigned extraSize = Get16(p + 24);
  const UInt32 extraOffset = kLocalHeaderSize + (UInt32)nameSize;
  if (extraOffset + extraSize > (1 << 16))
    return k_IsArc_Res_NO;

  p -= 4;

  {
    size_t rem = size - kLocalHeaderSize;
    if (rem > nameSize)
      rem = nameSize;
    const Byte *p2 = p + kLocalHeaderSize;
    for (size_t i = 0; i < rem; i++)
      if (p2[i] == 0)
        if (i != nameSize - 1)
          return k_IsArc_Res_NO;
  }

  if (size < extraOffset)
    return k_IsArc_Res_NEED_MORE;

  if (extraSize > 0)
  {
    p += extraOffset;
    size -= extraOffset;
    while (extraSize != 0)
    {
      if (extraSize < 4)
      {
        // 7-Zip before 9.31 created incorrect WsAES Extra in folder's local headers.
        // so we return k_IsArc_Res_YES to support such archives.
        // return k_IsArc_Res_NO; // do we need to support such extra ?
        return k_IsArc_Res_YES;
      }
      if (size < 4)
        return k_IsArc_Res_NEED_MORE;
      unsigned dataSize = Get16(p + 2);
      size -= 4;
      extraSize -= 4;
      p += 4;
      if (dataSize > extraSize)
        return k_IsArc_Res_NO;
      if (dataSize > size)
        return k_IsArc_Res_NEED_MORE;
      size -= dataSize;
      extraSize -= dataSize;
      p += dataSize;
    }
  }
  
  return k_IsArc_Res_YES;
}

static UInt32 IsArc_Zip_2(const Byte *p, size_t size, bool isFinal)
{
  UInt32 res = IsArc_Zip(p, size);
  if (res == k_IsArc_Res_NEED_MORE && isFinal)
    return k_IsArc_Res_NO;
  return res;
}



HRESULT CInArchive::FindMarker(IInStream *stream, const UInt64 *searchLimit)
{
  ArcInfo.MarkerPos = m_Position;
  ArcInfo.MarkerPos2 = m_Position;

  if (searchLimit && *searchLimit == 0)
  {
    Byte startBuf[kMarkerSize];
    {
      size_t processed = kMarkerSize;
      RINOK(ReadStream(stream, startBuf, &processed));
      m_Position += processed;
      if (processed != kMarkerSize)
        return S_FALSE;
    }

    m_Signature = Get32(startBuf);

    if (m_Signature != NSignature::kEcd &&
        m_Signature != NSignature::kLocalFileHeader)
    {
      if (m_Signature != NSignature::kNoSpan)
      {
        if (m_Signature != NSignature::kSpan)
          return S_FALSE;
        if (m_Position != 4) // we don't support multivol archives with sfx stub
          return S_FALSE;
        ArcInfo.IsSpanMode = true;
      }
      size_t processed = kMarkerSize;
      RINOK(ReadStream(stream, startBuf, &processed));
      m_Position += processed;
      if (processed != kMarkerSize)
        return S_FALSE;
      m_Signature = Get32(startBuf);
      if (m_Signature != NSignature::kEcd &&
          m_Signature != NSignature::kLocalFileHeader)
        return S_FALSE;
      ArcInfo.MarkerPos2 += 4;
    }

    // we use weak test in case of (*searchLimit == 0)
    // since error will be detected later in Open function
    return S_OK; // maybe we need to search backward.
  }

  const size_t kBufSize = (size_t)1 << 18; // must be larger than kCheckSize
  const size_t kCheckSize = (size_t)1 << 16; // must be smaller than kBufSize
  CByteArr buffer(kBufSize);
  
  size_t numBytesInBuffer = 0;
  UInt64 curScanPos = 0;

  for (;;)
  {
    size_t numReadBytes = kBufSize - numBytesInBuffer;
    RINOK(ReadStream(stream, buffer + numBytesInBuffer, &numReadBytes));
    m_Position += numReadBytes;
    numBytesInBuffer += numReadBytes;
    const bool isFinished = (numBytesInBuffer != kBufSize);
    
    size_t limit = numBytesInBuffer;;
    if (isFinished)
    {
      if (limit == 0)
        break;
      limit--;
    }
    else
      limit -= kCheckSize;

    if (searchLimit && curScanPos + limit > *searchLimit)
      limit = (size_t)(*searchLimit - curScanPos + 1);

    if (limit < 1)
      break;

    const Byte *buf = buffer;
    for (size_t pos = 0; pos < limit; pos++)
    {
      if (buf[pos] != 0x50)
        continue;
      if (buf[pos + 1] != 0x4B)
        continue;
      size_t rem = numBytesInBuffer - pos;
      UInt32 res = IsArc_Zip_2(buf + pos, rem, isFinished);
      if (res != k_IsArc_Res_NO)
      {
        if (rem < kMarkerSize)
          return S_FALSE;
        m_Signature = Get32(buf + pos);
        ArcInfo.MarkerPos += curScanPos + pos;
        ArcInfo.MarkerPos2 = ArcInfo.MarkerPos;
        if (m_Signature == NSignature::kNoSpan
            || m_Signature == NSignature::kSpan)
        {
          m_Signature = Get32(buf + pos + 4);
          ArcInfo.MarkerPos2 += 4;
        }
        m_Position = ArcInfo.MarkerPos2 + kMarkerSize;
        return S_OK;
      }
    }

    if (isFinished)
      break;

    curScanPos += limit;
    numBytesInBuffer -= limit;
    memmove(buffer, buffer + limit, numBytesInBuffer);
  }
  
  return S_FALSE;
}


HRESULT CInArchive::IncreaseRealPosition(Int64 addValue, bool &isFinished)
{
  isFinished = false;
  if (!IsMultiVol)
    return Stream->Seek(addValue, STREAM_SEEK_CUR, &m_Position);

  for (;;)
  {
    if (addValue == 0)
      return S_OK;
    if (addValue > 0)
    {
      if (Vols.StreamIndex < 0)
        return S_FALSE;
      if ((unsigned)Vols.StreamIndex >= Vols.Streams.Size())
      {
        isFinished = true;
        return S_OK;
      }
      {
        const CVols::CSubStreamInfo &s = Vols.Streams[Vols.StreamIndex];
        if (!s.Stream)
        {
          isFinished = true;
          return S_OK;
        }
        if (m_Position > s.Size)
          return S_FALSE;
        UInt64 rem = s.Size - m_Position;
        if ((UInt64)addValue <= rem)
          return Stream->Seek(addValue, STREAM_SEEK_CUR, &m_Position);
        RINOK(Stream->Seek(s.Size, STREAM_SEEK_SET, &m_Position));
        addValue -= rem;
        Stream = NULL;
        Vols.StreamIndex++;
        if ((unsigned)Vols.StreamIndex >= Vols.Streams.Size())
        {
          isFinished = true;
          return S_OK;
        }
      }
      const CVols::CSubStreamInfo &s2 = Vols.Streams[Vols.StreamIndex];
      if (!s2.Stream)
      {
        isFinished = true;
        return S_OK;
      }
      Stream = s2.Stream;
      m_Position = 0;
      RINOK(Stream->Seek(0, STREAM_SEEK_SET, &m_Position));
    }
    else
    {
      if (!Stream)
        return S_FALSE;
      {
        if (m_Position >= (UInt64)(-addValue))
          return Stream->Seek(addValue, STREAM_SEEK_CUR, &m_Position);
        addValue += m_Position;
        RINOK(Stream->Seek(0, STREAM_SEEK_SET, &m_Position));
        m_Position = 0;
        Stream = NULL;
        if (--Vols.StreamIndex < 0)
          return S_FALSE;
      }
      const CVols::CSubStreamInfo &s2 = Vols.Streams[Vols.StreamIndex];
      if (!s2.Stream)
        return S_FALSE;
      Stream = s2.Stream;
      m_Position = s2.Size;
      RINOK(Stream->Seek(s2.Size, STREAM_SEEK_SET, &m_Position));
    }
  }
}


class CUnexpectEnd {};


HRESULT CInArchive::ReadBytes(void *data, UInt32 size, UInt32 *processedSize)
{
  size_t realProcessedSize = size;
  HRESULT result = S_OK;
  if (_inBufMode)
  {
    try { realProcessedSize = _inBuffer.ReadBytes((Byte *)data, size); }
    catch (const CInBufferException &e) { return e.ErrorCode; }
  }
  else
    result = ReadStream(Stream, data, &realProcessedSize);
  if (processedSize)
    *processedSize = (UInt32)realProcessedSize;
  m_Position += realProcessedSize;
  return result;
}

void CInArchive::SafeReadBytes(void *data, unsigned size)
{
  size_t processed = size;
  
  HRESULT result = S_OK;

  if (!_inBufMode)
    result = ReadStream(Stream, data, &processed);
  else
  {
    for (;;)
    {
      processed = _inBuffer.ReadBytes((Byte *)data, size);
      if (processed != 0
          || IsMultiVol
          || !CanStartNewVol
          || Vols.StreamIndex < 0
          || (unsigned)Vols.StreamIndex >= Vols.Streams.Size())
        break;
      Vols.StreamIndex++;
      const CVols::CSubStreamInfo &s = Vols.Streams[Vols.StreamIndex];
      if (!s.Stream)
        break;
      // if (Vols.NeedSeek)
      {
        result = s.Stream->Seek(0, STREAM_SEEK_SET, NULL);
        m_Position = 0;
        if (result != S_OK)
          break;
        Vols.NeedSeek = false;
      }
      _inBuffer.SetStream(s.Stream);
      _inBuffer.Init();
    }
    CanStartNewVol = false;
  }

  m_Position += processed;
  _processedCnt += processed;

  if (result != S_OK)
    throw CSystemException(result);
  
  if (processed != size)
    throw CUnexpectEnd();
}

void CInArchive::ReadBuffer(CByteBuffer &buffer, unsigned size)
{
  buffer.Alloc(size);
  if (size > 0)
    SafeReadBytes(buffer, size);
}

Byte CInArchive::ReadByte()
{
  Byte b;
  SafeReadBytes(&b, 1);
  return b;
}

UInt16 CInArchive::ReadUInt16() { Byte buf[2]; SafeReadBytes(buf, 2); return Get16(buf); }
UInt32 CInArchive::ReadUInt32() { Byte buf[4]; SafeReadBytes(buf, 4); return Get32(buf); }
UInt64 CInArchive::ReadUInt64() { Byte buf[8]; SafeReadBytes(buf, 8); return Get64(buf); }

// we use Skip() inside headers only, so no need for stream change in multivol.

void CInArchive::Skip(unsigned num)
{
  if (_inBufMode)
  {
    size_t skip = _inBuffer.Skip(num);
    m_Position += skip;
    _processedCnt += skip;
    if (skip != num)
      throw CUnexpectEnd();
  }
  else
  {
    for (unsigned i = 0; i < num; i++)
      ReadByte();
  }
}

void CInArchive::Skip64(UInt64 num)
{
  for (UInt64 i = 0; i < num; i++)
    ReadByte();
}


void CInArchive::ReadFileName(unsigned size, AString &s)
{
  if (size == 0)
  {
    s.Empty();
    return;
  }
  SafeReadBytes(s.GetBuf(size), size);
  s.ReleaseBuf_CalcLen(size);
}


bool CInArchive::ReadExtra(unsigned extraSize, CExtraBlock &extraBlock,
    UInt64 &unpackSize, UInt64 &packSize, UInt64 &localHeaderOffset, UInt32 &diskStartNumber)
{
  extraBlock.Clear();
  
  UInt32 remain = extraSize;
  
  while (remain >= 4)
  {
    CExtraSubBlock subBlock;
    subBlock.ID = ReadUInt16();
    unsigned dataSize = ReadUInt16();
    remain -= 4;
    if (dataSize > remain) // it's bug
    {
      HeadersWarning = true;
      Skip(remain);
      return false;
    }
    if (subBlock.ID == NFileHeader::NExtraID::kZip64)
    {
      if (unpackSize == 0xFFFFFFFF)
      {
        if (dataSize < 8)
        {
          HeadersWarning = true;
          Skip(remain);
          return false;
        }
        unpackSize = ReadUInt64();
        remain -= 8;
        dataSize -= 8;
      }
      if (packSize == 0xFFFFFFFF)
      {
        if (dataSize < 8)
          break;
        packSize = ReadUInt64();
        remain -= 8;
        dataSize -= 8;
      }
      if (localHeaderOffset == 0xFFFFFFFF)
      {
        if (dataSize < 8)
          break;
        localHeaderOffset = ReadUInt64();
        remain -= 8;
        dataSize -= 8;
      }
      if (diskStartNumber == 0xFFFF)
      {
        if (dataSize < 4)
          break;
        diskStartNumber = ReadUInt32();
        remain -= 4;
        dataSize -= 4;
      }
      Skip(dataSize);
    }
    else
    {
      ReadBuffer(subBlock.Data, dataSize);
      extraBlock.SubBlocks.Add(subBlock);
    }
    remain -= dataSize;
  }

  if (remain != 0)
  {
    ExtraMinorError = true;
    // 7-Zip before 9.31 created incorrect WsAES Extra in folder's local headers.
    // so we don't return false, but just set warning flag
    // return false;
  }
  
  Skip(remain);
  return true;
}


bool CInArchive::ReadLocalItem(CItemEx &item)
{
  item.Disk = 0;
  if (IsMultiVol && Vols.StreamIndex >= 0)
    item.Disk = Vols.StreamIndex;
  const unsigned kPureHeaderSize = kLocalHeaderSize - 4;
  Byte p[kPureHeaderSize];
  SafeReadBytes(p, kPureHeaderSize);
  {
    unsigned i;
    for (i = 0; i < kPureHeaderSize && p[i] == 0; i++);
    if (i == kPureHeaderSize)
      return false;
  }

  item.ExtractVersion.Version = p[0];
  item.ExtractVersion.HostOS = p[1];
  G16(2, item.Flags);
  G16(4, item.Method);
  G32(6, item.Time);
  G32(10, item.Crc);
  G32(14, item.PackSize);
  G32(18, item.Size);
  const unsigned nameSize = Get16(p + 22);
  const unsigned extraSize = Get16(p + 24);
  ReadFileName(nameSize, item.Name);
  item.LocalFullHeaderSize = kLocalHeaderSize + (UInt32)nameSize + extraSize;

  /*
  if (item.IsDir())
    item.Size = 0; // check It
  */

  if (extraSize > 0)
  {
    UInt64 localHeaderOffset = 0;
    UInt32 diskStartNumber = 0;
    if (!ReadExtra(extraSize, item.LocalExtra, item.Size, item.PackSize,
        localHeaderOffset, diskStartNumber))
    {
      /* Most of archives are OK for Extra. But there are some rare cases
         that have error. And if error in first item, it can't open archive.
         So we ignore that error */
      // return false;
    }
  }
  
  if (!CheckDosTime(item.Time))
  {
    HeadersWarning = true;
    // return false;
  }
  
  if (item.Name.Len() != nameSize)
  {
    // we support "bad" archives with null-terminated name.
    if (item.Name.Len() + 1 != nameSize)
      return false;
    HeadersWarning = true;
  }
  
  return item.LocalFullHeaderSize <= ((UInt32)1 << 16);
}


static bool FlagsAreSame(const CItem &i1, const CItem &i2)
{
  if (i1.Method != i2.Method)
    return false;
  if (i1.Flags == i2.Flags)
    return true;
  UInt32 mask = 0xFFFF;
  switch (i1.Method)
  {
    case NFileHeader::NCompressionMethod::kDeflated:
      mask = 0x7FF9;
      break;
    default:
      if (i1.Method <= NFileHeader::NCompressionMethod::kImploded)
        mask = 0x7FFF;
  }

  // we can ignore utf8 flag, if name is ascii
  if ((i1.Flags ^ i2.Flags) & NFileHeader::NFlags::kUtf8)
    if (i1.Name.IsAscii() && i2.Name.IsAscii())
      mask &= ~NFileHeader::NFlags::kUtf8;
  
  return ((i1.Flags & mask) == (i2.Flags & mask));
}


// #ifdef _WIN32
static bool AreEqualPaths_IgnoreSlashes(const char *s1, const char *s2)
{
  for (;;)
  {
    char c1 = *s1++;
    char c2 = *s2++;
    if (c1 == c2)
    {
      if (c1 == 0)
        return true;
    }
    else
    {
      if (c1 == '\\') c1 = '/';
      if (c2 == '\\') c2 = '/';
      if (c1 != c2)
        return false;
    }
  }
}
// #endif


static bool AreItemsEqual(const CItemEx &localItem, const CItemEx &cdItem)
{
  if (!FlagsAreSame(cdItem, localItem))
    return false;
  if (!localItem.HasDescriptor())
  {
    if (cdItem.Crc != localItem.Crc ||
        cdItem.PackSize != localItem.PackSize ||
        cdItem.Size != localItem.Size)
      return false;
  }
  /* pkzip 2.50 creates incorrect archives. It uses
       - WIN encoding for name in local header
       - OEM encoding for name in central header
     We don't support these strange items. */

  /* if (cdItem.Name.Len() != localItem.Name.Len())
    return false;
  */
  if (cdItem.Name != localItem.Name)
  {
    // #ifdef _WIN32
    // some xap files use backslash in central dir items.
    // we can ignore such errors in windows, where all slashes are converted to backslashes
    unsigned hostOs = cdItem.GetHostOS();
    
    if (hostOs == NFileHeader::NHostOS::kFAT ||
        hostOs == NFileHeader::NHostOS::kNTFS)
    {
      if (!AreEqualPaths_IgnoreSlashes(cdItem.Name, localItem.Name))
      {
        // pkzip 2.50 uses DOS encoding in central dir and WIN encoding in local header.
        // so we ignore that error
        if (hostOs != NFileHeader::NHostOS::kFAT
            || cdItem.MadeByVersion.Version != 25)
          return false;
      }
    }
    /*
    else
    #endif
      return false;
    */
  }
  return true;
}


HRESULT CInArchive::ReadLocalItemAfterCdItem(CItemEx &item, bool &isAvail)
{
  isAvail = true;
  if (item.FromLocal)
    return S_OK;
  try
  {
    UInt64 offset = item.LocalHeaderPos;

    if (IsMultiVol)
    {
      if (item.Disk >= Vols.Streams.Size())
      {
        isAvail = false;
        return S_FALSE;
      }
      IInStream *str2 = Vols.Streams[item.Disk].Stream;
      if (!str2)
      {
        isAvail = false;
        return S_FALSE;
      }
      RINOK(str2->Seek(offset, STREAM_SEEK_SET, NULL));
      Stream = str2;
      Vols.StreamIndex = item.Disk;
    }
    else
    {
      if (UseDisk_in_SingleVol && item.Disk != EcdVolIndex)
      {
        isAvail = false;
        return S_FALSE;
      }
      Stream = StreamRef;

      offset += ArcInfo.Base;
      if (ArcInfo.Base < 0 && (Int64)offset < 0)
      {
        isAvail = false;
        return S_FALSE;
      }
      RINOK(Seek(offset));
    }


    CItemEx localItem;
    if (ReadUInt32() != NSignature::kLocalFileHeader)
      return S_FALSE;
    ReadLocalItem(localItem);
    if (!AreItemsEqual(localItem, item))
      return S_FALSE;
    item.LocalFullHeaderSize = localItem.LocalFullHeaderSize;
    item.LocalExtra = localItem.LocalExtra;
    item.FromLocal = true;
  }
  catch(...) { return S_FALSE; }
  return S_OK;
}


HRESULT CInArchive::ReadLocalItemDescriptor(CItemEx &item)
{
  const unsigned kBufSize = (1 << 12);
  Byte buf[kBufSize];
  
  UInt32 numBytesInBuffer = 0;
  UInt32 packedSize = 0;
  
  for (;;)
  {
    UInt32 processedSize;
    RINOK(ReadBytes(buf + numBytesInBuffer, kBufSize - numBytesInBuffer, &processedSize));
    numBytesInBuffer += processedSize;
    if (numBytesInBuffer < kDataDescriptorSize)
      return S_FALSE;
    
    UInt32 i;
    for (i = 0; i <= numBytesInBuffer - kDataDescriptorSize; i++)
    {
      // descriptor signature field is Info-ZIP's extension to pkware Zip specification.
      // New ZIP specification also allows descriptorSignature.
      if (buf[i] != 0x50)
        continue;
      // !!!! It must be fixed for Zip64 archives
      if (Get32(buf + i) == NSignature::kDataDescriptor)
      {
        UInt32 descriptorPackSize = Get32(buf + i + 8);
        if (descriptorPackSize == packedSize + i)
        {
          item.Crc = Get32(buf + i + 4);
          item.PackSize = descriptorPackSize;
          item.Size = Get32(buf + i + 12);
          bool isFinished;
          return IncreaseRealPosition((Int64)(Int32)(0 - (numBytesInBuffer - i - kDataDescriptorSize)), isFinished);
        }
      }
    }
    
    packedSize += i;
    unsigned j;
    for (j = 0; i < numBytesInBuffer; i++, j++)
      buf[j] = buf[i];
    numBytesInBuffer = j;
  }
}


HRESULT CInArchive::ReadLocalItemAfterCdItemFull(CItemEx &item)
{
  if (item.FromLocal)
    return S_OK;
  try
  {
    bool isAvail = true;
    RINOK(ReadLocalItemAfterCdItem(item, isAvail));
    if (item.HasDescriptor())
    {
      // pkzip's version without descriptor is not supported
      RINOK(Seek(ArcInfo.Base + item.GetDataPosition() + item.PackSize));
      if (ReadUInt32() != NSignature::kDataDescriptor)
        return S_FALSE;
      UInt32 crc = ReadUInt32();
      UInt64 packSize, unpackSize;

      /*
      if (IsZip64)
      {
        packSize = ReadUInt64();
        unpackSize = ReadUInt64();
      }
      else
      */
      {
        packSize = ReadUInt32();
        unpackSize = ReadUInt32();
      }

      if (crc != item.Crc || item.PackSize != packSize || item.Size != unpackSize)
        return S_FALSE;
    }
  }
  catch(...) { return S_FALSE; }
  return S_OK;
}
  

HRESULT CInArchive::ReadCdItem(CItemEx &item)
{
  item.FromCentral = true;
  Byte p[kCentralHeaderSize - 4];
  SafeReadBytes(p, kCentralHeaderSize - 4);

  item.MadeByVersion.Version = p[0];
  item.MadeByVersion.HostOS = p[1];
  item.ExtractVersion.Version = p[2];
  item.ExtractVersion.HostOS = p[3];
  G16(4, item.Flags);
  G16(6, item.Method);
  G32(8, item.Time);
  G32(12, item.Crc);
  G32(16, item.PackSize);
  G32(20, item.Size);
  const unsigned nameSize = Get16(p + 24);
  const unsigned extraSize = Get16(p + 26);
  const unsigned commentSize = Get16(p + 28);
  G16(30, item.Disk);
  G16(32, item.InternalAttrib);
  G32(34, item.ExternalAttrib);
  G32(38, item.LocalHeaderPos);
  ReadFileName(nameSize, item.Name);
  
  if (extraSize > 0)
    ReadExtra(extraSize, item.CentralExtra, item.Size, item.PackSize, item.LocalHeaderPos, item.Disk);

  // May be these strings must be deleted
  /*
  if (item.IsDir())
    item.Size = 0;
  */
  
  ReadBuffer(item.Comment, commentSize);
  return S_OK;
}


HRESULT CInArchive::TryEcd64(UInt64 offset, CCdInfo &cdInfo)
{
  if (offset >= ((UInt64)1 << 63))
    return S_FALSE;
  RINOK(Seek(offset));
  Byte buf[kEcd64_FullSize];

  RINOK(ReadStream_FALSE(Stream, buf, kEcd64_FullSize));

  if (Get32(buf) != NSignature::kEcd64)
    return S_FALSE;
  UInt64 mainSize = Get64(buf + 4);
  if (mainSize < kEcd64_MainSize || mainSize > ((UInt64)1 << 32))
    return S_FALSE;
  cdInfo.ParseEcd64e(buf + 12);
  return S_OK;
}


HRESULT CInArchive::FindCd(bool checkOffsetMode)
{
  CCdInfo &cdInfo = Vols.ecd;

  UInt64 endPos;
  
  RINOK(Stream->Seek(0, STREAM_SEEK_END, &endPos));
  
  const UInt32 kBufSizeMax = ((UInt32)1 << 16) + kEcdSize + kEcd64Locator_Size + kEcd64_FullSize;
  const UInt32 bufSize = (endPos < kBufSizeMax) ? (UInt32)endPos : kBufSizeMax;
  if (bufSize < kEcdSize)
    return S_FALSE;
  CByteArr byteBuffer(bufSize);

  const UInt64 startPos = endPos - bufSize;
  RINOK(Stream->Seek(startPos, STREAM_SEEK_SET, &m_Position));
  if (m_Position != startPos)
    return S_FALSE;
  
  RINOK(ReadStream_FALSE(Stream, byteBuffer, bufSize));
  
  for (UInt32 i = bufSize - kEcdSize + 1;;)
  {
    if (i == 0)
      return S_FALSE;
    
    const Byte *buf = byteBuffer;

    for (;;)
    {
      i--;
      if (buf[i] == 0x50)
        break;
      if (i == 0)
        return S_FALSE;
    }
    
    if (Get32(buf + i) != NSignature::kEcd)
      continue;

    cdInfo.ParseEcd32(buf + i);
    
    if (i >= kEcd64Locator_Size)
    {
      const Byte *locatorPtr = buf + i - kEcd64Locator_Size;
      if (Get32(locatorPtr) == NSignature::kEcd64Locator)
      {
        CLocator locator;
        locator.Parse(locatorPtr + 4);
        if ((cdInfo.ThisDisk == locator.NumDisks - 1 || cdInfo.ThisDisk == 0xFFFF)
            && locator.Ecd64Disk < locator.NumDisks)
        {
          if (locator.Ecd64Disk != cdInfo.ThisDisk && cdInfo.ThisDisk != 0xFFFF)
            return E_NOTIMPL;
          
          // Most of the zip64 use fixed size Zip64 ECD
          // we try relative backward reading.

          UInt64 absEcd64 = endPos - bufSize + i - (kEcd64Locator_Size + kEcd64_FullSize);
          if (checkOffsetMode || absEcd64 == locator.Ecd64Offset)
          {
            const Byte *ecd64 = locatorPtr - kEcd64_FullSize;
            if (Get32(ecd64) == NSignature::kEcd64)
            {
              UInt64 mainEcd64Size = Get64(ecd64 + 4);
              if (mainEcd64Size == kEcd64_MainSize)
              {
                cdInfo.ParseEcd64e(ecd64 + 12);
                ArcInfo.Base = absEcd64 - locator.Ecd64Offset;
                // ArcInfo.BaseVolIndex = cdInfo.ThisDisk;
                return S_OK;
              }
            }
          }
          
          // some zip64 use variable size Zip64 ECD.
          // we try to use absolute offset from locator.

          if (absEcd64 != locator.Ecd64Offset)
          {
            if (TryEcd64(locator.Ecd64Offset, cdInfo) == S_OK)
            {
              ArcInfo.Base = 0;
              // ArcInfo.BaseVolIndex = cdInfo.ThisDisk;
              return S_OK;
            }
          }
          
          // for variable Zip64 ECD with for archives with offset != 0.

          if (checkOffsetMode
              && ArcInfo.MarkerPos != 0
              && ArcInfo.MarkerPos + locator.Ecd64Offset != absEcd64)
          {
            if (TryEcd64(ArcInfo.MarkerPos + locator.Ecd64Offset, cdInfo) == S_OK)
            {
              ArcInfo.Base = ArcInfo.MarkerPos;
              // ArcInfo.BaseVolIndex = cdInfo.ThisDisk;
              return S_OK;
            }
          }
        }
      }
    }
    
    // bool isVolMode = (Vols.EndVolIndex != -1);
    // UInt32 searchDisk = (isVolMode ? Vols.EndVolIndex : 0);
    
    if (/* searchDisk == thisDisk && */ cdInfo.CdDisk <= cdInfo.ThisDisk)
    {
      // if (isVolMode)
      {
        if (cdInfo.CdDisk != cdInfo.ThisDisk)
          return S_OK;
      }
      
      UInt64 absEcdPos = endPos - bufSize + i;
      UInt64 cdEnd = cdInfo.Size + cdInfo.Offset;
      ArcInfo.Base = 0;
      // ArcInfo.BaseVolIndex = cdInfo.ThisDisk;
      if (absEcdPos != cdEnd)
      {
        /*
        if (cdInfo.Offset <= 16 && cdInfo.Size != 0)
        {
          // here we support some rare ZIP files with Central directory at the start
          ArcInfo.Base = 0;
        }
        else
        */
        ArcInfo.Base = absEcdPos - cdEnd;
      }
      return S_OK;
    }
  }
}


HRESULT CInArchive::TryReadCd(CObjectVector<CItemEx> &items, const CCdInfo &cdInfo, UInt64 cdOffset, UInt64 cdSize)
{
  items.Clear();

  ISequentialInStream *stream;
  
  if (!IsMultiVol)
  {
    stream = this->StartStream;
    Vols.StreamIndex = -1;
    RINOK(this->StartStream->Seek(cdOffset, STREAM_SEEK_SET, &m_Position));
    if (m_Position != cdOffset)
      return S_FALSE;
  }
  else
  {
    if (cdInfo.CdDisk >= Vols.Streams.Size())
      return S_FALSE;
    IInStream *str2 = Vols.Streams[cdInfo.CdDisk].Stream;
    if (!str2)
      return S_FALSE;
    RINOK(str2->Seek(cdOffset, STREAM_SEEK_SET, NULL));
    stream = str2;
    Vols.NeedSeek = false;
    Vols.StreamIndex = cdInfo.CdDisk;
    m_Position = cdOffset;
  }

  _inBuffer.SetStream(stream);

  _inBuffer.Init();
  _inBufMode = true;

  _processedCnt = 0;

  while (_processedCnt < cdSize)
  {
    CanStartNewVol = true;
    if (ReadUInt32() != NSignature::kCentralFileHeader)
      return S_FALSE;
    {
      CItemEx cdItem;
      RINOK(ReadCdItem(cdItem));
      items.Add(cdItem);
    }
    if (Callback && (items.Size() & 0xFFF) == 0)
    {
      const UInt64 numFiles = items.Size();
      RINOK(Callback->SetCompleted(&numFiles, NULL));
    }
  }

  CanStartNewVol = true;

  return (_processedCnt == cdSize) ? S_OK : S_FALSE;
}


HRESULT CInArchive::ReadCd(CObjectVector<CItemEx> &items, UInt32 &cdDisk, UInt64 &cdOffset, UInt64 &cdSize)
{
  bool checkOffsetMode = true;
  
  if (IsMultiVol)
  {
    if (Vols.EndVolIndex == -1)
      return S_FALSE;
    Stream = Vols.Streams[Vols.EndVolIndex].Stream;
    if (!Vols.StartIsZip)
      checkOffsetMode = false;
  }
  else
    Stream = StartStream;

  if (!Vols.ecd_wasRead)
  {
    RINOK(FindCd(checkOffsetMode));
  }

  CCdInfo &cdInfo = Vols.ecd;
  
  HRESULT res = S_FALSE;
  
  cdSize = cdInfo.Size;
  cdOffset = cdInfo.Offset;
  cdDisk = cdInfo.CdDisk;

  if (Callback)
  {
    RINOK(Callback->SetTotal(&cdInfo.NumEntries, NULL));
  }
  
  const UInt64 base = (IsMultiVol ? 0 : ArcInfo.Base);
  res = TryReadCd(items, cdInfo, base + cdOffset, cdSize);
  
  if (res == S_FALSE && !IsMultiVol && base != ArcInfo.MarkerPos)
  {
    // do we need that additional attempt to read cd?
    res = TryReadCd(items, cdInfo, ArcInfo.MarkerPos + cdOffset, cdSize);
    if (res == S_OK)
      ArcInfo.Base = ArcInfo.MarkerPos;
  }
  
  return res;
}


static int FindItem(const CObjectVector<CItemEx> &items, const CItemEx &item)
{
  unsigned left = 0, right = items.Size();
  for (;;)
  {
    if (left >= right)
      return -1;
    unsigned index = (left + right) / 2;
    const CItemEx &item2 = items[index];
    if (item.Disk < item2.Disk)
      right = index;
    else if (item.Disk > item2.Disk)
      left = index + 1;
    else if (item.LocalHeaderPos == item2.LocalHeaderPos)
      return index;
    else if (item.LocalHeaderPos < item2.LocalHeaderPos)
      right = index;
    else
      left = index + 1;
  }
}

static bool IsStrangeItem(const CItem &item)
{
  return item.Name.Len() > (1 << 14) || item.Method > (1 << 8);
}


HRESULT CInArchive::ReadLocals(CObjectVector<CItemEx> &items)
{
  items.Clear();
  
  while (m_Signature == NSignature::kLocalFileHeader)
  {
    CItemEx item;
    item.LocalHeaderPos = m_Position - 4;
    if (!IsMultiVol)
      item.LocalHeaderPos -= ArcInfo.MarkerPos;

    // we write ralative LocalHeaderPos here. Later we can correct it to real Base.
    
    try
    {
      ReadLocalItem(item);
      item.FromLocal = true;
      bool isFinished = false;
  
      if (item.HasDescriptor())
        ReadLocalItemDescriptor(item);
      else
      {
        /*
        if (IsMultiVol)
        {
          const int kStep = 10000;
          RINOK(IncreaseRealPosition(-kStep, isFinished));
          RINOK(IncreaseRealPosition(item.PackSize + kStep, isFinished));
        }
        else
        */
        RINOK(IncreaseRealPosition(item.PackSize, isFinished));
      }
      
      items.Add(item);
      
      if (isFinished)
        throw CUnexpectEnd();
      
      m_Signature = ReadUInt32();
    }
    catch (CUnexpectEnd &)
    {
      if (items.IsEmpty() || items.Size() == 1 && IsStrangeItem(items[0]))
        return S_FALSE;
      throw;
    }

    if (Callback && (items.Size() & 0xFF) == 0)
    {
      const UInt64 numFiles = items.Size();
      UInt64 numBytes = 0;
      // if (!sMultiVol)
        numBytes = item.LocalHeaderPos;
      RINOK(Callback->SetCompleted(&numFiles, &numBytes));
    }
  }

  if (items.Size() == 1 && m_Signature != NSignature::kCentralFileHeader)
    if (IsStrangeItem(items[0]))
      return S_FALSE;
  
  return S_OK;
}



HRESULT CVols::ParseArcName(IArchiveOpenVolumeCallback *volCallback)
{
  UString name;
  {
    NWindows::NCOM::CPropVariant prop;
    RINOK(volCallback->GetProperty(kpidName, &prop));
    if (prop.vt != VT_BSTR)
      return S_OK;
    name = prop.bstrVal;
  }

  UString base = name;
  int dotPos = name.ReverseFind_Dot();

  if (dotPos < 0)
    return S_OK;

  base.DeleteFrom(dotPos + 1);

  const UString ext = name.Ptr(dotPos + 1);
  StartVolIndex = (Int32)(-1);

  if (ext.IsEmpty())
    return S_OK;
  else
  {
    wchar_t c = ext[0];
    IsUpperCase = (c >= 'A' && c <= 'Z');
    if (ext.IsEqualTo_Ascii_NoCase("zip"))
    {
      BaseName = base;
      StartIsZ = true;
      StartIsZip = true;
      return S_OK;
    }
    else if (ext.IsEqualTo_Ascii_NoCase("exe"))
    {
      StartIsExe = true;
      BaseName = base;
      StartVolIndex = 0;
    }
    else if (ext[0] == 'z' || ext[0] == 'Z')
    {
      if (ext.Len() < 3)
        return S_OK;
      const wchar_t *end = NULL;
      UInt32 volNum = ConvertStringToUInt32(ext.Ptr(1), &end);
      if (*end != 0 || volNum < 1 || volNum > ((UInt32)1 << 30))
        return S_OK;
      StartVolIndex = volNum - 1;
      BaseName = base;
      StartIsZ = true;
    }
    else
      return S_OK;
  }

  UString volName = BaseName;
  volName.AddAscii(IsUpperCase ? "ZIP" : "zip");
  HRESULT result = volCallback->GetStream(volName, &ZipStream);
  if (result == S_FALSE || !ZipStream)
  {
    if (MissingName.IsEmpty())
      MissingName = volName;
    return S_OK;
  }

  return result;
}


HRESULT CInArchive::ReadVols2(IArchiveOpenVolumeCallback *volCallback,
    unsigned start, int lastDisk, int zipDisk, unsigned numMissingVolsMax, unsigned &numMissingVols)
{
  numMissingVols = 0;

  for (unsigned i = start;; i++)
  {
    if (lastDisk >= 0 && i >= (unsigned)lastDisk)
      break;
    
    if (i < Vols.Streams.Size())
      if (Vols.Streams[i].Stream)
        continue;

    CMyComPtr<IInStream> stream;

    if ((int)i == zipDisk)
    {
      stream = Vols.ZipStream;
    }
    else if ((int)i == Vols.StartVolIndex)
    {
      stream = StartStream;
    }
    else
    {
      UString volName = Vols.BaseName;
      {
        volName += (wchar_t)(Vols.IsUpperCase ? 'Z' : 'z');
        {
          char s[32];
          ConvertUInt32ToString(i + 1, s);
          unsigned len = (unsigned)strlen(s);
          while (len < 2)
          {
            volName += (wchar_t)'0';
            len++;
          }
          volName.AddAscii(s);
        }
      }
        
      HRESULT result = volCallback->GetStream(volName, &stream);
      if (result != S_OK && result != S_FALSE)
        return result;
      if (result == S_FALSE || !stream)
      {
        if (Vols.MissingName.IsEmpty())
          Vols.MissingName = volName;
        numMissingVols++;
        if (numMissingVols > numMissingVolsMax)
          return S_OK;
        if (lastDisk == -1 && numMissingVols != 0)
          return S_OK;
        continue;
      }
    }

    UInt64 size;

    UInt64 pos;
    RINOK(stream->Seek(0, STREAM_SEEK_CUR, &pos));
    RINOK(stream->Seek(0, STREAM_SEEK_END, &size));
    RINOK(stream->Seek(pos, STREAM_SEEK_SET, NULL));

    while (i >= Vols.Streams.Size())
      Vols.Streams.AddNew();
    
    CVols::CSubStreamInfo &ss = Vols.Streams[i];
    Vols.NumVols++;
    ss.Stream = stream;
    ss.Size = size;

    if ((int)i == zipDisk)
    {
      Vols.EndVolIndex = Vols.Streams.Size() - 1;
      break;
    }
  }

  return S_OK;
}


HRESULT CInArchive::ReadVols()
{
  CMyComPtr<IArchiveOpenVolumeCallback> volCallback;

  Callback->QueryInterface(IID_IArchiveOpenVolumeCallback, (void **)&volCallback);
  if (!volCallback)
    return S_OK;

  RINOK(Vols.ParseArcName(volCallback));

  int startZIndex = Vols.StartVolIndex;

  if (!Vols.StartIsZ)
  {
    // if (!Vols.StartIsExe)
      return S_OK;
  }

  int zipDisk = -1;
  int cdDisk = -1;

  if (Vols.StartIsZip)
    Vols.ZipStream = StartStream;

  // bool cdOK = false;

  if (Vols.ZipStream)
  {
    Stream = Vols.ZipStream;
    HRESULT res = FindCd(true);
    CCdInfo &ecd = Vols.ecd;
    if (res == S_OK)
    {
      zipDisk = ecd.ThisDisk;
      Vols.ecd_wasRead = true;
      if (ecd.ThisDisk == 0
          || ecd.ThisDisk >= ((UInt32)1 << 30)
          || ecd.ThisDisk < ecd.CdDisk)
        return S_OK;
      cdDisk = ecd.CdDisk;
      if (Vols.StartVolIndex < 0)
        Vols.StartVolIndex = ecd.ThisDisk;
      // Vols.StartVolIndex = ecd.ThisDisk;
      // Vols.EndVolIndex = ecd.ThisDisk;
      unsigned numMissingVols;
      if (cdDisk == zipDisk)
      {
        // cdOK = true;
      }
      else
      {
        RINOK(ReadVols2(volCallback, cdDisk, zipDisk, zipDisk, 0, numMissingVols));
        if (numMissingVols == 0)
        {
          // cdOK = false;
        }
      }
    }
    else if (res != S_FALSE)
      return res;
  }

  if (Vols.Streams.Size() > 0)
    IsMultiVol = true;
  
  if (Vols.StartVolIndex < 0)
    return S_OK;

  unsigned numMissingVols;

  if (cdDisk != 0)
  {
    RINOK(ReadVols2(volCallback, 0, cdDisk < 0 ? -1 : cdDisk, zipDisk, 1 << 10, numMissingVols));
  }

  if (Vols.ZipStream)
  {
    if (Vols.Streams.IsEmpty())
      if (zipDisk > (1 << 10))
        return S_OK;
    RINOK(ReadVols2(volCallback, zipDisk, zipDisk + 1, zipDisk, 0, numMissingVols));
  }

  if (!Vols.Streams.IsEmpty())
  {
    IsMultiVol = true;
    /*
    if (cdDisk)
      IsMultiVol = true;
    */
    if (startZIndex >= 0)
    {
      if (Vols.Streams.Size() >= (unsigned)startZIndex)
      {
        for (unsigned i = 0; i < (unsigned)startZIndex; i++)
          if (!Vols.Streams[i].Stream)
          {
            Vols.StartParsingVol = startZIndex;
            break;
          }
      }
    }
  }

  return S_OK;
}







HRESULT CVols::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (size == 0)
    return S_OK;

  for (;;)
  {
    if (StreamIndex < 0)
      return S_OK;
    if ((unsigned)StreamIndex >= Streams.Size())
      return S_OK;
    const CVols::CSubStreamInfo &s = Streams[StreamIndex];
    if (!s.Stream)
      return S_FALSE;
    if (NeedSeek)
    {
      RINOK(s.Stream->Seek(0, STREAM_SEEK_SET, NULL));
      NeedSeek = false;
    }
    UInt32 realProcessedSize = 0;
    HRESULT res = s.Stream->Read(data, size, &realProcessedSize);
    if (processedSize)
      *processedSize = realProcessedSize;
    if (res != S_OK)
      return res;
    if (realProcessedSize != 0)
      return res;
    StreamIndex++;
    NeedSeek = true;
  }
}

STDMETHODIMP CVolStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  return Vols->Read(data, size, processedSize);
}




#define COPY_ECD_ITEM_16(n) if (!isZip64 || ecd. n != 0xFFFF)     ecd64. n = ecd. n;
#define COPY_ECD_ITEM_32(n) if (!isZip64 || ecd. n != 0xFFFFFFFF) ecd64. n = ecd. n;


HRESULT CInArchive::ReadHeaders2(CObjectVector<CItemEx> &items)
{
  HRESULT res = S_OK;

  bool localsWereRead = false;
  UInt64 cdSize = 0, cdRelatOffset = 0, cdAbsOffset = 0;
  UInt32 cdDisk = 0;

  if (!_inBuffer.Create(1 << 15))
    return E_OUTOFMEMORY;

  if (!MarkerIsFound)
  {
    IsArc = true;
    res = ReadCd(items, cdDisk, cdRelatOffset, cdSize);
    if (res == S_OK)
      m_Signature = ReadUInt32();
  }
  else
  {
 
  // m_Signature must be kLocalFileHeader or kEcd
  // m_Position points to next byte after signature
  RINOK(Stream->Seek(m_Position, STREAM_SEEK_SET, NULL));

  _inBuffer.SetStream(Stream);

  bool needReadCd = true;

  if (m_Signature == NSignature::kEcd)
  {
    // It must be empty archive or backware archive
    // we don't support backware archive still
    
    const unsigned kBufSize = kEcdSize - 4;
    Byte buf[kBufSize];
    SafeReadBytes(buf, kBufSize);
    CEcd ecd;
    ecd.Parse(buf);
    // if (ecd.cdSize != 0)
    // Do we need also to support the case where empty zip archive with PK00 uses cdOffset = 4 ??
    if (!ecd.IsEmptyArc())
      return S_FALSE;

    ArcInfo.Base = ArcInfo.MarkerPos;
    needReadCd = false;
    IsArc = true; // check it: we need more tests?
    RINOK(Stream->Seek(ArcInfo.MarkerPos2 + 4, STREAM_SEEK_SET, &m_Position));
  }

  if (needReadCd)
  {
    CItemEx firstItem;
    // try
    {
      try
      {
        if (!ReadLocalItem(firstItem))
          return S_FALSE;
      }
      catch(CUnexpectEnd &)
      {
        return S_FALSE;
      }

      IsArc = true;
      res = ReadCd(items, cdDisk, cdRelatOffset, cdSize);
      if (res == S_OK)
        m_Signature = ReadUInt32();
    }
    // catch() { res = S_FALSE; }
    if (res != S_FALSE && res != S_OK)
      return res;

    if (res == S_OK && items.Size() == 0)
      res = S_FALSE;

    if (res == S_OK)
    {
      // we can't read local items here to keep _inBufMode state
      if ((Int64)ArcInfo.MarkerPos2 < ArcInfo.Base)
        res = S_FALSE;
      else
      {
        firstItem.LocalHeaderPos = ArcInfo.MarkerPos2 - ArcInfo.Base;
        int index = FindItem(items, firstItem);
        if (index == -1)
          res = S_FALSE;
        else if (!AreItemsEqual(firstItem, items[index]))
          res = S_FALSE;
        else
        {
          ArcInfo.CdWasRead = true;
          ArcInfo.FirstItemRelatOffset = items[0].LocalHeaderPos;
        }
      }
    }
  }
  }



  CObjectVector<CItemEx> cdItems;

  bool needSetBase = false;
  unsigned numCdItems = items.Size();
  
  if (res == S_FALSE)
  {
    // CD doesn't match firstItem,
    // so we clear items and read Locals.
    items.Clear();
    localsWereRead = true;
    _inBufMode = false;
    ArcInfo.Base = ArcInfo.MarkerPos;

    if (IsMultiVol)
    {
      Vols.StreamIndex = Vols.StartParsingVol;
      if (Vols.StartParsingVol >= (int)Vols.Streams.Size())
        return S_FALSE;
      Stream = Vols.Streams[Vols.StartParsingVol].Stream;
      if (!Stream)
        return S_FALSE;
    }

    RINOK(Stream->Seek(ArcInfo.MarkerPos2, STREAM_SEEK_SET, &m_Position));
    m_Signature = ReadUInt32();
    
    RINOK(ReadLocals(items));

    if (m_Signature != NSignature::kCentralFileHeader)
    {
      // if (!UnexpectedEnd)
        m_Position -= 4;
      NoCentralDir = true;
      HeadersError = true;
      return S_OK;
    }
    
    _inBufMode = true;
    _inBuffer.Init();
    
    cdAbsOffset = m_Position - 4;
    cdDisk = Vols.StreamIndex;

    for (;;)
    {
      CItemEx cdItem;
      CanStartNewVol = true;
      
      RINOK(ReadCdItem(cdItem));
      
      cdItems.Add(cdItem);
      if (Callback && (cdItems.Size() & 0xFFF) == 0)
      {
        const UInt64 numFiles = items.Size();
        RINOK(Callback->SetCompleted(&numFiles, NULL));
      }
      CanStartNewVol = true;
      m_Signature = ReadUInt32();
      if (m_Signature != NSignature::kCentralFileHeader)
        break;
    }
    
    cdSize = (m_Position - 4) - cdAbsOffset;
    needSetBase = true;
    numCdItems = cdItems.Size();

    if (!cdItems.IsEmpty())
    {
      ArcInfo.CdWasRead = true;
      ArcInfo.FirstItemRelatOffset = cdItems[0].LocalHeaderPos;
    }
  }

  
  
  CCdInfo ecd64;
  CLocator locator;
  bool isZip64 = false;
  const UInt64 ecd64AbsOffset = m_Position - 4;
  int ecd64Disk = -1;
  
  if (m_Signature == NSignature::kEcd64)
  {
    ecd64Disk = Vols.StreamIndex;

    IsZip64 = isZip64 = true;

    {
      const UInt64 recordSize = ReadUInt64();
      if (recordSize < kEcd64_MainSize)
      {
        HeadersError = true;
        return S_OK;
      }
      
      {
        const unsigned kBufSize = kEcd64_MainSize;
        Byte buf[kBufSize];
        SafeReadBytes(buf, kBufSize);
        ecd64.ParseEcd64e(buf);
      }
      
      Skip64(recordSize - kEcd64_MainSize);
    }


    m_Signature = ReadUInt32();

    if (m_Signature != NSignature::kEcd64Locator)
    {
      HeadersError = true;
      return S_OK;
    }
  
    {
      const unsigned kBufSize = 16;
      Byte buf[kBufSize];
      SafeReadBytes(buf, kBufSize);
      locator.Parse(buf);
    }

    m_Signature = ReadUInt32();
  }
  
  
  if (m_Signature != NSignature::kEcd)
  {
    HeadersError = true;
    return S_OK;
  }

  
  // ---------- ECD ----------

  CEcd ecd;
  {
    const unsigned kBufSize = kEcdSize - 4;
    Byte buf[kBufSize];
    SafeReadBytes(buf, kBufSize);
    ecd.Parse(buf);
  }

  COPY_ECD_ITEM_16(ThisDisk);
  COPY_ECD_ITEM_16(CdDisk);
  COPY_ECD_ITEM_16(NumEntries_in_ThisDisk);
  COPY_ECD_ITEM_16(NumEntries);
  COPY_ECD_ITEM_32(Size);
  COPY_ECD_ITEM_32(Offset);

  if (IsMultiVol)
  {
    if (cdDisk != (int)ecd64.CdDisk)
      HeadersError = true;
  }
  else if (needSetBase)
  {
    if (isZip64)
    {
      if (ecd64Disk == Vols.StartVolIndex)
      {
        ArcInfo.Base = ecd64AbsOffset - locator.Ecd64Offset;
        // cdRelatOffset = ecd64.Offset;
        needSetBase = false;
      }
    }
    else
    {
      if ((int)cdDisk == Vols.StartVolIndex)
      {
        ArcInfo.Base = cdAbsOffset - ecd64.Offset;
        cdRelatOffset = ecd64.Offset;
        needSetBase = false;
      }
    }
  }

  EcdVolIndex = ecd64.ThisDisk;

  if (!IsMultiVol)
  {
    UseDisk_in_SingleVol = true;

    if (localsWereRead)
    {
      if ((UInt64)ArcInfo.Base != ArcInfo.MarkerPos)
      {
        const UInt64 delta = ArcInfo.MarkerPos - ArcInfo.Base;
        FOR_VECTOR (i, items)
          items[i].LocalHeaderPos += delta;
      }
      
      if (EcdVolIndex != 0)
      {
        FOR_VECTOR (i, items)
          items[i].Disk = EcdVolIndex;
      }
    }
  }

  if (isZip64)
  {
    if (ecd64.ThisDisk == 0 && ecd64AbsOffset != ArcInfo.Base + locator.Ecd64Offset
        // || ecd64.NumEntries_in_ThisDisk != numCdItems
        || ecd64.NumEntries != numCdItems
        || ecd64.Size != cdSize
        || (ecd64.Offset != cdRelatOffset && !items.IsEmpty()))
    {
      HeadersError = true;
      return S_OK;
    }
  }

  // ---------- merge Central Directory Items ----------

  if (!cdItems.IsEmpty())
  {
    CObjectVector<CItemEx> items2;

    FOR_VECTOR (i, cdItems)
    {
      const CItemEx &cdItem = cdItems[i];
      int index = FindItem(items, cdItem);
      if (index == -1)
      {
        items2.Add(cdItem);
        HeadersError = true;
        continue;
      }
      CItemEx &item = items[index];
      if (item.Name != cdItem.Name
          // || item.Name.Len() != cdItem.Name.Len()
          || item.PackSize != cdItem.PackSize
          || item.Size != cdItem.Size
          // item.ExtractVersion != cdItem.ExtractVersion
          || !FlagsAreSame(item, cdItem)
          || item.Crc != cdItem.Crc)
      {
        HeadersError = true;
        continue;
      }

      // item.Name = cdItem.Name;
      item.MadeByVersion = cdItem.MadeByVersion;
      item.CentralExtra = cdItem.CentralExtra;
      item.InternalAttrib = cdItem.InternalAttrib;
      item.ExternalAttrib = cdItem.ExternalAttrib;
      item.Comment = cdItem.Comment;
      item.FromCentral = cdItem.FromCentral;
    }

    items += items2;
  }


  if (ecd.NumEntries < ecd.NumEntries_in_ThisDisk)
    HeadersError = true;

  if (ecd.ThisDisk == 0)
  {
    // if (isZip64)
    {
      if (ecd.NumEntries != ecd.NumEntries_in_ThisDisk)
        HeadersError = true;
    }
  }

  if (ecd.NumEntries > items.Size())
    HeadersError = true;

  if (isZip64)
  {
    if (ecd64.NumEntries != items.Size())
      HeadersError = true;
  }
  else
  {
    // old 7-zip could store 32-bit number of CD items to 16-bit field.
    /*
    if ((UInt16)ecd64.NumEntries == (UInt16)items.Size())
      HeadersError = true;
    */
  }

  ReadBuffer(ArcInfo.Comment, ecd.CommentSize);
  _inBufMode = false;
  _inBuffer.Free();

  if ((UInt16)ecd64.NumEntries != (UInt16)numCdItems
      || (UInt32)ecd64.Size != (UInt32)cdSize
      || ((UInt32)ecd64.Offset != (UInt32)cdRelatOffset && !items.IsEmpty()))
  {
    // return S_FALSE;
    HeadersError = true;
  }
  
  // printf("\nOpen OK");
  return S_OK;
}



HRESULT CInArchive::Open(IInStream *stream, const UInt64 *searchLimit,
    IArchiveOpenCallback *callback, CObjectVector<CItemEx> &items)
{
  _inBufMode = false;
  items.Clear();
  
  Close();
  ArcInfo.Clear();

  UInt64 startPos;
  RINOK(stream->Seek(0, STREAM_SEEK_CUR, &startPos));
  RINOK(stream->Seek(0, STREAM_SEEK_END, &ArcInfo.FileEndPos));
  m_Position = ArcInfo.FileEndPos;

  StartStream = stream;
  Callback = callback;
  
  bool volWasRequested = false;

  if (callback
      && (startPos == 0 || !searchLimit || *searchLimit != 0))
  {
    volWasRequested = true;
    RINOK(ReadVols());
  }

  if (IsMultiVol && Vols.StartVolIndex != 0)
  {
    Stream = Vols.Streams[0].Stream;
    if (Stream)
    {
      m_Position = 0;
      RINOK(Stream->Seek(0, STREAM_SEEK_SET, NULL));
      UInt64 limit = 0;
      HRESULT res = FindMarker(Stream, &limit);
      if (res == S_OK)
        MarkerIsFound = true;
      else if (res != S_FALSE)
        return res;
    }
  }
  else
  {
    // printf("\nOpen offset = %u\n", (unsigned)startPos);
    RINOK(stream->Seek(startPos, STREAM_SEEK_SET, NULL));
    m_Position = startPos;
    HRESULT res = FindMarker(stream, searchLimit);
    UInt64 curPos = m_Position;
    if (res == S_OK)
      MarkerIsFound = true;
    else
    {
      // if (res != S_FALSE)
      return res;
    }

    MarkerIsFound = true;
    
    if (ArcInfo.IsSpanMode && !volWasRequested)
    {
      RINOK(ReadVols());
    }
    
    if (IsMultiVol && (unsigned)Vols.StartVolIndex < Vols.Streams.Size())
    {
      Stream = Vols.Streams[Vols.StartVolIndex].Stream;
      if (!Stream)
        IsMultiVol = false;
      else
      {
        RINOK(Stream->Seek(curPos, STREAM_SEEK_SET, NULL));
        m_Position = curPos;
      }
    }
    else
      IsMultiVol = false;

    if (!IsMultiVol)
    {
      RINOK(stream->Seek(curPos, STREAM_SEEK_SET, NULL));
      m_Position = curPos;
      StreamRef = stream;
      Stream = stream;
    }
  }


  {
    HRESULT res;
    try
    {
      res = ReadHeaders2(items);
    }
    catch (const CInBufferException &e) { res = e.ErrorCode; }
    catch (const CUnexpectEnd &)
    {
      if (items.IsEmpty())
        return S_FALSE;
      UnexpectedEnd = true;
      res = S_OK;
    }
    catch (...)
    {
      _inBufMode = false;
      throw;
    }
    
    if (IsMultiVol)
    {
      ArcInfo.FinishPos = ArcInfo.FileEndPos;
      if ((unsigned)Vols.StreamIndex < Vols.Streams.Size())
        if (m_Position < Vols.Streams[Vols.StreamIndex].Size)
          ArcInfo.ThereIsTail = true;
    }
    else
    {
      ArcInfo.FinishPos = m_Position;
      ArcInfo.ThereIsTail = (ArcInfo.FileEndPos > m_Position);
    }

    _inBufMode = false;
    IsArcOpen = true;
    if (!IsMultiVol)
      Vols.Streams.Clear();
    return res;
  }
}


HRESULT CInArchive::GetItemStream(const CItemEx &item, bool seekPackData, CMyComPtr<ISequentialInStream> &stream)
{
  stream.Release();

  UInt64 pos = item.LocalHeaderPos;
  if (seekPackData)
    pos += item.LocalFullHeaderSize;

  if (!IsMultiVol)
  {
    if (UseDisk_in_SingleVol && item.Disk != EcdVolIndex)
      return S_OK;
    pos += ArcInfo.Base;
    RINOK(StreamRef->Seek(pos, STREAM_SEEK_SET, NULL));
    stream = StreamRef;
    return S_OK;
  }

  if (item.Disk >= Vols.Streams.Size())
    return S_OK;
    
  IInStream *str2 = Vols.Streams[item.Disk].Stream;
  if (!str2)
    return S_OK;
  RINOK(str2->Seek(pos, STREAM_SEEK_SET, NULL));
    
  Vols.NeedSeek = false;
  Vols.StreamIndex = item.Disk;
    
  CVolStream *volsStreamSpec = new CVolStream;
  volsStreamSpec->Vols = &Vols;
  stream = volsStreamSpec;
  
  return S_OK;
}

}}
// Archive/ZipIn.h

#ifndef __ZIP_IN_H
#define __ZIP_IN_H

#include "../../../Common/MyCom.h"

#include "../../IStream.h"

#include "../../Common/InBuffer.h"

#include "ZipHeader.h"
#include "ZipItem.h"

API_FUNC_IsArc IsArc_Zip(const Byte *p, size_t size);

namespace NArchive {
namespace NZip {
  
class CItemEx: public CItem
{
public:
  UInt32 LocalFullHeaderSize; // including Name and Extra
  
  UInt64 GetLocalFullSize() const
    { return LocalFullHeaderSize + PackSize + (HasDescriptor() ? kDataDescriptorSize : 0); }
  UInt64 GetDataPosition() const
    { return LocalHeaderPos + LocalFullHeaderSize; }
};


struct CInArchiveInfo
{
  Int64 Base; /* Base offset of start of archive in stream.
                 Offsets in headers must be calculated from that Base.
                 Base is equal to MarkerPos for normal ZIPs.
                 Base can point to PE stub for some ZIP SFXs.
                 if CentralDir was read,
                   Base can be negative, if start of data is not available,
                 if CentralDirs was not read,
                   Base = ArcInfo.MarkerPos; */

  /* The following *Pos variables contain absolute offsets in Stream */

  UInt64 MarkerPos;  /* Pos of first signature, it can point to kSpan/kNoSpan signature
                        = MarkerPos2      in most archives
                        = MarkerPos2 - 4  if there is kSpan/kNoSpan signature */
  UInt64 MarkerPos2; // Pos of first local item signature in stream
  UInt64 FinishPos;  // Finish pos of archive data in starting volume
  UInt64 FileEndPos; // Finish pos of stream

  UInt64 FirstItemRelatOffset; /* Relative offset of first local (read from cd) (relative to Base).
                                  = 0 in most archives
                                  = size of stub for some SFXs */
  bool CdWasRead;
  bool IsSpanMode;
  bool ThereIsTail;

  // UInt32 BaseVolIndex;

  CByteBuffer Comment;


  CInArchiveInfo():
      Base(0),
      MarkerPos(0),
      MarkerPos2(0),
      FinishPos(0),
      FileEndPos(0),
      FirstItemRelatOffset(0),
      CdWasRead(false),
      IsSpanMode(false),
      ThereIsTail(false)
      // BaseVolIndex(0)
      {}
  
  void Clear()
  {
    // BaseVolIndex = 0;
    Base = 0;
    MarkerPos = 0;
    MarkerPos2 = 0;
    FinishPos = 0;
    FileEndPos = 0;
    ThereIsTail = false;

    FirstItemRelatOffset = 0;

    CdWasRead = false;
    IsSpanMode = false;

    Comment.Free();
  }
};


struct CCdInfo
{
  // 64
  UInt16 VersionMade;
  UInt16 VersionNeedExtract;

  // old zip
  UInt32 ThisDisk;
  UInt32 CdDisk;
  UInt64 NumEntries_in_ThisDisk;
  UInt64 NumEntries;
  UInt64 Size;
  UInt64 Offset;

  UInt16 CommentSize;

  CCdInfo() { memset(this, 0, sizeof(*this)); }

  void ParseEcd32(const Byte *p);   // (p) includes signature
  void ParseEcd64e(const Byte *p);  // (p) exclude signature
};


class CVols
{
public:

  struct CSubStreamInfo
  {
    CMyComPtr<IInStream> Stream;
    UInt64 Size;

    CSubStreamInfo(): Size(0) {}
  };
  
  CObjectVector<CSubStreamInfo> Streams;
  int StreamIndex;
  bool NeedSeek;

  CMyComPtr<IInStream> ZipStream;

  bool StartIsExe;  // is .exe
  bool StartIsZ;    // is .zip or .zNN
  bool StartIsZip;  // is .zip
  bool IsUpperCase;
  Int32 StartVolIndex; // = (NN - 1), if StartStream is .zNN

  Int32 StartParsingVol; // if we need local parsing, we must use that stream
  unsigned NumVols;

  int EndVolIndex; // index of last volume (ecd volume),
                   // -1, if is not multivol

  UString BaseName; // including '.'

  UString MissingName;

  CCdInfo ecd;
  bool ecd_wasRead;

  void Clear()
  {
    StreamIndex = -1;
    NeedSeek = false;


    StartIsExe = false;
    StartIsZ = false;
    StartIsZip = false;
    IsUpperCase = false;

    StartVolIndex = -1;
    StartParsingVol = 0;
    NumVols = 0;
    EndVolIndex = -1;

    BaseName.Empty();
    MissingName.Empty();

    ecd_wasRead = false;

    Streams.Clear();
    ZipStream.Release();
  }

  HRESULT ParseArcName(IArchiveOpenVolumeCallback *volCallback);

  HRESULT Read(void *data, UInt32 size, UInt32 *processedSize);
  
  UInt64 GetTotalSize() const
  {
    UInt64 total = 0;
    FOR_VECTOR (i, Streams)
      total += Streams[i].Size;
    return total;
  }
};


class CVolStream:
  public ISequentialInStream,
  public CMyUnknownImp
{
public:
  CVols *Vols;
  
  MY_UNKNOWN_IMP1(ISequentialInStream)

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
};


class CInArchive
{
  CInBuffer _inBuffer;
  bool _inBufMode;
  UInt32 m_Signature;
  UInt64 m_Position;

  UInt64 _processedCnt;
  
  bool CanStartNewVol;

  CMyComPtr<IInStream> StreamRef;
  IInStream *Stream;
  IInStream *StartStream;

  bool IsArcOpen;

  HRESULT ReadVols2(IArchiveOpenVolumeCallback *volCallback,
      unsigned start, int lastDisk, int zipDisk, unsigned numMissingVolsMax, unsigned &numMissingVols);
  HRESULT ReadVols();

  HRESULT Seek(UInt64 offset);
  HRESULT FindMarker(IInStream *stream, const UInt64 *searchLimit);
  HRESULT IncreaseRealPosition(Int64 addValue, bool &isFinished);

  HRESULT ReadBytes(void *data, UInt32 size, UInt32 *processedSize);
  void SafeReadBytes(void *data, unsigned size);
  void ReadBuffer(CByteBuffer &buffer, unsigned size);
  Byte ReadByte();
  UInt16 ReadUInt16();
  UInt32 ReadUInt32();
  UInt64 ReadUInt64();
  void Skip(unsigned num);
  void Skip64(UInt64 num);
  void ReadFileName(unsigned nameSize, AString &dest);

  bool ReadExtra(unsigned extraSize, CExtraBlock &extraBlock,
      UInt64 &unpackSize, UInt64 &packSize, UInt64 &localHeaderOffset, UInt32 &diskStartNumber);
  bool ReadLocalItem(CItemEx &item);
  HRESULT ReadLocalItemDescriptor(CItemEx &item);
  HRESULT ReadCdItem(CItemEx &item);
  HRESULT TryEcd64(UInt64 offset, CCdInfo &cdInfo);
  HRESULT FindCd(bool checkOffsetMode);
  HRESULT TryReadCd(CObjectVector<CItemEx> &items, const CCdInfo &cdInfo, UInt64 cdOffset, UInt64 cdSize);
  HRESULT ReadCd(CObjectVector<CItemEx> &items, UInt32 &cdDisk, UInt64 &cdOffset, UInt64 &cdSize);
  HRESULT ReadLocals(CObjectVector<CItemEx> &localItems);

  HRESULT ReadHeaders2(CObjectVector<CItemEx> &items);

  HRESULT GetVolStream(unsigned vol, UInt64 pos, CMyComPtr<ISequentialInStream> &stream);
public:
  CInArchiveInfo ArcInfo;
  
  bool IsArc;
  bool IsZip64;
  bool HeadersError;
  bool HeadersWarning;
  bool ExtraMinorError;
  bool UnexpectedEnd;
  bool NoCentralDir;

  bool MarkerIsFound;

  bool IsMultiVol;
  bool UseDisk_in_SingleVol;
  UInt32 EcdVolIndex;

  CVols Vols;
 
  IArchiveOpenCallback *Callback;

  CInArchive(): Stream(NULL), Callback(NULL), IsArcOpen(false) {}

  UInt64 GetPhySize() const
  {
    if (IsMultiVol)
      return ArcInfo.FinishPos;
    else
      return ArcInfo.FinishPos - ArcInfo.Base;
  }

  UInt64 GetOffset() const
  {
    if (IsMultiVol)
      return 0;
    else
      return ArcInfo.Base;
  }

  
  void ClearRefs();
  void Close();
  HRESULT Open(IInStream *stream, const UInt64 *searchLimit, IArchiveOpenCallback *callback, CObjectVector<CItemEx> &items);
  HRESULT ReadHeaders(CObjectVector<CItemEx> &items);

  bool IsOpen() const { return IsArcOpen; }
  
  bool AreThereErrors() const
  {
    return HeadersError
        || UnexpectedEnd
        || !Vols.MissingName.IsEmpty();
  }

  bool IsLocalOffsetOK(const CItemEx &item) const
  {
    if (item.FromLocal)
      return true;
    return (Int64)GetOffset() + (Int64)item.LocalHeaderPos >= 0;
  }

  UInt64 GetEmbeddedStubSize() const
  {
    if (ArcInfo.CdWasRead)
      return ArcInfo.FirstItemRelatOffset;
    if (IsMultiVol)
      return 0;
    return ArcInfo.MarkerPos2 - ArcInfo.Base;
  }


  HRESULT ReadLocalItemAfterCdItem(CItemEx &item, bool &isAvail);
  HRESULT ReadLocalItemAfterCdItemFull(CItemEx &item);

  HRESULT GetItemStream(const CItemEx &item, bool seekPackData, CMyComPtr<ISequentialInStream> &stream);

  IInStream *GetBaseStream() { return StreamRef; }

  bool CanUpdate() const
  {
    if (AreThereErrors()
       || IsMultiVol
       || ArcInfo.Base < 0
       || (Int64)ArcInfo.MarkerPos2 < ArcInfo.Base
       || ArcInfo.ThereIsTail
       || GetEmbeddedStubSize() != 0)
      return false;
   
    // 7-zip probably can update archives with embedded stubs.
    // we just disable that feature for more safety.

    return true;
  }
};
  
}}
  
#endif
// Archive/ZipItem.cpp

#include "StdAfx.h"

#include "../../../../C/CpuArch.h"
#include "../../../../C/7zCrc.h"

#include "../../../Common/MyLinux.h"
#include "../../../Common/StringConvert.h"

#include "../Common/ItemNameUtils.h"

#include "ZipItem.h"

namespace NArchive {
namespace NZip {

using namespace NFileHeader;

bool CExtraSubBlock::ExtractNtfsTime(unsigned index, FILETIME &ft) const
{
  ft.dwHighDateTime = ft.dwLowDateTime = 0;
  UInt32 size = (UInt32)Data.Size();
  if (ID != NExtraID::kNTFS || size < 32)
    return false;
  const Byte *p = (const Byte *)Data;
  p += 4; // for reserved
  size -= 4;
  while (size > 4)
  {
    UInt16 tag = GetUi16(p);
    unsigned attrSize = GetUi16(p + 2);
    p += 4;
    size -= 4;
    if (attrSize > size)
      attrSize = size;
    
    if (tag == NNtfsExtra::kTagTime && attrSize >= 24)
    {
      p += 8 * index;
      ft.dwLowDateTime = GetUi32(p);
      ft.dwHighDateTime = GetUi32(p + 4);
      return true;
    }
    p += attrSize;
    size -= attrSize;
  }
  return false;
}

bool CExtraSubBlock::ExtractUnixTime(bool isCentral, unsigned index, UInt32 &res) const
{
  res = 0;
  UInt32 size = (UInt32)Data.Size();
  if (ID != NExtraID::kUnixTime || size < 5)
    return false;
  const Byte *p = (const Byte *)Data;
  Byte flags = *p++;
  size--;
  if (isCentral)
  {
    if (index != NUnixTime::kMTime ||
        (flags & (1 << NUnixTime::kMTime)) == 0 ||
        size < 4)
      return false;
    res = GetUi32(p);
    return true;
  }
  for (unsigned i = 0; i < 3; i++)
    if ((flags & (1 << i)) != 0)
    {
      if (size < 4)
        return false;
      if (index == i)
      {
        res = GetUi32(p);
        return true;
      }
      p += 4;
      size -= 4;
    }
  return false;
}


bool CExtraBlock::GetNtfsTime(unsigned index, FILETIME &ft) const
{
  FOR_VECTOR (i, SubBlocks)
  {
    const CExtraSubBlock &sb = SubBlocks[i];
    if (sb.ID == NFileHeader::NExtraID::kNTFS)
      return sb.ExtractNtfsTime(index, ft);
  }
  return false;
}

bool CExtraBlock::GetUnixTime(bool isCentral, unsigned index, UInt32 &res) const
{
  FOR_VECTOR (i, SubBlocks)
  {
    const CExtraSubBlock &sb = SubBlocks[i];
    if (sb.ID == NFileHeader::NExtraID::kUnixTime)
      return sb.ExtractUnixTime(isCentral, index, res);
  }
  return false;
}


bool CLocalItem::IsDir() const
{
  return NItemName::HasTailSlash(Name, GetCodePage());
}

bool CItem::IsDir() const
{
  if (NItemName::HasTailSlash(Name, GetCodePage()))
    return true;
  
  Byte hostOS = GetHostOS();

  if (Size == 0 && PackSize == 0 && !Name.IsEmpty() && Name.Back() == '\\')
  {
    // do we need to use CharPrevExA?
    // .NET Framework 4.5 : System.IO.Compression::CreateFromDirectory() probably writes backslashes to headers?
    // so we support that case
    switch (hostOS)
    {
      case NHostOS::kFAT:
      case NHostOS::kNTFS:
      case NHostOS::kHPFS:
      case NHostOS::kVFAT:
        return true;
    }
  }

  if (!FromCentral)
    return false;
  
  UInt16 highAttrib = (UInt16)((ExternalAttrib >> 16 ) & 0xFFFF);

  switch (hostOS)
  {
    case NHostOS::kAMIGA:
      switch (highAttrib & NAmigaAttrib::kIFMT)
      {
        case NAmigaAttrib::kIFDIR: return true;
        case NAmigaAttrib::kIFREG: return false;
        default: return false; // change it throw kUnknownAttributes;
      }
    case NHostOS::kFAT:
    case NHostOS::kNTFS:
    case NHostOS::kHPFS:
    case NHostOS::kVFAT:
      return ((ExternalAttrib & FILE_ATTRIBUTE_DIRECTORY) != 0);
    case NHostOS::kAtari:
    case NHostOS::kMac:
    case NHostOS::kVMS:
    case NHostOS::kVM_CMS:
    case NHostOS::kAcorn:
    case NHostOS::kMVS:
      return false; // change it throw kUnknownAttributes;
    case NHostOS::kUnix:
      return MY_LIN_S_ISDIR(highAttrib);
    default:
      return false;
  }
}

UInt32 CItem::GetWinAttrib() const
{
  UInt32 winAttrib = 0;
  switch (GetHostOS())
  {
    case NHostOS::kFAT:
    case NHostOS::kNTFS:
      if (FromCentral)
        winAttrib = ExternalAttrib;
      break;
#ifdef FILE_ATTRIBUTE_UNIX_EXTENSION
    case NFileHeader::NHostOS::kUnix:
        winAttrib = (ExternalAttrib & 0xFFFF0000) | FILE_ATTRIBUTE_UNIX_EXTENSION; 
        if (winAttrib & (MY_LIN_S_IFDIR << 16))
		winAttrib |= FILE_ATTRIBUTE_DIRECTORY;
        return winAttrib;
#endif
  }
  if (IsDir()) // test it;
    winAttrib |= FILE_ATTRIBUTE_DIRECTORY;
  return winAttrib;
}

bool CItem::GetPosixAttrib(UInt32 &attrib) const
{
  // some archivers can store PosixAttrib in high 16 bits even with HostOS=FAT.
  if (FromCentral && GetHostOS() == NHostOS::kUnix)
  {
    attrib = ExternalAttrib >> 16;
    return (attrib != 0);
  }
  attrib = 0;
  if (IsDir())
    attrib = MY_LIN_S_IFDIR;
  return false;
}

void CItem::GetUnicodeString(UString &res, const AString &s, bool isComment, bool useSpecifiedCodePage, UINT codePage) const
{
  bool isUtf8 = IsUtf8();
  bool ignore_Utf8_Errors = true;
  
  if (!isUtf8)
  {
    {
      const unsigned id = isComment ?
          NFileHeader::NExtraID::kIzUnicodeComment:
          NFileHeader::NExtraID::kIzUnicodeName;
      const CObjectVector<CExtraSubBlock> &subBlocks = GetMainExtra().SubBlocks;
      
      FOR_VECTOR (i, subBlocks)
      {
        const CExtraSubBlock &sb = subBlocks[i];
        if (sb.ID == id)
        {
          AString utf;
          if (sb.ExtractIzUnicode(CrcCalc(s, s.Len()), utf))
            if (ConvertUTF8ToUnicode(utf, res))
              return;
          break;
        }
      }
    }
    
    if (useSpecifiedCodePage)
      isUtf8 = (codePage == CP_UTF8);
    #ifdef _WIN32
    else if (GetHostOS() == NFileHeader::NHostOS::kUnix)
    {
      /* Some ZIP archives in Unix use UTF-8 encoding without Utf8 flag in header.
         We try to get name as UTF-8.
         Do we need to do it in POSIX version also? */
      isUtf8 = true;
      ignore_Utf8_Errors = false;
    }
    #endif
  }
  
  
  if (isUtf8)
    if (ConvertUTF8ToUnicode(s, res) || ignore_Utf8_Errors)
      return;
  
  MultiByteToUnicodeString2(res, s, useSpecifiedCodePage ? codePage : GetCodePage());
}

}}
// Archive/ZipItem.h

#ifndef __ARCHIVE_ZIP_ITEM_H
#define __ARCHIVE_ZIP_ITEM_H

#include "../../../../C/CpuArch.h"

#include "../../../Common/MyBuffer.h"
#include "../../../Common/MyString.h"
#include "../../../Common/UTFConvert.h"

#include "ZipHeader.h"

namespace NArchive {
namespace NZip {

struct CVersion
{
  Byte Version;
  Byte HostOS;
};

struct CExtraSubBlock
{
  UInt16 ID;
  CByteBuffer Data;

  bool ExtractNtfsTime(unsigned index, FILETIME &ft) const;
  bool ExtractUnixTime(bool isCentral, unsigned index, UInt32 &res) const;
  
  bool ExtractIzUnicode(UInt32 crc, AString &name) const
  {
    unsigned size = (unsigned)Data.Size();
    if (size < 1 + 4)
      return false;
    const Byte *p = (const Byte *)Data;
    if (p[0] > 1)
      return false;
    if (crc != GetUi32(p + 1))
      return false;
    size -= 5;
    name.SetFrom_CalcLen((const char *)p + 5, size);
    if (size != name.Len())
      return false;
    return CheckUTF8(name, false);
  }
};

const unsigned k_WzAesExtra_Size = 7;

struct CWzAesExtra
{
  UInt16 VendorVersion; // 1: AE-1, 2: AE-2,
  // UInt16 VendorId; // 'A' 'E'
  Byte Strength; // 1: 128-bit, 2: 192-bit, 3: 256-bit
  UInt16 Method;

  CWzAesExtra(): VendorVersion(2), Strength(3), Method(0) {}

  bool NeedCrc() const { return (VendorVersion == 1); }

  bool ParseFromSubBlock(const CExtraSubBlock &sb)
  {
    if (sb.ID != NFileHeader::NExtraID::kWzAES)
      return false;
    if (sb.Data.Size() < k_WzAesExtra_Size)
      return false;
    const Byte *p = (const Byte *)sb.Data;
    VendorVersion = GetUi16(p);
    if (p[2] != 'A' || p[3] != 'E')
      return false;
    Strength = p[4];
    // 9.31: The BUG was fixed:
    Method = GetUi16(p + 5);
    return true;
  }
  
  void SetSubBlock(CExtraSubBlock &sb) const
  {
    sb.Data.Alloc(k_WzAesExtra_Size);
    sb.ID = NFileHeader::NExtraID::kWzAES;
    Byte *p = (Byte *)sb.Data;
    p[0] = (Byte)VendorVersion;
    p[1] = (Byte)(VendorVersion >> 8);
    p[2] = 'A';
    p[3] = 'E';
    p[4] = Strength;
    p[5] = (Byte)Method;
    p[6] = (Byte)(Method >> 8);
  }
};

namespace NStrongCrypto_AlgId
{
  const UInt16 kDES = 0x6601;
  const UInt16 kRC2old = 0x6602;
  const UInt16 k3DES168 = 0x6603;
  const UInt16 k3DES112 = 0x6609;
  const UInt16 kAES128 = 0x660E;
  const UInt16 kAES192 = 0x660F;
  const UInt16 kAES256 = 0x6610;
  const UInt16 kRC2 = 0x6702;
  const UInt16 kBlowfish = 0x6720;
  const UInt16 kTwofish = 0x6721;
  const UInt16 kRC4 = 0x6801;
}

struct CStrongCryptoExtra
{
  UInt16 Format;
  UInt16 AlgId;
  UInt16 BitLen;
  UInt16 Flags;

  bool ParseFromSubBlock(const CExtraSubBlock &sb)
  {
    if (sb.ID != NFileHeader::NExtraID::kStrongEncrypt)
      return false;
    const Byte *p = (const Byte *)sb.Data;
    if (sb.Data.Size() < 8)
      return false;
    Format = GetUi16(p + 0);
    AlgId  = GetUi16(p + 2);
    BitLen = GetUi16(p + 4);
    Flags  = GetUi16(p + 6);
    return (Format == 2);
  }

  bool CertificateIsUsed() const { return (Flags > 0x0001); }
};

struct CExtraBlock
{
  CObjectVector<CExtraSubBlock> SubBlocks;
  
  void Clear() { SubBlocks.Clear(); }
  
  size_t GetSize() const
  {
    size_t res = 0;
    FOR_VECTOR (i, SubBlocks)
      res += SubBlocks[i].Data.Size() + 2 + 2;
    return res;
  }
  
  bool GetWzAes(CWzAesExtra &e) const
  {
    FOR_VECTOR (i, SubBlocks)
      if (e.ParseFromSubBlock(SubBlocks[i]))
        return true;
    return false;
  }

  bool HasWzAes() const
  {
    CWzAesExtra e;
    return GetWzAes(e);
  }

  bool GetStrongCrypto(CStrongCryptoExtra &e) const
  {
    FOR_VECTOR (i, SubBlocks)
      if (e.ParseFromSubBlock(SubBlocks[i]))
        return true;
    return false;
  }

  /*
  bool HasStrongCrypto() const
  {
    CStrongCryptoExtra e;
    return GetStrongCrypto(e);
  }
  */

  bool GetNtfsTime(unsigned index, FILETIME &ft) const;
  bool GetUnixTime(bool isCentral, unsigned index, UInt32 &res) const;

  void RemoveUnknownSubBlocks()
  {
    for (unsigned i = SubBlocks.Size(); i != 0;)
    {
      i--;
      if (SubBlocks[i].ID != NFileHeader::NExtraID::kWzAES)
        SubBlocks.Delete(i);
    }
  }
};


class CLocalItem
{
public:
  UInt16 Flags;
  UInt16 Method;
  CVersion ExtractVersion;

  UInt64 Size;
  UInt64 PackSize;
  UInt32 Time;
  UInt32 Crc;

  UInt32 Disk;
  
  AString Name;

  CExtraBlock LocalExtra;

  bool IsUtf8() const { return (Flags & NFileHeader::NFlags::kUtf8) != 0; }
  bool IsEncrypted() const { return (Flags & NFileHeader::NFlags::kEncrypted) != 0; }
  bool IsStrongEncrypted() const { return IsEncrypted() && (Flags & NFileHeader::NFlags::kStrongEncrypted) != 0; }
  bool IsAesEncrypted() const { return IsEncrypted() && (IsStrongEncrypted() || Method == NFileHeader::NCompressionMethod::kWzAES); }
  bool IsLzmaEOS() const { return (Flags & NFileHeader::NFlags::kLzmaEOS) != 0; }
  bool HasDescriptor() const { return (Flags & NFileHeader::NFlags::kDescriptorUsedMask) != 0; }
  
  bool IsDir() const;

  /*
  void GetUnicodeString(const AString &s, UString &res) const
  {
    bool isUtf8 = IsUtf8();
    if (isUtf8)
      if (ConvertUTF8ToUnicode(s, res))
        return;
    MultiByteToUnicodeString2(res, s, GetCodePage());
  }
  */

private:

  void SetFlag(unsigned bitMask, bool enable)
  {
    if (enable)
      Flags |= bitMask;
    else
      Flags &= ~bitMask;
  }

public:

  void ClearFlags() { Flags = 0; }
  void SetEncrypted(bool encrypted) { SetFlag(NFileHeader::NFlags::kEncrypted, encrypted); }
  void SetUtf8(bool isUtf8) { SetFlag(NFileHeader::NFlags::kUtf8, isUtf8); }
  void SetDescriptorMode(bool useDescriptor) { SetFlag(NFileHeader::NFlags::kDescriptorUsedMask, useDescriptor); }

  UINT GetCodePage() const { return CP_OEMCP; }
};


class CItem: public CLocalItem
{
public:
  CVersion MadeByVersion;
  UInt16 InternalAttrib;
  UInt32 ExternalAttrib;
  
  UInt64 LocalHeaderPos;
  
  CExtraBlock CentralExtra;
  CByteBuffer Comment;

  bool FromLocal;
  bool FromCentral;
  
  // CItem can be used as CLocalItem. So we must clear unused fields
  CItem():
      InternalAttrib(0),
      ExternalAttrib(0),
      FromLocal(false),
      FromCentral(false)
  {
    MadeByVersion.Version = 0;
    MadeByVersion.HostOS = 0;
  }

  const CExtraBlock &GetMainExtra() const { return *(FromCentral ? &CentralExtra : &LocalExtra); }

  bool IsDir() const;
  UInt32 GetWinAttrib() const;
  bool GetPosixAttrib(UInt32 &attrib) const;

  Byte GetHostOS() const { return FromCentral ? MadeByVersion.HostOS : ExtractVersion.HostOS; }

  void GetUnicodeString(UString &res, const AString &s, bool isComment, bool useSpecifiedCodePage, UINT codePage) const;

  bool IsThereCrc() const
  {
    if (Method == NFileHeader::NCompressionMethod::kWzAES)
    {
      CWzAesExtra aesField;
      if (GetMainExtra().GetWzAes(aesField))
        return aesField.NeedCrc();
    }
    return (Crc != 0 || !IsDir());
  }
  
  UINT GetCodePage() const
  {
    Byte hostOS = GetHostOS();
    return (UINT)((
           hostOS == NFileHeader::NHostOS::kFAT
        || hostOS == NFileHeader::NHostOS::kNTFS
        || hostOS == NFileHeader::NHostOS::kUnix // do we need it?
        ) ? CP_OEMCP : CP_ACP);
  }
};

}}

#endif
// ZipOut.cpp

#include "StdAfx.h"

#include "../../Common/OffsetStream.h"

#include "ZipOut.h"

namespace NArchive {
namespace NZip {

HRESULT COutArchive::Create(IOutStream *outStream)
{
  m_CurPos = 0;
  if (!m_OutBuffer.Create(1 << 16))
    return E_OUTOFMEMORY;
  m_Stream = outStream;
  m_OutBuffer.SetStream(outStream);
  m_OutBuffer.Init();

  return m_Stream->Seek(0, STREAM_SEEK_CUR, &m_Base);
}

void COutArchive::MoveCurPos(UInt64 distanceToMove)
{
  m_CurPos += distanceToMove; // test overflow
}

void COutArchive::SeekToRelatPos(UInt64 offset)
{
  HRESULT res = m_Stream->Seek(m_Base + offset, STREAM_SEEK_SET, NULL);
  if (res != S_OK)
    throw CSystemException(res);
}

void COutArchive::PrepareWriteCompressedDataZip64(unsigned fileNameLen, bool isZip64, bool aesEncryption)
{
  m_IsZip64 = isZip64;
  m_ExtraSize = isZip64 ? (4 + 8 + 8) : 0;
  if (aesEncryption)
    m_ExtraSize += 4 + k_WzAesExtra_Size;
  m_LocalFileHeaderSize = kLocalHeaderSize + fileNameLen + m_ExtraSize;
}

void COutArchive::PrepareWriteCompressedData(unsigned fileNameLen, UInt64 unPackSize, bool aesEncryption)
{
  // We use Zip64, if unPackSize size is larger than 0xF8000000 to support
  // cases when compressed size can be about 3% larger than uncompressed size

  PrepareWriteCompressedDataZip64(fileNameLen, unPackSize >= (UInt32)0xF8000000, aesEncryption);
}

#define DOES_NEED_ZIP64(v) (v >= (UInt32)0xFFFFFFFF)

void COutArchive::PrepareWriteCompressedData2(unsigned fileNameLen, UInt64 unPackSize, UInt64 packSize, bool aesEncryption)
{
  bool isZip64 =
      DOES_NEED_ZIP64(unPackSize) ||
      DOES_NEED_ZIP64(packSize);
  PrepareWriteCompressedDataZip64(fileNameLen, isZip64, aesEncryption);
}

void COutArchive::WriteBytes(const void *buffer, UInt32 size)
{
  m_OutBuffer.WriteBytes(buffer, size);
  m_CurPos += size;
}

void COutArchive::Write8(Byte b)
{
  m_OutBuffer.WriteByte(b);
  m_CurPos++;
}

void COutArchive::Write16(UInt16 val)
{
  for (int i = 0; i < 2; i++)
  {
    Write8((Byte)val);
    val >>= 8;
  }
}

void COutArchive::Write32(UInt32 val)
{
  for (int i = 0; i < 4; i++)
  {
    Write8((Byte)val);
    val >>= 8;
  }
}

void COutArchive::Write64(UInt64 val)
{
  for (int i = 0; i < 8; i++)
  {
    Write8((Byte)val);
    val >>= 8;
  }
}

void COutArchive::WriteExtra(const CExtraBlock &extra)
{
  if (extra.SubBlocks.Size() != 0)
  {
    FOR_VECTOR (i, extra.SubBlocks)
    {
      const CExtraSubBlock &subBlock = extra.SubBlocks[i];
      Write16(subBlock.ID);
      Write16((UInt16)subBlock.Data.Size());
      WriteBytes(subBlock.Data, (UInt32)subBlock.Data.Size());
    }
  }
}

void COutArchive::WriteCommonItemInfo(const CLocalItem &item, bool isZip64)
{
  {
    Byte ver = item.ExtractVersion.Version;
    if (isZip64 && ver < NFileHeader::NCompressionMethod::kExtractVersion_Zip64)
      ver = NFileHeader::NCompressionMethod::kExtractVersion_Zip64;
    Write8(ver);
  }
  Write8(item.ExtractVersion.HostOS);
  Write16(item.Flags);
  Write16(item.Method);
  Write32(item.Time);
  Write32(item.Crc);
}

#define WRITE_32_VAL_SPEC(__v, __isZip64) Write32((__isZip64) ? 0xFFFFFFFF : (UInt32)(__v));

void COutArchive::WriteLocalHeader(const CLocalItem &item)
{
  SeekToCurPos();
  
  bool isZip64 = m_IsZip64 ||
      DOES_NEED_ZIP64(item.PackSize) ||
      DOES_NEED_ZIP64(item.Size);
  
  Write32(NSignature::kLocalFileHeader);
  WriteCommonItemInfo(item, isZip64);

  WRITE_32_VAL_SPEC(item.PackSize, isZip64);
  WRITE_32_VAL_SPEC(item.Size, isZip64);

  Write16((UInt16)item.Name.Len());
  {
    UInt16 localExtraSize = (UInt16)((isZip64 ? (4 + 8 + 8): 0) + item.LocalExtra.GetSize());
    if (localExtraSize != m_ExtraSize)
      throw CSystemException(E_FAIL);
  }
  Write16((UInt16)m_ExtraSize);
  WriteBytes((const char *)item.Name, item.Name.Len());

  if (isZip64)
  {
    Write16(NFileHeader::NExtraID::kZip64);
    Write16(8 + 8);
    Write64(item.Size);
    Write64(item.PackSize);
  }

  WriteExtra(item.LocalExtra);

  // Why don't we write NTFS timestamps to local header?
  // Probably we want to reduce size of archive?

  m_OutBuffer.FlushWithCheck();
  MoveCurPos(item.PackSize);
}

void COutArchive::WriteCentralHeader(const CItemOut &item)
{
  bool isUnPack64 = DOES_NEED_ZIP64(item.Size);
  bool isPack64 = DOES_NEED_ZIP64(item.PackSize);
  bool isPosition64 = DOES_NEED_ZIP64(item.LocalHeaderPos);
  bool isZip64 = isPack64 || isUnPack64 || isPosition64;
  
  Write32(NSignature::kCentralFileHeader);
  Write8(item.MadeByVersion.Version);
  Write8(item.MadeByVersion.HostOS);
  
  WriteCommonItemInfo(item, isZip64);

  WRITE_32_VAL_SPEC(item.PackSize, isPack64);
  WRITE_32_VAL_SPEC(item.Size, isUnPack64);

  Write16((UInt16)item.Name.Len());
  
  UInt16 zip64ExtraSize = (UInt16)((isUnPack64 ? 8: 0) + (isPack64 ? 8: 0) + (isPosition64 ? 8: 0));
  const UInt16 kNtfsExtraSize = 4 + 2 + 2 + (3 * 8);
  const UInt16 centralExtraSize = (UInt16)(
      (isZip64 ? 4 + zip64ExtraSize : 0) +
      (item.NtfsTimeIsDefined ? 4 + kNtfsExtraSize : 0) +
      item.CentralExtra.GetSize());

  Write16(centralExtraSize); // test it;
  Write16((UInt16)item.Comment.Size());
  Write16(0); // DiskNumberStart;
  Write16(item.InternalAttrib);
  Write32(item.ExternalAttrib);
  WRITE_32_VAL_SPEC(item.LocalHeaderPos, isPosition64);
  WriteBytes((const char *)item.Name, item.Name.Len());
  
  if (isZip64)
  {
    Write16(NFileHeader::NExtraID::kZip64);
    Write16(zip64ExtraSize);
    if (isUnPack64)
      Write64(item.Size);
    if (isPack64)
      Write64(item.PackSize);
    if (isPosition64)
      Write64(item.LocalHeaderPos);
  }
  
  if (item.NtfsTimeIsDefined)
  {
    Write16(NFileHeader::NExtraID::kNTFS);
    Write16(kNtfsExtraSize);
    Write32(0); // reserved
    Write16(NFileHeader::NNtfsExtra::kTagTime);
    Write16(8 * 3);
    WriteNtfsTime(item.Ntfs_MTime);
    WriteNtfsTime(item.Ntfs_ATime);
    WriteNtfsTime(item.Ntfs_CTime);
  }
  
  WriteExtra(item.CentralExtra);
  if (item.Comment.Size() > 0)
    WriteBytes(item.Comment, (UInt32)item.Comment.Size());
}

void COutArchive::WriteCentralDir(const CObjectVector<CItemOut> &items, const CByteBuffer *comment)
{
  SeekToCurPos();
  
  UInt64 cdOffset = GetCurPos();
  FOR_VECTOR (i, items)
    WriteCentralHeader(items[i]);
  UInt64 cd64EndOffset = GetCurPos();
  UInt64 cdSize = cd64EndOffset - cdOffset;
  bool cdOffset64 = DOES_NEED_ZIP64(cdOffset);
  bool cdSize64 = DOES_NEED_ZIP64(cdSize);
  bool items64 = items.Size() >= 0xFFFF;
  bool isZip64 = (cdOffset64 || cdSize64 || items64);
  
  // isZip64 = true; // to test Zip64

  if (isZip64)
  {
    Write32(NSignature::kEcd64);
    Write64(kEcd64_MainSize);
    Write16(45); // made by version
    Write16(45); // extract version
    Write32(0); // ThisDiskNumber = 0;
    Write32(0); // StartCentralDirectoryDiskNumber;;
    Write64((UInt64)items.Size());
    Write64((UInt64)items.Size());
    Write64((UInt64)cdSize);
    Write64((UInt64)cdOffset);

    Write32(NSignature::kEcd64Locator);
    Write32(0); // number of the disk with the start of the zip64 end of central directory
    Write64(cd64EndOffset);
    Write32(1); // total number of disks
  }
  
  Write32(NSignature::kEcd);
  Write16(0); // ThisDiskNumber = 0;
  Write16(0); // StartCentralDirectoryDiskNumber;
  Write16((UInt16)(items64 ? 0xFFFF: items.Size()));
  Write16((UInt16)(items64 ? 0xFFFF: items.Size()));
  
  WRITE_32_VAL_SPEC(cdSize, cdSize64);
  WRITE_32_VAL_SPEC(cdOffset, cdOffset64);

  UInt32 commentSize = (UInt32)(comment ? comment->Size() : 0);
  Write16((UInt16)commentSize);
  if (commentSize > 0)
    WriteBytes((const Byte *)*comment, commentSize);
  m_OutBuffer.FlushWithCheck();
}

void COutArchive::CreateStreamForCompressing(IOutStream **outStream)
{
  COffsetOutStream *streamSpec = new COffsetOutStream;
  CMyComPtr<IOutStream> tempStream(streamSpec);
  streamSpec->Init(m_Stream, m_Base + m_CurPos + m_LocalFileHeaderSize);
  *outStream = tempStream.Detach();
}

/*
void COutArchive::SeekToPackedDataPosition()
{
  SeekTo(m_BasePosition + m_LocalFileHeaderSize);
}
*/

void COutArchive::SeekToCurPos()
{
  SeekToRelatPos(m_CurPos);
}

void COutArchive::CreateStreamForCopying(ISequentialOutStream **outStream)
{
  CMyComPtr<ISequentialOutStream> tempStream(m_Stream);
  *outStream = tempStream.Detach();
}

}}
// ZipOut.h

#ifndef __ZIP_OUT_H
#define __ZIP_OUT_H

#include "../../../Common/MyCom.h"

#include "../../IStream.h"
#include "../../Common/OutBuffer.h"

#include "ZipItem.h"

namespace NArchive {
namespace NZip {

// can throw CSystemException and COutBufferException

class CItemOut: public CItem
{
public:
  FILETIME Ntfs_MTime;
  FILETIME Ntfs_ATime;
  FILETIME Ntfs_CTime;
  bool NtfsTimeIsDefined;

  // It's possible that NtfsTime is not defined, but there is NtfsTime in Extra.

  CItemOut(): NtfsTimeIsDefined(false) {}
};

class COutArchive
{
  CMyComPtr<IOutStream> m_Stream;
  COutBuffer m_OutBuffer;

  UInt64 m_Base; // Base of arc (offset in output Stream)
  UInt64 m_CurPos; // Curent position in archive (relative from m_Base)

  UInt32 m_LocalFileHeaderSize;
  UInt32 m_ExtraSize;
  bool m_IsZip64;

  void SeekToRelatPos(UInt64 offset);

  void WriteBytes(const void *buffer, UInt32 size);
  void Write8(Byte b);
  void Write16(UInt16 val);
  void Write32(UInt32 val);
  void Write64(UInt64 val);
  void WriteNtfsTime(const FILETIME &ft)
  {
    Write32(ft.dwLowDateTime);
    Write32(ft.dwHighDateTime);
  }

  void WriteExtra(const CExtraBlock &extra);
  void WriteCommonItemInfo(const CLocalItem &item, bool isZip64);
  void WriteCentralHeader(const CItemOut &item);

  void PrepareWriteCompressedDataZip64(unsigned fileNameLen, bool isZip64, bool aesEncryption);

public:
  HRESULT Create(IOutStream *outStream);
  
  void MoveCurPos(UInt64 distanceToMove);
  UInt64 GetCurPos() const { return m_CurPos; }

  void SeekToCurPos();

  void PrepareWriteCompressedData(unsigned fileNameLen, UInt64 unPackSize, bool aesEncryption);
  void PrepareWriteCompressedData2(unsigned fileNameLen, UInt64 unPackSize, UInt64 packSize, bool aesEncryption);
  void WriteLocalHeader(const CLocalItem &item);

  void WriteLocalHeader_And_SeekToNextFile(const CLocalItem &item)
  {
    WriteLocalHeader(item);
    SeekToCurPos();
  }

  void WriteCentralDir(const CObjectVector<CItemOut> &items, const CByteBuffer *comment);

  void CreateStreamForCompressing(IOutStream **outStream);
  void CreateStreamForCopying(ISequentialOutStream **outStream);
};

}}

#endif
// ZipRegister.cpp

#include "StdAfx.h"

#include "../../Common/RegisterArc.h"

#include "ZipHandler.h"

namespace NArchive {
namespace NZip {

static const Byte k_Signature[] = {
    4, 0x50, 0x4B, 0x03, 0x04,
    4, 0x50, 0x4B, 0x05, 0x06,
    6, 0x50, 0x4B, 0x07, 0x08, 0x50, 0x4B,
    6, 0x50, 0x4B, 0x30, 0x30, 0x50, 0x4B };

REGISTER_ARC_IO(
  "zip", "zip z01 zipx jar xpi odt ods docx xlsx epub", 0, 1,
  k_Signature,
  0,
  NArcInfoFlags::kFindSignature |
  NArcInfoFlags::kMultiSignature |
  NArcInfoFlags::kUseGlobalOffset,
  IsArc_Zip)
 
}}
// ZipUpdate.cpp

#include "StdAfx.h"

#include "../../../../C/Alloc.h"

#include "../../../Common/AutoPtr.h"
#include "../../../Common/Defs.h"
#include "../../../Common/StringConvert.h"

#include "../../../Windows/TimeUtils.h"
#include "../../../Windows/Thread.h"

#include "../../Common/CreateCoder.h"
#include "../../Common/LimitedStreams.h"
#include "../../Common/OutMemStream.h"
#include "../../Common/ProgressUtils.h"
#ifndef _7ZIP_ST
#include "../../Common/ProgressMt.h"
#endif
#include "../../Common/StreamUtils.h"

#include "../../Compress/CopyCoder.h"

#include "ZipAddCommon.h"
#include "ZipOut.h"
#include "ZipUpdate.h"

using namespace NWindows;
using namespace NSynchronization;

namespace NArchive {
namespace NZip {

static const Byte kHostOS =
  #ifdef _WIN32
  NFileHeader::NHostOS::kFAT;
  #else
  NFileHeader::NHostOS::kUnix;
  #endif

static const Byte kMadeByHostOS = kHostOS;
static const Byte kExtractHostOS = kHostOS;

static const Byte kMethodForDirectory = NFileHeader::NCompressionMethod::kStored;

static HRESULT CopyBlockToArchive(ISequentialInStream *inStream, UInt64 size,
    COutArchive &outArchive, ICompressProgressInfo *progress)
{
  CMyComPtr<ISequentialOutStream> outStream;
  outArchive.CreateStreamForCopying(&outStream);
  return NCompress::CopyStream_ExactSize(inStream, outStream, size, progress);
}

static void SetFileHeader(
    COutArchive &archive,
    const CCompressionMethodMode &options,
    const CUpdateItem &ui,
    // bool isSeqMode,
    CItemOut &item)
{
  item.Size = ui.Size;
  bool isDir;

  item.ClearFlags();

  if (ui.NewProps)
  {
    isDir = ui.IsDir;
    item.Name = ui.Name;
    item.SetUtf8(ui.IsUtf8);
    item.ExternalAttrib = ui.Attrib;
    item.Time = ui.Time;
    item.Ntfs_MTime = ui.Ntfs_MTime;
    item.Ntfs_ATime = ui.Ntfs_ATime;
    item.Ntfs_CTime = ui.Ntfs_CTime;
    item.NtfsTimeIsDefined = ui.NtfsTimeIsDefined;
  }
  else
    isDir = item.IsDir();

  item.LocalHeaderPos = archive.GetCurPos();
  item.MadeByVersion.HostOS = kMadeByHostOS;
  item.MadeByVersion.Version = NFileHeader::NCompressionMethod::kMadeByProgramVersion;
  
  item.ExtractVersion.HostOS = kExtractHostOS;

  item.InternalAttrib = 0; // test it
  item.SetEncrypted(!isDir && options.PasswordIsDefined);
  // item.SetDescriptorMode(isSeqMode);

  if (isDir)
  {
    item.ExtractVersion.Version = NFileHeader::NCompressionMethod::kExtractVersion_Dir;
    item.Method = kMethodForDirectory;
    item.PackSize = 0;
    item.Size = 0;
    item.Crc = 0;
  }
}


static void SetItemInfoFromCompressingResult(const CCompressingResult &compressingResult,
    bool isAesMode, Byte aesKeyMode, CItem &item)
{
  item.ExtractVersion.Version = compressingResult.ExtractVersion;
  item.Method = compressingResult.Method;
  item.Crc = compressingResult.CRC;
  item.Size = compressingResult.UnpackSize;
  item.PackSize = compressingResult.PackSize;

  item.LocalExtra.Clear();
  item.CentralExtra.Clear();

  if (isAesMode)
  {
    CWzAesExtra wzAesField;
    wzAesField.Strength = aesKeyMode;
    wzAesField.Method = compressingResult.Method;
    item.Method = NFileHeader::NCompressionMethod::kWzAES;
    item.Crc = 0;
    CExtraSubBlock sb;
    wzAesField.SetSubBlock(sb);
    item.LocalExtra.SubBlocks.Add(sb);
    item.CentralExtra.SubBlocks.Add(sb);
  }
}


#ifndef _7ZIP_ST

static THREAD_FUNC_DECL CoderThread(void *threadCoderInfo);

struct CThreadInfo
{
  DECL_EXTERNAL_CODECS_LOC_VARS2;

  NWindows::CThread Thread;
  NWindows::NSynchronization::CAutoResetEvent CompressEvent;
  NWindows::NSynchronization::CAutoResetEventWFMO CompressionCompletedEvent;
  bool ExitThread;

  CMtCompressProgress *ProgressSpec;
  CMyComPtr<ICompressProgressInfo> Progress;

  COutMemStream *OutStreamSpec;
  CMyComPtr<IOutStream> OutStream;
  CMyComPtr<ISequentialInStream> InStream;

  CAddCommon Coder;
  HRESULT Result;
  CCompressingResult CompressingResult;

  bool IsFree;
  UInt32 UpdateIndex;
  UInt32 FileTime;

  CThreadInfo(const CCompressionMethodMode &options):
      ExitThread(false),
      ProgressSpec(0),
      OutStreamSpec(0),
      Coder(options),
      FileTime(0)
  {}
  
  HRESULT CreateEvents(CSynchro *sync)
  {
    RINOK(CompressEvent.CreateIfNotCreated());
    return CompressionCompletedEvent.CreateIfNotCreated(sync);
  }
  HRes CreateThread() { return Thread.Create(CoderThread, this); }

  void WaitAndCode();
  void StopWaitClose()
  {
    ExitThread = true;
    if (OutStreamSpec != 0)
      OutStreamSpec->StopWriting(E_ABORT);
    if (CompressEvent.IsCreated())
      CompressEvent.Set();
    Thread.Wait();
    Thread.Close();
  }
};

void CThreadInfo::WaitAndCode()
{
  for (;;)
  {
    CompressEvent.Lock();
    if (ExitThread)
      return;
    
    Result = Coder.Compress(
        EXTERNAL_CODECS_LOC_VARS
        InStream, OutStream, FileTime, Progress, CompressingResult);
    
    if (Result == S_OK && Progress)
      Result = Progress->SetRatioInfo(&CompressingResult.UnpackSize, &CompressingResult.PackSize);
    CompressionCompletedEvent.Set();
  }
}

static THREAD_FUNC_DECL CoderThread(void *threadCoderInfo)
{
  ((CThreadInfo *)threadCoderInfo)->WaitAndCode();
  return 0;
}

class CThreads
{
public:
  CObjectVector<CThreadInfo> Threads;
  ~CThreads()
  {
    FOR_VECTOR (i, Threads)
      Threads[i].StopWaitClose();
  }
};

struct CMemBlocks2: public CMemLockBlocks
{
  CCompressingResult CompressingResult;
  bool Defined;
  bool Skip;
  CMemBlocks2(): Defined(false), Skip(false) {}
};

class CMemRefs
{
public:
  CMemBlockManagerMt *Manager;
  CObjectVector<CMemBlocks2> Refs;
  CMemRefs(CMemBlockManagerMt *manager): Manager(manager) {} ;
  ~CMemRefs()
  {
    FOR_VECTOR (i, Refs)
      Refs[i].FreeOpt(Manager);
  }
};

class CMtProgressMixer2:
  public ICompressProgressInfo,
  public CMyUnknownImp
{
  UInt64 ProgressOffset;
  UInt64 InSizes[2];
  UInt64 OutSizes[2];
  CMyComPtr<IProgress> Progress;
  CMyComPtr<ICompressProgressInfo> RatioProgress;
  bool _inSizeIsMain;
public:
  NWindows::NSynchronization::CCriticalSection CriticalSection;
  MY_UNKNOWN_IMP
  void Create(IProgress *progress, bool inSizeIsMain);
  void SetProgressOffset(UInt64 progressOffset);
  HRESULT SetRatioInfo(unsigned index, const UInt64 *inSize, const UInt64 *outSize);
  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize);
};

void CMtProgressMixer2::Create(IProgress *progress, bool inSizeIsMain)
{
  Progress = progress;
  Progress.QueryInterface(IID_ICompressProgressInfo, &RatioProgress);
  _inSizeIsMain = inSizeIsMain;
  ProgressOffset = InSizes[0] = InSizes[1] = OutSizes[0] = OutSizes[1] = 0;
}

void CMtProgressMixer2::SetProgressOffset(UInt64 progressOffset)
{
  CriticalSection.Enter();
  InSizes[1] = OutSizes[1] = 0;
  ProgressOffset = progressOffset;
  CriticalSection.Leave();
}

HRESULT CMtProgressMixer2::SetRatioInfo(unsigned index, const UInt64 *inSize, const UInt64 *outSize)
{
  NWindows::NSynchronization::CCriticalSectionLock lock(CriticalSection);
  if (index == 0 && RatioProgress)
  {
    RINOK(RatioProgress->SetRatioInfo(inSize, outSize));
  }
  if (inSize)
    InSizes[index] = *inSize;
  if (outSize)
    OutSizes[index] = *outSize;
  UInt64 v = ProgressOffset + (_inSizeIsMain  ?
      (InSizes[0] + InSizes[1]) :
      (OutSizes[0] + OutSizes[1]));
  return Progress->SetCompleted(&v);
}

STDMETHODIMP CMtProgressMixer2::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)
{
  return SetRatioInfo(0, inSize, outSize);
}

class CMtProgressMixer:
  public ICompressProgressInfo,
  public CMyUnknownImp
{
public:
  CMtProgressMixer2 *Mixer2;
  CMyComPtr<ICompressProgressInfo> RatioProgress;
  void Create(IProgress *progress, bool inSizeIsMain);
  MY_UNKNOWN_IMP
  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize);
};

void CMtProgressMixer::Create(IProgress *progress, bool inSizeIsMain)
{
  Mixer2 = new CMtProgressMixer2;
  RatioProgress = Mixer2;
  Mixer2->Create(progress, inSizeIsMain);
}

STDMETHODIMP CMtProgressMixer::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)
{
  return Mixer2->SetRatioInfo(1, inSize, outSize);
}


#endif


static HRESULT UpdateItemOldData(
    COutArchive &archive,
    CInArchive *inArchive,
    const CItemEx &itemEx,
    const CUpdateItem &ui,
    CItemOut &item,
    /* bool izZip64, */
    ICompressProgressInfo *progress,
    IArchiveUpdateCallbackFile *opCallback,
    UInt64 &complexity)
{
  if (opCallback)
  {
    RINOK(opCallback->ReportOperation(
        NEventIndexType::kInArcIndex, (UInt32)ui.IndexInArc,
        NUpdateNotifyOp::kReplicate))
  }

  if (ui.NewProps)
  {
    if (item.HasDescriptor())
      return E_NOTIMPL;
    
    // use old name size.
    
    CMyComPtr<ISequentialInStream> packStream;
    RINOK(inArchive->GetItemStream(itemEx, true, packStream));
    if (!packStream)
      return E_NOTIMPL;

    // we keep ExternalAttrib and some another properties from old archive
    // item.ExternalAttrib = ui.Attrib;

    item.Name = ui.Name;
    item.SetUtf8(ui.IsUtf8);
    item.Time = ui.Time;
    item.Ntfs_MTime = ui.Ntfs_MTime;
    item.Ntfs_ATime = ui.Ntfs_ATime;
    item.Ntfs_CTime = ui.Ntfs_CTime;
    item.NtfsTimeIsDefined = ui.NtfsTimeIsDefined;

    item.CentralExtra.RemoveUnknownSubBlocks();
    item.LocalExtra.RemoveUnknownSubBlocks();
    item.LocalHeaderPos = archive.GetCurPos();

    archive.PrepareWriteCompressedData2(item.Name.Len(), item.Size, item.PackSize, item.LocalExtra.HasWzAes());
    archive.WriteLocalHeader(item);

    RINOK(CopyBlockToArchive(packStream, itemEx.PackSize, archive, progress));

    complexity += itemEx.PackSize;
  }
  else
  {
    CMyComPtr<ISequentialInStream> packStream;
    RINOK(inArchive->GetItemStream(itemEx, false, packStream));
    if (!packStream)
      return E_NOTIMPL;
    
    // set new header position
    item.LocalHeaderPos = archive.GetCurPos();
    
    const UInt64 rangeSize = itemEx.GetLocalFullSize();
    
    RINOK(CopyBlockToArchive(packStream, rangeSize, archive, progress));

    complexity += rangeSize;
    archive.MoveCurPos(rangeSize);
  }

  return S_OK;
}


static void WriteDirHeader(COutArchive &archive, const CCompressionMethodMode *options,
    const CUpdateItem &ui, CItemOut &item)
{
  SetFileHeader(archive, *options, ui, item);
  archive.PrepareWriteCompressedData(item.Name.Len(), ui.Size,
      // options->IsRealAesMode()
      false // fixed 9.31
      );
  archive.WriteLocalHeader_And_SeekToNextFile(item);
}


static inline bool IsZero_FILETIME(const FILETIME &ft)
{
  return (ft.dwHighDateTime == 0 && ft.dwLowDateTime == 0);
}

static void UpdatePropsFromStream(CUpdateItem &item, ISequentialInStream *fileInStream,
    IArchiveUpdateCallback *updateCallback, UInt64 &totalComplexity)
{
  CMyComPtr<IStreamGetProps> getProps;
  fileInStream->QueryInterface(IID_IStreamGetProps, (void **)&getProps);
  if (!getProps)
    return;

  FILETIME cTime, aTime, mTime;
  UInt64 size;
  // UInt32 attrib;
  if (getProps->GetProps(&size, &cTime, &aTime, &mTime, NULL) != S_OK)
    return;
  
  if (size != item.Size && size != (UInt64)(Int64)-1)
  {
    Int64 newComplexity = totalComplexity + ((Int64)size - (Int64)item.Size);
    if (newComplexity > 0)
    {
      totalComplexity = newComplexity;
      updateCallback->SetTotal(totalComplexity);
    }
    item.Size = size;
  }
  
  if (!IsZero_FILETIME(mTime))
  {
    item.Ntfs_MTime = mTime;
    FILETIME loc = { 0, 0 };
    if (FileTimeToLocalFileTime(&mTime, &loc))
    {
      item.Time = 0;
      NTime::FileTimeToDosTime(loc, item.Time);
    }
  }

  if (!IsZero_FILETIME(cTime)) item.Ntfs_CTime = cTime;
  if (!IsZero_FILETIME(aTime)) item.Ntfs_ATime = aTime;

  // item.Attrib = attrib;
}


static HRESULT Update2St(
    DECL_EXTERNAL_CODECS_LOC_VARS
    COutArchive &archive,
    CInArchive *inArchive,
    const CObjectVector<CItemEx> &inputItems,
    CObjectVector<CUpdateItem> &updateItems,
    const CCompressionMethodMode *options,
    const CByteBuffer *comment,
    IArchiveUpdateCallback *updateCallback,
    UInt64 &totalComplexity,
    IArchiveUpdateCallbackFile *opCallback)
{
  CLocalProgress *lps = new CLocalProgress;
  CMyComPtr<ICompressProgressInfo> progress = lps;
  lps->Init(updateCallback, true);

  CAddCommon compressor(*options);
  
  CObjectVector<CItemOut> items;
  UInt64 unpackSizeTotal = 0, packSizeTotal = 0;

  FOR_VECTOR (itemIndex, updateItems)
  {
    lps->InSize = unpackSizeTotal;
    lps->OutSize = packSizeTotal;
    RINOK(lps->SetCur());
    CUpdateItem &ui = updateItems[itemIndex];
    CItemEx itemEx;
    CItemOut item;

    if (!ui.NewProps || !ui.NewData)
    {
      itemEx = inputItems[ui.IndexInArc];
      if (inArchive->ReadLocalItemAfterCdItemFull(itemEx) != S_OK)
        return E_NOTIMPL;
      (CItem &)item = itemEx;
    }

    if (ui.NewData)
    {
      bool isDir = ((ui.NewProps) ? ui.IsDir : item.IsDir());
      if (isDir)
      {
        WriteDirHeader(archive, options, ui, item);
      }
      else
      {
        CMyComPtr<ISequentialInStream> fileInStream;
        HRESULT res = updateCallback->GetStream(ui.IndexInClient, &fileInStream);
        if (res == S_FALSE)
        {
          lps->ProgressOffset += ui.Size;
          RINOK(updateCallback->SetOperationResult(NArchive::NUpdate::NOperationResult::kOK));
          continue;
        }
        RINOK(res);
        if (!fileInStream)
          return E_INVALIDARG;

        // bool isSeqMode = false;
        /*
        {
          CMyComPtr<IInStream> inStream2;
          fileInStream->QueryInterface(IID_IInStream, (void **)&inStream2);
          isSeqMode = (inStream2 == NULL);
        }
        */

        UpdatePropsFromStream(ui, fileInStream, updateCallback, totalComplexity);
        SetFileHeader(archive, *options, ui, item);

        // file Size can be 64-bit !!!
        archive.PrepareWriteCompressedData(item.Name.Len(), ui.Size, options->IsRealAesMode());
        CCompressingResult compressingResult;
        CMyComPtr<IOutStream> outStream;
        archive.CreateStreamForCompressing(&outStream);
        
        RINOK(compressor.Compress(
            EXTERNAL_CODECS_LOC_VARS
            fileInStream, outStream,
            ui.Time,
            progress, compressingResult));
        
        if (compressingResult.FileTimeWasUsed)
        {
          /*
          if (!item.HasDescriptor())
            return E_FAIL;
          */
          item.SetDescriptorMode(true);
        }

        SetItemInfoFromCompressingResult(compressingResult, options->IsRealAesMode(), options->AesKeyMode, item);
        archive.WriteLocalHeader_And_SeekToNextFile(item);
        RINOK(updateCallback->SetOperationResult(NArchive::NUpdate::NOperationResult::kOK));
        unpackSizeTotal += item.Size;
        packSizeTotal += item.PackSize;
      }
    }
    else
    {
      UInt64 complexity = 0;
      lps->SendRatio = false;
      RINOK(UpdateItemOldData(archive, inArchive, itemEx, ui, item, progress, opCallback, complexity));
      lps->SendRatio = true;
      lps->ProgressOffset += complexity;
    }
  
    items.Add(item);
    lps->ProgressOffset += kLocalHeaderSize;
  }

  lps->InSize = unpackSizeTotal;
  lps->OutSize = packSizeTotal;
  RINOK(lps->SetCur());
  archive.WriteCentralDir(items, comment);
  return S_OK;
}


static HRESULT Update2(
    DECL_EXTERNAL_CODECS_LOC_VARS
    COutArchive &archive,
    CInArchive *inArchive,
    const CObjectVector<CItemEx> &inputItems,
    CObjectVector<CUpdateItem> &updateItems,
    const CCompressionMethodMode *options,
    const CByteBuffer *comment,
    IArchiveUpdateCallback *updateCallback)
{
  CMyComPtr<IArchiveUpdateCallbackFile> opCallback;
  updateCallback->QueryInterface(IID_IArchiveUpdateCallbackFile, (void **)&opCallback);

  UInt64 complexity = 0;
  UInt64 numFilesToCompress = 0;
  UInt64 numBytesToCompress = 0;
 
  unsigned i;
  
  for (i = 0; i < updateItems.Size(); i++)
  {
    const CUpdateItem &ui = updateItems[i];
    if (ui.NewData)
    {
      complexity += ui.Size;
      numBytesToCompress += ui.Size;
      numFilesToCompress++;
      /*
      if (ui.Commented)
        complexity += ui.CommentRange.Size;
      */
    }
    else
    {
      CItemEx inputItem = inputItems[ui.IndexInArc];
      if (inArchive->ReadLocalItemAfterCdItemFull(inputItem) != S_OK)
        return E_NOTIMPL;
      complexity += inputItem.GetLocalFullSize();
      // complexity += inputItem.GetCentralExtraPlusCommentSize();
    }
    complexity += kLocalHeaderSize;
    complexity += kCentralHeaderSize;
  }

  if (comment)
    complexity += comment->Size();
  complexity++; // end of central
  updateCallback->SetTotal(complexity);

  UInt64 totalComplexity = complexity;

  CAddCommon compressor(*options);
  
  complexity = 0;
  
  CCompressionMethodMode options2;
  if (options != 0)
    options2 = *options;

  #ifndef _7ZIP_ST

  UInt32 numThreads = options->NumThreads;
  const UInt32 kNumMaxThreads = 64;
  if (numThreads > kNumMaxThreads)
    numThreads = kNumMaxThreads;
  if (numThreads > MAXIMUM_WAIT_OBJECTS) // is 64 in Windows (is it 64 in all versions?)
    numThreads = MAXIMUM_WAIT_OBJECTS;
  if (numThreads < 1)
    numThreads = 1;

  
  const size_t kMemPerThread = (1 << 25);
  const size_t kBlockSize = 1 << 16;

  bool mtMode = ((options != 0) && (numThreads > 1));

  if (numFilesToCompress <= 1)
    mtMode = false;

  Byte method = options->MethodSequence.Front();

  if (!mtMode)
  {
    if (options2.MethodInfo.FindProp(NCoderPropID::kNumThreads) < 0)
    {
      // fixed for 9.31. bzip2 default is just one thread.
      if (options2.NumThreadsWasChanged || method == NFileHeader::NCompressionMethod::kBZip2)
        options2.MethodInfo.AddProp_NumThreads(numThreads);
    }
  }
  else
  {
    if (method == NFileHeader::NCompressionMethod::kStored && !options->PasswordIsDefined)
      numThreads = 1;
    if (method == NFileHeader::NCompressionMethod::kBZip2)
    {
      bool fixedNumber;
      UInt32 numBZip2Threads = options2.MethodInfo.Get_BZip2_NumThreads(fixedNumber);
      if (!fixedNumber)
      {
        UInt64 averageSize = numBytesToCompress / numFilesToCompress;
        UInt32 blockSize = options2.MethodInfo.Get_BZip2_BlockSize();
        UInt64 averageNumberOfBlocks = averageSize / blockSize + 1;
        numBZip2Threads = 32;
        if (averageNumberOfBlocks < numBZip2Threads)
          numBZip2Threads = (UInt32)averageNumberOfBlocks;
        options2.MethodInfo.AddProp_NumThreads(numBZip2Threads);
      }
      numThreads /= numBZip2Threads;
    }
    if (method == NFileHeader::NCompressionMethod::kLZMA)
    {
      bool fixedNumber;
      // we suppose that default LZMA is 2 thread. So we don't change it
      UInt32 numLZMAThreads = options2.MethodInfo.Get_Lzma_NumThreads(fixedNumber);
      numThreads /= numLZMAThreads;
    }
    if (numThreads > numFilesToCompress)
      numThreads = (UInt32)numFilesToCompress;
    if (numThreads <= 1)
      mtMode = false;
  }

  if (!mtMode)
  #endif
    return Update2St(
        EXTERNAL_CODECS_LOC_VARS
        archive, inArchive,
        inputItems, updateItems, &options2, comment, updateCallback, totalComplexity, opCallback);


  #ifndef _7ZIP_ST

  // Warning : before memManager, threads and compressingCompletedEvents
  // in order to have a "good" order for the destructor
  NWindows::NSynchronization::CSynchro synchroForCompressingCompletedEvents;
  synchroForCompressingCompletedEvents.Create();
  NWindows::NSynchronization::CSynchro synchroForOutStreamSpec;
  synchroForOutStreamSpec.Create();

  CObjectVector<CItemOut> items;

  CMtProgressMixer *mtProgressMixerSpec = new CMtProgressMixer;
  CMyComPtr<ICompressProgressInfo> progress = mtProgressMixerSpec;
  mtProgressMixerSpec->Create(updateCallback, true);

  CMtCompressProgressMixer mtCompressProgressMixer;
  mtCompressProgressMixer.Init(numThreads, mtProgressMixerSpec->RatioProgress);

  CMemBlockManagerMt memManager(kBlockSize);
  CMemRefs refs(&memManager);

  CThreads threads;
  CRecordVector<HANDLE> compressingCompletedEvents;
  CUIntVector threadIndices;  // list threads in order of updateItems

  {
    RINOK(memManager.AllocateSpaceAlways(&synchroForOutStreamSpec,(size_t)numThreads * (kMemPerThread / kBlockSize)));
    for (i = 0; i < updateItems.Size(); i++)
      refs.Refs.Add(CMemBlocks2());

    for (i = 0; i < numThreads; i++)
      threads.Threads.Add(CThreadInfo(options2));

    for (i = 0; i < numThreads; i++)
    {
      CThreadInfo &threadInfo = threads.Threads[i];
      #ifdef EXTERNAL_CODECS
      threadInfo.__externalCodecs = __externalCodecs;
      #endif
      RINOK(threadInfo.CreateEvents(&synchroForCompressingCompletedEvents));
      threadInfo.OutStreamSpec = new COutMemStream(&memManager);
      RINOK(threadInfo.OutStreamSpec->CreateEvents(&synchroForOutStreamSpec));
      threadInfo.OutStream = threadInfo.OutStreamSpec;
      threadInfo.IsFree = true;
      threadInfo.ProgressSpec = new CMtCompressProgress();
      threadInfo.Progress = threadInfo.ProgressSpec;
      threadInfo.ProgressSpec->Init(&mtCompressProgressMixer, (int)i);
      threadInfo.FileTime = 0; // fix it !
      RINOK(threadInfo.CreateThread());
    }
  }

  unsigned mtItemIndex = 0;
  unsigned itemIndex = 0;
  int lastRealStreamItemIndex = -1;

  while (itemIndex < updateItems.Size())
  {
    if (threadIndices.Size() < numThreads && mtItemIndex < updateItems.Size())
    {
      CUpdateItem &ui = updateItems[mtItemIndex++];
      if (!ui.NewData)
        continue;
      CItemEx itemEx;
      CItemOut item;
      
      if (ui.NewProps)
      {
        if (ui.IsDir)
          continue;
      }
      else
      {
        itemEx = inputItems[ui.IndexInArc];
        if (inArchive->ReadLocalItemAfterCdItemFull(itemEx) != S_OK)
          return E_NOTIMPL;
        (CItem &)item = itemEx;
        if (item.IsDir())
          continue;
      }
      
      CMyComPtr<ISequentialInStream> fileInStream;
      
      {
        NWindows::NSynchronization::CCriticalSectionLock lock(mtProgressMixerSpec->Mixer2->CriticalSection);
        HRESULT res = updateCallback->GetStream(ui.IndexInClient, &fileInStream);
        if (res == S_FALSE)
        {
          complexity += ui.Size;
          complexity += kLocalHeaderSize;
          mtProgressMixerSpec->Mixer2->SetProgressOffset(complexity);
          RINOK(updateCallback->SetOperationResult(NArchive::NUpdate::NOperationResult::kOK));
          refs.Refs[mtItemIndex - 1].Skip = true;
          continue;
        }
        RINOK(res);
        if (!fileInStream)
          return E_INVALIDARG;
        UpdatePropsFromStream(ui, fileInStream, updateCallback, totalComplexity);
        RINOK(updateCallback->SetOperationResult(NArchive::NUpdate::NOperationResult::kOK));
      }

      for (UInt32 k = 0; k < numThreads; k++)
      {
        CThreadInfo &threadInfo = threads.Threads[k];
        if (threadInfo.IsFree)
        {
          threadInfo.IsFree = false;
          threadInfo.InStream = fileInStream;

          // !!!!! we must release ref before sending event
          // BUG was here in v4.43 and v4.44. It could change ref counter in two threads in same time
          fileInStream.Release();

          threadInfo.OutStreamSpec->Init();
          threadInfo.ProgressSpec->Reinit();
          threadInfo.CompressEvent.Set();
          threadInfo.UpdateIndex = mtItemIndex - 1;

          compressingCompletedEvents.Add(threadInfo.CompressionCompletedEvent);
          threadIndices.Add(k);
          break;
        }
      }
 
      continue;
    }
    
    if (refs.Refs[itemIndex].Skip)
    {
      itemIndex++;
      continue;
    }

    const CUpdateItem &ui = updateItems[itemIndex];

    CItemEx itemEx;
    CItemOut item;
    
    if (!ui.NewProps || !ui.NewData)
    {
      itemEx = inputItems[ui.IndexInArc];
      if (inArchive->ReadLocalItemAfterCdItemFull(itemEx) != S_OK)
        return E_NOTIMPL;
      (CItem &)item = itemEx;
    }

    if (ui.NewData)
    {
      bool isDir = ((ui.NewProps) ? ui.IsDir : item.IsDir());
      
      if (isDir)
      {
        WriteDirHeader(archive, options, ui, item);
      }
      else
      {
        if (lastRealStreamItemIndex < (int)itemIndex)
        {
          lastRealStreamItemIndex = itemIndex;
          SetFileHeader(archive, *options, ui, item);
          // file Size can be 64-bit !!!
          archive.PrepareWriteCompressedData(item.Name.Len(), ui.Size, options->IsRealAesMode());
        }

        CMemBlocks2 &memRef = refs.Refs[itemIndex];
        
        if (memRef.Defined)
        {
          CMyComPtr<IOutStream> outStream;
          archive.CreateStreamForCompressing(&outStream);
          memRef.WriteToStream(memManager.GetBlockSize(), outStream);
          SetFileHeader(archive, *options, ui, item);
          // the BUG was fixed in 9.26:
          // SetItemInfoFromCompressingResult must be after SetFileHeader
          // to write correct Size.
          SetItemInfoFromCompressingResult(memRef.CompressingResult,
              options->IsRealAesMode(), options->AesKeyMode, item);
          archive.WriteLocalHeader_And_SeekToNextFile(item);
          // RINOK(updateCallback->SetOperationResult(NArchive::NUpdate::NOperationResult::kOK));
          memRef.FreeOpt(&memManager);
        }
        else
        {
          {
            CThreadInfo &thread = threads.Threads[threadIndices.Front()];
            if (!thread.OutStreamSpec->WasUnlockEventSent())
            {
              CMyComPtr<IOutStream> outStream;
              archive.CreateStreamForCompressing(&outStream);
              thread.OutStreamSpec->SetOutStream(outStream);
              thread.OutStreamSpec->SetRealStreamMode();
            }
          }

          DWORD result = ::WaitForMultipleObjects(compressingCompletedEvents.Size(),
              &compressingCompletedEvents.Front(), FALSE, INFINITE);
#ifdef _WIN32 // FIXME
          if (result == WAIT_FAILED)
          {
            DWORD lastError = GetLastError();
            return lastError != 0 ? lastError : E_FAIL;
          }
#endif
          unsigned t = (unsigned)(result - WAIT_OBJECT_0);
          if (t >= compressingCompletedEvents.Size())
            return E_FAIL;

          CThreadInfo &threadInfo = threads.Threads[threadIndices[t]];
          threadInfo.InStream.Release();
          threadInfo.IsFree = true;
          RINOK(threadInfo.Result);
          threadIndices.Delete(t);
          compressingCompletedEvents.Delete(t);
          
          if (t == 0)
          {
            RINOK(threadInfo.OutStreamSpec->WriteToRealStream());
            threadInfo.OutStreamSpec->ReleaseOutStream();
            SetFileHeader(archive, *options, ui, item);
            SetItemInfoFromCompressingResult(threadInfo.CompressingResult,
                options->IsRealAesMode(), options->AesKeyMode, item);
            archive.WriteLocalHeader_And_SeekToNextFile(item);
          }
          else
          {
            CMemBlocks2 &memRef2 = refs.Refs[threadInfo.UpdateIndex];
            threadInfo.OutStreamSpec->DetachData(memRef2);
            memRef2.CompressingResult = threadInfo.CompressingResult;
            memRef2.Defined = true;
            continue;
          }
        }
      }
    }
    else
    {
      RINOK(UpdateItemOldData(archive, inArchive, itemEx, ui, item, progress, opCallback, complexity));
    }
 
    items.Add(item);
    complexity += kLocalHeaderSize;
    mtProgressMixerSpec->Mixer2->SetProgressOffset(complexity);
    itemIndex++;
  }
  
  RINOK(mtCompressProgressMixer.SetRatioInfo(0, NULL, NULL));
  archive.WriteCentralDir(items, comment);
  return S_OK;
  #endif
}


static const size_t kCacheBlockSize = (1 << 20);
static const size_t kCacheSize = (kCacheBlockSize << 2);
static const size_t kCacheMask = (kCacheSize - 1);

class CCacheOutStream:
  public IOutStream,
  public CMyUnknownImp
{
  CMyComPtr<IOutStream> _stream;
  Byte *_cache;
  UInt64 _virtPos;
  UInt64 _virtSize;
  UInt64 _phyPos;
  UInt64 _phySize; // <= _virtSize
  UInt64 _cachedPos; // (_cachedPos + _cachedSize) <= _virtSize
  size_t _cachedSize;

  HRESULT MyWrite(size_t size);
  HRESULT MyWriteBlock()
  {
    return MyWrite(kCacheBlockSize - ((size_t)_cachedPos & (kCacheBlockSize - 1)));
  }
  HRESULT FlushCache();
public:
  CCacheOutStream(): _cache(0) {}
  ~CCacheOutStream();
  bool Allocate();
  HRESULT Init(IOutStream *stream);
  
  MY_UNKNOWN_IMP

  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
  STDMETHOD(SetSize)(UInt64 newSize);
};

bool CCacheOutStream::Allocate()
{
  if (!_cache)
    _cache = (Byte *)::MidAlloc(kCacheSize);
  return (_cache != NULL);
}

HRESULT CCacheOutStream::Init(IOutStream *stream)
{
  _virtPos = _phyPos = 0;
  _stream = stream;
  RINOK(_stream->Seek(0, STREAM_SEEK_CUR, &_virtPos));
  RINOK(_stream->Seek(0, STREAM_SEEK_END, &_virtSize));
  RINOK(_stream->Seek(_virtPos, STREAM_SEEK_SET, &_virtPos));
  _phyPos = _virtPos;
  _phySize = _virtSize;
  _cachedPos = 0;
  _cachedSize = 0;
  return S_OK;
}

HRESULT CCacheOutStream::MyWrite(size_t size)
{
  while (size != 0 && _cachedSize != 0)
  {
    if (_phyPos != _cachedPos)
    {
      RINOK(_stream->Seek(_cachedPos, STREAM_SEEK_SET, &_phyPos));
    }
    size_t pos = (size_t)_cachedPos & kCacheMask;
    size_t curSize = MyMin(kCacheSize - pos, _cachedSize);
    curSize = MyMin(curSize, size);
    RINOK(WriteStream(_stream, _cache + pos, curSize));
    _phyPos += curSize;
    if (_phySize < _phyPos)
      _phySize = _phyPos;
    _cachedPos += curSize;
    _cachedSize -= curSize;
    size -= curSize;
  }
  return S_OK;
}

HRESULT CCacheOutStream::FlushCache()
{
  return MyWrite(_cachedSize);
}

CCacheOutStream::~CCacheOutStream()
{
  FlushCache();
  if (_virtSize != _phySize)
    _stream->SetSize(_virtSize);
  if (_virtPos != _phyPos)
    _stream->Seek(_virtPos, STREAM_SEEK_SET, NULL);
  ::MidFree(_cache);
}

STDMETHODIMP CCacheOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (size == 0)
    return S_OK;

  UInt64 zerosStart = _virtPos;
  if (_cachedSize != 0)
  {
    if (_virtPos < _cachedPos)
    {
      RINOK(FlushCache());
    }
    else
    {
      UInt64 cachedEnd = _cachedPos + _cachedSize;
      if (cachedEnd < _virtPos)
      {
        if (cachedEnd < _phySize)
        {
          RINOK(FlushCache());
        }
        else
          zerosStart = cachedEnd;
      }
    }
  }

  if (_cachedSize == 0 && _phySize < _virtPos)
    _cachedPos = zerosStart = _phySize;

  if (zerosStart != _virtPos)
  {
    // write zeros to [cachedEnd ... _virtPos)
    
    for (;;)
    {
      UInt64 cachedEnd = _cachedPos + _cachedSize;
      size_t endPos = (size_t)cachedEnd & kCacheMask;
      size_t curSize = kCacheSize - endPos;
      if (curSize > _virtPos - cachedEnd)
        curSize = (size_t)(_virtPos - cachedEnd);
      if (curSize == 0)
        break;
      while (curSize > (kCacheSize - _cachedSize))
      {
        RINOK(MyWriteBlock());
      }
      memset(_cache + endPos, 0, curSize);
      _cachedSize += curSize;
    }
  }

  if (_cachedSize == 0)
    _cachedPos = _virtPos;

  size_t pos = (size_t)_virtPos & kCacheMask;
  size = (UInt32)MyMin((size_t)size, kCacheSize - pos);
  UInt64 cachedEnd = _cachedPos + _cachedSize;
  if (_virtPos != cachedEnd) // _virtPos < cachedEnd
    size = (UInt32)MyMin((size_t)size, (size_t)(cachedEnd - _virtPos));
  else
  {
    // _virtPos == cachedEnd
    if (_cachedSize == kCacheSize)
    {
      RINOK(MyWriteBlock());
    }
    size_t startPos = (size_t)_cachedPos & kCacheMask;
    if (startPos > pos)
      size = (UInt32)MyMin((size_t)size, (size_t)(startPos - pos));
    _cachedSize += size;
  }
  memcpy(_cache + pos, data, size);
  if (processedSize)
    *processedSize = size;
  _virtPos += size;
  if (_virtSize < _virtPos)
    _virtSize = _virtPos;
  return S_OK;
}

STDMETHODIMP CCacheOutStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _virtPos; break;
    case STREAM_SEEK_END: offset += _virtSize; break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _virtPos = offset;
  if (newPosition)
    *newPosition = offset;
  return S_OK;
}

STDMETHODIMP CCacheOutStream::SetSize(UInt64 newSize)
{
  _virtSize = newSize;
  if (newSize < _phySize)
  {
    RINOK(_stream->SetSize(newSize));
    _phySize = newSize;
  }
  if (newSize <= _cachedPos)
  {
    _cachedSize = 0;
    _cachedPos = newSize;
  }
  if (newSize < _cachedPos + _cachedSize)
    _cachedSize = (size_t)(newSize - _cachedPos);
  return S_OK;
}


HRESULT Update(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const CObjectVector<CItemEx> &inputItems,
    CObjectVector<CUpdateItem> &updateItems,
    ISequentialOutStream *seqOutStream,
    CInArchive *inArchive, bool removeSfx,
    CCompressionMethodMode *compressionMethodMode,
    IArchiveUpdateCallback *updateCallback)
{
  if (inArchive)
  {
    if (!inArchive->CanUpdate())
      return E_NOTIMPL;
  }


  CMyComPtr<IOutStream> outStream;
  {
    CMyComPtr<IOutStream> outStreamReal;
    seqOutStream->QueryInterface(IID_IOutStream, (void **)&outStreamReal);
    if (!outStreamReal)
      return E_NOTIMPL;

    if (inArchive)
    {
      if (!inArchive->IsMultiVol && inArchive->ArcInfo.Base > 0 && !removeSfx)
      {
        IInStream *baseStream = inArchive->GetBaseStream();
        RINOK(baseStream->Seek(0, STREAM_SEEK_SET, NULL));
        RINOK(NCompress::CopyStream_ExactSize(baseStream, outStreamReal, inArchive->ArcInfo.Base, NULL));
      }
    }

    CCacheOutStream *cacheStream = new CCacheOutStream();
    outStream = cacheStream;
    if (!cacheStream->Allocate())
      return E_OUTOFMEMORY;
    RINOK(cacheStream->Init(outStreamReal));
  }

  COutArchive outArchive;
  RINOK(outArchive.Create(outStream));

  if (inArchive)
  {
    if (!inArchive->IsMultiVol && (Int64)inArchive->ArcInfo.MarkerPos2 > inArchive->ArcInfo.Base)
    {
      IInStream *baseStream = inArchive->GetBaseStream();
      RINOK(baseStream->Seek(inArchive->ArcInfo.Base, STREAM_SEEK_SET, NULL));
      UInt64 embStubSize = inArchive->ArcInfo.MarkerPos2 - inArchive->ArcInfo.Base;
      RINOK(NCompress::CopyStream_ExactSize(baseStream, outStream, embStubSize, NULL));
      outArchive.MoveCurPos(embStubSize);
    }
  }

  return Update2(
      EXTERNAL_CODECS_LOC_VARS
      outArchive, inArchive,
      inputItems, updateItems,
      compressionMethodMode,
      inArchive ? &inArchive->ArcInfo.Comment : NULL,
      updateCallback);
}

}}
// ZipUpdate.h

#ifndef __ZIP_UPDATE_H
#define __ZIP_UPDATE_H

#include "../../ICoder.h"
#include "../IArchive.h"

#include "../../Common/CreateCoder.h"

#include "ZipCompressionMode.h"
#include "ZipIn.h"

namespace NArchive {
namespace NZip {

struct CUpdateRange
{
  UInt64 Position;
  UInt64 Size;
  
  // CUpdateRange() {};
  CUpdateRange(UInt64 position, UInt64 size): Position(position), Size(size) {};
};

struct CUpdateItem
{
  bool NewData;
  bool NewProps;
  bool IsDir;
  bool NtfsTimeIsDefined;
  bool IsUtf8;
  int IndexInArc;
  int IndexInClient;
  UInt32 Attrib;
  UInt32 Time;
  UInt64 Size;
  AString Name;
  // bool Commented;
  // CUpdateRange CommentRange;
  FILETIME Ntfs_MTime;
  FILETIME Ntfs_ATime;
  FILETIME Ntfs_CTime;

  CUpdateItem(): NtfsTimeIsDefined(false), IsUtf8(false), Size(0) {}
};

HRESULT Update(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const CObjectVector<CItemEx> &inputItems,
    CObjectVector<CUpdateItem> &updateItems,
    ISequentialOutStream *seqOutStream,
    CInArchive *inArchive, bool removeSfx,
    CCompressionMethodMode *compressionMethodMode,
    IArchiveUpdateCallback *updateCallback);

}}

#endif

include ../../../../makefile.crc32
include ../../../../makefile.machine

TARGET_FLAGS=$(CC_EXE)
LOCAL_LINK=$(LINK_EXE)
LIBS=$(LOCAL_LIBS)

include ../../../../makefile.glb


# WARNING : automatically generated by utils/generate.py

PROG=../../../../bin/7za$(BINSUFFIX)

all: $(PCH_NAME) $(PROG)

LOCAL_FLAGS=$(TARGET_FLAGS) \
  -D_FILE_OFFSET_BITS=64 \
  -D_LARGEFILE_SOURCE \
  -D_REENTRANT \
  -DENV_UNIX \
  -DBREAK_HANDLER \
  -DUNICODE \
  -D_UNICODE \
  -DUNIX_USE_WIN_FILE \

SRCS=\
  ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zDecode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zEncode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zExtract.cpp \
  ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandler.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHeader.cpp \
  ../../../../CPP/7zip/Archive/7z/7zIn.cpp \
  ../../../../CPP/7zip/Archive/7z/7zOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zProperties.cpp \
  ../../../../CPP/7zip/Archive/7z/7zRegister.cpp \
  ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp \
  ../../../../CPP/7zip/Archive/Bz2Handler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHandler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHeader.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabIn.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabRegister.cpp \
  ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp \
  ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp \
  ../../../../CPP/7zip/Archive/Common/FindSignature.cpp \
  ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp \
  ../../../../CPP/7zip/Archive/Common/MultiStream.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp \
  ../../../../CPP/7zip/Archive/DeflateProps.cpp \
  ../../../../CPP/7zip/Archive/GzHandler.cpp \
  ../../../../CPP/7zip/Archive/LzmaHandler.cpp \
  ../../../../CPP/7zip/Archive/PpmdHandler.cpp \
  ../../../../CPP/7zip/Archive/SplitHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHeader.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarIn.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarRegister.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp \
  ../../../../CPP/7zip/Archive/XzHandler.cpp \
  ../../../../CPP/7zip/Archive/ZHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipIn.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipItem.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp \
  ../../../../CPP/7zip/Common/CWrappers.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilePathAutoRename.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/InBuffer.cpp \
  ../../../../CPP/7zip/Common/InOutTempBuffer.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MemBlocks.cpp \
  ../../../../CPP/7zip/Common/MethodId.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/OffsetStream.cpp \
  ../../../../CPP/7zip/Common/OutBuffer.cpp \
  ../../../../CPP/7zip/Common/OutMemStream.cpp \
  ../../../../CPP/7zip/Common/ProgressMt.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamBinder.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Common/VirtThread.cpp \
  ../../../../CPP/7zip/Compress/BZip2Crc.cpp \
  ../../../../CPP/7zip/Compress/BZip2Decoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Encoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Register.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Coder.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Register.cpp \
  ../../../../CPP/7zip/Compress/BcjCoder.cpp \
  ../../../../CPP/7zip/Compress/BcjRegister.cpp \
  ../../../../CPP/7zip/Compress/BitlDecoder.cpp \
  ../../../../CPP/7zip/Compress/BranchMisc.cpp \
  ../../../../CPP/7zip/Compress/BranchRegister.cpp \
  ../../../../CPP/7zip/Compress/ByteSwap.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/Compress/CopyRegister.cpp \
  ../../../../CPP/7zip/Compress/Deflate64Register.cpp \
  ../../../../CPP/7zip/Compress/DeflateDecoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateEncoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateRegister.cpp \
  ../../../../CPP/7zip/Compress/DeltaFilter.cpp \
  ../../../../CPP/7zip/Compress/ImplodeDecoder.cpp \
  ../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzOutWindow.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Register.cpp \
  ../../../../CPP/7zip/Compress/LzmaDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaEncoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaRegister.cpp \
  ../../../../CPP/7zip/Compress/LzxDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdEncoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdRegister.cpp \
  ../../../../CPP/7zip/Compress/PpmdZip.cpp \
  ../../../../CPP/7zip/Compress/QuantumDecoder.cpp \
  ../../../../CPP/7zip/Compress/ShrinkDecoder.cpp \
  ../../../../CPP/7zip/Compress/ZDecoder.cpp \
  ../../../../CPP/7zip/Crypto/7zAes.cpp \
  ../../../../CPP/7zip/Crypto/7zAesRegister.cpp \
  ../../../../CPP/7zip/Crypto/HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/MyAes.cpp \
  ../../../../CPP/7zip/Crypto/MyAesReg.cpp \
  ../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/RandGen.cpp \
  ../../../../CPP/7zip/Crypto/WzAes.cpp \
  ../../../../CPP/7zip/Crypto/ZipCrypto.cpp \
  ../../../../CPP/7zip/Crypto/ZipStrong.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp \
  ../../../../CPP/7zip/UI/Common/Bench.cpp \
  ../../../../CPP/7zip/UI/Common/DefaultName.cpp \
  ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp \
  ../../../../CPP/7zip/UI/Common/Extract.cpp \
  ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp \
  ../../../../CPP/7zip/UI/Common/HashCalc.cpp \
  ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp \
  ../../../../CPP/7zip/UI/Common/OpenArchive.cpp \
  ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp \
  ../../../../CPP/7zip/UI/Common/SetProperties.cpp \
  ../../../../CPP/7zip/UI/Common/SortUtils.cpp \
  ../../../../CPP/7zip/UI/Common/TempFiles.cpp \
  ../../../../CPP/7zip/UI/Common/Update.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateAction.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp \
  ../../../../CPP/7zip/UI/Common/UpdatePair.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp \
  ../../../../CPP/7zip/UI/Console/BenchCon.cpp \
  ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp \
  ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/HashCon.cpp \
  ../../../../CPP/7zip/UI/Console/List.cpp \
  ../../../../CPP/7zip/UI/Console/Main.cpp \
  ../../../../CPP/7zip/UI/Console/MainAr.cpp \
  ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp \
  ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CommandLineParser.cpp \
  ../../../../CPP/Common/CrcReg.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/ListFileUtils.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/Sha1Reg.cpp \
  ../../../../CPP/Common/Sha256Reg.cpp \
  ../../../../CPP/Common/StdInStream.cpp \
  ../../../../CPP/Common/StdOutStream.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Common/XzCrc64Reg.cpp \
  ../../../../CPP/Windows/ErrorMsg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantConv.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/myWindows/myAddExeFlag.cpp \
  ../../../../CPP/myWindows/mySplitCommandLine.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \

SRCS_C=\
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/7zStream.c \
  ../../../../C/Aes.c \
  ../../../../C/Alloc.c \
  ../../../../C/Bcj2.c \
  ../../../../C/Bcj2Enc.c \
  ../../../../C/Bra.c \
  ../../../../C/Bra86.c \
  ../../../../C/BraIA64.c \
  ../../../../C/BwtSort.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Delta.c \
  ../../../../C/HuffEnc.c \
  ../../../../C/LzFind.c \
  ../../../../C/LzFindMt.c \
  ../../../../C/Lzma2Dec.c \
  ../../../../C/Lzma2Enc.c \
  ../../../../C/LzmaDec.c \
  ../../../../C/LzmaEnc.c \
  ../../../../C/MtCoder.c \
  ../../../../C/Ppmd7.c \
  ../../../../C/Ppmd7Dec.c \
  ../../../../C/Ppmd7Enc.c \
  ../../../../C/Ppmd8.c \
  ../../../../C/Ppmd8Dec.c \
  ../../../../C/Ppmd8Enc.c \
  ../../../../C/Sha1.c \
  ../../../../C/Sha256.c \
  ../../../../C/Sort.c \
  ../../../../C/Threads.c \
  ../../../../C/Xz.c \
  ../../../../C/XzCrc64.c \
  ../../../../C/XzCrc64Opt.c \
  ../../../../C/XzDec.c \
  ../../../../C/XzEnc.c \
  ../../../../C/XzIn.c \

StdAfx.h.gch : ../../../myWindows/StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) ../../../myWindows/StdAfx.h -o StdAfx.h.gch
7zCrc.o : ../../../../C/7zCrc.c
	$(CC) $(CFLAGS) ../../../../C/7zCrc.c
7zCrcOpt.o : ../../../../C/7zCrcOpt.c
	$(CC) $(CFLAGS) ../../../../C/7zCrcOpt.c
7zStream.o : ../../../../C/7zStream.c
	$(CC) $(CFLAGS) ../../../../C/7zStream.c
Aes.o : ../../../../C/Aes.c
	$(CC) $(CFLAGS) ../../../../C/Aes.c
Alloc.o : ../../../../C/Alloc.c
	$(CC) $(CFLAGS) ../../../../C/Alloc.c
Bcj2.o : ../../../../C/Bcj2.c
	$(CC) $(CFLAGS) ../../../../C/Bcj2.c
Bcj2Enc.o : ../../../../C/Bcj2Enc.c
	$(CC) $(CFLAGS) ../../../../C/Bcj2Enc.c
Bra.o : ../../../../C/Bra.c
	$(CC) $(CFLAGS) ../../../../C/Bra.c
Bra86.o : ../../../../C/Bra86.c
	$(CC) $(CFLAGS) ../../../../C/Bra86.c
BraIA64.o : ../../../../C/BraIA64.c
	$(CC) $(CFLAGS) ../../../../C/BraIA64.c
BwtSort.o : ../../../../C/BwtSort.c
	$(CC) $(CFLAGS) ../../../../C/BwtSort.c
CpuArch.o : ../../../../C/CpuArch.c
	$(CC) $(CFLAGS) ../../../../C/CpuArch.c
Delta.o : ../../../../C/Delta.c
	$(CC) $(CFLAGS) ../../../../C/Delta.c
HuffEnc.o : ../../../../C/HuffEnc.c
	$(CC) $(CFLAGS) ../../../../C/HuffEnc.c
LzFind.o : ../../../../C/LzFind.c
	$(CC) $(CFLAGS) ../../../../C/LzFind.c
LzFindMt.o : ../../../../C/LzFindMt.c
	$(CC) $(CFLAGS) ../../../../C/LzFindMt.c
Lzma2Dec.o : ../../../../C/Lzma2Dec.c
	$(CC) $(CFLAGS) ../../../../C/Lzma2Dec.c
Lzma2Enc.o : ../../../../C/Lzma2Enc.c
	$(CC) $(CFLAGS) ../../../../C/Lzma2Enc.c
LzmaDec.o : ../../../../C/LzmaDec.c
	$(CC) $(CFLAGS) ../../../../C/LzmaDec.c
LzmaEnc.o : ../../../../C/LzmaEnc.c
	$(CC) $(CFLAGS) ../../../../C/LzmaEnc.c
MtCoder.o : ../../../../C/MtCoder.c
	$(CC) $(CFLAGS) ../../../../C/MtCoder.c
Ppmd7.o : ../../../../C/Ppmd7.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd7.c
Ppmd7Dec.o : ../../../../C/Ppmd7Dec.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd7Dec.c
Ppmd7Enc.o : ../../../../C/Ppmd7Enc.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd7Enc.c
Ppmd8.o : ../../../../C/Ppmd8.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd8.c
Ppmd8Dec.o : ../../../../C/Ppmd8Dec.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd8Dec.c
Ppmd8Enc.o : ../../../../C/Ppmd8Enc.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd8Enc.c
Sha1.o : ../../../../C/Sha1.c
	$(CC) $(CFLAGS) ../../../../C/Sha1.c
Sha256.o : ../../../../C/Sha256.c
	$(CC) $(CFLAGS) ../../../../C/Sha256.c
Sort.o : ../../../../C/Sort.c
	$(CC) $(CFLAGS) ../../../../C/Sort.c
Threads.o : ../../../../C/Threads.c
	$(CC) $(CFLAGS) ../../../../C/Threads.c
Xz.o : ../../../../C/Xz.c
	$(CC) $(CFLAGS) ../../../../C/Xz.c
XzCrc64.o : ../../../../C/XzCrc64.c
	$(CC) $(CFLAGS) ../../../../C/XzCrc64.c
XzCrc64Opt.o : ../../../../C/XzCrc64Opt.c
	$(CC) $(CFLAGS) ../../../../C/XzCrc64Opt.c
XzDec.o : ../../../../C/XzDec.c
	$(CC) $(CFLAGS) ../../../../C/XzDec.c
XzEnc.o : ../../../../C/XzEnc.c
	$(CC) $(CFLAGS) ../../../../C/XzEnc.c
XzIn.o : ../../../../C/XzIn.c
	$(CC) $(CFLAGS) ../../../../C/XzIn.c
7zCompressionMode.o : ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp
7zDecode.o : ../../../../CPP/7zip/Archive/7z/7zDecode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zDecode.cpp
7zEncode.o : ../../../../CPP/7zip/Archive/7z/7zEncode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zEncode.cpp
7zExtract.o : ../../../../CPP/7zip/Archive/7z/7zExtract.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zExtract.cpp
7zFolderInStream.o : ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp
7zHandler.o : ../../../../CPP/7zip/Archive/7z/7zHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHandler.cpp
7zHandlerOut.o : ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp
7zHeader.o : ../../../../CPP/7zip/Archive/7z/7zHeader.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHeader.cpp
7zIn.o : ../../../../CPP/7zip/Archive/7z/7zIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zIn.cpp
7zOut.o : ../../../../CPP/7zip/Archive/7z/7zOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zOut.cpp
7zProperties.o : ../../../../CPP/7zip/Archive/7z/7zProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zProperties.cpp
7zRegister.o : ../../../../CPP/7zip/Archive/7z/7zRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zRegister.cpp
7zSpecStream.o : ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp
7zUpdate.o : ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp
Bz2Handler.o : ../../../../CPP/7zip/Archive/Bz2Handler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Bz2Handler.cpp
CabBlockInStream.o : ../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp
CabHandler.o : ../../../../CPP/7zip/Archive/Cab/CabHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabHandler.cpp
CabHeader.o : ../../../../CPP/7zip/Archive/Cab/CabHeader.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabHeader.cpp
CabIn.o : ../../../../CPP/7zip/Archive/Cab/CabIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabIn.cpp
CabRegister.o : ../../../../CPP/7zip/Archive/Cab/CabRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabRegister.cpp
CoderMixer2.o : ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp
DummyOutStream.o : ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp
FindSignature.o : ../../../../CPP/7zip/Archive/Common/FindSignature.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/FindSignature.cpp
HandlerOut.o : ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp
InStreamWithCRC.o : ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp
ItemNameUtils.o : ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp
MultiStream.o : ../../../../CPP/7zip/Archive/Common/MultiStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/MultiStream.cpp
OutStreamWithCRC.o : ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
ParseProperties.o : ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp
DeflateProps.o : ../../../../CPP/7zip/Archive/DeflateProps.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/DeflateProps.cpp
GzHandler.o : ../../../../CPP/7zip/Archive/GzHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/GzHandler.cpp
LzmaHandler.o : ../../../../CPP/7zip/Archive/LzmaHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/LzmaHandler.cpp
PpmdHandler.o : ../../../../CPP/7zip/Archive/PpmdHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/PpmdHandler.cpp
SplitHandler.o : ../../../../CPP/7zip/Archive/SplitHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/SplitHandler.cpp
TarHandler.o : ../../../../CPP/7zip/Archive/Tar/TarHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarHandler.cpp
TarHandlerOut.o : ../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp
TarHeader.o : ../../../../CPP/7zip/Archive/Tar/TarHeader.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarHeader.cpp
TarIn.o : ../../../../CPP/7zip/Archive/Tar/TarIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarIn.cpp
TarOut.o : ../../../../CPP/7zip/Archive/Tar/TarOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarOut.cpp
TarRegister.o : ../../../../CPP/7zip/Archive/Tar/TarRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarRegister.cpp
TarUpdate.o : ../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp
XzHandler.o : ../../../../CPP/7zip/Archive/XzHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/XzHandler.cpp
ZHandler.o : ../../../../CPP/7zip/Archive/ZHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/ZHandler.cpp
ZipAddCommon.o : ../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp
ZipHandler.o : ../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp
ZipHandlerOut.o : ../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp
ZipIn.o : ../../../../CPP/7zip/Archive/Zip/ZipIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipIn.cpp
ZipItem.o : ../../../../CPP/7zip/Archive/Zip/ZipItem.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipItem.cpp
ZipOut.o : ../../../../CPP/7zip/Archive/Zip/ZipOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipOut.cpp
ZipRegister.o : ../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp
ZipUpdate.o : ../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp
CWrappers.o : ../../../../CPP/7zip/Common/CWrappers.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CWrappers.cpp
CreateCoder.o : ../../../../CPP/7zip/Common/CreateCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CreateCoder.cpp
FilePathAutoRename.o : ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
FileStreams.o : ../../../../CPP/7zip/Common/FileStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FileStreams.cpp
FilterCoder.o : ../../../../CPP/7zip/Common/FilterCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilterCoder.cpp
InBuffer.o : ../../../../CPP/7zip/Common/InBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/InBuffer.cpp
InOutTempBuffer.o : ../../../../CPP/7zip/Common/InOutTempBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/InOutTempBuffer.cpp
LimitedStreams.o : ../../../../CPP/7zip/Common/LimitedStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/LimitedStreams.cpp
MemBlocks.o : ../../../../CPP/7zip/Common/MemBlocks.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MemBlocks.cpp
MethodId.o : ../../../../CPP/7zip/Common/MethodId.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MethodId.cpp
MethodProps.o : ../../../../CPP/7zip/Common/MethodProps.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MethodProps.cpp
OffsetStream.o : ../../../../CPP/7zip/Common/OffsetStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OffsetStream.cpp
OutBuffer.o : ../../../../CPP/7zip/Common/OutBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OutBuffer.cpp
OutMemStream.o : ../../../../CPP/7zip/Common/OutMemStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OutMemStream.cpp
ProgressMt.o : ../../../../CPP/7zip/Common/ProgressMt.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/ProgressMt.cpp
ProgressUtils.o : ../../../../CPP/7zip/Common/ProgressUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/ProgressUtils.cpp
PropId.o : ../../../../CPP/7zip/Common/PropId.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/PropId.cpp
StreamBinder.o : ../../../../CPP/7zip/Common/StreamBinder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamBinder.cpp
StreamObjects.o : ../../../../CPP/7zip/Common/StreamObjects.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamObjects.cpp
StreamUtils.o : ../../../../CPP/7zip/Common/StreamUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamUtils.cpp
UniqBlocks.o : ../../../../CPP/7zip/Common/UniqBlocks.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/UniqBlocks.cpp
VirtThread.o : ../../../../CPP/7zip/Common/VirtThread.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/VirtThread.cpp
BZip2Crc.o : ../../../../CPP/7zip/Compress/BZip2Crc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BZip2Crc.cpp
BZip2Decoder.o : ../../../../CPP/7zip/Compress/BZip2Decoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BZip2Decoder.cpp
BZip2Encoder.o : ../../../../CPP/7zip/Compress/BZip2Encoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BZip2Encoder.cpp
BZip2Register.o : ../../../../CPP/7zip/Compress/BZip2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BZip2Register.cpp
Bcj2Coder.o : ../../../../CPP/7zip/Compress/Bcj2Coder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Bcj2Coder.cpp
Bcj2Register.o : ../../../../CPP/7zip/Compress/Bcj2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Bcj2Register.cpp
BcjCoder.o : ../../../../CPP/7zip/Compress/BcjCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BcjCoder.cpp
BcjRegister.o : ../../../../CPP/7zip/Compress/BcjRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BcjRegister.cpp
BitlDecoder.o : ../../../../CPP/7zip/Compress/BitlDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BitlDecoder.cpp
BranchMisc.o : ../../../../CPP/7zip/Compress/BranchMisc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BranchMisc.cpp
BranchRegister.o : ../../../../CPP/7zip/Compress/BranchRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BranchRegister.cpp
ByteSwap.o : ../../../../CPP/7zip/Compress/ByteSwap.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ByteSwap.cpp
CopyCoder.o : ../../../../CPP/7zip/Compress/CopyCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyCoder.cpp
CopyRegister.o : ../../../../CPP/7zip/Compress/CopyRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyRegister.cpp
Deflate64Register.o : ../../../../CPP/7zip/Compress/Deflate64Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Deflate64Register.cpp
DeflateDecoder.o : ../../../../CPP/7zip/Compress/DeflateDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeflateDecoder.cpp
DeflateEncoder.o : ../../../../CPP/7zip/Compress/DeflateEncoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeflateEncoder.cpp
DeflateRegister.o : ../../../../CPP/7zip/Compress/DeflateRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeflateRegister.cpp
DeltaFilter.o : ../../../../CPP/7zip/Compress/DeltaFilter.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeltaFilter.cpp
ImplodeDecoder.o : ../../../../CPP/7zip/Compress/ImplodeDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ImplodeDecoder.cpp
ImplodeHuffmanDecoder.o : ../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp
LzOutWindow.o : ../../../../CPP/7zip/Compress/LzOutWindow.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzOutWindow.cpp
Lzma2Decoder.o : ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp
Lzma2Encoder.o : ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp
Lzma2Register.o : ../../../../CPP/7zip/Compress/Lzma2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Register.cpp
LzmaDecoder.o : ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
LzmaEncoder.o : ../../../../CPP/7zip/Compress/LzmaEncoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaEncoder.cpp
LzmaRegister.o : ../../../../CPP/7zip/Compress/LzmaRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaRegister.cpp
LzxDecoder.o : ../../../../CPP/7zip/Compress/LzxDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzxDecoder.cpp
PpmdDecoder.o : ../../../../CPP/7zip/Compress/PpmdDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdDecoder.cpp
PpmdEncoder.o : ../../../../CPP/7zip/Compress/PpmdEncoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdEncoder.cpp
PpmdRegister.o : ../../../../CPP/7zip/Compress/PpmdRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdRegister.cpp
PpmdZip.o : ../../../../CPP/7zip/Compress/PpmdZip.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdZip.cpp
QuantumDecoder.o : ../../../../CPP/7zip/Compress/QuantumDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/QuantumDecoder.cpp
ShrinkDecoder.o : ../../../../CPP/7zip/Compress/ShrinkDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ShrinkDecoder.cpp
ZDecoder.o : ../../../../CPP/7zip/Compress/ZDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ZDecoder.cpp
7zAes.o : ../../../../CPP/7zip/Crypto/7zAes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/7zAes.cpp
7zAesRegister.o : ../../../../CPP/7zip/Crypto/7zAesRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/7zAesRegister.cpp
HmacSha1.o : ../../../../CPP/7zip/Crypto/HmacSha1.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/HmacSha1.cpp
MyAes.o : ../../../../CPP/7zip/Crypto/MyAes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/MyAes.cpp
MyAesReg.o : ../../../../CPP/7zip/Crypto/MyAesReg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/MyAesReg.cpp
Pbkdf2HmacSha1.o : ../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp
RandGen.o : ../../../../CPP/7zip/Crypto/RandGen.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/RandGen.cpp
WzAes.o : ../../../../CPP/7zip/Crypto/WzAes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/WzAes.cpp
ZipCrypto.o : ../../../../CPP/7zip/Crypto/ZipCrypto.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/ZipCrypto.cpp
ZipStrong.o : ../../../../CPP/7zip/Crypto/ZipStrong.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/ZipStrong.cpp
ArchiveCommandLine.o : ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp
ArchiveExtractCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
ArchiveOpenCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
Bench.o : ../../../../CPP/7zip/UI/Common/Bench.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Bench.cpp
DefaultName.o : ../../../../CPP/7zip/UI/Common/DefaultName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/DefaultName.cpp
EnumDirItems.o : ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp
Extract.o : ../../../../CPP/7zip/UI/Common/Extract.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Extract.cpp
ExtractingFilePath.o : ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
HashCalc.o : ../../../../CPP/7zip/UI/Common/HashCalc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/HashCalc.cpp
LoadCodecs.o : ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
OpenArchive.o : ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
PropIDUtils.o : ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
SetProperties.o : ../../../../CPP/7zip/UI/Common/SetProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/SetProperties.cpp
SortUtils.o : ../../../../CPP/7zip/UI/Common/SortUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/SortUtils.cpp
TempFiles.o : ../../../../CPP/7zip/UI/Common/TempFiles.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/TempFiles.cpp
Update.o : ../../../../CPP/7zip/UI/Common/Update.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Update.cpp
UpdateAction.o : ../../../../CPP/7zip/UI/Common/UpdateAction.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateAction.cpp
UpdateCallback.o : ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp
UpdatePair.o : ../../../../CPP/7zip/UI/Common/UpdatePair.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdatePair.cpp
UpdateProduce.o : ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp
BenchCon.o : ../../../../CPP/7zip/UI/Console/BenchCon.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/BenchCon.cpp
ConsoleClose.o : ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp
ExtractCallbackConsole.o : ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp
HashCon.o : ../../../../CPP/7zip/UI/Console/HashCon.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/HashCon.cpp
List.o : ../../../../CPP/7zip/UI/Console/List.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/List.cpp
Main.o : ../../../../CPP/7zip/UI/Console/Main.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/Main.cpp
MainAr.o : ../../../../CPP/7zip/UI/Console/MainAr.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/MainAr.cpp
OpenCallbackConsole.o : ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp
PercentPrinter.o : ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp
UpdateCallbackConsole.o : ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp
UserInputUtils.o : ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp
CRC.o : ../../../../CPP/Common/CRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CRC.cpp
CommandLineParser.o : ../../../../CPP/Common/CommandLineParser.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CommandLineParser.cpp
CrcReg.o : ../../../../CPP/Common/CrcReg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CrcReg.cpp
IntToString.o : ../../../../CPP/Common/IntToString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/IntToString.cpp
ListFileUtils.o : ../../../../CPP/Common/ListFileUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/ListFileUtils.cpp
MyString.o : ../../../../CPP/Common/MyString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyString.cpp
MyVector.o : ../../../../CPP/Common/MyVector.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyVector.cpp
MyWindows.o : ../../../../CPP/Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyWindows.cpp
Sha1Reg.o : ../../../../CPP/Common/Sha1Reg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Sha1Reg.cpp
Sha256Reg.o : ../../../../CPP/Common/Sha256Reg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Sha256Reg.cpp
StdInStream.o : ../../../../CPP/Common/StdInStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StdInStream.cpp
StdOutStream.o : ../../../../CPP/Common/StdOutStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StdOutStream.cpp
StringConvert.o : ../../../../CPP/Common/StringConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringConvert.cpp
StringToInt.o : ../../../../CPP/Common/StringToInt.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringToInt.cpp
UTFConvert.o : ../../../../CPP/Common/UTFConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/UTFConvert.cpp
Wildcard.o : ../../../../CPP/Common/Wildcard.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Wildcard.cpp
XzCrc64Reg.o : ../../../../CPP/Common/XzCrc64Reg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/XzCrc64Reg.cpp
ErrorMsg.o : ../../../../CPP/Windows/ErrorMsg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/ErrorMsg.cpp
FileDir.o : ../../../../CPP/Windows/FileDir.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileDir.cpp
FileFind.o : ../../../../CPP/Windows/FileFind.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileFind.cpp
FileIO.o : ../../../../CPP/Windows/FileIO.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileIO.cpp
FileName.o : ../../../../CPP/Windows/FileName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileName.cpp
PropVariant.o : ../../../../CPP/Windows/PropVariant.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariant.cpp
PropVariantConv.o : ../../../../CPP/Windows/PropVariantConv.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariantConv.cpp
Synchronization.o : ../../../../CPP/Windows/Synchronization.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Synchronization.cpp
System.o : ../../../../CPP/Windows/System.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/System.cpp
TimeUtils.o : ../../../../CPP/Windows/TimeUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/TimeUtils.cpp
myAddExeFlag.o : ../../../../CPP/myWindows/myAddExeFlag.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/myAddExeFlag.cpp
mySplitCommandLine.o : ../../../../CPP/myWindows/mySplitCommandLine.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/mySplitCommandLine.cpp
wine_date_and_time.o : ../../../../CPP/myWindows/wine_date_and_time.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_date_and_time.cpp

OBJS=\
 7zCrc.o \
 $(OBJ_CRC32) \
 7zStream.o \
 Aes.o \
 Alloc.o \
 Bcj2.o \
 Bcj2Enc.o \
 Bra.o \
 Bra86.o \
 BraIA64.o \
 BwtSort.o \
 CpuArch.o \
 Delta.o \
 HuffEnc.o \
 LzFind.o \
 LzFindMt.o \
 Lzma2Dec.o \
 Lzma2Enc.o \
 LzmaDec.o \
 LzmaEnc.o \
 MtCoder.o \
 Ppmd7.o \
 Ppmd7Dec.o \
 Ppmd7Enc.o \
 Ppmd8.o \
 Ppmd8Dec.o \
 Ppmd8Enc.o \
 Sha1.o \
 Sha256.o \
 Sort.o \
 Threads.o \
 Xz.o \
 XzCrc64.o \
 XzCrc64Opt.o \
 XzDec.o \
 XzEnc.o \
 XzIn.o \
 7zCompressionMode.o \
 7zDecode.o \
 7zEncode.o \
 7zExtract.o \
 7zFolderInStream.o \
 7zHandler.o \
 7zHandlerOut.o \
 7zHeader.o \
 7zIn.o \
 7zOut.o \
 7zProperties.o \
 7zRegister.o \
 7zSpecStream.o \
 7zUpdate.o \
 Bz2Handler.o \
 CabBlockInStream.o \
 CabHandler.o \
 CabHeader.o \
 CabIn.o \
 CabRegister.o \
 CoderMixer2.o \
 DummyOutStream.o \
 FindSignature.o \
 HandlerOut.o \
 InStreamWithCRC.o \
 ItemNameUtils.o \
 MultiStream.o \
 OutStreamWithCRC.o \
 ParseProperties.o \
 DeflateProps.o \
 GzHandler.o \
 LzmaHandler.o \
 PpmdHandler.o \
 SplitHandler.o \
 TarHandler.o \
 TarHandlerOut.o \
 TarHeader.o \
 TarIn.o \
 TarOut.o \
 TarRegister.o \
 TarUpdate.o \
 XzHandler.o \
 ZHandler.o \
 ZipAddCommon.o \
 ZipHandler.o \
 ZipHandlerOut.o \
 ZipIn.o \
 ZipItem.o \
 ZipOut.o \
 ZipRegister.o \
 ZipUpdate.o \
 CWrappers.o \
 CreateCoder.o \
 FilePathAutoRename.o \
 FileStreams.o \
 FilterCoder.o \
 InBuffer.o \
 InOutTempBuffer.o \
 LimitedStreams.o \
 MemBlocks.o \
 MethodId.o \
 MethodProps.o \
 OffsetStream.o \
 OutBuffer.o \
 OutMemStream.o \
 ProgressMt.o \
 ProgressUtils.o \
 PropId.o \
 StreamBinder.o \
 StreamObjects.o \
 StreamUtils.o \
 UniqBlocks.o \
 VirtThread.o \
 BZip2Crc.o \
 BZip2Decoder.o \
 BZip2Encoder.o \
 BZip2Register.o \
 Bcj2Coder.o \
 Bcj2Register.o \
 BcjCoder.o \
 BcjRegister.o \
 BitlDecoder.o \
 BranchMisc.o \
 BranchRegister.o \
 ByteSwap.o \
 CopyCoder.o \
 CopyRegister.o \
 Deflate64Register.o \
 DeflateDecoder.o \
 DeflateEncoder.o \
 DeflateRegister.o \
 DeltaFilter.o \
 ImplodeDecoder.o \
 ImplodeHuffmanDecoder.o \
 LzOutWindow.o \
 Lzma2Decoder.o \
 Lzma2Encoder.o \
 Lzma2Register.o \
 LzmaDecoder.o \
 LzmaEncoder.o \
 LzmaRegister.o \
 LzxDecoder.o \
 PpmdDecoder.o \
 PpmdEncoder.o \
 PpmdRegister.o \
 PpmdZip.o \
 QuantumDecoder.o \
 ShrinkDecoder.o \
 ZDecoder.o \
 7zAes.o \
 7zAesRegister.o \
 HmacSha1.o \
 MyAes.o \
 MyAesReg.o \
 Pbkdf2HmacSha1.o \
 RandGen.o \
 WzAes.o \
 ZipCrypto.o \
 ZipStrong.o \
 ArchiveCommandLine.o \
 ArchiveExtractCallback.o \
 ArchiveOpenCallback.o \
 Bench.o \
 DefaultName.o \
 EnumDirItems.o \
 Extract.o \
 ExtractingFilePath.o \
 HashCalc.o \
 LoadCodecs.o \
 OpenArchive.o \
 PropIDUtils.o \
 SetProperties.o \
 SortUtils.o \
 TempFiles.o \
 Update.o \
 UpdateAction.o \
 UpdateCallback.o \
 UpdatePair.o \
 UpdateProduce.o \
 BenchCon.o \
 ConsoleClose.o \
 ExtractCallbackConsole.o \
 HashCon.o \
 List.o \
 Main.o \
 MainAr.o \
 OpenCallbackConsole.o \
 PercentPrinter.o \
 UpdateCallbackConsole.o \
 UserInputUtils.o \
 CRC.o \
 CommandLineParser.o \
 CrcReg.o \
 IntToString.o \
 ListFileUtils.o \
 MyString.o \
 MyVector.o \
 MyWindows.o \
 Sha1Reg.o \
 Sha256Reg.o \
 StdInStream.o \
 StdOutStream.o \
 StringConvert.o \
 StringToInt.o \
 UTFConvert.o \
 Wildcard.o \
 XzCrc64Reg.o \
 ErrorMsg.o \
 FileDir.o \
 FileFind.o \
 FileIO.o \
 FileName.o \
 PropVariant.o \
 PropVariantConv.o \
 Synchronization.o \
 System.o \
 TimeUtils.o \
 myAddExeFlag.o \
 mySplitCommandLine.o \
 wine_date_and_time.o \
 $(OBJ_AES) \



# WARNING : automatically generated by utils/generate.py

PROG=../../../../bin/7zr$(BINSUFFIX)

all: $(PCH_NAME) $(PROG)

LOCAL_FLAGS=$(TARGET_FLAGS) \
  -D_FILE_OFFSET_BITS=64 \
  -D_LARGEFILE_SOURCE \
  -D_REENTRANT \
  -DENV_UNIX \
  -D_NO_CRYPTO \
  -DBREAK_HANDLER \
  -DUNICODE \
  -D_UNICODE \
  -DUNIX_USE_WIN_FILE \

SRCS=\
  ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zDecode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zEncode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zExtract.cpp \
  ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandler.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHeader.cpp \
  ../../../../CPP/7zip/Archive/7z/7zIn.cpp \
  ../../../../CPP/7zip/Archive/7z/7zOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zProperties.cpp \
  ../../../../CPP/7zip/Archive/7z/7zRegister.cpp \
  ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp \
  ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp \
  ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp \
  ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp \
  ../../../../CPP/7zip/Archive/Common/MultiStream.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp \
  ../../../../CPP/7zip/Archive/LzmaHandler.cpp \
  ../../../../CPP/7zip/Archive/SplitHandler.cpp \
  ../../../../CPP/7zip/Archive/XzHandler.cpp \
  ../../../../CPP/7zip/Common/CWrappers.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilePathAutoRename.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/InBuffer.cpp \
  ../../../../CPP/7zip/Common/InOutTempBuffer.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MethodId.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/OffsetStream.cpp \
  ../../../../CPP/7zip/Common/OutBuffer.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamBinder.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Common/VirtThread.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Coder.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Register.cpp \
  ../../../../CPP/7zip/Compress/BcjCoder.cpp \
  ../../../../CPP/7zip/Compress/BcjRegister.cpp \
  ../../../../CPP/7zip/Compress/BranchMisc.cpp \
  ../../../../CPP/7zip/Compress/BranchRegister.cpp \
  ../../../../CPP/7zip/Compress/ByteSwap.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/Compress/CopyRegister.cpp \
  ../../../../CPP/7zip/Compress/DeltaFilter.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Register.cpp \
  ../../../../CPP/7zip/Compress/LzmaDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaEncoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaRegister.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp \
  ../../../../CPP/7zip/UI/Common/Bench.cpp \
  ../../../../CPP/7zip/UI/Common/DefaultName.cpp \
  ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp \
  ../../../../CPP/7zip/UI/Common/Extract.cpp \
  ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp \
  ../../../../CPP/7zip/UI/Common/HashCalc.cpp \
  ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp \
  ../../../../CPP/7zip/UI/Common/OpenArchive.cpp \
  ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp \
  ../../../../CPP/7zip/UI/Common/SetProperties.cpp \
  ../../../../CPP/7zip/UI/Common/SortUtils.cpp \
  ../../../../CPP/7zip/UI/Common/TempFiles.cpp \
  ../../../../CPP/7zip/UI/Common/Update.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateAction.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp \
  ../../../../CPP/7zip/UI/Common/UpdatePair.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp \
  ../../../../CPP/7zip/UI/Console/BenchCon.cpp \
  ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp \
  ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/HashCon.cpp \
  ../../../../CPP/7zip/UI/Console/List.cpp \
  ../../../../CPP/7zip/UI/Console/Main.cpp \
  ../../../../CPP/7zip/UI/Console/MainAr.cpp \
  ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp \
  ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CommandLineParser.cpp \
  ../../../../CPP/Common/CrcReg.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/ListFileUtils.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/NewHandler.cpp \
  ../../../../CPP/Common/Sha256Reg.cpp \
  ../../../../CPP/Common/StdInStream.cpp \
  ../../../../CPP/Common/StdOutStream.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Common/XzCrc64Reg.cpp \
  ../../../../CPP/Windows/ErrorMsg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantConv.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/myWindows/myAddExeFlag.cpp \
  ../../../../CPP/myWindows/mySplitCommandLine.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \

SRCS_C=\
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/7zStream.c \
  ../../../../C/Alloc.c \
  ../../../../C/Bcj2.c \
  ../../../../C/Bcj2Enc.c \
  ../../../../C/Bra.c \
  ../../../../C/Bra86.c \
  ../../../../C/BraIA64.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Delta.c \
  ../../../../C/LzFind.c \
  ../../../../C/LzFindMt.c \
  ../../../../C/Lzma2Dec.c \
  ../../../../C/Lzma2Enc.c \
  ../../../../C/LzmaDec.c \
  ../../../../C/LzmaEnc.c \
  ../../../../C/MtCoder.c \
  ../../../../C/Sha256.c \
  ../../../../C/Threads.c \
  ../../../../C/Xz.c \
  ../../../../C/XzCrc64.c \
  ../../../../C/XzCrc64Opt.c \
  ../../../../C/XzDec.c \
  ../../../../C/XzEnc.c \
  ../../../../C/XzIn.c \

StdAfx.h.gch : ../../../myWindows/StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) ../../../myWindows/StdAfx.h -o StdAfx.h.gch
7zCrc.o : ../../../../C/7zCrc.c
	$(CC) $(CFLAGS) ../../../../C/7zCrc.c
7zCrcOpt.o : ../../../../C/7zCrcOpt.c
	$(CC) $(CFLAGS) ../../../../C/7zCrcOpt.c
7zStream.o : ../../../../C/7zStream.c
	$(CC) $(CFLAGS) ../../../../C/7zStream.c
Alloc.o : ../../../../C/Alloc.c
	$(CC) $(CFLAGS) ../../../../C/Alloc.c
Bcj2.o : ../../../../C/Bcj2.c
	$(CC) $(CFLAGS) ../../../../C/Bcj2.c
Bcj2Enc.o : ../../../../C/Bcj2Enc.c
	$(CC) $(CFLAGS) ../../../../C/Bcj2Enc.c
Bra.o : ../../../../C/Bra.c
	$(CC) $(CFLAGS) ../../../../C/Bra.c
Bra86.o : ../../../../C/Bra86.c
	$(CC) $(CFLAGS) ../../../../C/Bra86.c
BraIA64.o : ../../../../C/BraIA64.c
	$(CC) $(CFLAGS) ../../../../C/BraIA64.c
CpuArch.o : ../../../../C/CpuArch.c
	$(CC) $(CFLAGS) ../../../../C/CpuArch.c
Delta.o : ../../../../C/Delta.c
	$(CC) $(CFLAGS) ../../../../C/Delta.c
LzFind.o : ../../../../C/LzFind.c
	$(CC) $(CFLAGS) ../../../../C/LzFind.c
LzFindMt.o : ../../../../C/LzFindMt.c
	$(CC) $(CFLAGS) ../../../../C/LzFindMt.c
Lzma2Dec.o : ../../../../C/Lzma2Dec.c
	$(CC) $(CFLAGS) ../../../../C/Lzma2Dec.c
Lzma2Enc.o : ../../../../C/Lzma2Enc.c
	$(CC) $(CFLAGS) ../../../../C/Lzma2Enc.c
LzmaDec.o : ../../../../C/LzmaDec.c
	$(CC) $(CFLAGS) ../../../../C/LzmaDec.c
LzmaEnc.o : ../../../../C/LzmaEnc.c
	$(CC) $(CFLAGS) ../../../../C/LzmaEnc.c
MtCoder.o : ../../../../C/MtCoder.c
	$(CC) $(CFLAGS) ../../../../C/MtCoder.c
Sha256.o : ../../../../C/Sha256.c
	$(CC) $(CFLAGS) ../../../../C/Sha256.c
Threads.o : ../../../../C/Threads.c
	$(CC) $(CFLAGS) ../../../../C/Threads.c
Xz.o : ../../../../C/Xz.c
	$(CC) $(CFLAGS) ../../../../C/Xz.c
XzCrc64.o : ../../../../C/XzCrc64.c
	$(CC) $(CFLAGS) ../../../../C/XzCrc64.c
XzCrc64Opt.o : ../../../../C/XzCrc64Opt.c
	$(CC) $(CFLAGS) ../../../../C/XzCrc64Opt.c
XzDec.o : ../../../../C/XzDec.c
	$(CC) $(CFLAGS) ../../../../C/XzDec.c
XzEnc.o : ../../../../C/XzEnc.c
	$(CC) $(CFLAGS) ../../../../C/XzEnc.c
XzIn.o : ../../../../C/XzIn.c
	$(CC) $(CFLAGS) ../../../../C/XzIn.c
7zCompressionMode.o : ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp
7zDecode.o : ../../../../CPP/7zip/Archive/7z/7zDecode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zDecode.cpp
7zEncode.o : ../../../../CPP/7zip/Archive/7z/7zEncode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zEncode.cpp
7zExtract.o : ../../../../CPP/7zip/Archive/7z/7zExtract.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zExtract.cpp
7zFolderInStream.o : ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp
7zHandler.o : ../../../../CPP/7zip/Archive/7z/7zHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHandler.cpp
7zHandlerOut.o : ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp
7zHeader.o : ../../../../CPP/7zip/Archive/7z/7zHeader.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHeader.cpp
7zIn.o : ../../../../CPP/7zip/Archive/7z/7zIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zIn.cpp
7zOut.o : ../../../../CPP/7zip/Archive/7z/7zOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zOut.cpp
7zProperties.o : ../../../../CPP/7zip/Archive/7z/7zProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zProperties.cpp
7zRegister.o : ../../../../CPP/7zip/Archive/7z/7zRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zRegister.cpp
7zSpecStream.o : ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp
7zUpdate.o : ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp
CoderMixer2.o : ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp
DummyOutStream.o : ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp
HandlerOut.o : ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp
InStreamWithCRC.o : ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp
ItemNameUtils.o : ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp
MultiStream.o : ../../../../CPP/7zip/Archive/Common/MultiStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/MultiStream.cpp
OutStreamWithCRC.o : ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
ParseProperties.o : ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp
LzmaHandler.o : ../../../../CPP/7zip/Archive/LzmaHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/LzmaHandler.cpp
SplitHandler.o : ../../../../CPP/7zip/Archive/SplitHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/SplitHandler.cpp
XzHandler.o : ../../../../CPP/7zip/Archive/XzHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/XzHandler.cpp
CWrappers.o : ../../../../CPP/7zip/Common/CWrappers.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CWrappers.cpp
CreateCoder.o : ../../../../CPP/7zip/Common/CreateCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CreateCoder.cpp
FilePathAutoRename.o : ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
FileStreams.o : ../../../../CPP/7zip/Common/FileStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FileStreams.cpp
FilterCoder.o : ../../../../CPP/7zip/Common/FilterCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilterCoder.cpp
InBuffer.o : ../../../../CPP/7zip/Common/InBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/InBuffer.cpp
InOutTempBuffer.o : ../../../../CPP/7zip/Common/InOutTempBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/InOutTempBuffer.cpp
LimitedStreams.o : ../../../../CPP/7zip/Common/LimitedStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/LimitedStreams.cpp
MethodId.o : ../../../../CPP/7zip/Common/MethodId.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MethodId.cpp
MethodProps.o : ../../../../CPP/7zip/Common/MethodProps.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MethodProps.cpp
OffsetStream.o : ../../../../CPP/7zip/Common/OffsetStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OffsetStream.cpp
OutBuffer.o : ../../../../CPP/7zip/Common/OutBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OutBuffer.cpp
ProgressUtils.o : ../../../../CPP/7zip/Common/ProgressUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/ProgressUtils.cpp
PropId.o : ../../../../CPP/7zip/Common/PropId.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/PropId.cpp
StreamBinder.o : ../../../../CPP/7zip/Common/StreamBinder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamBinder.cpp
StreamObjects.o : ../../../../CPP/7zip/Common/StreamObjects.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamObjects.cpp
StreamUtils.o : ../../../../CPP/7zip/Common/StreamUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamUtils.cpp
UniqBlocks.o : ../../../../CPP/7zip/Common/UniqBlocks.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/UniqBlocks.cpp
VirtThread.o : ../../../../CPP/7zip/Common/VirtThread.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/VirtThread.cpp
Bcj2Coder.o : ../../../../CPP/7zip/Compress/Bcj2Coder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Bcj2Coder.cpp
Bcj2Register.o : ../../../../CPP/7zip/Compress/Bcj2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Bcj2Register.cpp
BcjCoder.o : ../../../../CPP/7zip/Compress/BcjCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BcjCoder.cpp
BcjRegister.o : ../../../../CPP/7zip/Compress/BcjRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BcjRegister.cpp
BranchMisc.o : ../../../../CPP/7zip/Compress/BranchMisc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BranchMisc.cpp
BranchRegister.o : ../../../../CPP/7zip/Compress/BranchRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BranchRegister.cpp
ByteSwap.o : ../../../../CPP/7zip/Compress/ByteSwap.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ByteSwap.cpp
CopyCoder.o : ../../../../CPP/7zip/Compress/CopyCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyCoder.cpp
CopyRegister.o : ../../../../CPP/7zip/Compress/CopyRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyRegister.cpp
DeltaFilter.o : ../../../../CPP/7zip/Compress/DeltaFilter.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeltaFilter.cpp
Lzma2Decoder.o : ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp
Lzma2Encoder.o : ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp
Lzma2Register.o : ../../../../CPP/7zip/Compress/Lzma2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Register.cpp
LzmaDecoder.o : ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
LzmaEncoder.o : ../../../../CPP/7zip/Compress/LzmaEncoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaEncoder.cpp
LzmaRegister.o : ../../../../CPP/7zip/Compress/LzmaRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaRegister.cpp
ArchiveCommandLine.o : ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp
ArchiveExtractCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
ArchiveOpenCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
Bench.o : ../../../../CPP/7zip/UI/Common/Bench.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Bench.cpp
DefaultName.o : ../../../../CPP/7zip/UI/Common/DefaultName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/DefaultName.cpp
EnumDirItems.o : ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp
Extract.o : ../../../../CPP/7zip/UI/Common/Extract.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Extract.cpp
ExtractingFilePath.o : ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
HashCalc.o : ../../../../CPP/7zip/UI/Common/HashCalc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/HashCalc.cpp
LoadCodecs.o : ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
OpenArchive.o : ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
PropIDUtils.o : ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
SetProperties.o : ../../../../CPP/7zip/UI/Common/SetProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/SetProperties.cpp
SortUtils.o : ../../../../CPP/7zip/UI/Common/SortUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/SortUtils.cpp
TempFiles.o : ../../../../CPP/7zip/UI/Common/TempFiles.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/TempFiles.cpp
Update.o : ../../../../CPP/7zip/UI/Common/Update.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Update.cpp
UpdateAction.o : ../../../../CPP/7zip/UI/Common/UpdateAction.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateAction.cpp
UpdateCallback.o : ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp
UpdatePair.o : ../../../../CPP/7zip/UI/Common/UpdatePair.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdatePair.cpp
UpdateProduce.o : ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp
BenchCon.o : ../../../../CPP/7zip/UI/Console/BenchCon.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/BenchCon.cpp
ConsoleClose.o : ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp
ExtractCallbackConsole.o : ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp
HashCon.o : ../../../../CPP/7zip/UI/Console/HashCon.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/HashCon.cpp
List.o : ../../../../CPP/7zip/UI/Console/List.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/List.cpp
Main.o : ../../../../CPP/7zip/UI/Console/Main.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/Main.cpp
MainAr.o : ../../../../CPP/7zip/UI/Console/MainAr.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/MainAr.cpp
OpenCallbackConsole.o : ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp
PercentPrinter.o : ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp
UpdateCallbackConsole.o : ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp
UserInputUtils.o : ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp
CRC.o : ../../../../CPP/Common/CRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CRC.cpp
CommandLineParser.o : ../../../../CPP/Common/CommandLineParser.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CommandLineParser.cpp
CrcReg.o : ../../../../CPP/Common/CrcReg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CrcReg.cpp
IntToString.o : ../../../../CPP/Common/IntToString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/IntToString.cpp
ListFileUtils.o : ../../../../CPP/Common/ListFileUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/ListFileUtils.cpp
MyString.o : ../../../../CPP/Common/MyString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyString.cpp
MyVector.o : ../../../../CPP/Common/MyVector.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyVector.cpp
MyWindows.o : ../../../../CPP/Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyWindows.cpp
NewHandler.o : ../../../../CPP/Common/NewHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/NewHandler.cpp
Sha256Reg.o : ../../../../CPP/Common/Sha256Reg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Sha256Reg.cpp
StdInStream.o : ../../../../CPP/Common/StdInStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StdInStream.cpp
StdOutStream.o : ../../../../CPP/Common/StdOutStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StdOutStream.cpp
StringConvert.o : ../../../../CPP/Common/StringConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringConvert.cpp
StringToInt.o : ../../../../CPP/Common/StringToInt.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringToInt.cpp
UTFConvert.o : ../../../../CPP/Common/UTFConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/UTFConvert.cpp
Wildcard.o : ../../../../CPP/Common/Wildcard.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Wildcard.cpp
XzCrc64Reg.o : ../../../../CPP/Common/XzCrc64Reg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/XzCrc64Reg.cpp
ErrorMsg.o : ../../../../CPP/Windows/ErrorMsg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/ErrorMsg.cpp
FileDir.o : ../../../../CPP/Windows/FileDir.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileDir.cpp
FileFind.o : ../../../../CPP/Windows/FileFind.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileFind.cpp
FileIO.o : ../../../../CPP/Windows/FileIO.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileIO.cpp
FileName.o : ../../../../CPP/Windows/FileName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileName.cpp
PropVariant.o : ../../../../CPP/Windows/PropVariant.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariant.cpp
PropVariantConv.o : ../../../../CPP/Windows/PropVariantConv.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariantConv.cpp
Synchronization.o : ../../../../CPP/Windows/Synchronization.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Synchronization.cpp
System.o : ../../../../CPP/Windows/System.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/System.cpp
TimeUtils.o : ../../../../CPP/Windows/TimeUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/TimeUtils.cpp
myAddExeFlag.o : ../../../../CPP/myWindows/myAddExeFlag.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/myAddExeFlag.cpp
mySplitCommandLine.o : ../../../../CPP/myWindows/mySplitCommandLine.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/mySplitCommandLine.cpp
wine_date_and_time.o : ../../../../CPP/myWindows/wine_date_and_time.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_date_and_time.cpp

OBJS=\
 7zCrc.o \
 $(OBJ_CRC32) \
 7zStream.o \
 Alloc.o \
 Bcj2.o \
 Bcj2Enc.o \
 Bra.o \
 Bra86.o \
 BraIA64.o \
 CpuArch.o \
 Delta.o \
 LzFind.o \
 LzFindMt.o \
 Lzma2Dec.o \
 Lzma2Enc.o \
 LzmaDec.o \
 LzmaEnc.o \
 MtCoder.o \
 Sha256.o \
 Threads.o \
 Xz.o \
 XzCrc64.o \
 XzCrc64Opt.o \
 XzDec.o \
 XzEnc.o \
 XzIn.o \
 7zCompressionMode.o \
 7zDecode.o \
 7zEncode.o \
 7zExtract.o \
 7zFolderInStream.o \
 7zHandler.o \
 7zHandlerOut.o \
 7zHeader.o \
 7zIn.o \
 7zOut.o \
 7zProperties.o \
 7zRegister.o \
 7zSpecStream.o \
 7zUpdate.o \
 CoderMixer2.o \
 DummyOutStream.o \
 HandlerOut.o \
 InStreamWithCRC.o \
 ItemNameUtils.o \
 MultiStream.o \
 OutStreamWithCRC.o \
 ParseProperties.o \
 LzmaHandler.o \
 SplitHandler.o \
 XzHandler.o \
 CWrappers.o \
 CreateCoder.o \
 FilePathAutoRename.o \
 FileStreams.o \
 FilterCoder.o \
 InBuffer.o \
 InOutTempBuffer.o \
 LimitedStreams.o \
 MethodId.o \
 MethodProps.o \
 OffsetStream.o \
 OutBuffer.o \
 ProgressUtils.o \
 PropId.o \
 StreamBinder.o \
 StreamObjects.o \
 StreamUtils.o \
 UniqBlocks.o \
 VirtThread.o \
 Bcj2Coder.o \
 Bcj2Register.o \
 BcjCoder.o \
 BcjRegister.o \
 BranchMisc.o \
 BranchRegister.o \
 ByteSwap.o \
 CopyCoder.o \
 CopyRegister.o \
 DeltaFilter.o \
 Lzma2Decoder.o \
 Lzma2Encoder.o \
 Lzma2Register.o \
 LzmaDecoder.o \
 LzmaEncoder.o \
 LzmaRegister.o \
 ArchiveCommandLine.o \
 ArchiveExtractCallback.o \
 ArchiveOpenCallback.o \
 Bench.o \
 DefaultName.o \
 EnumDirItems.o \
 Extract.o \
 ExtractingFilePath.o \
 HashCalc.o \
 LoadCodecs.o \
 OpenArchive.o \
 PropIDUtils.o \
 SetProperties.o \
 SortUtils.o \
 TempFiles.o \
 Update.o \
 UpdateAction.o \
 UpdateCallback.o \
 UpdatePair.o \
 UpdateProduce.o \
 BenchCon.o \
 ConsoleClose.o \
 ExtractCallbackConsole.o \
 HashCon.o \
 List.o \
 Main.o \
 MainAr.o \
 OpenCallbackConsole.o \
 PercentPrinter.o \
 UpdateCallbackConsole.o \
 UserInputUtils.o \
 CRC.o \
 CommandLineParser.o \
 CrcReg.o \
 IntToString.o \
 ListFileUtils.o \
 MyString.o \
 MyVector.o \
 MyWindows.o \
 NewHandler.o \
 Sha256Reg.o \
 StdInStream.o \
 StdOutStream.o \
 StringConvert.o \
 StringToInt.o \
 UTFConvert.o \
 Wildcard.o \
 XzCrc64Reg.o \
 ErrorMsg.o \
 FileDir.o \
 FileFind.o \
 FileIO.o \
 FileName.o \
 PropVariant.o \
 PropVariantConv.o \
 Synchronization.o \
 System.o \
 TimeUtils.o \
 myAddExeFlag.o \
 mySplitCommandLine.o \
 wine_date_and_time.o \
 $(OBJ_AES) \


# gcov *.c *.cpp

#  -fprofile-arcs -ftest-coverage

# gprof
# Compiling a Program for Profiling : -pg
# Once the program is compiled for profiling, you must run it in order to generate the information that gprof needs
# gprof 7za.exe > gprof.output



#  Profile guided optimization with gcc
#  ======================================
#  Compile all code with -fprofile-generate in {C|CXX|LD}FLAGS  : -fprofile-generate
#  Run the binary
#  Run your application/benchmark against that binary
#  Recompile all code with -fprofile-use (above steps will place lots of .gcda files in source tree)

LOCAL_FLAGS=\
  -pg -g2 \
  -DBREAK_HANDLER \
  -DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE \
	-I../../Archive \
	-I../../Archive/7z \
	-I../../Archive/BZip2 \
	-I../../Archive/Common \
	-I../../Archive/GZip \
	-I../../Archive/Cab \
	-I../../Archive/Lzma \
	-I../../Archive/Tar \
	-I../../Archive/Zip \
	-I../../Archive/Split \
	-I../../Archive/Z \
	-I../../Compress \
       	-I../../Crypto \
	-I../../UI/Console \
	-I../../UI/Common \
	-I../../../Windows \
	-I../../../Common \
	-I../../../7zip/Common \
	-I../../../../C \
-I../../../myWindows \
-I../../../ \
-I../../../include_windows

include ../../../../makefile.machine

SRCS=\
  ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zDecode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zEncode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zExtract.cpp \
  ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zFolderOutStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandler.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHeader.cpp \
  ../../../../CPP/7zip/Archive/7z/7zIn.cpp \
  ../../../../CPP/7zip/Archive/7z/7zOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zProperties.cpp \
  ../../../../CPP/7zip/Archive/7z/7zRegister.cpp \
  ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp \
  ../../../../CPP/7zip/Archive/Bz2Handler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHandler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHeader.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabIn.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabRegister.cpp \
  ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp \
  ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp \
  ../../../../CPP/7zip/Archive/Common/FindSignature.cpp \
  ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp \
  ../../../../CPP/7zip/Archive/Common/MultiStream.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp \
  ../../../../CPP/7zip/Archive/DeflateProps.cpp \
  ../../../../CPP/7zip/Archive/GzHandler.cpp \
  ../../../../CPP/7zip/Archive/LzmaHandler.cpp \
  ../../../../CPP/7zip/Archive/PpmdHandler.cpp \
  ../../../../CPP/7zip/Archive/SplitHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHeader.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarIn.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarRegister.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp \
  ../../../../CPP/7zip/Archive/XzHandler.cpp \
  ../../../../CPP/7zip/Archive/ZHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipIn.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipItem.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp \
  ../../../../CPP/7zip/Common/CWrappers.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilePathAutoRename.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/InBuffer.cpp \
  ../../../../CPP/7zip/Common/InOutTempBuffer.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MemBlocks.cpp \
  ../../../../CPP/7zip/Common/MethodId.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/OffsetStream.cpp \
  ../../../../CPP/7zip/Common/OutBuffer.cpp \
  ../../../../CPP/7zip/Common/OutMemStream.cpp \
  ../../../../CPP/7zip/Common/ProgressMt.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamBinder.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Common/VirtThread.cpp \
  ../../../../CPP/7zip/Compress/BZip2Crc.cpp \
  ../../../../CPP/7zip/Compress/BZip2Decoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Encoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Register.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Coder.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Register.cpp \
  ../../../../CPP/7zip/Compress/BcjCoder.cpp \
  ../../../../CPP/7zip/Compress/BcjRegister.cpp \
  ../../../../CPP/7zip/Compress/BitlDecoder.cpp \
  ../../../../CPP/7zip/Compress/BranchMisc.cpp \
  ../../../../CPP/7zip/Compress/BranchRegister.cpp \
  ../../../../CPP/7zip/Compress/ByteSwap.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/Compress/CopyRegister.cpp \
  ../../../../CPP/7zip/Compress/Deflate64Register.cpp \
  ../../../../CPP/7zip/Compress/DeflateDecoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateEncoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateRegister.cpp \
  ../../../../CPP/7zip/Compress/DeltaFilter.cpp \
  ../../../../CPP/7zip/Compress/ImplodeDecoder.cpp \
  ../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzOutWindow.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Register.cpp \
  ../../../../CPP/7zip/Compress/LzmaDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaEncoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaRegister.cpp \
  ../../../../CPP/7zip/Compress/LzxDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdEncoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdRegister.cpp \
  ../../../../CPP/7zip/Compress/PpmdZip.cpp \
  ../../../../CPP/7zip/Compress/QuantumDecoder.cpp \
  ../../../../CPP/7zip/Compress/ShrinkDecoder.cpp \
  ../../../../CPP/7zip/Compress/ZDecoder.cpp \
  ../../../../CPP/7zip/Crypto/7zAes.cpp \
  ../../../../CPP/7zip/Crypto/7zAesRegister.cpp \
  ../../../../CPP/7zip/Crypto/HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/MyAes.cpp \
  ../../../../CPP/7zip/Crypto/MyAesReg.cpp \
  ../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/RandGen.cpp \
  ../../../../CPP/7zip/Crypto/WzAes.cpp \
  ../../../../CPP/7zip/Crypto/ZipCrypto.cpp \
  ../../../../CPP/7zip/Crypto/ZipStrong.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp \
  ../../../../CPP/7zip/UI/Common/Bench.cpp \
  ../../../../CPP/7zip/UI/Common/DefaultName.cpp \
  ../../../../CPP/7zip/UI/Common/EnumDirItems.cpp \
  ../../../../CPP/7zip/UI/Common/Extract.cpp \
  ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp \
  ../../../../CPP/7zip/UI/Common/HashCalc.cpp \
  ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp \
  ../../../../CPP/7zip/UI/Common/OpenArchive.cpp \
  ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp \
  ../../../../CPP/7zip/UI/Common/SetProperties.cpp \
  ../../../../CPP/7zip/UI/Common/SortUtils.cpp \
  ../../../../CPP/7zip/UI/Common/TempFiles.cpp \
  ../../../../CPP/7zip/UI/Common/Update.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateAction.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateCallback.cpp \
  ../../../../CPP/7zip/UI/Common/UpdatePair.cpp \
  ../../../../CPP/7zip/UI/Common/UpdateProduce.cpp \
  ../../../../CPP/7zip/UI/Console/BenchCon.cpp \
  ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp \
  ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/HashCon.cpp \
  ../../../../CPP/7zip/UI/Console/List.cpp \
  ../../../../CPP/7zip/UI/Console/Main.cpp \
  ../../../../CPP/7zip/UI/Console/MainAr.cpp \
  ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp \
  ../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CommandLineParser.cpp \
  ../../../../CPP/Common/CrcReg.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/ListFileUtils.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/Sha1Reg.cpp \
  ../../../../CPP/Common/Sha256Reg.cpp \
  ../../../../CPP/Common/StdInStream.cpp \
  ../../../../CPP/Common/StdOutStream.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Common/XzCrc64Reg.cpp \
  ../../../../CPP/Windows/DLL.cpp \
  ../../../../CPP/Windows/ErrorMsg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantConv.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/myWindows/myAddExeFlag.cpp \
  ../../../../CPP/myWindows/mySplitCommandLine.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \

SRCS_C=\
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/7zStream.c \
  ../../../../C/Aes.c \
  ../../../../C/Alloc.c \
  ../../../../C/Bcj2.c \
  ../../../../C/Bcj2Enc.c \
  ../../../../C/Bra.c \
  ../../../../C/Bra86.c \
  ../../../../C/BraIA64.c \
  ../../../../C/BwtSort.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Delta.c \
  ../../../../C/HuffEnc.c \
  ../../../../C/LzFind.c \
  ../../../../C/LzFindMt.c \
  ../../../../C/Lzma2Dec.c \
  ../../../../C/Lzma2Enc.c \
  ../../../../C/LzmaDec.c \
  ../../../../C/LzmaEnc.c \
  ../../../../C/MtCoder.c \
  ../../../../C/Ppmd7.c \
  ../../../../C/Ppmd7Dec.c \
  ../../../../C/Ppmd7Enc.c \
  ../../../../C/Ppmd8.c \
  ../../../../C/Ppmd8Dec.c \
  ../../../../C/Ppmd8Enc.c \
  ../../../../C/Sha1.c \
  ../../../../C/Sha256.c \
  ../../../../C/Sort.c \
  ../../../../C/Threads.c \
  ../../../../C/Xz.c \
  ../../../../C/XzCrc64.c \
  ../../../../C/XzCrc64Opt.c \
  ../../../../C/XzDec.c \
  ../../../../C/XzEnc.c \
  ../../../../C/XzIn.c \

all : copy 7za.exe
	
7za.exe:
	$(CXX) $(LOCAL_FLAGS) -c *.cpp 
	$(CC)  $(LOCAL_FLAGS) -c *.c
	$(CXX) $(LOCAL_FLAGS) *.o -o 7za.exe $(LOCAL_LIBS_DLL)
	ld -r *.o -o  7za.ld
	nm -u -C 7za.ld > 7za.undefined
copy:
	rm -f *.cpp *.c
	cp -p $(SRCS) $(SRCS_C) .

clean:
	rm -f 7za.exe 7za.ld 7za.undefined *.cpp *.c *.gcov *.gcda *.gcno *.o core *~ gmon*  gprof.output


TARGET_FLAGS=$(CC_SHARED) -DRegisterArc=DllRegisterArc -DRegisterCodec=DllRegisterCodec

include ../../../../makefile.crc32
include ../../../../makefile.machine

LOCAL_LINK=$(LINK_SHARED)
LIBS=$(LOCAL_LIBS_DLL)

include ../../../../makefile.glb



# WARNING : automatically generated by utils/generate.py

PROG=../../../../bin/7z.so

all: $(PCH_NAME) $(PROG)

LOCAL_FLAGS=$(TARGET_FLAGS) \
  -DEXTERNAL_CODECS \
  -D_FILE_OFFSET_BITS=64 \
  -D_LARGEFILE_SOURCE \
  -D_REENTRANT \
  -DENV_UNIX \
  -DBREAK_HANDLER \
  -DUNICODE \
  -D_UNICODE \
  -DUNIX_USE_WIN_FILE \

SRCS=\
  ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zDecode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zEncode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zExtract.cpp \
  ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandler.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHeader.cpp \
  ../../../../CPP/7zip/Archive/7z/7zIn.cpp \
  ../../../../CPP/7zip/Archive/7z/7zOut.cpp \
  ../../../../CPP/7zip/Archive/7z/7zProperties.cpp \
  ../../../../CPP/7zip/Archive/7z/7zRegister.cpp \
  ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp \
  ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp \
  ../../../../CPP/7zip/Archive/ApmHandler.cpp \
  ../../../../CPP/7zip/Archive/ArHandler.cpp \
  ../../../../CPP/7zip/Archive/ArchiveExports.cpp \
  ../../../../CPP/7zip/Archive/ArjHandler.cpp \
  ../../../../CPP/7zip/Archive/Bz2Handler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHandler.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabHeader.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabIn.cpp \
  ../../../../CPP/7zip/Archive/Cab/CabRegister.cpp \
  ../../../../CPP/7zip/Archive/Chm/ChmHandler.cpp \
  ../../../../CPP/7zip/Archive/Chm/ChmIn.cpp \
  ../../../../CPP/7zip/Archive/ComHandler.cpp \
  ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp \
  ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp \
  ../../../../CPP/7zip/Archive/Common/FindSignature.cpp \
  ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp \
  ../../../../CPP/7zip/Archive/Common/MultiStream.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithSha1.cpp \
  ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp \
  ../../../../CPP/7zip/Archive/CpioHandler.cpp \
  ../../../../CPP/7zip/Archive/CramfsHandler.cpp \
  ../../../../CPP/7zip/Archive/DeflateProps.cpp \
  ../../../../CPP/7zip/Archive/DllExports2.cpp \
  ../../../../CPP/7zip/Archive/DmgHandler.cpp \
  ../../../../CPP/7zip/Archive/ElfHandler.cpp \
  ../../../../CPP/7zip/Archive/ExtHandler.cpp \
  ../../../../CPP/7zip/Archive/FatHandler.cpp \
  ../../../../CPP/7zip/Archive/FlvHandler.cpp \
  ../../../../CPP/7zip/Archive/GzHandler.cpp \
  ../../../../CPP/7zip/Archive/GptHandler.cpp \
  ../../../../CPP/7zip/Archive/HandlerCont.cpp \
  ../../../../CPP/7zip/Archive/HfsHandler.cpp \
  ../../../../CPP/7zip/Archive/IhexHandler.cpp \
  ../../../../CPP/7zip/Archive/Iso/IsoHandler.cpp \
  ../../../../CPP/7zip/Archive/Iso/IsoHeader.cpp \
  ../../../../CPP/7zip/Archive/Iso/IsoIn.cpp \
  ../../../../CPP/7zip/Archive/Iso/IsoRegister.cpp \
  ../../../../CPP/7zip/Archive/LzhHandler.cpp \
  ../../../../CPP/7zip/Archive/LzmaHandler.cpp \
  ../../../../CPP/7zip/Archive/MachoHandler.cpp \
  ../../../../CPP/7zip/Archive/MbrHandler.cpp \
  ../../../../CPP/7zip/Archive/MslzHandler.cpp \
  ../../../../CPP/7zip/Archive/MubHandler.cpp \
  ../../../../CPP/7zip/Archive/Nsis/NsisDecode.cpp \
  ../../../../CPP/7zip/Archive/Nsis/NsisHandler.cpp \
  ../../../../CPP/7zip/Archive/Nsis/NsisIn.cpp \
  ../../../../CPP/7zip/Archive/Nsis/NsisRegister.cpp \
  ../../../../CPP/7zip/Archive/NtfsHandler.cpp \
  ../../../../CPP/7zip/Archive/PeHandler.cpp \
  ../../../../CPP/7zip/Archive/PpmdHandler.cpp \
  ../../../../CPP/7zip/Archive/QcowHandler.cpp \
  ../../../../CPP/7zip/Archive/Rar/RarHandler.cpp \
  ../../../../CPP/7zip/Archive/Rar/Rar5Handler.cpp \
  ../../../../CPP/7zip/Archive/RpmHandler.cpp \
  ../../../../CPP/7zip/Archive/SplitHandler.cpp \
  ../../../../CPP/7zip/Archive/SquashfsHandler.cpp \
  ../../../../CPP/7zip/Archive/SwfHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandler.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarHeader.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarIn.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarOut.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarRegister.cpp \
  ../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp \
  ../../../../CPP/7zip/Archive/Udf/UdfHandler.cpp \
  ../../../../CPP/7zip/Archive/Udf/UdfIn.cpp \
  ../../../../CPP/7zip/Archive/UefiHandler.cpp \
  ../../../../CPP/7zip/Archive/VdiHandler.cpp \
  ../../../../CPP/7zip/Archive/VhdHandler.cpp \
  ../../../../CPP/7zip/Archive/VmdkHandler.cpp \
  ../../../../CPP/7zip/Archive/Wim/WimHandler.cpp \
  ../../../../CPP/7zip/Archive/Wim/WimHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Wim/WimIn.cpp \
  ../../../../CPP/7zip/Archive/Wim/WimRegister.cpp \
  ../../../../CPP/7zip/Archive/XarHandler.cpp \
  ../../../../CPP/7zip/Archive/XzHandler.cpp \
  ../../../../CPP/7zip/Archive/ZHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipIn.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipItem.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipOut.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp \
  ../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp \
  ../../../../CPP/7zip/Common/CWrappers.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/InBuffer.cpp \
  ../../../../CPP/7zip/Common/InOutTempBuffer.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/MemBlocks.cpp \
  ../../../../CPP/7zip/Common/MethodId.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/OffsetStream.cpp \
  ../../../../CPP/7zip/Common/OutBuffer.cpp \
  ../../../../CPP/7zip/Common/OutMemStream.cpp \
  ../../../../CPP/7zip/Common/ProgressMt.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/PropId.cpp \
  ../../../../CPP/7zip/Common/StreamBinder.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/UniqBlocks.cpp \
  ../../../../CPP/7zip/Common/VirtThread.cpp \
  ../../../../CPP/7zip/Compress/BZip2Crc.cpp \
  ../../../../CPP/7zip/Compress/BZip2Decoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Encoder.cpp \
  ../../../../CPP/7zip/Compress/BZip2Register.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Coder.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Register.cpp \
  ../../../../CPP/7zip/Compress/BcjCoder.cpp \
  ../../../../CPP/7zip/Compress/BcjRegister.cpp \
  ../../../../CPP/7zip/Compress/BitlDecoder.cpp \
  ../../../../CPP/7zip/Compress/BranchMisc.cpp \
  ../../../../CPP/7zip/Compress/BranchRegister.cpp \
  ../../../../CPP/7zip/Compress/ByteSwap.cpp \
  ../../../../CPP/7zip/Compress/CodecExports.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/Compress/CopyRegister.cpp \
  ../../../../CPP/7zip/Compress/Deflate64Register.cpp \
  ../../../../CPP/7zip/Compress/DeflateDecoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateEncoder.cpp \
  ../../../../CPP/7zip/Compress/DeflateRegister.cpp \
  ../../../../CPP/7zip/Compress/DeltaFilter.cpp \
  ../../../../CPP/7zip/Compress/ImplodeDecoder.cpp \
  ../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzOutWindow.cpp \
  ../../../../CPP/7zip/Compress/LzhDecoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Register.cpp \
  ../../../../CPP/7zip/Compress/LzmaDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaEncoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaRegister.cpp \
  ../../../../CPP/7zip/Compress/LzmsDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzxDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdEncoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdRegister.cpp \
  ../../../../CPP/7zip/Compress/PpmdZip.cpp \
  ../../../../CPP/7zip/Compress/QuantumDecoder.cpp \
  ../../../../CPP/7zip/Compress/ShrinkDecoder.cpp \
  ../../../../CPP/7zip/Compress/ZDecoder.cpp \
  ../../../../CPP/7zip/Compress/XpressDecoder.cpp \
  ../../../../CPP/7zip/Compress/ZlibDecoder.cpp \
  ../../../../CPP/7zip/Compress/ZlibEncoder.cpp \
  ../../../../CPP/7zip/Crypto/7zAes.cpp \
  ../../../../CPP/7zip/Crypto/7zAesRegister.cpp \
  ../../../../CPP/7zip/Crypto/HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/HmacSha256.cpp \
  ../../../../CPP/7zip/Crypto/MyAes.cpp \
  ../../../../CPP/7zip/Crypto/MyAesReg.cpp \
  ../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp \
  ../../../../CPP/7zip/Crypto/RandGen.cpp \
  ../../../../CPP/7zip/Crypto/Rar20Crypto.cpp \
  ../../../../CPP/7zip/Crypto/Rar5Aes.cpp \
  ../../../../CPP/7zip/Crypto/RarAes.cpp \
  ../../../../CPP/7zip/Crypto/WzAes.cpp \
  ../../../../CPP/7zip/Crypto/ZipCrypto.cpp \
  ../../../../CPP/7zip/Crypto/ZipStrong.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CrcReg.cpp \
  ../../../../CPP/Common/DynLimBuf.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/MyMap.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/MyXml.cpp \
  ../../../../CPP/Common/NewHandler.cpp \
  ../../../../CPP/Common/Sha1Reg.cpp \
  ../../../../CPP/Common/Sha256Reg.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Common/XzCrc64Reg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantUtils.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/Windows/TimeUtils.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \

SRCS_C=\
  ../../../../C/7zBuf2.c \
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/7zStream.c \
  ../../../../C/Aes.c \
  ../../../../C/Alloc.c \
  ../../../../C/Bcj2.c \
  ../../../../C/Bcj2Enc.c \
  ../../../../C/Blake2s.c \
  ../../../../C/Bra.c \
  ../../../../C/Bra86.c \
  ../../../../C/BraIA64.c \
  ../../../../C/BwtSort.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Delta.c \
  ../../../../C/HuffEnc.c \
  ../../../../C/LzFind.c \
  ../../../../C/LzFindMt.c \
  ../../../../C/Lzma2Dec.c \
  ../../../../C/Lzma2Enc.c \
  ../../../../C/LzmaDec.c \
  ../../../../C/LzmaEnc.c \
  ../../../../C/MtCoder.c \
  ../../../../C/Ppmd7.c \
  ../../../../C/Ppmd7Dec.c \
  ../../../../C/Ppmd7Enc.c \
  ../../../../C/Ppmd8.c \
  ../../../../C/Ppmd8Dec.c \
  ../../../../C/Ppmd8Enc.c \
  ../../../../C/Sha1.c \
  ../../../../C/Sha256.c \
  ../../../../C/Sort.c \
  ../../../../C/Threads.c \
  ../../../../C/Xz.c \
  ../../../../C/XzCrc64.c \
  ../../../../C/XzCrc64Opt.c \
  ../../../../C/XzDec.c \
  ../../../../C/XzEnc.c \
  ../../../../C/XzIn.c \

StdAfx.h.gch : ../../../myWindows/StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) ../../../myWindows/StdAfx.h -o StdAfx.h.gch
7zBuf2.o : ../../../../C/7zBuf2.c
	$(CC) $(CFLAGS) ../../../../C/7zBuf2.c
7zCrc.o : ../../../../C/7zCrc.c
	$(CC) $(CFLAGS) ../../../../C/7zCrc.c
7zCrcOpt.o : ../../../../C/7zCrcOpt.c
	$(CC) $(CFLAGS) ../../../../C/7zCrcOpt.c
7zStream.o : ../../../../C/7zStream.c
	$(CC) $(CFLAGS) ../../../../C/7zStream.c
Aes.o : ../../../../C/Aes.c
	$(CC) $(CFLAGS) ../../../../C/Aes.c
Alloc.o : ../../../../C/Alloc.c
	$(CC) $(CFLAGS) ../../../../C/Alloc.c
Bcj2.o : ../../../../C/Bcj2.c
	$(CC) $(CFLAGS) ../../../../C/Bcj2.c
Bcj2Enc.o : ../../../../C/Bcj2Enc.c
	$(CC) $(CFLAGS) ../../../../C/Bcj2Enc.c
Blake2s.o : ../../../../C/Blake2s.c
	$(CC) $(CFLAGS) ../../../../C/Blake2s.c
Bra.o : ../../../../C/Bra.c
	$(CC) $(CFLAGS) ../../../../C/Bra.c
Bra86.o : ../../../../C/Bra86.c
	$(CC) $(CFLAGS) ../../../../C/Bra86.c
BraIA64.o : ../../../../C/BraIA64.c
	$(CC) $(CFLAGS) ../../../../C/BraIA64.c
BwtSort.o : ../../../../C/BwtSort.c
	$(CC) $(CFLAGS) ../../../../C/BwtSort.c
CpuArch.o : ../../../../C/CpuArch.c
	$(CC) $(CFLAGS) ../../../../C/CpuArch.c
Delta.o : ../../../../C/Delta.c
	$(CC) $(CFLAGS) ../../../../C/Delta.c
HuffEnc.o : ../../../../C/HuffEnc.c
	$(CC) $(CFLAGS) ../../../../C/HuffEnc.c
LzFind.o : ../../../../C/LzFind.c
	$(CC) $(CFLAGS) ../../../../C/LzFind.c
LzFindMt.o : ../../../../C/LzFindMt.c
	$(CC) $(CFLAGS) ../../../../C/LzFindMt.c
Lzma2Dec.o : ../../../../C/Lzma2Dec.c
	$(CC) $(CFLAGS) ../../../../C/Lzma2Dec.c
Lzma2Enc.o : ../../../../C/Lzma2Enc.c
	$(CC) $(CFLAGS) ../../../../C/Lzma2Enc.c
LzmaDec.o : ../../../../C/LzmaDec.c
	$(CC) $(CFLAGS) ../../../../C/LzmaDec.c
LzmaEnc.o : ../../../../C/LzmaEnc.c
	$(CC) $(CFLAGS) ../../../../C/LzmaEnc.c
MtCoder.o : ../../../../C/MtCoder.c
	$(CC) $(CFLAGS) ../../../../C/MtCoder.c
Ppmd7.o : ../../../../C/Ppmd7.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd7.c
Ppmd7Dec.o : ../../../../C/Ppmd7Dec.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd7Dec.c
Ppmd7Enc.o : ../../../../C/Ppmd7Enc.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd7Enc.c
Ppmd8.o : ../../../../C/Ppmd8.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd8.c
Ppmd8Dec.o : ../../../../C/Ppmd8Dec.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd8Dec.c
Ppmd8Enc.o : ../../../../C/Ppmd8Enc.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd8Enc.c
Sha1.o : ../../../../C/Sha1.c
	$(CC) $(CFLAGS) ../../../../C/Sha1.c
Sha256.o : ../../../../C/Sha256.c
	$(CC) $(CFLAGS) ../../../../C/Sha256.c
Sort.o : ../../../../C/Sort.c
	$(CC) $(CFLAGS) ../../../../C/Sort.c
Threads.o : ../../../../C/Threads.c
	$(CC) $(CFLAGS) ../../../../C/Threads.c
Xz.o : ../../../../C/Xz.c
	$(CC) $(CFLAGS) ../../../../C/Xz.c
XzCrc64.o : ../../../../C/XzCrc64.c
	$(CC) $(CFLAGS) ../../../../C/XzCrc64.c
XzCrc64Opt.o : ../../../../C/XzCrc64Opt.c
	$(CC) $(CFLAGS) ../../../../C/XzCrc64Opt.c
XzDec.o : ../../../../C/XzDec.c
	$(CC) $(CFLAGS) ../../../../C/XzDec.c
XzEnc.o : ../../../../C/XzEnc.c
	$(CC) $(CFLAGS) ../../../../C/XzEnc.c
XzIn.o : ../../../../C/XzIn.c
	$(CC) $(CFLAGS) ../../../../C/XzIn.c
7zCompressionMode.o : ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp
7zDecode.o : ../../../../CPP/7zip/Archive/7z/7zDecode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zDecode.cpp
7zEncode.o : ../../../../CPP/7zip/Archive/7z/7zEncode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zEncode.cpp
7zExtract.o : ../../../../CPP/7zip/Archive/7z/7zExtract.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zExtract.cpp
7zFolderInStream.o : ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp
7zHandler.o : ../../../../CPP/7zip/Archive/7z/7zHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHandler.cpp
7zHandlerOut.o : ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp
7zHeader.o : ../../../../CPP/7zip/Archive/7z/7zHeader.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHeader.cpp
7zIn.o : ../../../../CPP/7zip/Archive/7z/7zIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zIn.cpp
7zOut.o : ../../../../CPP/7zip/Archive/7z/7zOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zOut.cpp
7zProperties.o : ../../../../CPP/7zip/Archive/7z/7zProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zProperties.cpp
7zRegister.o : ../../../../CPP/7zip/Archive/7z/7zRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zRegister.cpp
7zSpecStream.o : ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp
7zUpdate.o : ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zUpdate.cpp
ApmHandler.o : ../../../../CPP/7zip/Archive/ApmHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/ApmHandler.cpp
ArHandler.o : ../../../../CPP/7zip/Archive/ArHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/ArHandler.cpp
ArchiveExports.o : ../../../../CPP/7zip/Archive/ArchiveExports.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/ArchiveExports.cpp
ArjHandler.o : ../../../../CPP/7zip/Archive/ArjHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/ArjHandler.cpp
Bz2Handler.o : ../../../../CPP/7zip/Archive/Bz2Handler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Bz2Handler.cpp
CabBlockInStream.o : ../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp
CabHandler.o : ../../../../CPP/7zip/Archive/Cab/CabHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabHandler.cpp
CabHeader.o : ../../../../CPP/7zip/Archive/Cab/CabHeader.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabHeader.cpp
CabIn.o : ../../../../CPP/7zip/Archive/Cab/CabIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabIn.cpp
CabRegister.o : ../../../../CPP/7zip/Archive/Cab/CabRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Cab/CabRegister.cpp
ChmHandler.o : ../../../../CPP/7zip/Archive/Chm/ChmHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Chm/ChmHandler.cpp
ChmIn.o : ../../../../CPP/7zip/Archive/Chm/ChmIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Chm/ChmIn.cpp
ComHandler.o : ../../../../CPP/7zip/Archive/ComHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/ComHandler.cpp
CoderMixer2.o : ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp
DummyOutStream.o : ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp
FindSignature.o : ../../../../CPP/7zip/Archive/Common/FindSignature.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/FindSignature.cpp
HandlerOut.o : ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/HandlerOut.cpp
InStreamWithCRC.o : ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp
ItemNameUtils.o : ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp
MultiStream.o : ../../../../CPP/7zip/Archive/Common/MultiStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/MultiStream.cpp
OutStreamWithCRC.o : ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
OutStreamWithSha1.o : ../../../../CPP/7zip/Archive/Common/OutStreamWithSha1.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/OutStreamWithSha1.cpp
ParseProperties.o : ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/ParseProperties.cpp
CpioHandler.o : ../../../../CPP/7zip/Archive/CpioHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/CpioHandler.cpp
CramfsHandler.o : ../../../../CPP/7zip/Archive/CramfsHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/CramfsHandler.cpp
DeflateProps.o : ../../../../CPP/7zip/Archive/DeflateProps.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/DeflateProps.cpp
DllExports2.o : ../../../../CPP/7zip/Archive/DllExports2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/DllExports2.cpp
DmgHandler.o : ../../../../CPP/7zip/Archive/DmgHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/DmgHandler.cpp
ElfHandler.o : ../../../../CPP/7zip/Archive/ElfHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/ElfHandler.cpp
ExtHandler.o : ../../../../CPP/7zip/Archive/ExtHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/ExtHandler.cpp
FatHandler.o : ../../../../CPP/7zip/Archive/FatHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/FatHandler.cpp
FlvHandler.o : ../../../../CPP/7zip/Archive/FlvHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/FlvHandler.cpp
GzHandler.o : ../../../../CPP/7zip/Archive/GzHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/GzHandler.cpp
GptHandler.o : ../../../../CPP/7zip/Archive/GptHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/GptHandler.cpp
HandlerCont.o : ../../../../CPP/7zip/Archive/HandlerCont.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/HandlerCont.cpp
HfsHandler.o : ../../../../CPP/7zip/Archive/HfsHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/HfsHandler.cpp
IhexHandler.o : ../../../../CPP/7zip/Archive/IhexHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/IhexHandler.cpp
IsoHandler.o : ../../../../CPP/7zip/Archive/Iso/IsoHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Iso/IsoHandler.cpp
IsoHeader.o : ../../../../CPP/7zip/Archive/Iso/IsoHeader.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Iso/IsoHeader.cpp
IsoIn.o : ../../../../CPP/7zip/Archive/Iso/IsoIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Iso/IsoIn.cpp
IsoRegister.o : ../../../../CPP/7zip/Archive/Iso/IsoRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Iso/IsoRegister.cpp
LzhHandler.o : ../../../../CPP/7zip/Archive/LzhHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/LzhHandler.cpp
LzmaHandler.o : ../../../../CPP/7zip/Archive/LzmaHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/LzmaHandler.cpp
MachoHandler.o : ../../../../CPP/7zip/Archive/MachoHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/MachoHandler.cpp
MbrHandler.o : ../../../../CPP/7zip/Archive/MbrHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/MbrHandler.cpp
MslzHandler.o : ../../../../CPP/7zip/Archive/MslzHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/MslzHandler.cpp
MubHandler.o : ../../../../CPP/7zip/Archive/MubHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/MubHandler.cpp
NsisDecode.o : ../../../../CPP/7zip/Archive/Nsis/NsisDecode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Nsis/NsisDecode.cpp
NsisHandler.o : ../../../../CPP/7zip/Archive/Nsis/NsisHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Nsis/NsisHandler.cpp
NsisIn.o : ../../../../CPP/7zip/Archive/Nsis/NsisIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Nsis/NsisIn.cpp
NsisRegister.o : ../../../../CPP/7zip/Archive/Nsis/NsisRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Nsis/NsisRegister.cpp
NtfsHandler.o : ../../../../CPP/7zip/Archive/NtfsHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/NtfsHandler.cpp
PeHandler.o : ../../../../CPP/7zip/Archive/PeHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/PeHandler.cpp
PpmdHandler.o : ../../../../CPP/7zip/Archive/PpmdHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/PpmdHandler.cpp
QcowHandler.o : ../../../../CPP/7zip/Archive/QcowHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/QcowHandler.cpp
RarHandler.o : ../../../../CPP/7zip/Archive/Rar/RarHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Rar/RarHandler.cpp
Rar5Handler.o : ../../../../CPP/7zip/Archive/Rar/Rar5Handler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Rar/Rar5Handler.cpp
RpmHandler.o : ../../../../CPP/7zip/Archive/RpmHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/RpmHandler.cpp
SplitHandler.o : ../../../../CPP/7zip/Archive/SplitHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/SplitHandler.cpp
SquashfsHandler.o : ../../../../CPP/7zip/Archive/SquashfsHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/SquashfsHandler.cpp
SwfHandler.o : ../../../../CPP/7zip/Archive/SwfHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/SwfHandler.cpp
TarHandler.o : ../../../../CPP/7zip/Archive/Tar/TarHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarHandler.cpp
TarHandlerOut.o : ../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp
TarHeader.o : ../../../../CPP/7zip/Archive/Tar/TarHeader.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarHeader.cpp
TarIn.o : ../../../../CPP/7zip/Archive/Tar/TarIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarIn.cpp
TarOut.o : ../../../../CPP/7zip/Archive/Tar/TarOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarOut.cpp
TarRegister.o : ../../../../CPP/7zip/Archive/Tar/TarRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarRegister.cpp
TarUpdate.o : ../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp
UdfHandler.o : ../../../../CPP/7zip/Archive/Udf/UdfHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Udf/UdfHandler.cpp
UdfIn.o : ../../../../CPP/7zip/Archive/Udf/UdfIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Udf/UdfIn.cpp
UefiHandler.o : ../../../../CPP/7zip/Archive/UefiHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/UefiHandler.cpp
VdiHandler.o : ../../../../CPP/7zip/Archive/VdiHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/VdiHandler.cpp
VhdHandler.o : ../../../../CPP/7zip/Archive/VhdHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/VhdHandler.cpp
VmdkHandler.o : ../../../../CPP/7zip/Archive/VmdkHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/VmdkHandler.cpp
WimHandler.o : ../../../../CPP/7zip/Archive/Wim/WimHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Wim/WimHandler.cpp
WimHandlerOut.o : ../../../../CPP/7zip/Archive/Wim/WimHandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Wim/WimHandlerOut.cpp
WimIn.o : ../../../../CPP/7zip/Archive/Wim/WimIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Wim/WimIn.cpp
WimRegister.o : ../../../../CPP/7zip/Archive/Wim/WimRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Wim/WimRegister.cpp
XarHandler.o : ../../../../CPP/7zip/Archive/XarHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/XarHandler.cpp
XzHandler.o : ../../../../CPP/7zip/Archive/XzHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/XzHandler.cpp
ZHandler.o : ../../../../CPP/7zip/Archive/ZHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/ZHandler.cpp
ZipAddCommon.o : ../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp
ZipHandler.o : ../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp
ZipHandlerOut.o : ../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp
ZipIn.o : ../../../../CPP/7zip/Archive/Zip/ZipIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipIn.cpp
ZipItem.o : ../../../../CPP/7zip/Archive/Zip/ZipItem.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipItem.cpp
ZipOut.o : ../../../../CPP/7zip/Archive/Zip/ZipOut.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipOut.cpp
ZipRegister.o : ../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp
ZipUpdate.o : ../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp
CWrappers.o : ../../../../CPP/7zip/Common/CWrappers.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CWrappers.cpp
CreateCoder.o : ../../../../CPP/7zip/Common/CreateCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CreateCoder.cpp
FilterCoder.o : ../../../../CPP/7zip/Common/FilterCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilterCoder.cpp
InBuffer.o : ../../../../CPP/7zip/Common/InBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/InBuffer.cpp
InOutTempBuffer.o : ../../../../CPP/7zip/Common/InOutTempBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/InOutTempBuffer.cpp
LimitedStreams.o : ../../../../CPP/7zip/Common/LimitedStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/LimitedStreams.cpp
MemBlocks.o : ../../../../CPP/7zip/Common/MemBlocks.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MemBlocks.cpp
MethodId.o : ../../../../CPP/7zip/Common/MethodId.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MethodId.cpp
MethodProps.o : ../../../../CPP/7zip/Common/MethodProps.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MethodProps.cpp
OffsetStream.o : ../../../../CPP/7zip/Common/OffsetStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OffsetStream.cpp
OutBuffer.o : ../../../../CPP/7zip/Common/OutBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OutBuffer.cpp
OutMemStream.o : ../../../../CPP/7zip/Common/OutMemStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OutMemStream.cpp
ProgressMt.o : ../../../../CPP/7zip/Common/ProgressMt.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/ProgressMt.cpp
ProgressUtils.o : ../../../../CPP/7zip/Common/ProgressUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/ProgressUtils.cpp
PropId.o : ../../../../CPP/7zip/Common/PropId.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/PropId.cpp
StreamBinder.o : ../../../../CPP/7zip/Common/StreamBinder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamBinder.cpp
StreamObjects.o : ../../../../CPP/7zip/Common/StreamObjects.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamObjects.cpp
StreamUtils.o : ../../../../CPP/7zip/Common/StreamUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamUtils.cpp
UniqBlocks.o : ../../../../CPP/7zip/Common/UniqBlocks.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/UniqBlocks.cpp
VirtThread.o : ../../../../CPP/7zip/Common/VirtThread.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/VirtThread.cpp
BZip2Crc.o : ../../../../CPP/7zip/Compress/BZip2Crc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BZip2Crc.cpp
BZip2Decoder.o : ../../../../CPP/7zip/Compress/BZip2Decoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BZip2Decoder.cpp
BZip2Encoder.o : ../../../../CPP/7zip/Compress/BZip2Encoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BZip2Encoder.cpp
BZip2Register.o : ../../../../CPP/7zip/Compress/BZip2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BZip2Register.cpp
Bcj2Coder.o : ../../../../CPP/7zip/Compress/Bcj2Coder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Bcj2Coder.cpp
Bcj2Register.o : ../../../../CPP/7zip/Compress/Bcj2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Bcj2Register.cpp
BcjCoder.o : ../../../../CPP/7zip/Compress/BcjCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BcjCoder.cpp
BcjRegister.o : ../../../../CPP/7zip/Compress/BcjRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BcjRegister.cpp
BitlDecoder.o : ../../../../CPP/7zip/Compress/BitlDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BitlDecoder.cpp
BranchMisc.o : ../../../../CPP/7zip/Compress/BranchMisc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BranchMisc.cpp
BranchRegister.o : ../../../../CPP/7zip/Compress/BranchRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BranchRegister.cpp
ByteSwap.o : ../../../../CPP/7zip/Compress/ByteSwap.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ByteSwap.cpp
CodecExports.o : ../../../../CPP/7zip/Compress/CodecExports.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CodecExports.cpp
CopyCoder.o : ../../../../CPP/7zip/Compress/CopyCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyCoder.cpp
CopyRegister.o : ../../../../CPP/7zip/Compress/CopyRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyRegister.cpp
Deflate64Register.o : ../../../../CPP/7zip/Compress/Deflate64Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Deflate64Register.cpp
DeflateDecoder.o : ../../../../CPP/7zip/Compress/DeflateDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeflateDecoder.cpp
DeflateEncoder.o : ../../../../CPP/7zip/Compress/DeflateEncoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeflateEncoder.cpp
DeflateRegister.o : ../../../../CPP/7zip/Compress/DeflateRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeflateRegister.cpp
DeltaFilter.o : ../../../../CPP/7zip/Compress/DeltaFilter.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeltaFilter.cpp
ImplodeDecoder.o : ../../../../CPP/7zip/Compress/ImplodeDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ImplodeDecoder.cpp
ImplodeHuffmanDecoder.o : ../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp
LzOutWindow.o : ../../../../CPP/7zip/Compress/LzOutWindow.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzOutWindow.cpp
LzhDecoder.o : ../../../../CPP/7zip/Compress/LzhDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzhDecoder.cpp
Lzma2Decoder.o : ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp
Lzma2Encoder.o : ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Encoder.cpp
Lzma2Register.o : ../../../../CPP/7zip/Compress/Lzma2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Register.cpp
LzmaDecoder.o : ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
LzmaEncoder.o : ../../../../CPP/7zip/Compress/LzmaEncoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaEncoder.cpp
LzmaRegister.o : ../../../../CPP/7zip/Compress/LzmaRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaRegister.cpp
LzmsDecoder.o : ../../../../CPP/7zip/Compress/LzmsDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmsDecoder.cpp
LzxDecoder.o : ../../../../CPP/7zip/Compress/LzxDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzxDecoder.cpp
PpmdDecoder.o : ../../../../CPP/7zip/Compress/PpmdDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdDecoder.cpp
PpmdEncoder.o : ../../../../CPP/7zip/Compress/PpmdEncoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdEncoder.cpp
PpmdRegister.o : ../../../../CPP/7zip/Compress/PpmdRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdRegister.cpp
PpmdZip.o : ../../../../CPP/7zip/Compress/PpmdZip.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdZip.cpp
QuantumDecoder.o : ../../../../CPP/7zip/Compress/QuantumDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/QuantumDecoder.cpp
ShrinkDecoder.o : ../../../../CPP/7zip/Compress/ShrinkDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ShrinkDecoder.cpp
ZDecoder.o : ../../../../CPP/7zip/Compress/ZDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ZDecoder.cpp
XpressDecoder.o : ../../../../CPP/7zip/Compress/XpressDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/XpressDecoder.cpp
ZlibDecoder.o : ../../../../CPP/7zip/Compress/ZlibDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ZlibDecoder.cpp
ZlibEncoder.o : ../../../../CPP/7zip/Compress/ZlibEncoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/ZlibEncoder.cpp
7zAes.o : ../../../../CPP/7zip/Crypto/7zAes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/7zAes.cpp
7zAesRegister.o : ../../../../CPP/7zip/Crypto/7zAesRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/7zAesRegister.cpp
HmacSha1.o : ../../../../CPP/7zip/Crypto/HmacSha1.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/HmacSha1.cpp
HmacSha256.o : ../../../../CPP/7zip/Crypto/HmacSha256.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/HmacSha256.cpp
MyAes.o : ../../../../CPP/7zip/Crypto/MyAes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/MyAes.cpp
MyAesReg.o : ../../../../CPP/7zip/Crypto/MyAesReg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/MyAesReg.cpp
Pbkdf2HmacSha1.o : ../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp
RandGen.o : ../../../../CPP/7zip/Crypto/RandGen.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/RandGen.cpp
Rar20Crypto.o : ../../../../CPP/7zip/Crypto/Rar20Crypto.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/Rar20Crypto.cpp
Rar5Aes.o : ../../../../CPP/7zip/Crypto/Rar5Aes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/Rar5Aes.cpp
RarAes.o : ../../../../CPP/7zip/Crypto/RarAes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/RarAes.cpp
WzAes.o : ../../../../CPP/7zip/Crypto/WzAes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/WzAes.cpp
ZipCrypto.o : ../../../../CPP/7zip/Crypto/ZipCrypto.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/ZipCrypto.cpp
ZipStrong.o : ../../../../CPP/7zip/Crypto/ZipStrong.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/ZipStrong.cpp
CRC.o : ../../../../CPP/Common/CRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CRC.cpp
CrcReg.o : ../../../../CPP/Common/CrcReg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CrcReg.cpp
DynLimBuf.o : ../../../../CPP/Common/DynLimBuf.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/DynLimBuf.cpp
IntToString.o : ../../../../CPP/Common/IntToString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/IntToString.cpp
MyMap.o : ../../../../CPP/Common/MyMap.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyMap.cpp
MyString.o : ../../../../CPP/Common/MyString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyString.cpp
MyVector.o : ../../../../CPP/Common/MyVector.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyVector.cpp
MyWindows.o : ../../../../CPP/Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyWindows.cpp
MyXml.o : ../../../../CPP/Common/MyXml.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyXml.cpp
NewHandler.o : ../../../../CPP/Common/NewHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/NewHandler.cpp
Sha1Reg.o : ../../../../CPP/Common/Sha1Reg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Sha1Reg.cpp
Sha256Reg.o : ../../../../CPP/Common/Sha256Reg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Sha256Reg.cpp
StringConvert.o : ../../../../CPP/Common/StringConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringConvert.cpp
StringToInt.o : ../../../../CPP/Common/StringToInt.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringToInt.cpp
UTFConvert.o : ../../../../CPP/Common/UTFConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/UTFConvert.cpp
Wildcard.o : ../../../../CPP/Common/Wildcard.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Wildcard.cpp
XzCrc64Reg.o : ../../../../CPP/Common/XzCrc64Reg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/XzCrc64Reg.cpp
FileDir.o : ../../../../CPP/Windows/FileDir.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileDir.cpp
FileFind.o : ../../../../CPP/Windows/FileFind.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileFind.cpp
FileIO.o : ../../../../CPP/Windows/FileIO.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileIO.cpp
FileName.o : ../../../../CPP/Windows/FileName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileName.cpp
PropVariant.o : ../../../../CPP/Windows/PropVariant.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariant.cpp
PropVariantUtils.o : ../../../../CPP/Windows/PropVariantUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariantUtils.cpp
Synchronization.o : ../../../../CPP/Windows/Synchronization.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Synchronization.cpp
System.o : ../../../../CPP/Windows/System.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/System.cpp
TimeUtils.o : ../../../../CPP/Windows/TimeUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/TimeUtils.cpp
wine_date_and_time.o : ../../../../CPP/myWindows/wine_date_and_time.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_date_and_time.cpp

OBJS=\
 7zBuf2.o \
 7zCrc.o \
 $(OBJ_CRC32) \
 7zStream.o \
 Aes.o \
 Alloc.o \
 Bcj2.o \
 Bcj2Enc.o \
 Blake2s.o \
 Bra.o \
 Bra86.o \
 BraIA64.o \
 BwtSort.o \
 CpuArch.o \
 Delta.o \
 HuffEnc.o \
 LzFind.o \
 LzFindMt.o \
 Lzma2Dec.o \
 Lzma2Enc.o \
 LzmaDec.o \
 LzmaEnc.o \
 MtCoder.o \
 Ppmd7.o \
 Ppmd7Dec.o \
 Ppmd7Enc.o \
 Ppmd8.o \
 Ppmd8Dec.o \
 Ppmd8Enc.o \
 Sha1.o \
 Sha256.o \
 Sort.o \
 Threads.o \
 Xz.o \
 XzCrc64.o \
 XzCrc64Opt.o \
 XzDec.o \
 XzEnc.o \
 XzIn.o \
 7zCompressionMode.o \
 7zDecode.o \
 7zEncode.o \
 7zExtract.o \
 7zFolderInStream.o \
 7zHandler.o \
 7zHandlerOut.o \
 7zHeader.o \
 7zIn.o \
 7zOut.o \
 7zProperties.o \
 7zRegister.o \
 7zSpecStream.o \
 7zUpdate.o \
 ApmHandler.o \
 ArHandler.o \
 ArchiveExports.o \
 ArjHandler.o \
 Bz2Handler.o \
 CabBlockInStream.o \
 CabHandler.o \
 CabHeader.o \
 CabIn.o \
 CabRegister.o \
 ChmHandler.o \
 ChmIn.o \
 ComHandler.o \
 CoderMixer2.o \
 DummyOutStream.o \
 FindSignature.o \
 HandlerOut.o \
 InStreamWithCRC.o \
 ItemNameUtils.o \
 MultiStream.o \
 OutStreamWithCRC.o \
 OutStreamWithSha1.o \
 ParseProperties.o \
 CpioHandler.o \
 CramfsHandler.o \
 DeflateProps.o \
 DllExports2.o \
 DmgHandler.o \
 ElfHandler.o \
 ExtHandler.o \
 FatHandler.o \
 FlvHandler.o \
 GzHandler.o \
 GptHandler.o \
 HandlerCont.o \
 HfsHandler.o \
 IhexHandler.o \
 IsoHandler.o \
 IsoHeader.o \
 IsoIn.o \
 IsoRegister.o \
 LzhHandler.o \
 LzmaHandler.o \
 MachoHandler.o \
 MbrHandler.o \
 MslzHandler.o \
 MubHandler.o \
 NsisDecode.o \
 NsisHandler.o \
 NsisIn.o \
 NsisRegister.o \
 NtfsHandler.o \
 PeHandler.o \
 PpmdHandler.o \
 QcowHandler.o \
 RarHandler.o \
 Rar5Handler.o \
 RpmHandler.o \
 SplitHandler.o \
 SquashfsHandler.o \
 SwfHandler.o \
 TarHandler.o \
 TarHandlerOut.o \
 TarHeader.o \
 TarIn.o \
 TarOut.o \
 TarRegister.o \
 TarUpdate.o \
 UdfHandler.o \
 UdfIn.o \
 UefiHandler.o \
 VdiHandler.o \
 VhdHandler.o \
 VmdkHandler.o \
 WimHandler.o \
 WimHandlerOut.o \
 WimIn.o \
 WimRegister.o \
 XarHandler.o \
 XzHandler.o \
 ZHandler.o \
 ZipAddCommon.o \
 ZipHandler.o \
 ZipHandlerOut.o \
 ZipIn.o \
 ZipItem.o \
 ZipOut.o \
 ZipRegister.o \
 ZipUpdate.o \
 CWrappers.o \
 CreateCoder.o \
 FilterCoder.o \
 InBuffer.o \
 InOutTempBuffer.o \
 LimitedStreams.o \
 MemBlocks.o \
 MethodId.o \
 MethodProps.o \
 OffsetStream.o \
 OutBuffer.o \
 OutMemStream.o \
 ProgressMt.o \
 ProgressUtils.o \
 PropId.o \
 StreamBinder.o \
 StreamObjects.o \
 StreamUtils.o \
 UniqBlocks.o \
 VirtThread.o \
 BZip2Crc.o \
 BZip2Decoder.o \
 BZip2Encoder.o \
 BZip2Register.o \
 Bcj2Coder.o \
 Bcj2Register.o \
 BcjCoder.o \
 BcjRegister.o \
 BitlDecoder.o \
 BranchMisc.o \
 BranchRegister.o \
 ByteSwap.o \
 CodecExports.o \
 CopyCoder.o \
 CopyRegister.o \
 Deflate64Register.o \
 DeflateDecoder.o \
 DeflateEncoder.o \
 DeflateRegister.o \
 DeltaFilter.o \
 ImplodeDecoder.o \
 ImplodeHuffmanDecoder.o \
 LzOutWindow.o \
 LzhDecoder.o \
 Lzma2Decoder.o \
 Lzma2Encoder.o \
 Lzma2Register.o \
 LzmaDecoder.o \
 LzmaEncoder.o \
 LzmaRegister.o \
 LzmsDecoder.o \
 LzxDecoder.o \
 PpmdDecoder.o \
 PpmdEncoder.o \
 PpmdRegister.o \
 PpmdZip.o \
 QuantumDecoder.o \
 ShrinkDecoder.o \
 ZDecoder.o \
 XpressDecoder.o \
 ZlibDecoder.o \
 ZlibEncoder.o \
 7zAes.o \
 7zAesRegister.o \
 HmacSha1.o \
 HmacSha256.o \
 MyAes.o \
 MyAesReg.o \
 Pbkdf2HmacSha1.o \
 RandGen.o \
 Rar20Crypto.o \
 Rar5Aes.o \
 RarAes.o \
 WzAes.o \
 ZipCrypto.o \
 ZipStrong.o \
 CRC.o \
 CrcReg.o \
 DynLimBuf.o \
 IntToString.o \
 MyMap.o \
 MyString.o \
 MyVector.o \
 MyWindows.o \
 MyXml.o \
 NewHandler.o \
 Sha1Reg.o \
 Sha256Reg.o \
 StringConvert.o \
 StringToInt.o \
 UTFConvert.o \
 Wildcard.o \
 XzCrc64Reg.o \
 FileDir.o \
 FileFind.o \
 FileIO.o \
 FileName.o \
 PropVariant.o \
 PropVariantUtils.o \
 Synchronization.o \
 System.o \
 TimeUtils.o \
 wine_date_and_time.o \
 $(OBJ_AES) \

// LzmaAlone.cpp

#include "StdAfx.h"

#include <stdio.h>

#if (defined(_WIN32) || defined(OS2) || defined(MSDOS)) && !defined(UNDER_CE)
#include <fcntl.h>
#include <io.h>
#define MY_SET_BINARY_MODE(file) _setmode(_fileno(file), O_BINARY)
#else
#define MY_SET_BINARY_MODE(file)
#endif

#include "../../../Common/MyWindows.h"
#include "../../../Common/MyInitGuid.h"

#include "../../../../C/7zVersion.h"
#include "../../../../C/Alloc.h"
#include "../../../../C/Lzma86.h"

#include "../../../Windows/NtCheck.h"

#ifndef _7ZIP_ST
#include "../../../Windows/System.h"
#endif

#include "../../../Common/IntToString.h"
#include "../../../Common/CommandLineParser.h"
#include "../../../Common/StringConvert.h"
#include "../../../Common/StringToInt.h"

#include "../../Common/FileStreams.h"
#include "../../Common/StreamUtils.h"

#include "../../Compress/LzmaDecoder.h"
#include "../../Compress/LzmaEncoder.h"

#include "../../UI/Console/BenchCon.h"
#include "../../UI/Console/ConsoleClose.h"

using namespace NCommandLineParser;

static const unsigned kDictSizeLog = 24;

static const char *kCopyrightString = "\nLZMA " MY_VERSION_COPYRIGHT_DATE "\n\n";

static const char *kHelpString =
    "Usage:  LZMA <command> [inputFile] [outputFile] [<switches>...]\n"
    "\n"
    "<command>\n"
    "  e : Encode file\n"
    "  d : Decode file\n"
    "  b : Benchmark\n"
    "<switches>\n"
    "  -a{N}  : set compression mode : [0, 1] : default = 1 (max)\n"
    "  -d{N}  : set dictionary size : [12, 30] : default = 24 (16 MiB)\n"
    "  -fb{N} : set number of fast bytes : [5, 273] : default = 128\n"
    "  -mc{N} : set number of cycles for match finder\n"
    "  -lc{N} : set number of literal context bits : [0, 8] : default = 3\n"
    "  -lp{N} : set number of literal pos bits : [0, 4] : default = 0\n"
    "  -pb{N} : set number of pos bits : [0, 4] : default = 2\n"
    "  -mf{M} : set match finder: [hc4, bt2, bt3, bt4] : default = bt4\n"
    "  -mt{N} : set number of CPU threads\n"
    "  -eos   : write end of stream marker\n"
    "  -si    : read data from stdin\n"
    "  -so    : write data to stdout\n";


static const char *kCantAllocate = "Can not allocate memory";
static const char *kReadError = "Read error";
static const char *kWriteError = "Write error";


namespace NKey {
enum Enum
{
  kHelp1 = 0,
  kHelp2,
  kMethod,
  kLevel,
  kAlgo,
  kDict,
  kFb,
  kMc,
  kLc,
  kLp,
  kPb,
  kMatchFinder,
  kMultiThread,
  kEOS,
  kStdIn,
  kStdOut,
  kFilter86
};
}

static const CSwitchForm kSwitchForms[] =
{
  { "?",  NSwitchType::kSimple, false },
  { "H",  NSwitchType::kSimple, false },
  { "MM", NSwitchType::kString, false, 1 },
  { "X", NSwitchType::kString, false, 1 },
  { "A", NSwitchType::kString, false, 1 },
  { "D", NSwitchType::kString, false, 1 },
  { "FB", NSwitchType::kString, false, 1 },
  { "MC", NSwitchType::kString, false, 1 },
  { "LC", NSwitchType::kString, false, 1 },
  { "LP", NSwitchType::kString, false, 1 },
  { "PB", NSwitchType::kString, false, 1 },
  { "MF", NSwitchType::kString, false, 1 },
  { "MT", NSwitchType::kString, false, 0 },
  { "EOS", NSwitchType::kSimple, false },
  { "SI",  NSwitchType::kSimple, false },
  { "SO",  NSwitchType::kSimple, false },
  { "F86",  NSwitchType::kChar, false, 0, "+" }
};


static void PrintErr(const char *s)
{
  fputs(s, stderr);
}

static void PrintErr_LF(const char *s)
{
  PrintErr(s);
  fputc('\n', stderr);
}


static void PrintError(const char *s)
{
  PrintErr("\nERROR: ");
  PrintErr_LF(s);
}

static void PrintError2(const char *s1, const wchar_t *s2)
{
  PrintError(s1);
  PrintErr_LF(GetOemString(s2));
}

static void PrintError_int(const char *s, int code)
{
  PrintError(s);
  char temp[32];
  ConvertInt64ToString(code, temp);
  PrintErr("Error code = ");
  PrintErr_LF(temp);
}



static void Print(const char *s)
{
  fputs(s, stdout);
}

static void Print_UInt64(UInt64 v)
{
  char temp[32];
  ConvertUInt64ToString(v, temp);
  Print(temp);
}

static void Print_MB(UInt64 v)
{
  Print_UInt64(v);
  Print(" MiB");
}

static void Print_Size(const char *s, UInt64 v)
{
  Print(s);
  Print_UInt64(v);
  Print(" (");
  Print_MB(v >> 20);
  Print(")\n");
}

static void PrintTitle()
{
  Print(kCopyrightString);
}

static void PrintHelp()
{
  PrintTitle();
  Print(kHelpString);
}

class CProgressPrint:
  public ICompressProgressInfo,
  public CMyUnknownImp
{
  UInt64 _size1;
  UInt64 _size2;
public:
  CProgressPrint(): _size1(0), _size2(0) {}

  void ClosePrint();

  MY_UNKNOWN_IMP1(ICompressProgressInfo)

  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize);
};

#define BACK_STR \
"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
static const char *kBackSpaces =
BACK_STR
"                                                                "
BACK_STR;


void CProgressPrint::ClosePrint()
{
  Print(kBackSpaces);
}

STDMETHODIMP CProgressPrint::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)
{
  if (NConsoleClose::TestBreakSignal())
    return E_ABORT;
  if (inSize)
  {
    UInt64 v1 = *inSize >> 20;
    UInt64 v2 = _size2;
    if (outSize)
      v2 = *outSize >> 20;
    if (v1 != _size1 || v2 != _size2)
    {
      _size1 = v1;
      _size2 = v2;
      ClosePrint();
      Print_MB(_size1);
      Print(" -> ");
      Print_MB(_size2);
    }
  }
  return S_OK;
}


static void IncorrectCommand()
{
  throw "Incorrect command";
}

static UInt32 GetNumber(const wchar_t *s)
{
  const wchar_t *end;
  UInt32 v = ConvertStringToUInt32(s, &end);
  if (*end != 0)
    IncorrectCommand();
  return v;
}

static void ParseUInt32(const CParser &parser, unsigned index, UInt32 &res)
{
  if (parser[index].ThereIs)
    res = GetNumber(parser[index].PostStrings[0]);
}


static int Error_HRESULT(const char *s, HRESULT res)
{
  if (res == E_ABORT)
  {
    Print("\n\nBreak signaled\n");
    return 255;
  }

  PrintError(s);

  if (res == E_OUTOFMEMORY)
  {
    PrintErr_LF(kCantAllocate);
    return 8;
  }
  if (res == E_INVALIDARG)
  {
    PrintErr_LF("Ununsupported parameter");
  }
  else
  {
    char temp[32];
    ConvertUInt32ToHex(res, temp);
    PrintErr("Error code = 0x");
    PrintErr_LF(temp);
  }
  return 1;
}

#define NT_CHECK_FAIL_ACTION PrintError("Unsupported Windows version"); return 1;

static void AddProp(CObjectVector<CProperty> &props2, const char *name, const wchar_t *val)
{
  CProperty &prop = props2.AddNew();
  prop.Name.SetFromAscii(name);
  prop.Value = val;
}

static int main2(int numArgs, const char *args[])
{
  NT_CHECK

  if (numArgs == 1)
  {
    PrintHelp();
    return 0;
  }

  /*
  bool unsupportedTypes = (sizeof(Byte) != 1 || sizeof(UInt32) < 4 || sizeof(UInt64) < 8);
  if (unsupportedTypes)
    throw "Unsupported base types. Edit Common/Types.h and recompile";
  */

  UStringVector commandStrings;
  for (int i = 1; i < numArgs; i++)
    commandStrings.Add(MultiByteToUnicodeString(args[i]));
  
  CParser parser(ARRAY_SIZE(kSwitchForms));
  try
  {
    if (!parser.ParseStrings(kSwitchForms, commandStrings))
    {
      PrintError2(parser.ErrorMessage, parser.ErrorLine);
      return 1;
    }
  }
  catch(...)
  {
    IncorrectCommand();
  }

  if (parser[NKey::kHelp1].ThereIs || parser[NKey::kHelp2].ThereIs)
  {
    PrintHelp();
    return 0;
  }

  bool stdInMode = parser[NKey::kStdIn].ThereIs;
  bool stdOutMode = parser[NKey::kStdOut].ThereIs;

  if (!stdOutMode)
    PrintTitle();

  const UStringVector &params = parser.NonSwitchStrings;

  unsigned paramIndex = 0;
  if (paramIndex >= params.Size())
    IncorrectCommand();
  const UString &command = params[paramIndex++];

  CObjectVector<CProperty> props2;
  bool dictDefined = false;
  UInt32 dict = (UInt32)(Int32)-1;
  
  if (parser[NKey::kDict].ThereIs)
  {
    UInt32 dictLog;
    const UString &s = parser[NKey::kDict].PostStrings[0];
    dictLog = GetNumber(s);
    dict = 1 << dictLog;
    dictDefined = true;
    AddProp(props2, "d", s);
  }
  
  if (parser[NKey::kLevel].ThereIs)
  {
    const UString &s = parser[NKey::kLevel].PostStrings[0];
    /* UInt32 level = */ GetNumber(s);
    AddProp(props2, "x", s);
  }
  
  UString mf = L"BT4";
  if (parser[NKey::kMatchFinder].ThereIs)
    mf = parser[NKey::kMatchFinder].PostStrings[0];

  UInt32 numThreads = (UInt32)(Int32)-1;

  #ifndef _7ZIP_ST
  
  if (parser[NKey::kMultiThread].ThereIs)
  {
    const UString &s = parser[NKey::kMultiThread].PostStrings[0];
    if (s.IsEmpty())
      numThreads = NWindows::NSystem::GetNumberOfProcessors();
    else
      numThreads = GetNumber(s);
    AddProp(props2, "mt", s);
  }
  
  #endif

  
  if (parser[NKey::kMethod].ThereIs)
  {
    const UString &s = parser[NKey::kMethod].PostStrings[0];
    if (s.IsEmpty() || s[0] != '=')
      IncorrectCommand();
    AddProp(props2, "m", s.Ptr(1));
  }

  if (StringsAreEqualNoCase_Ascii(command, "b"))
  {
    UInt32 numIterations = 1;
    if (paramIndex < params.Size())
      numIterations = GetNumber(params[paramIndex++]);
    if (params.Size() != paramIndex)
      IncorrectCommand();
  
    HRESULT res = BenchCon(props2, numIterations, stdout);
    
    if (res == S_OK)
      return 0;
    return Error_HRESULT("Benchmark error", res);
  }

  {
    UInt32 needParams = 3;
    if (stdInMode) needParams--;
    if (stdOutMode) needParams--;
    if (needParams != params.Size())
      IncorrectCommand();
  }

  if (numThreads == (UInt32)(Int32)-1)
    numThreads = 1;

  bool encodeMode = false;
  
  if (StringsAreEqualNoCase_Ascii(command, "e"))
    encodeMode = true;
  else if (!StringsAreEqualNoCase_Ascii(command, "d"))
    IncorrectCommand();

  CMyComPtr<ISequentialInStream> inStream;
  CInFileStream *inStreamSpec = NULL;
  
  if (stdInMode)
  {
    inStream = new CStdInFileStream;
    MY_SET_BINARY_MODE(stdin);
  }
  else
  {
    const UString &inputName = params[paramIndex++];
    inStreamSpec = new CInFileStream;
    inStream = inStreamSpec;
    if (!inStreamSpec->Open(us2fs(inputName)))
    {
      PrintError2("can not open input file", inputName);
      return 1;
    }
  }

  CMyComPtr<ISequentialOutStream> outStream;
  COutFileStream *outStreamSpec = NULL;
  
  if (stdOutMode)
  {
    outStream = new CStdOutFileStream;
    MY_SET_BINARY_MODE(stdout);
  }
  else
  {
    const UString &outputName = params[paramIndex++];
    outStreamSpec = new COutFileStream;
    outStream = outStreamSpec;
    if (!outStreamSpec->Create(us2fs(outputName), true))
    {
      PrintError2("can not open output file", outputName);
      return 1;
    }
  }

  bool fileSizeDefined = false;
  UInt64 fileSize = 0;
  
  if (inStreamSpec)
  {
    if (!inStreamSpec->File.GetLength(fileSize))
      throw "Can not get file length";
    fileSizeDefined = true;
    if (!stdOutMode)
      Print_Size("Input size:  ", fileSize);
  }

  if (encodeMode && !dictDefined)
  {
    dict = 1 << kDictSizeLog;
    if (fileSizeDefined)
    {
      unsigned i;
      for (i = 16; i < kDictSizeLog; i++)
        if ((UInt32)((UInt32)1 << i) >= fileSize)
          break;
      dict = (UInt32)1 << i;
    }
  }

  if (parser[NKey::kFilter86].ThereIs)
  {
    /* -f86 switch is for x86 filtered mode: BCJ + LZMA.
       It uses modified header format.
       It's not recommended to use -f86 mode now.
       You can use xz format instead, if you want to use filters */

    if (parser[NKey::kEOS].ThereIs || stdInMode)
      throw "Can not use stdin in this mode";

    size_t inSize = (size_t)fileSize;

    if (inSize != fileSize)
      throw "File is too big";

    Byte *inBuffer = NULL;
    
    if (inSize != 0)
    {
      inBuffer = (Byte *)MyAlloc((size_t)inSize);
      if (!inBuffer)
        throw kCantAllocate;
    }
    
    if (ReadStream_FAIL(inStream, inBuffer, inSize) != S_OK)
      throw "Can not read";

    Byte *outBuffer = NULL;
    size_t outSize;
    
    if (encodeMode)
    {
      // we allocate 105% of original size for output buffer
      UInt64 outSize64 = fileSize / 20 * 21 + (1 << 16);

      outSize = (size_t)outSize64;
      
      if (outSize != outSize64)
        throw "File is too big";

      if (outSize != 0)
      {
        outBuffer = (Byte *)MyAlloc((size_t)outSize);
        if (!outBuffer)
          throw kCantAllocate;
      }
      
      int res = Lzma86_Encode(outBuffer, &outSize, inBuffer, inSize,
          5, dict, parser[NKey::kFilter86].PostCharIndex == 0 ? SZ_FILTER_YES : SZ_FILTER_AUTO);
  
      if (res != 0)
      {
        PrintError_int("Encode error", (int)res);
        return 1;
      }
    }
    else
    {
      UInt64 outSize64;
      
      if (Lzma86_GetUnpackSize(inBuffer, inSize, &outSize64) != 0)
        throw "data error";
      
      outSize = (size_t)outSize64;
      if (outSize != outSize64)
        throw "Unpack size is too big";
      if (outSize != 0)
      {
        outBuffer = (Byte *)MyAlloc(outSize);
        if (!outBuffer)
          throw kCantAllocate;
      }
      
      int res = Lzma86_Decode(outBuffer, &outSize, inBuffer, &inSize);
      
      if (inSize != (size_t)fileSize)
        throw "incorrect processed size";
      if (res != 0)
      {
        PrintError_int("Decode error", (int)res);
        return 1;
      }
    }
    
    if (WriteStream(outStream, outBuffer, outSize) != S_OK)
      throw kWriteError;
    
    MyFree(outBuffer);
    MyFree(inBuffer);
  }
  else
  {

  CProgressPrint *progressSpec = NULL;
  CMyComPtr<ICompressProgressInfo> progress;

  if (!stdOutMode)
  {
    progressSpec = new CProgressPrint;
    progress = progressSpec;
  }

  if (encodeMode)
  {
    NCompress::NLzma::CEncoder *encoderSpec = new NCompress::NLzma::CEncoder;
    CMyComPtr<ICompressCoder> encoder = encoderSpec;

    UInt32 pb = 2;
    UInt32 lc = 3; // = 0; for 32-bit data
    UInt32 lp = 0; // = 2; for 32-bit data
    UInt32 algo = 1;
    UInt32 fb = 128;
    UInt32 mc = 16 + fb / 2;
    bool mcDefined = false;

    bool eos = parser[NKey::kEOS].ThereIs || stdInMode;
 
    ParseUInt32(parser, NKey::kAlgo, algo);
    ParseUInt32(parser, NKey::kFb, fb);
    ParseUInt32(parser, NKey::kLc, lc);
    ParseUInt32(parser, NKey::kLp, lp);
    ParseUInt32(parser, NKey::kPb, pb);

    mcDefined = parser[NKey::kMc].ThereIs;
    if (mcDefined)
      mc = GetNumber(parser[NKey::kMc].PostStrings[0]);
    
    const PROPID propIDs[] =
    {
      NCoderPropID::kDictionarySize,
      NCoderPropID::kPosStateBits,
      NCoderPropID::kLitContextBits,
      NCoderPropID::kLitPosBits,
      NCoderPropID::kAlgorithm,
      NCoderPropID::kNumFastBytes,
      NCoderPropID::kMatchFinder,
      NCoderPropID::kEndMarker,
      NCoderPropID::kNumThreads,
      NCoderPropID::kMatchFinderCycles,
    };

    const unsigned kNumPropsMax = ARRAY_SIZE(propIDs);

    PROPVARIANT props[kNumPropsMax];
    for (int p = 0; p < 6; p++)
      props[p].vt = VT_UI4;

    props[0].ulVal = (UInt32)dict;
    props[1].ulVal = (UInt32)pb;
    props[2].ulVal = (UInt32)lc;
    props[3].ulVal = (UInt32)lp;
    props[4].ulVal = (UInt32)algo;
    props[5].ulVal = (UInt32)fb;

    props[6].vt = VT_BSTR;
    props[6].bstrVal = const_cast<BSTR>((const wchar_t *)mf);

    props[7].vt = VT_BOOL;
    props[7].boolVal = eos ? VARIANT_TRUE : VARIANT_FALSE;

    props[8].vt = VT_UI4;
    props[8].ulVal = (UInt32)numThreads;

    // it must be last in property list
    props[9].vt = VT_UI4;
    props[9].ulVal = (UInt32)mc;

    unsigned numProps = kNumPropsMax;
    if (!mcDefined)
      numProps--;

    HRESULT res = encoderSpec->SetCoderProperties(propIDs, props, numProps);
    if (res != S_OK)
      return Error_HRESULT("incorrect encoder properties", res);

    if (encoderSpec->WriteCoderProperties(outStream) != S_OK)
      throw kWriteError;

    bool fileSizeWasUsed = true;
    if (eos || stdInMode)
    {
      fileSize = (UInt64)(Int64)-1;
      fileSizeWasUsed = false;
    }

    {
      Byte temp[8];
      for (int i = 0; i < 8; i++)
        temp[i]= (Byte)(fileSize >> (8 * i));
      if (WriteStream(outStream, temp, 8) != S_OK)
        throw kWriteError;
    }
  
    res = encoder->Code(inStream, outStream, NULL, NULL, progress);
    if (progressSpec)
      progressSpec->ClosePrint();

    if (res != S_OK)
      return Error_HRESULT("Encoding error", res);

    UInt64 processedSize = encoderSpec->GetInputProcessedSize();
    
    if (fileSizeWasUsed && processedSize != fileSize)
      throw "Incorrect size of processed data";
  }
  else
  {
    NCompress::NLzma::CDecoder *decoderSpec = new NCompress::NLzma::CDecoder;
    CMyComPtr<ICompressCoder> decoder = decoderSpec;
    
    decoderSpec->FinishStream = true;
    
    const unsigned kPropertiesSize = 5;
    Byte header[kPropertiesSize + 8];

    if (ReadStream_FALSE(inStream, header, kPropertiesSize + 8) != S_OK)
      throw kReadError;
    
    if (decoderSpec->SetDecoderProperties2(header, kPropertiesSize) != S_OK)
      throw "SetDecoderProperties error";
    
    UInt64 unpackSize = 0;
    for (int i = 0; i < 8; i++)
      unpackSize |= ((UInt64)header[kPropertiesSize + i]) << (8 * i);

    bool unpackSizeDefined = (unpackSize != (UInt64)(Int64)-1);

    HRESULT res = decoder->Code(inStream, outStream, NULL, unpackSizeDefined ? &unpackSize : NULL, progress);
    if (progressSpec)
      progressSpec->ClosePrint();

    if (res != S_OK)
    {
      if (res == S_FALSE)
      {
        PrintError("Decoding error");
        return 1;
      }
      return Error_HRESULT("Decoding error", res);
    }
    
    if (unpackSizeDefined && unpackSize != decoderSpec->GetOutputProcessedSize())
      throw "incorrect uncompressed size in header";
  }
  }

  if (!stdOutMode)
    Print_Size("Output size: ", outStreamSpec->ProcessedSize);

  if (outStreamSpec)
  {
    if (outStreamSpec->Close() != S_OK)
      throw "File closing error";
  }

  return 0;
}

int MY_CDECL main(int numArgs, const char *args[])
{
  NConsoleClose::CCtrlHandlerSetter ctrlHandlerSetter;

  try { return main2(numArgs, args); }
  catch (const char *s)
  {
    PrintError(s);
    return 1;
  }
  catch(...)
  {
    PrintError("Unknown Error");
    return 1;
  }
}

# TARGET_FLAGS=-D_7ZIP_ST

include ../../../../makefile.crc32
include ../../../../makefile.machine

TARGET_FLAGS=$(CC_EXE)
LOCAL_LINK=$(LINK_EXE)
LIBS=$(LOCAL_LIBS)

include ../../../../makefile.glb

test: $(PROG)
	echo TOOLS=$(TOOLS)
	cp LzmaAlone.cpp testfile
	$(TOOLS) ./$(PROG) e testfile testfile.lzma
	$(TOOLS) ./$(PROG) d testfile.lzma testfile.lzma.d 
	diff -s testfile testfile.lzma.d
	$(TOOLS) ./$(PROG) e testfile testfile.lzma
	$(TOOLS) ./$(PROG) d testfile.lzma testfile.lzma.d 
	diff -s testfile testfile.lzma.d
	$(TOOLS) ./$(PROG) e -si -so < testfile > testfile.lzma.2
	$(TOOLS) ./$(PROG) d -si -so < testfile.lzma.2 > testfile.lzma.2.d 
	diff -s testfile testfile.lzma.2.d
	@echo =========
	@echo All Done 
	@echo =========


clean2: clean
	rm -f testfile*



# WARNING : automatically generated by utils/generate.py

PROG=../../../../bin/LzmaCon$(BINSUFFIX)

all: $(PCH_NAME) $(PROG)

LOCAL_FLAGS=$(TARGET_FLAGS) \
  -D_FILE_OFFSET_BITS=64 \
  -D_LARGEFILE_SOURCE \
  -D_REENTRANT \
  -DENV_UNIX \

SRCS=\
  ../../../../CPP/7zip/Bundles/LzmaCon/LzmaAlone.cpp \
  ../../../../CPP/7zip/Common/CWrappers.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/MethodProps.cpp \
  ../../../../CPP/7zip/Common/OutBuffer.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Compress/LzmaDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaEncoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaRegister.cpp \
  ../../../../CPP/7zip/UI/Common/Bench.cpp \
  ../../../../CPP/7zip/UI/Console/BenchCon.cpp \
  ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CommandLineParser.cpp \
  ../../../../CPP/Common/CrcReg.cpp \
  ../../../../CPP/Common/C_FileIO.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/NewHandler.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/StringToInt.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \

SRCS_C=\
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/Alloc.c \
  ../../../../C/Bra86.c \
  ../../../../C/CpuArch.c \
  ../../../../C/LzFind.c \
  ../../../../C/LzFindMt.c \
  ../../../../C/LzmaDec.c \
  ../../../../C/LzmaEnc.c \
  ../../../../C/Lzma86Dec.c \
  ../../../../C/Lzma86Enc.c \
  ../../../../C/Threads.c \

StdAfx.h.gch : ../../../myWindows/StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) ../../../myWindows/StdAfx.h -o StdAfx.h.gch
7zCrc.o : ../../../../C/7zCrc.c
	$(CC) $(CFLAGS) ../../../../C/7zCrc.c
7zCrcOpt.o : ../../../../C/7zCrcOpt.c
	$(CC) $(CFLAGS) ../../../../C/7zCrcOpt.c
Alloc.o : ../../../../C/Alloc.c
	$(CC) $(CFLAGS) ../../../../C/Alloc.c
Bra86.o : ../../../../C/Bra86.c
	$(CC) $(CFLAGS) ../../../../C/Bra86.c
CpuArch.o : ../../../../C/CpuArch.c
	$(CC) $(CFLAGS) ../../../../C/CpuArch.c
LzFind.o : ../../../../C/LzFind.c
	$(CC) $(CFLAGS) ../../../../C/LzFind.c
LzFindMt.o : ../../../../C/LzFindMt.c
	$(CC) $(CFLAGS) ../../../../C/LzFindMt.c
LzmaDec.o : ../../../../C/LzmaDec.c
	$(CC) $(CFLAGS) ../../../../C/LzmaDec.c
LzmaEnc.o : ../../../../C/LzmaEnc.c
	$(CC) $(CFLAGS) ../../../../C/LzmaEnc.c
Lzma86Dec.o : ../../../../C/Lzma86Dec.c
	$(CC) $(CFLAGS) ../../../../C/Lzma86Dec.c
Lzma86Enc.o : ../../../../C/Lzma86Enc.c
	$(CC) $(CFLAGS) ../../../../C/Lzma86Enc.c
Threads.o : ../../../../C/Threads.c
	$(CC) $(CFLAGS) ../../../../C/Threads.c
LzmaAlone.o : ../../../../CPP/7zip/Bundles/LzmaCon/LzmaAlone.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Bundles/LzmaCon/LzmaAlone.cpp
CWrappers.o : ../../../../CPP/7zip/Common/CWrappers.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CWrappers.cpp
CreateCoder.o : ../../../../CPP/7zip/Common/CreateCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CreateCoder.cpp
FileStreams.o : ../../../../CPP/7zip/Common/FileStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FileStreams.cpp
FilterCoder.o : ../../../../CPP/7zip/Common/FilterCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilterCoder.cpp
MethodProps.o : ../../../../CPP/7zip/Common/MethodProps.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/MethodProps.cpp
OutBuffer.o : ../../../../CPP/7zip/Common/OutBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OutBuffer.cpp
StreamUtils.o : ../../../../CPP/7zip/Common/StreamUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamUtils.cpp
LzmaDecoder.o : ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
LzmaEncoder.o : ../../../../CPP/7zip/Compress/LzmaEncoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaEncoder.cpp
LzmaRegister.o : ../../../../CPP/7zip/Compress/LzmaRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaRegister.cpp
Bench.o : ../../../../CPP/7zip/UI/Common/Bench.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Bench.cpp
BenchCon.o : ../../../../CPP/7zip/UI/Console/BenchCon.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/BenchCon.cpp
ConsoleClose.o : ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp
CRC.o : ../../../../CPP/Common/CRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CRC.cpp
CommandLineParser.o : ../../../../CPP/Common/CommandLineParser.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CommandLineParser.cpp
CrcReg.o : ../../../../CPP/Common/CrcReg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CrcReg.cpp
C_FileIO.o : ../../../../CPP/Common/C_FileIO.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/C_FileIO.cpp
IntToString.o : ../../../../CPP/Common/IntToString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/IntToString.cpp
MyString.o : ../../../../CPP/Common/MyString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyString.cpp
MyVector.o : ../../../../CPP/Common/MyVector.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyVector.cpp
MyWindows.o : ../../../../CPP/Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyWindows.cpp
NewHandler.o : ../../../../CPP/Common/NewHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/NewHandler.cpp
StringConvert.o : ../../../../CPP/Common/StringConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringConvert.cpp
StringToInt.o : ../../../../CPP/Common/StringToInt.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringToInt.cpp
PropVariant.o : ../../../../CPP/Windows/PropVariant.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariant.cpp
System.o : ../../../../CPP/Windows/System.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/System.cpp
wine_date_and_time.o : ../../../../CPP/myWindows/wine_date_and_time.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_date_and_time.cpp

OBJS=\
 7zCrc.o \
 $(OBJ_CRC32) \
 Alloc.o \
 Bra86.o \
 CpuArch.o \
 LzFind.o \
 LzFindMt.o \
 LzmaDec.o \
 LzmaEnc.o \
 Lzma86Dec.o \
 Lzma86Enc.o \
 Threads.o \
 LzmaAlone.o \
 CWrappers.o \
 CreateCoder.o \
 FileStreams.o \
 FilterCoder.o \
 MethodProps.o \
 OutBuffer.o \
 StreamUtils.o \
 LzmaDecoder.o \
 LzmaEncoder.o \
 LzmaRegister.o \
 Bench.o \
 BenchCon.o \
 ConsoleClose.o \
 CRC.o \
 CommandLineParser.o \
 CrcReg.o \
 C_FileIO.o \
 IntToString.o \
 MyString.o \
 MyVector.o \
 MyWindows.o \
 NewHandler.o \
 StringConvert.o \
 StringToInt.o \
 PropVariant.o \
 System.o \
 wine_date_and_time.o \
 $(OBJ_AES) \

// Main.cpp

#include "StdAfx.h"

#include "../../../Common/MyWindows.h"

#include "../../../Common/MyInitGuid.h"

#include "../../../Common/CommandLineParser.h"
#include "../../../Common/MyException.h"

#ifdef _WIN32
#include "../../../Windows/DLL.h"
#include "../../../Windows/FileDir.h"
#else
#include "myPrivate.h"
#endif
#include "../../../Windows/FileName.h"

#include "../../UI/Common/ExitCode.h"
#include "../../UI/Common/Extract.h"

#include "../../UI/Console/ExtractCallbackConsole.h"
#include "../../UI/Console/List.h"
#include "../../UI/Console/OpenCallbackConsole.h"

#include "../../MyVersion.h"

using namespace NWindows;
using namespace NFile;
// FIXME using namespace NDir;
using namespace NCommandLineParser;

#ifdef _WIN32
HINSTANCE g_hInstance = 0;
#endif
int g_CodePage = -1;
extern CStdOutStream *g_StdStream;

static const char *kCopyrightString =
"\n7-Zip SFX " MY_VERSION_COPYRIGHT_DATE "\n";

static const int kNumSwitches = 6;

namespace NKey {
enum Enum
{
  kHelp1 = 0,
  kHelp2,
  kDisablePercents,
  kYes,
  kPassword,
  kOutputDir
};

}

namespace NRecursedType {
enum EEnum
{
  kRecursed,
  kWildcardOnlyRecursed,
  kNonRecursed
};
}
/*
static const char kRecursedIDChar = 'R';
static const wchar_t *kRecursedPostCharSet = L"0-";

namespace NRecursedPostCharIndex {
  enum EEnum
  {
    kWildcardRecursionOnly = 0,
    kNoRecursion = 1
  };
}

static const char kFileListID = '@';
static const char kImmediateNameID = '!';

static const char kSomeCludePostStringMinSize = 2; // at least <@|!><N>ame must be
static const char kSomeCludeAfterRecursedPostStringMinSize = 2; // at least <@|!><N>ame must be
*/
static const CSwitchForm kSwitchForms[kNumSwitches] =
{
  { "?",  NSwitchType::kSimple },
  { "H",  NSwitchType::kSimple },
  { "BD", NSwitchType::kSimple },
  { "Y",  NSwitchType::kSimple },
  { "P",  NSwitchType::kString, false, 1 },
  { "O",  NSwitchType::kString, false, 1 },
};

static const int kNumCommandForms = 3;

static const NRecursedType::EEnum kCommandRecursedDefault[kNumCommandForms] =
{
  NRecursedType::kRecursed
};

// static const bool kTestExtractRecursedDefault = true;
// static const bool kAddRecursedDefault = false;

static const wchar_t *kUniversalWildcard = L"*";
static const int kCommandIndex = 0;

static const char *kHelpString =
    "\nUsage: 7zSFX [<command>] [<switches>...]\n"
    "\n"
    "<Commands>\n"
    // "  l: List contents of archive\n"
    "  t: Test integrity of archive\n"
    "  x: eXtract files with full pathname (default)\n"
    "<Switches>\n"
    // "  -bd Disable percentage indicator\n"
    "  -o{Directory}: set Output directory\n"
    "  -p{Password}: set Password\n"
    "  -y: assume Yes on all queries\n";


// ---------------------------
// exception messages

static const char *kUserErrorMessage  = "Incorrect command line"; // NExitCode::kUserError
// static const char *kIncorrectListFile = "Incorrect wildcard in listfile";
static const char *kIncorrectWildcardInCommandLine  = "Incorrect wildcard in command line";

// static const CSysString kFileIsNotArchiveMessageBefore = "File \"";
// static const CSysString kFileIsNotArchiveMessageAfter = "\" is not archive";

// static const char *kProcessArchiveMessage = " archive: ";

static const char *kCantFindSFX = " cannot find sfx";

namespace NCommandType
{
  enum EEnum
  {
    kTest = 0,
    kFullExtract,
    kList
  };
}

static const char *g_Commands = "txl";

struct CArchiveCommand
{
  NCommandType::EEnum CommandType;

  NRecursedType::EEnum DefaultRecursedType() const;
};

bool ParseArchiveCommand(const UString &commandString, CArchiveCommand &command)
{
  UString s = commandString;
  s.MakeLower_Ascii();
  if (s.Len() != 1)
    return false;
  if (s[0] >= 0x80)
    return false;
  int index = FindCharPosInString(g_Commands, (char)s[0]);
  if (index < 0)
    return false;
  command.CommandType = (NCommandType::EEnum)index;
  return true;
}

NRecursedType::EEnum CArchiveCommand::DefaultRecursedType() const
{
  return kCommandRecursedDefault[CommandType];
}

void PrintHelp(void)
{
  g_StdOut << kHelpString;
}

static void ShowMessageAndThrowException(const char *message, NExitCode::EEnum code)
{
  g_StdOut << message << endl;
  throw code;
}

static void PrintHelpAndExit() // yyy
{
  PrintHelp();
  ShowMessageAndThrowException(kUserErrorMessage, NExitCode::kUserError);
}

// ------------------------------------------------------------------
// filenames functions

static bool AddNameToCensor(NWildcard::CCensor &wildcardCensor,
    const UString &name, bool include, NRecursedType::EEnum type)
{
  /*
  if (!IsWildcardFilePathLegal(name))
    return false;
  */
  bool isWildcard = DoesNameContainWildcard(name);
  bool recursed = false;

  switch (type)
  {
    case NRecursedType::kWildcardOnlyRecursed:
      recursed = isWildcard;
      break;
    case NRecursedType::kRecursed:
      recursed = true;
      break;
    case NRecursedType::kNonRecursed:
      recursed = false;
      break;
  }
  wildcardCensor.AddPreItem(include, name, recursed, true);
  return true;
}

void AddCommandLineWildcardToCensor(NWildcard::CCensor &wildcardCensor,
    const UString &name, bool include, NRecursedType::EEnum type)
{
  if (!AddNameToCensor(wildcardCensor, name, include, type))
    ShowMessageAndThrowException(kIncorrectWildcardInCommandLine, NExitCode::kUserError);
}

void AddToCensorFromNonSwitchesStrings(NWildcard::CCensor &wildcardCensor,
    const UStringVector & /* nonSwitchStrings */, NRecursedType::EEnum type,
    bool /* thereAreSwitchIncludeWildcards */)
{
  AddCommandLineWildcardToCensor(wildcardCensor, kUniversalWildcard, true, type);
}


#if 0 // #ifndef _WIN32
static void GetArguments(int numArgs, const char *args[], UStringVector &parts)
{
  parts.Clear();
  for (int i = 0; i < numArgs; i++)
  {
    UString s = MultiByteToUnicodeString(args[i]);
    parts.Add(s);
  }
}
#endif

int Main2(
  #ifndef _WIN32
  int numArgs, char *args[]
  #endif
)
{
  #if defined(_WIN32) && !defined(UNDER_CE)
  SetFileApisToOEM();
  #endif
  
  g_StdOut << kCopyrightString;

  UStringVector commandStrings;
  #ifdef _WIN32
  NCommandLineParser::SplitCommandLine(GetCommandLineW(), commandStrings);
  #else
  // GetArguments(numArgs, args, commandStrings);
  mySplitCommandLine(numArgs,args,commandStrings);
  #endif

  #ifdef _WIN32
  
  FString arcPath;
  {
    FString path;
    NDLL::MyGetModuleFileName(path);
    if (!MyGetFullPathName(path, arcPath))
    {
      g_StdOut << "GetFullPathName Error";
      return NExitCode::kFatalError;
    }
  }

  #else
  // After mySplitCommandLine
  showP7zipInfo(&g_StdOut);

  UString arcPath = commandStrings.Front();

  #endif

  commandStrings.Delete(0);

  NCommandLineParser::CParser parser(kNumSwitches);
  try
  {
    parser.ParseStrings(kSwitchForms, commandStrings);
  }
  catch(...)
  {
    PrintHelpAndExit();
  }

  if (parser[NKey::kHelp1].ThereIs || parser[NKey::kHelp2].ThereIs)
  {
    PrintHelp();
    return 0;
  }
  const UStringVector &nonSwitchStrings = parser.NonSwitchStrings;

  int numNonSwitchStrings = nonSwitchStrings.Size();

  CArchiveCommand command;
  if (numNonSwitchStrings == 0)
    command.CommandType = NCommandType::kFullExtract;
  else
  {
    if (numNonSwitchStrings > 1)
      PrintHelpAndExit();
    if (!ParseArchiveCommand(nonSwitchStrings[kCommandIndex], command))
      PrintHelpAndExit();
  }


  NRecursedType::EEnum recursedType;
  recursedType = command.DefaultRecursedType();

  NWildcard::CCensor wildcardCensor;
  
  bool thereAreSwitchIncludeWildcards;
  thereAreSwitchIncludeWildcards = false;

  AddToCensorFromNonSwitchesStrings(wildcardCensor, nonSwitchStrings, recursedType,
      thereAreSwitchIncludeWildcards);

  bool yesToAll = parser[NKey::kYes].ThereIs;

  // NExtractMode::EEnum extractMode;
  // bool isExtractGroupCommand = command.IsFromExtractGroup(extractMode);

  bool passwordEnabled = parser[NKey::kPassword].ThereIs;

  UString password;
  if (passwordEnabled)
    password = parser[NKey::kPassword].PostStrings[0];

  if (!NFind::DoesFileExist(arcPath))
    throw kCantFindSFX;
  
  FString outputDir;
  if (parser[NKey::kOutputDir].ThereIs)
  {
    outputDir = us2fs(parser[NKey::kOutputDir].PostStrings[0]);
    NName::NormalizeDirPathPrefix(outputDir);
  }


  wildcardCensor.AddPathsToCensor(NWildcard::k_RelatPath);
  
  {
    UStringVector v1, v2;
    v1.Add(fs2us(arcPath));
    v2.Add(fs2us(arcPath));
    const NWildcard::CCensorNode &wildcardCensorHead =
      wildcardCensor.Pairs.Front().Head;

    CCodecs *codecs = new CCodecs;
    CMyComPtr<
      #ifdef EXTERNAL_CODECS
      ICompressCodecsInfo
      #else
      IUnknown
      #endif
      > compressCodecsInfo = codecs;
    {
      HRESULT result = codecs->Load();
      if (result != S_OK)
        throw CSystemException(result);
    }

    if (command.CommandType != NCommandType::kList)
    {
      CExtractCallbackConsole *ecs = new CExtractCallbackConsole;
      CMyComPtr<IFolderArchiveExtractCallback> extractCallback = ecs;
      ecs->Init(g_StdStream, &g_StdErr, g_StdStream);

      #ifndef _NO_CRYPTO
      ecs->PasswordIsDefined = passwordEnabled;
      ecs->Password = password;
      #endif

      /*
      COpenCallbackConsole openCallback;
      openCallback.Init(g_StdStream, g_StdStream);

      #ifndef _NO_CRYPTO
      openCallback.PasswordIsDefined = passwordEnabled;
      openCallback.Password = password;
      #endif
      */

      CExtractOptions eo;
      eo.StdOutMode = false;
      eo.YesToAll = yesToAll;
      eo.TestMode = command.CommandType == NCommandType::kTest;
      eo.PathMode = NExtract::NPathMode::kFullPaths;
      eo.OverwriteMode = yesToAll ?
          NExtract::NOverwriteMode::kOverwrite :
          NExtract::NOverwriteMode::kAsk;
      eo.OutputDir = outputDir;

      UString errorMessage;
      CDecompressStat stat;
      HRESULT result = Extract(
          codecs, CObjectVector<COpenType>(), CIntVector(),
          v1, v2,
          wildcardCensorHead,
          eo, ecs, ecs,
          // NULL, // hash
          errorMessage, stat);
      if (!errorMessage.IsEmpty())
      {
        (*g_StdStream) << endl << "Error: " << errorMessage;;
        if (result == S_OK)
          result = E_FAIL;
      }

      if (ecs->NumArcsWithError != 0 || ecs->NumFileErrors != 0)
      {
        if (ecs->NumArcsWithError != 0)
          (*g_StdStream) << endl << "Archive Errors" << endl;
        if (ecs->NumFileErrors != 0)
          (*g_StdStream) << endl << "Sub items Errors: " << ecs->NumFileErrors << endl;
        return NExitCode::kFatalError;
      }
      if (result != S_OK)
        throw CSystemException(result);
    }
    else
    {
      throw CSystemException(E_NOTIMPL);

      /*
      UInt64 numErrors = 0;
      UInt64 numWarnings = 0;
      HRESULT result = ListArchives(
          codecs, CObjectVector<COpenType>(), CIntVector(),
          false, // stdInMode
          v1, v2,
          true, // processAltStreams
          false, // showAltStreams
          wildcardCensorHead,
          true, // enableHeaders
          false, // techMode
          #ifndef _NO_CRYPTO
          passwordEnabled, password,
          #endif
          numErrors, numWarnings);
      if (numErrors > 0)
      {
        g_StdOut << endl << "Errors: " << numErrors;
        return NExitCode::kFatalError;
      }
      if (result != S_OK)
        throw CSystemException(result);
      */
    }
  }
  return 0;
}

include ../../../../makefile.crc32
include ../../../../makefile.machine

TARGET_FLAGS=$(CC_EXE)
LOCAL_LINK=$(LINK_EXE)
LIBS=$(LOCAL_LIBS)

include ../../../../makefile.glb



# WARNING : automatically generated by utils/generate.py

PROG=../../../../bin/7zCon.sfx$(BINSUFFIX)

all: $(PCH_NAME) $(PROG)

LOCAL_FLAGS=$(TARGET_FLAGS) \
  -D_FILE_OFFSET_BITS=64 \
  -D_LARGEFILE_SOURCE \
  -D_REENTRANT \
  -DENV_UNIX \
  -DBREAK_HANDLER \
  -DUNICODE \
  -D_UNICODE \
  -DUNIX_USE_WIN_FILE \
  -DEXTRACT_ONLY \
  -DNO_READ_FROM_CODER \
  -D_SFX \

SRCS=\
  ../../../../CPP/7zip/Archive/7z/7zDecode.cpp \
  ../../../../CPP/7zip/Archive/7z/7zExtract.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHandler.cpp \
  ../../../../CPP/7zip/Archive/7z/7zHeader.cpp \
  ../../../../CPP/7zip/Archive/7z/7zIn.cpp \
  ../../../../CPP/7zip/Archive/7z/7zRegister.cpp \
  ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp \
  ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp \
  ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp \
  ../../../../CPP/7zip/Bundles/SFXCon/SfxCon.cpp \
  ../../../../CPP/7zip/Common/CWrappers.cpp \
  ../../../../CPP/7zip/Common/CreateCoder.cpp \
  ../../../../CPP/7zip/Common/FilePathAutoRename.cpp \
  ../../../../CPP/7zip/Common/FileStreams.cpp \
  ../../../../CPP/7zip/Common/FilterCoder.cpp \
  ../../../../CPP/7zip/Common/InBuffer.cpp \
  ../../../../CPP/7zip/Common/LimitedStreams.cpp \
  ../../../../CPP/7zip/Common/OutBuffer.cpp \
  ../../../../CPP/7zip/Common/ProgressUtils.cpp \
  ../../../../CPP/7zip/Common/StreamBinder.cpp \
  ../../../../CPP/7zip/Common/StreamObjects.cpp \
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Common/VirtThread.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Coder.cpp \
  ../../../../CPP/7zip/Compress/Bcj2Register.cpp \
  ../../../../CPP/7zip/Compress/BcjCoder.cpp \
  ../../../../CPP/7zip/Compress/BcjRegister.cpp \
  ../../../../CPP/7zip/Compress/BranchMisc.cpp \
  ../../../../CPP/7zip/Compress/BranchRegister.cpp \
  ../../../../CPP/7zip/Compress/CopyCoder.cpp \
  ../../../../CPP/7zip/Compress/CopyRegister.cpp \
  ../../../../CPP/7zip/Compress/DeltaFilter.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp \
  ../../../../CPP/7zip/Compress/Lzma2Register.cpp \
  ../../../../CPP/7zip/Compress/LzmaDecoder.cpp \
  ../../../../CPP/7zip/Compress/LzmaRegister.cpp \
  ../../../../CPP/7zip/Compress/PpmdDecoder.cpp \
  ../../../../CPP/7zip/Compress/PpmdRegister.cpp \
  ../../../../CPP/7zip/Crypto/7zAes.cpp \
  ../../../../CPP/7zip/Crypto/7zAesRegister.cpp \
  ../../../../CPP/7zip/Crypto/MyAes.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp \
  ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp \
  ../../../../CPP/7zip/UI/Common/DefaultName.cpp \
  ../../../../CPP/7zip/UI/Common/Extract.cpp \
  ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp \
  ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp \
  ../../../../CPP/7zip/UI/Common/OpenArchive.cpp \
  ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp \
  ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp \
  ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/List.cpp \
  ../../../../CPP/7zip/UI/Console/MainAr.cpp \
  ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp \
  ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp \
  ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp \
  ../../../../CPP/Common/CRC.cpp \
  ../../../../CPP/Common/CommandLineParser.cpp \
  ../../../../CPP/Common/IntToString.cpp \
  ../../../../CPP/Common/MyString.cpp \
  ../../../../CPP/Common/MyVector.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Common/StdInStream.cpp \
  ../../../../CPP/Common/StdOutStream.cpp \
  ../../../../CPP/Common/StringConvert.cpp \
  ../../../../CPP/Common/UTFConvert.cpp \
  ../../../../CPP/Common/Wildcard.cpp \
  ../../../../CPP/Windows/ErrorMsg.cpp \
  ../../../../CPP/Windows/FileDir.cpp \
  ../../../../CPP/Windows/FileFind.cpp \
  ../../../../CPP/Windows/FileIO.cpp \
  ../../../../CPP/Windows/FileName.cpp \
  ../../../../CPP/Windows/PropVariant.cpp \
  ../../../../CPP/Windows/PropVariantConv.cpp \
  ../../../../CPP/Windows/Synchronization.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/myWindows/mySplitCommandLine.cpp \
  ../../../../CPP/myWindows/wine_date_and_time.cpp \

SRCS_C=\
  ../../../../C/7zCrc.c \
  ../../../../C/7zCrcOpt.c \
  ../../../../C/Aes.c \
  ../../../../C/Alloc.c \
  ../../../../C/Bcj2.c \
  ../../../../C/Bra.c \
  ../../../../C/Bra86.c \
  ../../../../C/BraIA64.c \
  ../../../../C/CpuArch.c \
  ../../../../C/Delta.c \
  ../../../../C/Lzma2Dec.c \
  ../../../../C/LzmaDec.c \
  ../../../../C/Ppmd7.c \
  ../../../../C/Ppmd7Dec.c \
  ../../../../C/Sha256.c \
  ../../../../C/Threads.c \

StdAfx.h.gch : ../../../myWindows/StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) ../../../myWindows/StdAfx.h -o StdAfx.h.gch
7zCrc.o : ../../../../C/7zCrc.c
	$(CC) $(CFLAGS) ../../../../C/7zCrc.c
7zCrcOpt.o : ../../../../C/7zCrcOpt.c
	$(CC) $(CFLAGS) ../../../../C/7zCrcOpt.c
Aes.o : ../../../../C/Aes.c
	$(CC) $(CFLAGS) ../../../../C/Aes.c
Alloc.o : ../../../../C/Alloc.c
	$(CC) $(CFLAGS) ../../../../C/Alloc.c
Bcj2.o : ../../../../C/Bcj2.c
	$(CC) $(CFLAGS) ../../../../C/Bcj2.c
Bra.o : ../../../../C/Bra.c
	$(CC) $(CFLAGS) ../../../../C/Bra.c
Bra86.o : ../../../../C/Bra86.c
	$(CC) $(CFLAGS) ../../../../C/Bra86.c
BraIA64.o : ../../../../C/BraIA64.c
	$(CC) $(CFLAGS) ../../../../C/BraIA64.c
CpuArch.o : ../../../../C/CpuArch.c
	$(CC) $(CFLAGS) ../../../../C/CpuArch.c
Delta.o : ../../../../C/Delta.c
	$(CC) $(CFLAGS) ../../../../C/Delta.c
Lzma2Dec.o : ../../../../C/Lzma2Dec.c
	$(CC) $(CFLAGS) ../../../../C/Lzma2Dec.c
LzmaDec.o : ../../../../C/LzmaDec.c
	$(CC) $(CFLAGS) ../../../../C/LzmaDec.c
Ppmd7.o : ../../../../C/Ppmd7.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd7.c
Ppmd7Dec.o : ../../../../C/Ppmd7Dec.c
	$(CC) $(CFLAGS) ../../../../C/Ppmd7Dec.c
Sha256.o : ../../../../C/Sha256.c
	$(CC) $(CFLAGS) ../../../../C/Sha256.c
Threads.o : ../../../../C/Threads.c
	$(CC) $(CFLAGS) ../../../../C/Threads.c
7zDecode.o : ../../../../CPP/7zip/Archive/7z/7zDecode.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zDecode.cpp
7zExtract.o : ../../../../CPP/7zip/Archive/7z/7zExtract.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zExtract.cpp
7zHandler.o : ../../../../CPP/7zip/Archive/7z/7zHandler.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHandler.cpp
7zHeader.o : ../../../../CPP/7zip/Archive/7z/7zHeader.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zHeader.cpp
7zIn.o : ../../../../CPP/7zip/Archive/7z/7zIn.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zIn.cpp
7zRegister.o : ../../../../CPP/7zip/Archive/7z/7zRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/7z/7zRegister.cpp
CoderMixer2.o : ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp
ItemNameUtils.o : ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp
OutStreamWithCRC.o : ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp
SfxCon.o : ../../../../CPP/7zip/Bundles/SFXCon/SfxCon.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Bundles/SFXCon/SfxCon.cpp
CWrappers.o : ../../../../CPP/7zip/Common/CWrappers.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CWrappers.cpp
CreateCoder.o : ../../../../CPP/7zip/Common/CreateCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/CreateCoder.cpp
FilePathAutoRename.o : ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilePathAutoRename.cpp
FileStreams.o : ../../../../CPP/7zip/Common/FileStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FileStreams.cpp
FilterCoder.o : ../../../../CPP/7zip/Common/FilterCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/FilterCoder.cpp
InBuffer.o : ../../../../CPP/7zip/Common/InBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/InBuffer.cpp
LimitedStreams.o : ../../../../CPP/7zip/Common/LimitedStreams.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/LimitedStreams.cpp
OutBuffer.o : ../../../../CPP/7zip/Common/OutBuffer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/OutBuffer.cpp
ProgressUtils.o : ../../../../CPP/7zip/Common/ProgressUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/ProgressUtils.cpp
StreamBinder.o : ../../../../CPP/7zip/Common/StreamBinder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamBinder.cpp
StreamObjects.o : ../../../../CPP/7zip/Common/StreamObjects.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamObjects.cpp
StreamUtils.o : ../../../../CPP/7zip/Common/StreamUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamUtils.cpp
VirtThread.o : ../../../../CPP/7zip/Common/VirtThread.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/VirtThread.cpp
Bcj2Coder.o : ../../../../CPP/7zip/Compress/Bcj2Coder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Bcj2Coder.cpp
Bcj2Register.o : ../../../../CPP/7zip/Compress/Bcj2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Bcj2Register.cpp
BcjCoder.o : ../../../../CPP/7zip/Compress/BcjCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BcjCoder.cpp
BcjRegister.o : ../../../../CPP/7zip/Compress/BcjRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BcjRegister.cpp
BranchMisc.o : ../../../../CPP/7zip/Compress/BranchMisc.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BranchMisc.cpp
BranchRegister.o : ../../../../CPP/7zip/Compress/BranchRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/BranchRegister.cpp
CopyCoder.o : ../../../../CPP/7zip/Compress/CopyCoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyCoder.cpp
CopyRegister.o : ../../../../CPP/7zip/Compress/CopyRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CopyRegister.cpp
DeltaFilter.o : ../../../../CPP/7zip/Compress/DeltaFilter.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DeltaFilter.cpp
Lzma2Decoder.o : ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Decoder.cpp
Lzma2Register.o : ../../../../CPP/7zip/Compress/Lzma2Register.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzma2Register.cpp
LzmaDecoder.o : ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaDecoder.cpp
LzmaRegister.o : ../../../../CPP/7zip/Compress/LzmaRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/LzmaRegister.cpp
PpmdDecoder.o : ../../../../CPP/7zip/Compress/PpmdDecoder.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdDecoder.cpp
PpmdRegister.o : ../../../../CPP/7zip/Compress/PpmdRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/PpmdRegister.cpp
7zAes.o : ../../../../CPP/7zip/Crypto/7zAes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/7zAes.cpp
7zAesRegister.o : ../../../../CPP/7zip/Crypto/7zAesRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/7zAesRegister.cpp
MyAes.o : ../../../../CPP/7zip/Crypto/MyAes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Crypto/MyAes.cpp
ArchiveExtractCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp
ArchiveOpenCallback.o : ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp
DefaultName.o : ../../../../CPP/7zip/UI/Common/DefaultName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/DefaultName.cpp
Extract.o : ../../../../CPP/7zip/UI/Common/Extract.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/Extract.cpp
ExtractingFilePath.o : ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp
LoadCodecs.o : ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/LoadCodecs.cpp
OpenArchive.o : ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/OpenArchive.cpp
PropIDUtils.o : ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Common/PropIDUtils.cpp
ConsoleClose.o : ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/ConsoleClose.cpp
ExtractCallbackConsole.o : ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp
List.o : ../../../../CPP/7zip/UI/Console/List.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/List.cpp
MainAr.o : ../../../../CPP/7zip/UI/Console/MainAr.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/MainAr.cpp
OpenCallbackConsole.o : ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp
PercentPrinter.o : ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/PercentPrinter.cpp
UserInputUtils.o : ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/UI/Console/UserInputUtils.cpp
CRC.o : ../../../../CPP/Common/CRC.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CRC.cpp
CommandLineParser.o : ../../../../CPP/Common/CommandLineParser.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/CommandLineParser.cpp
IntToString.o : ../../../../CPP/Common/IntToString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/IntToString.cpp
MyString.o : ../../../../CPP/Common/MyString.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyString.cpp
MyVector.o : ../../../../CPP/Common/MyVector.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyVector.cpp
MyWindows.o : ../../../../CPP/Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyWindows.cpp
StdInStream.o : ../../../../CPP/Common/StdInStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StdInStream.cpp
StdOutStream.o : ../../../../CPP/Common/StdOutStream.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StdOutStream.cpp
StringConvert.o : ../../../../CPP/Common/StringConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/StringConvert.cpp
UTFConvert.o : ../../../../CPP/Common/UTFConvert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/UTFConvert.cpp
Wildcard.o : ../../../../CPP/Common/Wildcard.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/Wildcard.cpp
ErrorMsg.o : ../../../../CPP/Windows/ErrorMsg.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/ErrorMsg.cpp
FileDir.o : ../../../../CPP/Windows/FileDir.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileDir.cpp
FileFind.o : ../../../../CPP/Windows/FileFind.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileFind.cpp
FileIO.o : ../../../../CPP/Windows/FileIO.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileIO.cpp
FileName.o : ../../../../CPP/Windows/FileName.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/FileName.cpp
PropVariant.o : ../../../../CPP/Windows/PropVariant.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariant.cpp
PropVariantConv.o : ../../../../CPP/Windows/PropVariantConv.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/PropVariantConv.cpp
Synchronization.o : ../../../../CPP/Windows/Synchronization.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/Synchronization.cpp
System.o : ../../../../CPP/Windows/System.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/System.cpp
mySplitCommandLine.o : ../../../../CPP/myWindows/mySplitCommandLine.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/mySplitCommandLine.cpp
wine_date_and_time.o : ../../../../CPP/myWindows/wine_date_and_time.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/myWindows/wine_date_and_time.cpp

OBJS=\
 7zCrc.o \
 $(OBJ_CRC32) \
 Aes.o \
 Alloc.o \
 Bcj2.o \
 Bra.o \
 Bra86.o \
 BraIA64.o \
 CpuArch.o \
 Delta.o \
 Lzma2Dec.o \
 LzmaDec.o \
 Ppmd7.o \
 Ppmd7Dec.o \
 Sha256.o \
 Threads.o \
 7zDecode.o \
 7zExtract.o \
 7zHandler.o \
 7zHeader.o \
 7zIn.o \
 7zRegister.o \
 CoderMixer2.o \
 ItemNameUtils.o \
 OutStreamWithCRC.o \
 SfxCon.o \
 CWrappers.o \
 CreateCoder.o \
 FilePathAutoRename.o \
 FileStreams.o \
 FilterCoder.o \
 InBuffer.o \
 LimitedStreams.o \
 OutBuffer.o \
 ProgressUtils.o \
 StreamBinder.o \
 StreamObjects.o \
 StreamUtils.o \
 VirtThread.o \
 Bcj2Coder.o \
 Bcj2Register.o \
 BcjCoder.o \
 BcjRegister.o \
 BranchMisc.o \
 BranchRegister.o \
 CopyCoder.o \
 CopyRegister.o \
 DeltaFilter.o \
 Lzma2Decoder.o \
 Lzma2Register.o \
 LzmaDecoder.o \
 LzmaRegister.o \
 PpmdDecoder.o \
 PpmdRegister.o \
 7zAes.o \
 7zAesRegister.o \
 MyAes.o \
 ArchiveExtractCallback.o \
 ArchiveOpenCallback.o \
 DefaultName.o \
 Extract.o \
 ExtractingFilePath.o \
 LoadCodecs.o \
 OpenArchive.o \
 PropIDUtils.o \
 ConsoleClose.o \
 ExtractCallbackConsole.o \
 List.o \
 MainAr.o \
 OpenCallbackConsole.o \
 PercentPrinter.o \
 UserInputUtils.o \
 CRC.o \
 CommandLineParser.o \
 IntToString.o \
 MyString.o \
 MyVector.o \
 MyWindows.o \
 StdInStream.o \
 StdOutStream.o \
 StringConvert.o \
 UTFConvert.o \
 Wildcard.o \
 ErrorMsg.o \
 FileDir.o \
 FileFind.o \
 FileIO.o \
 FileName.o \
 PropVariant.o \
 PropVariantConv.o \
 Synchronization.o \
 System.o \
 mySplitCommandLine.o \
 wine_date_and_time.o \
 $(OBJ_AES) \

cmake_minimum_required(VERSION 2.6)

project(p7zip)

SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/bin
    CACHE STRING "Where binaries and .dll files go" FORCE)
    

IF(HAVE_WCHAR_H)
  OPTION(HAVE_UNICODE_WCHAR "Enable Unicode Support" YES)
  MARK_AS_ADVANCED(HAVE_UNICODE_WCHAR)
ELSE(HAVE_WCHAR_H)
  SET(HAVE_UNICODE_WCHAR 0)
ENDIF(HAVE_WCHAR_H)

SET(HAVE_PTHREADS 0)
FIND_PACKAGE(Threads)
IF(WIN32 OR CMAKE_USE_PTHREADS_INIT)
  SET(HAVE_PTHREADS 1)
ENDIF(WIN32 OR CMAKE_USE_PTHREADS_INIT)

add_definitions(-DENV_HAVE_GCCVISIBILITYPATCH)

SET(CMAKE_CXX_FLAGS "-fvisibility=hidden -fvisibility-inlines-hidden")

add_subdirectory(7za)

add_subdirectory(7z_)

add_subdirectory(7zr)

add_subdirectory(Format7zFree  bin)

find_package(wxWidgets COMPONENTS core base adv)

if(wxWidgets_FOUND)

	add_subdirectory(7zG)

	add_subdirectory(7zFM)

else(wxWidgets_FOUND)
	message("Warning : wxWidgets not found")
endif(wxWidgets_FOUND)




doit()
{
	cd ..
	rm -fr "P7ZIP.$1"
	mkdir  "P7ZIP.$1"
	cd     "P7ZIP.$1"

	cmake -G "$2" -DCMAKE_BUILD_TYPE=Debug  ../CMAKE/
	#cmake -G "$2" -DCMAKE_BUILD_TYPE=Release  ../CMAKE/
}

CURDIR=$PWD

cd $CURDIR
doit "Unix" "Unix Makefiles"

cd $CURDIR
doit "codeblocks" "CodeBlocks - Unix Makefiles"

#cd $CURDIR
#doit "KDevelop3" "KDevelop3"

cd $CURDIR
doit "EclipseCDT4" "Eclipse CDT4 - Unix Makefiles"

cd $CURDIR
doit "ninja" "Ninja"


doit()
{
	cd ..
	rm -fr "P7ZIP.$1"
	mkdir  "P7ZIP.$1"
	cd     "P7ZIP.$1"

	cmake -G "$2" -DCMAKE_BUILD_TYPE=Debug  ../CMAKE/
	#cmake -G "$2" -DCMAKE_BUILD_TYPE=Release  ../CMAKE/
}

CURDIR=$PWD

cd $CURDIR
CMAKE_OSX_ARCHITECTURES=i386
export CMAKE_OSX_ARCHITECTURES
doit "Xcode" "Xcode"



# WARNING : automatically generated by utils/generate.py
cmake_minimum_required(VERSION 2.8)

include_directories(
  "../../../myWindows"
  "../../../"
  "../../../include_windows"
)

add_definitions( -DLANG -DNEW_FOLDER_INTERFACE -DEXTERNAL_CODECS -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_REENTRANT -DENV_UNIX -DBREAK_HANDLER -DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE)

IF(APPLE)
  add_definitions(-DENV_MACOSX)
  FIND_LIBRARY(COREFOUNDATION_LIBRARY CoreFoundation )
ENDIF(APPLE)

add_executable(7zFM_do_not_use

  "../../../../C/7zCrc.c"
  "../../../../C/7zCrcOpt.c"
  "../../../../C/Alloc.c"
  "../../../../C/CpuArch.c"
  "../../../../C/Sha256.c"
  "../../../../C/Sort.c"
  "../../../../C/Threads.c"
  "../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp"
  "../../../../CPP/7zip/Common/CreateCoder.cpp"
  "../../../../CPP/7zip/Common/FilePathAutoRename.cpp"
  "../../../../CPP/7zip/Common/FileStreams.cpp"
  "../../../../CPP/7zip/Common/FilterCoder.cpp"
  "../../../../CPP/7zip/Common/LimitedStreams.cpp"
  "../../../../CPP/7zip/Common/MethodProps.cpp"
  "../../../../CPP/7zip/Common/ProgressUtils.cpp"
  "../../../../CPP/7zip/Common/PropId.cpp"
  "../../../../CPP/7zip/Common/StreamObjects.cpp"
  "../../../../CPP/7zip/Common/StreamUtils.cpp"
  "../../../../CPP/7zip/Common/UniqBlocks.cpp"
  "../../../../CPP/7zip/Compress/CopyCoder.cpp"
  "../../../../CPP/7zip/UI/Agent/Agent.cpp"
  "../../../../CPP/7zip/UI/Agent/AgentOut.cpp"
  "../../../../CPP/7zip/UI/Agent/AgentProxy.cpp"
  "../../../../CPP/7zip/UI/Agent/ArchiveFolder.cpp"
  "../../../../CPP/7zip/UI/Agent/ArchiveFolderOpen.cpp"
  "../../../../CPP/7zip/UI/Agent/ArchiveFolderOut.cpp"
  "../../../../CPP/7zip/UI/Agent/UpdateCallbackAgent.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveName.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp"
  "../../../../CPP/7zip/UI/Common/CompressCall.cpp"
  "../../../../CPP/7zip/UI/Common/DefaultName.cpp"
  "../../../../CPP/7zip/UI/Common/EnumDirItems.cpp"
  "../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp"
  "../../../../CPP/7zip/UI/Common/HashCalc.cpp"
  "../../../../CPP/7zip/UI/Common/LoadCodecs.cpp"
  "../../../../CPP/7zip/UI/Common/OpenArchive.cpp"
  "../../../../CPP/7zip/UI/Common/PropIDUtils.cpp"
  "../../../../CPP/7zip/UI/Common/SetProperties.cpp"
  "../../../../CPP/7zip/UI/Common/SortUtils.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateAction.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateCallback.cpp"
  "../../../../CPP/7zip/UI/Common/UpdatePair.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateProduce.cpp"
  "../../../../CPP/7zip/UI/Common/WorkDir.cpp"
  "../../../../CPP/7zip/UI/Common/ZipRegistry.cpp"
  "../../../../CPP/7zip/UI/FileManager/App.cpp"
  "../../../../CPP/7zip/UI/FileManager/ClassDefs.cpp"
  "../../../../CPP/7zip/UI/FileManager/ComboDialog.cpp"
  "../../../../CPP/7zip/UI/FileManager/ComboDialog_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/CopyDialog.cpp"
  "../../../../CPP/7zip/UI/FileManager/CopyDialog_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/ExtractCallback.cpp"
  "../../../../CPP/7zip/UI/FileManager/FM.cpp"
  "../../../../CPP/7zip/UI/FileManager/FM_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/FSDrives.cpp"
  "../../../../CPP/7zip/UI/FileManager/FSFolder.cpp"
  "../../../../CPP/7zip/UI/FileManager/FSFolderCopy.cpp"
  "../../../../CPP/7zip/UI/FileManager/FileFolderPluginOpen.cpp"
  "../../../../CPP/7zip/UI/FileManager/FormatUtils.cpp"
  "../../../../CPP/7zip/UI/FileManager/LangUtils.cpp"
  "../../../../CPP/7zip/UI/FileManager/ListViewDialog.cpp"
  "../../../../CPP/7zip/UI/FileManager/ListViewDialog_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/MessagesDialog.cpp"
  "../../../../CPP/7zip/UI/FileManager/MessagesDialog_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/MyLoadMenu.cpp"
  "../../../../CPP/7zip/UI/FileManager/OpenCallback.cpp"
  "../../../../CPP/7zip/UI/FileManager/OverwriteDialog.cpp"
  "../../../../CPP/7zip/UI/FileManager/OverwriteDialog_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/Panel.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelCopy.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelCrc.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelFolderChange.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelItemOpen.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelItems.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelListNotify.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelMenu.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelOperations.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelSelect.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelSort.cpp"
  "../../../../CPP/7zip/UI/FileManager/PanelSplitFile.cpp"
  "../../../../CPP/7zip/UI/FileManager/PasswordDialog.cpp"
  "../../../../CPP/7zip/UI/FileManager/PasswordDialog_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/ProgramLocation.cpp"
  "../../../../CPP/7zip/UI/FileManager/ProgressDialog2.cpp"
  "../../../../CPP/7zip/UI/FileManager/ProgressDialog2_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/PropertyName.cpp"
  "../../../../CPP/7zip/UI/FileManager/RegistryUtils.cpp"
  "../../../../CPP/7zip/UI/FileManager/RootFolder.cpp"
  "../../../../CPP/7zip/UI/FileManager/SplitDialog.cpp"
  "../../../../CPP/7zip/UI/FileManager/SplitDialog_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/SplitUtils.cpp"
  "../../../../CPP/7zip/UI/FileManager/StringUtils.cpp"
  "../../../../CPP/7zip/UI/FileManager/SysIconUtils.cpp"
  "../../../../CPP/7zip/UI/FileManager/TextPairs.cpp"
  "../../../../CPP/7zip/UI/FileManager/UpdateCallback100.cpp"
  "../../../../CPP/7zip/UI/FileManager/ViewSettings.cpp"
  "../../../../CPP/7zip/UI/FileManager/wxFM.cpp"
  "../../../../CPP/7zip/UI/GUI/HashGUI.cpp"
  "../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI2.cpp"
  "../../../../CPP/Common/CRC.cpp"
  "../../../../CPP/Common/CrcReg.cpp"
  "../../../../CPP/Common/IntToString.cpp"
  "../../../../CPP/Common/Lang.cpp"
  "../../../../CPP/Common/MyString.cpp"
  "../../../../CPP/Common/MyVector.cpp"
  "../../../../CPP/Common/MyWindows.cpp"
  "../../../../CPP/Common/NewHandler.cpp"
  "../../../../CPP/Common/StringConvert.cpp"
  "../../../../CPP/Common/StringToInt.cpp"
  "../../../../CPP/Common/TextConfig.cpp"
  "../../../../CPP/Common/UTFConvert.cpp"
  "../../../../CPP/Common/Wildcard.cpp"
  "../../../../CPP/Windows/Clipboard.cpp"
  "../../../../CPP/Windows/Control/Controls.cpp"
  "../../../../CPP/Windows/Control/Dialog.cpp"
  "../../../../CPP/Windows/Control/Window2.cpp"
  "../../../../CPP/Windows/DLL.cpp"
  "../../../../CPP/Windows/ErrorMsg.cpp"
  "../../../../CPP/Windows/FileDir.cpp"
  "../../../../CPP/Windows/FileFind.cpp"
  "../../../../CPP/Windows/FileIO.cpp"
  "../../../../CPP/Windows/FileName.cpp"
  "../../../../CPP/Windows/PropVariant.cpp"
  "../../../../CPP/Windows/PropVariantConv.cpp"
  "../../../../CPP/Windows/Registry.cpp"
  "../../../../CPP/Windows/Synchronization.cpp"
  "../../../../CPP/Windows/System.cpp"
  "../../../../CPP/Windows/TimeUtils.cpp"
  "../../../../CPP/Windows/Window.cpp"
  "../../../../CPP/myWindows/wine_GetXXXDefaultLangID.cpp"
  "../../../../CPP/myWindows/wine_date_and_time.cpp"
)


IF(APPLE)
  add_definitions(-DENV_MACOSX  -D__WXMAC__)
ENDIF(APPLE)

find_package(wxWidgets COMPONENTS core base adv REQUIRED)

find_library(DL_LIB dl)

include( ${wxWidgets_USE_FILE} )

link_directories(${DL_LIB_PATH})

IF(APPLE)
   TARGET_LINK_LIBRARIES(7zFM_do_not_use ${COREFOUNDATION_LIBRARY} ${wxWidgets_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT})
ELSE(APPLE)
  IF(HAVE_PTHREADS)
   TARGET_LINK_LIBRARIES(7zFM_do_not_use ${wxWidgets_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT} dl)
  ENDIF(HAVE_PTHREADS)
ENDIF(APPLE)



# WARNING : automatically generated by utils/generate.py
cmake_minimum_required(VERSION 2.8)

include_directories(
  "../../../myWindows"
  "../../../"
  "../../../include_windows"
)

add_definitions( -DLANG -DEXTERNAL_CODECS -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_REENTRANT -DENV_UNIX -DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE)

IF(APPLE)
  add_definitions(-DENV_MACOSX)
  FIND_LIBRARY(COREFOUNDATION_LIBRARY CoreFoundation )
ENDIF(APPLE)

add_executable(7zG

  "../../../../C/7zCrc.c"
  "../../../../C/7zCrcOpt.c"
  "../../../../C/Alloc.c"
  "../../../../C/CpuArch.c"
  "../../../../C/Threads.c"
  "../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp"
  "../../../../CPP/7zip/Common/CreateCoder.cpp"
  "../../../../CPP/7zip/Common/FilePathAutoRename.cpp"
  "../../../../CPP/7zip/Common/FileStreams.cpp"
  "../../../../CPP/7zip/Common/FilterCoder.cpp"
  "../../../../CPP/7zip/Common/LimitedStreams.cpp"
  "../../../../CPP/7zip/Common/MethodProps.cpp"
  "../../../../CPP/7zip/Common/ProgressUtils.cpp"
  "../../../../CPP/7zip/Common/PropId.cpp"
  "../../../../CPP/7zip/Common/StreamObjects.cpp"
  "../../../../CPP/7zip/Common/StreamUtils.cpp"
  "../../../../CPP/7zip/Common/UniqBlocks.cpp"
  "../../../../CPP/7zip/Compress/CopyCoder.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp"
  "../../../../CPP/7zip/UI/Common/Bench.cpp"
  "../../../../CPP/7zip/UI/Common/DefaultName.cpp"
  "../../../../CPP/7zip/UI/Common/EnumDirItems.cpp"
  "../../../../CPP/7zip/UI/Common/Extract.cpp"
  "../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp"
  "../../../../CPP/7zip/UI/Common/HashCalc.cpp"
  "../../../../CPP/7zip/UI/Common/LoadCodecs.cpp"
  "../../../../CPP/7zip/UI/Common/OpenArchive.cpp"
  "../../../../CPP/7zip/UI/Common/PropIDUtils.cpp"
  "../../../../CPP/7zip/UI/Common/SetProperties.cpp"
  "../../../../CPP/7zip/UI/Common/SortUtils.cpp"
  "../../../../CPP/7zip/UI/Common/TempFiles.cpp"
  "../../../../CPP/7zip/UI/Common/Update.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateAction.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateCallback.cpp"
  "../../../../CPP/7zip/UI/Common/UpdatePair.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateProduce.cpp"
  "../../../../CPP/7zip/UI/Common/WorkDir.cpp"
  "../../../../CPP/7zip/UI/Common/ZipRegistry.cpp"
  "../../../../CPP/7zip/UI/Explorer/MyMessages.cpp"
  "../../../../CPP/7zip/UI/FileManager/ExtractCallback.cpp"
  "../../../../CPP/7zip/UI/FileManager/FormatUtils.cpp"
  "../../../../CPP/7zip/UI/FileManager/LangUtils.cpp"
  "../../../../CPP/7zip/UI/FileManager/OverwriteDialog.cpp"
  "../../../../CPP/7zip/UI/FileManager/OverwriteDialog_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/PasswordDialog.cpp"
  "../../../../CPP/7zip/UI/FileManager/PasswordDialog_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/ProgramLocation.cpp"
  "../../../../CPP/7zip/UI/FileManager/PropertyName.cpp"
  "../../../../CPP/7zip/UI/FileManager/ProgressDialog2.cpp"
  "../../../../CPP/7zip/UI/FileManager/ProgressDialog2_rc.cpp"
  "../../../../CPP/7zip/UI/FileManager/SplitUtils.cpp"
  "../../../../CPP/7zip/UI/FileManager/StringUtils.cpp"
  "../../../../CPP/7zip/UI/GUI/BenchmarkDialog.cpp"
  "../../../../CPP/7zip/UI/GUI/BenchmarkDialog_rc.cpp"
  "../../../../CPP/7zip/UI/GUI/CompressDialog.cpp"
  "../../../../CPP/7zip/UI/GUI/CompressDialog_rc.cpp"
  "../../../../CPP/7zip/UI/GUI/ExtractDialog.cpp"
  "../../../../CPP/7zip/UI/GUI/ExtractDialog_rc.cpp"
  "../../../../CPP/7zip/UI/GUI/ExtractGUI.cpp"
  "../../../../CPP/7zip/UI/GUI/GUI.cpp"
  "../../../../CPP/7zip/UI/GUI/HashGUI.cpp"
  "../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI.cpp"
  "../../../../CPP/7zip/UI/GUI/UpdateCallbackGUI2.cpp"
  "../../../../CPP/7zip/UI/GUI/UpdateGUI.cpp"
  "../../../../CPP/7zip/UI/GUI/wxGUI.cpp"
  "../../../../CPP/Common/CRC.cpp"
  "../../../../CPP/Common/CommandLineParser.cpp"
  "../../../../CPP/Common/IntToString.cpp"
  "../../../../CPP/Common/Lang.cpp"
  "../../../../CPP/Common/ListFileUtils.cpp"
  "../../../../CPP/Common/MyString.cpp"
  "../../../../CPP/Common/MyVector.cpp"
  "../../../../CPP/Common/MyWindows.cpp"
  "../../../../CPP/Common/NewHandler.cpp"
  "../../../../CPP/Common/StringConvert.cpp"
  "../../../../CPP/Common/StringToInt.cpp"
  "../../../../CPP/Common/UTFConvert.cpp"
  "../../../../CPP/Common/Wildcard.cpp"
  "../../../../CPP/Windows/Control/Controls.cpp"
  "../../../../CPP/Windows/Control/Dialog.cpp"
  "../../../../CPP/Windows/DLL.cpp"
  "../../../../CPP/Windows/ErrorMsg.cpp"
  "../../../../CPP/Windows/FileDir.cpp"
  "../../../../CPP/Windows/FileFind.cpp"
  "../../../../CPP/Windows/FileIO.cpp"
  "../../../../CPP/Windows/FileName.cpp"
  "../../../../CPP/Windows/PropVariant.cpp"
  "../../../../CPP/Windows/PropVariantConv.cpp"
  "../../../../CPP/Windows/Registry.cpp"
  "../../../../CPP/Windows/Synchronization.cpp"
  "../../../../CPP/Windows/System.cpp"
  "../../../../CPP/Windows/TimeUtils.cpp"
  "../../../../CPP/Windows/Window.cpp"
  "../../../../CPP/myWindows/wine_GetXXXDefaultLangID.cpp"
  "../../../../CPP/myWindows/wine_date_and_time.cpp"
)


IF(APPLE)
  add_definitions(-DENV_MACOSX  -D__WXMAC__)
ENDIF(APPLE)

find_package(wxWidgets COMPONENTS core base adv REQUIRED)

find_library(DL_LIB dl)

include( ${wxWidgets_USE_FILE} )

link_directories(${DL_LIB_PATH})

IF(APPLE)
   TARGET_LINK_LIBRARIES(7zG ${COREFOUNDATION_LIBRARY} ${wxWidgets_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT})
ELSE(APPLE)
  IF(HAVE_PTHREADS)
   TARGET_LINK_LIBRARIES(7zG ${wxWidgets_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT} dl)
  ENDIF(HAVE_PTHREADS)
ENDIF(APPLE)



# WARNING : automatically generated by utils/generate.py
cmake_minimum_required(VERSION 2.8)

include_directories(
  "../../../myWindows"
  "../../../"
  "../../../include_windows"
)

add_definitions( -DEXTERNAL_CODECS -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_REENTRANT -DENV_UNIX -DBREAK_HANDLER -DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE)

IF(APPLE)
  add_definitions(-DENV_MACOSX)
  FIND_LIBRARY(COREFOUNDATION_LIBRARY CoreFoundation )
ENDIF(APPLE)

add_executable(7z_

  "../../../../C/7zCrc.c"
  "../../../../C/7zCrcOpt.c"
  "../../../../C/Alloc.c"
  "../../../../C/CpuArch.c"
  "../../../../C/Threads.c"
  "../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp"
  "../../../../CPP/7zip/Common/CreateCoder.cpp"
  "../../../../CPP/7zip/Common/FilePathAutoRename.cpp"
  "../../../../CPP/7zip/Common/FileStreams.cpp"
  "../../../../CPP/7zip/Common/FilterCoder.cpp"
  "../../../../CPP/7zip/Common/LimitedStreams.cpp"
  "../../../../CPP/7zip/Common/MethodProps.cpp"
  "../../../../CPP/7zip/Common/ProgressUtils.cpp"
  "../../../../CPP/7zip/Common/PropId.cpp"
  "../../../../CPP/7zip/Common/StreamObjects.cpp"
  "../../../../CPP/7zip/Common/StreamUtils.cpp"
  "../../../../CPP/7zip/Common/UniqBlocks.cpp"
  "../../../../CPP/7zip/Compress/CopyCoder.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp"
  "../../../../CPP/7zip/UI/Common/Bench.cpp"
  "../../../../CPP/7zip/UI/Common/DefaultName.cpp"
  "../../../../CPP/7zip/UI/Common/EnumDirItems.cpp"
  "../../../../CPP/7zip/UI/Common/Extract.cpp"
  "../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp"
  "../../../../CPP/7zip/UI/Common/HashCalc.cpp"
  "../../../../CPP/7zip/UI/Common/LoadCodecs.cpp"
  "../../../../CPP/7zip/UI/Common/OpenArchive.cpp"
  "../../../../CPP/7zip/UI/Common/PropIDUtils.cpp"
  "../../../../CPP/7zip/UI/Common/SetProperties.cpp"
  "../../../../CPP/7zip/UI/Common/SortUtils.cpp"
  "../../../../CPP/7zip/UI/Common/TempFiles.cpp"
  "../../../../CPP/7zip/UI/Common/Update.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateAction.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateCallback.cpp"
  "../../../../CPP/7zip/UI/Common/UpdatePair.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateProduce.cpp"
  "../../../../CPP/7zip/UI/Console/BenchCon.cpp"
  "../../../../CPP/7zip/UI/Console/ConsoleClose.cpp"
  "../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp"
  "../../../../CPP/7zip/UI/Console/HashCon.cpp"
  "../../../../CPP/7zip/UI/Console/List.cpp"
  "../../../../CPP/7zip/UI/Console/Main.cpp"
  "../../../../CPP/7zip/UI/Console/MainAr.cpp"
  "../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp"
  "../../../../CPP/7zip/UI/Console/PercentPrinter.cpp"
  "../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp"
  "../../../../CPP/7zip/UI/Console/UserInputUtils.cpp"
  "../../../../CPP/Common/CRC.cpp"
  "../../../../CPP/Common/CommandLineParser.cpp"
  "../../../../CPP/Common/IntToString.cpp"
  "../../../../CPP/Common/ListFileUtils.cpp"
  "../../../../CPP/Common/MyString.cpp"
  "../../../../CPP/Common/MyVector.cpp"
  "../../../../CPP/Common/MyWindows.cpp"
  "../../../../CPP/Common/NewHandler.cpp"
  "../../../../CPP/Common/StdInStream.cpp"
  "../../../../CPP/Common/StdOutStream.cpp"
  "../../../../CPP/Common/StringConvert.cpp"
  "../../../../CPP/Common/StringToInt.cpp"
  "../../../../CPP/Common/UTFConvert.cpp"
  "../../../../CPP/Common/Wildcard.cpp"
  "../../../../CPP/Windows/DLL.cpp"
  "../../../../CPP/Windows/ErrorMsg.cpp"
  "../../../../CPP/Windows/FileDir.cpp"
  "../../../../CPP/Windows/FileFind.cpp"
  "../../../../CPP/Windows/FileIO.cpp"
  "../../../../CPP/Windows/FileName.cpp"
  "../../../../CPP/Windows/PropVariant.cpp"
  "../../../../CPP/Windows/PropVariantConv.cpp"
  "../../../../CPP/Windows/System.cpp"
  "../../../../CPP/Windows/TimeUtils.cpp"
  "../../../../CPP/myWindows/myAddExeFlag.cpp"
  "../../../../CPP/myWindows/mySplitCommandLine.cpp"
  "../../../../CPP/myWindows/wine_date_and_time.cpp"
)


find_library(DL_LIB dl)

link_directories(${DL_LIB_PATH})

IF(APPLE)
   TARGET_LINK_LIBRARIES(7z_ ${COREFOUNDATION_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
ELSE(APPLE)
  IF(HAVE_PTHREADS)
   TARGET_LINK_LIBRARIES(7z_ ${CMAKE_THREAD_LIBS_INIT} dl)
  ENDIF(HAVE_PTHREADS)
ENDIF(APPLE)



# WARNING : automatically generated by utils/generate.py
cmake_minimum_required(VERSION 2.8)

include_directories(
  "../../../myWindows"
  "../../../"
  "../../../include_windows"
)

add_definitions( -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_REENTRANT -DENV_UNIX -DBREAK_HANDLER -DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE)

IF(APPLE)
  add_definitions(-DENV_MACOSX)
  FIND_LIBRARY(COREFOUNDATION_LIBRARY CoreFoundation )
ENDIF(APPLE)

add_executable(7za

  "../../../../C/7zCrc.c"
  "../../../../C/7zCrcOpt.c"
  "../../../../C/7zStream.c"
  "../../../../C/Aes.c"
  "../../../../C/Alloc.c"
  "../../../../C/Bcj2.c"
  "../../../../C/Bcj2Enc.c"
  "../../../../C/Bra.c"
  "../../../../C/Bra86.c"
  "../../../../C/BraIA64.c"
  "../../../../C/BwtSort.c"
  "../../../../C/CpuArch.c"
  "../../../../C/Delta.c"
  "../../../../C/HuffEnc.c"
  "../../../../C/LzFind.c"
  "../../../../C/LzFindMt.c"
  "../../../../C/Lzma2Dec.c"
  "../../../../C/Lzma2Enc.c"
  "../../../../C/LzmaDec.c"
  "../../../../C/LzmaEnc.c"
  "../../../../C/MtCoder.c"
  "../../../../C/Ppmd7.c"
  "../../../../C/Ppmd7Dec.c"
  "../../../../C/Ppmd7Enc.c"
  "../../../../C/Ppmd8.c"
  "../../../../C/Ppmd8Dec.c"
  "../../../../C/Ppmd8Enc.c"
  "../../../../C/Sha1.c"
  "../../../../C/Sha256.c"
  "../../../../C/Sort.c"
  "../../../../C/Threads.c"
  "../../../../C/Xz.c"
  "../../../../C/XzCrc64.c"
  "../../../../C/XzCrc64Opt.c"
  "../../../../C/XzDec.c"
  "../../../../C/XzEnc.c"
  "../../../../C/XzIn.c"
  "../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp"
  "../../../../CPP/7zip/Archive/7z/7zDecode.cpp"
  "../../../../CPP/7zip/Archive/7z/7zEncode.cpp"
  "../../../../CPP/7zip/Archive/7z/7zExtract.cpp"
  "../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp"
  "../../../../CPP/7zip/Archive/7z/7zHandler.cpp"
  "../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp"
  "../../../../CPP/7zip/Archive/7z/7zHeader.cpp"
  "../../../../CPP/7zip/Archive/7z/7zIn.cpp"
  "../../../../CPP/7zip/Archive/7z/7zOut.cpp"
  "../../../../CPP/7zip/Archive/7z/7zProperties.cpp"
  "../../../../CPP/7zip/Archive/7z/7zRegister.cpp"
  "../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp"
  "../../../../CPP/7zip/Archive/7z/7zUpdate.cpp"
  "../../../../CPP/7zip/Archive/Bz2Handler.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabHandler.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabHeader.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabIn.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabRegister.cpp"
  "../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp"
  "../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp"
  "../../../../CPP/7zip/Archive/Common/FindSignature.cpp"
  "../../../../CPP/7zip/Archive/Common/HandlerOut.cpp"
  "../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp"
  "../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp"
  "../../../../CPP/7zip/Archive/Common/MultiStream.cpp"
  "../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp"
  "../../../../CPP/7zip/Archive/Common/ParseProperties.cpp"
  "../../../../CPP/7zip/Archive/DeflateProps.cpp"
  "../../../../CPP/7zip/Archive/GzHandler.cpp"
  "../../../../CPP/7zip/Archive/LzmaHandler.cpp"
  "../../../../CPP/7zip/Archive/PpmdHandler.cpp"
  "../../../../CPP/7zip/Archive/SplitHandler.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarHandler.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarHeader.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarIn.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarOut.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarRegister.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp"
  "../../../../CPP/7zip/Archive/XzHandler.cpp"
  "../../../../CPP/7zip/Archive/ZHandler.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipIn.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipItem.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipOut.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp"
  "../../../../CPP/7zip/Common/CWrappers.cpp"
  "../../../../CPP/7zip/Common/CreateCoder.cpp"
  "../../../../CPP/7zip/Common/FilePathAutoRename.cpp"
  "../../../../CPP/7zip/Common/FileStreams.cpp"
  "../../../../CPP/7zip/Common/FilterCoder.cpp"
  "../../../../CPP/7zip/Common/InBuffer.cpp"
  "../../../../CPP/7zip/Common/InOutTempBuffer.cpp"
  "../../../../CPP/7zip/Common/LimitedStreams.cpp"
  "../../../../CPP/7zip/Common/MemBlocks.cpp"
  "../../../../CPP/7zip/Common/MethodId.cpp"
  "../../../../CPP/7zip/Common/MethodProps.cpp"
  "../../../../CPP/7zip/Common/OffsetStream.cpp"
  "../../../../CPP/7zip/Common/OutBuffer.cpp"
  "../../../../CPP/7zip/Common/OutMemStream.cpp"
  "../../../../CPP/7zip/Common/ProgressMt.cpp"
  "../../../../CPP/7zip/Common/ProgressUtils.cpp"
  "../../../../CPP/7zip/Common/PropId.cpp"
  "../../../../CPP/7zip/Common/StreamBinder.cpp"
  "../../../../CPP/7zip/Common/StreamObjects.cpp"
  "../../../../CPP/7zip/Common/StreamUtils.cpp"
  "../../../../CPP/7zip/Common/UniqBlocks.cpp"
  "../../../../CPP/7zip/Common/VirtThread.cpp"
  "../../../../CPP/7zip/Compress/BZip2Crc.cpp"
  "../../../../CPP/7zip/Compress/BZip2Decoder.cpp"
  "../../../../CPP/7zip/Compress/BZip2Encoder.cpp"
  "../../../../CPP/7zip/Compress/BZip2Register.cpp"
  "../../../../CPP/7zip/Compress/Bcj2Coder.cpp"
  "../../../../CPP/7zip/Compress/Bcj2Register.cpp"
  "../../../../CPP/7zip/Compress/BcjCoder.cpp"
  "../../../../CPP/7zip/Compress/BcjRegister.cpp"
  "../../../../CPP/7zip/Compress/BitlDecoder.cpp"
  "../../../../CPP/7zip/Compress/BranchMisc.cpp"
  "../../../../CPP/7zip/Compress/BranchRegister.cpp"
  "../../../../CPP/7zip/Compress/ByteSwap.cpp"
  "../../../../CPP/7zip/Compress/CopyCoder.cpp"
  "../../../../CPP/7zip/Compress/CopyRegister.cpp"
  "../../../../CPP/7zip/Compress/Deflate64Register.cpp"
  "../../../../CPP/7zip/Compress/DeflateDecoder.cpp"
  "../../../../CPP/7zip/Compress/DeflateEncoder.cpp"
  "../../../../CPP/7zip/Compress/DeflateRegister.cpp"
  "../../../../CPP/7zip/Compress/DeltaFilter.cpp"
  "../../../../CPP/7zip/Compress/ImplodeDecoder.cpp"
  "../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp"
  "../../../../CPP/7zip/Compress/LzOutWindow.cpp"
  "../../../../CPP/7zip/Compress/Lzma2Decoder.cpp"
  "../../../../CPP/7zip/Compress/Lzma2Encoder.cpp"
  "../../../../CPP/7zip/Compress/Lzma2Register.cpp"
  "../../../../CPP/7zip/Compress/LzmaDecoder.cpp"
  "../../../../CPP/7zip/Compress/LzmaEncoder.cpp"
  "../../../../CPP/7zip/Compress/LzmaRegister.cpp"
  "../../../../CPP/7zip/Compress/LzxDecoder.cpp"
  "../../../../CPP/7zip/Compress/PpmdDecoder.cpp"
  "../../../../CPP/7zip/Compress/PpmdEncoder.cpp"
  "../../../../CPP/7zip/Compress/PpmdRegister.cpp"
  "../../../../CPP/7zip/Compress/PpmdZip.cpp"
  "../../../../CPP/7zip/Compress/QuantumDecoder.cpp"
  "../../../../CPP/7zip/Compress/ShrinkDecoder.cpp"
  "../../../../CPP/7zip/Compress/ZDecoder.cpp"
  "../../../../CPP/7zip/Crypto/7zAes.cpp"
  "../../../../CPP/7zip/Crypto/7zAesRegister.cpp"
  "../../../../CPP/7zip/Crypto/HmacSha1.cpp"
  "../../../../CPP/7zip/Crypto/MyAes.cpp"
  "../../../../CPP/7zip/Crypto/MyAesReg.cpp"
  "../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp"
  "../../../../CPP/7zip/Crypto/RandGen.cpp"
  "../../../../CPP/7zip/Crypto/WzAes.cpp"
  "../../../../CPP/7zip/Crypto/ZipCrypto.cpp"
  "../../../../CPP/7zip/Crypto/ZipStrong.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp"
  "../../../../CPP/7zip/UI/Common/Bench.cpp"
  "../../../../CPP/7zip/UI/Common/DefaultName.cpp"
  "../../../../CPP/7zip/UI/Common/EnumDirItems.cpp"
  "../../../../CPP/7zip/UI/Common/Extract.cpp"
  "../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp"
  "../../../../CPP/7zip/UI/Common/HashCalc.cpp"
  "../../../../CPP/7zip/UI/Common/LoadCodecs.cpp"
  "../../../../CPP/7zip/UI/Common/OpenArchive.cpp"
  "../../../../CPP/7zip/UI/Common/PropIDUtils.cpp"
  "../../../../CPP/7zip/UI/Common/SetProperties.cpp"
  "../../../../CPP/7zip/UI/Common/SortUtils.cpp"
  "../../../../CPP/7zip/UI/Common/TempFiles.cpp"
  "../../../../CPP/7zip/UI/Common/Update.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateAction.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateCallback.cpp"
  "../../../../CPP/7zip/UI/Common/UpdatePair.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateProduce.cpp"
  "../../../../CPP/7zip/UI/Console/BenchCon.cpp"
  "../../../../CPP/7zip/UI/Console/ConsoleClose.cpp"
  "../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp"
  "../../../../CPP/7zip/UI/Console/HashCon.cpp"
  "../../../../CPP/7zip/UI/Console/List.cpp"
  "../../../../CPP/7zip/UI/Console/Main.cpp"
  "../../../../CPP/7zip/UI/Console/MainAr.cpp"
  "../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp"
  "../../../../CPP/7zip/UI/Console/PercentPrinter.cpp"
  "../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp"
  "../../../../CPP/7zip/UI/Console/UserInputUtils.cpp"
  "../../../../CPP/Common/CRC.cpp"
  "../../../../CPP/Common/CommandLineParser.cpp"
  "../../../../CPP/Common/CrcReg.cpp"
  "../../../../CPP/Common/IntToString.cpp"
  "../../../../CPP/Common/ListFileUtils.cpp"
  "../../../../CPP/Common/MyString.cpp"
  "../../../../CPP/Common/MyVector.cpp"
  "../../../../CPP/Common/MyWindows.cpp"
  "../../../../CPP/Common/Sha1Reg.cpp"
  "../../../../CPP/Common/Sha256Reg.cpp"
  "../../../../CPP/Common/StdInStream.cpp"
  "../../../../CPP/Common/StdOutStream.cpp"
  "../../../../CPP/Common/StringConvert.cpp"
  "../../../../CPP/Common/StringToInt.cpp"
  "../../../../CPP/Common/UTFConvert.cpp"
  "../../../../CPP/Common/Wildcard.cpp"
  "../../../../CPP/Common/XzCrc64Reg.cpp"
  "../../../../CPP/Windows/ErrorMsg.cpp"
  "../../../../CPP/Windows/FileDir.cpp"
  "../../../../CPP/Windows/FileFind.cpp"
  "../../../../CPP/Windows/FileIO.cpp"
  "../../../../CPP/Windows/FileName.cpp"
  "../../../../CPP/Windows/PropVariant.cpp"
  "../../../../CPP/Windows/PropVariantConv.cpp"
  "../../../../CPP/Windows/Synchronization.cpp"
  "../../../../CPP/Windows/System.cpp"
  "../../../../CPP/Windows/TimeUtils.cpp"
  "../../../../CPP/myWindows/myAddExeFlag.cpp"
  "../../../../CPP/myWindows/mySplitCommandLine.cpp"
  "../../../../CPP/myWindows/wine_date_and_time.cpp"
)


IF(APPLE)
   TARGET_LINK_LIBRARIES(7za ${COREFOUNDATION_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
ELSE(APPLE)
  IF(HAVE_PTHREADS)
   TARGET_LINK_LIBRARIES(7za ${CMAKE_THREAD_LIBS_INIT} dl)
  ENDIF(HAVE_PTHREADS)
ENDIF(APPLE)



# WARNING : automatically generated by utils/generate.py
cmake_minimum_required(VERSION 2.8)

include_directories(
  "../../../myWindows"
  "../../../"
  "../../../include_windows"
)

add_definitions( -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_REENTRANT -DENV_UNIX -D_NO_CRYPTO -DBREAK_HANDLER -DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE)

IF(APPLE)
  add_definitions(-DENV_MACOSX)
  FIND_LIBRARY(COREFOUNDATION_LIBRARY CoreFoundation )
ENDIF(APPLE)

add_executable(7zr

  "../../../../C/7zCrc.c"
  "../../../../C/7zCrcOpt.c"
  "../../../../C/7zStream.c"
  "../../../../C/Alloc.c"
  "../../../../C/Bcj2.c"
  "../../../../C/Bcj2Enc.c"
  "../../../../C/Bra.c"
  "../../../../C/Bra86.c"
  "../../../../C/BraIA64.c"
  "../../../../C/CpuArch.c"
  "../../../../C/Delta.c"
  "../../../../C/LzFind.c"
  "../../../../C/LzFindMt.c"
  "../../../../C/Lzma2Dec.c"
  "../../../../C/Lzma2Enc.c"
  "../../../../C/LzmaDec.c"
  "../../../../C/LzmaEnc.c"
  "../../../../C/MtCoder.c"
  "../../../../C/Sha256.c"
  "../../../../C/Threads.c"
  "../../../../C/Xz.c"
  "../../../../C/XzCrc64.c"
  "../../../../C/XzCrc64Opt.c"
  "../../../../C/XzDec.c"
  "../../../../C/XzEnc.c"
  "../../../../C/XzIn.c"
  "../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp"
  "../../../../CPP/7zip/Archive/7z/7zDecode.cpp"
  "../../../../CPP/7zip/Archive/7z/7zEncode.cpp"
  "../../../../CPP/7zip/Archive/7z/7zExtract.cpp"
  "../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp"
  "../../../../CPP/7zip/Archive/7z/7zHandler.cpp"
  "../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp"
  "../../../../CPP/7zip/Archive/7z/7zHeader.cpp"
  "../../../../CPP/7zip/Archive/7z/7zIn.cpp"
  "../../../../CPP/7zip/Archive/7z/7zOut.cpp"
  "../../../../CPP/7zip/Archive/7z/7zProperties.cpp"
  "../../../../CPP/7zip/Archive/7z/7zRegister.cpp"
  "../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp"
  "../../../../CPP/7zip/Archive/7z/7zUpdate.cpp"
  "../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp"
  "../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp"
  "../../../../CPP/7zip/Archive/Common/HandlerOut.cpp"
  "../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp"
  "../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp"
  "../../../../CPP/7zip/Archive/Common/MultiStream.cpp"
  "../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp"
  "../../../../CPP/7zip/Archive/Common/ParseProperties.cpp"
  "../../../../CPP/7zip/Archive/LzmaHandler.cpp"
  "../../../../CPP/7zip/Archive/SplitHandler.cpp"
  "../../../../CPP/7zip/Archive/XzHandler.cpp"
  "../../../../CPP/7zip/Common/CWrappers.cpp"
  "../../../../CPP/7zip/Common/CreateCoder.cpp"
  "../../../../CPP/7zip/Common/FilePathAutoRename.cpp"
  "../../../../CPP/7zip/Common/FileStreams.cpp"
  "../../../../CPP/7zip/Common/FilterCoder.cpp"
  "../../../../CPP/7zip/Common/InBuffer.cpp"
  "../../../../CPP/7zip/Common/InOutTempBuffer.cpp"
  "../../../../CPP/7zip/Common/LimitedStreams.cpp"
  "../../../../CPP/7zip/Common/MethodId.cpp"
  "../../../../CPP/7zip/Common/MethodProps.cpp"
  "../../../../CPP/7zip/Common/OffsetStream.cpp"
  "../../../../CPP/7zip/Common/OutBuffer.cpp"
  "../../../../CPP/7zip/Common/ProgressUtils.cpp"
  "../../../../CPP/7zip/Common/PropId.cpp"
  "../../../../CPP/7zip/Common/StreamBinder.cpp"
  "../../../../CPP/7zip/Common/StreamObjects.cpp"
  "../../../../CPP/7zip/Common/StreamUtils.cpp"
  "../../../../CPP/7zip/Common/UniqBlocks.cpp"
  "../../../../CPP/7zip/Common/VirtThread.cpp"
  "../../../../CPP/7zip/Compress/Bcj2Coder.cpp"
  "../../../../CPP/7zip/Compress/Bcj2Register.cpp"
  "../../../../CPP/7zip/Compress/BcjCoder.cpp"
  "../../../../CPP/7zip/Compress/BcjRegister.cpp"
  "../../../../CPP/7zip/Compress/BranchMisc.cpp"
  "../../../../CPP/7zip/Compress/BranchRegister.cpp"
  "../../../../CPP/7zip/Compress/ByteSwap.cpp"
  "../../../../CPP/7zip/Compress/CopyCoder.cpp"
  "../../../../CPP/7zip/Compress/CopyRegister.cpp"
  "../../../../CPP/7zip/Compress/DeltaFilter.cpp"
  "../../../../CPP/7zip/Compress/Lzma2Decoder.cpp"
  "../../../../CPP/7zip/Compress/Lzma2Encoder.cpp"
  "../../../../CPP/7zip/Compress/Lzma2Register.cpp"
  "../../../../CPP/7zip/Compress/LzmaDecoder.cpp"
  "../../../../CPP/7zip/Compress/LzmaEncoder.cpp"
  "../../../../CPP/7zip/Compress/LzmaRegister.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveCommandLine.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveExtractCallback.cpp"
  "../../../../CPP/7zip/UI/Common/ArchiveOpenCallback.cpp"
  "../../../../CPP/7zip/UI/Common/Bench.cpp"
  "../../../../CPP/7zip/UI/Common/DefaultName.cpp"
  "../../../../CPP/7zip/UI/Common/EnumDirItems.cpp"
  "../../../../CPP/7zip/UI/Common/Extract.cpp"
  "../../../../CPP/7zip/UI/Common/ExtractingFilePath.cpp"
  "../../../../CPP/7zip/UI/Common/HashCalc.cpp"
  "../../../../CPP/7zip/UI/Common/LoadCodecs.cpp"
  "../../../../CPP/7zip/UI/Common/OpenArchive.cpp"
  "../../../../CPP/7zip/UI/Common/PropIDUtils.cpp"
  "../../../../CPP/7zip/UI/Common/SetProperties.cpp"
  "../../../../CPP/7zip/UI/Common/SortUtils.cpp"
  "../../../../CPP/7zip/UI/Common/TempFiles.cpp"
  "../../../../CPP/7zip/UI/Common/Update.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateAction.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateCallback.cpp"
  "../../../../CPP/7zip/UI/Common/UpdatePair.cpp"
  "../../../../CPP/7zip/UI/Common/UpdateProduce.cpp"
  "../../../../CPP/7zip/UI/Console/BenchCon.cpp"
  "../../../../CPP/7zip/UI/Console/ConsoleClose.cpp"
  "../../../../CPP/7zip/UI/Console/ExtractCallbackConsole.cpp"
  "../../../../CPP/7zip/UI/Console/HashCon.cpp"
  "../../../../CPP/7zip/UI/Console/List.cpp"
  "../../../../CPP/7zip/UI/Console/Main.cpp"
  "../../../../CPP/7zip/UI/Console/MainAr.cpp"
  "../../../../CPP/7zip/UI/Console/OpenCallbackConsole.cpp"
  "../../../../CPP/7zip/UI/Console/PercentPrinter.cpp"
  "../../../../CPP/7zip/UI/Console/UpdateCallbackConsole.cpp"
  "../../../../CPP/7zip/UI/Console/UserInputUtils.cpp"
  "../../../../CPP/Common/CRC.cpp"
  "../../../../CPP/Common/CommandLineParser.cpp"
  "../../../../CPP/Common/CrcReg.cpp"
  "../../../../CPP/Common/IntToString.cpp"
  "../../../../CPP/Common/ListFileUtils.cpp"
  "../../../../CPP/Common/MyString.cpp"
  "../../../../CPP/Common/MyVector.cpp"
  "../../../../CPP/Common/MyWindows.cpp"
  "../../../../CPP/Common/NewHandler.cpp"
  "../../../../CPP/Common/Sha256Reg.cpp"
  "../../../../CPP/Common/StdInStream.cpp"
  "../../../../CPP/Common/StdOutStream.cpp"
  "../../../../CPP/Common/StringConvert.cpp"
  "../../../../CPP/Common/StringToInt.cpp"
  "../../../../CPP/Common/UTFConvert.cpp"
  "../../../../CPP/Common/Wildcard.cpp"
  "../../../../CPP/Common/XzCrc64Reg.cpp"
  "../../../../CPP/Windows/ErrorMsg.cpp"
  "../../../../CPP/Windows/FileDir.cpp"
  "../../../../CPP/Windows/FileFind.cpp"
  "../../../../CPP/Windows/FileIO.cpp"
  "../../../../CPP/Windows/FileName.cpp"
  "../../../../CPP/Windows/PropVariant.cpp"
  "../../../../CPP/Windows/PropVariantConv.cpp"
  "../../../../CPP/Windows/Synchronization.cpp"
  "../../../../CPP/Windows/System.cpp"
  "../../../../CPP/Windows/TimeUtils.cpp"
  "../../../../CPP/myWindows/myAddExeFlag.cpp"
  "../../../../CPP/myWindows/mySplitCommandLine.cpp"
  "../../../../CPP/myWindows/wine_date_and_time.cpp"
)


IF(APPLE)
   TARGET_LINK_LIBRARIES(7zr ${COREFOUNDATION_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
ELSE(APPLE)
  IF(HAVE_PTHREADS)
   TARGET_LINK_LIBRARIES(7zr ${CMAKE_THREAD_LIBS_INIT} dl)
  ENDIF(HAVE_PTHREADS)
ENDIF(APPLE)



# WARNING : automatically generated by utils/generate.py
cmake_minimum_required(VERSION 2.8)

include_directories(
  "../../../myWindows"
  "../../../"
  "../../../include_windows"
)

add_definitions( -DEXTERNAL_CODECS -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_REENTRANT -DENV_UNIX -DBREAK_HANDLER -DUNICODE -D_UNICODE -DUNIX_USE_WIN_FILE)

IF(APPLE)
  add_definitions(-DENV_MACOSX)
  FIND_LIBRARY(COREFOUNDATION_LIBRARY CoreFoundation )
ENDIF(APPLE)

add_library(7z MODULE

  "../../../../C/7zBuf2.c"
  "../../../../C/7zCrc.c"
  "../../../../C/7zCrcOpt.c"
  "../../../../C/7zStream.c"
  "../../../../C/Aes.c"
  "../../../../C/Alloc.c"
  "../../../../C/Bcj2.c"
  "../../../../C/Bcj2Enc.c"
  "../../../../C/Blake2s.c"
  "../../../../C/Bra.c"
  "../../../../C/Bra86.c"
  "../../../../C/BraIA64.c"
  "../../../../C/BwtSort.c"
  "../../../../C/CpuArch.c"
  "../../../../C/Delta.c"
  "../../../../C/HuffEnc.c"
  "../../../../C/LzFind.c"
  "../../../../C/LzFindMt.c"
  "../../../../C/Lzma2Dec.c"
  "../../../../C/Lzma2Enc.c"
  "../../../../C/LzmaDec.c"
  "../../../../C/LzmaEnc.c"
  "../../../../C/MtCoder.c"
  "../../../../C/Ppmd7.c"
  "../../../../C/Ppmd7Dec.c"
  "../../../../C/Ppmd7Enc.c"
  "../../../../C/Ppmd8.c"
  "../../../../C/Ppmd8Dec.c"
  "../../../../C/Ppmd8Enc.c"
  "../../../../C/Sha1.c"
  "../../../../C/Sha256.c"
  "../../../../C/Sort.c"
  "../../../../C/Threads.c"
  "../../../../C/Xz.c"
  "../../../../C/XzCrc64.c"
  "../../../../C/XzCrc64Opt.c"
  "../../../../C/XzDec.c"
  "../../../../C/XzEnc.c"
  "../../../../C/XzIn.c"
  "../../../../CPP/7zip/Archive/7z/7zCompressionMode.cpp"
  "../../../../CPP/7zip/Archive/7z/7zDecode.cpp"
  "../../../../CPP/7zip/Archive/7z/7zEncode.cpp"
  "../../../../CPP/7zip/Archive/7z/7zExtract.cpp"
  "../../../../CPP/7zip/Archive/7z/7zFolderInStream.cpp"
  "../../../../CPP/7zip/Archive/7z/7zHandler.cpp"
  "../../../../CPP/7zip/Archive/7z/7zHandlerOut.cpp"
  "../../../../CPP/7zip/Archive/7z/7zHeader.cpp"
  "../../../../CPP/7zip/Archive/7z/7zIn.cpp"
  "../../../../CPP/7zip/Archive/7z/7zOut.cpp"
  "../../../../CPP/7zip/Archive/7z/7zProperties.cpp"
  "../../../../CPP/7zip/Archive/7z/7zRegister.cpp"
  "../../../../CPP/7zip/Archive/7z/7zSpecStream.cpp"
  "../../../../CPP/7zip/Archive/7z/7zUpdate.cpp"
  "../../../../CPP/7zip/Archive/ApmHandler.cpp"
  "../../../../CPP/7zip/Archive/ArHandler.cpp"
  "../../../../CPP/7zip/Archive/ArchiveExports.cpp"
  "../../../../CPP/7zip/Archive/ArjHandler.cpp"
  "../../../../CPP/7zip/Archive/Bz2Handler.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabBlockInStream.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabHandler.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabHeader.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabIn.cpp"
  "../../../../CPP/7zip/Archive/Cab/CabRegister.cpp"
  "../../../../CPP/7zip/Archive/Chm/ChmHandler.cpp"
  "../../../../CPP/7zip/Archive/Chm/ChmIn.cpp"
  "../../../../CPP/7zip/Archive/ComHandler.cpp"
  "../../../../CPP/7zip/Archive/Common/CoderMixer2.cpp"
  "../../../../CPP/7zip/Archive/Common/DummyOutStream.cpp"
  "../../../../CPP/7zip/Archive/Common/FindSignature.cpp"
  "../../../../CPP/7zip/Archive/Common/HandlerOut.cpp"
  "../../../../CPP/7zip/Archive/Common/InStreamWithCRC.cpp"
  "../../../../CPP/7zip/Archive/Common/ItemNameUtils.cpp"
  "../../../../CPP/7zip/Archive/Common/MultiStream.cpp"
  "../../../../CPP/7zip/Archive/Common/OutStreamWithCRC.cpp"
  "../../../../CPP/7zip/Archive/Common/OutStreamWithSha1.cpp"
  "../../../../CPP/7zip/Archive/Common/ParseProperties.cpp"
  "../../../../CPP/7zip/Archive/CpioHandler.cpp"
  "../../../../CPP/7zip/Archive/CramfsHandler.cpp"
  "../../../../CPP/7zip/Archive/DeflateProps.cpp"
  "../../../../CPP/7zip/Archive/DllExports2.cpp"
  "../../../../CPP/7zip/Archive/DmgHandler.cpp"
  "../../../../CPP/7zip/Archive/ElfHandler.cpp"
  "../../../../CPP/7zip/Archive/ExtHandler.cpp"
  "../../../../CPP/7zip/Archive/FatHandler.cpp"
  "../../../../CPP/7zip/Archive/FlvHandler.cpp"
  "../../../../CPP/7zip/Archive/GzHandler.cpp"
  "../../../../CPP/7zip/Archive/GptHandler.cpp"
  "../../../../CPP/7zip/Archive/HandlerCont.cpp"
  "../../../../CPP/7zip/Archive/HfsHandler.cpp"
  "../../../../CPP/7zip/Archive/IhexHandler.cpp"
  "../../../../CPP/7zip/Archive/Iso/IsoHandler.cpp"
  "../../../../CPP/7zip/Archive/Iso/IsoHeader.cpp"
  "../../../../CPP/7zip/Archive/Iso/IsoIn.cpp"
  "../../../../CPP/7zip/Archive/Iso/IsoRegister.cpp"
  "../../../../CPP/7zip/Archive/LzhHandler.cpp"
  "../../../../CPP/7zip/Archive/LzmaHandler.cpp"
  "../../../../CPP/7zip/Archive/MachoHandler.cpp"
  "../../../../CPP/7zip/Archive/MbrHandler.cpp"
  "../../../../CPP/7zip/Archive/MslzHandler.cpp"
  "../../../../CPP/7zip/Archive/MubHandler.cpp"
  "../../../../CPP/7zip/Archive/Nsis/NsisDecode.cpp"
  "../../../../CPP/7zip/Archive/Nsis/NsisHandler.cpp"
  "../../../../CPP/7zip/Archive/Nsis/NsisIn.cpp"
  "../../../../CPP/7zip/Archive/Nsis/NsisRegister.cpp"
  "../../../../CPP/7zip/Archive/NtfsHandler.cpp"
  "../../../../CPP/7zip/Archive/PeHandler.cpp"
  "../../../../CPP/7zip/Archive/PpmdHandler.cpp"
  "../../../../CPP/7zip/Archive/QcowHandler.cpp"
  "../../../../CPP/7zip/Archive/Rar/RarHandler.cpp"
  "../../../../CPP/7zip/Archive/Rar/Rar5Handler.cpp"
  "../../../../CPP/7zip/Archive/RpmHandler.cpp"
  "../../../../CPP/7zip/Archive/SplitHandler.cpp"
  "../../../../CPP/7zip/Archive/SquashfsHandler.cpp"
  "../../../../CPP/7zip/Archive/SwfHandler.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarHandler.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarHandlerOut.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarHeader.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarIn.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarOut.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarRegister.cpp"
  "../../../../CPP/7zip/Archive/Tar/TarUpdate.cpp"
  "../../../../CPP/7zip/Archive/Udf/UdfHandler.cpp"
  "../../../../CPP/7zip/Archive/Udf/UdfIn.cpp"
  "../../../../CPP/7zip/Archive/UefiHandler.cpp"
  "../../../../CPP/7zip/Archive/VdiHandler.cpp"
  "../../../../CPP/7zip/Archive/VhdHandler.cpp"
  "../../../../CPP/7zip/Archive/VmdkHandler.cpp"
  "../../../../CPP/7zip/Archive/Wim/WimHandler.cpp"
  "../../../../CPP/7zip/Archive/Wim/WimHandlerOut.cpp"
  "../../../../CPP/7zip/Archive/Wim/WimIn.cpp"
  "../../../../CPP/7zip/Archive/Wim/WimRegister.cpp"
  "../../../../CPP/7zip/Archive/XarHandler.cpp"
  "../../../../CPP/7zip/Archive/XzHandler.cpp"
  "../../../../CPP/7zip/Archive/ZHandler.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipAddCommon.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipHandler.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipHandlerOut.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipIn.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipItem.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipOut.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipRegister.cpp"
  "../../../../CPP/7zip/Archive/Zip/ZipUpdate.cpp"
  "../../../../CPP/7zip/Common/CWrappers.cpp"
  "../../../../CPP/7zip/Common/CreateCoder.cpp"
  "../../../../CPP/7zip/Common/FilterCoder.cpp"
  "../../../../CPP/7zip/Common/InBuffer.cpp"
  "../../../../CPP/7zip/Common/InOutTempBuffer.cpp"
  "../../../../CPP/7zip/Common/LimitedStreams.cpp"
  "../../../../CPP/7zip/Common/MemBlocks.cpp"
  "../../../../CPP/7zip/Common/MethodId.cpp"
  "../../../../CPP/7zip/Common/MethodProps.cpp"
  "../../../../CPP/7zip/Common/OffsetStream.cpp"
  "../../../../CPP/7zip/Common/OutBuffer.cpp"
  "../../../../CPP/7zip/Common/OutMemStream.cpp"
  "../../../../CPP/7zip/Common/ProgressMt.cpp"
  "../../../../CPP/7zip/Common/ProgressUtils.cpp"
  "../../../../CPP/7zip/Common/PropId.cpp"
  "../../../../CPP/7zip/Common/StreamBinder.cpp"
  "../../../../CPP/7zip/Common/StreamObjects.cpp"
  "../../../../CPP/7zip/Common/StreamUtils.cpp"
  "../../../../CPP/7zip/Common/UniqBlocks.cpp"
  "../../../../CPP/7zip/Common/VirtThread.cpp"
  "../../../../CPP/7zip/Compress/BZip2Crc.cpp"
  "../../../../CPP/7zip/Compress/BZip2Decoder.cpp"
  "../../../../CPP/7zip/Compress/BZip2Encoder.cpp"
  "../../../../CPP/7zip/Compress/BZip2Register.cpp"
  "../../../../CPP/7zip/Compress/Bcj2Coder.cpp"
  "../../../../CPP/7zip/Compress/Bcj2Register.cpp"
  "../../../../CPP/7zip/Compress/BcjCoder.cpp"
  "../../../../CPP/7zip/Compress/BcjRegister.cpp"
  "../../../../CPP/7zip/Compress/BitlDecoder.cpp"
  "../../../../CPP/7zip/Compress/BranchMisc.cpp"
  "../../../../CPP/7zip/Compress/BranchRegister.cpp"
  "../../../../CPP/7zip/Compress/ByteSwap.cpp"
  "../../../../CPP/7zip/Compress/CodecExports.cpp"
  "../../../../CPP/7zip/Compress/CopyCoder.cpp"
  "../../../../CPP/7zip/Compress/CopyRegister.cpp"
  "../../../../CPP/7zip/Compress/Deflate64Register.cpp"
  "../../../../CPP/7zip/Compress/DeflateDecoder.cpp"
  "../../../../CPP/7zip/Compress/DeflateEncoder.cpp"
  "../../../../CPP/7zip/Compress/DeflateRegister.cpp"
  "../../../../CPP/7zip/Compress/DeltaFilter.cpp"
  "../../../../CPP/7zip/Compress/ImplodeDecoder.cpp"
  "../../../../CPP/7zip/Compress/ImplodeHuffmanDecoder.cpp"
  "../../../../CPP/7zip/Compress/LzOutWindow.cpp"
  "../../../../CPP/7zip/Compress/LzhDecoder.cpp"
  "../../../../CPP/7zip/Compress/Lzma2Decoder.cpp"
  "../../../../CPP/7zip/Compress/Lzma2Encoder.cpp"
  "../../../../CPP/7zip/Compress/Lzma2Register.cpp"
  "../../../../CPP/7zip/Compress/LzmaDecoder.cpp"
  "../../../../CPP/7zip/Compress/LzmaEncoder.cpp"
  "../../../../CPP/7zip/Compress/LzmaRegister.cpp"
  "../../../../CPP/7zip/Compress/LzmsDecoder.cpp"
  "../../../../CPP/7zip/Compress/LzxDecoder.cpp"
  "../../../../CPP/7zip/Compress/PpmdDecoder.cpp"
  "../../../../CPP/7zip/Compress/PpmdEncoder.cpp"
  "../../../../CPP/7zip/Compress/PpmdRegister.cpp"
  "../../../../CPP/7zip/Compress/PpmdZip.cpp"
  "../../../../CPP/7zip/Compress/QuantumDecoder.cpp"
  "../../../../CPP/7zip/Compress/ShrinkDecoder.cpp"
  "../../../../CPP/7zip/Compress/ZDecoder.cpp"
  "../../../../CPP/7zip/Compress/XpressDecoder.cpp"
  "../../../../CPP/7zip/Compress/ZlibDecoder.cpp"
  "../../../../CPP/7zip/Compress/ZlibEncoder.cpp"
  "../../../../CPP/7zip/Crypto/7zAes.cpp"
  "../../../../CPP/7zip/Crypto/7zAesRegister.cpp"
  "../../../../CPP/7zip/Crypto/HmacSha1.cpp"
  "../../../../CPP/7zip/Crypto/HmacSha256.cpp"
  "../../../../CPP/7zip/Crypto/MyAes.cpp"
  "../../../../CPP/7zip/Crypto/MyAesReg.cpp"
  "../../../../CPP/7zip/Crypto/Pbkdf2HmacSha1.cpp"
  "../../../../CPP/7zip/Crypto/RandGen.cpp"
  "../../../../CPP/7zip/Crypto/Rar20Crypto.cpp"
  "../../../../CPP/7zip/Crypto/Rar5Aes.cpp"
  "../../../../CPP/7zip/Crypto/RarAes.cpp"
  "../../../../CPP/7zip/Crypto/WzAes.cpp"
  "../../../../CPP/7zip/Crypto/ZipCrypto.cpp"
  "../../../../CPP/7zip/Crypto/ZipStrong.cpp"
  "../../../../CPP/Common/CRC.cpp"
  "../../../../CPP/Common/CrcReg.cpp"
  "../../../../CPP/Common/DynLimBuf.cpp"
  "../../../../CPP/Common/IntToString.cpp"
  "../../../../CPP/Common/MyMap.cpp"
  "../../../../CPP/Common/MyString.cpp"
  "../../../../CPP/Common/MyVector.cpp"
  "../../../../CPP/Common/MyWindows.cpp"
  "../../../../CPP/Common/MyXml.cpp"
  "../../../../CPP/Common/NewHandler.cpp"
  "../../../../CPP/Common/Sha1Reg.cpp"
  "../../../../CPP/Common/Sha256Reg.cpp"
  "../../../../CPP/Common/StringConvert.cpp"
  "../../../../CPP/Common/StringToInt.cpp"
  "../../../../CPP/Common/UTFConvert.cpp"
  "../../../../CPP/Common/Wildcard.cpp"
  "../../../../CPP/Common/XzCrc64Reg.cpp"
  "../../../../CPP/Windows/FileDir.cpp"
  "../../../../CPP/Windows/FileFind.cpp"
  "../../../../CPP/Windows/FileIO.cpp"
  "../../../../CPP/Windows/FileName.cpp"
  "../../../../CPP/Windows/PropVariant.cpp"
  "../../../../CPP/Windows/PropVariantUtils.cpp"
  "../../../../CPP/Windows/Synchronization.cpp"
  "../../../../CPP/Windows/System.cpp"
  "../../../../CPP/Windows/TimeUtils.cpp"
  "../../../../CPP/myWindows/wine_date_and_time.cpp"
)


SET_TARGET_PROPERTIES(7z PROPERTIES PREFIX "")

IF(APPLE)
   TARGET_LINK_LIBRARIES(7z ${COREFOUNDATION_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
ELSE(APPLE)
  IF(HAVE_PTHREADS)
   TARGET_LINK_LIBRARIES(7z ${CMAKE_THREAD_LIBS_INIT})
  ENDIF(HAVE_PTHREADS)
ENDIF(APPLE)
	
// CWrappers.h

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "CWrappers.h"

#include "StreamUtils.h"

#define PROGRESS_UNKNOWN_VALUE ((UInt64)(Int64)-1)

#define CONVERT_PR_VAL(x) (x == PROGRESS_UNKNOWN_VALUE ? NULL : &x)

static SRes CompressProgress(void *pp, UInt64 inSize, UInt64 outSize) throw()
{
  CCompressProgressWrap *p = (CCompressProgressWrap *)pp;
  p->Res = p->Progress->SetRatioInfo(CONVERT_PR_VAL(inSize), CONVERT_PR_VAL(outSize));
  return (SRes)p->Res;
}

CCompressProgressWrap::CCompressProgressWrap(ICompressProgressInfo *progress) throw()
{
  p.Progress = CompressProgress;
  Progress = progress;
  Res = SZ_OK;
}

static const UInt32 kStreamStepSize = (UInt32)1 << 31;

SRes HRESULT_To_SRes(HRESULT res, SRes defaultRes)
{
  switch (res)
  {
    case S_OK: return SZ_OK;
    case E_OUTOFMEMORY: return SZ_ERROR_MEM;
    case E_INVALIDARG: return SZ_ERROR_PARAM;
    case E_ABORT: return SZ_ERROR_PROGRESS;
    case S_FALSE: return SZ_ERROR_DATA;
    case E_NOTIMPL: return SZ_ERROR_UNSUPPORTED;
  }
  return defaultRes;
}

static SRes MyRead(void *object, void *data, size_t *size) throw()
{
  CSeqInStreamWrap *p = (CSeqInStreamWrap *)object;
  UInt32 curSize = ((*size < kStreamStepSize) ? (UInt32)*size : kStreamStepSize);
  p->Res = (p->Stream->Read(data, curSize, &curSize));
  *size = curSize;
  p->Processed += curSize;
  if (p->Res == S_OK)
    return SZ_OK;
  return HRESULT_To_SRes(p->Res, SZ_ERROR_READ);
}

static size_t MyWrite(void *object, const void *data, size_t size) throw()
{
  CSeqOutStreamWrap *p = (CSeqOutStreamWrap *)object;
  if (p->Stream)
  {
    p->Res = WriteStream(p->Stream, data, size);
    if (p->Res != 0)
      return 0;
  }
  else
    p->Res = S_OK;
  p->Processed += size;
  return size;
}

CSeqInStreamWrap::CSeqInStreamWrap(ISequentialInStream *stream) throw()
{
  p.Read = MyRead;
  Stream = stream;
  Processed = 0;
}

CSeqOutStreamWrap::CSeqOutStreamWrap(ISequentialOutStream *stream) throw()
{
  p.Write = MyWrite;
  Stream = stream;
  Res = SZ_OK;
  Processed = 0;
}

HRESULT SResToHRESULT(SRes res) throw()
{
  switch (res)
  {
    case SZ_OK: return S_OK;
    case SZ_ERROR_MEM: return E_OUTOFMEMORY;
    case SZ_ERROR_PARAM: return E_INVALIDARG;
    case SZ_ERROR_PROGRESS: return E_ABORT;
    case SZ_ERROR_DATA: return S_FALSE;
    case SZ_ERROR_UNSUPPORTED: return E_NOTIMPL;
  }
  return E_FAIL;
}

static SRes InStreamWrap_Read(void *pp, void *data, size_t *size) throw()
{
  CSeekInStreamWrap *p = (CSeekInStreamWrap *)pp;
  UInt32 curSize = ((*size < kStreamStepSize) ? (UInt32)*size : kStreamStepSize);
  p->Res = p->Stream->Read(data, curSize, &curSize);
  *size = curSize;
  return (p->Res == S_OK) ? SZ_OK : SZ_ERROR_READ;
}

static SRes InStreamWrap_Seek(void *pp, Int64 *offset, ESzSeek origin) throw()
{
  CSeekInStreamWrap *p = (CSeekInStreamWrap *)pp;
  UInt32 moveMethod;
  switch (origin)
  {
    case SZ_SEEK_SET: moveMethod = STREAM_SEEK_SET; break;
    case SZ_SEEK_CUR: moveMethod = STREAM_SEEK_CUR; break;
    case SZ_SEEK_END: moveMethod = STREAM_SEEK_END; break;
    default: return SZ_ERROR_PARAM;
  }
  UInt64 newPosition;
  p->Res = p->Stream->Seek(*offset, moveMethod, &newPosition);
  *offset = (Int64)newPosition;
  return (p->Res == S_OK) ? SZ_OK : SZ_ERROR_READ;
}

CSeekInStreamWrap::CSeekInStreamWrap(IInStream *stream) throw()
{
  Stream = stream;
  p.Read = InStreamWrap_Read;
  p.Seek = InStreamWrap_Seek;
  Res = S_OK;
}


/* ---------- CByteInBufWrap ---------- */

void CByteInBufWrap::Free() throw()
{
  ::MidFree(Buf);
  Buf = 0;
}

bool CByteInBufWrap::Alloc(UInt32 size) throw()
{
  if (Buf == 0 || size != Size)
  {
    Free();
    Lim = Cur = Buf = (Byte *)::MidAlloc((size_t)size);
    Size = size;
  }
  return (Buf != 0);
}

Byte CByteInBufWrap::ReadByteFromNewBlock() throw()
{
  if (Res == S_OK)
  {
    UInt32 avail;
    Processed += (Cur - Buf);
    Res = Stream->Read(Buf, Size, &avail);
    Cur = Buf;
    Lim = Buf + avail;
    if (avail != 0)
      return *Cur++;
  }
  Extra = true;
  return 0;
}

static Byte Wrap_ReadByte(void *pp) throw()
{
  CByteInBufWrap *p = (CByteInBufWrap *)pp;
  if (p->Cur != p->Lim)
    return *p->Cur++;
  return p->ReadByteFromNewBlock();
}

CByteInBufWrap::CByteInBufWrap(): Buf(0)
{
  p.Read = Wrap_ReadByte;
}


/* ---------- CByteOutBufWrap ---------- */

void CByteOutBufWrap::Free() throw()
{
  ::MidFree(Buf);
  Buf = 0;
}

bool CByteOutBufWrap::Alloc(size_t size) throw()
{
  if (Buf == 0 || size != Size)
  {
    Free();
    Buf = (Byte *)::MidAlloc(size);
    Size = size;
  }
  return (Buf != 0);
}

HRESULT CByteOutBufWrap::Flush() throw()
{
  if (Res == S_OK)
  {
    size_t size = (Cur - Buf);
    Res = WriteStream(Stream, Buf, size);
    if (Res == S_OK)
      Processed += size;
    Cur = Buf;
  }
  return Res;
}

static void Wrap_WriteByte(void *pp, Byte b) throw()
{
  CByteOutBufWrap *p = (CByteOutBufWrap *)pp;
  Byte *dest = p->Cur;
  *dest = b;
  p->Cur = ++dest;
  if (dest == p->Lim)
    p->Flush();
}

CByteOutBufWrap::CByteOutBufWrap() throw(): Buf(0)
{
  p.Write = Wrap_WriteByte;
}
// CWrappers.h

#ifndef __C_WRAPPERS_H
#define __C_WRAPPERS_H

#include "../ICoder.h"
#include "../../Common/MyCom.h"

struct CCompressProgressWrap
{
  ICompressProgress p;
  ICompressProgressInfo *Progress;
  HRESULT Res;
  
  CCompressProgressWrap(ICompressProgressInfo *progress) throw();
};

struct CSeqInStreamWrap
{
  ISeqInStream p;
  ISequentialInStream *Stream;
  HRESULT Res;
  UInt64 Processed;
  
  CSeqInStreamWrap(ISequentialInStream *stream) throw();
};

struct CSeekInStreamWrap
{
  ISeekInStream p;
  IInStream *Stream;
  HRESULT Res;
  
  CSeekInStreamWrap(IInStream *stream) throw();
};

struct CSeqOutStreamWrap
{
  ISeqOutStream p;
  ISequentialOutStream *Stream;
  HRESULT Res;
  UInt64 Processed;
  
  CSeqOutStreamWrap(ISequentialOutStream *stream) throw();
};

HRESULT SResToHRESULT(SRes res) throw();

struct CByteInBufWrap
{
  IByteIn p;
  const Byte *Cur;
  const Byte *Lim;
  Byte *Buf;
  UInt32 Size;
  ISequentialInStream *Stream;
  UInt64 Processed;
  bool Extra;
  HRESULT Res;
  
  CByteInBufWrap();
  ~CByteInBufWrap() { Free(); }
  void Free() throw();
  bool Alloc(UInt32 size) throw();
  void Init()
  {
    Lim = Cur = Buf;
    Processed = 0;
    Extra = false;
    Res = S_OK;
  }
  UInt64 GetProcessed() const { return Processed + (Cur - Buf); }
  Byte ReadByteFromNewBlock() throw();
  Byte ReadByte()
  {
    if (Cur != Lim)
      return *Cur++;
    return ReadByteFromNewBlock();
  }
};

struct CByteOutBufWrap
{
  IByteOut p;
  Byte *Cur;
  const Byte *Lim;
  Byte *Buf;
  size_t Size;
  ISequentialOutStream *Stream;
  UInt64 Processed;
  HRESULT Res;
  
  CByteOutBufWrap() throw();
  ~CByteOutBufWrap() { Free(); }
  void Free() throw();
  bool Alloc(size_t size) throw();
  void Init()
  {
    Cur = Buf;
    Lim = Buf + Size;
    Processed = 0;
    Res = S_OK;
  }
  UInt64 GetProcessed() const { return Processed + (Cur - Buf); }
  HRESULT Flush() throw();
  void WriteByte(Byte b)
  {
    *Cur++ = b;
    if (Cur == Lim)
      Flush();
  }
};

#endif
// CreateCoder.cpp

#include "StdAfx.h"

#include "../../Windows/Defs.h"
#include "../../Windows/PropVariant.h"

#include "CreateCoder.h"

#include "FilterCoder.h"
#include "RegisterCodec.h"

static const unsigned kNumCodecsMax = 64;
unsigned g_NumCodecs = 0;
const CCodecInfo *g_Codecs[kNumCodecsMax];

// We use g_ExternalCodecs in other stages.
/*
#ifdef EXTERNAL_CODECS
extern CExternalCodecs g_ExternalCodecs;
#define CHECK_GLOBAL_CODECS \
    if (!__externalCodecs || !__externalCodecs->IsSet()) __externalCodecs = &g_ExternalCodecs;
#endif
*/

#define CHECK_GLOBAL_CODECS

void RegisterCodec(const CCodecInfo *codecInfo) throw()
{
  if (g_NumCodecs < kNumCodecsMax)
    g_Codecs[g_NumCodecs++] = codecInfo;
}

static const unsigned kNumHashersMax = 16;
unsigned g_NumHashers = 0;
const CHasherInfo *g_Hashers[kNumHashersMax];

void RegisterHasher(const CHasherInfo *hashInfo) throw()
{
  if (g_NumHashers < kNumHashersMax)
    g_Hashers[g_NumHashers++] = hashInfo;
}


#ifdef EXTERNAL_CODECS

static HRESULT ReadNumberOfStreams(ICompressCodecsInfo *codecsInfo, UInt32 index, PROPID propID, UInt32 &res)
{
  NWindows::NCOM::CPropVariant prop;
  RINOK(codecsInfo->GetProperty(index, propID, &prop));
  if (prop.vt == VT_EMPTY)
    res = 1;
  else if (prop.vt == VT_UI4)
    res = prop.ulVal;
  else
    return E_INVALIDARG;
  return S_OK;
}

static HRESULT ReadIsAssignedProp(ICompressCodecsInfo *codecsInfo, UInt32 index, PROPID propID, bool &res)
{
  NWindows::NCOM::CPropVariant prop;
  RINOK(codecsInfo->GetProperty(index, propID, &prop));
  if (prop.vt == VT_EMPTY)
    res = true;
  else if (prop.vt == VT_BOOL)
    res = VARIANT_BOOLToBool(prop.boolVal);
  else
    return E_INVALIDARG;
  return S_OK;
}

HRESULT CExternalCodecs::Load()
{
  Codecs.Clear();
  Hashers.Clear();

  if (GetCodecs)
  {
    CCodecInfoEx info;
    
    UString s;
    UInt32 num;
    RINOK(GetCodecs->GetNumMethods(&num));
    
    for (UInt32 i = 0; i < num; i++)
    {
      NWindows::NCOM::CPropVariant prop;
      
      RINOK(GetCodecs->GetProperty(i, NMethodPropID::kID, &prop));
      if (prop.vt != VT_UI8)
        continue; // old Interface
      info.Id = prop.uhVal.QuadPart;
      
      prop.Clear();
      
      info.Name.Empty();
      RINOK(GetCodecs->GetProperty(i, NMethodPropID::kName, &prop));
      if (prop.vt == VT_BSTR)
        info.Name.SetFromWStr_if_Ascii(prop.bstrVal);
      else if (prop.vt != VT_EMPTY)
        continue;
      
      RINOK(ReadNumberOfStreams(GetCodecs, i, NMethodPropID::kPackStreams, info.NumStreams));
      {
        UInt32 numUnpackStreams = 1;
        RINOK(ReadNumberOfStreams(GetCodecs, i, NMethodPropID::kUnpackStreams, numUnpackStreams));
        if (numUnpackStreams != 1)
          continue;
      }
      RINOK(ReadIsAssignedProp(GetCodecs, i, NMethodPropID::kEncoderIsAssigned, info.EncoderIsAssigned));
      RINOK(ReadIsAssignedProp(GetCodecs, i, NMethodPropID::kDecoderIsAssigned, info.DecoderIsAssigned));
      
      Codecs.Add(info);
    }
  }
  
  if (GetHashers)
  {
    UInt32 num = GetHashers->GetNumHashers();
    CHasherInfoEx info;
    
    for (UInt32 i = 0; i < num; i++)
    {
      NWindows::NCOM::CPropVariant prop;

      RINOK(GetHashers->GetHasherProp(i, NMethodPropID::kID, &prop));
      if (prop.vt != VT_UI8)
        continue;
      info.Id = prop.uhVal.QuadPart;
      
      prop.Clear();
      
      info.Name.Empty();
      RINOK(GetHashers->GetHasherProp(i, NMethodPropID::kName, &prop));
      if (prop.vt == VT_BSTR)
        info.Name.SetFromWStr_if_Ascii(prop.bstrVal);
      else if (prop.vt != VT_EMPTY)
        continue;
      
      Hashers.Add(info);
    }
  }
  
  return S_OK;
}

#endif


bool FindMethod(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const AString &name,
    CMethodId &methodId, UInt32 &numStreams)
{
  unsigned i;
  for (i = 0; i < g_NumCodecs; i++)
  {
    const CCodecInfo &codec = *g_Codecs[i];
    if (StringsAreEqualNoCase_Ascii(name, codec.Name))
    {
      methodId = codec.Id;
      numStreams = codec.NumStreams;
      return true;
    }
  }
  
  #ifdef EXTERNAL_CODECS
  
  CHECK_GLOBAL_CODECS

  if (__externalCodecs)
    for (i = 0; i < __externalCodecs->Codecs.Size(); i++)
    {
      const CCodecInfoEx &codec = __externalCodecs->Codecs[i];
      if (StringsAreEqualNoCase_Ascii(name, codec.Name))
      {
        methodId = codec.Id;
        numStreams = codec.NumStreams;
        return true;
      }
    }
  
  #endif
  
  return false;
}

bool FindMethod(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId,
    AString &name)
{
  name.Empty();
 
  unsigned i;
  for (i = 0; i < g_NumCodecs; i++)
  {
    const CCodecInfo &codec = *g_Codecs[i];
    if (methodId == codec.Id)
    {
      name = codec.Name;
      return true;
    }
  }
  
  #ifdef EXTERNAL_CODECS

  CHECK_GLOBAL_CODECS

  if (__externalCodecs)
    for (i = 0; i < __externalCodecs->Codecs.Size(); i++)
    {
      const CCodecInfoEx &codec = __externalCodecs->Codecs[i];
      if (methodId == codec.Id)
      {
        name = codec.Name;
        return true;
      }
    }
  
  #endif
  
  return false;
}

bool FindHashMethod(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const AString &name,
    CMethodId &methodId)
{
  unsigned i;
  for (i = 0; i < g_NumHashers; i++)
  {
    const CHasherInfo &codec = *g_Hashers[i];
    if (StringsAreEqualNoCase_Ascii(name, codec.Name))
    {
      methodId = codec.Id;
      return true;
    }
  }
  
  #ifdef EXTERNAL_CODECS

  CHECK_GLOBAL_CODECS

  if (__externalCodecs)
    for (i = 0; i < __externalCodecs->Hashers.Size(); i++)
    {
      const CHasherInfoEx &codec = __externalCodecs->Hashers[i];
      if (StringsAreEqualNoCase_Ascii(name, codec.Name))
      {
        methodId = codec.Id;
        return true;
      }
    }
  
  #endif
  
  return false;
}

void GetHashMethods(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CRecordVector<CMethodId> &methods)
{
  methods.ClearAndSetSize(g_NumHashers);
  unsigned i;
  for (i = 0; i < g_NumHashers; i++)
    methods[i] = (*g_Hashers[i]).Id;
  
  #ifdef EXTERNAL_CODECS
  
  CHECK_GLOBAL_CODECS

  if (__externalCodecs)
    for (i = 0; i < __externalCodecs->Hashers.Size(); i++)
      methods.Add(__externalCodecs->Hashers[i].Id);
  
  #endif
}

HRESULT CreateCoder(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId, bool encode,
    CMyComPtr<ICompressFilter> &filter,
    CCreatedCoder &cod)
{
  cod.IsExternal = false;
  cod.IsFilter = false;
  cod.NumStreams = 1;

  unsigned i;
  for (i = 0; i < g_NumCodecs; i++)
  {
    const CCodecInfo &codec = *g_Codecs[i];
    if (codec.Id == methodId)
    {
      if (encode)
      {
        if (codec.CreateEncoder)
        {
          void *p = codec.CreateEncoder();
          if (codec.IsFilter) filter = (ICompressFilter *)p;
          else if (codec.NumStreams == 1) cod.Coder = (ICompressCoder *)p;
          else { cod.Coder2 = (ICompressCoder2 *)p; cod.NumStreams = codec.NumStreams; }
          return S_OK;
        }
      }
      else
        if (codec.CreateDecoder)
        {
          void *p = codec.CreateDecoder();
          if (codec.IsFilter) filter = (ICompressFilter *)p;
          else if (codec.NumStreams == 1) cod.Coder = (ICompressCoder *)p;
          else { cod.Coder2 = (ICompressCoder2 *)p; cod.NumStreams = codec.NumStreams; }
          return S_OK;
        }
    }
  }

  #ifdef EXTERNAL_CODECS

  CHECK_GLOBAL_CODECS
  
  if (__externalCodecs)
  {
    cod.IsExternal = true;
    for (i = 0; i < __externalCodecs->Codecs.Size(); i++)
    {
      const CCodecInfoEx &codec = __externalCodecs->Codecs[i];
      if (codec.Id == methodId)
      {
        if (encode)
        {
          if (codec.EncoderIsAssigned)
          {
            if (codec.NumStreams == 1)
            {
              HRESULT res = __externalCodecs->GetCodecs->CreateEncoder(i, &IID_ICompressCoder, (void **)&cod.Coder);
              if (res != S_OK && res != E_NOINTERFACE && res != CLASS_E_CLASSNOTAVAILABLE)
                return res;
              if (cod.Coder)
                return res;
              return __externalCodecs->GetCodecs->CreateEncoder(i, &IID_ICompressFilter, (void **)&filter);
            }
            cod.NumStreams = codec.NumStreams;
            return __externalCodecs->GetCodecs->CreateEncoder(i, &IID_ICompressCoder2, (void **)&cod.Coder2);
          }
        }
        else
          if (codec.DecoderIsAssigned)
          {
            if (codec.NumStreams == 1)
            {
              HRESULT res = __externalCodecs->GetCodecs->CreateDecoder(i, &IID_ICompressCoder, (void **)&cod.Coder);
              if (res != S_OK && res != E_NOINTERFACE && res != CLASS_E_CLASSNOTAVAILABLE)
                return res;
              if (cod.Coder)
                return res;
              return __externalCodecs->GetCodecs->CreateDecoder(i, &IID_ICompressFilter, (void **)&filter);
            }
            cod.NumStreams = codec.NumStreams;
            return __externalCodecs->GetCodecs->CreateDecoder(i, &IID_ICompressCoder2, (void **)&cod.Coder2);
          }
      }
    }
  }
  #endif

  return S_OK;
}

HRESULT CreateCoder(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId, bool encode,
    CCreatedCoder &cod)
{
  CMyComPtr<ICompressFilter> filter;
  HRESULT res = CreateCoder(
      EXTERNAL_CODECS_LOC_VARS
      methodId, encode,
      filter, cod);
  
  if (filter)
  {
    cod.IsFilter = true;
    CFilterCoder *coderSpec = new CFilterCoder(encode);
    cod.Coder = coderSpec;
    coderSpec->Filter = filter;
  }
  
  return res;
}

HRESULT CreateCoder(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId, bool encode,
    CMyComPtr<ICompressCoder> &coder)
{
  CCreatedCoder cod;
  HRESULT res = CreateCoder(
      EXTERNAL_CODECS_LOC_VARS
      methodId, encode,
      cod);
  coder = cod.Coder;
  return res;
}

HRESULT CreateFilter(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId, bool encode,
    CMyComPtr<ICompressFilter> &filter)
{
  CCreatedCoder cod;
  return CreateCoder(
      EXTERNAL_CODECS_LOC_VARS
      methodId, encode,
      filter, cod);
}


HRESULT CreateHasher(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId,
    AString &name,
    CMyComPtr<IHasher> &hasher)
{
  name.Empty();

  unsigned i;
  for (i = 0; i < g_NumHashers; i++)
  {
    const CHasherInfo &codec = *g_Hashers[i];
    if (codec.Id == methodId)
    {
      hasher = codec.CreateHasher();
      name = codec.Name;
      break;
    }
  }

  #ifdef EXTERNAL_CODECS

  CHECK_GLOBAL_CODECS

  if (!hasher && __externalCodecs)
    for (i = 0; i < __externalCodecs->Hashers.Size(); i++)
    {
      const CHasherInfoEx &codec = __externalCodecs->Hashers[i];
      if (codec.Id == methodId)
      {
        name = codec.Name;
        return __externalCodecs->GetHashers->CreateHasher((UInt32)i, &hasher);
      }
    }

  #endif

  return S_OK;
}
// CreateCoder.h

#ifndef __CREATE_CODER_H
#define __CREATE_CODER_H

#include "../../Common/MyCom.h"
#include "../../Common/MyString.h"

#include "../ICoder.h"

#include "MethodId.h"

/*
  if EXTERNAL_CODECS is not defined, the code supports only codecs that
      are statically linked at compile-time and link-time.

  if EXTERNAL_CODECS is defined, the code supports also codecs from another
      executable modules, that can be linked dynamically at run-time:
        - EXE module can use codecs from external DLL files.
        - DLL module can use codecs from external EXE and DLL files.
     
      CExternalCodecs contains information about codecs and interfaces to create them.
  
  The order of codecs:
    1) Internal codecs
    2) External codecs
*/

#ifdef EXTERNAL_CODECS

struct CCodecInfoEx
{
  CMethodId Id;
  AString Name;
  UInt32 NumStreams;
  bool EncoderIsAssigned;
  bool DecoderIsAssigned;
  
  CCodecInfoEx(): EncoderIsAssigned(false), DecoderIsAssigned(false) {}
};

struct CHasherInfoEx
{
  CMethodId Id;
  AString Name;
};

#define PUBLIC_ISetCompressCodecsInfo public ISetCompressCodecsInfo,
#define QUERY_ENTRY_ISetCompressCodecsInfo MY_QUERYINTERFACE_ENTRY(ISetCompressCodecsInfo)
#define DECL_ISetCompressCodecsInfo STDMETHOD(SetCompressCodecsInfo)(ICompressCodecsInfo *compressCodecsInfo);
#define IMPL_ISetCompressCodecsInfo2(x) \
STDMETHODIMP x::SetCompressCodecsInfo(ICompressCodecsInfo *compressCodecsInfo) { \
  COM_TRY_BEGIN __externalCodecs.GetCodecs = compressCodecsInfo;  return __externalCodecs.Load(); COM_TRY_END }
#define IMPL_ISetCompressCodecsInfo IMPL_ISetCompressCodecsInfo2(CHandler)

struct CExternalCodecs
{
  CMyComPtr<ICompressCodecsInfo> GetCodecs;
  CMyComPtr<IHashers> GetHashers;

  CObjectVector<CCodecInfoEx> Codecs;
  CObjectVector<CHasherInfoEx> Hashers;

  bool IsSet() const { return GetCodecs != NULL || GetHashers != NULL; }

  HRESULT Load();

  void ClearAndRelease()
  {
    Hashers.Clear();
    Codecs.Clear();
    GetHashers.Release();
    GetCodecs.Release();
  }

  ~CExternalCodecs()
  {
    GetHashers.Release();
    GetCodecs.Release();
  }
};

extern CExternalCodecs g_ExternalCodecs;

#define EXTERNAL_CODECS_VARS2   (__externalCodecs.IsSet() ? &__externalCodecs : &g_ExternalCodecs)
#define EXTERNAL_CODECS_VARS2_L (&__externalCodecs)
#define EXTERNAL_CODECS_VARS2_G (&g_ExternalCodecs)

#define DECL_EXTERNAL_CODECS_VARS CExternalCodecs __externalCodecs;

#define EXTERNAL_CODECS_VARS   EXTERNAL_CODECS_VARS2,
#define EXTERNAL_CODECS_VARS_L EXTERNAL_CODECS_VARS2_L,
#define EXTERNAL_CODECS_VARS_G EXTERNAL_CODECS_VARS2_G,

#define DECL_EXTERNAL_CODECS_LOC_VARS2 const CExternalCodecs *__externalCodecs
#define EXTERNAL_CODECS_LOC_VARS2 __externalCodecs

#define DECL_EXTERNAL_CODECS_LOC_VARS DECL_EXTERNAL_CODECS_LOC_VARS2,
#define EXTERNAL_CODECS_LOC_VARS EXTERNAL_CODECS_LOC_VARS2,

#else

#define PUBLIC_ISetCompressCodecsInfo
#define QUERY_ENTRY_ISetCompressCodecsInfo
#define DECL_ISetCompressCodecsInfo
#define IMPL_ISetCompressCodecsInfo
#define EXTERNAL_CODECS_VARS2
#define DECL_EXTERNAL_CODECS_VARS
#define EXTERNAL_CODECS_VARS
#define EXTERNAL_CODECS_VARS_L
#define EXTERNAL_CODECS_VARS_G
#define DECL_EXTERNAL_CODECS_LOC_VARS2
#define EXTERNAL_CODECS_LOC_VARS2
#define DECL_EXTERNAL_CODECS_LOC_VARS
#define EXTERNAL_CODECS_LOC_VARS

#endif




bool FindMethod(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const AString &name,
    CMethodId &methodId, UInt32 &numStreams);

bool FindMethod(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId,
    AString &name);

bool FindHashMethod(
    DECL_EXTERNAL_CODECS_LOC_VARS
    const AString &name,
    CMethodId &methodId);

void GetHashMethods(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CRecordVector<CMethodId> &methods);


struct CCreatedCoder
{
  CMyComPtr<ICompressCoder> Coder;
  CMyComPtr<ICompressCoder2> Coder2;
  
  bool IsExternal;
  bool IsFilter; // = true, if Coder was created from filter
  UInt32 NumStreams;

  // CCreatedCoder(): IsExternal(false), IsFilter(false), NumStreams(1) {}
};


HRESULT CreateCoder(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId, bool encode,
    CMyComPtr<ICompressFilter> &filter,
    CCreatedCoder &cod);

HRESULT CreateCoder(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId, bool encode,
    CCreatedCoder &cod);

HRESULT CreateCoder(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId, bool encode,
    CMyComPtr<ICompressCoder> &coder);

HRESULT CreateFilter(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId, bool encode,
    CMyComPtr<ICompressFilter> &filter);

HRESULT CreateHasher(
    DECL_EXTERNAL_CODECS_LOC_VARS
    CMethodId methodId,
    AString &name,
    CMyComPtr<IHasher> &hasher);

#endif
// FilePathAutoRename.cpp

#include "StdAfx.h"

#include "../../Common/Defs.h"
#include "../../Common/IntToString.h"

#include "../../Windows/FileFind.h"

#include "FilePathAutoRename.h"

using namespace NWindows;

static bool MakeAutoName(const FString &name,
    const FString &extension, UInt32 value, FString &path)
{
  char temp[16];
  ConvertUInt32ToString(value, temp);
  path = name;
  path.AddAscii(temp);
  path += extension;
  return NFile::NFind::DoesFileOrDirExist(path);
}

bool AutoRenamePath(FString &path)
{
  int dotPos = path.ReverseFind_Dot();
  int slashPos = path.ReverseFind_PathSepar();

  FString name = path;
  FString extension;
  if (dotPos > slashPos + 1)
  {
    name.DeleteFrom(dotPos);
    extension = path.Ptr(dotPos);
  }
  name += FTEXT('_');
  
  FString temp;

  UInt32 left = 1, right = ((UInt32)1 << 30);
  while (left != right)
  {
    UInt32 mid = (left + right) / 2;
    if (MakeAutoName(name, extension, mid, temp))
      left = mid + 1;
    else
      right = mid;
  }
  return !MakeAutoName(name, extension, right, path);
}
// FilePathAutoRename.h

#ifndef __FILE_PATH_AUTO_RENAME_H
#define __FILE_PATH_AUTO_RENAME_H

#include "../../Common/MyString.h"

bool AutoRenamePath(FString &fullProcessedPath);

#endif
// FileStreams.cpp

#include "StdAfx.h"

#ifndef _WIN32
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#endif

#ifdef SUPPORT_DEVICE_FILE
#include "../../../C/Alloc.h"
#include "../../Common/Defs.h"
#endif

#include "FileStreams.h"

static inline HRESULT ConvertBoolToHRESULT(bool result)
{
  #ifdef _WIN32
  if (result)
    return S_OK;
  DWORD lastError = ::GetLastError();
  if (lastError == 0)
    return E_FAIL;
  return HRESULT_FROM_WIN32(lastError);
  #else
  return result ? S_OK: E_FAIL;
  #endif
}


static const UInt32 kClusterSize = 1 << 18;
CInFileStream::CInFileStream(bool b):
  #ifdef SUPPORT_DEVICE_FILE
  VirtPos(0),
  PhyPos(0),
  Buf(0),
  BufSize(0),
  #endif
  SupportHardLinks(false),
  Callback(NULL),
  CallbackRef(0)
{
  _ignoreSymbolicLink = b;
}

CInFileStream::~CInFileStream()
{
  #ifdef SUPPORT_DEVICE_FILE
  MidFree(Buf);
  #endif

  if (Callback)
    Callback->InFileStream_On_Destroy(CallbackRef);
}

STDMETHODIMP CInFileStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  #ifdef USE_WIN_FILE
  
  #ifdef SUPPORT_DEVICE_FILE
  if (processedSize)
    *processedSize = 0;
  if (size == 0)
    return S_OK;
  if (File.IsDeviceFile)
  {
    if (File.SizeDefined)
    {
      if (VirtPos >= File.Size)
        return VirtPos == File.Size ? S_OK : E_FAIL;
      UInt64 rem = File.Size - VirtPos;
      if (size > rem)
        size = (UInt32)rem;
    }
    for (;;)
    {
      const UInt32 mask = kClusterSize - 1;
      const UInt64 mask2 = ~(UInt64)mask;
      UInt64 alignedPos = VirtPos & mask2;
      if (BufSize > 0 && BufStartPos == alignedPos)
      {
        UInt32 pos = (UInt32)VirtPos & mask;
        if (pos >= BufSize)
          return S_OK;
        UInt32 rem = MyMin(BufSize - pos, size);
        memcpy(data, Buf + pos, rem);
        VirtPos += rem;
        if (processedSize)
          *processedSize += rem;
        return S_OK;
      }
      
      bool useBuf = false;
      if ((VirtPos & mask) != 0 || ((ptrdiff_t)data & mask) != 0 )
        useBuf = true;
      else
      {
        UInt64 end = VirtPos + size;
        if ((end & mask) != 0)
        {
          end &= mask2;
          if (end <= VirtPos)
            useBuf = true;
          else
            size = (UInt32)(end - VirtPos);
        }
      }
      if (!useBuf)
        break;
      if (alignedPos != PhyPos)
      {
        UInt64 realNewPosition;
        bool result = File.Seek(alignedPos, FILE_BEGIN, realNewPosition);
        if (!result)
          return ConvertBoolToHRESULT(result);
        PhyPos = realNewPosition;
      }

      BufStartPos = alignedPos;
      UInt32 readSize = kClusterSize;
      if (File.SizeDefined)
        readSize = (UInt32)MyMin(File.Size - PhyPos, (UInt64)kClusterSize);

      if (!Buf)
      {
        Buf = (Byte *)MidAlloc(kClusterSize);
        if (!Buf)
          return E_OUTOFMEMORY;
      }
      bool result = File.Read1(Buf, readSize, BufSize);
      if (!result)
        return ConvertBoolToHRESULT(result);

      if (BufSize == 0)
        return S_OK;
      PhyPos += BufSize;
    }

    if (VirtPos != PhyPos)
    {
      UInt64 realNewPosition;
      bool result = File.Seek(VirtPos, FILE_BEGIN, realNewPosition);
      if (!result)
        return ConvertBoolToHRESULT(result);
      PhyPos = VirtPos = realNewPosition;
    }
  }
  #endif

  UInt32 realProcessedSize;
  bool result = File.ReadPart(data, size, realProcessedSize);
  if (processedSize)
    *processedSize = realProcessedSize;

  #ifdef SUPPORT_DEVICE_FILE
  VirtPos += realProcessedSize;
  PhyPos += realProcessedSize;
  #endif

  if (result)
    return S_OK;

  {
    DWORD error = ::GetLastError();

    if (Callback)
      return Callback->InFileStream_On_Error(CallbackRef, error);
    if (error == 0)
      return E_FAIL;

    return HRESULT_FROM_WIN32(error);
  }

  #else
  
  if (processedSize)
    *processedSize = 0;
  ssize_t res = File.Read(data, (size_t)size);
  if (res == -1)
  {
    if (Callback)
      return Callback->InFileStream_On_Error(CallbackRef, E_FAIL);
    return E_FAIL;
  }
  if (processedSize)
    *processedSize = (UInt32)res;
  return S_OK;

  #endif
}

#ifdef UNDER_CE
STDMETHODIMP CStdInFileStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  size_t s2 = fread(data, 1, size, stdin);
  int error = ferror(stdin);
  if (processedSize)
    *processedSize = s2;
  if (s2 <= size && error == 0)
    return S_OK;
  return E_FAIL;
}
#else
STDMETHODIMP CStdInFileStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  #ifdef _WIN32
  
  DWORD realProcessedSize;
  UInt32 sizeTemp = (1 << 20);
  if (sizeTemp > size)
    sizeTemp = size;
  BOOL res = ::ReadFile(GetStdHandle(STD_INPUT_HANDLE), data, sizeTemp, &realProcessedSize, NULL);
  if (processedSize)
    *processedSize = realProcessedSize;
  if (res == FALSE && GetLastError() == ERROR_BROKEN_PIPE)
    return S_OK;
  return ConvertBoolToHRESULT(res != FALSE);
  
  #else

  if (processedSize)
    *processedSize = 0;
  ssize_t res;
  do
  {
    res = read(0, data, (size_t)size);
  }
  while (res < 0 && (errno == EINTR));
  if (res == -1)
    return E_FAIL;
  if (processedSize)
    *processedSize = (UInt32)res;
  return S_OK;
  
  #endif
}
  
#endif

STDMETHODIMP CInFileStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  if (seekOrigin >= 3)
    return STG_E_INVALIDFUNCTION;

  #ifdef USE_WIN_FILE

  #ifdef SUPPORT_DEVICE_FILE
  if (File.IsDeviceFile && (File.SizeDefined || seekOrigin != STREAM_SEEK_END))
  {
    switch (seekOrigin)
    {
      case STREAM_SEEK_SET: break;
      case STREAM_SEEK_CUR: offset += VirtPos; break;
      case STREAM_SEEK_END: offset += File.Size; break;
      default: return STG_E_INVALIDFUNCTION;
    }
    if (offset < 0)
      return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
    VirtPos = offset;
    if (newPosition)
      *newPosition = offset;
    return S_OK;
  }
  #endif
  
  UInt64 realNewPosition;
  bool result = File.Seek(offset, seekOrigin, realNewPosition);
  
  #ifdef SUPPORT_DEVICE_FILE
  PhyPos = VirtPos = realNewPosition;
  #endif

  if (newPosition)
    *newPosition = realNewPosition;
  return ConvertBoolToHRESULT(result);
  
  #else
  
  off_t res = File.Seek((off_t)offset, seekOrigin);
  if (res == -1)
    return E_FAIL;
  if (newPosition)
    *newPosition = (UInt64)res;
  return S_OK;
  
  #endif
}

STDMETHODIMP CInFileStream::GetSize(UInt64 *size)
{
  return ConvertBoolToHRESULT(File.GetLength(*size));
}

#if 0 // #ifdef USE_WIN_FILE

STDMETHODIMP CInFileStream::GetProps(UInt64 *size, FILETIME *cTime, FILETIME *aTime, FILETIME *mTime, UInt32 *attrib)
{
  BY_HANDLE_FILE_INFORMATION info;
  if (File.GetFileInformation(&info))
  {
    if (size) *size = (((UInt64)info.nFileSizeHigh) << 32) + info.nFileSizeLow;
    if (cTime) *cTime = info.ftCreationTime;
    if (aTime) *aTime = info.ftLastAccessTime;
    if (mTime) *mTime = info.ftLastWriteTime;
    if (attrib) *attrib = info.dwFileAttributes;
    return S_OK;
  }
  return GetLastError();
}

STDMETHODIMP CInFileStream::GetProps2(CStreamFileProps *props)
{
  BY_HANDLE_FILE_INFORMATION info;
  if (File.GetFileInformation(&info))
  {
    props->Size = (((UInt64)info.nFileSizeHigh) << 32) + info.nFileSizeLow;
    props->VolID = info.dwVolumeSerialNumber;
    props->FileID_Low = (((UInt64)info.nFileIndexHigh) << 32) + info.nFileIndexLow;
    props->FileID_High = 0;
    props->NumLinks = SupportHardLinks ? info.nNumberOfLinks : 1;
    props->Attrib = info.dwFileAttributes;
    props->CTime = info.ftCreationTime;
    props->ATime = info.ftLastAccessTime;
    props->MTime = info.ftLastWriteTime;
    return S_OK;
  }
  return GetLastError();
}

#endif

//////////////////////////
// COutFileStream

HRESULT COutFileStream::Close()
{
  return ConvertBoolToHRESULT(File.Close());
}

STDMETHODIMP COutFileStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  #ifdef USE_WIN_FILE

  UInt32 realProcessedSize;
  bool result = File.Write(data, size, realProcessedSize);
  ProcessedSize += realProcessedSize;
  if (processedSize)
    *processedSize = realProcessedSize;
  return ConvertBoolToHRESULT(result);
  
  #else
  
  if (processedSize)
    *processedSize = 0;
  ssize_t res = File.Write(data, (size_t)size);
  if (res == -1)
    return E_FAIL;
  if (processedSize)
    *processedSize = (UInt32)res;
  ProcessedSize += res;
  return S_OK;
  
  #endif
}
  
STDMETHODIMP COutFileStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  if (seekOrigin >= 3)
    return STG_E_INVALIDFUNCTION;
  
  #ifdef USE_WIN_FILE

  UInt64 realNewPosition;
  bool result = File.Seek(offset, seekOrigin, realNewPosition);
  if (newPosition)
    *newPosition = realNewPosition;
  return ConvertBoolToHRESULT(result);
  
  #else
  
  off_t res = File.Seek((off_t)offset, seekOrigin);
  if (res == -1)
    return E_FAIL;
  if (newPosition)
    *newPosition = (UInt64)res;
  return S_OK;
  
  #endif
}

STDMETHODIMP COutFileStream::SetSize(UInt64 newSize)
{
  #ifdef USE_WIN_FILE
  
  UInt64 currentPos;
  if (!File.Seek(0, FILE_CURRENT, currentPos))
    return E_FAIL;
  bool result = File.SetLength(newSize);
  UInt64 currentPos2;
  result = result && File.Seek(currentPos, currentPos2);
  return result ? S_OK : E_FAIL;
  
  #else
  
  return E_FAIL;
  
  #endif
}

HRESULT COutFileStream::GetSize(UInt64 *size)
{
  return ConvertBoolToHRESULT(File.GetLength(*size));
}

#ifdef UNDER_CE

STDMETHODIMP CStdOutFileStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  size_t s2 = fwrite(data, 1, size, stdout);
  if (processedSize)
    *processedSize = s2;
  return (s2 == size) ? S_OK : E_FAIL;
}

#else

STDMETHODIMP CStdOutFileStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;

  #ifdef _WIN32

  UInt32 realProcessedSize;
  BOOL res = TRUE;
  if (size > 0)
  {
    // Seems that Windows doesn't like big amounts writing to stdout.
    // So we limit portions by 32KB.
    UInt32 sizeTemp = (1 << 15);
    if (sizeTemp > size)
      sizeTemp = size;
    res = ::WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
        data, sizeTemp, (DWORD *)&realProcessedSize, NULL);
    _size += realProcessedSize;
    size -= realProcessedSize;
    data = (const void *)((const Byte *)data + realProcessedSize);
    if (processedSize)
      *processedSize += realProcessedSize;
  }
  return ConvertBoolToHRESULT(res != FALSE);

  #else
  
  ssize_t res;

  do
  {
    res = write(1, data, (size_t)size);
  }
  while (res < 0 && (errno == EINTR));
  
  if (res == -1)
    return E_FAIL;

  _size += (size_t)res;
  if (processedSize)
    *processedSize = (UInt32)res;
  return S_OK;
  
  #endif
}

#endif
// FileStreams.h

#ifndef __FILE_STREAMS_H
#define __FILE_STREAMS_H

#if defined(_WIN32) || defined(UNIX_USE_WIN_FILE)
#define USE_WIN_FILE
#endif

#include "../../Common/MyString.h"

#ifdef USE_WIN_FILE
#include "../../Windows/FileIO.h"
#else
#include "../../Common/C_FileIO.h"
#endif

#include "../../Common/MyCom.h"

#include "../IStream.h"

#if 1 // FIXME #ifdef _WIN32
typedef UINT_PTR My_UINT_PTR;
#else
typedef UINT My_UINT_PTR;
#endif

struct IInFileStream_Callback
{
  virtual HRESULT InFileStream_On_Error(My_UINT_PTR val, DWORD error) = 0;
  virtual void InFileStream_On_Destroy(My_UINT_PTR val) = 0;
};

class CInFileStream:
  public IInStream,
  public IStreamGetSize,
  #if 0 // #ifdef USE_WIN_FILE
  public IStreamGetProps,
  public IStreamGetProps2,
  #endif
  public CMyUnknownImp
{
  bool _ignoreSymbolicLink;
public:
  #ifdef USE_WIN_FILE
  NWindows::NFile::NIO::CInFile File;
  
  #ifdef SUPPORT_DEVICE_FILE
  UInt64 VirtPos;
  UInt64 PhyPos;
  UInt64 BufStartPos;
  Byte *Buf;
  UInt32 BufSize;
  #endif

  #else
  NC::NFile::NIO::CInFile File;
  #endif

  bool SupportHardLinks;

  IInFileStream_Callback *Callback;
  My_UINT_PTR CallbackRef;

  virtual ~CInFileStream();

  CInFileStream(bool b=false);
  
  bool Open(CFSTR fileName)
  {
  #ifdef USE_WIN_FILE
    return File.Open(fileName,_ignoreSymbolicLink);
  #else
    return File.Open(fileName);
  #endif
  }
  
  bool OpenShared(CFSTR fileName, bool shareForWrite)
  {
    return this->Open(fileName); // return File.OpenShared(fileName, shareForWrite);
  }

  MY_QUERYINTERFACE_BEGIN2(IInStream)
  MY_QUERYINTERFACE_ENTRY(IStreamGetSize)
  #if 0 // #ifdef USE_WIN_FILE
  MY_QUERYINTERFACE_ENTRY(IStreamGetProps)
  MY_QUERYINTERFACE_ENTRY(IStreamGetProps2)
  #endif
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);

  STDMETHOD(GetSize)(UInt64 *size);
  #if 0 // #ifdef USE_WIN_FILE
  STDMETHOD(GetProps)(UInt64 *size, FILETIME *cTime, FILETIME *aTime, FILETIME *mTime, UInt32 *attrib);
  STDMETHOD(GetProps2)(CStreamFileProps *props);
  #endif
};

class CStdInFileStream:
  public ISequentialInStream,
  public CMyUnknownImp
{
public:
  MY_UNKNOWN_IMP

  virtual ~CStdInFileStream() {}
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
};

class COutFileStream:
  public IOutStream,
  public CMyUnknownImp
{
public:
  #ifdef USE_WIN_FILE
  NWindows::NFile::NIO::COutFile File;
  #else
  NC::NFile::NIO::COutFile File;
  #endif
  virtual ~COutFileStream() {}
  bool Create(CFSTR fileName, bool createAlways)
  {
    ProcessedSize = 0;
    return File.Create(fileName, createAlways);
  }
  bool Open(CFSTR fileName, DWORD creationDisposition)
  {
    ProcessedSize = 0;
    return File.Open(fileName, creationDisposition);
  }

  HRESULT Close();
  
  UInt64 ProcessedSize;

  #ifdef USE_WIN_FILE
  bool SetTime(const FILETIME *cTime, const FILETIME *aTime, const FILETIME *mTime)
  {
    return File.SetTime(cTime, aTime, mTime);
  }
  bool SetMTime(const FILETIME *mTime) {  return File.SetMTime(mTime); }
  #endif


  MY_UNKNOWN_IMP1(IOutStream)

  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
  STDMETHOD(SetSize)(UInt64 newSize);

  HRESULT GetSize(UInt64 *size);
};

class CStdOutFileStream:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  UInt64 _size;
public:
  MY_UNKNOWN_IMP

  UInt64 GetSize() const { return _size; }
  CStdOutFileStream(): _size(0) {}
  virtual ~CStdOutFileStream() {}
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
};

#endif
// FilterCoder.cpp

#include "StdAfx.h"

#include "../../Common/Defs.h"

#include "FilterCoder.h"
#include "StreamUtils.h"

/*
  AES filters need 16-bytes alignment for HARDWARE-AES instructions.
  So we call IFilter::Filter(, size), where (size != 16 * N) only for last data block.

  AES-CBC filters need data size aligned for 16-bytes.
  So the encoder can add zeros to the end of original stream.

  Some filters (BCJ and others) don't process data at the end of stream in some cases.
  So the encoder and decoder write such last bytes without change.
*/


static const UInt32 kBufSize = 1 << 20;

STDMETHODIMP CFilterCoder::SetInBufSize(UInt32 , UInt32 size) { _inBufSize = size; return S_OK; }
STDMETHODIMP CFilterCoder::SetOutBufSize(UInt32 , UInt32 size) { _outBufSize = size; return S_OK; }

HRESULT CFilterCoder::Alloc()
{
  UInt32 size = MyMin(_inBufSize, _outBufSize);
  /* minimal bufSize is 16 bytes for AES and IA64 filter.
     bufSize for AES must be aligned for 16 bytes.
     We use (1 << 12) min size to support future aligned filters. */
  const UInt32 kMinSize = 1 << 12;
  size &= ~(UInt32)(kMinSize - 1);
  if (size < kMinSize)
    size = kMinSize;
  if (!_buf || _bufSize != size)
  {
    AllocAlignedMask(size, 16 - 1);
    if (!_buf)
      return E_OUTOFMEMORY;
    _bufSize = size;
  }
  return S_OK;
}

HRESULT CFilterCoder::Init_and_Alloc()
{
  RINOK(Filter->Init());
  return Alloc();
}

CFilterCoder::CFilterCoder(bool encodeMode):
    _bufSize(0),
    _inBufSize(kBufSize),
    _outBufSize(kBufSize),
    _encodeMode(encodeMode),
    _outSizeIsDefined(false),
    _outSize(0),
    _nowPos64(0)
  {}

CFilterCoder::~CFilterCoder()
{
}

STDMETHODIMP CFilterCoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  RINOK(Init_and_Alloc());
  
  UInt64 nowPos64 = 0;
  bool inputFinished = false;
  UInt32 pos = 0;

  while (!outSize || nowPos64 < *outSize)
  {
    UInt32 endPos = pos;
    
    if (!inputFinished)
    {
      size_t processedSize = _bufSize - pos;
      RINOK(ReadStream(inStream, _buf + pos, &processedSize));
      endPos = pos + (UInt32)processedSize;
      inputFinished = (endPos != _bufSize);
    }

    pos = Filter->Filter(_buf, endPos);
    
    if (pos > endPos)
    {
      // AES
      if (!inputFinished || pos > _bufSize)
        return E_FAIL;
      if (!_encodeMode)
        return S_FALSE;
      
      do
        _buf[endPos] = 0;
      while (++endPos != pos);
      
      if (pos != Filter->Filter(_buf, pos))
        return E_FAIL;
    }

    if (endPos == 0)
      return S_OK;

    UInt32 size = (pos != 0 ? pos : endPos);
    if (outSize)
    {
      UInt64 remSize = *outSize - nowPos64;
      if (size > remSize)
        size = (UInt32)remSize;
    }
    
    RINOK(WriteStream(outStream, _buf, size));
    nowPos64 += size;

    if (pos == 0)
      return S_OK;

    if (progress)
      RINOK(progress->SetRatioInfo(&nowPos64, &nowPos64));

    UInt32 i = 0;
    while (pos < endPos)
      _buf[i++] = _buf[pos++];
    pos = i;
  }

  return S_OK;
}



// ---------- Write to Filter ----------

STDMETHODIMP CFilterCoder::SetOutStream(ISequentialOutStream *outStream)
{
  _outStream = outStream;
  return S_OK;
}

STDMETHODIMP CFilterCoder::ReleaseOutStream()
{
  _outStream.Release();
  return S_OK;
}

HRESULT CFilterCoder::Flush2()
{
  while (_convSize != 0)
  {
    UInt32 num = _convSize;
    if (_outSizeIsDefined)
    {
      UInt64 rem = _outSize - _nowPos64;
      if (num > rem)
        num = (UInt32)rem;
      if (num == 0)
        return k_My_HRESULT_WritingWasCut;
    }
    
    UInt32 processed = 0;
    HRESULT res = _outStream->Write(_buf + _convPos, num, &processed);
    if (processed == 0)
      return res != S_OK ? res : E_FAIL;
    
    _convPos += processed;
    _convSize -= processed;
    _nowPos64 += processed;
    RINOK(res);
  }
    
  if (_convPos != 0)
  {
    UInt32 num = _bufPos - _convPos;
    for (UInt32 i = 0; i < num; i++)
      _buf[i] = _buf[_convPos + i];
    _bufPos = num;
    _convPos = 0;
  }
    
  return S_OK;
}

STDMETHODIMP CFilterCoder::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  
  while (size != 0)
  {
    RINOK(Flush2());

    // _convSize is 0
    // _convPos is 0
    // _bufPos is small

    if (_bufPos != _bufSize)
    {
      UInt32 num = MyMin(size, _bufSize - _bufPos);
      memcpy(_buf + _bufPos, data, num);
      size -= num;
      data = (const Byte *)data + num;
      if (processedSize)
        *processedSize += num;
      _bufPos += num;
      if (_bufPos != _bufSize)
        continue;
    }

    // _bufPos == _bufSize
    _convSize = Filter->Filter(_buf, _bufPos);
    
    if (_convSize == 0)
      break;
    if (_convSize > _bufPos)
    {
      // that case is not possible.
      _convSize = 0;
      return E_FAIL;
    }
  }

  return S_OK;
}

STDMETHODIMP CFilterCoder::OutStreamFinish()
{
  for (;;)
  {
    RINOK(Flush2());
    if (_bufPos == 0)
      break;
    _convSize = Filter->Filter(_buf, _bufPos);
    if (_convSize == 0)
      _convSize = _bufPos;
    else if (_convSize > _bufPos)
    {
      // AES
      if (_convSize > _bufSize)
      {
        _convSize = 0;
        return E_FAIL;
      }
      if (!_encodeMode)
      {
        _convSize = 0;
        return S_FALSE;
      }
      for (; _bufPos < _convSize; _bufPos++)
        _buf[_bufPos] = 0;
      _convSize = Filter->Filter(_buf, _bufPos);
      if (_convSize != _bufPos)
        return E_FAIL;
    }
  }
  
  CMyComPtr<IOutStreamFinish> finish;
  _outStream.QueryInterface(IID_IOutStreamFinish, &finish);
  if (finish)
    return finish->OutStreamFinish();
  return S_OK;
}

// ---------- Init functions ----------

STDMETHODIMP CFilterCoder::InitEncoder()
{
  InitSpecVars();
  return Init_and_Alloc();
}

HRESULT CFilterCoder::Init_NoSubFilterInit()
{
  InitSpecVars();
  return Alloc();
}

STDMETHODIMP CFilterCoder::SetOutStreamSize(const UInt64 *outSize)
{
  InitSpecVars();
  if (outSize)
  {
    _outSize = *outSize;
    _outSizeIsDefined = true;
  }
  return Init_and_Alloc();
}

// ---------- Read from Filter ----------

STDMETHODIMP CFilterCoder::SetInStream(ISequentialInStream *inStream)
{
  _inStream = inStream;
  return S_OK;
}

STDMETHODIMP CFilterCoder::ReleaseInStream()
{
  _inStream.Release();
  return S_OK;
}


STDMETHODIMP CFilterCoder::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  
  while (size != 0)
  {
    if (_convSize != 0)
    {
      if (size > _convSize)
        size = _convSize;
      if (_outSizeIsDefined)
      {
        UInt64 rem = _outSize - _nowPos64;
        if (size > rem)
          size = (UInt32)rem;
      }
      memcpy(data, _buf + _convPos, size);
      _convPos += size;
      _convSize -= size;
      _nowPos64 += size;
      if (processedSize)
        *processedSize = size;
      break;
    }
  
    if (_convPos != 0)
    {
      UInt32 num = _bufPos - _convPos;
      for (UInt32 i = 0; i < num; i++)
        _buf[i] = _buf[_convPos + i];
      _bufPos = num;
      _convPos = 0;
    }
    
    {
      size_t readSize = _bufSize - _bufPos;
      HRESULT res = ReadStream(_inStream, _buf + _bufPos, &readSize);
      _bufPos += (UInt32)readSize;
      RINOK(res);
    }
    
    _convSize = Filter->Filter(_buf, _bufPos);
    
    if (_convSize == 0)
    {
      if (_bufPos == 0)
        break;
      // BCJ
      _convSize = _bufPos;
      continue;
    }
    
    if (_convSize > _bufPos)
    {
      // AES
      if (_convSize > _bufSize)
        return E_FAIL;
      if (!_encodeMode)
        return S_FALSE;
      
      do
        _buf[_bufPos] = 0;
      while (++_bufPos != _convSize);
      
      _convSize = Filter->Filter(_buf, _convSize);
      if (_convSize != _bufPos)
        return E_FAIL;
    }
  }
 
  return S_OK;
}


#ifndef _NO_CRYPTO

STDMETHODIMP CFilterCoder::CryptoSetPassword(const Byte *data, UInt32 size)
  { return _SetPassword->CryptoSetPassword(data, size); }

STDMETHODIMP CFilterCoder::SetKey(const Byte *data, UInt32 size)
  { return _CryptoProperties->SetKey(data, size); }

STDMETHODIMP CFilterCoder::SetInitVector(const Byte *data, UInt32 size)
  { return _CryptoProperties->SetInitVector(data, size); }

#endif


#ifndef EXTRACT_ONLY

STDMETHODIMP CFilterCoder::SetCoderProperties(const PROPID *propIDs,
    const PROPVARIANT *properties, UInt32 numProperties)
  { return _SetCoderProperties->SetCoderProperties(propIDs, properties, numProperties); }

STDMETHODIMP CFilterCoder::WriteCoderProperties(ISequentialOutStream *outStream)
  { return _WriteCoderProperties->WriteCoderProperties(outStream); }

/*
STDMETHODIMP CFilterCoder::ResetSalt()
  { return _CryptoResetSalt->ResetSalt(); }
*/

STDMETHODIMP CFilterCoder::ResetInitVector()
  { return _CryptoResetInitVector->ResetInitVector(); }

#endif


STDMETHODIMP CFilterCoder::SetDecoderProperties2(const Byte *data, UInt32 size)
  { return _SetDecoderProperties2->SetDecoderProperties2(data, size); }
// FilterCoder.h

#ifndef __FILTER_CODER_H
#define __FILTER_CODER_H

#include "../../../C/Alloc.h"

#include "../../Common/MyCom.h"
#include "../ICoder.h"

#ifndef _NO_CRYPTO
#include "../IPassword.h"
#endif

#define MY_QUERYINTERFACE_ENTRY_AG(i, sub0, sub) else if (iid == IID_ ## i) \
  { if (!sub) RINOK(sub0->QueryInterface(IID_ ## i, (void **)&sub)) \
    *outObject = (void *)(i *)this; }


struct CAlignedMidBuffer
{
  #ifdef _WIN32

  Byte *_buf;

  CAlignedMidBuffer(): _buf(NULL) {}
  ~CAlignedMidBuffer() { ::MidFree(_buf); }
  
  void AllocAlignedMask(size_t size, size_t)
  {
    ::MidFree(_buf);
    _buf = (Byte *)::MidAlloc(size);
  }
  
  #else
  
  Byte *_bufBase;
  Byte *_buf;

  CAlignedMidBuffer(): _bufBase(NULL), _buf(NULL) {}
  ~CAlignedMidBuffer() { ::MidFree(_bufBase); }
  
  void AllocAlignedMask(size_t size, size_t alignMask)
  {
    ::MidFree(_bufBase);
    _buf = NULL;
    _bufBase = (Byte *)::MidAlloc(size + alignMask);
    
    if (_bufBase)
    {
      // _buf = (Byte *)(((uintptr_t)_bufBase + alignMask) & ~(uintptr_t)alignMask);
         _buf = (Byte *)(((ptrdiff_t)_bufBase + alignMask) & ~(ptrdiff_t)alignMask);
    }
  }
  
  #endif
};

class CFilterCoder:
  public ICompressCoder,
  
  public ICompressSetOutStreamSize,
  public ICompressInitEncoder,
 
  public ICompressSetInStream,
  public ISequentialInStream,
  
  public ICompressSetOutStream,
  public ISequentialOutStream,
  public IOutStreamFinish,
  
  public ICompressSetBufSize,

  #ifndef _NO_CRYPTO
  public ICryptoSetPassword,
  public ICryptoProperties,
  #endif
  
  #ifndef EXTRACT_ONLY
  public ICompressSetCoderProperties,
  public ICompressWriteCoderProperties,
  // public ICryptoResetSalt,
  public ICryptoResetInitVector,
  #endif
  
  public ICompressSetDecoderProperties2,
  public CMyUnknownImp,
  public CAlignedMidBuffer
{
  UInt32 _bufSize;
  UInt32 _inBufSize;
  UInt32 _outBufSize;

  bool _encodeMode;
  bool _outSizeIsDefined;
  UInt64 _outSize;
  UInt64 _nowPos64;

  CMyComPtr<ISequentialInStream> _inStream;
  CMyComPtr<ISequentialOutStream> _outStream;
  UInt32 _bufPos;
  UInt32 _convPos;    // current pos in buffer for converted data
  UInt32 _convSize;   // size of converted data starting from _convPos
  
  void InitSpecVars()
  {
    _bufPos = 0;
    _convPos = 0;
    _convSize = 0;

    _outSizeIsDefined = false;
    _outSize = 0;
    _nowPos64 = 0;
  }

  HRESULT Alloc();
  HRESULT Init_and_Alloc();
  HRESULT Flush2();

  #ifndef _NO_CRYPTO
  CMyComPtr<ICryptoSetPassword> _SetPassword;
  CMyComPtr<ICryptoProperties> _CryptoProperties;
  #endif

  #ifndef EXTRACT_ONLY
  CMyComPtr<ICompressSetCoderProperties> _SetCoderProperties;
  CMyComPtr<ICompressWriteCoderProperties> _WriteCoderProperties;
  // CMyComPtr<ICryptoResetSalt> _CryptoResetSalt;
  CMyComPtr<ICryptoResetInitVector> _CryptoResetInitVector;
  #endif

  CMyComPtr<ICompressSetDecoderProperties2> _SetDecoderProperties2;

public:
  CMyComPtr<ICompressFilter> Filter;

  CFilterCoder(bool encodeMode);
  ~CFilterCoder();

  class C_InStream_Releaser
  {
  public:
    CFilterCoder *FilterCoder;
    C_InStream_Releaser(): FilterCoder(NULL) {}
    ~C_InStream_Releaser() { if (FilterCoder) FilterCoder->ReleaseInStream(); }
  };
  
  class C_OutStream_Releaser
  {
  public:
    CFilterCoder *FilterCoder;
    C_OutStream_Releaser(): FilterCoder(NULL) {}
    ~C_OutStream_Releaser() { if (FilterCoder) FilterCoder->ReleaseOutStream(); }
  };

  MY_QUERYINTERFACE_BEGIN2(ICompressCoder)

    MY_QUERYINTERFACE_ENTRY(ICompressSetOutStreamSize)
    MY_QUERYINTERFACE_ENTRY(ICompressInitEncoder)
    
    MY_QUERYINTERFACE_ENTRY(ICompressSetInStream)
    MY_QUERYINTERFACE_ENTRY(ISequentialInStream)
    
    MY_QUERYINTERFACE_ENTRY(ICompressSetOutStream)
    MY_QUERYINTERFACE_ENTRY(ISequentialOutStream)
    MY_QUERYINTERFACE_ENTRY(IOutStreamFinish)
    
    MY_QUERYINTERFACE_ENTRY(ICompressSetBufSize)

    #ifndef _NO_CRYPTO
    MY_QUERYINTERFACE_ENTRY_AG(ICryptoSetPassword, Filter, _SetPassword)
    MY_QUERYINTERFACE_ENTRY_AG(ICryptoProperties, Filter, _CryptoProperties)
    #endif

    #ifndef EXTRACT_ONLY
    MY_QUERYINTERFACE_ENTRY_AG(ICompressSetCoderProperties, Filter, _SetCoderProperties)
    MY_QUERYINTERFACE_ENTRY_AG(ICompressWriteCoderProperties, Filter, _WriteCoderProperties)
    // MY_QUERYINTERFACE_ENTRY_AG(ICryptoResetSalt, Filter, _CryptoResetSalt)
    MY_QUERYINTERFACE_ENTRY_AG(ICryptoResetInitVector, Filter, _CryptoResetInitVector)
    #endif

    MY_QUERYINTERFACE_ENTRY_AG(ICompressSetDecoderProperties2, Filter, _SetDecoderProperties2)
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE
  
  
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  
  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);
  STDMETHOD(InitEncoder)();

  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
  STDMETHOD(ReleaseInStream)();
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);

  STDMETHOD(SetOutStream)(ISequentialOutStream *outStream);
  STDMETHOD(ReleaseOutStream)();
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(OutStreamFinish)();
  
  STDMETHOD(SetInBufSize)(UInt32 streamIndex, UInt32 size);
  STDMETHOD(SetOutBufSize)(UInt32 streamIndex, UInt32 size);

  #ifndef _NO_CRYPTO
  STDMETHOD(CryptoSetPassword)(const Byte *data, UInt32 size);

  STDMETHOD(SetKey)(const Byte *data, UInt32 size);
  STDMETHOD(SetInitVector)(const Byte *data, UInt32 size);
  #endif
  
  #ifndef EXTRACT_ONLY
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs,
      const PROPVARIANT *properties, UInt32 numProperties);
  STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStream);
  // STDMETHOD(ResetSalt)();
  STDMETHOD(ResetInitVector)();
  #endif
  
  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);

  
  HRESULT Init_NoSubFilterInit();
};

#endif
// InBuffer.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "InBuffer.h"

CInBufferBase::CInBufferBase() throw():
  _buf(0),
  _bufLim(0),
  _bufBase(0),
  _stream(0),
  _processedSize(0),
  _bufSize(0),
  _wasFinished(false),
  NumExtraBytes(0)
{}

bool CInBuffer::Create(size_t bufSize) throw()
{
  const unsigned kMinBlockSize = 1;
  if (bufSize < kMinBlockSize)
    bufSize = kMinBlockSize;
  if (_bufBase != 0 && _bufSize == bufSize)
    return true;
  Free();
  _bufSize = bufSize;
  _bufBase = (Byte *)::MidAlloc(bufSize);
  return (_bufBase != 0);
}

void CInBuffer::Free() throw()
{
  ::MidFree(_bufBase);
  _bufBase = 0;
}

void CInBufferBase::Init() throw()
{
  _processedSize = 0;
  _buf = _bufBase;
  _bufLim = _buf;
  _wasFinished = false;
  #ifdef _NO_EXCEPTIONS
  ErrorCode = S_OK;
  #endif
  NumExtraBytes = 0;
}

bool CInBufferBase::ReadBlock()
{
  #ifdef _NO_EXCEPTIONS
  if (ErrorCode != S_OK)
    return false;
  #endif
  if (_wasFinished)
    return false;
  _processedSize += (_buf - _bufBase);
  _buf = _bufBase;
  _bufLim = _bufBase;
  UInt32 processed;
  // FIX_ME: we can improve it to support (_bufSize >= (1 << 32))
  HRESULT result = _stream->Read(_bufBase, (UInt32)_bufSize, &processed);
  #ifdef _NO_EXCEPTIONS
  ErrorCode = result;
  #else
  if (result != S_OK)
    throw CInBufferException(result);
  #endif
  _bufLim = _buf + processed;
  _wasFinished = (processed == 0);
  return !_wasFinished;
}

bool CInBufferBase::ReadByte_FromNewBlock(Byte &b)
{
  if (!ReadBlock())
  {
    NumExtraBytes++;
    b = 0xFF;
    return false;
  }
  b = *_buf++;
  return true;
}

Byte CInBufferBase::ReadByte_FromNewBlock()
{
  if (!ReadBlock())
  {
    NumExtraBytes++;
    return 0xFF;
  }
  return *_buf++;
}

size_t CInBufferBase::ReadBytes(Byte *buf, size_t size)
{
  if ((size_t)(_bufLim - _buf) >= size)
  {
    const Byte *src = _buf;
    for (size_t i = 0; i < size; i++)
      buf[i] = src[i];
    _buf += size;
    return size;
  }
  for (size_t i = 0; i < size; i++)
  {
    if (_buf >= _bufLim)
      if (!ReadBlock())
        return i;
    buf[i] = *_buf++;
  }
  return size;
}

size_t CInBufferBase::Skip(size_t size)
{
  size_t processed = 0;
  for (;;)
  {
    size_t rem = (_bufLim - _buf);
    if (rem >= size)
    {
      _buf += size;
      return processed + size;
    }
    _buf += rem;
    processed += rem;
    size -= rem;
    if (!ReadBlock())
      return processed;
  }
}
// InBuffer.h

#ifndef __IN_BUFFER_H
#define __IN_BUFFER_H

#include "../../Common/MyException.h"
#include "../IStream.h"

#ifndef _NO_EXCEPTIONS
struct CInBufferException: public CSystemException
{
  CInBufferException(HRESULT errorCode): CSystemException(errorCode) {}
};
#endif

class CInBufferBase
{
protected:
  Byte *_buf;
  Byte *_bufLim;
  Byte *_bufBase;

  ISequentialInStream *_stream;
  UInt64 _processedSize;
  size_t _bufSize; // actually it's number of Bytes for next read. The buf can be larger
                   // only up to 32-bits values now are supported!
  bool _wasFinished;

  bool ReadBlock();
  bool ReadByte_FromNewBlock(Byte &b);
  Byte ReadByte_FromNewBlock();

public:
  #ifdef _NO_EXCEPTIONS
  HRESULT ErrorCode;
  #endif
  UInt32 NumExtraBytes;

  CInBufferBase() throw();

  UInt64 GetStreamSize() const { return _processedSize + (_buf - _bufBase); }
  UInt64 GetProcessedSize() const { return _processedSize + NumExtraBytes + (_buf - _bufBase); }
  bool WasFinished() const { return _wasFinished; }

  void SetStream(ISequentialInStream *stream) { _stream = stream; }
  
  void SetBuf(Byte *buf, size_t bufSize, size_t end, size_t pos)
  {
    _bufBase = buf;
    _bufSize = bufSize;
    _processedSize = 0;
    _buf = buf + pos;
    _bufLim = buf + end;
    _wasFinished = false;
    #ifdef _NO_EXCEPTIONS
    ErrorCode = S_OK;
    #endif
    NumExtraBytes = 0;
  }

  void Init() throw();

  bool ReadByte(Byte &b)
  {
    if (_buf >= _bufLim)
      return ReadByte_FromNewBlock(b);
    b = *_buf++;
    return true;
  }
  
  Byte ReadByte()
  {
    if (_buf >= _bufLim)
      return ReadByte_FromNewBlock();
    return *_buf++;
  }
  
  size_t ReadBytes(Byte *buf, size_t size);
  size_t Skip(size_t size);
};

class CInBuffer: public CInBufferBase
{
public:
  ~CInBuffer() { Free(); }
  bool Create(size_t bufSize) throw(); // only up to 32-bits values now are supported!
  void Free() throw();
};

#endif
// InOutTempBuffer.cpp

#include "StdAfx.h"

#include "../../../C/7zCrc.h"

#include "../../Common/Defs.h"

#include "InOutTempBuffer.h"
#include "StreamUtils.h"

using namespace NWindows;
using namespace NFile;
using namespace NDir;

static const size_t kTempBufSize = (1 << 20);

static CFSTR kTempFilePrefixString = FTEXT("7zt");

CInOutTempBuffer::CInOutTempBuffer(): _buf(NULL) { }

void CInOutTempBuffer::Create()
{
  if (!_buf)
    _buf = new Byte[kTempBufSize];
}

CInOutTempBuffer::~CInOutTempBuffer()
{
  delete []_buf;
}

void CInOutTempBuffer::InitWriting()
{
  _bufPos = 0;
  _tempFileCreated = false;
  _size = 0;
  _crc = CRC_INIT_VAL;
}

bool CInOutTempBuffer::WriteToFile(const void *data, UInt32 size)
{
  if (size == 0)
    return true;
  if (!_tempFileCreated)
  {
    if (!_tempFile.CreateRandomInTempFolder(kTempFilePrefixString, &_outFile))
      return false;
    _tempFileCreated = true;
  }
  UInt32 processed;
  if (!_outFile.Write(data, size, processed))
    return false;
  _crc = CrcUpdate(_crc, data, processed);
  _size += processed;
  return (processed == size);
}

bool CInOutTempBuffer::Write(const void *data, UInt32 size)
{
  if (size == 0)
    return true;
  size_t cur = kTempBufSize - _bufPos;
  if (cur != 0)
  {
    if (cur > size)
      cur = size;
    memcpy(_buf + _bufPos, data, cur);
    _crc = CrcUpdate(_crc, data, cur);
    _bufPos += cur;
    _size += cur;
    size -= (UInt32)cur;
    data = ((const Byte *)data) + cur;
  }
  return WriteToFile(data, size);
}

HRESULT CInOutTempBuffer::WriteToStream(ISequentialOutStream *stream)
{
  if (!_outFile.Close())
    return E_FAIL;

  UInt64 size = 0;
  UInt32 crc = CRC_INIT_VAL;

  if (_bufPos != 0)
  {
    RINOK(WriteStream(stream, _buf, _bufPos));
    crc = CrcUpdate(crc, _buf, _bufPos);
    size += _bufPos;
  }
  
  if (_tempFileCreated)
  {
    NIO::CInFile inFile;
    if (!inFile.Open(_tempFile.GetPath()))
      return E_FAIL;
    while (size < _size)
    {
      UInt32 processed;
      if (!inFile.ReadPart(_buf, kTempBufSize, processed))
        return E_FAIL;
      if (processed == 0)
        break;
      RINOK(WriteStream(stream, _buf, processed));
      crc = CrcUpdate(crc, _buf, processed);
      size += processed;
    }
  }
  
  return (_crc == crc && size == _size) ? S_OK : E_FAIL;
}

/*
STDMETHODIMP CSequentialOutTempBufferImp::Write(const void *data, UInt32 size, UInt32 *processed)
{
  if (!_buf->Write(data, size))
  {
    if (processed)
      *processed = 0;
    return E_FAIL;
  }
  if (processed)
    *processed = size;
  return S_OK;
}
*/
// InOutTempBuffer.h

#ifndef __IN_OUT_TEMP_BUFFER_H
#define __IN_OUT_TEMP_BUFFER_H

#include "../../Common/MyCom.h"
#include "../../Windows/FileDir.h"

#include "../IStream.h"

class CInOutTempBuffer
{
  NWindows::NFile::NDir::CTempFile _tempFile;
  NWindows::NFile::NIO::COutFile _outFile;
  Byte *_buf;
  size_t _bufPos;
  UInt64 _size;
  UInt32 _crc;
  bool _tempFileCreated;

  bool WriteToFile(const void *data, UInt32 size);
public:
  CInOutTempBuffer();
  ~CInOutTempBuffer();
  void Create();

  void InitWriting();
  bool Write(const void *data, UInt32 size);

  HRESULT WriteToStream(ISequentialOutStream *stream);
  UInt64 GetDataSize() const { return _size; }
};

/*
class CSequentialOutTempBufferImp:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  CInOutTempBuffer *_buf;
public:
  void Init(CInOutTempBuffer *buffer)  { _buf = buffer; }
  MY_UNKNOWN_IMP

  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
};
*/

#endif
// LimitedStreams.cpp

#include "StdAfx.h"

#include <string.h>

#include "LimitedStreams.h"

STDMETHODIMP CLimitedSequentialInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  UInt32 realProcessedSize = 0;
  {
    const UInt64 rem = _size - _pos;
    if (size > rem)
      size = (UInt32)rem;
  }
  HRESULT result = S_OK;
  if (size != 0)
  {
    result = _stream->Read(data, size, &realProcessedSize);
    _pos += realProcessedSize;
    if (realProcessedSize == 0)
      _wasFinished = true;
  }
  if (processedSize)
    *processedSize = realProcessedSize;
  return result;
}

STDMETHODIMP CLimitedInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (_virtPos >= _size)
  {
    // 9.31: Fixed. Windows doesn't return error in ReadFile and IStream->Read in that case.
    return S_OK;
    // return (_virtPos == _size) ? S_OK: E_FAIL; // ERROR_HANDLE_EOF
  }
  {
    const UInt64 rem = _size - _virtPos;
    if (size > rem)
      size = (UInt32)rem;
  }
  UInt64 newPos = _startOffset + _virtPos;
  if (newPos != _physPos)
  {
    _physPos = newPos;
    RINOK(SeekToPhys());
  }
  HRESULT res = _stream->Read(data, size, &size);
  if (processedSize)
    *processedSize = size;
  _physPos += size;
  _virtPos += size;
  return res;
}

STDMETHODIMP CLimitedInStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _virtPos; break;
    case STREAM_SEEK_END: offset += _size; break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _virtPos = offset;
  if (newPosition)
    *newPosition = _virtPos;
  return S_OK;
}

HRESULT CreateLimitedInStream(IInStream *inStream, UInt64 pos, UInt64 size, ISequentialInStream **resStream)
{
  *resStream = 0;
  CLimitedInStream *streamSpec = new CLimitedInStream;
  CMyComPtr<ISequentialInStream> streamTemp = streamSpec;
  streamSpec->SetStream(inStream);
  RINOK(streamSpec->InitAndSeek(pos, size));
  streamSpec->SeekToStart();
  *resStream = streamTemp.Detach();
  return S_OK;
}

STDMETHODIMP CClusterInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (_virtPos >= Size)
    return S_OK;
  {
    UInt64 rem = Size - _virtPos;
    if (size > rem)
      size = (UInt32)rem;
  }
  if (size == 0)
    return S_OK;

  if (_curRem == 0)
  {
    const UInt32 blockSize = (UInt32)1 << BlockSizeLog;
    const UInt32 virtBlock = (UInt32)(_virtPos >> BlockSizeLog);
    const UInt32 offsetInBlock = (UInt32)_virtPos & (blockSize - 1);
    const UInt32 phyBlock = Vector[virtBlock];
    
    UInt64 newPos = StartOffset + ((UInt64)phyBlock << BlockSizeLog) + offsetInBlock;
    if (newPos != _physPos)
    {
      _physPos = newPos;
      RINOK(SeekToPhys());
    }

    _curRem = blockSize - offsetInBlock;
    
    for (int i = 1; i < 64 && (virtBlock + i) < (UInt32)Vector.Size() && phyBlock + i == Vector[virtBlock + i]; i++)
      _curRem += (UInt32)1 << BlockSizeLog;
  }
  
  if (size > _curRem)
    size = _curRem;
  HRESULT res = Stream->Read(data, size, &size);
  if (processedSize)
    *processedSize = size;
  _physPos += size;
  _virtPos += size;
  _curRem -= size;
  return res;
}
 
STDMETHODIMP CClusterInStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _virtPos; break;
    case STREAM_SEEK_END: offset += Size; break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  if (_virtPos != (UInt64)offset)
    _curRem = 0;
  _virtPos = offset;
  if (newPosition)
    *newPosition = offset;
  return S_OK;
}


STDMETHODIMP CExtentsStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (_virtPos >= Extents.Back().Virt)
    return S_OK;
  if (size == 0)
    return S_OK;
  
  unsigned left = 0, right = Extents.Size() - 1;
  for (;;)
  {
    unsigned mid = (left + right) / 2;
    if (mid == left)
      break;
    if (_virtPos < Extents[mid].Virt)
      right = mid;
    else
      left = mid;
  }
  
  const CSeekExtent &extent = Extents[left];
  UInt64 phyPos = extent.Phy + (_virtPos - extent.Virt);
  if (_needStartSeek || _phyPos != phyPos)
  {
    _needStartSeek = false;
    _phyPos = phyPos;
    RINOK(SeekToPhys());
  }
  
  UInt64 rem = Extents[left + 1].Virt - _virtPos;
  if (size > rem)
    size = (UInt32)rem;
  
  HRESULT res = Stream->Read(data, size, &size);
  _phyPos += size;
  _virtPos += size;
  if (processedSize)
    *processedSize = size;
  return res;
}

STDMETHODIMP CExtentsStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _virtPos; break;
    case STREAM_SEEK_END: offset += Extents.Back().Virt; break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _virtPos = offset;
  if (newPosition)
    *newPosition = _virtPos;
  return S_OK;
}


STDMETHODIMP CLimitedSequentialOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  HRESULT result = S_OK;
  if (processedSize)
    *processedSize = 0;
  if (size > _size)
  {
    if (_size == 0)
    {
      _overflow = true;
      if (!_overflowIsAllowed)
        return E_FAIL;
      if (processedSize)
        *processedSize = size;
      return S_OK;
    }
    size = (UInt32)_size;
  }
  if (_stream)
    result = _stream->Write(data, size, &size);
  _size -= size;
  if (processedSize)
    *processedSize = size;
  return result;
}


STDMETHODIMP CTailInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  UInt32 cur;
  HRESULT res = Stream->Read(data, size, &cur);
  if (processedSize)
    *processedSize = cur;
  _virtPos += cur;
  return res;
}
  
STDMETHODIMP CTailInStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _virtPos; break;
    case STREAM_SEEK_END:
    {
      UInt64 pos = 0;
      RINOK(Stream->Seek(offset, STREAM_SEEK_END, &pos));
      if (pos < Offset)
        return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
      _virtPos = pos - Offset;
      if (newPosition)
        *newPosition = _virtPos;
      return S_OK;
    }
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _virtPos = offset;
  if (newPosition)
    *newPosition = _virtPos;
  return Stream->Seek(Offset + _virtPos, STREAM_SEEK_SET, NULL);
}

STDMETHODIMP CLimitedCachedInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (_virtPos >= _size)
  {
    // 9.31: Fixed. Windows doesn't return error in ReadFile and IStream->Read in that case.
    return S_OK;
    // return (_virtPos == _size) ? S_OK: E_FAIL; // ERROR_HANDLE_EOF
  }
  UInt64 rem = _size - _virtPos;
  if (rem < size)
    size = (UInt32)rem;

  UInt64 newPos = _startOffset + _virtPos;
  UInt64 offsetInCache = newPos - _cachePhyPos;
  HRESULT res = S_OK;
  if (newPos >= _cachePhyPos &&
      offsetInCache <= _cacheSize &&
      size <= _cacheSize - (size_t)offsetInCache)
  {
    if (size != 0)
      memcpy(data, _cache + (size_t)offsetInCache, size);
  }
  else
  {
    if (newPos != _physPos)
    {
      _physPos = newPos;
      RINOK(SeekToPhys());
    }
    res = _stream->Read(data, size, &size);
    _physPos += size;
  }
  if (processedSize)
    *processedSize = size;
  _virtPos += size;
  return res;
}

STDMETHODIMP CLimitedCachedInStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _virtPos; break;
    case STREAM_SEEK_END: offset += _size; break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _virtPos = offset;
  if (newPosition)
    *newPosition = _virtPos;
  return S_OK;
}

STDMETHODIMP CTailOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  UInt32 cur;
  HRESULT res = Stream->Write(data, size, &cur);
  if (processedSize)
    *processedSize = cur;
  _virtPos += cur;
  if (_virtSize < _virtPos)
    _virtSize = _virtPos;
  return res;
}
  
STDMETHODIMP CTailOutStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _virtPos; break;
    case STREAM_SEEK_END: offset += _virtSize; break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _virtPos = offset;
  if (newPosition)
    *newPosition = _virtPos;
  return Stream->Seek(Offset + _virtPos, STREAM_SEEK_SET, NULL);
}

STDMETHODIMP CTailOutStream::SetSize(UInt64 newSize)
{
  _virtSize = newSize;
  return Stream->SetSize(Offset + newSize);
}
// LimitedStreams.h

#ifndef __LIMITED_STREAMS_H
#define __LIMITED_STREAMS_H

#include "../../Common/MyBuffer.h"
#include "../../Common/MyCom.h"
#include "../../Common/MyVector.h"
#include "../IStream.h"

class CLimitedSequentialInStream:
  public ISequentialInStream,
  public CMyUnknownImp
{
  CMyComPtr<ISequentialInStream> _stream;
  UInt64 _size;
  UInt64 _pos;
  bool _wasFinished;
public:
  void SetStream(ISequentialInStream *stream) { _stream = stream; }
  void ReleaseStream() { _stream.Release(); }
  void Init(UInt64 streamSize)
  {
    _size = streamSize;
    _pos = 0;
    _wasFinished = false;
  }
 
  MY_UNKNOWN_IMP1(ISequentialInStream)

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  UInt64 GetSize() const { return _pos; }
  UInt64 GetRem() const { return _size - _pos; }
  bool WasFinished() const { return _wasFinished; }
};

class CLimitedInStream:
  public IInStream,
  public CMyUnknownImp
{
  CMyComPtr<IInStream> _stream;
  UInt64 _virtPos;
  UInt64 _physPos;
  UInt64 _size;
  UInt64 _startOffset;

  HRESULT SeekToPhys() { return _stream->Seek(_physPos, STREAM_SEEK_SET, NULL); }
public:
  void SetStream(IInStream *stream) { _stream = stream; }
  HRESULT InitAndSeek(UInt64 startOffset, UInt64 size)
  {
    _startOffset = startOffset;
    _physPos = startOffset;
    _virtPos = 0;
    _size = size;
    return SeekToPhys();
  }
 
  MY_UNKNOWN_IMP2(ISequentialInStream, IInStream)

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);

  HRESULT SeekToStart() { return Seek(0, STREAM_SEEK_SET, NULL); }
};

HRESULT CreateLimitedInStream(IInStream *inStream, UInt64 pos, UInt64 size, ISequentialInStream **resStream);

class CClusterInStream:
  public IInStream,
  public CMyUnknownImp
{
  UInt64 _virtPos;
  UInt64 _physPos;
  UInt32 _curRem;
public:
  unsigned BlockSizeLog;
  UInt64 Size;
  CMyComPtr<IInStream> Stream;
  CRecordVector<UInt32> Vector;
  UInt64 StartOffset;

  HRESULT SeekToPhys() { return Stream->Seek(_physPos, STREAM_SEEK_SET, NULL); }

  HRESULT InitAndSeek()
  {
    _curRem = 0;
    _virtPos = 0;
    _physPos = StartOffset;
    if (Vector.Size() > 0)
    {
      _physPos = StartOffset + (Vector[0] << BlockSizeLog);
      return SeekToPhys();
    }
    return S_OK;
  }

  MY_UNKNOWN_IMP2(ISequentialInStream, IInStream)

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
};

struct CSeekExtent
{
  UInt64 Phy;
  UInt64 Virt;
};

class CExtentsStream:
  public IInStream,
  public CMyUnknownImp
{
  UInt64 _phyPos;
  UInt64 _virtPos;
  bool _needStartSeek;

  HRESULT SeekToPhys() { return Stream->Seek(_phyPos, STREAM_SEEK_SET, NULL); }

public:
  CMyComPtr<IInStream> Stream;
  CRecordVector<CSeekExtent> Extents;

  MY_UNKNOWN_IMP2(ISequentialInStream, IInStream)
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
  void ReleaseStream() { Stream.Release(); }

  void Init()
  {
    _virtPos = 0;
    _phyPos = 0;
    _needStartSeek = true;
  }
};

class CLimitedSequentialOutStream:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  CMyComPtr<ISequentialOutStream> _stream;
  UInt64 _size;
  bool _overflow;
  bool _overflowIsAllowed;
public:
  MY_UNKNOWN_IMP1(ISequentialOutStream)
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  void SetStream(ISequentialOutStream *stream) { _stream = stream; }
  void ReleaseStream() { _stream.Release(); }
  void Init(UInt64 size, bool overflowIsAllowed = false)
  {
    _size = size;
    _overflow = false;
    _overflowIsAllowed = overflowIsAllowed;
  }
  bool IsFinishedOK() const { return (_size == 0 && !_overflow); }
  UInt64 GetRem() const { return _size; }
};


class CTailInStream:
  public IInStream,
  public CMyUnknownImp
{
  UInt64 _virtPos;
public:
  CMyComPtr<IInStream> Stream;
  UInt64 Offset;

  void Init()
  {
    _virtPos = 0;
  }
 
  MY_UNKNOWN_IMP2(ISequentialInStream, IInStream)

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);

  HRESULT SeekToStart() { return Stream->Seek(Offset, STREAM_SEEK_SET, NULL); }
};

class CLimitedCachedInStream:
  public IInStream,
  public CMyUnknownImp
{
  CMyComPtr<IInStream> _stream;
  UInt64 _virtPos;
  UInt64 _physPos;
  UInt64 _size;
  UInt64 _startOffset;
  
  const Byte *_cache;
  size_t _cacheSize;
  size_t _cachePhyPos;


  HRESULT SeekToPhys() { return _stream->Seek(_physPos, STREAM_SEEK_SET, NULL); }
public:
  CByteBuffer Buffer;

  void SetStream(IInStream *stream) { _stream = stream; }
  void SetCache(size_t cacheSize, size_t cachePos)
  {
    _cache = Buffer;
    _cacheSize = cacheSize;
    _cachePhyPos = cachePos;
  }

  HRESULT InitAndSeek(UInt64 startOffset, UInt64 size)
  {
    _startOffset = startOffset;
    _physPos = startOffset;
    _virtPos = 0;
    _size = size;
    return SeekToPhys();
  }
 
  MY_UNKNOWN_IMP2(ISequentialInStream, IInStream)

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);

  HRESULT SeekToStart() { return Seek(0, STREAM_SEEK_SET, NULL); }
};

class CTailOutStream:
  public IOutStream,
  public CMyUnknownImp
{
  UInt64 _virtPos;
  UInt64 _virtSize;
public:
  CMyComPtr<IOutStream> Stream;
  UInt64 Offset;
  
  virtual ~CTailOutStream() {}

  MY_UNKNOWN_IMP2(ISequentialOutStream, IOutStream)

  void Init()
  {
    _virtPos = 0;
    _virtSize = 0;
  }

  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
  STDMETHOD(SetSize)(UInt64 newSize);
};

#endif
// MemBlocks.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "MemBlocks.h"
#include "StreamUtils.h"

bool CMemBlockManager::AllocateSpace(size_t numBlocks)
{
  FreeSpace();
  if (_blockSize < sizeof(void *) || numBlocks < 1)
    return false;
  size_t totalSize = numBlocks * _blockSize;
  if (totalSize / _blockSize != numBlocks)
    return false;
  _data = ::MidAlloc(totalSize);
  if (_data == 0)
    return false;
  Byte *p = (Byte *)_data;
  for (size_t i = 0; i + 1 < numBlocks; i++, p += _blockSize)
    *(Byte **)p = (p + _blockSize);
  *(Byte **)p = 0;
  _headFree = _data;
  return true;
}

void CMemBlockManager::FreeSpace()
{
  ::MidFree(_data);
  _data = 0;
  _headFree= 0;
}

void *CMemBlockManager::AllocateBlock()
{
  if (_headFree == 0)
    return 0;
  void *p = _headFree;
  _headFree = *(void **)_headFree;
  return p;
}

void CMemBlockManager::FreeBlock(void *p)
{
  if (p == 0)
    return;
  *(void **)p = _headFree;
  _headFree = p;
}


HRes CMemBlockManagerMt::AllocateSpace(NWindows::NSynchronization::CSynchro *sync ,size_t numBlocks, size_t numNoLockBlocks)
{
  if (numNoLockBlocks > numBlocks)
    return E_INVALIDARG;
  if (!CMemBlockManager::AllocateSpace(numBlocks))
    return E_OUTOFMEMORY;
  size_t numLockBlocks = numBlocks - numNoLockBlocks;
  Semaphore.Close();
  return Semaphore.Create(sync,(LONG)numLockBlocks, (LONG)numLockBlocks);
}

HRes CMemBlockManagerMt::AllocateSpaceAlways(NWindows::NSynchronization::CSynchro *sync, size_t desiredNumberOfBlocks, size_t numNoLockBlocks)
{
  if (numNoLockBlocks > desiredNumberOfBlocks)
    return E_INVALIDARG;
  for (;;)
  {
    if (AllocateSpace(sync,desiredNumberOfBlocks, numNoLockBlocks) == 0)
      return 0;
    if (desiredNumberOfBlocks == numNoLockBlocks)
      return E_OUTOFMEMORY;
    desiredNumberOfBlocks = numNoLockBlocks + ((desiredNumberOfBlocks - numNoLockBlocks) >> 1);
  }
}

void CMemBlockManagerMt::FreeSpace()
{
  Semaphore.Close();
  CMemBlockManager::FreeSpace();
}

void *CMemBlockManagerMt::AllocateBlock()
{
  // Semaphore.Lock();
  NWindows::NSynchronization::CCriticalSectionLock lock(_criticalSection);
  return CMemBlockManager::AllocateBlock();
}

void CMemBlockManagerMt::FreeBlock(void *p, bool lockMode)
{
  if (p == 0)
    return;
  {
    NWindows::NSynchronization::CCriticalSectionLock lock(_criticalSection);
    CMemBlockManager::FreeBlock(p);
  }
  if (lockMode)
    Semaphore.Release();
}

void CMemBlocks::Free(CMemBlockManagerMt *manager)
{
  while (Blocks.Size() > 0)
  {
    manager->FreeBlock(Blocks.Back());
    Blocks.DeleteBack();
  }
  TotalSize = 0;
}

void CMemBlocks::FreeOpt(CMemBlockManagerMt *manager)
{
  Free(manager);
  Blocks.ClearAndFree();
}

HRESULT CMemBlocks::WriteToStream(size_t blockSize, ISequentialOutStream *outStream) const
{
  UInt64 totalSize = TotalSize;
  for (unsigned blockIndex = 0; totalSize > 0; blockIndex++)
  {
    UInt32 curSize = (UInt32)blockSize;
    if (totalSize < curSize)
      curSize = (UInt32)totalSize;
    if (blockIndex >= Blocks.Size())
      return E_FAIL;
    RINOK(WriteStream(outStream, Blocks[blockIndex], curSize));
    totalSize -= curSize;
  }
  return S_OK;
}


void CMemLockBlocks::FreeBlock(int index, CMemBlockManagerMt *memManager)
{
  memManager->FreeBlock(Blocks[index], LockMode);
  Blocks[index] = 0;
}

void CMemLockBlocks::Free(CMemBlockManagerMt *memManager)
{
  while (Blocks.Size() > 0)
  {
    FreeBlock(Blocks.Size() - 1, memManager);
    Blocks.DeleteBack();
  }
  TotalSize = 0;
}

HRes CMemLockBlocks::SwitchToNoLockMode(CMemBlockManagerMt *memManager)
{
  if (LockMode)
  {
    if (Blocks.Size() > 0)
    {
      RINOK(memManager->ReleaseLockedBlocks(Blocks.Size()));
    }
    LockMode = false;
  }
  return 0;
}

void CMemLockBlocks::Detach(CMemLockBlocks &blocks, CMemBlockManagerMt *memManager)
{
  blocks.Free(memManager);
  blocks.LockMode = LockMode;
  UInt64 totalSize = 0;
  size_t blockSize = memManager->GetBlockSize();
  FOR_VECTOR (i, Blocks)
  {
    if (totalSize < TotalSize)
      blocks.Blocks.Add(Blocks[i]);
    else
      FreeBlock(i, memManager);
    Blocks[i] = 0;
    totalSize += blockSize;
  }
  blocks.TotalSize = TotalSize;
  Free(memManager);
}
// MemBlocks.h

#ifndef __MEM_BLOCKS_H
#define __MEM_BLOCKS_H

#include "../../Common/MyVector.h"

#include "../../Windows/Synchronization.h"

#include "../IStream.h"

class CMemBlockManager
{
  void *_data;
  size_t _blockSize;
  void *_headFree;
public:
  CMemBlockManager(size_t blockSize = (1 << 20)): _data(0), _blockSize(blockSize), _headFree(0) {}
  ~CMemBlockManager() { FreeSpace(); }

  bool AllocateSpace(size_t numBlocks);
  void FreeSpace();
  size_t GetBlockSize() const { return _blockSize; }
  void *AllocateBlock();
  void FreeBlock(void *p);
};


class CMemBlockManagerMt: public CMemBlockManager
{
  NWindows::NSynchronization::CCriticalSection _criticalSection;
public:
  NWindows::NSynchronization::CSemaphoreWFMO Semaphore;

  CMemBlockManagerMt(size_t blockSize = (1 << 20)): CMemBlockManager(blockSize) {}
  ~CMemBlockManagerMt() { FreeSpace(); }

  HRes AllocateSpace(NWindows::NSynchronization::CSynchro *sync ,size_t numBlocks, size_t numNoLockBlocks = 0);
  HRes AllocateSpaceAlways(NWindows::NSynchronization::CSynchro *sync, size_t desiredNumberOfBlocks, size_t numNoLockBlocks = 0);
  void FreeSpace();
  void *AllocateBlock();
  void FreeBlock(void *p, bool lockMode = true);
  HRes ReleaseLockedBlocks(int number) { return Semaphore.Release(number); }
};


class CMemBlocks
{
  void Free(CMemBlockManagerMt *manager);
public:
  CRecordVector<void *> Blocks;
  UInt64 TotalSize;
  
  CMemBlocks(): TotalSize(0) {}

  void FreeOpt(CMemBlockManagerMt *manager);
  HRESULT WriteToStream(size_t blockSize, ISequentialOutStream *outStream) const;
};

struct CMemLockBlocks: public CMemBlocks
{
  bool LockMode;

  CMemLockBlocks(): LockMode(true) {};
  void Free(CMemBlockManagerMt *memManager);
  void FreeBlock(int index, CMemBlockManagerMt *memManager);
  HRes SwitchToNoLockMode(CMemBlockManagerMt *memManager);
  void Detach(CMemLockBlocks &blocks, CMemBlockManagerMt *memManager);
};

#endif
// MethodId.cpp

#include "StdAfx.h"
// MethodId.h

#ifndef __7Z_METHOD_ID_H
#define __7Z_METHOD_ID_H

#include "../../Common/MyTypes.h"

typedef UInt64 CMethodId;

#endif
// MethodProps.cpp

#include "StdAfx.h"

#include "../../Common/StringToInt.h"

#include "MethodProps.h"

using namespace NWindows;

bool StringToBool(const UString &s, bool &res)
{
  if (s.IsEmpty() || (s[0] == '+' && s[1] == 0) || StringsAreEqualNoCase_Ascii(s, "ON"))
  {
    res = true;
    return true;
  }
  if ((s[0] == '-' && s[1] == 0) || StringsAreEqualNoCase_Ascii(s, "OFF"))
  {
    res = false;
    return true;
  }
  return false;
}

HRESULT PROPVARIANT_to_bool(const PROPVARIANT &prop, bool &dest)
{
  switch (prop.vt)
  {
    case VT_EMPTY: dest = true; return S_OK;
    case VT_BOOL: dest = (prop.boolVal != VARIANT_FALSE); return S_OK;
    case VT_BSTR: return StringToBool(prop.bstrVal, dest) ? S_OK : E_INVALIDARG;
  }
  return E_INVALIDARG;
}

unsigned ParseStringToUInt32(const UString &srcString, UInt32 &number)
{
  const wchar_t *start = srcString;
  const wchar_t *end;
  number = ConvertStringToUInt32(start, &end);
  return (unsigned)(end - start);
}

HRESULT ParsePropToUInt32(const UString &name, const PROPVARIANT &prop, UInt32 &resValue)
{
  // =VT_UI4
  // =VT_EMPTY
  // {stringUInt32}=VT_EMPTY

  if (prop.vt == VT_UI4)
  {
    if (!name.IsEmpty())
      return E_INVALIDARG;
    resValue = prop.ulVal;
    return S_OK;
  }
  if (prop.vt != VT_EMPTY)
    return E_INVALIDARG;
  if (name.IsEmpty())
    return S_OK;
  UInt32 v;
  if (ParseStringToUInt32(name, v) != name.Len())
    return E_INVALIDARG;
  resValue = v;
  return S_OK;
}

HRESULT ParseMtProp(const UString &name, const PROPVARIANT &prop, UInt32 defaultNumThreads, UInt32 &numThreads)
{
  if (name.IsEmpty())
  {
    switch (prop.vt)
    {
      case VT_UI4:
        numThreads = prop.ulVal;
        break;
      default:
      {
        bool val;
        RINOK(PROPVARIANT_to_bool(prop, val));
        numThreads = (val ? defaultNumThreads : 1);
        break;
      }
    }
    return S_OK;
  }
  if (prop.vt != VT_EMPTY)
    return E_INVALIDARG;
  return ParsePropToUInt32(name, prop, numThreads);
}


static HRESULT StringToDictSize(const UString &s, NCOM::CPropVariant &destProp)
{
  const wchar_t *end;
  UInt32 number = ConvertStringToUInt32(s, &end);
  unsigned numDigits = (unsigned)(end - s);
  if (numDigits == 0 || s.Len() > numDigits + 1)
    return E_INVALIDARG;
  
  if (s.Len() == numDigits)
  {
    if (number >= 64)
      return E_INVALIDARG;
    if (number < 32)
      destProp = (UInt32)((UInt32)1 << (unsigned)number);
    else
      destProp = (UInt64)((UInt64)1 << (unsigned)number);
    return S_OK;
  }
  
  unsigned numBits;
  
  switch (MyCharLower_Ascii(s[numDigits]))
  {
    case 'b': destProp = number; return S_OK;
    case 'k': numBits = 10; break;
    case 'm': numBits = 20; break;
    case 'g': numBits = 30; break;
    default: return E_INVALIDARG;
  }
  
  if (number < ((UInt32)1 << (32 - numBits)))
    destProp = (UInt32)(number << numBits);
  else
    destProp = (UInt64)((UInt64)number << numBits);
  
  return S_OK;
}


static HRESULT PROPVARIANT_to_DictSize(const PROPVARIANT &prop, NCOM::CPropVariant &destProp)
{
  if (prop.vt == VT_UI4)
  {
    UInt32 v = prop.ulVal;
    if (v >= 64)
      return E_INVALIDARG;
    if (v < 32)
      destProp = (UInt32)((UInt32)1 << (unsigned)v);
    else
      destProp = (UInt64)((UInt64)1 << (unsigned)v);
    return S_OK;
  }
  if (prop.vt == VT_BSTR)
    return StringToDictSize(prop.bstrVal, destProp);
  return E_INVALIDARG;
}


void CProps::AddProp32(PROPID propid, UInt32 level)
{
  CProp &prop = Props.AddNew();
  prop.IsOptional = true;
  prop.Id = propid;
  prop.Value = (UInt32)level;
}

class CCoderProps
{
  PROPID *_propIDs;
  NCOM::CPropVariant *_props;
  unsigned _numProps;
  unsigned _numPropsMax;
public:
  CCoderProps(unsigned numPropsMax)
  {
    _numPropsMax = numPropsMax;
    _numProps = 0;
    _propIDs = new PROPID[numPropsMax];
    _props = new NCOM::CPropVariant[numPropsMax];
  }
  ~CCoderProps()
  {
    delete []_propIDs;
    delete []_props;
  }
  void AddProp(const CProp &prop);
  HRESULT SetProps(ICompressSetCoderProperties *setCoderProperties)
  {
    return setCoderProperties->SetCoderProperties(_propIDs, _props, _numProps);
  }
};

void CCoderProps::AddProp(const CProp &prop)
{
  if (_numProps >= _numPropsMax)
    throw 1;
  _propIDs[_numProps] = prop.Id;
  _props[_numProps] = prop.Value;
  _numProps++;
}

HRESULT CProps::SetCoderProps(ICompressSetCoderProperties *scp, const UInt64 *dataSizeReduce) const
{
  CCoderProps coderProps(Props.Size() + (dataSizeReduce ? 1 : 0));
  FOR_VECTOR (i, Props)
    coderProps.AddProp(Props[i]);
  if (dataSizeReduce)
  {
    CProp prop;
    prop.Id = NCoderPropID::kReduceSize;
    prop.Value = *dataSizeReduce;
    coderProps.AddProp(prop);
  }
  return coderProps.SetProps(scp);
}


int CMethodProps::FindProp(PROPID id) const
{
  for (int i = Props.Size() - 1; i >= 0; i--)
    if (Props[i].Id == id)
      return i;
  return -1;
}

int CMethodProps::GetLevel() const
{
  int i = FindProp(NCoderPropID::kLevel);
  if (i < 0)
    return 5;
  if (Props[i].Value.vt != VT_UI4)
    return 9;
  UInt32 level = Props[i].Value.ulVal;
  return level > 9 ? 9 : (int)level;
}

struct CNameToPropID
{
  VARTYPE VarType;
  const char *Name;
};

static const CNameToPropID g_NameToPropID[] =
{
  { VT_UI4, "" },
  { VT_UI4, "d" },
  { VT_UI4, "mem" },
  { VT_UI4, "o" },
  { VT_UI4, "c" },
  { VT_UI4, "pb" },
  { VT_UI4, "lc" },
  { VT_UI4, "lp" },
  { VT_UI4, "fb" },
  { VT_BSTR, "mf" },
  { VT_UI4, "mc" },
  { VT_UI4, "pass" },
  { VT_UI4, "a" },
  { VT_UI4, "mt" },
  { VT_BOOL, "eos" },
  { VT_UI4, "x" },
  { VT_UI4, "reduceSize" }
};

static int FindPropIdExact(const UString &name)
{
  for (unsigned i = 0; i < ARRAY_SIZE(g_NameToPropID); i++)
    if (StringsAreEqualNoCase_Ascii(name, g_NameToPropID[i].Name))
      return i;
  return -1;
}

static bool ConvertProperty(const PROPVARIANT &srcProp, VARTYPE varType, NCOM::CPropVariant &destProp)
{
  if (varType == srcProp.vt)
  {
    destProp = srcProp;
    return true;
  }
  if (varType == VT_BOOL)
  {
    bool res;
    if (PROPVARIANT_to_bool(srcProp, res) != S_OK)
      return false;
    destProp = res;
    return true;
  }
  if (srcProp.vt == VT_EMPTY)
  {
    destProp = srcProp;
    return true;
  }
  return false;
}
    
static void SplitParams(const UString &srcString, UStringVector &subStrings)
{
  subStrings.Clear();
  UString s;
  unsigned len = srcString.Len();
  if (len == 0)
    return;
  for (unsigned i = 0; i < len; i++)
  {
    wchar_t c = srcString[i];
    if (c == L':')
    {
      subStrings.Add(s);
      s.Empty();
    }
    else
      s += c;
  }
  subStrings.Add(s);
}

static void SplitParam(const UString &param, UString &name, UString &value)
{
  int eqPos = param.Find(L'=');
  if (eqPos >= 0)
  {
    name.SetFrom(param, eqPos);
    value = param.Ptr(eqPos + 1);
    return;
  }
  unsigned i;
  for (i = 0; i < param.Len(); i++)
  {
    wchar_t c = param[i];
    if (c >= L'0' && c <= L'9')
      break;
  }
  name.SetFrom(param, i);
  value = param.Ptr(i);
}

static bool IsLogSizeProp(PROPID propid)
{
  switch (propid)
  {
    case NCoderPropID::kDictionarySize:
    case NCoderPropID::kUsedMemorySize:
    case NCoderPropID::kBlockSize:
    case NCoderPropID::kReduceSize:
      return true;
  }
  return false;
}

HRESULT CMethodProps::SetParam(const UString &name, const UString &value)
{
  int index = FindPropIdExact(name);
  if (index < 0)
    return E_INVALIDARG;
  const CNameToPropID &nameToPropID = g_NameToPropID[(unsigned)index];
  CProp prop;
  prop.Id = index;

  if (IsLogSizeProp(prop.Id))
  {
    RINOK(StringToDictSize(value, prop.Value));
  }
  else
  {
    NCOM::CPropVariant propValue;
    if (nameToPropID.VarType == VT_BSTR)
      propValue = value;
    else if (nameToPropID.VarType == VT_BOOL)
    {
      bool res;
      if (!StringToBool(value, res))
        return E_INVALIDARG;
      propValue = res;
    }
    else if (!value.IsEmpty())
    {
      UInt32 number;
      if (ParseStringToUInt32(value, number) == value.Len())
        propValue = number;
      else
        propValue = value;
    }
    if (!ConvertProperty(propValue, nameToPropID.VarType, prop.Value))
      return E_INVALIDARG;
  }
  Props.Add(prop);
  return S_OK;
}

HRESULT CMethodProps::ParseParamsFromString(const UString &srcString)
{
  UStringVector params;
  SplitParams(srcString, params);
  FOR_VECTOR (i, params)
  {
    const UString &param = params[i];
    UString name, value;
    SplitParam(param, name, value);
    RINOK(SetParam(name, value));
  }
  return S_OK;
}

HRESULT CMethodProps::ParseParamsFromPROPVARIANT(const UString &realName, const PROPVARIANT &value)
{
  if (realName.Len() == 0)
  {
    // [empty]=method
    return E_INVALIDARG;
  }
  if (value.vt == VT_EMPTY)
  {
    // {realName}=[empty]
    UString name, valueStr;
    SplitParam(realName, name, valueStr);
    return SetParam(name, valueStr);
  }
  
  // {realName}=value
  int index = FindPropIdExact(realName);
  if (index < 0)
    return E_INVALIDARG;
  const CNameToPropID &nameToPropID = g_NameToPropID[(unsigned)index];
  CProp prop;
  prop.Id = index;
  
  if (IsLogSizeProp(prop.Id))
  {
    RINOK(PROPVARIANT_to_DictSize(value, prop.Value));
  }
  else
  {
    if (!ConvertProperty(value, nameToPropID.VarType, prop.Value))
      return E_INVALIDARG;
  }
  Props.Add(prop);
  return S_OK;
}

HRESULT COneMethodInfo::ParseMethodFromString(const UString &s)
{
  MethodName.Empty();
  int splitPos = s.Find(L':');
  {
    UString temp = s;
    if (splitPos >= 0)
      temp.DeleteFrom(splitPos);
    if (!temp.IsAscii())
      return E_INVALIDARG;
    MethodName.SetFromWStr_if_Ascii(temp);
  }
  if (splitPos < 0)
    return S_OK;
  PropsString = s.Ptr(splitPos + 1);
  return ParseParamsFromString(PropsString);
}

HRESULT COneMethodInfo::ParseMethodFromPROPVARIANT(const UString &realName, const PROPVARIANT &value)
{
  if (!realName.IsEmpty() && !StringsAreEqualNoCase_Ascii(realName, "m"))
    return ParseParamsFromPROPVARIANT(realName, value);
  // -m{N}=method
  if (value.vt != VT_BSTR)
    return E_INVALIDARG;
  return ParseMethodFromString(value.bstrVal);
}
// MethodProps.h

#ifndef __7Z_METHOD_PROPS_H
#define __7Z_METHOD_PROPS_H

#include "../../Common/MyString.h"

#include "../../Windows/PropVariant.h"

#include "../ICoder.h"

bool StringToBool(const UString &s, bool &res);
HRESULT PROPVARIANT_to_bool(const PROPVARIANT &prop, bool &dest);
unsigned ParseStringToUInt32(const UString &srcString, UInt32 &number);
HRESULT ParsePropToUInt32(const UString &name, const PROPVARIANT &prop, UInt32 &resValue);

HRESULT ParseMtProp(const UString &name, const PROPVARIANT &prop, UInt32 defaultNumThreads, UInt32 &numThreads);

struct CProp
{
  PROPID Id;
  bool IsOptional;
  NWindows::NCOM::CPropVariant Value;
  CProp(): IsOptional(false) {}
};

struct CProps
{
  CObjectVector<CProp> Props;

  void Clear() { Props.Clear(); }

  bool AreThereNonOptionalProps() const
  {
    FOR_VECTOR (i, Props)
      if (!Props[i].IsOptional)
        return true;
    return false;
  }

  void AddProp32(PROPID propid, UInt32 level);

  void AddProp_Ascii(PROPID propid, const char *s)
  {
    CProp &prop = Props.AddNew();
    prop.IsOptional = true;
    prop.Id = propid;
    prop.Value = s;
  }

  HRESULT SetCoderProps(ICompressSetCoderProperties *scp, const UInt64 *dataSizeReduce) const;
};

class CMethodProps: public CProps
{
  HRESULT SetParam(const UString &name, const UString &value);
public:
  int GetLevel() const;
  int Get_NumThreads() const
  {
    int i = FindProp(NCoderPropID::kNumThreads);
    if (i >= 0)
      if (Props[i].Value.vt == VT_UI4)
        return (int)Props[i].Value.ulVal;
    return -1;
  }

  bool Get_DicSize(UInt32 &res) const
  {
    res = 0;
    int i = FindProp(NCoderPropID::kDictionarySize);
    if (i >= 0)
      if (Props[i].Value.vt == VT_UI4)
      {
        res = Props[i].Value.ulVal;
        return true;
      }
    return false;
  }

  int FindProp(PROPID id) const;

  UInt32 Get_Lzma_Algo() const
  {
    int i = FindProp(NCoderPropID::kAlgorithm);
    if (i >= 0)
      if (Props[i].Value.vt == VT_UI4)
        return Props[i].Value.ulVal;
    return GetLevel() >= 5 ? 1 : 0;
  }

  UInt32 Get_Lzma_DicSize() const
  {
    int i = FindProp(NCoderPropID::kDictionarySize);
    if (i >= 0)
      if (Props[i].Value.vt == VT_UI4)
        return Props[i].Value.ulVal;
    int level = GetLevel();
    return level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26));
  }

  bool Are_Lzma_Model_Props_Defined() const
  {
    if (FindProp(NCoderPropID::kPosStateBits) >= 0) return true;
    if (FindProp(NCoderPropID::kLitContextBits) >= 0) return true;
    if (FindProp(NCoderPropID::kLitPosBits) >= 0) return true;
    return false;
  }

  UInt32 Get_Lzma_NumThreads(bool &fixedNumber) const
  {
    fixedNumber = false;
    int numThreads = Get_NumThreads();
    if (numThreads >= 0)
    {
      fixedNumber = true;
      return numThreads < 2 ? 1 : 2;
    }
    return Get_Lzma_Algo() == 0 ? 1 : 2;
  }

  UInt32 Get_BZip2_NumThreads(bool &fixedNumber) const
  {
    fixedNumber = false;
    int numThreads = Get_NumThreads();
    if (numThreads >= 0)
    {
      fixedNumber = true;
      if (numThreads < 1) return 1;
      if (numThreads > 64) return 64;
      return numThreads;
    }
    return 1;
  }

  UInt32 Get_BZip2_BlockSize() const
  {
    int i = FindProp(NCoderPropID::kDictionarySize);
    if (i >= 0)
      if (Props[i].Value.vt == VT_UI4)
      {
        UInt32 blockSize = Props[i].Value.ulVal;
        const UInt32 kDicSizeMin = 100000;
        const UInt32 kDicSizeMax = 900000;
        if (blockSize < kDicSizeMin) blockSize = kDicSizeMin;
        if (blockSize > kDicSizeMax) blockSize = kDicSizeMax;
        return blockSize;
      }
    int level = GetLevel();
    return 100000 * (level >= 5 ? 9 : (level >= 1 ? level * 2 - 1: 1));
  }

  UInt32 Get_Ppmd_MemSize() const
  {
    int i = FindProp(NCoderPropID::kUsedMemorySize);
    if (i >= 0)
      if (Props[i].Value.vt == VT_UI4)
        return Props[i].Value.ulVal;
    int level = GetLevel();
    return level >= 9 ? (192 << 20) : ((UInt32)1 << (level + 19));
  }

  void AddProp_Level(UInt32 level)
  {
    AddProp32(NCoderPropID::kLevel, level);
  }

  void AddProp_NumThreads(UInt32 numThreads)
  {
    AddProp32(NCoderPropID::kNumThreads, numThreads);
  }

  HRESULT ParseParamsFromString(const UString &srcString);
  HRESULT ParseParamsFromPROPVARIANT(const UString &realName, const PROPVARIANT &value);
};

class COneMethodInfo: public CMethodProps
{
public:
  AString MethodName;
  UString PropsString;
  
  void Clear()
  {
    CMethodProps::Clear();
    MethodName.Empty();
    PropsString.Empty();
  }
  bool IsEmpty() const { return MethodName.IsEmpty() && Props.IsEmpty(); }
  HRESULT ParseMethodFromPROPVARIANT(const UString &realName, const PROPVARIANT &value);
  HRESULT ParseMethodFromString(const UString &s);
};

#endif
// OffsetStream.cpp

#include "StdAfx.h"

#include "../../Common/Defs.h"

#include "OffsetStream.h"

HRESULT COffsetOutStream::Init(IOutStream *stream, UInt64 offset)
{
  _offset = offset;
  _stream = stream;
  return _stream->Seek(offset, STREAM_SEEK_SET, NULL);
}

STDMETHODIMP COffsetOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  return _stream->Write(data, size, processedSize);
}

STDMETHODIMP COffsetOutStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  UInt64 absoluteNewPosition;
  if (seekOrigin == STREAM_SEEK_SET)
  {
    if (offset < 0)
      return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
    offset += _offset;
  }
  HRESULT result = _stream->Seek(offset, seekOrigin, &absoluteNewPosition);
  if (newPosition)
    *newPosition = absoluteNewPosition - _offset;
  return result;
}

STDMETHODIMP COffsetOutStream::SetSize(UInt64 newSize)
{
  return _stream->SetSize(_offset + newSize);
}
// OffsetStream.h

#ifndef __OFFSET_STREAM_H
#define __OFFSET_STREAM_H

#include "../../Common/MyCom.h"

#include "../IStream.h"

class COffsetOutStream:
  public IOutStream,
  public CMyUnknownImp
{
  UInt64 _offset;
  CMyComPtr<IOutStream> _stream;
public:
  HRESULT Init(IOutStream *stream, UInt64 offset);
  
  MY_UNKNOWN_IMP

  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
  STDMETHOD(SetSize)(UInt64 newSize);
};

#endif
// OutBuffer.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "OutBuffer.h"

bool COutBuffer::Create(UInt32 bufSize) throw()
{
  const UInt32 kMinBlockSize = 1;
  if (bufSize < kMinBlockSize)
    bufSize = kMinBlockSize;
  if (_buf != 0 && _bufSize == bufSize)
    return true;
  Free();
  _bufSize = bufSize;
  _buf = (Byte *)::MidAlloc(bufSize);
  return (_buf != 0);
}

void COutBuffer::Free() throw()
{
  ::MidFree(_buf);
  _buf = 0;
}

void COutBuffer::Init() throw()
{
  _streamPos = 0;
  _limitPos = _bufSize;
  _pos = 0;
  _processedSize = 0;
  _overDict = false;
  #ifdef _NO_EXCEPTIONS
  ErrorCode = S_OK;
  #endif
}

UInt64 COutBuffer::GetProcessedSize() const throw()
{
  UInt64 res = _processedSize + _pos - _streamPos;
  if (_streamPos > _pos)
    res += _bufSize;
  return res;
}


HRESULT COutBuffer::FlushPart() throw()
{
  // _streamPos < _bufSize
  UInt32 size = (_streamPos >= _pos) ? (_bufSize - _streamPos) : (_pos - _streamPos);
  HRESULT result = S_OK;
  #ifdef _NO_EXCEPTIONS
  result = ErrorCode;
  #endif
  if (_buf2 != 0)
  {
    memcpy(_buf2, _buf + _streamPos, size);
    _buf2 += size;
  }

  if (_stream != 0
      #ifdef _NO_EXCEPTIONS
      && (ErrorCode == S_OK)
      #endif
     )
  {
    UInt32 processedSize = 0;
    result = _stream->Write(_buf + _streamPos, size, &processedSize);
    size = processedSize;
  }
  _streamPos += size;
  if (_streamPos == _bufSize)
    _streamPos = 0;
  if (_pos == _bufSize)
  {
    _overDict = true;
    _pos = 0;
  }
  _limitPos = (_streamPos > _pos) ? _streamPos : _bufSize;
  _processedSize += size;
  return result;
}

HRESULT COutBuffer::Flush() throw()
{
  #ifdef _NO_EXCEPTIONS
  if (ErrorCode != S_OK)
    return ErrorCode;
  #endif

  while (_streamPos != _pos)
  {
    HRESULT result = FlushPart();
    if (result != S_OK)
      return result;
  }
  return S_OK;
}

void COutBuffer::FlushWithCheck()
{
  HRESULT result = Flush();
  #ifdef _NO_EXCEPTIONS
  ErrorCode = result;
  #else
  if (result != S_OK)
    throw COutBufferException(result);
  #endif
}
// OutBuffer.h

#ifndef __OUT_BUFFER_H
#define __OUT_BUFFER_H

#include "../IStream.h"
#include "../../Common/MyCom.h"
#include "../../Common/MyException.h"

#ifndef _NO_EXCEPTIONS
struct COutBufferException: public CSystemException
{
  COutBufferException(HRESULT errorCode): CSystemException(errorCode) {}
};
#endif

class COutBuffer
{
protected:
  Byte *_buf;
  UInt32 _pos;
  UInt32 _limitPos;
  UInt32 _streamPos;
  UInt32 _bufSize;
  ISequentialOutStream *_stream;
  UInt64 _processedSize;
  Byte  *_buf2;
  bool _overDict;

  HRESULT FlushPart() throw();
public:
  #ifdef _NO_EXCEPTIONS
  HRESULT ErrorCode;
  #endif

  COutBuffer(): _buf(0), _pos(0), _stream(0), _buf2(0) {}
  ~COutBuffer() { Free(); }
  
  bool Create(UInt32 bufSize) throw();
  void Free() throw();

  void SetMemStream(Byte *buf) { _buf2 = buf; }
  void SetStream(ISequentialOutStream *stream) { _stream = stream; }
  void Init() throw();
  HRESULT Flush() throw();
  void FlushWithCheck();

  void WriteByte(Byte b)
  {
    _buf[_pos++] = b;
    if (_pos == _limitPos)
      FlushWithCheck();
  }
  void WriteBytes(const void *data, size_t size)
  {
    for (size_t i = 0; i < size; i++)
      WriteByte(((const Byte *)data)[i]);
  }

  UInt64 GetProcessedSize() const throw();
};

#endif
// OutMemStream.cpp

#include "StdAfx.h"

#include "OutMemStream.h"

void COutMemStream::Free()
{
  Blocks.Free(_memManager);
  Blocks.LockMode = true;
}

void COutMemStream::Init()
{
  WriteToRealStreamEvent.Reset();
  _unlockEventWasSent = false;
  _realStreamMode = false;
  Free();
  _curBlockPos = 0;
  _curBlockIndex = 0;
}

void COutMemStream::DetachData(CMemLockBlocks &blocks)
{
  Blocks.Detach(blocks, _memManager);
  Free();
}


HRESULT COutMemStream::WriteToRealStream()
{
  RINOK(Blocks.WriteToStream(_memManager->GetBlockSize(), OutSeqStream));
  Blocks.Free(_memManager);
  return S_OK;
}

STDMETHODIMP COutMemStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  if (_realStreamMode)
    return OutSeqStream->Write(data, size, processedSize);
  if (processedSize != 0)
    *processedSize = 0;
  while (size != 0)
  {
    if (_curBlockIndex < Blocks.Blocks.Size())
    {
      Byte *p = (Byte *)Blocks.Blocks[_curBlockIndex] + _curBlockPos;
      size_t curSize = _memManager->GetBlockSize() - _curBlockPos;
      if (size < curSize)
        curSize = size;
      memcpy(p, data, curSize);
      if (processedSize != 0)
        *processedSize += (UInt32)curSize;
      data = (const void *)((const Byte *)data + curSize);
      size -= (UInt32)curSize;
      _curBlockPos += curSize;

      UInt64 pos64 = GetPos();
      if (pos64 > Blocks.TotalSize)
        Blocks.TotalSize = pos64;
      if (_curBlockPos == _memManager->GetBlockSize())
      {
        _curBlockIndex++;
        _curBlockPos = 0;
      }
      continue;
    }
    HANDLE events[3] = { StopWritingEvent, WriteToRealStreamEvent, /* NoLockEvent, */ _memManager->Semaphore };
    DWORD waitResult = ::WaitForMultipleObjects((Blocks.LockMode ? 3 : 2), events, FALSE, INFINITE);
    switch (waitResult)
    {
      case (WAIT_OBJECT_0 + 0):
        return StopWriteResult;
      case (WAIT_OBJECT_0 + 1):
      {
        _realStreamMode = true;
        RINOK(WriteToRealStream());
        UInt32 processedSize2;
        HRESULT res = OutSeqStream->Write(data, size, &processedSize2);
        if (processedSize != 0)
          *processedSize += processedSize2;
        return res;
      }
      /*
      case (WAIT_OBJECT_0 + 2):
      {
        // it has bug: no write.
        if (!Blocks.SwitchToNoLockMode(_memManager))
          return E_FAIL;
        break;
      }
      */
      case (WAIT_OBJECT_0 + 2):
        break;
      default:
        return E_FAIL;
    }
    Blocks.Blocks.Add(_memManager->AllocateBlock());
    if (Blocks.Blocks.Back() == 0)
      return E_FAIL;
  }
  return S_OK;
}

STDMETHODIMP COutMemStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  if (_realStreamMode)
  {
    if (!OutStream)
      return E_FAIL;
    return OutStream->Seek(offset, seekOrigin, newPosition);
  }
  if (seekOrigin == STREAM_SEEK_CUR)
  {
    if (offset != 0)
      return E_NOTIMPL;
  }
  else if (seekOrigin == STREAM_SEEK_SET)
  {
    if (offset != 0)
      return E_NOTIMPL;
    _curBlockIndex = 0;
    _curBlockPos = 0;
  }
  else
    return E_NOTIMPL;
  if (newPosition)
    *newPosition = GetPos();
  return S_OK;
}

STDMETHODIMP COutMemStream::SetSize(UInt64 newSize)
{
  if (_realStreamMode)
  {
    if (!OutStream)
      return E_FAIL;
    return OutStream->SetSize(newSize);
  }
  Blocks.TotalSize = newSize;
  return S_OK;
}
// OutMemStream.h

#ifndef __OUT_MEM_STREAM_H
#define __OUT_MEM_STREAM_H

#include "../../Common/MyCom.h"

#include "MemBlocks.h"

class COutMemStream:
  public IOutStream,
  public CMyUnknownImp
{
  CMemBlockManagerMt *_memManager;
  unsigned _curBlockIndex;
  size_t _curBlockPos;
  bool _realStreamMode;

  bool _unlockEventWasSent;
  NWindows::NSynchronization::CAutoResetEventWFMO StopWritingEvent;
  NWindows::NSynchronization::CAutoResetEventWFMO WriteToRealStreamEvent;
  // NWindows::NSynchronization::CAutoResetEvent NoLockEvent;

  HRESULT StopWriteResult;
  CMemLockBlocks Blocks;

  UInt64 GetPos() const { return (UInt64)_curBlockIndex * _memManager->GetBlockSize() + _curBlockPos; }

  CMyComPtr<ISequentialOutStream> OutSeqStream;
  CMyComPtr<IOutStream> OutStream;

public:

  HRes CreateEvents(NWindows::NSynchronization::CSynchro *sync)
  {
    RINOK(StopWritingEvent.CreateIfNotCreated(sync));
    return WriteToRealStreamEvent.CreateIfNotCreated(sync);
  }

  void SetOutStream(IOutStream *outStream)
  {
    OutStream = outStream;
    OutSeqStream = outStream;
  }

  void SetSeqOutStream(ISequentialOutStream *outStream)
  {
    OutStream = NULL;
    OutSeqStream = outStream;
  }

  void ReleaseOutStream()
  {
    OutStream.Release();
    OutSeqStream.Release();
  }

  COutMemStream(CMemBlockManagerMt *memManager): _memManager(memManager)  { }

  ~COutMemStream() { Free(); }
  void Free();

  void Init();
  HRESULT WriteToRealStream();

  void DetachData(CMemLockBlocks &blocks);

  bool WasUnlockEventSent() const { return _unlockEventWasSent; }

  void SetRealStreamMode()
  {
    _unlockEventWasSent = true;
    WriteToRealStreamEvent.Set();
  }

  /*
  void SetNoLockMode()
  {
    _unlockEventWasSent = true;
    NoLockEvent.Set();
  }
  */

  void StopWriting(HRESULT res)
  {
    StopWriteResult = res;
    StopWritingEvent.Set();
  }

  MY_UNKNOWN_IMP

  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
  STDMETHOD(SetSize)(UInt64 newSize);
};

#endif
// ProgressMt.h

#include "StdAfx.h"

#include "ProgressMt.h"

void CMtCompressProgressMixer::Init(int numItems, ICompressProgressInfo *progress)
{
  NWindows::NSynchronization::CCriticalSectionLock lock(CriticalSection);
  InSizes.Clear();
  OutSizes.Clear();
  for (int i = 0; i < numItems; i++)
  {
    InSizes.Add(0);
    OutSizes.Add(0);
  }
  TotalInSize = 0;
  TotalOutSize = 0;
  _progress = progress;
}

void CMtCompressProgressMixer::Reinit(int index)
{
  NWindows::NSynchronization::CCriticalSectionLock lock(CriticalSection);
  InSizes[index] = 0;
  OutSizes[index] = 0;
}

HRESULT CMtCompressProgressMixer::SetRatioInfo(int index, const UInt64 *inSize, const UInt64 *outSize)
{
  NWindows::NSynchronization::CCriticalSectionLock lock(CriticalSection);
  if (inSize != 0)
  {
    UInt64 diff = *inSize - InSizes[index];
    InSizes[index] = *inSize;
    TotalInSize += diff;
  }
  if (outSize != 0)
  {
    UInt64 diff = *outSize - OutSizes[index];
    OutSizes[index] = *outSize;
    TotalOutSize += diff;
  }
  if (_progress)
    return _progress->SetRatioInfo(&TotalInSize, &TotalOutSize);
  return S_OK;
}


STDMETHODIMP CMtCompressProgress::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)
{
  return _progress->SetRatioInfo(_index, inSize, outSize);
}
// ProgressMt.h

#ifndef __PROGRESSMT_H
#define __PROGRESSMT_H

#include "../../Common/MyCom.h"
#include "../../Common/MyVector.h"
#include "../../Windows/Synchronization.h"

#include "../ICoder.h"
#include "../IProgress.h"

class CMtCompressProgressMixer
{
  CMyComPtr<ICompressProgressInfo> _progress;
  CRecordVector<UInt64> InSizes;
  CRecordVector<UInt64> OutSizes;
  UInt64 TotalInSize;
  UInt64 TotalOutSize;
public:
  NWindows::NSynchronization::CCriticalSection CriticalSection;
  void Init(int numItems, ICompressProgressInfo *progress);
  void Reinit(int index);
  HRESULT SetRatioInfo(int index, const UInt64 *inSize, const UInt64 *outSize);
};

class CMtCompressProgress:
  public ICompressProgressInfo,
  public CMyUnknownImp
{
  CMtCompressProgressMixer *_progress;
  int _index;
public:
  void Init(CMtCompressProgressMixer *progress, int index)
  {
    _progress = progress;
    _index = index;
  }
  void Reinit() { _progress->Reinit(_index); }

  MY_UNKNOWN_IMP

  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize);
};

#endif
// ProgressUtils.cpp

#include "StdAfx.h"

#include "ProgressUtils.h"

CLocalProgress::CLocalProgress():
    ProgressOffset(0),
    InSize(0),
    OutSize(0),
    SendRatio(true),
    SendProgress(true)
  {}

void CLocalProgress::Init(IProgress *progress, bool inSizeIsMain)
{
  _ratioProgress.Release();
  _progress = progress;
  _progress.QueryInterface(IID_ICompressProgressInfo, &_ratioProgress);
  _inSizeIsMain = inSizeIsMain;
}

STDMETHODIMP CLocalProgress::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)
{
  UInt64 inSize2 = InSize;
  UInt64 outSize2 = OutSize;
  
  if (inSize)
    inSize2 += (*inSize);
  if (outSize)
    outSize2 += (*outSize);
  
  if (SendRatio && _ratioProgress)
  {
    RINOK(_ratioProgress->SetRatioInfo(&inSize2, &outSize2));
  }
  
  if (SendProgress)
  {
    inSize2 += ProgressOffset;
    outSize2 += ProgressOffset;
    return _progress->SetCompleted(_inSizeIsMain ? &inSize2 : &outSize2);
  }
  
  return S_OK;
}

HRESULT CLocalProgress::SetCur()
{
  return SetRatioInfo(NULL, NULL);
}
// ProgressUtils.h

#ifndef __PROGRESS_UTILS_H
#define __PROGRESS_UTILS_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"
#include "../IProgress.h"

class CLocalProgress:
  public ICompressProgressInfo,
  public CMyUnknownImp
{
  CMyComPtr<IProgress> _progress;
  CMyComPtr<ICompressProgressInfo> _ratioProgress;
  bool _inSizeIsMain;
public:
  UInt64 ProgressOffset;
  UInt64 InSize;
  UInt64 OutSize;
  bool SendRatio;
  bool SendProgress;

  CLocalProgress();

  void Init(IProgress *progress, bool inSizeIsMain);
  HRESULT SetCur();

  MY_UNKNOWN_IMP1(ICompressProgressInfo)

  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize);
};

#endif
// PropId.cpp

#include "StdAfx.h"

#include "../../Common/MyWindows.h"

#include "../PropID.h"

// VARTYPE
const Byte k7z_PROPID_To_VARTYPE[kpid_NUM_DEFINED] =
{
  VT_EMPTY,
  VT_UI4,
  VT_UI4,
  VT_BSTR,
  VT_BSTR,
  VT_BSTR,
  VT_BOOL,
  VT_UI8,
  VT_UI8,
  VT_UI4,
  VT_FILETIME,
  VT_FILETIME,
  VT_FILETIME,
  VT_BOOL,
  VT_BOOL,
  VT_BOOL,
  VT_BOOL,
  VT_BOOL,
  VT_UI4,
  VT_UI4,
  VT_BSTR,
  VT_BOOL,
  VT_BSTR,
  VT_BSTR,
  VT_BSTR,
  VT_BSTR,
  VT_BSTR,
  VT_UI8,
  VT_BSTR,
  VT_UI8,
  VT_BSTR,
  VT_UI8,
  VT_UI8,
  VT_BSTR, // or VT_UI8 kpidUnpackVer
  VT_UI4, // or VT_UI8 kpidVolume
  VT_BOOL,
  VT_UI8,
  VT_UI8,
  VT_UI8,
  VT_UI8,
  VT_UI4,
  VT_BOOL,
  VT_BOOL,
  VT_BSTR,
  VT_UI8,
  VT_UI8,
  VT_UI4, // kpidChecksum
  VT_BSTR,
  VT_UI8,
  VT_BSTR, // or VT_UI8 kpidId
  VT_BSTR,
  VT_BSTR,
  VT_UI4,
  VT_UI4,
  VT_BSTR,
  VT_BSTR,
  VT_UI8,
  VT_UI8,
  VT_UI4,
  VT_BSTR,
  VT_BSTR,
  VT_BSTR,
  VT_BSTR, // kpidNtSecure
  VT_BOOL,
  VT_BOOL,
  VT_BOOL,
  VT_BOOL,
  VT_BSTR, // SHA-1
  VT_BSTR, // SHA-256
  VT_BSTR,
  VT_UI8,
  VT_UI4,
  VT_UI4,
  VT_BSTR,
  VT_UI8,
  VT_UI8,
  VT_UI8,
  VT_UI8,
  VT_UI8,
  VT_UI8,
  VT_UI8,
  VT_BSTR,
  VT_BSTR,
  VT_BSTR,
  VT_BOOL,
  VT_BOOL,
  VT_BOOL,
  VT_UI8,
  VT_UI8,
  VT_BSTR, // kpidNtReparse
  VT_BSTR,
  VT_UI8,
  VT_UI8,
  VT_BOOL,
  VT_BSTR,
  VT_BSTR
};
// RegisterArc.h

#ifndef __REGISTER_ARC_H
#define __REGISTER_ARC_H

#include "../Archive/IArchive.h"

struct CArcInfo
{
  UInt16 Flags;
  Byte Id;
  Byte SignatureSize;
  UInt16 SignatureOffset;
  
  const Byte *Signature;
  const char *Name;
  const char *Ext;
  const char *AddExt;
  
  Func_CreateInArchive CreateInArchive;
  Func_CreateOutArchive CreateOutArchive;
  Func_IsArc IsArc;

  bool IsMultiSignature() const { return (Flags & NArcInfoFlags::kMultiSignature) != 0; }
};

void RegisterArc(const CArcInfo *arcInfo) throw();


#define IMP_CreateArcIn_2(c) \
  static IInArchive *CreateArc() { return new c; }

#define IMP_CreateArcIn IMP_CreateArcIn_2(CHandler())

#ifdef EXTRACT_ONLY
  #define IMP_CreateArcOut
  #define CreateArcOut NULL
#else
  #define IMP_CreateArcOut static IOutArchive *CreateArcOut() { return new CHandler(); }
#endif

#define REGISTER_ARC_V(n, e, ae, id, sigSize, sig, offs, flags, crIn, crOut, isArc) \
  static const CArcInfo g_ArcInfo = { flags, id, sigSize, offs, sig, n, e, ae, crIn, crOut, isArc } ; \

#define REGISTER_ARC_R(n, e, ae, id, sigSize, sig, offs, flags, crIn, crOut, isArc) \
  REGISTER_ARC_V(n, e, ae, id, sigSize, sig, offs, flags, crIn, crOut, isArc) \
  struct CRegisterArc { CRegisterArc() { RegisterArc(&g_ArcInfo); }}; \
  static CRegisterArc g_RegisterArc;


#define REGISTER_ARC_I_CLS(cls, n, e, ae, id, sig, offs, flags, isArc) \
  IMP_CreateArcIn_2(cls) \
  REGISTER_ARC_R(n, e, ae, id, ARRAY_SIZE(sig), sig, offs, flags, CreateArc, NULL, isArc)

#define REGISTER_ARC_I_CLS_NO_SIG(cls, n, e, ae, id, offs, flags, isArc) \
  IMP_CreateArcIn_2(cls) \
  REGISTER_ARC_R(n, e, ae, id, 0, NULL, offs, flags, CreateArc, NULL, isArc)

#define REGISTER_ARC_I(n, e, ae, id, sig, offs, flags, isArc) \
  REGISTER_ARC_I_CLS(CHandler(), n, e, ae, id, sig, offs, flags, isArc)

#define REGISTER_ARC_I_NO_SIG(n, e, ae, id, offs, flags, isArc) \
  REGISTER_ARC_I_CLS_NO_SIG(CHandler(), n, e, ae, id, offs, flags, isArc)


#define REGISTER_ARC_IO(n, e, ae, id, sig, offs, flags, isArc) \
  IMP_CreateArcIn \
  IMP_CreateArcOut \
  REGISTER_ARC_R(n, e, ae, id, ARRAY_SIZE(sig), sig, offs, flags, CreateArc, CreateArcOut, isArc)

#define REGISTER_ARC_IO_DECREMENT_SIG(n, e, ae, id, sig, offs, flags, isArc) \
  IMP_CreateArcIn \
  IMP_CreateArcOut \
  REGISTER_ARC_V(n, e, ae, id, ARRAY_SIZE(sig), sig, offs, flags, CreateArc, CreateArcOut, isArc) \
  struct CRegisterArcDecSig { CRegisterArcDecSig() { sig[0]--; RegisterArc(&g_ArcInfo); }}; \
  static CRegisterArcDecSig g_RegisterArc;

#endif
// RegisterCodec.h

#ifndef __REGISTER_CODEC_H
#define __REGISTER_CODEC_H

#include "../Common/MethodId.h"

#include "../ICoder.h"

typedef void * (*CreateCodecP)();

struct CCodecInfo
{
  CreateCodecP CreateDecoder;
  CreateCodecP CreateEncoder;
  CMethodId Id;
  const char *Name;
  UInt32 NumStreams;
  bool IsFilter;
};

void RegisterCodec(const CCodecInfo *codecInfo) throw();


#define REGISTER_CODEC_CREATE_2(name, cls, i) static void *name() { return (void *)(i *)(new cls); }
#define REGISTER_CODEC_CREATE(name, cls) REGISTER_CODEC_CREATE_2(name, cls, ICompressCoder)

#define REGISTER_CODEC_NAME(x) CRegisterCodec ## x
#define REGISTER_CODEC_VAR static const CCodecInfo g_CodecInfo =

#define REGISTER_CODEC(x) struct REGISTER_CODEC_NAME(x) { \
    REGISTER_CODEC_NAME(x)() { RegisterCodec(&g_CodecInfo); }}; \
    static REGISTER_CODEC_NAME(x) g_RegisterCodec;


#define REGISTER_CODECS_NAME(x) CRegisterCodecs ## x
#define REGISTER_CODECS_VAR static const CCodecInfo g_CodecsInfo[] =

#define REGISTER_CODECS(x) struct REGISTER_CODECS_NAME(x) { \
    REGISTER_CODECS_NAME(x)() { for (unsigned i = 0; i < ARRAY_SIZE(g_CodecsInfo); i++) \
    RegisterCodec(&g_CodecsInfo[i]); }}; \
    static REGISTER_CODECS_NAME(x) g_RegisterCodecs;


#define REGISTER_CODEC_2(x, crDec, crEnc, id, name) \
    REGISTER_CODEC_VAR \
    { crDec, crEnc, id, name, 1, false }; \
    REGISTER_CODEC(x)


#ifdef EXTRACT_ONLY
  #define REGISTER_CODEC_E(x, clsDec, clsEnc, id, name) \
    REGISTER_CODEC_CREATE(CreateDec, clsDec) \
    REGISTER_CODEC_2(x, CreateDec, NULL, id, name)
#else
  #define REGISTER_CODEC_E(x, clsDec, clsEnc, id, name) \
    REGISTER_CODEC_CREATE(CreateDec, clsDec) \
    REGISTER_CODEC_CREATE(CreateEnc, clsEnc) \
    REGISTER_CODEC_2(x, CreateDec, CreateEnc, id, name)
#endif



#define REGISTER_FILTER_CREATE(name, cls) REGISTER_CODEC_CREATE_2(name, cls, ICompressFilter)

#define REGISTER_FILTER_ITEM(crDec, crEnc, id, name) \
    { crDec, crEnc, id, name, 1, true }

#define REGISTER_FILTER(x, crDec, crEnc, id, name) \
    REGISTER_CODEC_VAR \
    REGISTER_FILTER_ITEM(crDec, crEnc, id, name); \
    REGISTER_CODEC(x)

#ifdef EXTRACT_ONLY
  #define REGISTER_FILTER_E(x, clsDec, clsEnc, id, name) \
    REGISTER_FILTER_CREATE(CreateDec, clsDec) \
    REGISTER_FILTER(x, CreateDec, NULL, id, name)
#else
  #define REGISTER_FILTER_E(x, clsDec, clsEnc, id, name) \
    REGISTER_FILTER_CREATE(CreateDec, clsDec) \
    REGISTER_FILTER_CREATE(CreateEnc, clsEnc) \
    REGISTER_FILTER(x, CreateDec, CreateEnc, id, name)
#endif



struct CHasherInfo
{
  IHasher * (*CreateHasher)();
  CMethodId Id;
  const char *Name;
  UInt32 DigestSize;
};

void RegisterHasher(const CHasherInfo *hasher) throw();

#define REGISTER_HASHER_NAME(x) CRegHasher_ ## x

#define REGISTER_HASHER(cls, id, name, size) \
    STDMETHODIMP_(UInt32) cls::GetDigestSize() throw() { return size; } \
    static IHasher *CreateHasherSpec() { return new cls(); } \
    static const CHasherInfo g_HasherInfo = { CreateHasherSpec, id, name, size }; \
    struct REGISTER_HASHER_NAME(cls) { REGISTER_HASHER_NAME(cls)() { RegisterHasher(&g_HasherInfo); }}; \
    static REGISTER_HASHER_NAME(cls) g_RegisterHasher;

#endif
// StreamBinder.cpp

#include "StdAfx.h"

#include "../../Common/MyCom.h"

#include "StreamBinder.h"

class CBinderInStream:
  public ISequentialInStream,
  public CMyUnknownImp
{
  CStreamBinder *_binder;
public:
  MY_UNKNOWN_IMP1(ISequentialInStream)
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  ~CBinderInStream() { _binder->CloseRead(); }
  CBinderInStream(CStreamBinder *binder): _binder(binder) {}
};

STDMETHODIMP CBinderInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
  { return _binder->Read(data, size, processedSize); }

class CBinderOutStream:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  CStreamBinder *_binder;
public:
  MY_UNKNOWN_IMP1(ISequentialOutStream)
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  ~CBinderOutStream() { _binder->CloseWrite(); }
  CBinderOutStream(CStreamBinder *binder): _binder(binder) {}
};

STDMETHODIMP CBinderOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
  { return _binder->Write(data, size, processedSize); }



WRes CStreamBinder::CreateEvents()
{
  _synchroFor_canWrite_Event_and_readingWasClosed_Event.Create();
  RINOK(_canWrite_Event.Create(&_synchroFor_canWrite_Event_and_readingWasClosed_Event));
  RINOK(_canRead_Event.Create());
  return _readingWasClosed_Event.Create(&_synchroFor_canWrite_Event_and_readingWasClosed_Event);
}

void CStreamBinder::ReInit()
{
  _canWrite_Event.Reset();
  _canRead_Event.Reset();
  _readingWasClosed_Event.Reset();

  // _readingWasClosed = false;
  _readingWasClosed2 = false;

  _waitWrite = true;
  _bufSize = 0;
  _buf = NULL;
  ProcessedSize = 0;
  // WritingWasCut = false;
}


void CStreamBinder::CreateStreams(ISequentialInStream **inStream, ISequentialOutStream **outStream)
{
  // _readingWasClosed = false;
  _readingWasClosed2 = false;

  _waitWrite = true;
  _bufSize = 0;
  _buf = NULL;
  ProcessedSize = 0;
  // WritingWasCut = false;

  CBinderInStream *inStreamSpec = new CBinderInStream(this);
  CMyComPtr<ISequentialInStream> inStreamLoc(inStreamSpec);
  *inStream = inStreamLoc.Detach();

  CBinderOutStream *outStreamSpec = new CBinderOutStream(this);
  CMyComPtr<ISequentialOutStream> outStreamLoc(outStreamSpec);
  *outStream = outStreamLoc.Detach();
}

// (_canRead_Event && _bufSize == 0) means that stream is finished.

HRESULT CStreamBinder::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (size != 0)
  {
    if (_waitWrite)
    {
      RINOK(_canRead_Event.Lock());
      _waitWrite = false;
    }
    if (size > _bufSize)
      size = _bufSize;
    if (size != 0)
    {
      memcpy(data, _buf, size);
      _buf = ((const Byte *)_buf) + size;
      ProcessedSize += size;
      if (processedSize)
        *processedSize = size;
      _bufSize -= size;
      if (_bufSize == 0)
      {
        _waitWrite = true;
        _canRead_Event.Reset();
        _canWrite_Event.Set();
      }
    }
  }
  return S_OK;
}

HRESULT CStreamBinder::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (size == 0)
    return S_OK;

  if (!_readingWasClosed2)
  {
    _buf = data;
    _bufSize = size;
    _canRead_Event.Set();
    
    /*
    _canWrite_Event.Lock();
    if (_readingWasClosed)
      _readingWasClosed2 = true;
    */

    HANDLE events[2] = { _canWrite_Event, _readingWasClosed_Event };
    DWORD waitResult = ::WaitForMultipleObjects(2, events, FALSE, INFINITE);
    if (waitResult >= WAIT_OBJECT_0 + 2)
      return E_FAIL;

    size -= _bufSize;
    if (size != 0)
    {
      if (processedSize)
        *processedSize = size;
      return S_OK;
    }
    // if (waitResult == WAIT_OBJECT_0 + 1)
      _readingWasClosed2 = true;
  }

  // WritingWasCut = true;
  return k_My_HRESULT_WritingWasCut;
}
// StreamBinder.h

#ifndef __STREAM_BINDER_H
#define __STREAM_BINDER_H

#include "../../Windows/Synchronization.h"

#include "../IStream.h"

/*
We don't use probably UNSAFE version:
reader thread:
     _canWrite_Event.Set();
     _readingWasClosed = true
     _canWrite_Event.Set();
writer thread:
     _canWrite_Event.Wait()
      if (_readingWasClosed)
Can second call of _canWrite_Event.Set() be executed without memory barrier, if event is already set?
*/

class CStreamBinder
{
  NWindows::NSynchronization::CSynchro _synchroFor_canWrite_Event_and_readingWasClosed_Event;
  NWindows::NSynchronization::CAutoResetEventWFMO _canWrite_Event;
  NWindows::NSynchronization::CManualResetEvent _canRead_Event;
  NWindows::NSynchronization::CManualResetEventWFMO _readingWasClosed_Event;

  // bool _readingWasClosed;
  bool _readingWasClosed2;
  // bool WritingWasCut;
  bool _waitWrite;
  UInt32 _bufSize;
  const void *_buf;
public:
  UInt64 ProcessedSize;

  WRes CreateEvents();
  void CreateStreams(ISequentialInStream **inStream, ISequentialOutStream **outStream);
  
  void ReInit();
  
  HRESULT Read(void *data, UInt32 size, UInt32 *processedSize);
  HRESULT Write(const void *data, UInt32 size, UInt32 *processedSize);

  void CloseRead()
  {
    _readingWasClosed_Event.Set();
    // _readingWasClosed = true;
    // _canWrite_Event.Set();
  }
  
  void CloseWrite()
  {
    _buf = NULL;
    _bufSize = 0;
    _canRead_Event.Set();
  }
};

#endif
// StreamObjects.cpp

#include "StdAfx.h"

#include <stdlib.h>

#include "../../../C/Alloc.h"

#include "StreamObjects.h"

STDMETHODIMP CBufferInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (size == 0)
    return S_OK;
  if (_pos >= Buf.Size())
    return S_OK;
  size_t rem = Buf.Size() - (size_t)_pos;
  if (rem > size)
    rem = (size_t)size;
  memcpy(data, (const Byte *)Buf + (size_t)_pos, rem);
  _pos += rem;
  if (processedSize)
    *processedSize = (UInt32)rem;
  return S_OK;
}

STDMETHODIMP CBufferInStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _pos; break;
    case STREAM_SEEK_END: offset += Buf.Size(); break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _pos = offset;
  if (newPosition)
    *newPosition = offset;
  return S_OK;
}

STDMETHODIMP CBufInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (size == 0)
    return S_OK;
  if (_pos >= _size)
    return S_OK;
  size_t rem = _size - (size_t)_pos;
  if (rem > size)
    rem = (size_t)size;
  memcpy(data, _data + (size_t)_pos, rem);
  _pos += rem;
  if (processedSize)
    *processedSize = (UInt32)rem;
  return S_OK;
}

STDMETHODIMP CBufInStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _pos; break;
    case STREAM_SEEK_END: offset += _size; break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _pos = offset;
  if (newPosition)
    *newPosition = offset;
  return S_OK;
}

void Create_BufInStream_WithReference(const void *data, size_t size, IUnknown *ref, ISequentialInStream **stream)
{
  *stream = NULL;
  CBufInStream *inStreamSpec = new CBufInStream;
  CMyComPtr<ISequentialInStream> streamTemp = inStreamSpec;
  inStreamSpec->Init((const Byte *)data, size, ref);
  *stream = streamTemp.Detach();
}

void Create_BufInStream_WithNewBuffer(const void *data, size_t size, ISequentialInStream **stream)
{
  *stream = NULL;
  CBufferInStream *inStreamSpec = new CBufferInStream;
  CMyComPtr<ISequentialInStream> streamTemp = inStreamSpec;
  inStreamSpec->Buf.CopyFrom((const Byte *)data, size);
  inStreamSpec->Init();
  *stream = streamTemp.Detach();
}

void CByteDynBuffer::Free() throw()
{
  free(_buf);
  _buf = 0;
  _capacity = 0;
}

bool CByteDynBuffer::EnsureCapacity(size_t cap) throw()
{
  if (cap <= _capacity)
    return true;
  size_t delta;
  if (_capacity > 64)
    delta = _capacity / 4;
  else if (_capacity > 8)
    delta = 16;
  else
    delta = 4;
  cap = MyMax(_capacity + delta, cap);
  Byte *buf = (Byte *)realloc(_buf, cap);
  if (!buf)
    return false;
  _buf = buf;
  _capacity = cap;
  return true;
}

Byte *CDynBufSeqOutStream::GetBufPtrForWriting(size_t addSize)
{
  addSize += _size;
  if (addSize < _size)
    return NULL;
  if (!_buffer.EnsureCapacity(addSize))
    return NULL;
  return (Byte *)_buffer + _size;
}

void CDynBufSeqOutStream::CopyToBuffer(CByteBuffer &dest) const
{
  dest.CopyFrom((const Byte *)_buffer, _size);
}

STDMETHODIMP CDynBufSeqOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (size == 0)
    return S_OK;
  Byte *buf = GetBufPtrForWriting(size);
  if (!buf)
    return E_OUTOFMEMORY;
  memcpy(buf, data, size);
  UpdateSize(size);
  if (processedSize)
    *processedSize = size;
  return S_OK;
}

STDMETHODIMP CBufPtrSeqOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  size_t rem = _size - _pos;
  if (rem > size)
    rem = (size_t)size;
  if (rem != 0)
  {
    memcpy(_buffer + _pos, data, rem);
    _pos += rem;
  }
  if (processedSize)
    *processedSize = (UInt32)rem;
  return (rem != 0 || size == 0) ? S_OK : E_FAIL;
}

STDMETHODIMP CSequentialOutStreamSizeCount::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  UInt32 realProcessedSize;
  HRESULT result = _stream->Write(data, size, &realProcessedSize);
  _size += realProcessedSize;
  if (processedSize)
    *processedSize = realProcessedSize;
  return result;
}

static const UInt64 kEmptyTag = (UInt64)(Int64)-1;

void CCachedInStream::Free() throw()
{
  MyFree(_tags);
  _tags = 0;
  MidFree(_data);
  _data = 0;
}

bool CCachedInStream::Alloc(unsigned blockSizeLog, unsigned numBlocksLog) throw()
{
  unsigned sizeLog = blockSizeLog + numBlocksLog;
  if (sizeLog >= sizeof(size_t) * 8)
    return false;
  size_t dataSize = (size_t)1 << sizeLog;
  if (_data == 0 || dataSize != _dataSize)
  {
    MidFree(_data);
    _data = (Byte *)MidAlloc(dataSize);
    if (_data == 0)
      return false;
    _dataSize = dataSize;
  }
  if (_tags == 0 || numBlocksLog != _numBlocksLog)
  {
    MyFree(_tags);
    _tags = (UInt64 *)MyAlloc(sizeof(UInt64) << numBlocksLog);
    if (_tags == 0)
      return false;
    _numBlocksLog = numBlocksLog;
  }
  _blockSizeLog = blockSizeLog;
  return true;
}

void CCachedInStream::Init(UInt64 size) throw()
{
  _size = size;
  _pos = 0;
  size_t numBlocks = (size_t)1 << _numBlocksLog;
  for (size_t i = 0; i < numBlocks; i++)
    _tags[i] = kEmptyTag;
}

STDMETHODIMP CCachedInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  if (size == 0)
    return S_OK;
  if (_pos >= _size)
    return S_OK;

  {
    UInt64 rem = _size - _pos;
    if (size > rem)
      size = (UInt32)rem;
  }

  while (size != 0)
  {
    UInt64 cacheTag = _pos >> _blockSizeLog;
    size_t cacheIndex = (size_t)cacheTag & (((size_t)1 << _numBlocksLog) - 1);
    Byte *p = _data + (cacheIndex << _blockSizeLog);
    if (_tags[cacheIndex] != cacheTag)
    {
      UInt64 remInBlock = _size - (cacheTag << _blockSizeLog);
      size_t blockSize = (size_t)1 << _blockSizeLog;
      if (blockSize > remInBlock)
        blockSize = (size_t)remInBlock;
      RINOK(ReadBlock(cacheTag, p, blockSize));
      _tags[cacheIndex] = cacheTag;
    }
    size_t offset = (size_t)_pos & (((size_t)1 << _blockSizeLog) - 1);
    UInt32 cur = (UInt32)MyMin(((size_t)1 << _blockSizeLog) - offset, (size_t)size);
    memcpy(data, p + offset, cur);
    if (processedSize)
      *processedSize += cur;
    data = (void *)((const Byte *)data + cur);
    _pos += cur;
    size -= cur;
  }

  return S_OK;
}
 
STDMETHODIMP CCachedInStream::Seek(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
{
  switch (seekOrigin)
  {
    case STREAM_SEEK_SET: break;
    case STREAM_SEEK_CUR: offset += _pos; break;
    case STREAM_SEEK_END: offset += _size; break;
    default: return STG_E_INVALIDFUNCTION;
  }
  if (offset < 0)
    return HRESULT_WIN32_ERROR_NEGATIVE_SEEK;
  _pos = offset;
  if (newPosition)
    *newPosition = offset;
  return S_OK;
}
// StreamObjects.h

#ifndef __STREAM_OBJECTS_H
#define __STREAM_OBJECTS_H

#include "../../Common/MyBuffer.h"
#include "../../Common/MyCom.h"
#include "../../Common/MyVector.h"

#include "../IStream.h"

class CBufferInStream:
  public IInStream,
  public CMyUnknownImp
{
  UInt64 _pos;
public:
  CByteBuffer Buf;
  void Init() { _pos = 0; }
 
  MY_UNKNOWN_IMP2(ISequentialInStream, IInStream)

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
};

struct CReferenceBuf:
  public IUnknown,
  public CMyUnknownImp
{
  CByteBuffer Buf;
  MY_UNKNOWN_IMP
};

class CBufInStream:
  public IInStream,
  public CMyUnknownImp
{
  const Byte *_data;
  UInt64 _pos;
  size_t _size;
  CMyComPtr<IUnknown> _ref;
public:
  void Init(const Byte *data, size_t size, IUnknown *ref = 0)
  {
    _data = data;
    _size = size;
    _pos = 0;
    _ref = ref;
  }
  void Init(CReferenceBuf *ref) { Init(ref->Buf, ref->Buf.Size(), ref); }

  MY_UNKNOWN_IMP2(ISequentialInStream, IInStream)
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
};

void Create_BufInStream_WithReference(const void *data, size_t size, IUnknown *ref, ISequentialInStream **stream);
void Create_BufInStream_WithNewBuffer(const void *data, size_t size, ISequentialInStream **stream);
inline void Create_BufInStream_WithNewBuffer(const CByteBuffer &buf, ISequentialInStream **stream)
  { Create_BufInStream_WithNewBuffer(buf, buf.Size(), stream); }

class CByteDynBuffer
{
  size_t _capacity;
  Byte *_buf;
public:
  CByteDynBuffer(): _capacity(0), _buf(0) {};
  // there is no copy constructor. So don't copy this object.
  ~CByteDynBuffer() { Free(); }
  void Free() throw();
  size_t GetCapacity() const { return _capacity; }
  operator Byte*() const { return _buf; }
  operator const Byte*() const { return _buf; }
  bool EnsureCapacity(size_t capacity) throw();
};

class CDynBufSeqOutStream:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  CByteDynBuffer _buffer;
  size_t _size;
public:
  CDynBufSeqOutStream(): _size(0) {}
  void Init() { _size = 0;  }
  size_t GetSize() const { return _size; }
  const Byte *GetBuffer() const { return _buffer; }
  void CopyToBuffer(CByteBuffer &dest) const;
  Byte *GetBufPtrForWriting(size_t addSize);
  void UpdateSize(size_t addSize) { _size += addSize; }

  MY_UNKNOWN_IMP1(ISequentialOutStream)
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
};

class CBufPtrSeqOutStream:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  Byte *_buffer;
  size_t _size;
  size_t _pos;
public:
  void Init(Byte *buffer, size_t size)
  {
    _buffer = buffer;
    _pos = 0;
    _size = size;
  }
  size_t GetPos() const { return _pos; }

  MY_UNKNOWN_IMP1(ISequentialOutStream)
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
};

class CSequentialOutStreamSizeCount:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  CMyComPtr<ISequentialOutStream> _stream;
  UInt64 _size;
public:
  void SetStream(ISequentialOutStream *stream) { _stream = stream; }
  void Init() { _size = 0; }
  UInt64 GetSize() const { return _size; }

  MY_UNKNOWN_IMP1(ISequentialOutStream)
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
};

class CCachedInStream:
  public IInStream,
  public CMyUnknownImp
{
  UInt64 *_tags;
  Byte *_data;
  size_t _dataSize;
  unsigned _blockSizeLog;
  unsigned _numBlocksLog;
  UInt64 _size;
  UInt64 _pos;
protected:
  virtual HRESULT ReadBlock(UInt64 blockIndex, Byte *dest, size_t blockSize) = 0;
public:
  CCachedInStream(): _tags(0), _data(0) {}
  virtual ~CCachedInStream() { Free(); } // the destructor must be virtual (release calls it) !!!
  void Free() throw();
  bool Alloc(unsigned blockSizeLog, unsigned numBlocksLog) throw();
  void Init(UInt64 size) throw();

  MY_UNKNOWN_IMP2(ISequentialInStream, IInStream)
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
};

#endif
// StreamUtils.cpp

#include "StdAfx.h"

#include "StreamUtils.h"

static const UInt32 kBlockSize = ((UInt32)1 << 31);

HRESULT ReadStream(ISequentialInStream *stream, void *data, size_t *processedSize) throw()
{
  size_t size = *processedSize;
  *processedSize = 0;
  while (size != 0)
  {
    UInt32 curSize = (size < kBlockSize) ? (UInt32)size : kBlockSize;
    UInt32 processedSizeLoc;
    HRESULT res = stream->Read(data, curSize, &processedSizeLoc);
    *processedSize += processedSizeLoc;
    data = (void *)((Byte *)data + processedSizeLoc);
    size -= processedSizeLoc;
    RINOK(res);
    if (processedSizeLoc == 0)
      return S_OK;
  }
  return S_OK;
}

HRESULT ReadStream_FALSE(ISequentialInStream *stream, void *data, size_t size) throw()
{
  size_t processedSize = size;
  RINOK(ReadStream(stream, data, &processedSize));
  return (size == processedSize) ? S_OK : S_FALSE;
}

HRESULT ReadStream_FAIL(ISequentialInStream *stream, void *data, size_t size) throw()
{
  size_t processedSize = size;
  RINOK(ReadStream(stream, data, &processedSize));
  return (size == processedSize) ? S_OK : E_FAIL;
}

HRESULT WriteStream(ISequentialOutStream *stream, const void *data, size_t size) throw()
{
  while (size != 0)
  {
    UInt32 curSize = (size < kBlockSize) ? (UInt32)size : kBlockSize;
    UInt32 processedSizeLoc;
    HRESULT res = stream->Write(data, curSize, &processedSizeLoc);
    data = (const void *)((const Byte *)data + processedSizeLoc);
    size -= processedSizeLoc;
    RINOK(res);
    if (processedSizeLoc == 0)
      return E_FAIL;
  }
  return S_OK;
}
// StreamUtils.h

#ifndef __STREAM_UTILS_H
#define __STREAM_UTILS_H

#include "../IStream.h"

HRESULT ReadStream(ISequentialInStream *stream, void *data, size_t *size) throw();
HRESULT ReadStream_FALSE(ISequentialInStream *stream, void *data, size_t size) throw();
HRESULT ReadStream_FAIL(ISequentialInStream *stream, void *data, size_t size) throw();
HRESULT WriteStream(ISequentialOutStream *stream, const void *data, size_t size) throw();

#endif
// UniqBlocks.cpp

#include "StdAfx.h"

#include <string.h>

#include "UniqBlocks.h"

unsigned CUniqBlocks::AddUniq(const Byte *data, size_t size)
{
  unsigned left = 0, right = Sorted.Size();
  while (left != right)
  {
    unsigned mid = (left + right) / 2;
    unsigned index = Sorted[mid];
    const CByteBuffer &buf = Bufs[index];
    size_t sizeMid = buf.Size();
    if (size < sizeMid)
      right = mid;
    else if (size > sizeMid)
      left = mid + 1;
    else
    {
      if (size == 0)
        return index;
      int cmp = memcmp(data, buf, size);
      if (cmp == 0)
        return index;
      if (cmp < 0)
        right = mid;
      else
        left = mid + 1;
    }
  }
  unsigned index = Bufs.Size();
  Sorted.Insert(left, index);
  Bufs.AddNew().CopyFrom(data, size);
  return index;
}

UInt64 CUniqBlocks::GetTotalSizeInBytes() const
{
  UInt64 size = 0;
  FOR_VECTOR (i, Bufs)
    size += Bufs[i].Size();
  return size;
}

void CUniqBlocks::GetReverseMap()
{
  unsigned num = Sorted.Size();
  BufIndexToSortedIndex.ClearAndSetSize(num);
  unsigned *p = &BufIndexToSortedIndex[0];
  const unsigned *sorted = &Sorted[0];
  for (unsigned i = 0; i < num; i++)
    p[sorted[i]] = i;
}
// UniqBlocks.h

#ifndef __UNIQ_BLOCKS_H
#define __UNIQ_BLOCKS_H

#include "../../Common/MyTypes.h"
#include "../../Common/MyBuffer.h"
#include "../../Common/MyVector.h"

struct CUniqBlocks
{
  CObjectVector<CByteBuffer> Bufs;
  CUIntVector Sorted;
  CUIntVector BufIndexToSortedIndex;

  unsigned AddUniq(const Byte *data, size_t size);
  UInt64 GetTotalSizeInBytes() const;
  void GetReverseMap();

  bool IsOnlyEmpty() const
  {
    return (Bufs.Size() == 0 || Bufs.Size() == 1 && Bufs[0].Size() == 0);
  }
};

#endif
// VirtThread.cpp

#include "StdAfx.h"

#include "VirtThread.h"

static THREAD_FUNC_DECL CoderThread(void *p)
{
  for (;;)
  {
    CVirtThread *t = (CVirtThread *)p;
    t->StartEvent.Lock();
    if (t->Exit)
      return 0;
    t->Execute();
    t->FinishedEvent.Set();
  }
}

WRes CVirtThread::Create()
{
  RINOK(StartEvent.CreateIfNotCreated());
  RINOK(FinishedEvent.CreateIfNotCreated());
  StartEvent.Reset();
  FinishedEvent.Reset();
  Exit = false;
  if (Thread.IsCreated())
    return S_OK;
  return Thread.Create(CoderThread, this);
}

void CVirtThread::Start()
{
  Exit = false;
  StartEvent.Set();
}

void CVirtThread::WaitThreadFinish()
{
  Exit = true;
  if (StartEvent.IsCreated())
    StartEvent.Set();
  if (Thread.IsCreated())
  {
    Thread.Wait();
    Thread.Close();
  }
}
// VirtThread.h

#ifndef __VIRT_THREAD_H
#define __VIRT_THREAD_H

#include "../../Windows/Synchronization.h"
#include "../../Windows/Thread.h"

struct CVirtThread
{
  NWindows::NSynchronization::CAutoResetEvent StartEvent;
  NWindows::NSynchronization::CAutoResetEvent FinishedEvent;
  NWindows::CThread Thread;
  bool Exit;

  ~CVirtThread() { WaitThreadFinish(); }
  void WaitThreadFinish(); // call it in destructor of child class !
  WRes Create();
  void Start();
  virtual void Execute() = 0;
  void WaitExecuteFinish() { FinishedEvent.Lock(); }
};

#endif
// Compress/BZip2Const.h

#ifndef __COMPRESS_BZIP2_CONST_H
#define __COMPRESS_BZIP2_CONST_H

namespace NCompress {
namespace NBZip2 {

const Byte kArSig0 = 'B';
const Byte kArSig1 = 'Z';
const Byte kArSig2 = 'h';
const Byte kArSig3 = '0';

const Byte kFinSig0 = 0x17;
const Byte kFinSig1 = 0x72;
const Byte kFinSig2 = 0x45;
const Byte kFinSig3 = 0x38;
const Byte kFinSig4 = 0x50;
const Byte kFinSig5 = 0x90;

const Byte kBlockSig0 = 0x31;
const Byte kBlockSig1 = 0x41;
const Byte kBlockSig2 = 0x59;
const Byte kBlockSig3 = 0x26;
const Byte kBlockSig4 = 0x53;
const Byte kBlockSig5 = 0x59;

const unsigned kNumOrigBits = 24;

const unsigned kNumTablesBits = 3;
const unsigned kNumTablesMin = 2;
const unsigned kNumTablesMax = 6;

const unsigned kNumLevelsBits = 5;

const unsigned kMaxHuffmanLen = 20; // Check it

const unsigned kMaxAlphaSize = 258;

const unsigned kGroupSize = 50;

const unsigned kBlockSizeMultMin = 1;
const unsigned kBlockSizeMultMax = 9;

const UInt32 kBlockSizeStep = 100000;
const UInt32 kBlockSizeMax = kBlockSizeMultMax * kBlockSizeStep;

const unsigned kNumSelectorsBits = 15;
const UInt32 kNumSelectorsMax = (2 + (kBlockSizeMax / kGroupSize));

const unsigned kRleModeRepSize = 4;

}}

#endif
// BZip2Crc.cpp

#include "StdAfx.h"

#include "BZip2Crc.h"

UInt32 CBZip2Crc::Table[256];

static const UInt32 kBZip2CrcPoly = 0x04c11db7;  /* AUTODIN II, Ethernet, & FDDI */

void CBZip2Crc::InitTable()
{
  for (UInt32 i = 0; i < 256; i++)
  {
    UInt32 r = (i << 24);
    for (int j = 8; j > 0; j--)
      r = (r & 0x80000000) ? ((r << 1) ^ kBZip2CrcPoly) : (r << 1);
    Table[i] = r;
  }
}

class CBZip2CrcTableInit
{
public:
  CBZip2CrcTableInit() { CBZip2Crc::InitTable(); }
} g_BZip2CrcTableInit;
// BZip2Crc.h

#ifndef __BZIP2_CRC_H
#define __BZIP2_CRC_H

#include "../../Common/MyTypes.h"

class CBZip2Crc
{
  UInt32 _value;
  static UInt32 Table[256];
public:
  static void InitTable();
  CBZip2Crc(): _value(0xFFFFFFFF) {};
  void Init() { _value = 0xFFFFFFFF; }
  void UpdateByte(Byte b) { _value = Table[(_value >> 24) ^ b] ^ (_value << 8); }
  void UpdateByte(unsigned int b) { _value = Table[(_value >> 24) ^ b] ^ (_value << 8); }
  UInt32 GetDigest() const { return _value ^ 0xFFFFFFFF; }
};

class CBZip2CombinedCrc
{
  UInt32 _value;
public:
  CBZip2CombinedCrc():  _value(0){};
  void Init() { _value = 0; }
  void Update(UInt32 v) { _value = ((_value << 1) | (_value >> 31)) ^ v; }
  UInt32 GetDigest() const { return _value ; }
};

#endif
// BZip2Decoder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "BZip2Decoder.h"
#include "Mtf8.h"

namespace NCompress {
namespace NBZip2 {

#undef NO_INLINE
#define NO_INLINE
  
static const UInt32 kNumThreadsMax = 4;

static const UInt32 kBufferSize = (1 << 17);

static const UInt16 kRandNums[512] = {
   619, 720, 127, 481, 931, 816, 813, 233, 566, 247,
   985, 724, 205, 454, 863, 491, 741, 242, 949, 214,
   733, 859, 335, 708, 621, 574, 73, 654, 730, 472,
   419, 436, 278, 496, 867, 210, 399, 680, 480, 51,
   878, 465, 811, 169, 869, 675, 611, 697, 867, 561,
   862, 687, 507, 283, 482, 129, 807, 591, 733, 623,
   150, 238, 59, 379, 684, 877, 625, 169, 643, 105,
   170, 607, 520, 932, 727, 476, 693, 425, 174, 647,
   73, 122, 335, 530, 442, 853, 695, 249, 445, 515,
   909, 545, 703, 919, 874, 474, 882, 500, 594, 612,
   641, 801, 220, 162, 819, 984, 589, 513, 495, 799,
   161, 604, 958, 533, 221, 400, 386, 867, 600, 782,
   382, 596, 414, 171, 516, 375, 682, 485, 911, 276,
   98, 553, 163, 354, 666, 933, 424, 341, 533, 870,
   227, 730, 475, 186, 263, 647, 537, 686, 600, 224,
   469, 68, 770, 919, 190, 373, 294, 822, 808, 206,
   184, 943, 795, 384, 383, 461, 404, 758, 839, 887,
   715, 67, 618, 276, 204, 918, 873, 777, 604, 560,
   951, 160, 578, 722, 79, 804, 96, 409, 713, 940,
   652, 934, 970, 447, 318, 353, 859, 672, 112, 785,
   645, 863, 803, 350, 139, 93, 354, 99, 820, 908,
   609, 772, 154, 274, 580, 184, 79, 626, 630, 742,
   653, 282, 762, 623, 680, 81, 927, 626, 789, 125,
   411, 521, 938, 300, 821, 78, 343, 175, 128, 250,
   170, 774, 972, 275, 999, 639, 495, 78, 352, 126,
   857, 956, 358, 619, 580, 124, 737, 594, 701, 612,
   669, 112, 134, 694, 363, 992, 809, 743, 168, 974,
   944, 375, 748, 52, 600, 747, 642, 182, 862, 81,
   344, 805, 988, 739, 511, 655, 814, 334, 249, 515,
   897, 955, 664, 981, 649, 113, 974, 459, 893, 228,
   433, 837, 553, 268, 926, 240, 102, 654, 459, 51,
   686, 754, 806, 760, 493, 403, 415, 394, 687, 700,
   946, 670, 656, 610, 738, 392, 760, 799, 887, 653,
   978, 321, 576, 617, 626, 502, 894, 679, 243, 440,
   680, 879, 194, 572, 640, 724, 926, 56, 204, 700,
   707, 151, 457, 449, 797, 195, 791, 558, 945, 679,
   297, 59, 87, 824, 713, 663, 412, 693, 342, 606,
   134, 108, 571, 364, 631, 212, 174, 643, 304, 329,
   343, 97, 430, 751, 497, 314, 983, 374, 822, 928,
   140, 206, 73, 263, 980, 736, 876, 478, 430, 305,
   170, 514, 364, 692, 829, 82, 855, 953, 676, 246,
   369, 970, 294, 750, 807, 827, 150, 790, 288, 923,
   804, 378, 215, 828, 592, 281, 565, 555, 710, 82,
   896, 831, 547, 261, 524, 462, 293, 465, 502, 56,
   661, 821, 976, 991, 658, 869, 905, 758, 745, 193,
   768, 550, 608, 933, 378, 286, 215, 979, 792, 961,
   61, 688, 793, 644, 986, 403, 106, 366, 905, 644,
   372, 567, 466, 434, 645, 210, 389, 550, 919, 135,
   780, 773, 635, 389, 707, 100, 626, 958, 165, 504,
   920, 176, 193, 713, 857, 265, 203, 50, 668, 108,
   645, 990, 626, 197, 510, 357, 358, 850, 858, 364,
   936, 638
};

bool CState::Alloc()
{
  if (!Counters)
    Counters = (UInt32 *)::BigAlloc((256 + kBlockSizeMax) * sizeof(UInt32));
  return (Counters != 0);
}

void CState::Free()
{
  ::BigFree(Counters);
  Counters = 0;
}

Byte CDecoder::ReadByte() { return (Byte)Base.ReadBits(8); }

UInt32 CBase::ReadBits(unsigned numBits) { return BitDecoder.ReadBits(numBits); }
unsigned CBase::ReadBit() { return (unsigned)BitDecoder.ReadBits(1); }

HRESULT CBase::ReadBlock(UInt32 *charCounters, UInt32 blockSizeMax, CBlockProps *props)
{
  NumBlocks++;

  if (props->randMode)
    props->randMode = ReadBit() ? true : false;
  props->origPtr = ReadBits(kNumOrigBits);
  
  // in original code it compares OrigPtr to (UInt32)(10 + blockSizeMax)) : why ?
  if (props->origPtr >= blockSizeMax)
    return S_FALSE;

  CMtf8Decoder mtf;
  mtf.StartInit();
  
  unsigned numInUse = 0;
  {
    Byte inUse16[16];
    unsigned i;
    for (i = 0; i < 16; i++)
      inUse16[i] = (Byte)ReadBit();
    for (i = 0; i < 256; i++)
      if (inUse16[i >> 4])
      {
        if (ReadBit())
          mtf.Add(numInUse++, (Byte)i);
      }
    if (numInUse == 0)
      return S_FALSE;
    // mtf.Init(numInUse);
  }
  unsigned alphaSize = numInUse + 2;

  unsigned numTables = ReadBits(kNumTablesBits);
  if (numTables < kNumTablesMin || numTables > kNumTablesMax)
    return S_FALSE;
  
  UInt32 numSelectors = ReadBits(kNumSelectorsBits);
  if (numSelectors < 1 || numSelectors > kNumSelectorsMax)
    return S_FALSE;

  {
    Byte mtfPos[kNumTablesMax];
    unsigned t = 0;
    do
      mtfPos[t] = (Byte)t;
    while (++t < numTables);
    UInt32 i = 0;
    do
    {
      unsigned j = 0;
      while (ReadBit())
        if (++j >= numTables)
          return S_FALSE;
      Byte tmp = mtfPos[j];
      for (;j > 0; j--)
        mtfPos[j] = mtfPos[j - 1];
      m_Selectors[i] = mtfPos[0] = tmp;
    }
    while (++i < numSelectors);
  }

  unsigned t = 0;
  do
  {
    Byte lens[kMaxAlphaSize];
    unsigned len = (unsigned)ReadBits(kNumLevelsBits);
    unsigned i;
    for (i = 0; i < alphaSize; i++)
    {
      for (;;)
      {
        if (len < 1 || len > kMaxHuffmanLen)
          return S_FALSE;
        if (!ReadBit())
          break;
        len++;
        len -= (ReadBit() << 1);
      }
      lens[i] = (Byte)len;
    }
    for (; i < kMaxAlphaSize; i++)
      lens[i] = 0;
    if (!m_HuffmanDecoders[t].Build(lens))
      return S_FALSE;
  }
  while (++t < numTables);

  {
    for (unsigned i = 0; i < 256; i++)
      charCounters[i] = 0;
  }
  
  UInt32 blockSize = 0;
  {
    UInt32 groupIndex = 0;
    UInt32 groupSize = 0;
    CHuffmanDecoder *huffmanDecoder = 0;
    unsigned runPower = 0;
    UInt32 runCounter = 0;
    
    for (;;)
    {
      if (groupSize == 0)
      {
        if (groupIndex >= numSelectors)
          return S_FALSE;
        groupSize = kGroupSize;
        huffmanDecoder = &m_HuffmanDecoders[m_Selectors[groupIndex++]];
      }
      groupSize--;
        
      if (BitDecoder.ExtraBitsWereRead_Fast())
        break;

      UInt32 nextSym = huffmanDecoder->Decode(&BitDecoder);
      
      if (nextSym < 2)
      {
        runCounter += ((UInt32)(nextSym + 1) << runPower++);
        if (blockSizeMax - blockSize < runCounter)
          return S_FALSE;
        continue;
      }
      if (runCounter != 0)
      {
        UInt32 b = (UInt32)mtf.GetHead();
        charCounters[b] += runCounter;
        do
          charCounters[256 + blockSize++] = b;
        while (--runCounter != 0);
        runPower = 0;
      }
      if (nextSym <= (UInt32)numInUse)
      {
        UInt32 b = (UInt32)mtf.GetAndMove((unsigned)nextSym - 1);
        if (blockSize >= blockSizeMax)
          return S_FALSE;
        charCounters[b]++;
        charCounters[256 + blockSize++] = b;
      }
      else if (nextSym == (UInt32)numInUse + 1)
        break;
      else
        return S_FALSE;
    }

    if (BitDecoder.ExtraBitsWereRead())
      return S_FALSE;
  }
  props->blockSize = blockSize;
  return (props->origPtr < props->blockSize) ? S_OK : S_FALSE;
}

static void NO_INLINE DecodeBlock1(UInt32 *charCounters, UInt32 blockSize)
{
  {
    UInt32 sum = 0;
    for (UInt32 i = 0; i < 256; i++)
    {
      sum += charCounters[i];
      charCounters[i] = sum - charCounters[i];
    }
  }
  
  UInt32 *tt = charCounters + 256;
  // Compute the T^(-1) vector
  UInt32 i = 0;
  do
    tt[charCounters[tt[i] & 0xFF]++] |= (i << 8);
  while (++i < blockSize);
}

static UInt32 NO_INLINE DecodeBlock2(const UInt32 *tt, UInt32 blockSize, UInt32 OrigPtr, COutBuffer &m_OutStream)
{
  CBZip2Crc crc;

  // it's for speed optimization: prefetch & prevByte_init;
  UInt32 tPos = tt[tt[OrigPtr] >> 8];
  unsigned prevByte = (unsigned)(tPos & 0xFF);
  
  unsigned numReps = 0;

  do
  {
    unsigned b = (unsigned)(tPos & 0xFF);
    tPos = tt[tPos >> 8];
    
    if (numReps == kRleModeRepSize)
    {
      for (; b > 0; b--)
      {
        crc.UpdateByte(prevByte);
        m_OutStream.WriteByte((Byte)prevByte);
      }
      numReps = 0;
      continue;
    }
    if (b != prevByte)
      numReps = 0;
    numReps++;
    prevByte = b;
    crc.UpdateByte(b);
    m_OutStream.WriteByte((Byte)b);

    /*
    prevByte = b;
    crc.UpdateByte(b);
    m_OutStream.WriteByte((Byte)b);
    for (; --blockSize != 0;)
    {
      b = (unsigned)(tPos & 0xFF);
      tPos = tt[tPos >> 8];
      crc.UpdateByte(b);
      m_OutStream.WriteByte((Byte)b);
      if (b != prevByte)
      {
        prevByte = b;
        continue;
      }
      if (--blockSize == 0)
        break;
      
      b = (unsigned)(tPos & 0xFF);
      tPos = tt[tPos >> 8];
      crc.UpdateByte(b);
      m_OutStream.WriteByte((Byte)b);
      if (b != prevByte)
      {
        prevByte = b;
        continue;
      }
      if (--blockSize == 0)
        break;
      
      b = (unsigned)(tPos & 0xFF);
      tPos = tt[tPos >> 8];
      crc.UpdateByte(b);
      m_OutStream.WriteByte((Byte)b);
      if (b != prevByte)
      {
        prevByte = b;
        continue;
      }
      --blockSize;
      break;
    }
    if (blockSize == 0)
      break;

    b = (unsigned)(tPos & 0xFF);
    tPos = tt[tPos >> 8];
    
    for (; b > 0; b--)
    {
      crc.UpdateByte(prevByte);
      m_OutStream.WriteByte((Byte)prevByte);
    }
    */
  }
  while (--blockSize != 0);
  return crc.GetDigest();
}

static UInt32 NO_INLINE DecodeBlock2Rand(const UInt32 *tt, UInt32 blockSize, UInt32 OrigPtr, COutBuffer &m_OutStream)
{
  CBZip2Crc crc;
  
  UInt32 randIndex = 1;
  UInt32 randToGo = kRandNums[0] - 2;
  
  unsigned numReps = 0;

  // it's for speed optimization: prefetch & prevByte_init;
  UInt32 tPos = tt[tt[OrigPtr] >> 8];
  unsigned prevByte = (unsigned)(tPos & 0xFF);
  
  do
  {
    unsigned b = (unsigned)(tPos & 0xFF);
    tPos = tt[tPos >> 8];
    
    {
      if (randToGo == 0)
      {
        b ^= 1;
        randToGo = kRandNums[randIndex++];
        randIndex &= 0x1FF;
      }
      randToGo--;
    }
    
    if (numReps == kRleModeRepSize)
    {
      for (; b > 0; b--)
      {
        crc.UpdateByte(prevByte);
        m_OutStream.WriteByte((Byte)prevByte);
      }
      numReps = 0;
      continue;
    }
    if (b != prevByte)
      numReps = 0;
    numReps++;
    prevByte = b;
    crc.UpdateByte(b);
    m_OutStream.WriteByte((Byte)b);
  }
  while (--blockSize != 0);
  return crc.GetDigest();
}

static UInt32 NO_INLINE DecodeBlock(const CBlockProps &props, UInt32 *tt, COutBuffer &m_OutStream)
{
  if (props.randMode)
    return DecodeBlock2Rand(tt, props.blockSize, props.origPtr, m_OutStream);
  else
    return DecodeBlock2    (tt, props.blockSize, props.origPtr, m_OutStream);
}

CDecoder::CDecoder()
{
  #ifndef _7ZIP_ST
  m_States = 0;
  m_NumThreadsPrev = 0;
  NumThreads = 1;
  #endif
  _needInStreamInit = true;
}

#ifndef _7ZIP_ST

CDecoder::~CDecoder()
{
  Free();
}

#define RINOK_THREAD(x) { WRes __result_ = (x); if (__result_ != 0) return __result_; }

HRESULT CDecoder::Create()
{
  RINOK_THREAD(CanProcessEvent.CreateIfNotCreated());
  RINOK_THREAD(CanStartWaitingEvent.CreateIfNotCreated());
  if (m_States != 0 && m_NumThreadsPrev == NumThreads)
    return S_OK;
  Free();
  MtMode = (NumThreads > 1);
  m_NumThreadsPrev = NumThreads;
  try
  {
    m_States = new CState[NumThreads];
    if (!m_States)
      return E_OUTOFMEMORY;
  }
  catch(...) { return E_OUTOFMEMORY; }
  for (UInt32 t = 0; t < NumThreads; t++)
  {
    CState &ti = m_States[t];
    ti.Decoder = this;
    if (MtMode)
    {
      HRESULT res = ti.Create();
      if (res != S_OK)
      {
        NumThreads = t;
        Free();
        return res;
      }
    }
  }
  return S_OK;
}

void CDecoder::Free()
{
  if (!m_States)
    return;
  CloseThreads = true;
  CanProcessEvent.Set();
  for (UInt32 t = 0; t < NumThreads; t++)
  {
    CState &s = m_States[t];
    if (MtMode)
      s.Thread.Wait();
    s.Free();
  }
  delete []m_States;
  m_States = 0;
}

#endif

bool IsEndSig(const Byte *p) throw()
{
  return
    p[0] == kFinSig0 &&
    p[1] == kFinSig1 &&
    p[2] == kFinSig2 &&
    p[3] == kFinSig3 &&
    p[4] == kFinSig4 &&
    p[5] == kFinSig5;
}

bool IsBlockSig(const Byte *p) throw()
{
  return
    p[0] == kBlockSig0 &&
    p[1] == kBlockSig1 &&
    p[2] == kBlockSig2 &&
    p[3] == kBlockSig3 &&
    p[4] == kBlockSig4 &&
    p[5] == kBlockSig5;
}

HRESULT CDecoder::ReadSignature(UInt32 &crc)
{
  BzWasFinished = false;
  crc = 0;

  Byte s[10];
  unsigned i;
  for (i = 0; i < 10; i++)
    s[i] = ReadByte();

  if (Base.BitDecoder.ExtraBitsWereRead())
    return S_FALSE;

  UInt32 v = 0;
  for (i = 0; i < 4; i++)
  {
    v <<= 8;
    v |= s[6 + i];
  }

  crc = v;

  if (IsBlockSig(s))
  {
    IsBz = true;
    CombinedCrc.Update(crc);
    return S_OK;
  }

  if (!IsEndSig(s))
    return S_FALSE;

  IsBz = true;
  BzWasFinished = true;
  if (crc != CombinedCrc.GetDigest())
  {
    CrcError = true;
    return S_FALSE;
  }
  return S_OK;
}

HRESULT CDecoder::DecodeFile(ICompressProgressInfo *progress)
{
  Progress = progress;
  #ifndef _7ZIP_ST
  RINOK(Create());
  for (UInt32 t = 0; t < NumThreads; t++)
  {
    CState &s = m_States[t];
    if (!s.Alloc())
      return E_OUTOFMEMORY;
    if (MtMode)
    {
      RINOK(s.StreamWasFinishedEvent.Reset());
      RINOK(s.WaitingWasStartedEvent.Reset());
      RINOK(s.CanWriteEvent.Reset());
    }
  }
  #else
  if (!m_States[0].Alloc())
    return E_OUTOFMEMORY;
  #endif

  IsBz = false;

  /*
  if (Base.BitDecoder.ExtraBitsWereRead())
    return E_FAIL;
  */

  Byte s[4];
  unsigned i;
  for (i = 0; i < 4; i++)
    s[i] = ReadByte();
  if (Base.BitDecoder.ExtraBitsWereRead())
    return S_FALSE;

  if (s[0] != kArSig0 ||
      s[1] != kArSig1 ||
      s[2] != kArSig2 ||
      s[3] <= kArSig3 ||
      s[3] > kArSig3 + kBlockSizeMultMax)
    return S_FALSE;

  UInt32 dicSize = (UInt32)(s[3] - kArSig3) * kBlockSizeStep;

  CombinedCrc.Init();
  #ifndef _7ZIP_ST
  if (MtMode)
  {
    NextBlockIndex = 0;
    StreamWasFinished1 = StreamWasFinished2 = false;
    CloseThreads = false;
    CanStartWaitingEvent.Reset();
    m_States[0].CanWriteEvent.Set();
    BlockSizeMax = dicSize;
    Result1 = Result2 = S_OK;
    CanProcessEvent.Set();
    UInt32 t;
    for (t = 0; t < NumThreads; t++)
      m_States[t].StreamWasFinishedEvent.Lock();
    CanProcessEvent.Reset();
    CanStartWaitingEvent.Set();
    for (t = 0; t < NumThreads; t++)
      m_States[t].WaitingWasStartedEvent.Lock();
    CanStartWaitingEvent.Reset();
    RINOK(Result2);
    RINOK(Result1);
  }
  else
  #endif
  {
    CState &state = m_States[0];
    for (;;)
    {
      RINOK(SetRatioProgress(Base.BitDecoder.GetProcessedSize()));
      UInt32 crc;
      RINOK(ReadSignature(crc));
      if (BzWasFinished)
        return S_OK;

      CBlockProps props;
      props.randMode = true;
      RINOK(Base.ReadBlock(state.Counters, dicSize, &props));
      DecodeBlock1(state.Counters, props.blockSize);
      if (DecodeBlock(props, state.Counters + 256, m_OutStream) != crc)
      {
        CrcError = true;
        return S_FALSE;
      }
    }
  }
  return SetRatioProgress(Base.BitDecoder.GetProcessedSize());
}

HRESULT CDecoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    ICompressProgressInfo *progress)
{
  IsBz = false;
  BzWasFinished = false;
  CrcError = false;

  try
  {

  if (!Base.BitDecoder.Create(kBufferSize))
    return E_OUTOFMEMORY;
  if (!m_OutStream.Create(kBufferSize))
    return E_OUTOFMEMORY;

  if (inStream)
    Base.BitDecoder.SetStream(inStream);

  CDecoderFlusher flusher(this);

  if (_needInStreamInit)
  {
    Base.BitDecoder.Init();
    _needInStreamInit = false;
  }
  _inStart = Base.BitDecoder.GetProcessedSize();

  Base.BitDecoder.AlignToByte();

  m_OutStream.SetStream(outStream);
  m_OutStream.Init();

  RINOK(DecodeFile(progress));
  flusher.NeedFlush = false;
  return Flush();

  }
  catch(const CInBufferException &e)  { return e.ErrorCode; }
  catch(const COutBufferException &e) { return e.ErrorCode; }
  catch(...) { return E_FAIL; }
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  _needInStreamInit = true;
  return CodeReal(inStream, outStream, progress);
}

HRESULT CDecoder::CodeResume(ISequentialOutStream *outStream, ICompressProgressInfo *progress)
{
  return CodeReal(NULL, outStream, progress);
}

STDMETHODIMP CDecoder::SetInStream(ISequentialInStream *inStream)
{
  Base.InStreamRef = inStream;
  Base.BitDecoder.SetStream(inStream);
  return S_OK;
}

STDMETHODIMP CDecoder::ReleaseInStream()
{
  Base.InStreamRef.Release();
  return S_OK;
}

#ifndef _7ZIP_ST

static THREAD_FUNC_DECL MFThread(void *p) { ((CState *)p)->ThreadFunc(); return 0; }

HRESULT CState::Create()
{
  RINOK_THREAD(StreamWasFinishedEvent.CreateIfNotCreated());
  RINOK_THREAD(WaitingWasStartedEvent.CreateIfNotCreated());
  RINOK_THREAD(CanWriteEvent.CreateIfNotCreated());
  RINOK_THREAD(Thread.Create(MFThread, this));
  return S_OK;
}

void CState::FinishStream()
{
  Decoder->StreamWasFinished1 = true;
  StreamWasFinishedEvent.Set();
  Decoder->CS.Leave();
  Decoder->CanStartWaitingEvent.Lock();
  WaitingWasStartedEvent.Set();
}

void CState::ThreadFunc()
{
  for (;;)
  {
    Decoder->CanProcessEvent.Lock();
    Decoder->CS.Enter();
    if (Decoder->CloseThreads)
    {
      Decoder->CS.Leave();
      return;
    }
    if (Decoder->StreamWasFinished1)
    {
      FinishStream();
      continue;
    }
    HRESULT res = S_OK;

    UInt32 blockIndex = Decoder->NextBlockIndex;
    UInt32 nextBlockIndex = blockIndex + 1;
    if (nextBlockIndex == Decoder->NumThreads)
      nextBlockIndex = 0;
    Decoder->NextBlockIndex = nextBlockIndex;
    UInt32 crc;
    UInt64 packSize = 0;
    CBlockProps props;

    try
    {
      res = Decoder->ReadSignature(crc);
      if (res != S_OK)
      {
        Decoder->Result1 = res;
        FinishStream();
        continue;
      }
      if (Decoder->BzWasFinished)
      {
        Decoder->Result1 = res;
        FinishStream();
        continue;
      }

      props.randMode = true;
      res = Decoder->Base.ReadBlock(Counters, Decoder->BlockSizeMax, &props);
      if (res != S_OK)
      {
        Decoder->Result1 = res;
        FinishStream();
        continue;
      }
      packSize = Decoder->Base.BitDecoder.GetProcessedSize();
    }
    catch(const CInBufferException &e) { res = e.ErrorCode; if (res == S_OK) res = E_FAIL; }
    catch(...) { res = E_FAIL; }
    if (res != S_OK)
    {
      Decoder->Result1 = res;
      FinishStream();
      continue;
    }

    Decoder->CS.Leave();

    DecodeBlock1(Counters, props.blockSize);

    bool needFinish = true;
    try
    {
      Decoder->m_States[blockIndex].CanWriteEvent.Lock();
      needFinish = Decoder->StreamWasFinished2;
      if (!needFinish)
      {
        if (DecodeBlock(props, Counters + 256, Decoder->m_OutStream) == crc)
          res = Decoder->SetRatioProgress(packSize);
        else
          res = S_FALSE;
      }
    }
    catch(const COutBufferException &e) { res = e.ErrorCode; if (res == S_OK) res = E_FAIL; }
    catch(...) { res = E_FAIL; }
    if (res != S_OK)
    {
      Decoder->Result2 = res;
      Decoder->StreamWasFinished2 = true;
    }
    Decoder->m_States[nextBlockIndex].CanWriteEvent.Set();
    if (res != S_OK || needFinish)
    {
      StreamWasFinishedEvent.Set();
      Decoder->CanStartWaitingEvent.Lock();
      WaitingWasStartedEvent.Set();
    }
  }
}

STDMETHODIMP CDecoder::SetNumberOfThreads(UInt32 numThreads)
{
  NumThreads = numThreads;
  if (NumThreads < 1)
    NumThreads = 1;
  if (NumThreads > kNumThreadsMax)
    NumThreads = kNumThreadsMax;
  return S_OK;
}

#endif

HRESULT CDecoder::SetRatioProgress(UInt64 packSize)
{
  if (!Progress)
    return S_OK;
  packSize -= _inStart;
  UInt64 unpackSize = m_OutStream.GetProcessedSize();
  return Progress->SetRatioInfo(&packSize, &unpackSize);
}


// ---------- NSIS ----------

enum
{
  NSIS_STATE_INIT,
  NSIS_STATE_NEW_BLOCK,
  NSIS_STATE_DATA,
  NSIS_STATE_FINISHED,
  NSIS_STATE_ERROR
};

STDMETHODIMP CNsisDecoder::SetInStream(ISequentialInStream *inStream)
{
  Base.InStreamRef = inStream;
  Base.BitDecoder.SetStream(inStream);
  return S_OK;
}
STDMETHODIMP CNsisDecoder::ReleaseInStream()
{
  Base.InStreamRef.Release();
  return S_OK;
}

STDMETHODIMP CNsisDecoder::SetOutStreamSize(const UInt64 * /* outSize */)
{
  _nsisState = NSIS_STATE_INIT;
  return S_OK;
}

STDMETHODIMP CNsisDecoder::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  try {

  *processedSize = 0;
  if (_nsisState == NSIS_STATE_FINISHED)
    return S_OK;
  if (_nsisState == NSIS_STATE_ERROR)
    return S_FALSE;
  if (size == 0)
    return S_OK;

  CState &state = m_State;

  if (_nsisState == NSIS_STATE_INIT)
  {
    if (!Base.BitDecoder.Create(kBufferSize))
      return E_OUTOFMEMORY;
    if (!state.Alloc())
      return E_OUTOFMEMORY;
    Base.BitDecoder.Init();
    _nsisState = NSIS_STATE_NEW_BLOCK;
  }

  if (_nsisState == NSIS_STATE_NEW_BLOCK)
  {
    Byte b = (Byte)Base.ReadBits(8);
    if (b == kFinSig0)
    {
      _nsisState = NSIS_STATE_FINISHED;
      return S_OK;
    }
    if (b != kBlockSig0)
    {
      _nsisState = NSIS_STATE_ERROR;
      return S_FALSE;
    }
    CBlockProps props;
    props.randMode = false;
    RINOK(Base.ReadBlock(state.Counters, 9 * kBlockSizeStep, &props));
    _blockSize = props.blockSize;
    DecodeBlock1(state.Counters, props.blockSize);
    const UInt32 *tt = state.Counters + 256;
    _tPos = tt[tt[props.origPtr] >> 8];
    _prevByte = (unsigned)(_tPos & 0xFF);
    _numReps = 0;
    _repRem = 0;
    _nsisState = NSIS_STATE_DATA;
  }

  UInt32 tPos = _tPos;
  unsigned prevByte = _prevByte;
  unsigned numReps = _numReps;
  UInt32 blockSize = _blockSize;
  const UInt32 *tt = state.Counters + 256;

  while (_repRem)
  {
    _repRem--;
    *(Byte *)data = (Byte)prevByte;
    data = (Byte *)data + 1;
    (*processedSize)++;
    if (--size == 0)
      return S_OK;
  }

  if (blockSize == 0)
  {
    _nsisState = NSIS_STATE_NEW_BLOCK;
    return S_OK;
  }

  do
  {
    unsigned b = (unsigned)(tPos & 0xFF);
    tPos = tt[tPos >> 8];
    blockSize--;
    
    if (numReps == kRleModeRepSize)
    {
      numReps = 0;
      while (b)
      {
        b--;
        *(Byte *)data = (Byte)prevByte;
        data = (Byte *)data + 1;
        (*processedSize)++;
        if (--size == 0)
          break;
      }
      _repRem = b;
      continue;
    }
    if (b != prevByte)
      numReps = 0;
    numReps++;
    prevByte = b;
    *(Byte *)data = (Byte)b;
    data = (Byte *)data + 1;
    (*processedSize)++;
    size--;
  }
  while (size && blockSize);
  _tPos = tPos;
  _prevByte = prevByte;
  _numReps = numReps;
  _blockSize = blockSize;
  return S_OK;

  }
  catch(const CInBufferException &e)  { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
}

}}
// Compress/BZip2Decoder.h

#ifndef __COMPRESS_BZIP2_DECODER_H
#define __COMPRESS_BZIP2_DECODER_H

#include "../../Common/MyCom.h"

#ifndef _7ZIP_ST
#include "../../Windows/Synchronization.h"
#include "../../Windows/Thread.h"
#endif

#include "../ICoder.h"

#include "../Common/InBuffer.h"
#include "../Common/OutBuffer.h"

#include "BitmDecoder.h"
#include "BZip2Const.h"
#include "BZip2Crc.h"
#include "HuffmanDecoder.h"

namespace NCompress {
namespace NBZip2 {

bool IsEndSig(const Byte *p) throw();
bool IsBlockSig(const Byte *p) throw();

typedef NCompress::NHuffman::CDecoder<kMaxHuffmanLen, kMaxAlphaSize> CHuffmanDecoder;

class CDecoder;

struct CState
{
  UInt32 *Counters;

  #ifndef _7ZIP_ST

  CDecoder *Decoder;
  NWindows::CThread Thread;
  bool m_OptimizeNumTables;

  NWindows::NSynchronization::CAutoResetEvent StreamWasFinishedEvent;
  NWindows::NSynchronization::CAutoResetEvent WaitingWasStartedEvent;

  // it's not member of this thread. We just need one event per thread
  NWindows::NSynchronization::CAutoResetEvent CanWriteEvent;

  Byte MtPad[1 << 8]; // It's pad for Multi-Threading. Must be >= Cache_Line_Size.

  HRESULT Create();
  void FinishStream();
  void ThreadFunc();

  #endif

  CState(): Counters(0) {}
  ~CState() { Free(); }
  bool Alloc();
  void Free();
};

struct CBlockProps
{
  UInt32 blockSize;
  UInt32 origPtr;
  bool randMode;
  
  CBlockProps(): blockSize(0), origPtr(0), randMode(false) {}
};

struct CBase
{
  CMyComPtr<ISequentialInStream> InStreamRef;
  NBitm::CDecoder<CInBuffer> BitDecoder;

private:
  Byte m_Selectors[kNumSelectorsMax];
  CHuffmanDecoder m_HuffmanDecoders[kNumTablesMax];

public:
  UInt64 NumBlocks;

  CBase(): NumBlocks(0) {}
  UInt32 ReadBits(unsigned numBits);
  unsigned ReadBit();
  void InitNumBlocks() { NumBlocks = 0; }

  /*
    ReadBlock() props->randMode:
      in: need read randMode bit,
      out: randMode status
  */
  HRESULT ReadBlock(UInt32 *charCounters, UInt32 blockSizeMax, CBlockProps *props);
};

class CDecoder :
  public ICompressCoder,
  #ifndef _7ZIP_ST
  public ICompressSetCoderMt,
  #endif
  public CMyUnknownImp
{
public:
  COutBuffer m_OutStream;
  Byte MtPad[1 << 8]; // It's pad for Multi-Threading. Must be >= Cache_Line_Size.

  CBase Base;

  UInt64 _inStart;

private:

  bool _needInStreamInit;

  Byte ReadByte();

  HRESULT DecodeFile(ICompressProgressInfo *progress);
  HRESULT CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream, ICompressProgressInfo *progress);
  
  class CDecoderFlusher
  {
    CDecoder *_decoder;
  public:
    bool NeedFlush;
    CDecoderFlusher(CDecoder *decoder): _decoder(decoder), NeedFlush(true) {}
    ~CDecoderFlusher()
    {
      if (NeedFlush)
        _decoder->Flush();
    }
  };

public:
  CBZip2CombinedCrc CombinedCrc;
  ICompressProgressInfo *Progress;

  #ifndef _7ZIP_ST
  CState *m_States;
  UInt32 m_NumThreadsPrev;

  NWindows::NSynchronization::CManualResetEvent CanProcessEvent;
  NWindows::NSynchronization::CCriticalSection CS;
  UInt32 NumThreads;
  bool MtMode;
  UInt32 NextBlockIndex;
  bool CloseThreads;
  bool StreamWasFinished1;
  bool StreamWasFinished2;
  NWindows::NSynchronization::CManualResetEvent CanStartWaitingEvent;

  HRESULT Result1;
  HRESULT Result2;

  UInt32 BlockSizeMax;

  ~CDecoder();
  HRESULT Create();
  void Free();

  #else
  CState m_States[1];
  #endif

  bool IsBz;
  bool BzWasFinished; // bzip stream was finished with end signature
  bool CrcError; // it can CRC error of block or CRC error of whole stream.

  CDecoder();

  HRESULT SetRatioProgress(UInt64 packSize);
  HRESULT ReadSignature(UInt32 &crc);

  HRESULT Flush() { return m_OutStream.Flush(); }

  MY_QUERYINTERFACE_BEGIN2(ICompressCoder)
  #ifndef _7ZIP_ST
  MY_QUERYINTERFACE_ENTRY(ICompressSetCoderMt)
  #endif

  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE

  
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
  STDMETHOD(ReleaseInStream)();

  HRESULT CodeResume(ISequentialOutStream *outStream, ICompressProgressInfo *progress);

  UInt64 GetStreamSize() const { return Base.BitDecoder.GetStreamSize(); }
  UInt64 GetInputProcessedSize() const { return Base.BitDecoder.GetProcessedSize(); }

  void InitNumBlocks() { Base.InitNumBlocks(); }
  UInt64 GetNumBlocks() const { return Base.NumBlocks; }
  
  #ifndef _7ZIP_ST
  STDMETHOD(SetNumberOfThreads)(UInt32 numThreads);
  #endif
};


class CNsisDecoder :
  public ISequentialInStream,
  public ICompressSetInStream,
  public ICompressSetOutStreamSize,
  public CMyUnknownImp
{
  CBase Base;

  CState m_State;
  
  int _nsisState;
  UInt32 _tPos;
  unsigned _prevByte;
  unsigned _repRem;
  unsigned _numReps;
  UInt32 _blockSize;

public:

  MY_QUERYINTERFACE_BEGIN2(ISequentialInStream)
  MY_QUERYINTERFACE_ENTRY(ICompressSetInStream)
  MY_QUERYINTERFACE_ENTRY(ICompressSetOutStreamSize)
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
  STDMETHOD(ReleaseInStream)();
  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);
};

}}

#endif
// BZip2Encoder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"
#include "../../../C/BwtSort.h"
#include "../../../C/HuffEnc.h"

#include "BZip2Crc.h"
#include "BZip2Encoder.h"
#include "Mtf8.h"

namespace NCompress {
namespace NBZip2 {

const unsigned kMaxHuffmanLenForEncoding = 16; // it must be < kMaxHuffmanLen = 20

static const UInt32 kBufferSize = (1 << 17);
static const unsigned kNumHuffPasses = 4;

bool CThreadInfo::Alloc()
{
  if (m_BlockSorterIndex == 0)
  {
    m_BlockSorterIndex = (UInt32 *)::BigAlloc(BLOCK_SORT_BUF_SIZE(kBlockSizeMax) * sizeof(UInt32));
    if (m_BlockSorterIndex == 0)
      return false;
  }

  if (m_Block == 0)
  {
    m_Block = (Byte *)::MidAlloc(kBlockSizeMax * 5 + kBlockSizeMax / 10 + (20 << 10));
    if (m_Block == 0)
      return false;
    m_MtfArray = m_Block + kBlockSizeMax;
    m_TempArray = m_MtfArray + kBlockSizeMax * 2 + 2;
  }
  return true;
}

void CThreadInfo::Free()
{
  ::BigFree(m_BlockSorterIndex);
  m_BlockSorterIndex = 0;
  ::MidFree(m_Block);
  m_Block = 0;
}

#ifndef _7ZIP_ST

static THREAD_FUNC_DECL MFThread(void *threadCoderInfo)
{
  return ((CThreadInfo *)threadCoderInfo)->ThreadFunc();
}

#define RINOK_THREAD(x) { WRes __result_ = (x); if (__result_ != 0) return __result_; }

HRESULT CThreadInfo::Create()
{
  RINOK_THREAD(StreamWasFinishedEvent.Create());
  RINOK_THREAD(WaitingWasStartedEvent.Create());
  RINOK_THREAD(CanWriteEvent.Create());
  RINOK_THREAD(Thread.Create(MFThread, this));
  return S_OK;
}

void CThreadInfo::FinishStream(bool needLeave)
{
  Encoder->StreamWasFinished = true;
  StreamWasFinishedEvent.Set();
  if (needLeave)
    Encoder->CS.Leave();
  Encoder->CanStartWaitingEvent.Lock();
  WaitingWasStartedEvent.Set();
}

DWORD CThreadInfo::ThreadFunc()
{
  for (;;)
  {
    Encoder->CanProcessEvent.Lock();
    Encoder->CS.Enter();
    if (Encoder->CloseThreads)
    {
      Encoder->CS.Leave();
      return 0;
    }
    if (Encoder->StreamWasFinished)
    {
      FinishStream(true);
      continue;
    }
    HRESULT res = S_OK;
    bool needLeave = true;
    try
    {
      UInt32 blockSize = Encoder->ReadRleBlock(m_Block);
      m_PackSize = Encoder->m_InStream.GetProcessedSize();
      m_BlockIndex = Encoder->NextBlockIndex;
      if (++Encoder->NextBlockIndex == Encoder->NumThreads)
        Encoder->NextBlockIndex = 0;
      if (blockSize == 0)
      {
        FinishStream(true);
        continue;
      }
      Encoder->CS.Leave();
      needLeave = false;
      res = EncodeBlock3(blockSize);
    }
    catch(const CInBufferException &e)  { res = e.ErrorCode; }
    catch(const COutBufferException &e) { res = e.ErrorCode; }
    catch(...) { res = E_FAIL; }
    if (res != S_OK)
    {
      Encoder->Result = res;
      FinishStream(needLeave);
      continue;
    }
  }
}

#endif

void CEncProps::Normalize(int level)
{
  if (level < 0) level = 5;
  if (level > 9) level = 9;
  
  if (NumPasses == (UInt32)(Int32)-1)
    NumPasses = (level >= 9 ? 7 : (level >= 7 ? 2 : 1));
  if (NumPasses < 1) NumPasses = 1;
  if (NumPasses > kNumPassesMax) NumPasses = kNumPassesMax;
  
  if (BlockSizeMult == (UInt32)(Int32)-1)
    BlockSizeMult = (level >= 5 ? 9 : (level >= 1 ? level * 2 - 1: 1));
  if (BlockSizeMult < kBlockSizeMultMin) BlockSizeMult = kBlockSizeMultMin;
  if (BlockSizeMult > kBlockSizeMultMax) BlockSizeMult = kBlockSizeMultMax;
}

CEncoder::CEncoder()
{
  _props.Normalize(-1);

  #ifndef _7ZIP_ST
  ThreadsInfo = 0;
  m_NumThreadsPrev = 0;
  NumThreads = 1;
  #endif
}

#ifndef _7ZIP_ST
CEncoder::~CEncoder()
{
  Free();
}

HRESULT CEncoder::Create()
{
  RINOK_THREAD(CanProcessEvent.CreateIfNotCreated());
  RINOK_THREAD(CanStartWaitingEvent.CreateIfNotCreated());
  if (ThreadsInfo != 0 && m_NumThreadsPrev == NumThreads)
    return S_OK;
  try
  {
    Free();
    MtMode = (NumThreads > 1);
    m_NumThreadsPrev = NumThreads;
    ThreadsInfo = new CThreadInfo[NumThreads];
    if (ThreadsInfo == 0)
      return E_OUTOFMEMORY;
  }
  catch(...) { return E_OUTOFMEMORY; }
  for (UInt32 t = 0; t < NumThreads; t++)
  {
    CThreadInfo &ti = ThreadsInfo[t];
    ti.Encoder = this;
    if (MtMode)
    {
      HRESULT res = ti.Create();
      if (res != S_OK)
      {
        NumThreads = t;
        Free();
        return res;
      }
    }
  }
  return S_OK;
}

void CEncoder::Free()
{
  if (!ThreadsInfo)
    return;
  CloseThreads = true;
  CanProcessEvent.Set();
  for (UInt32 t = 0; t < NumThreads; t++)
  {
    CThreadInfo &ti = ThreadsInfo[t];
    if (MtMode)
      ti.Thread.Wait();
    ti.Free();
  }
  delete []ThreadsInfo;
  ThreadsInfo = 0;
}
#endif

UInt32 CEncoder::ReadRleBlock(Byte *buffer)
{
  UInt32 i = 0;
  Byte prevByte;
  if (m_InStream.ReadByte(prevByte))
  {
    UInt32 blockSize = _props.BlockSizeMult * kBlockSizeStep - 1;
    unsigned numReps = 1;
    buffer[i++] = prevByte;
    while (i < blockSize) // "- 1" to support RLE
    {
      Byte b;
      if (!m_InStream.ReadByte(b))
        break;
      if (b != prevByte)
      {
        if (numReps >= kRleModeRepSize)
          buffer[i++] = (Byte)(numReps - kRleModeRepSize);
        buffer[i++] = b;
        numReps = 1;
        prevByte = b;
        continue;
      }
      numReps++;
      if (numReps <= kRleModeRepSize)
        buffer[i++] = b;
      else if (numReps == kRleModeRepSize + 255)
      {
        buffer[i++] = (Byte)(numReps - kRleModeRepSize);
        numReps = 0;
      }
    }
    // it's to support original BZip2 decoder
    if (numReps >= kRleModeRepSize)
      buffer[i++] = (Byte)(numReps - kRleModeRepSize);
  }
  return i;
}

void CThreadInfo::WriteBits2(UInt32 value, unsigned numBits) { m_OutStreamCurrent->WriteBits(value, numBits); }
void CThreadInfo::WriteByte2(Byte b) { WriteBits2(b, 8); }
void CThreadInfo::WriteBit2(Byte v) { WriteBits2(v, 1); }
void CThreadInfo::WriteCrc2(UInt32 v)
{
  for (unsigned i = 0; i < 4; i++)
    WriteByte2(((Byte)(v >> (24 - i * 8))));
}

void CEncoder::WriteBits(UInt32 value, unsigned numBits) { m_OutStream.WriteBits(value, numBits); }
void CEncoder::WriteByte(Byte b) { WriteBits(b, 8); }
// void CEncoder::WriteBit(Byte v) { WriteBits(v, 1); }
void CEncoder::WriteCrc(UInt32 v)
{
  for (unsigned i = 0; i < 4; i++)
    WriteByte(((Byte)(v >> (24 - i * 8))));
}


// blockSize > 0
void CThreadInfo::EncodeBlock(const Byte *block, UInt32 blockSize)
{
  WriteBit2(0); // Randomised = false
  
  {
    UInt32 origPtr = BlockSort(m_BlockSorterIndex, block, blockSize);
    // if (m_BlockSorterIndex[origPtr] != 0) throw 1;
    m_BlockSorterIndex[origPtr] = blockSize;
    WriteBits2(origPtr, kNumOrigBits);
  }

  CMtf8Encoder mtf;
  unsigned numInUse = 0;
  {
    Byte inUse[256];
    Byte inUse16[16];
    UInt32 i;
    for (i = 0; i < 256; i++)
      inUse[i] = 0;
    for (i = 0; i < 16; i++)
      inUse16[i] = 0;
    for (i = 0; i < blockSize; i++)
      inUse[block[i]] = 1;
    for (i = 0; i < 256; i++)
      if (inUse[i])
      {
        inUse16[i >> 4] = 1;
        mtf.Buf[numInUse++] = (Byte)i;
      }
    for (i = 0; i < 16; i++)
      WriteBit2(inUse16[i]);
    for (i = 0; i < 256; i++)
      if (inUse16[i >> 4])
        WriteBit2(inUse[i]);
  }
  unsigned alphaSize = numInUse + 2;

  Byte *mtfs = m_MtfArray;
  UInt32 mtfArraySize = 0;
  UInt32 symbolCounts[kMaxAlphaSize];
  {
    for (unsigned i = 0; i < kMaxAlphaSize; i++)
      symbolCounts[i] = 0;
  }

  {
    UInt32 rleSize = 0;
    UInt32 i = 0;
    const UInt32 *bsIndex = m_BlockSorterIndex;
    block--;
    do
    {
      unsigned pos = mtf.FindAndMove(block[bsIndex[i]]);
      if (pos == 0)
        rleSize++;
      else
      {
        while (rleSize != 0)
        {
          rleSize--;
          mtfs[mtfArraySize++] = (Byte)(rleSize & 1);
          symbolCounts[rleSize & 1]++;
          rleSize >>= 1;
        }
        if (pos >= 0xFE)
        {
          mtfs[mtfArraySize++] = 0xFF;
          mtfs[mtfArraySize++] = (Byte)(pos - 0xFE);
        }
        else
          mtfs[mtfArraySize++] = (Byte)(pos + 1);
        symbolCounts[pos + 1]++;
      }
    }
    while (++i < blockSize);

    while (rleSize != 0)
    {
      rleSize--;
      mtfs[mtfArraySize++] = (Byte)(rleSize & 1);
      symbolCounts[rleSize & 1]++;
      rleSize >>= 1;
    }

    if (alphaSize < 256)
      mtfs[mtfArraySize++] = (Byte)(alphaSize - 1);
    else
    {
      mtfs[mtfArraySize++] = 0xFF;
      mtfs[mtfArraySize++] = (Byte)(alphaSize - 256);
    }
    symbolCounts[alphaSize - 1]++;
  }

  UInt32 numSymbols = 0;
  {
    for (unsigned i = 0; i < kMaxAlphaSize; i++)
      numSymbols += symbolCounts[i];
  }

  unsigned bestNumTables = kNumTablesMin;
  UInt32 bestPrice = 0xFFFFFFFF;
  UInt32 startPos = m_OutStreamCurrent->GetPos();
  Byte startCurByte = m_OutStreamCurrent->GetCurByte();
  for (unsigned nt = kNumTablesMin; nt <= kNumTablesMax + 1; nt++)
  {
    unsigned numTables;

    if (m_OptimizeNumTables)
    {
      m_OutStreamCurrent->SetPos(startPos);
      m_OutStreamCurrent->SetCurState((startPos & 7), startCurByte);
      if (nt <= kNumTablesMax)
        numTables = nt;
      else
        numTables = bestNumTables;
    }
    else
    {
      if (numSymbols < 200)  numTables = 2;
      else if (numSymbols < 600) numTables = 3;
      else if (numSymbols < 1200) numTables = 4;
      else if (numSymbols < 2400) numTables = 5;
      else numTables = 6;
    }

    WriteBits2(numTables, kNumTablesBits);
    
    UInt32 numSelectors = (numSymbols + kGroupSize - 1) / kGroupSize;
    WriteBits2(numSelectors, kNumSelectorsBits);
    
    {
      UInt32 remFreq = numSymbols;
      unsigned gs = 0;
      unsigned t = numTables;
      do
      {
        UInt32 tFreq = remFreq / t;
        unsigned ge = gs;
        UInt32 aFreq = 0;
        while (aFreq < tFreq) //  && ge < alphaSize)
          aFreq += symbolCounts[ge++];
        
        if (ge > gs + 1 && t != numTables && t != 1 && (((numTables - t) & 1) == 1))
          aFreq -= symbolCounts[--ge];
        
        Byte *lens = Lens[t - 1];
        unsigned i = 0;
        do
          lens[i] = (Byte)((i >= gs && i < ge) ? 0 : 1);
        while (++i < alphaSize);
        gs = ge;
        remFreq -= aFreq;
      }
      while (--t != 0);
    }
    
    
    for (unsigned pass = 0; pass < kNumHuffPasses; pass++)
    {
      {
        unsigned t = 0;
        do
          memset(Freqs[t], 0, sizeof(Freqs[t]));
        while (++t < numTables);
      }
      
      {
        UInt32 mtfPos = 0;
        UInt32 g = 0;
        do
        {
          UInt32 symbols[kGroupSize];
          unsigned i = 0;
          do
          {
            UInt32 symbol = mtfs[mtfPos++];
            if (symbol >= 0xFF)
              symbol += mtfs[mtfPos++];
            symbols[i] = symbol;
          }
          while (++i < kGroupSize && mtfPos < mtfArraySize);
          
          UInt32 bestPrice2 = 0xFFFFFFFF;
          unsigned t = 0;
          do
          {
            const Byte *lens = Lens[t];
            UInt32 price = 0;
            unsigned j = 0;
            do
              price += lens[symbols[j]];
            while (++j < i);
            if (price < bestPrice2)
            {
              m_Selectors[g] = (Byte)t;
              bestPrice2 = price;
            }
          }
          while (++t < numTables);
          UInt32 *freqs = Freqs[m_Selectors[g++]];
          unsigned j = 0;
          do
            freqs[symbols[j]]++;
          while (++j < i);
        }
        while (mtfPos < mtfArraySize);
      }
      
      unsigned t = 0;
      do
      {
        UInt32 *freqs = Freqs[t];
        unsigned i = 0;
        do
          if (freqs[i] == 0)
            freqs[i] = 1;
        while (++i < alphaSize);
        Huffman_Generate(freqs, Codes[t], Lens[t], kMaxAlphaSize, kMaxHuffmanLenForEncoding);
      }
      while (++t < numTables);
    }
    
    {
      Byte mtfSel[kNumTablesMax];
      {
        unsigned t = 0;
        do
          mtfSel[t] = (Byte)t;
        while (++t < numTables);
      }
      
      UInt32 i = 0;
      do
      {
        Byte sel = m_Selectors[i];
        unsigned pos;
        for (pos = 0; mtfSel[pos] != sel; pos++)
          WriteBit2(1);
        WriteBit2(0);
        for (; pos > 0; pos--)
          mtfSel[pos] = mtfSel[pos - 1];
        mtfSel[0] = sel;
      }
      while (++i < numSelectors);
    }
    
    {
      unsigned t = 0;
      do
      {
        const Byte *lens = Lens[t];
        UInt32 len = lens[0];
        WriteBits2(len, kNumLevelsBits);
        unsigned i = 0;
        do
        {
          UInt32 level = lens[i];
          while (len != level)
          {
            WriteBit2(1);
            if (len < level)
            {
              WriteBit2(0);
              len++;
            }
            else
            {
              WriteBit2(1);
              len--;
            }
          }
          WriteBit2(0);
        }
        while (++i < alphaSize);
      }
      while (++t < numTables);
    }
    
    {
      UInt32 groupSize = 0;
      UInt32 groupIndex = 0;
      const Byte *lens = 0;
      const UInt32 *codes = 0;
      UInt32 mtfPos = 0;
      do
      {
        UInt32 symbol = mtfs[mtfPos++];
        if (symbol >= 0xFF)
          symbol += mtfs[mtfPos++];
        if (groupSize == 0)
        {
          groupSize = kGroupSize;
          unsigned t = m_Selectors[groupIndex++];
          lens = Lens[t];
          codes = Codes[t];
        }
        groupSize--;
        m_OutStreamCurrent->WriteBits(codes[symbol], lens[symbol]);
      }
      while (mtfPos < mtfArraySize);
    }

    if (!m_OptimizeNumTables)
      break;
    UInt32 price = m_OutStreamCurrent->GetPos() - startPos;
    if (price <= bestPrice)
    {
      if (nt == kNumTablesMax)
        break;
      bestPrice = price;
      bestNumTables = nt;
    }
  }
}

// blockSize > 0
UInt32 CThreadInfo::EncodeBlockWithHeaders(const Byte *block, UInt32 blockSize)
{
  WriteByte2(kBlockSig0);
  WriteByte2(kBlockSig1);
  WriteByte2(kBlockSig2);
  WriteByte2(kBlockSig3);
  WriteByte2(kBlockSig4);
  WriteByte2(kBlockSig5);

  CBZip2Crc crc;
  unsigned numReps = 0;
  Byte prevByte = block[0];
  UInt32 i = 0;
  do
  {
    Byte b = block[i];
    if (numReps == kRleModeRepSize)
    {
      for (; b > 0; b--)
        crc.UpdateByte(prevByte);
      numReps = 0;
      continue;
    }
    if (prevByte == b)
      numReps++;
    else
    {
      numReps = 1;
      prevByte = b;
    }
    crc.UpdateByte(b);
  }
  while (++i < blockSize);
  UInt32 crcRes = crc.GetDigest();
  WriteCrc2(crcRes);
  EncodeBlock(block, blockSize);
  return crcRes;
}

void CThreadInfo::EncodeBlock2(const Byte *block, UInt32 blockSize, UInt32 numPasses)
{
  UInt32 numCrcs = m_NumCrcs;
  bool needCompare = false;

  UInt32 startBytePos = m_OutStreamCurrent->GetBytePos();
  UInt32 startPos = m_OutStreamCurrent->GetPos();
  Byte startCurByte = m_OutStreamCurrent->GetCurByte();
  Byte endCurByte = 0;
  UInt32 endPos = 0;
  if (numPasses > 1 && blockSize >= (1 << 10))
  {
    UInt32 blockSize0 = blockSize / 2;
    for (;(block[blockSize0] == block[blockSize0 - 1] ||
          block[blockSize0 - 1] == block[blockSize0 - 2]) &&
          blockSize0 < blockSize; blockSize0++);
    if (blockSize0 < blockSize)
    {
      EncodeBlock2(block, blockSize0, numPasses - 1);
      EncodeBlock2(block + blockSize0, blockSize - blockSize0, numPasses - 1);
      endPos = m_OutStreamCurrent->GetPos();
      endCurByte = m_OutStreamCurrent->GetCurByte();
      if ((endPos & 7) > 0)
        WriteBits2(0, 8 - (endPos & 7));
      m_OutStreamCurrent->SetCurState((startPos & 7), startCurByte);
      needCompare = true;
    }
  }

  UInt32 startBytePos2 = m_OutStreamCurrent->GetBytePos();
  UInt32 startPos2 = m_OutStreamCurrent->GetPos();
  UInt32 crcVal = EncodeBlockWithHeaders(block, blockSize);
  UInt32 endPos2 = m_OutStreamCurrent->GetPos();

  if (needCompare)
  {
    UInt32 size2 = endPos2 - startPos2;
    if (size2 < endPos - startPos)
    {
      UInt32 numBytes = m_OutStreamCurrent->GetBytePos() - startBytePos2;
      Byte *buffer = m_OutStreamCurrent->GetStream();
      for (UInt32 i = 0; i < numBytes; i++)
        buffer[startBytePos + i] = buffer[startBytePos2 + i];
      m_OutStreamCurrent->SetPos(startPos + endPos2 - startPos2);
      m_NumCrcs = numCrcs;
      m_CRCs[m_NumCrcs++] = crcVal;
    }
    else
    {
      m_OutStreamCurrent->SetPos(endPos);
      m_OutStreamCurrent->SetCurState((endPos & 7), endCurByte);
    }
  }
  else
  {
    m_NumCrcs = numCrcs;
    m_CRCs[m_NumCrcs++] = crcVal;
  }
}

HRESULT CThreadInfo::EncodeBlock3(UInt32 blockSize)
{
  CMsbfEncoderTemp outStreamTemp;
  outStreamTemp.SetStream(m_TempArray);
  outStreamTemp.Init();
  m_OutStreamCurrent = &outStreamTemp;

  m_NumCrcs = 0;

  EncodeBlock2(m_Block, blockSize, Encoder->_props.NumPasses);

  #ifndef _7ZIP_ST
  if (Encoder->MtMode)
    Encoder->ThreadsInfo[m_BlockIndex].CanWriteEvent.Lock();
  #endif
  for (UInt32 i = 0; i < m_NumCrcs; i++)
    Encoder->CombinedCrc.Update(m_CRCs[i]);
  Encoder->WriteBytes(m_TempArray, outStreamTemp.GetPos(), outStreamTemp.GetCurByte());
  HRESULT res = S_OK;
  #ifndef _7ZIP_ST
  if (Encoder->MtMode)
  {
    UInt32 blockIndex = m_BlockIndex + 1;
    if (blockIndex == Encoder->NumThreads)
      blockIndex = 0;

    if (Encoder->Progress)
    {
      UInt64 unpackSize = Encoder->m_OutStream.GetProcessedSize();
      res = Encoder->Progress->SetRatioInfo(&m_PackSize, &unpackSize);
    }

    Encoder->ThreadsInfo[blockIndex].CanWriteEvent.Set();
  }
  #endif
  return res;
}

void CEncoder::WriteBytes(const Byte *data, UInt32 sizeInBits, Byte lastByte)
{
  UInt32 bytesSize = (sizeInBits >> 3);
  for (UInt32 i = 0; i < bytesSize; i++)
    m_OutStream.WriteBits(data[i], 8);
  WriteBits(lastByte, (sizeInBits & 7));
}


HRESULT CEncoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  #ifndef _7ZIP_ST
  Progress = progress;
  RINOK(Create());
  for (UInt32 t = 0; t < NumThreads; t++)
  #endif
  {
    #ifndef _7ZIP_ST
    CThreadInfo &ti = ThreadsInfo[t];
    if (MtMode)
    {
      RINOK(ti.StreamWasFinishedEvent.Reset());
      RINOK(ti.WaitingWasStartedEvent.Reset());
      RINOK(ti.CanWriteEvent.Reset());
    }
    #else
    CThreadInfo &ti = ThreadsInfo;
    ti.Encoder = this;
    #endif

    ti.m_OptimizeNumTables = _props.DoOptimizeNumTables();

    if (!ti.Alloc())
      return E_OUTOFMEMORY;
  }


  if (!m_InStream.Create(kBufferSize))
    return E_OUTOFMEMORY;
  if (!m_OutStream.Create(kBufferSize))
    return E_OUTOFMEMORY;


  m_InStream.SetStream(inStream);
  m_InStream.Init();

  m_OutStream.SetStream(outStream);
  m_OutStream.Init();

  CombinedCrc.Init();
  #ifndef _7ZIP_ST
  NextBlockIndex = 0;
  StreamWasFinished = false;
  CloseThreads = false;
  CanStartWaitingEvent.Reset();
  #endif

  WriteByte(kArSig0);
  WriteByte(kArSig1);
  WriteByte(kArSig2);
  WriteByte((Byte)(kArSig3 + _props.BlockSizeMult));

  #ifndef _7ZIP_ST

  if (MtMode)
  {
    ThreadsInfo[0].CanWriteEvent.Set();
    Result = S_OK;
    CanProcessEvent.Set();
    UInt32 t;
    for (t = 0; t < NumThreads; t++)
      ThreadsInfo[t].StreamWasFinishedEvent.Lock();
    CanProcessEvent.Reset();
    CanStartWaitingEvent.Set();
    for (t = 0; t < NumThreads; t++)
      ThreadsInfo[t].WaitingWasStartedEvent.Lock();
    CanStartWaitingEvent.Reset();
    RINOK(Result);
  }
  else
  #endif
  {
    for (;;)
    {
      CThreadInfo &ti =
      #ifndef _7ZIP_ST
      ThreadsInfo[0];
      #else
      ThreadsInfo;
      #endif
      UInt32 blockSize = ReadRleBlock(ti.m_Block);
      if (blockSize == 0)
        break;
      RINOK(ti.EncodeBlock3(blockSize));
      if (progress)
      {
        UInt64 packSize = m_InStream.GetProcessedSize();
        UInt64 unpackSize = m_OutStream.GetProcessedSize();
        RINOK(progress->SetRatioInfo(&packSize, &unpackSize));
      }
    }
  }
  WriteByte(kFinSig0);
  WriteByte(kFinSig1);
  WriteByte(kFinSig2);
  WriteByte(kFinSig3);
  WriteByte(kFinSig4);
  WriteByte(kFinSig5);

  WriteCrc(CombinedCrc.GetDigest());
  return Flush();
}

STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try { return CodeReal(inStream, outStream, inSize, outSize, progress); }
  catch(const CInBufferException &e) { return e.ErrorCode; }
  catch(const COutBufferException &e) { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
}

HRESULT CEncoder::SetCoderProperties(const PROPID *propIDs, const PROPVARIANT *coderProps, UInt32 numProps)
{
  int level = -1;
  CEncProps props;
  for (UInt32 i = 0; i < numProps; i++)
  {
    const PROPVARIANT &prop = coderProps[i];
    PROPID propID = propIDs[i];
    if (propID >= NCoderPropID::kReduceSize)
      continue;
    if (prop.vt != VT_UI4)
      return E_INVALIDARG;
    UInt32 v = (UInt32)prop.ulVal;
    switch (propID)
    {
      case NCoderPropID::kNumPasses: props.NumPasses = v; break;
      case NCoderPropID::kDictionarySize: props.BlockSizeMult = v / kBlockSizeStep; break;
      case NCoderPropID::kLevel: level = v; break;
      case NCoderPropID::kNumThreads:
      {
        #ifndef _7ZIP_ST
        SetNumberOfThreads(v);
        #endif
        break;
      }
      default: return E_INVALIDARG;
    }
  }
  props.Normalize(level);
  _props = props;
  return S_OK;
}

#ifndef _7ZIP_ST
STDMETHODIMP CEncoder::SetNumberOfThreads(UInt32 numThreads)
{
  const UInt32 kNumThreadsMax = 64;
  if (numThreads < 1) numThreads = 1;
  if (numThreads > kNumThreadsMax) numThreads = kNumThreadsMax;
  NumThreads = numThreads;
  return S_OK;
}
#endif

}}
// BZip2Encoder.h

#ifndef __COMPRESS_BZIP2_ENCODER_H
#define __COMPRESS_BZIP2_ENCODER_H

#include "../../Common/Defs.h"
#include "../../Common/MyCom.h"

#ifndef _7ZIP_ST
#include "../../Windows/Synchronization.h"
#include "../../Windows/Thread.h"
#endif

#include "../ICoder.h"

#include "../Common/InBuffer.h"
#include "../Common/OutBuffer.h"

#include "BitmEncoder.h"
#include "BZip2Const.h"
#include "BZip2Crc.h"

namespace NCompress {
namespace NBZip2 {

class CMsbfEncoderTemp
{
  UInt32 _pos;
  unsigned _bitPos;
  Byte _curByte;
  Byte *_buf;
public:
  void SetStream(Byte *buf) { _buf = buf;  }
  Byte *GetStream() const { return _buf; }

  void Init()
  {
    _pos = 0;
    _bitPos = 8;
    _curByte = 0;
  }

  void Flush()
  {
    if (_bitPos < 8)
      WriteBits(0, _bitPos);
  }

  void WriteBits(UInt32 value, unsigned numBits)
  {
    while (numBits > 0)
    {
      unsigned numNewBits = MyMin(numBits, _bitPos);
      numBits -= numNewBits;
      
      _curByte <<= numNewBits;
      UInt32 newBits = value >> numBits;
      _curByte |= Byte(newBits);
      value -= (newBits << numBits);
      
      _bitPos -= numNewBits;
      
      if (_bitPos == 0)
      {
       _buf[_pos++] = _curByte;
        _bitPos = 8;
      }
    }
  }
  
  UInt32 GetBytePos() const { return _pos ; }
  UInt32 GetPos() const { return _pos * 8 + (8 - _bitPos); }
  Byte GetCurByte() const { return _curByte; }
  void SetPos(UInt32 bitPos)
  {
    _pos = bitPos >> 3;
    _bitPos = 8 - ((unsigned)bitPos & 7);
  }
  void SetCurState(unsigned bitPos, Byte curByte)
  {
    _bitPos = 8 - bitPos;
    _curByte = curByte;
  }
};

class CEncoder;

const unsigned kNumPassesMax = 10;

class CThreadInfo
{
public:
  Byte *m_Block;
private:
  Byte *m_MtfArray;
  Byte *m_TempArray;
  UInt32 *m_BlockSorterIndex;

  CMsbfEncoderTemp *m_OutStreamCurrent;

  Byte Lens[kNumTablesMax][kMaxAlphaSize];
  UInt32 Freqs[kNumTablesMax][kMaxAlphaSize];
  UInt32 Codes[kNumTablesMax][kMaxAlphaSize];

  Byte m_Selectors[kNumSelectorsMax];

  UInt32 m_CRCs[1 << kNumPassesMax];
  UInt32 m_NumCrcs;

  UInt32 m_BlockIndex;

  void WriteBits2(UInt32 value, unsigned numBits);
  void WriteByte2(Byte b);
  void WriteBit2(Byte v);
  void WriteCrc2(UInt32 v);

  void EncodeBlock(const Byte *block, UInt32 blockSize);
  UInt32 EncodeBlockWithHeaders(const Byte *block, UInt32 blockSize);
  void EncodeBlock2(const Byte *block, UInt32 blockSize, UInt32 numPasses);
public:
  bool m_OptimizeNumTables;
  CEncoder *Encoder;
  #ifndef _7ZIP_ST
  NWindows::CThread Thread;

  NWindows::NSynchronization::CAutoResetEvent StreamWasFinishedEvent;
  NWindows::NSynchronization::CAutoResetEvent WaitingWasStartedEvent;

  // it's not member of this thread. We just need one event per thread
  NWindows::NSynchronization::CAutoResetEvent CanWriteEvent;

  UInt64 m_PackSize;

  Byte MtPad[1 << 8]; // It's pad for Multi-Threading. Must be >= Cache_Line_Size.
  HRESULT Create();
  void FinishStream(bool needLeave);
  DWORD ThreadFunc();
  #endif

  CThreadInfo(): m_BlockSorterIndex(0), m_Block(0) {}
  ~CThreadInfo() { Free(); }
  bool Alloc();
  void Free();

  HRESULT EncodeBlock3(UInt32 blockSize);
};

struct CEncProps
{
  UInt32 BlockSizeMult;
  UInt32 NumPasses;
  
  CEncProps()
  {
    BlockSizeMult = (UInt32)(Int32)-1;
    NumPasses = (UInt32)(Int32)-1;
  }
  void Normalize(int level);
  bool DoOptimizeNumTables() const { return NumPasses > 1; }
};

class CEncoder :
  public ICompressCoder,
  public ICompressSetCoderProperties,
  #ifndef _7ZIP_ST
  public ICompressSetCoderMt,
  #endif
  public CMyUnknownImp
{
  UInt32 m_NumThreadsPrev;
public:
  CInBuffer m_InStream;
  Byte MtPad[1 << 8]; // It's pad for Multi-Threading. Must be >= Cache_Line_Size.
  CBitmEncoder<COutBuffer> m_OutStream;
  CEncProps _props;
  CBZip2CombinedCrc CombinedCrc;

  #ifndef _7ZIP_ST
  CThreadInfo *ThreadsInfo;
  NWindows::NSynchronization::CManualResetEvent CanProcessEvent;
  NWindows::NSynchronization::CCriticalSection CS;
  UInt32 NumThreads;
  bool MtMode;
  UInt32 NextBlockIndex;

  bool CloseThreads;
  bool StreamWasFinished;
  NWindows::NSynchronization::CManualResetEvent CanStartWaitingEvent;

  HRESULT Result;
  ICompressProgressInfo *Progress;
  #else
  CThreadInfo ThreadsInfo;
  #endif

  UInt32 ReadRleBlock(Byte *buf);
  void WriteBytes(const Byte *data, UInt32 sizeInBits, Byte lastByte);

  void WriteBits(UInt32 value, unsigned numBits);
  void WriteByte(Byte b);
  // void WriteBit(Byte v);
  void WriteCrc(UInt32 v);

  #ifndef _7ZIP_ST
  HRESULT Create();
  void Free();
  #endif

public:
  CEncoder();
  #ifndef _7ZIP_ST
  ~CEncoder();
  #endif

  HRESULT Flush() { return m_OutStream.Flush(); }
  
  MY_QUERYINTERFACE_BEGIN2(ICompressCoder)
  #ifndef _7ZIP_ST
  MY_QUERYINTERFACE_ENTRY(ICompressSetCoderMt)
  #endif
  MY_QUERYINTERFACE_ENTRY(ICompressSetCoderProperties)
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE

  HRESULT CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);

  #ifndef _7ZIP_ST
  STDMETHOD(SetNumberOfThreads)(UInt32 numThreads);
  #endif
};

}}

#endif
// BZip2Register.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "BZip2Decoder.h"
#if !defined(EXTRACT_ONLY) && !defined(BZIP2_EXTRACT_ONLY)
#include "BZip2Encoder.h"
#endif

namespace NCompress {
namespace NBZip2 {

REGISTER_CODEC_CREATE(CreateDec, CDecoder)

#if !defined(EXTRACT_ONLY) && !defined(BZIP2_EXTRACT_ONLY)
REGISTER_CODEC_CREATE(CreateEnc, CEncoder)
#else
#define CreateEnc NULL
#endif

REGISTER_CODEC_2(BZip2, CreateDec, CreateEnc, 0x40202, "BZip2")

}}
// Bcj2Coder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "../Common/StreamUtils.h"

#include "Bcj2Coder.h"

namespace NCompress {
namespace NBcj2 {

CBaseCoder::CBaseCoder()
{
  for (int i = 0; i < BCJ2_NUM_STREAMS + 1; i++)
  {
    _bufs[i] = NULL;
    _bufsCurSizes[i] = 0;
    _bufsNewSizes[i] = (1 << 18);
  }
}

CBaseCoder::~CBaseCoder()
{
  for (int i = 0; i < BCJ2_NUM_STREAMS + 1; i++)
    ::MidFree(_bufs[i]);
}

HRESULT CBaseCoder::Alloc(bool allocForOrig)
{
  unsigned num = allocForOrig ? BCJ2_NUM_STREAMS + 1 : BCJ2_NUM_STREAMS;
  for (unsigned i = 0; i < num; i++)
  {
    UInt32 newSize = _bufsNewSizes[i];
    const UInt32 kMinBufSize = 1;
    if (newSize < kMinBufSize)
      newSize = kMinBufSize;
    if (!_bufs[i] || newSize != _bufsCurSizes[i])
    {
      if (_bufs[i])
      {
        ::MidFree(_bufs[i]);
        _bufs[i] = 0;
      }
      _bufsCurSizes[i] = 0;
      Byte *buf = (Byte *)::MidAlloc(newSize);
      _bufs[i] = buf;
      if (!buf)
        return E_OUTOFMEMORY;
      _bufsCurSizes[i] = newSize;
    }
  }
  return S_OK;
}



#ifndef EXTRACT_ONLY

CEncoder::CEncoder(): _relatLim(BCJ2_RELAT_LIMIT) {}
CEncoder::~CEncoder() {}

STDMETHODIMP CEncoder::SetInBufSize(UInt32, UInt32 size) { _bufsNewSizes[BCJ2_NUM_STREAMS] = size; return S_OK; }
STDMETHODIMP CEncoder::SetOutBufSize(UInt32 streamIndex, UInt32 size) { _bufsNewSizes[streamIndex] = size; return S_OK; }

STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps)
{
  UInt32 relatLim = BCJ2_RELAT_LIMIT;
  
  for (UInt32 i = 0; i < numProps; i++)
  {
    const PROPVARIANT &prop = props[i];
    PROPID propID = propIDs[i];
    if (propID >= NCoderPropID::kReduceSize)
      continue;
    switch (propID)
    {
      /*
      case NCoderPropID::kDefaultProp:
      {
        if (prop.vt != VT_UI4)
          return E_INVALIDARG;
        UInt32 v = prop.ulVal;
        if (v > 31)
          return E_INVALIDARG;
        relatLim = (UInt32)1 << v;
        break;
      }
      */
      case NCoderPropID::kDictionarySize:
      {
        if (prop.vt != VT_UI4)
          return E_INVALIDARG;
        relatLim = prop.ulVal;
        if (relatLim > ((UInt32)1 << 31))
          return E_INVALIDARG;
        break;
      }

      case NCoderPropID::kNumThreads:
        continue;
      case NCoderPropID::kLevel:
        continue;
     
      default: return E_INVALIDARG;
    }
  }
  
  _relatLim = relatLim;
  
  return S_OK;
}


HRESULT CEncoder::CodeReal(ISequentialInStream * const *inStreams, const UInt64 * const *inSizes, UInt32 numInStreams,
    ISequentialOutStream * const *outStreams, const UInt64 * const * /* outSizes */, UInt32 numOutStreams,
    ICompressProgressInfo *progress)
{
  if (numInStreams != 1 || numOutStreams != BCJ2_NUM_STREAMS)
    return E_INVALIDARG;

  RINOK(Alloc());

  UInt32 fileSize_for_Conv = 0;
  if (inSizes && inSizes[0])
  {
    UInt64 inSize = *inSizes[0];
    if (inSize <= BCJ2_FileSize_MAX)
      fileSize_for_Conv = (UInt32)inSize;
  }

  CMyComPtr<ICompressGetSubStreamSize> getSubStreamSize;
  inStreams[0]->QueryInterface(IID_ICompressGetSubStreamSize, (void **)&getSubStreamSize);

  CBcj2Enc enc;
    
  enc.src = _bufs[BCJ2_NUM_STREAMS];
  enc.srcLim = enc.src;
    
  {
    for (int i = 0; i < BCJ2_NUM_STREAMS; i++)
    {
      enc.bufs[i] = _bufs[i];
      enc.lims[i] = _bufs[i] + _bufsCurSizes[i];
    }
  }

  size_t numBytes_in_ReadBuf = 0;
  UInt64 prevProgress = 0;
  UInt64 totalStreamRead = 0; // size read from InputStream
  UInt64 currentInPos = 0; // data that was processed, it doesn't incl