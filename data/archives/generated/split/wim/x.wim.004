ude data in input buffer and data in enc.temp
  UInt64 outSizeRc = 0;

  Bcj2Enc_Init(&enc);

  enc.fileIp = 0;
  enc.fileSize = fileSize_for_Conv;

  enc.relatLimit = _relatLim;

  enc.finishMode = BCJ2_ENC_FINISH_MODE_CONTINUE;

  bool needSubSize = false;
  UInt64 subStreamIndex = 0;
  UInt64 subStreamStartPos = 0;
  bool readWasFinished = false;

  for (;;)
  {
    if (needSubSize && getSubStreamSize)
    {
      enc.fileIp = 0;
      enc.fileSize = fileSize_for_Conv;
      enc.finishMode = BCJ2_ENC_FINISH_MODE_CONTINUE;
      
      for (;;)
      {
        UInt64 subStreamSize = 0;
        HRESULT result = getSubStreamSize->GetSubStreamSize(subStreamIndex, &subStreamSize);
        needSubSize = false;
        
        if (result == S_OK)
        {
          UInt64 newEndPos = subStreamStartPos + subStreamSize;
          
          bool isAccurateEnd = (newEndPos < totalStreamRead ||
            (newEndPos <= totalStreamRead && readWasFinished));
          
          if (newEndPos <= currentInPos && isAccurateEnd)
          {
            subStreamStartPos = newEndPos;
            subStreamIndex++;
            continue;
          }
          
          enc.srcLim = _bufs[BCJ2_NUM_STREAMS] + numBytes_in_ReadBuf;
          
          if (isAccurateEnd)
          {
            // data in enc.temp is possible here
            size_t rem = (size_t)(totalStreamRead - newEndPos);
            
            /* Pos_of(enc.src) <= old newEndPos <= newEndPos
               in another case, it's fail in some code */
            if ((size_t)(enc.srcLim - enc.src) < rem)
              return E_FAIL;
            
            enc.srcLim -= rem;
            enc.finishMode = BCJ2_ENC_FINISH_MODE_END_BLOCK;
          }
          
          if (subStreamSize <= BCJ2_FileSize_MAX)
          {
            enc.fileIp = enc.ip + (UInt32)(subStreamStartPos - currentInPos);
            enc.fileSize = (UInt32)subStreamSize;
          }
          break;
        }
        
        if (result == S_FALSE)
          break;
        if (result == E_NOTIMPL)
        {
          getSubStreamSize.Release();
          break;
        }
        return result;
      }
    }

    if (readWasFinished && totalStreamRead - currentInPos == Bcj2Enc_Get_InputData_Size(&enc))
      enc.finishMode = BCJ2_ENC_FINISH_MODE_END_STREAM;

    Bcj2Enc_Encode(&enc);

    currentInPos = totalStreamRead - numBytes_in_ReadBuf + (enc.src - _bufs[BCJ2_NUM_STREAMS]) - enc.tempPos;
    
    if (Bcj2Enc_IsFinished(&enc))
      break;

    if (enc.state < BCJ2_NUM_STREAMS)
    {
      size_t curSize = enc.bufs[enc.state] - _bufs[enc.state];
      // printf("Write stream = %2d %6d\n", enc.state, curSize);
      RINOK(WriteStream(outStreams[enc.state], _bufs[enc.state], curSize));
      if (enc.state == BCJ2_STREAM_RC)
        outSizeRc += curSize;

      enc.bufs[enc.state] = _bufs[enc.state];
      enc.lims[enc.state] = _bufs[enc.state] + _bufsCurSizes[enc.state];
    }
    else if (enc.state != BCJ2_ENC_STATE_ORIG)
      return E_FAIL;
    else
    {
      needSubSize = true;

      if (numBytes_in_ReadBuf != (size_t)(enc.src - _bufs[BCJ2_NUM_STREAMS]))
      {
        enc.srcLim = _bufs[BCJ2_NUM_STREAMS] + numBytes_in_ReadBuf;
        continue;
      }

      if (readWasFinished)
        continue;
      
      numBytes_in_ReadBuf = 0;
      enc.src    = _bufs[BCJ2_NUM_STREAMS];
      enc.srcLim = _bufs[BCJ2_NUM_STREAMS];
 
      UInt32 curSize = _bufsCurSizes[BCJ2_NUM_STREAMS];
      RINOK(inStreams[0]->Read(_bufs[BCJ2_NUM_STREAMS], curSize, &curSize));

      // printf("Read %6d bytes\n", curSize);
      if (curSize == 0)
      {
        readWasFinished = true;
        continue;
      }

      numBytes_in_ReadBuf = curSize;
      totalStreamRead += numBytes_in_ReadBuf;
      enc.srcLim = _bufs[BCJ2_NUM_STREAMS] + numBytes_in_ReadBuf;
    }

    if (progress && currentInPos - prevProgress >= (1 << 20))
    {
      UInt64 outSize2 = currentInPos + outSizeRc + enc.bufs[BCJ2_STREAM_RC] - enc.bufs[BCJ2_STREAM_RC];
      prevProgress = currentInPos;
      // printf("progress %8d, %8d\n", (int)inSize2, (int)outSize2);
      RINOK(progress->SetRatioInfo(&currentInPos, &outSize2));
    }
  }

  for (int i = 0; i < BCJ2_NUM_STREAMS; i++)
  {
    RINOK(WriteStream(outStreams[i], _bufs[i], enc.bufs[i] - _bufs[i]));
  }

  // if (currentInPos != subStreamStartPos + subStreamSize) return E_FAIL;

  return S_OK;
}

STDMETHODIMP CEncoder::Code(ISequentialInStream * const *inStreams, const UInt64 * const *inSizes, UInt32 numInStreams,
    ISequentialOutStream * const *outStreams, const UInt64 * const *outSizes, UInt32 numOutStreams,
    ICompressProgressInfo *progress)
{
  try
  {
    return CodeReal(inStreams, inSizes, numInStreams, outStreams, outSizes,numOutStreams, progress);
  }
  catch(...) { return E_FAIL; }
}

#endif






STDMETHODIMP CDecoder::SetInBufSize(UInt32 streamIndex, UInt32 size) { _bufsNewSizes[streamIndex] = size; return S_OK; }
STDMETHODIMP CDecoder::SetOutBufSize(UInt32 , UInt32 size) { _bufsNewSizes[BCJ2_NUM_STREAMS] = size; return S_OK; }

CDecoder::CDecoder(): _finishMode(false), _outSizeDefined(false), _outSize(0)
{}

STDMETHODIMP CDecoder::SetFinishMode(UInt32 finishMode)
{
  _finishMode = (finishMode != 0);
  return S_OK;
}

void CDecoder::InitCommon()
{
  {
    for (int i = 0; i < BCJ2_NUM_STREAMS; i++)
      dec.lims[i] = dec.bufs[i] = _bufs[i];
  }

  {
    for (int i = 0; i < BCJ2_NUM_STREAMS; i++)
    {
      _extraReadSizes[i] = 0;
      _inStreamsProcessed[i] = 0;
      _readRes[i] = S_OK;
    }
  }
    
  Bcj2Dec_Init(&dec);
}

HRESULT CDecoder::Code(ISequentialInStream * const *inStreams, const UInt64 * const *inSizes, UInt32 numInStreams,
    ISequentialOutStream * const *outStreams, const UInt64 * const *outSizes, UInt32 numOutStreams,
    ICompressProgressInfo *progress)
{
  if (numInStreams != BCJ2_NUM_STREAMS || numOutStreams != 1)
    return E_INVALIDARG;

  RINOK(Alloc());
    
  InitCommon();

  dec.destLim = dec.dest = _bufs[BCJ2_NUM_STREAMS];
  
  UInt64 outSizeProcessed = 0;
  UInt64 prevProgress = 0;

  HRESULT res = S_OK;

  for (;;)
  {
    if (Bcj2Dec_Decode(&dec) != SZ_OK)
      return S_FALSE;
    
    if (dec.state < BCJ2_NUM_STREAMS)
    {
      size_t totalRead = _extraReadSizes[dec.state];
      {
        Byte *buf = _bufs[dec.state];
        for (size_t i = 0; i < totalRead; i++)
          buf[i] = dec.bufs[dec.state][i];
        dec.lims[dec.state] =
        dec.bufs[dec.state] = buf;
      }

      if (_readRes[dec.state] != S_OK)
      {
        res = _readRes[dec.state];
        break;
      }

      do
      {
        UInt32 curSize = _bufsCurSizes[dec.state] - (UInt32)totalRead;
        /*
        we want to call Read even even if size is 0
        if (inSizes && inSizes[dec.state])
        {
          UInt64 rem = *inSizes[dec.state] - _inStreamsProcessed[dec.state];
          if (curSize > rem)
            curSize = (UInt32)rem;
        }
        */

        HRESULT res2 = inStreams[dec.state]->Read(_bufs[dec.state] + totalRead, curSize, &curSize);
        _readRes[dec.state] = res2;
        if (curSize == 0)
          break;
        _inStreamsProcessed[dec.state] += curSize;
        totalRead += curSize;
        if (res2 != S_OK)
          break;
      }
      while (totalRead < 4 && BCJ2_IS_32BIT_STREAM(dec.state));

      if (_readRes[dec.state] != S_OK)
        res = _readRes[dec.state];

      if (totalRead == 0)
        break;

      // res == S_OK;

      if (BCJ2_IS_32BIT_STREAM(dec.state))
      {
        unsigned extraSize = ((unsigned)totalRead & 3);
        _extraReadSizes[dec.state] = extraSize;
        if (totalRead < 4)
        {
          res = (_readRes[dec.state] != S_OK) ? _readRes[dec.state] : S_FALSE;
          break;
        }
        totalRead -= extraSize;
      }

      dec.lims[dec.state] = _bufs[dec.state] + totalRead;
    }
    else // if (dec.state <= BCJ2_STATE_ORIG)
    {
      size_t curSize = dec.dest - _bufs[BCJ2_NUM_STREAMS];
      if (curSize != 0)
      {
        outSizeProcessed += curSize;
        RINOK(WriteStream(outStreams[0], _bufs[BCJ2_NUM_STREAMS], curSize));
      }
      dec.dest = _bufs[BCJ2_NUM_STREAMS];
      {
        size_t rem = _bufsCurSizes[BCJ2_NUM_STREAMS];
        if (outSizes && outSizes[0])
        {
          UInt64 outSize = *outSizes[0] - outSizeProcessed;
          if (rem > outSize)
            rem = (size_t)outSize;
        }
        dec.destLim = dec.dest + rem;
        if (rem == 0)
          break;
      }
    }

    if (progress)
    {
      UInt64 outSize2 = outSizeProcessed + (dec.dest - _bufs[BCJ2_NUM_STREAMS]);
      if (outSize2 - prevProgress >= (1 << 22))
      {
        UInt64 inSize2 = outSize2 + _inStreamsProcessed[BCJ2_STREAM_RC] - (dec.lims[BCJ2_STREAM_RC] - dec.bufs[BCJ2_STREAM_RC]);
        RINOK(progress->SetRatioInfo(&inSize2, &outSize2));
        prevProgress = outSize2;
      }
    }
  }

  size_t curSize = dec.dest - _bufs[BCJ2_NUM_STREAMS];
  if (curSize != 0)
  {
    outSizeProcessed += curSize;
    RINOK(WriteStream(outStreams[0], _bufs[BCJ2_NUM_STREAMS], curSize));
  }

  if (res != S_OK)
    return res;

  if (_finishMode)
  {
    if (!Bcj2Dec_IsFinished(&dec))
      return S_FALSE;

    // we still allow the cases when input streams are larger than required for decoding.
    // so the case (dec.state == BCJ2_STATE_ORIG) is also allowed, if MAIN stream is larger than required.
    if (dec.state != BCJ2_STREAM_MAIN &&
        dec.state != BCJ2_DEC_STATE_ORIG)
      return S_FALSE;

    if (inSizes)
    {
      for (int i = 0; i < BCJ2_NUM_STREAMS; i++)
      {
        size_t rem = dec.lims[i] - dec.bufs[i] + _extraReadSizes[i];
        /*
        if (rem != 0)
          return S_FALSE;
        */
        if (inSizes[i] && *inSizes[i] != _inStreamsProcessed[i] - rem)
          return S_FALSE;
      }
    }
  }

  return S_OK;
}

STDMETHODIMP CDecoder::SetInStream2(UInt32 streamIndex, ISequentialInStream *inStream)
{
  _inStreams[streamIndex] = inStream;
  return S_OK;
}

STDMETHODIMP CDecoder::ReleaseInStream2(UInt32 streamIndex)
{
  _inStreams[streamIndex].Release();
  return S_OK;
}

STDMETHODIMP CDecoder::SetOutStreamSize(const UInt64 *outSize)
{
  _outSizeDefined = (outSize != NULL);
  _outSize = 0;
  if (_outSizeDefined)
    _outSize = *outSize;

  _outSize_Processed = 0;

  HRESULT res = Alloc(false);
  
  InitCommon();
  dec.destLim = dec.dest = NULL;

  return res;
}


STDMETHODIMP CDecoder::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;

  if (size == 0)
    return S_OK;

  UInt32 totalProcessed = 0;
 
  if (_outSizeDefined)
  {
    UInt64 rem = _outSize - _outSize_Processed;
    if (size > rem)
      size = (UInt32)rem;
  }
  dec.dest = (Byte *)data;
  dec.destLim = (const Byte *)data + size;

  HRESULT res = S_OK;

  for (;;)
  {
    SRes sres = Bcj2Dec_Decode(&dec);
    if (sres != SZ_OK)
      return S_FALSE;
    
    {
      UInt32 curSize = (UInt32)(dec.dest - (Byte *)data);
      if (curSize != 0)
      {
        totalProcessed += curSize;
        if (processedSize)
          *processedSize = totalProcessed;
        data = (void *)((Byte *)data + curSize);
        size -= curSize;
        _outSize_Processed += curSize;
      }
    }

    if (dec.state >= BCJ2_NUM_STREAMS)
      break;

    {
      size_t totalRead = _extraReadSizes[dec.state];
      {
        Byte *buf = _bufs[dec.state];
        for (size_t i = 0; i < totalRead; i++)
          buf[i] = dec.bufs[dec.state][i];
        dec.lims[dec.state] =
        dec.bufs[dec.state] = buf;
      }

      if (_readRes[dec.state] != S_OK)
        return _readRes[dec.state];

      do
      {
        UInt32 curSize = _bufsCurSizes[dec.state] - (UInt32)totalRead;
        HRESULT res2 = _inStreams[dec.state]->Read(_bufs[dec.state] + totalRead, curSize, &curSize);
        _readRes[dec.state] = res2;
        if (curSize == 0)
          break;
        _inStreamsProcessed[dec.state] += curSize;
        totalRead += curSize;
        if (res2 != S_OK)
          break;
      }
      while (totalRead < 4 && BCJ2_IS_32BIT_STREAM(dec.state));

      if (totalRead == 0)
      {
        if (totalProcessed == 0)
          res = _readRes[dec.state];
        break;
      }

      if (BCJ2_IS_32BIT_STREAM(dec.state))
      {
        unsigned extraSize = ((unsigned)totalRead & 3);
        _extraReadSizes[dec.state] = extraSize;
        if (totalRead < 4)
        {
          if (totalProcessed != 0)
            return S_OK;
          return (_readRes[dec.state] != S_OK) ? _readRes[dec.state] : S_FALSE;
        }
        totalRead -= extraSize;
      }

      dec.lims[dec.state] = _bufs[dec.state] + totalRead;
    }
  }

  if (_finishMode && _outSizeDefined && _outSize == _outSize_Processed)
  {
    if (!Bcj2Dec_IsFinished(&dec))
      return S_FALSE;

    if (dec.state != BCJ2_STREAM_MAIN &&
        dec.state != BCJ2_DEC_STATE_ORIG)
      return S_FALSE;
  
    /*
    for (int i = 0; i < BCJ2_NUM_STREAMS; i++)
      if (dec.bufs[i] != dec.lims[i] || _extraReadSizes[i] != 0)
        return S_FALSE;
    */
  }

  return res;
}

}}
// Bcj2Coder.h

#ifndef __COMPRESS_BCJ2_CODER_H
#define __COMPRESS_BCJ2_CODER_H

#include "../../../C/Bcj2.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

namespace NCompress {
namespace NBcj2 {

class CBaseCoder
{
protected:
  Byte *_bufs[BCJ2_NUM_STREAMS + 1];
  UInt32 _bufsCurSizes[BCJ2_NUM_STREAMS + 1];
  UInt32 _bufsNewSizes[BCJ2_NUM_STREAMS + 1];

  HRESULT Alloc(bool allocForOrig = true);
public:
  CBaseCoder();
  ~CBaseCoder();
};


#ifndef EXTRACT_ONLY

class CEncoder:
  public ICompressCoder2,
  public ICompressSetCoderProperties,
  public ICompressSetBufSize,
  public CMyUnknownImp,
  public CBaseCoder
{
  UInt32 _relatLim;

  HRESULT CodeReal(ISequentialInStream * const *inStreams, const UInt64 * const *inSizes, UInt32 numInStreams,
      ISequentialOutStream * const *outStreams, const UInt64 * const *outSizes, UInt32 numOutStreams,
      ICompressProgressInfo *progress);

public:
  MY_UNKNOWN_IMP3(ICompressCoder2, ICompressSetCoderProperties, ICompressSetBufSize)

  STDMETHOD(Code)(ISequentialInStream * const *inStreams, const UInt64 * const *inSizes, UInt32 numInStreams,
      ISequentialOutStream * const *outStreams, const UInt64 * const *outSizes, UInt32 numOutStreams,
      ICompressProgressInfo *progress);

  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
  
  STDMETHOD(SetInBufSize)(UInt32 streamIndex, UInt32 size);
  STDMETHOD(SetOutBufSize)(UInt32 streamIndex, UInt32 size);
  
  CEncoder();
  ~CEncoder();
};

#endif

class CDecoder:
  public ICompressCoder2,
  public ICompressSetFinishMode,
  public ICompressSetInStream2,
  public ISequentialInStream,
  public ICompressSetOutStreamSize,
  public ICompressSetBufSize,
  public CMyUnknownImp,
  public CBaseCoder
{
  unsigned _extraReadSizes[BCJ2_NUM_STREAMS];
  UInt64 _inStreamsProcessed[BCJ2_NUM_STREAMS];
  HRESULT _readRes[BCJ2_NUM_STREAMS];
  CMyComPtr<ISequentialInStream> _inStreams[BCJ2_NUM_STREAMS];

  bool _finishMode;
  bool _outSizeDefined;
  UInt64 _outSize;
  UInt64 _outSize_Processed;
  CBcj2Dec dec;

  void InitCommon();
  // HRESULT ReadSpec();
  
public:
  MY_UNKNOWN_IMP6(
    ICompressCoder2,
    ICompressSetFinishMode,
    ICompressSetInStream2,
    ISequentialInStream,
    ICompressSetOutStreamSize,
    ICompressSetBufSize
    );
  
  STDMETHOD(Code)(ISequentialInStream * const *inStreams, const UInt64 * const *inSizes, UInt32 numInStreams,
      ISequentialOutStream * const *outStreams, const UInt64 * const *outSizes, UInt32 numOutStreams,
      ICompressProgressInfo *progress);

  STDMETHOD(SetFinishMode)(UInt32 finishMode);

  STDMETHOD(SetInStream2)(UInt32 streamIndex, ISequentialInStream *inStream);
  STDMETHOD(ReleaseInStream2)(UInt32 streamIndex);

  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);

  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);

  STDMETHOD(SetInBufSize)(UInt32 streamIndex, UInt32 size);
  STDMETHOD(SetOutBufSize)(UInt32 streamIndex, UInt32 size);

  CDecoder();
};

}}

#endif
// Bcj2Register.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "Bcj2Coder.h"

namespace NCompress {
namespace NBcj2 {

REGISTER_CODEC_CREATE_2(CreateCodec, CDecoder(), ICompressCoder2)
#ifndef EXTRACT_ONLY
REGISTER_CODEC_CREATE_2(CreateCodecOut, CEncoder(), ICompressCoder2)
#else
#define CreateCodecOut NULL
#endif

REGISTER_CODEC_VAR
  { CreateCodec, CreateCodecOut, 0x303011B, "BCJ2", 4, false };

REGISTER_CODEC(BCJ2)

}}
// BcjCoder.cpp

#include "StdAfx.h"

#include "BcjCoder.h"

namespace NCompress {
namespace NBcj {

STDMETHODIMP CCoder::Init()
{
  _bufferPos = 0;
  x86_Convert_Init(_prevMask);
  return S_OK;
}

STDMETHODIMP_(UInt32) CCoder::Filter(Byte *data, UInt32 size)
{
  UInt32 processed = (UInt32)::x86_Convert(data, size, _bufferPos, &_prevMask, _encode);
  _bufferPos += processed;
  return processed;
}

}}
// BcjCoder.h

#ifndef __COMPRESS_BCJ_CODER_H
#define __COMPRESS_BCJ_CODER_H

#include "../../../C/Bra.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

namespace NCompress {
namespace NBcj {

class CCoder:
  public ICompressFilter,
  public CMyUnknownImp
{
  UInt32 _bufferPos;
  UInt32 _prevMask;
  int _encode;
public:
  MY_UNKNOWN_IMP1(ICompressFilter);
  INTERFACE_ICompressFilter(;)

  CCoder(int encode): _bufferPos(0), _encode(encode) { x86_Convert_Init(_prevMask); }
};

}}

#endif
// BcjRegister.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "BcjCoder.h"

namespace NCompress {
namespace NBcj {

REGISTER_FILTER_E(BCJ,
    CCoder(false),
    CCoder(true),
    0x3030103, "BCJ")

}}
// BitlDecoder.cpp

#include "StdAfx.h"

#include "BitlDecoder.h"

namespace NBitl {

Byte kInvertTable[256];

struct CInverterTableInitializer
{
  CInverterTableInitializer()
  {
    for (unsigned i = 0; i < 256; i++)
    {
      unsigned x = ((i & 0x55) << 1) | ((i & 0xAA) >> 1);
      x = ((x & 0x33) << 2) | ((x & 0xCC) >> 2);
      kInvertTable[i] = (Byte)(((x & 0x0F) << 4) | ((x & 0xF0) >> 4));
    }
  }
} g_InverterTableInitializer;

}
// BitlDecoder.h -- the Least Significant Bit of byte is First

#ifndef __BITL_DECODER_H
#define __BITL_DECODER_H

#include "../IStream.h"

namespace NBitl {

const unsigned kNumBigValueBits = 8 * 4;
const unsigned kNumValueBytes = 3;
const unsigned kNumValueBits = 8 * kNumValueBytes;

const UInt32 kMask = (1 << kNumValueBits) - 1;

extern Byte kInvertTable[256];

/* TInByte must support "Extra Bytes" (bytes that can be read after the end of stream
   TInByte::ReadByte() returns 0xFF after the end of stream
   TInByte::NumExtraBytes contains the number "Extra Bytes"
       
   Bitl decoder can read up to 4 bytes ahead to internal buffer. */

template<class TInByte>
class CBaseDecoder
{
protected:
  unsigned _bitPos;
  UInt32 _value;
  TInByte _stream;
public:
  bool Create(UInt32 bufSize) { return _stream.Create(bufSize); }
  void SetStream(ISequentialInStream *inStream) { _stream.SetStream(inStream); }
  void Init()
  {
    _stream.Init();
    _bitPos = kNumBigValueBits;
    _value = 0;
  }

  UInt64 GetStreamSize() const { return _stream.GetStreamSize(); }
  UInt64 GetProcessedSize() const { return _stream.GetProcessedSize() - ((kNumBigValueBits - _bitPos) >> 3); }

  bool ThereAreDataInBitsBuffer() const { return this->_bitPos != kNumBigValueBits; }

  void Normalize()
  {
    for (; _bitPos >= 8; _bitPos -= 8)
      _value = ((UInt32)_stream.ReadByte() << (kNumBigValueBits - _bitPos)) | _value;
  }
  
  UInt32 ReadBits(unsigned numBits)
  {
    Normalize();
    UInt32 res = _value & ((1 << numBits) - 1);
    _bitPos += numBits;
    _value >>= numBits;
    return res;
  }

  bool ExtraBitsWereRead() const
  {
    return (_stream.NumExtraBytes > 4 || kNumBigValueBits - _bitPos < (_stream.NumExtraBytes << 3));
  }
  
  bool ExtraBitsWereRead_Fast() const
  {
    // full version is not inlined in vc6.
    // return _stream.NumExtraBytes != 0 && (_stream.NumExtraBytes > 4 || kNumBigValueBits - _bitPos < (_stream.NumExtraBytes << 3));
    
    // (_stream.NumExtraBytes > 4) is fast overread detection. It's possible that
    // it doesn't return true, if small number of extra bits were read.
    return (_stream.NumExtraBytes > 4);
  }

  // it must be fixed !!! with extra bits
  // UInt32 GetNumExtraBytes() const { return _stream.NumExtraBytes; }
};

template<class TInByte>
class CDecoder: public CBaseDecoder<TInByte>
{
  UInt32 _normalValue;

public:
  void Init()
  {
    CBaseDecoder<TInByte>::Init();
    _normalValue = 0;
  }

  void Normalize()
  {
    for (; this->_bitPos >= 8; this->_bitPos -= 8)
    {
      Byte b = this->_stream.ReadByte();
      _normalValue = ((UInt32)b << (kNumBigValueBits - this->_bitPos)) | _normalValue;
      this->_value = (this->_value << 8) | kInvertTable[b];
    }
  }
  
  UInt32 GetValue(unsigned numBits)
  {
    Normalize();
    return ((this->_value >> (8 - this->_bitPos)) & kMask) >> (kNumValueBits - numBits);
  }

  void MovePos(unsigned numBits)
  {
    this->_bitPos += numBits;
    _normalValue >>= numBits;
  }
  
  UInt32 ReadBits(unsigned numBits)
  {
    Normalize();
    UInt32 res = _normalValue & ((1 << numBits) - 1);
    MovePos(numBits);
    return res;
  }

  void AlignToByte() { MovePos((32 - this->_bitPos) & 7); }

  Byte ReadDirectByte() { return this->_stream.ReadByte(); }

  Byte ReadAlignedByte()
  {
    if (this->_bitPos == kNumBigValueBits)
      return this->_stream.ReadByte();
    Byte b = (Byte)(_normalValue & 0xFF);
    MovePos(8);
    return b;
  }
};

}

#endif
// BitlEncoder.h -- the Least Significant Bit of byte is First

#ifndef __BITL_ENCODER_H
#define __BITL_ENCODER_H

#include "../Common/OutBuffer.h"

class CBitlEncoder
{
  COutBuffer _stream;
  unsigned _bitPos;
  Byte _curByte;
public:
  bool Create(UInt32 bufSize) { return _stream.Create(bufSize); }
  void SetStream(ISequentialOutStream *outStream) { _stream.SetStream(outStream); }
  // unsigned GetBitPosition() const { return (8 - _bitPos); }
  UInt64 GetProcessedSize() const { return _stream.GetProcessedSize() + ((8 - _bitPos + 7) >> 3); }
  void Init()
  {
    _stream.Init();
    _bitPos = 8;
    _curByte = 0;
  }
  HRESULT Flush()
  {
    FlushByte();
    return _stream.Flush();
  }
  void FlushByte()
  {
    if (_bitPos < 8)
      _stream.WriteByte(_curByte);
    _bitPos = 8;
    _curByte = 0;
  }
  void WriteBits(UInt32 value, unsigned numBits)
  {
    while (numBits > 0)
    {
      if (numBits < _bitPos)
      {
        _curByte |= (value & ((1 << numBits) - 1)) << (8 - _bitPos);
        _bitPos -= numBits;
        return;
      }
      numBits -= _bitPos;
      _stream.WriteByte((Byte)(_curByte | (value << (8 - _bitPos))));
      value >>= _bitPos;
      _bitPos = 8;
      _curByte = 0;
    }
  }
  void WriteByte(Byte b) { _stream.WriteByte(b);}
};

#endif
// BitmDecoder.h -- the Most Significant Bit of byte is First

#ifndef __BITM_DECODER_H
#define __BITM_DECODER_H

#include "../IStream.h"

namespace NBitm {

const unsigned kNumBigValueBits = 8 * 4;
const unsigned kNumValueBytes = 3;
const unsigned kNumValueBits = 8 * kNumValueBytes;

const UInt32 kMask = (1 << kNumValueBits) - 1;

// _bitPos - the number of free bits (high bits in _value)
// (kNumBigValueBits - _bitPos) = (32 - _bitPos) == the number of ready to read bits (low bits of _value)

template<class TInByte>
class CDecoder
{
  unsigned _bitPos;
  UInt32 _value;
  TInByte _stream;
public:
  bool Create(UInt32 bufSize) { return _stream.Create(bufSize); }
  void SetStream(ISequentialInStream *inStream) { _stream.SetStream(inStream);}

  void Init()
  {
    _stream.Init();
    _bitPos = kNumBigValueBits;
    _value = 0;
    Normalize();
  }
  
  UInt64 GetStreamSize() const { return _stream.GetStreamSize(); }
  UInt64 GetProcessedSize() const { return _stream.GetProcessedSize() - ((kNumBigValueBits - _bitPos) >> 3); }

  bool ExtraBitsWereRead() const
  {
    return (_stream.NumExtraBytes > 4 || kNumBigValueBits - _bitPos < (_stream.NumExtraBytes << 3));
  }

  bool ExtraBitsWereRead_Fast() const
  {
    return (_stream.NumExtraBytes > 4);
  }

  void Normalize()
  {
    for (; _bitPos >= 8; _bitPos -= 8)
      _value = (_value << 8) | _stream.ReadByte();
  }

  UInt32 GetValue(unsigned numBits) const
  {
    // return (_value << _bitPos) >> (kNumBigValueBits - numBits);
    return ((_value >> (8 - _bitPos)) & kMask) >> (kNumValueBits - numBits);
  }
  
  void MovePos(unsigned numBits)
  {
    _bitPos += numBits;
    Normalize();
  }
  
  UInt32 ReadBits(unsigned numBits)
  {
    UInt32 res = GetValue(numBits);
    MovePos(numBits);
    return res;
  }

  /*
  unsigned ReadBit()
  {
    UInt32 res = ((_value >> (8 - _bitPos)) & kMask) >> (kNumValueBits - 1);
    if (++_bitPos >= 8)
    {
      _value = (_value << 8) | _stream.ReadByte();
      _bitPos -= 8;
    }
    return (unsigned)res;
  }
  */

  void AlignToByte() { MovePos((kNumBigValueBits - _bitPos) & 7); }

  UInt32 ReadAlignBits() { return ReadBits((kNumBigValueBits - _bitPos) & 7); }
};

}

#endif
// BitmEncoder.h -- the Most Significant Bit of byte is First

#ifndef __BITM_ENCODER_H
#define __BITM_ENCODER_H

#include "../IStream.h"

template<class TOutByte>
class CBitmEncoder
{
  unsigned _bitPos;
  Byte _curByte;
  TOutByte _stream;
public:
  bool Create(UInt32 bufferSize) { return _stream.Create(bufferSize); }
  void SetStream(ISequentialOutStream *outStream) { _stream.SetStream(outStream);}
  UInt64 GetProcessedSize() const { return _stream.GetProcessedSize() + ((8 - _bitPos + 7) >> 3); }
  void Init()
  {
    _stream.Init();
    _bitPos = 8;
    _curByte = 0;
  }
  HRESULT Flush()
  {
    if (_bitPos < 8)
      WriteBits(0, _bitPos);
    return _stream.Flush();
  }
  void WriteBits(UInt32 value, unsigned numBits)
  {
    while (numBits > 0)
    {
      if (numBits < _bitPos)
      {
        _curByte |= ((Byte)value << (_bitPos -= numBits));
        return;
      }
      numBits -= _bitPos;
      UInt32 newBits = (value >> numBits);
      value -= (newBits << numBits);
      _stream.WriteByte((Byte)(_curByte | newBits));
      _bitPos = 8;
      _curByte = 0;
    }
  }
};

#endif
// BranchMisc.cpp

#include "StdAfx.h"

#include "BranchMisc.h"

namespace NCompress {
namespace NBranch {

STDMETHODIMP CCoder::Init()
{
  _bufferPos = 0;
  return S_OK;
}

STDMETHODIMP_(UInt32) CCoder::Filter(Byte *data, UInt32 size)
{
  UInt32 processed = (UInt32)BraFunc(data, size, _bufferPos, _encode);
  _bufferPos += processed;
  return processed;
}

}}
// BranchMisc.h

#ifndef __COMPRESS_BRANCH_MISC_H
#define __COMPRESS_BRANCH_MISC_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"

EXTERN_C_BEGIN

typedef SizeT (*Func_Bra)(Byte *data, SizeT size, UInt32 ip, int encoding);

EXTERN_C_END

namespace NCompress {
namespace NBranch {

class CCoder:
  public ICompressFilter,
  public CMyUnknownImp
{
  UInt32 _bufferPos;
  int _encode;
  Func_Bra BraFunc;
public:
  MY_UNKNOWN_IMP1(ICompressFilter);
  INTERFACE_ICompressFilter(;)

  CCoder(Func_Bra bra, int encode):  _bufferPos(0), _encode(encode), BraFunc(bra) {}
};

}}

#endif
// BranchRegister.cpp

#include "StdAfx.h"

#include "../../../C/Bra.h"

#include "../Common/RegisterCodec.h"

#include "BranchMisc.h"

namespace NCompress {
namespace NBranch {

#define CREATE_BRA(n) \
    REGISTER_FILTER_CREATE(CreateBra_Decoder_ ## n, CCoder(n ## _Convert, false)) \
    REGISTER_FILTER_CREATE(CreateBra_Encoder_ ## n, CCoder(n ## _Convert, true)) \

CREATE_BRA(PPC)
CREATE_BRA(IA64)
CREATE_BRA(ARM)
CREATE_BRA(ARMT)
CREATE_BRA(SPARC)

#define METHOD_ITEM(n, id, name) \
    REGISTER_FILTER_ITEM( \
      CreateBra_Decoder_ ## n, \
      CreateBra_Encoder_ ## n, \
      0x3030000 + id, name)

REGISTER_CODECS_VAR
{
  METHOD_ITEM(PPC,   0x205, "PPC"),
  METHOD_ITEM(IA64,  0x401, "IA64"),
  METHOD_ITEM(ARM,   0x501, "ARM"),
  METHOD_ITEM(ARMT,  0x701, "ARMT"),
  METHOD_ITEM(SPARC, 0x805, "SPARC")
};

REGISTER_CODECS(Branch)

}}
// ByteSwap.cpp

#include "StdAfx.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "../Common/RegisterCodec.h"

namespace NCompress {
namespace NByteSwap {

class CByteSwap2:
  public ICompressFilter,
  public CMyUnknownImp
{
public:
  MY_UNKNOWN_IMP1(ICompressFilter);
  INTERFACE_ICompressFilter(;)
};

class CByteSwap4:
  public ICompressFilter,
  public CMyUnknownImp
{
public:
  MY_UNKNOWN_IMP1(ICompressFilter);
  INTERFACE_ICompressFilter(;)
};

STDMETHODIMP CByteSwap2::Init() { return S_OK; }

STDMETHODIMP_(UInt32) CByteSwap2::Filter(Byte *data, UInt32 size)
{
  const UInt32 kStep = 2;
  if (size < kStep)
    return 0;
  size &= ~(kStep - 1);
  
  const Byte *end = data + (size_t)size;
  
  do
  {
    Byte b0 = data[0];
    data[0] = data[1];
    data[1] = b0;
    data += kStep;
  }
  while (data != end);

  return size;
}

STDMETHODIMP CByteSwap4::Init() { return S_OK; }

STDMETHODIMP_(UInt32) CByteSwap4::Filter(Byte *data, UInt32 size)
{
  const UInt32 kStep = 4;
  if (size < kStep)
    return 0;
  size &= ~(kStep - 1);
  
  const Byte *end = data + (size_t)size;
  
  do
  {
    Byte b0 = data[0];
    Byte b1 = data[1];
    data[0] = data[3];
    data[1] = data[2];
    data[2] = b1;
    data[3] = b0;
    data += kStep;
  }
  while (data != end);

  return size;
}

REGISTER_FILTER_CREATE(CreateFilter2, CByteSwap2())
REGISTER_FILTER_CREATE(CreateFilter4, CByteSwap4())

REGISTER_CODECS_VAR
{
  REGISTER_FILTER_ITEM(CreateFilter2, CreateFilter2, 0x20302, "Swap2"),
  REGISTER_FILTER_ITEM(CreateFilter4, CreateFilter4, 0x20304, "Swap4")
};

REGISTER_CODECS(ByteSwap)

}}
// CodecExports.cpp

#include "StdAfx.h"

#include "../../../C/CpuArch.h"

#include "../../Common/ComTry.h"
#include "../../Common/MyCom.h"

#include "../../Windows/Defs.h"

#include "../ICoder.h"

#include "../Common/RegisterCodec.h"

extern unsigned g_NumCodecs;
extern const CCodecInfo *g_Codecs[];

extern unsigned g_NumHashers;
extern const CHasherInfo *g_Hashers[];

static void SetPropFromAscii(const char *s, PROPVARIANT *prop) throw()
{
  UINT len = (UINT)strlen(s);
  BSTR dest = ::SysAllocStringLen(NULL, len);
  if (dest)
  {
    for (UINT i = 0; i <= len; i++)
      dest[i] = (Byte)s[i];
    prop->bstrVal = dest;
    prop->vt = VT_BSTR;
  }
}

static inline HRESULT SetPropGUID(const GUID &guid, PROPVARIANT *value) throw()
{
  if ((value->bstrVal = ::SysAllocStringByteLen((const char *)&guid, sizeof(guid))) != NULL)
    value->vt = VT_BSTR;
  return S_OK;
}

static HRESULT MethodToClassID(UInt16 typeId, CMethodId id, PROPVARIANT *value) throw()
{
  GUID clsId;
  clsId.Data1 = k_7zip_GUID_Data1;
  clsId.Data2 = k_7zip_GUID_Data2;
  clsId.Data3 = typeId;
  SetUi64(clsId.Data4, id);
  return SetPropGUID(clsId, value);
}

static HRESULT FindCodecClassId(const GUID *clsid, bool isCoder2, bool isFilter, bool &encode, int &index) throw()
{
  index = -1;
  if (clsid->Data1 != k_7zip_GUID_Data1 ||
      clsid->Data2 != k_7zip_GUID_Data2)
    return S_OK;
  
  encode = true;
  
       if (clsid->Data3 == k_7zip_GUID_Data3_Decoder) encode = false;
  else if (clsid->Data3 != k_7zip_GUID_Data3_Encoder) return S_OK;
  
  UInt64 id = GetUi64(clsid->Data4);
  
  for (unsigned i = 0; i < g_NumCodecs; i++)
  {
    const CCodecInfo &codec = *g_Codecs[i];
    
    if (id != codec.Id
        || (encode ? !codec.CreateEncoder : !codec.CreateDecoder)
        || (isFilter ? !codec.IsFilter : codec.IsFilter))
      continue;

    if (codec.NumStreams == 1 ? isCoder2 : !isCoder2)
      return E_NOINTERFACE;
    
    index = i;
    return S_OK;
  }
  
  return S_OK;
}

static HRESULT CreateCoderMain(unsigned index, bool encode, void **coder)
{
  COM_TRY_BEGIN
  
  const CCodecInfo &codec = *g_Codecs[index];
  
  void *c;
  if (encode)
    c = codec.CreateEncoder();
  else
    c = codec.CreateDecoder();
  
  if (c)
  {
    IUnknown *unk;
    if (codec.IsFilter)
      unk = (IUnknown *)(ICompressFilter *)c;
    else if (codec.NumStreams != 1)
      unk = (IUnknown *)(ICompressCoder2 *)c;
    else
      unk = (IUnknown *)(ICompressCoder *)c;
    unk->AddRef();
    *coder = c;
  }
  return S_OK;
  
  COM_TRY_END
}

static HRESULT CreateCoder2(bool encode, UInt32 index, const GUID *iid, void **outObject)
{
  *outObject = NULL;

  const CCodecInfo &codec = *g_Codecs[index];

  if (encode ? !codec.CreateEncoder : !codec.CreateDecoder)
    return CLASS_E_CLASSNOTAVAILABLE;

  if (codec.IsFilter)
  {
    if (*iid != IID_ICompressFilter) return E_NOINTERFACE;
  }
  else if (codec.NumStreams != 1)
  {
    if (*iid != IID_ICompressCoder2) return E_NOINTERFACE;
  }
  else
  {
    if (*iid != IID_ICompressCoder) return E_NOINTERFACE;
  }
  
  return CreateCoderMain(index, encode, outObject);
}

STDAPI CreateDecoder(UInt32 index, const GUID *iid, void **outObject)
{
  return CreateCoder2(false, index, iid, outObject);
}

STDAPI CreateEncoder(UInt32 index, const GUID *iid, void **outObject)
{
  return CreateCoder2(true, index, iid, outObject);
}

STDAPI CreateCoder(const GUID *clsid, const GUID *iid, void **outObject)
{
  *outObject = NULL;

  bool isFilter = false;
  bool isCoder2 = false;
  bool isCoder = (*iid == IID_ICompressCoder) != 0;
  if (!isCoder)
  {
    isFilter = (*iid == IID_ICompressFilter) != 0;
    if (!isFilter)
    {
      isCoder2 = (*iid == IID_ICompressCoder2) != 0;
      if (!isCoder2)
        return E_NOINTERFACE;
    }
  }
  
  bool encode;
  int codecIndex;
  HRESULT res = FindCodecClassId(clsid, isCoder2, isFilter, encode, codecIndex);
  if (res != S_OK)
    return res;
  if (codecIndex < 0)
    return CLASS_E_CLASSNOTAVAILABLE;

  return CreateCoderMain(codecIndex, encode, outObject);
}
 
STDAPI GetMethodProperty(UInt32 codecIndex, PROPID propID, PROPVARIANT *value)
{
  ::VariantClear((VARIANTARG *)value);
  const CCodecInfo &codec = *g_Codecs[codecIndex];
  switch (propID)
  {
    case NMethodPropID::kID:
      value->uhVal.QuadPart = (UInt64)codec.Id;
      value->vt = VT_UI8;
      break;
    case NMethodPropID::kName:
      SetPropFromAscii(codec.Name, value);
      break;
    case NMethodPropID::kDecoder:
      if (codec.CreateDecoder)
        return MethodToClassID(k_7zip_GUID_Data3_Decoder, codec.Id, value);
      break;
    case NMethodPropID::kEncoder:
      if (codec.CreateEncoder)
        return MethodToClassID(k_7zip_GUID_Data3_Encoder, codec.Id, value);
      break;
    case NMethodPropID::kDecoderIsAssigned:
        value->vt = VT_BOOL;
        value->boolVal = BoolToVARIANT_BOOL(codec.CreateDecoder != NULL);
      break;
    case NMethodPropID::kEncoderIsAssigned:
        value->vt = VT_BOOL;
        value->boolVal = BoolToVARIANT_BOOL(codec.CreateEncoder != NULL);
      break;
    case NMethodPropID::kPackStreams:
      if (codec.NumStreams != 1)
      {
        value->vt = VT_UI4;
        value->ulVal = (ULONG)codec.NumStreams;
      }
      break;
    /*
    case NMethodPropID::kIsFilter:
      // if (codec.IsFilter)
      {
        value->vt = VT_BOOL;
        value->boolVal = BoolToVARIANT_BOOL(codec.IsFilter);
      }
      break;
    */
    /*
    case NMethodPropID::kDecoderFlags:
      {
        value->vt = VT_UI4;
        value->ulVal = (ULONG)codec.DecoderFlags;
      }
      break;
    case NMethodPropID::kEncoderFlags:
      {
        value->vt = VT_UI4;
        value->ulVal = (ULONG)codec.EncoderFlags;
      }
      break;
    */
  }
  return S_OK;
}

STDAPI GetNumberOfMethods(UINT32 *numCodecs)
{
  *numCodecs = g_NumCodecs;
  return S_OK;
}


// ---------- Hashers ----------

static int FindHasherClassId(const GUID *clsid) throw()
{
  if (clsid->Data1 != k_7zip_GUID_Data1 ||
      clsid->Data2 != k_7zip_GUID_Data2 ||
      clsid->Data3 != k_7zip_GUID_Data3_Hasher)
    return -1;
  UInt64 id = GetUi64(clsid->Data4);
  for (unsigned i = 0; i < g_NumCodecs; i++)
    if (id == g_Hashers[i]->Id)
      return i;
  return -1;
}

static HRESULT CreateHasher2(UInt32 index, IHasher **hasher)
{
  COM_TRY_BEGIN
  *hasher = g_Hashers[index]->CreateHasher();
  if (*hasher)
    (*hasher)->AddRef();
  return S_OK;
  COM_TRY_END
}

STDAPI CreateHasher(const GUID *clsid, IHasher **outObject)
{
  COM_TRY_BEGIN
  *outObject = 0;
  int index = FindHasherClassId(clsid);
  if (index < 0)
    return CLASS_E_CLASSNOTAVAILABLE;
  return CreateHasher2(index, outObject);
  COM_TRY_END
}

STDAPI GetHasherProp(UInt32 codecIndex, PROPID propID, PROPVARIANT *value)
{
  ::VariantClear((VARIANTARG *)value);
  const CHasherInfo &codec = *g_Hashers[codecIndex];
  switch (propID)
  {
    case NMethodPropID::kID:
      value->uhVal.QuadPart = (UInt64)codec.Id;
      value->vt = VT_UI8;
      break;
    case NMethodPropID::kName:
      SetPropFromAscii(codec.Name, value);
      break;
    case NMethodPropID::kEncoder:
      if (codec.CreateHasher)
        return MethodToClassID(k_7zip_GUID_Data3_Hasher, codec.Id, value);
      break;
    case NMethodPropID::kDigestSize:
      value->ulVal = (ULONG)codec.DigestSize;
      value->vt = VT_UI4;
      break;
  }
  return S_OK;
}

class CHashers:
  public IHashers,
  public CMyUnknownImp
{
public:
  MY_UNKNOWN_IMP1(IHashers)

  STDMETHOD_(UInt32, GetNumHashers)();
  STDMETHOD(GetHasherProp)(UInt32 index, PROPID propID, PROPVARIANT *value);
  STDMETHOD(CreateHasher)(UInt32 index, IHasher **hasher);
};

STDAPI GetHashers(IHashers **hashers)
{
  COM_TRY_BEGIN
  *hashers = new CHashers;
  if (*hashers)
    (*hashers)->AddRef();
  return S_OK;
  COM_TRY_END
}

STDMETHODIMP_(UInt32) CHashers::GetNumHashers()
{
  return g_NumHashers;
}

STDMETHODIMP CHashers::GetHasherProp(UInt32 index, PROPID propID, PROPVARIANT *value)
{
  return ::GetHasherProp(index, propID, value);
}

STDMETHODIMP CHashers::CreateHasher(UInt32 index, IHasher **hasher)
{
  return ::CreateHasher2(index, hasher);
}
// Compress/CopyCoder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "CopyCoder.h"

namespace NCompress {

static const UInt32 kBufSize = 1 << 17;

CCopyCoder::~CCopyCoder()
{
  ::MidFree(_buf);
}

STDMETHODIMP CCopyCoder::Code(ISequentialInStream *inStream,
    ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize,
    ICompressProgressInfo *progress)
{
  if (!_buf)
  {
    _buf = (Byte *)::MidAlloc(kBufSize);
    if (!_buf)
      return E_OUTOFMEMORY;
  }

  TotalSize = 0;
  
  for (;;)
  {
    UInt32 size = kBufSize;
    if (outSize && size > *outSize - TotalSize)
      size = (UInt32)(*outSize - TotalSize);
    if (size == 0)
      return S_OK;
    
    HRESULT readRes = inStream->Read(_buf, size, &size);

    if (size == 0)
      return readRes;

    if (outStream)
    {
      UInt32 pos = 0;
      do
      {
        UInt32 curSize = size - pos;
        HRESULT res = outStream->Write(_buf + pos, curSize, &curSize);
        pos += curSize;
        TotalSize += curSize;
        RINOK(res);
        if (curSize == 0)
          return E_FAIL;
      }
      while (pos < size);
    }
    else
      TotalSize += size;

    RINOK(readRes);

    if (progress)
    {
      RINOK(progress->SetRatioInfo(&TotalSize, &TotalSize));
    }
  }
}

STDMETHODIMP CCopyCoder::SetInStream(ISequentialInStream *inStream)
{
  _inStream = inStream;
  TotalSize = 0;
  return S_OK;
}

STDMETHODIMP CCopyCoder::ReleaseInStream()
{
  _inStream.Release();
  return S_OK;
}

STDMETHODIMP CCopyCoder::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  UInt32 realProcessedSize = 0;
  HRESULT res = _inStream->Read(data, size, &realProcessedSize);
  TotalSize += realProcessedSize;
  if (processedSize)
    *processedSize = realProcessedSize;
  return res;
}

STDMETHODIMP CCopyCoder::GetInStreamProcessedSize(UInt64 *value)
{
  *value = TotalSize;
  return S_OK;
}

HRESULT CopyStream(ISequentialInStream *inStream, ISequentialOutStream *outStream, ICompressProgressInfo *progress)
{
  CMyComPtr<ICompressCoder> copyCoder = new CCopyCoder;
  return copyCoder->Code(inStream, outStream, NULL, NULL, progress);
}

HRESULT CopyStream_ExactSize(ISequentialInStream *inStream, ISequentialOutStream *outStream, UInt64 size, ICompressProgressInfo *progress)
{
  NCompress::CCopyCoder *copyCoderSpec = new NCompress::CCopyCoder;
  CMyComPtr<ICompressCoder> copyCoder = copyCoderSpec;
  RINOK(copyCoder->Code(inStream, outStream, NULL, &size, progress));
  return copyCoderSpec->TotalSize == size ? S_OK : E_FAIL;
}

}
// Compress/CopyCoder.h

#ifndef __COMPRESS_COPY_CODER_H
#define __COMPRESS_COPY_CODER_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"

namespace NCompress {

class CCopyCoder:
  public ICompressCoder,
  public ICompressSetInStream,
  public ISequentialInStream,
  public ICompressGetInStreamProcessedSize,
  public CMyUnknownImp
{
  Byte *_buf;
  CMyComPtr<ISequentialInStream> _inStream;
public:
  UInt64 TotalSize;
  
  CCopyCoder(): _buf(0), TotalSize(0) {};
  ~CCopyCoder();

  MY_UNKNOWN_IMP4(
      ICompressCoder,
      ICompressSetInStream,
      ISequentialInStream,
      ICompressGetInStreamProcessedSize)

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
  STDMETHOD(ReleaseInStream)();
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  STDMETHOD(GetInStreamProcessedSize)(UInt64 *value);
};

HRESULT CopyStream(ISequentialInStream *inStream, ISequentialOutStream *outStream, ICompressProgressInfo *progress);
HRESULT CopyStream_ExactSize(ISequentialInStream *inStream, ISequentialOutStream *outStream, UInt64 size, ICompressProgressInfo *progress);

}

#endif
// CopyRegister.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "CopyCoder.h"

namespace NCompress {

REGISTER_CODEC_CREATE(CreateCodec, CCopyCoder())

REGISTER_CODEC_2(Copy, CreateCodec, CreateCodec, 0, "Copy")

}
// Deflate64Register.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "DeflateDecoder.h"

#if !defined(EXTRACT_ONLY) && !defined(DEFLATE_EXTRACT_ONLY)
#include "DeflateEncoder.h"
#endif

namespace NCompress {
namespace NDeflate {

REGISTER_CODEC_CREATE(CreateDec, NDecoder::CCOMCoder64())

#if !defined(EXTRACT_ONLY) && !defined(DEFLATE_EXTRACT_ONLY)
REGISTER_CODEC_CREATE(CreateEnc, NEncoder::CCOMCoder64())
#else
#define CreateEnc NULL
#endif

REGISTER_CODEC_2(Deflate64, CreateDec, CreateEnc, 0x40109, "Deflate64")

}}
// DeflateConst.h

#ifndef __DEFLATE_CONST_H
#define __DEFLATE_CONST_H

namespace NCompress {
namespace NDeflate {

const unsigned kNumHuffmanBits = 15;

const UInt32 kHistorySize32 = (1 << 15);
const UInt32 kHistorySize64 = (1 << 16);

const unsigned kDistTableSize32 = 30;
const unsigned kDistTableSize64 = 32;
  
const unsigned kNumLenSymbols32 = 256;
const unsigned kNumLenSymbols64 = 255; // don't change it. It must be <= 255.
const unsigned kNumLenSymbolsMax = kNumLenSymbols32;
  
const unsigned kNumLenSlots = 29;

const unsigned kFixedDistTableSize = 32;
const unsigned kFixedLenTableSize = 31;

const unsigned kSymbolEndOfBlock = 0x100;
const unsigned kSymbolMatch = kSymbolEndOfBlock + 1;

const unsigned kMainTableSize = kSymbolMatch + kNumLenSlots;
const unsigned kFixedMainTableSize = kSymbolMatch + kFixedLenTableSize;

const unsigned kLevelTableSize = 19;

const unsigned kTableDirectLevels = 16;
const unsigned kTableLevelRepNumber = kTableDirectLevels;
const unsigned kTableLevel0Number = kTableLevelRepNumber + 1;
const unsigned kTableLevel0Number2 = kTableLevel0Number + 1;

const unsigned kLevelMask = 0xF;

const Byte kLenStart32[kFixedLenTableSize] =
  {0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224, 255, 0, 0};
const Byte kLenStart64[kFixedLenTableSize] =
  {0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224, 0, 0, 0};

const Byte kLenDirectBits32[kFixedLenTableSize] =
  {0,0,0,0,0,0,0,0,1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5, 0, 0, 0};
const Byte kLenDirectBits64[kFixedLenTableSize] =
  {0,0,0,0,0,0,0,0,1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5, 16, 0, 0};

const UInt32 kDistStart[kDistTableSize64] =
  {0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,
  1024,1536,2048,3072,4096,6144,8192,12288,16384,24576,32768,49152};
const Byte kDistDirectBits[kDistTableSize64] =
  {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14};

const Byte kLevelDirectBits[3] = {2, 3, 7};

const Byte kCodeLengthAlphabetOrder[kLevelTableSize] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

const unsigned kMatchMinLen = 3;
const unsigned kMatchMaxLen32 = kNumLenSymbols32 + kMatchMinLen - 1; // 256 + 2
const unsigned kMatchMaxLen64 = kNumLenSymbols64 + kMatchMinLen - 1; // 255 + 2
const unsigned kMatchMaxLen = kMatchMaxLen32;

const unsigned kFinalBlockFieldSize = 1;

namespace NFinalBlockField
{
  enum
  {
    kNotFinalBlock = 0,
    kFinalBlock = 1
  };
}

const unsigned kBlockTypeFieldSize = 2;

namespace NBlockType
{
  enum
  {
    kStored = 0,
    kFixedHuffman = 1,
    kDynamicHuffman = 2
  };
}

const unsigned kNumLenCodesFieldSize = 5;
const unsigned kNumDistCodesFieldSize = 5;
const unsigned kNumLevelCodesFieldSize = 4;

const unsigned kNumLitLenCodesMin = 257;
const unsigned kNumDistCodesMin = 1;
const unsigned kNumLevelCodesMin = 4;

const unsigned kLevelFieldSize = 3;

const unsigned kStoredBlockLengthFieldSize = 16;

struct CLevels
{
  Byte litLenLevels[kFixedMainTableSize];
  Byte distLevels[kFixedDistTableSize];

  void SubClear()
  {
    unsigned i;
    for (i = kNumLitLenCodesMin; i < kFixedMainTableSize; i++)
      litLenLevels[i] = 0;
    for (i = 0; i < kFixedDistTableSize; i++)
      distLevels[i] = 0;
  }

  void SetFixedLevels()
  {
    unsigned i = 0;
    
    for (; i < 144; i++) litLenLevels[i] = 8;
    for (; i < 256; i++) litLenLevels[i] = 9;
    for (; i < 280; i++) litLenLevels[i] = 7;
    for (; i < 288; i++) litLenLevels[i] = 8;
    
    for (i = 0; i < kFixedDistTableSize; i++)  // test it: InfoZip only uses kDistTableSize
      distLevels[i] = 5;
  }
};

}}

#endif
// DeflateDecoder.cpp

#include "StdAfx.h"

#include "DeflateDecoder.h"

namespace NCompress {
namespace NDeflate {
namespace NDecoder {

CCoder::CCoder(bool deflate64Mode, bool deflateNSIS):
    _deflate64Mode(deflate64Mode),
    _deflateNSIS(deflateNSIS),
    _keepHistory(false),
    _needFinishInput(false),
    _needInitInStream(true),
    ZlibMode(false) {}

UInt32 CCoder::ReadBits(unsigned numBits)
{
  return m_InBitStream.ReadBits(numBits);
}

Byte CCoder::ReadAlignedByte()
{
  return m_InBitStream.ReadAlignedByte();
}

bool CCoder::DecodeLevels(Byte *levels, unsigned numSymbols)
{
  unsigned i = 0;
  
  do
  {
    UInt32 sym = m_LevelDecoder.Decode(&m_InBitStream);
    if (sym < kTableDirectLevels)
      levels[i++] = (Byte)sym;
    else
    {
      if (sym >= kLevelTableSize)
        return false;
      
      unsigned num;
      unsigned numBits;
      Byte symbol;
      
      if (sym == kTableLevelRepNumber)
      {
        if (i == 0)
          return false;
        numBits = 2;
        num = 0;
        symbol = levels[i - 1];
      }
      else
      {
        sym -= kTableLevel0Number;
        sym <<= 2;
        numBits = 3 + (unsigned)sym;
        num = ((unsigned)sym << 1);
        symbol = 0;
      }
      
      num += i + 3 + ReadBits(numBits);
      if (num > numSymbols)
        return false;
      do
        levels[i++] = symbol;
      while (i < num);
    }
  }
  while (i < numSymbols);
  
  return true;
}

#define RIF(x) { if (!(x)) return false; }

bool CCoder::ReadTables(void)
{
  m_FinalBlock = (ReadBits(kFinalBlockFieldSize) == NFinalBlockField::kFinalBlock);
  if (m_InBitStream.ExtraBitsWereRead())
    return false;
  UInt32 blockType = ReadBits(kBlockTypeFieldSize);
  if (blockType > NBlockType::kDynamicHuffman)
    return false;
  if (m_InBitStream.ExtraBitsWereRead())
    return false;

  if (blockType == NBlockType::kStored)
  {
    m_StoredMode = true;
    m_InBitStream.AlignToByte();
    m_StoredBlockSize = ReadAligned_UInt16(); // ReadBits(kStoredBlockLengthFieldSize)
    if (_deflateNSIS)
      return true;
    return (m_StoredBlockSize == (UInt16)~ReadAligned_UInt16());
  }

  m_StoredMode = false;

  CLevels levels;
  if (blockType == NBlockType::kFixedHuffman)
  {
    levels.SetFixedLevels();
    _numDistLevels = _deflate64Mode ? kDistTableSize64 : kDistTableSize32;
  }
  else
  {
    unsigned numLitLenLevels = ReadBits(kNumLenCodesFieldSize) + kNumLitLenCodesMin;
    _numDistLevels = ReadBits(kNumDistCodesFieldSize) + kNumDistCodesMin;
    unsigned numLevelCodes = ReadBits(kNumLevelCodesFieldSize) + kNumLevelCodesMin;

    if (!_deflate64Mode)
      if (_numDistLevels > kDistTableSize32)
        return false;
    
    Byte levelLevels[kLevelTableSize];
    for (unsigned i = 0; i < kLevelTableSize; i++)
    {
      unsigned position = kCodeLengthAlphabetOrder[i];
      if (i < numLevelCodes)
        levelLevels[position] = (Byte)ReadBits(kLevelFieldSize);
      else
        levelLevels[position] = 0;
    }
    
    if (m_InBitStream.ExtraBitsWereRead())
      return false;

    RIF(m_LevelDecoder.Build(levelLevels));
    
    Byte tmpLevels[kFixedMainTableSize + kFixedDistTableSize];
    if (!DecodeLevels(tmpLevels, numLitLenLevels + _numDistLevels))
      return false;
    
    if (m_InBitStream.ExtraBitsWereRead())
      return false;

    levels.SubClear();
    memcpy(levels.litLenLevels, tmpLevels, numLitLenLevels);
    memcpy(levels.distLevels, tmpLevels + numLitLenLevels, _numDistLevels);
  }
  RIF(m_MainDecoder.Build(levels.litLenLevels));
  return m_DistDecoder.Build(levels.distLevels);
}

HRESULT CCoder::CodeSpec(UInt32 curSize, bool finishInputStream)
{
  if (_remainLen == kLenIdFinished)
    return S_OK;
  if (_remainLen == kLenIdNeedInit)
  {
    if (!_keepHistory)
      if (!m_OutWindowStream.Create(_deflate64Mode ? kHistorySize64: kHistorySize32))
        return E_OUTOFMEMORY;
    RINOK(InitInStream(_needInitInStream));
    m_OutWindowStream.Init(_keepHistory);
    m_FinalBlock = false;
    _remainLen = 0;
    _needReadTable = true;
  }

  while (_remainLen > 0 && curSize > 0)
  {
    _remainLen--;
    Byte b = m_OutWindowStream.GetByte(_rep0);
    m_OutWindowStream.PutByte(b);
    curSize--;
  }

  while (curSize > 0 || finishInputStream)
  {
    if (m_InBitStream.ExtraBitsWereRead())
      return S_FALSE;

    if (_needReadTable)
    {
      if (m_FinalBlock)
      {
        _remainLen = kLenIdFinished;
        break;
      }
      if (!ReadTables())
        return S_FALSE;
      if (m_InBitStream.ExtraBitsWereRead())
        return S_FALSE;
      _needReadTable = false;
    }

    if (m_StoredMode)
    {
      if (finishInputStream && curSize == 0 && m_StoredBlockSize != 0)
        return S_FALSE;
      /* NSIS version contains some bits in bitl bits buffer.
         So we must read some first bytes via ReadAlignedByte */
      for (; m_StoredBlockSize > 0 && curSize > 0 && m_InBitStream.ThereAreDataInBitsBuffer(); m_StoredBlockSize--, curSize--)
        m_OutWindowStream.PutByte(ReadAlignedByte());
      for (; m_StoredBlockSize > 0 && curSize > 0; m_StoredBlockSize--, curSize--)
        m_OutWindowStream.PutByte(m_InBitStream.ReadDirectByte());
      _needReadTable = (m_StoredBlockSize == 0);
      continue;
    }
    
    while (curSize > 0)
    {
      if (m_InBitStream.ExtraBitsWereRead_Fast())
        return S_FALSE;

      UInt32 sym = m_MainDecoder.Decode(&m_InBitStream);

      if (sym < 0x100)
      {
        m_OutWindowStream.PutByte((Byte)sym);
        curSize--;
        continue;
      }
      else if (sym == kSymbolEndOfBlock)
      {
        _needReadTable = true;
        break;
      }
      else if (sym < kMainTableSize)
      {
        sym -= kSymbolMatch;
        UInt32 len;
        {
          unsigned numBits;
          if (_deflate64Mode)
          {
            len = kLenStart64[sym];
            numBits = kLenDirectBits64[sym];
          }
          else
          {
            len = kLenStart32[sym];
            numBits = kLenDirectBits32[sym];
          }
          len += kMatchMinLen + m_InBitStream.ReadBits(numBits);
        }
        UInt32 locLen = len;
        if (locLen > curSize)
          locLen = (UInt32)curSize;
        sym = m_DistDecoder.Decode(&m_InBitStream);
        if (sym >= _numDistLevels)
          return S_FALSE;
        UInt32 distance = kDistStart[sym] + m_InBitStream.ReadBits(kDistDirectBits[sym]);
        if (!m_OutWindowStream.CopyBlock(distance, locLen))
          return S_FALSE;
        curSize -= locLen;
        len -= locLen;
        if (len != 0)
        {
          _remainLen = (Int32)len;
          _rep0 = distance;
          break;
        }
      }
      else
        return S_FALSE;
    }
    
    if (finishInputStream && curSize == 0)
    {
      if (m_MainDecoder.Decode(&m_InBitStream) != kSymbolEndOfBlock)
        return S_FALSE;
      _needReadTable = true;
    }
  }

  if (m_InBitStream.ExtraBitsWereRead())
    return S_FALSE;

  return S_OK;
}


#ifdef _NO_EXCEPTIONS

#define DEFLATE_TRY_BEGIN
#define DEFLATE_TRY_END(res)

#else

#define DEFLATE_TRY_BEGIN try {
#define DEFLATE_TRY_END(res) } \
  catch(const CInBufferException &e)  { res = e.ErrorCode; } \
  catch(const CLzOutWindowException &e)  { res = e.ErrorCode; } \
  catch(...) { res = S_FALSE; }

#endif


HRESULT CCoder::CodeReal(ISequentialOutStream *outStream,
      const UInt64 *outSize, ICompressProgressInfo *progress)
{
  HRESULT res;
  DEFLATE_TRY_BEGIN
  m_OutWindowStream.SetStream(outStream);
  CCoderReleaser flusher(this);

  const UInt64 inStart = _needInitInStream ? 0 : m_InBitStream.GetProcessedSize();
  const UInt64 start = m_OutWindowStream.GetProcessedSize();

  for (;;)
  {
    UInt32 curSize = 1 << 18;
    bool finishInputStream = false;
    if (outSize)
    {
      const UInt64 rem = *outSize - (m_OutWindowStream.GetProcessedSize() - start);
      if (curSize >= rem)
      {
        curSize = (UInt32)rem;
        if (ZlibMode || _needFinishInput)
          finishInputStream = true;
      }
    }
    if (!finishInputStream && curSize == 0)
      break;
    RINOK(CodeSpec(curSize, finishInputStream));
    if (_remainLen == kLenIdFinished)
      break;
    if (progress)
    {
      const UInt64 inSize = m_InBitStream.GetProcessedSize() - inStart;
      const UInt64 nowPos64 = m_OutWindowStream.GetProcessedSize() - start;
      RINOK(progress->SetRatioInfo(&inSize, &nowPos64));
    }
  }
  
  if (_remainLen == kLenIdFinished && ZlibMode)
  {
    m_InBitStream.AlignToByte();
    for (unsigned i = 0; i < 4; i++)
      ZlibFooter[i] = ReadAlignedByte();
  }
  
  flusher.NeedFlush = false;
  res = Flush();
  if (res == S_OK && _remainLen != kLenIdNeedInit && InputEofError())
    return S_FALSE;
  DEFLATE_TRY_END(res)
  return res;
}

HRESULT CCoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  SetInStream(inStream);
  SetOutStreamSize(outSize);
  HRESULT res = CodeReal(outStream, outSize, progress);
  ReleaseInStream();
  return res;
}

STDMETHODIMP CCoder::GetInStreamProcessedSize(UInt64 *value)
{
  if (!value)
    return E_INVALIDARG;
  *value = m_InBitStream.GetProcessedSize();
  return S_OK;
}

STDMETHODIMP CCoder::SetInStream(ISequentialInStream *inStream)
{
  m_InStreamRef = inStream;
  m_InBitStream.SetStream(inStream);
  return S_OK;
}

STDMETHODIMP CCoder::ReleaseInStream()
{
  m_InStreamRef.Release();
  return S_OK;
}

STDMETHODIMP CCoder::SetOutStreamSize(const UInt64 * /* outSize */)
{
  _remainLen = kLenIdNeedInit;
  _needInitInStream = true;
  m_OutWindowStream.Init(_keepHistory);
  return S_OK;
}

#ifndef NO_READ_FROM_CODER

STDMETHODIMP CCoder::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  HRESULT res;
  DEFLATE_TRY_BEGIN
  if (processedSize)
    *processedSize = 0;
  const UInt64 startPos = m_OutWindowStream.GetProcessedSize();
  m_OutWindowStream.SetMemStream((Byte *)data);
  res = CodeSpec(size, false);
  if (res == S_OK)
  {
    res = Flush();
    if (processedSize)
      *processedSize = (UInt32)(m_OutWindowStream.GetProcessedSize() - startPos);
  }
  DEFLATE_TRY_END(res)
  m_OutWindowStream.SetMemStream(NULL);
  return res;
}

#endif

STDMETHODIMP CCoder::CodeResume(ISequentialOutStream *outStream, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  _remainLen = kLenIdNeedInit;
  m_OutWindowStream.Init(_keepHistory);
  return CodeReal(outStream, outSize, progress);
}

}}}
// DeflateDecoder.h

#ifndef __DEFLATE_DECODER_H
#define __DEFLATE_DECODER_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "../Common/InBuffer.h"

#include "BitlDecoder.h"
#include "DeflateConst.h"
#include "HuffmanDecoder.h"
#include "LzOutWindow.h"

namespace NCompress {
namespace NDeflate {
namespace NDecoder {

const int kLenIdFinished = -1;
const int kLenIdNeedInit = -2;

class CCoder:
  public ICompressCoder,
  public ICompressGetInStreamProcessedSize,
  #ifndef NO_READ_FROM_CODER
  public ICompressSetInStream,
  public ICompressSetOutStreamSize,
  public ISequentialInStream,
  #endif
  public CMyUnknownImp
{
  CLzOutWindow m_OutWindowStream;
  CMyComPtr<ISequentialInStream> m_InStreamRef;
  NBitl::CDecoder<CInBuffer> m_InBitStream;
  NCompress::NHuffman::CDecoder<kNumHuffmanBits, kFixedMainTableSize> m_MainDecoder;
  NCompress::NHuffman::CDecoder<kNumHuffmanBits, kFixedDistTableSize> m_DistDecoder;
  NCompress::NHuffman::CDecoder7b<kLevelTableSize> m_LevelDecoder;

  UInt32 m_StoredBlockSize;

  UInt32 _numDistLevels;
  bool m_FinalBlock;
  bool m_StoredMode;

  bool _deflateNSIS;
  bool _deflate64Mode;
  bool _keepHistory;
  bool _needFinishInput;
  
  bool _needInitInStream;
  bool _needReadTable;
  Int32 _remainLen;
  UInt32 _rep0;

  UInt32 ReadBits(unsigned numBits);

  bool DecodeLevels(Byte *levels, unsigned numSymbols);
  bool ReadTables();
  
  HRESULT Flush() { return m_OutWindowStream.Flush(); }
  class CCoderReleaser
  {
    CCoder *_coder;
  public:
    bool NeedFlush;
    CCoderReleaser(CCoder *coder): _coder(coder), NeedFlush(true) {}
    ~CCoderReleaser()
    {
      if (NeedFlush)
        _coder->Flush();
    }
  };
  friend class CCoderReleaser;

  HRESULT CodeSpec(UInt32 curSize, bool finishInputStream);
public:
  bool ZlibMode;
  Byte ZlibFooter[4];

  CCoder(bool deflate64Mode, bool deflateNSIS = false);
  virtual ~CCoder() {};

  void Set_KeepHistory(bool keepHistory) { _keepHistory = keepHistory; }
  void Set_NeedFinishInput(bool needFinishInput) { _needFinishInput = needFinishInput; }

  bool IsFinished() const { return _remainLen == kLenIdFinished;; }
  bool IsFinalBlock() const { return m_FinalBlock; }

  HRESULT CodeReal(ISequentialOutStream *outStream,
      const UInt64 *outSize, ICompressProgressInfo *progress);

  #ifndef NO_READ_FROM_CODER
  MY_UNKNOWN_IMP5(
      ICompressCoder,
      ICompressGetInStreamProcessedSize,
      ICompressSetInStream,
      ICompressSetOutStreamSize,
      ISequentialInStream
      )
  #else
  MY_UNKNOWN_IMP2(
      ICompressCoder,
      ICompressGetInStreamProcessedSize)
  #endif

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
  STDMETHOD(ReleaseInStream)();
  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);
  
  #ifndef NO_READ_FROM_CODER
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  #endif

  STDMETHOD(CodeResume)(ISequentialOutStream *outStream, const UInt64 *outSize, ICompressProgressInfo *progress);

  HRESULT InitInStream(bool needInit)
  {
    if (!m_InBitStream.Create(1 << 17))
      return E_OUTOFMEMORY;
    if (needInit)
    {
      m_InBitStream.Init();
      _needInitInStream = false;
    }
    return S_OK;
  }

  void AlignToByte() { m_InBitStream.AlignToByte(); }
  Byte ReadAlignedByte();
  UInt32 ReadAligned_UInt16() // aligned for Byte range
  {
    UInt32 v = m_InBitStream.ReadAlignedByte();
    return v | ((UInt32)m_InBitStream.ReadAlignedByte() << 8);
  }
  bool InputEofError() const { return m_InBitStream.ExtraBitsWereRead(); }

  UInt64 GetStreamSize() const { return m_InBitStream.GetStreamSize(); }
  UInt64 GetInputProcessedSize() const { return m_InBitStream.GetProcessedSize(); }

  // IGetInStreamProcessedSize
  STDMETHOD(GetInStreamProcessedSize)(UInt64 *value);
};

class CCOMCoder     : public CCoder { public: CCOMCoder(): CCoder(false) {} };
class CNsisCOMCoder : public CCoder { public: CNsisCOMCoder(): CCoder(false, true) {} };
class CCOMCoder64   : public CCoder { public: CCOMCoder64(): CCoder(true) {} };

}}}

#endif
// DeflateEncoder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"
#include "../../../C/HuffEnc.h"

#include "../../Common/ComTry.h"

#include "DeflateEncoder.h"

#undef NO_INLINE

#ifdef _MSC_VER
#define NO_INLINE MY_NO_INLINE
#else
#define NO_INLINE
#endif

namespace NCompress {
namespace NDeflate {
namespace NEncoder {

static const unsigned kNumDivPassesMax = 10; // [0, 16); ratio/speed/ram tradeoff; use big value for better compression ratio.
static const UInt32 kNumTables = (1 << kNumDivPassesMax);

static const UInt32 kFixedHuffmanCodeBlockSizeMax = (1 << 8); // [0, (1 << 32)); ratio/speed tradeoff; use big value for better compression ratio.
static const UInt32 kDivideCodeBlockSizeMin = (1 << 7); // [1, (1 << 32)); ratio/speed tradeoff; use small value for better compression ratio.
static const UInt32 kDivideBlockSizeMin = (1 << 6); // [1, (1 << 32)); ratio/speed tradeoff; use small value for better compression ratio.

static const UInt32 kMaxUncompressedBlockSize = ((1 << 16) - 1) * 1; // [1, (1 << 32))
static const UInt32 kMatchArraySize = kMaxUncompressedBlockSize * 10; // [kMatchMaxLen * 2, (1 << 32))
static const UInt32 kMatchArrayLimit = kMatchArraySize - kMatchMaxLen * 4 * sizeof(UInt16);
static const UInt32 kBlockUncompressedSizeThreshold = kMaxUncompressedBlockSize -
    kMatchMaxLen - kNumOpts;

static const unsigned kMaxCodeBitLength = 11;
static const unsigned kMaxLevelBitLength = 7;

static const Byte kNoLiteralStatPrice = 11;
static const Byte kNoLenStatPrice = 11;
static const Byte kNoPosStatPrice = 6;

static Byte g_LenSlots[kNumLenSymbolsMax];
static Byte g_FastPos[1 << 9];

class CFastPosInit
{
public:
  CFastPosInit()
  {
    unsigned i;
    for (i = 0; i < kNumLenSlots; i++)
    {
      unsigned c = kLenStart32[i];
      unsigned j = 1 << kLenDirectBits32[i];
      for (unsigned k = 0; k < j; k++, c++)
        g_LenSlots[c] = (Byte)i;
    }
    
    const unsigned kFastSlots = 18;
    unsigned c = 0;
    for (Byte slotFast = 0; slotFast < kFastSlots; slotFast++)
    {
      UInt32 k = (1 << kDistDirectBits[slotFast]);
      for (UInt32 j = 0; j < k; j++, c++)
        g_FastPos[c] = slotFast;
    }
  }
};

static CFastPosInit g_FastPosInit;


inline UInt32 GetPosSlot(UInt32 pos)
{
  if (pos < 0x200)
    return g_FastPos[pos];
  return g_FastPos[pos >> 8] + 16;
}

void CEncProps::Normalize()
{
  int level = Level;
  if (level < 0) level = 5;
  Level = level;
  if (algo < 0) algo = (level < 5 ? 0 : 1);
  if (fb < 0) fb = (level < 7 ? 32 : (level < 9 ? 64 : 128));
  if (btMode < 0) btMode = (algo == 0 ? 0 : 1);
  if (mc == 0) mc = (16 + (fb >> 1));
  if (numPasses == (UInt32)(Int32)-1) numPasses = (level < 7 ? 1 : (level < 9 ? 3 : 10));
}

void CCoder::SetProps(const CEncProps *props2)
{
  CEncProps props = *props2;
  props.Normalize();

  m_MatchFinderCycles = props.mc;
  {
    unsigned fb = props.fb;
    if (fb < kMatchMinLen)
      fb = kMatchMinLen;
    if (fb > m_MatchMaxLen)
      fb = m_MatchMaxLen;
    m_NumFastBytes = fb;
  }
  _fastMode = (props.algo == 0);
  _btMode = (props.btMode != 0);

  m_NumDivPasses = props.numPasses;
  if (m_NumDivPasses == 0)
    m_NumDivPasses = 1;
  if (m_NumDivPasses == 1)
    m_NumPasses = 1;
  else if (m_NumDivPasses <= kNumDivPassesMax)
    m_NumPasses = 2;
  else
  {
    m_NumPasses = 2 + (m_NumDivPasses - kNumDivPassesMax);
    m_NumDivPasses = kNumDivPassesMax;
  }
}

CCoder::CCoder(bool deflate64Mode):
  m_Deflate64Mode(deflate64Mode),
  m_OnePosMatchesMemory(0),
  m_DistanceMemory(0),
  m_Created(false),
  m_Values(0),
  m_Tables(0)
{
  m_MatchMaxLen = deflate64Mode ? kMatchMaxLen64 : kMatchMaxLen32;
  m_NumLenCombinations = deflate64Mode ? kNumLenSymbols64 : kNumLenSymbols32;
  m_LenStart = deflate64Mode ? kLenStart64 : kLenStart32;
  m_LenDirectBits = deflate64Mode ? kLenDirectBits64 : kLenDirectBits32;
  {
    CEncProps props;
    SetProps(&props);
  }
  MatchFinder_Construct(&_lzInWindow);
}

HRESULT CCoder::Create()
{
  // COM_TRY_BEGIN
  if (m_Values == 0)
  {
    m_Values = (CCodeValue *)MyAlloc((kMaxUncompressedBlockSize) * sizeof(CCodeValue));
    if (m_Values == 0)
      return E_OUTOFMEMORY;
  }
  if (m_Tables == 0)
  {
    m_Tables = (CTables *)MyAlloc((kNumTables) * sizeof(CTables));
    if (m_Tables == 0)
      return E_OUTOFMEMORY;
  }

  if (m_IsMultiPass)
  {
    if (m_OnePosMatchesMemory == 0)
    {
      m_OnePosMatchesMemory = (UInt16 *)::MidAlloc(kMatchArraySize * sizeof(UInt16));
      if (m_OnePosMatchesMemory == 0)
        return E_OUTOFMEMORY;
    }
  }
  else
  {
    if (m_DistanceMemory == 0)
    {
      m_DistanceMemory = (UInt16 *)MyAlloc((kMatchMaxLen + 2) * 2 * sizeof(UInt16));
      if (m_DistanceMemory == 0)
        return E_OUTOFMEMORY;
      m_MatchDistances = m_DistanceMemory;
    }
  }

  if (!m_Created)
  {
    _lzInWindow.btMode = (Byte)(_btMode ? 1 : 0);
    _lzInWindow.numHashBytes = 3;
    if (!MatchFinder_Create(&_lzInWindow,
        m_Deflate64Mode ? kHistorySize64 : kHistorySize32,
        kNumOpts + kMaxUncompressedBlockSize,
        m_NumFastBytes, m_MatchMaxLen - m_NumFastBytes, &g_Alloc))
      return E_OUTOFMEMORY;
    if (!m_OutStream.Create(1 << 20))
      return E_OUTOFMEMORY;
  }
  if (m_MatchFinderCycles != 0)
    _lzInWindow.cutValue = m_MatchFinderCycles;
  m_Created = true;
  return S_OK;
  // COM_TRY_END
}

HRESULT CCoder::BaseSetEncoderProperties2(const PROPID *propIDs, const PROPVARIANT *coderProps, UInt32 numProps)
{
  CEncProps props;
  for (UInt32 i = 0; i < numProps; i++)
  {
    const PROPVARIANT &prop = coderProps[i];
    PROPID propID = propIDs[i];
    if (propID >= NCoderPropID::kReduceSize)
      continue;
    if (prop.vt != VT_UI4)
      return E_INVALIDARG;
    UInt32 v = (UInt32)prop.ulVal;
    switch (propID)
    {
      case NCoderPropID::kNumPasses: props.numPasses = v; break;
      case NCoderPropID::kNumFastBytes: props.fb = v; break;
      case NCoderPropID::kMatchFinderCycles: props.mc = v; break;
      case NCoderPropID::kAlgorithm: props.algo = v; break;
      case NCoderPropID::kLevel: props.Level = v; break;
      case NCoderPropID::kNumThreads: break;
      default: return E_INVALIDARG;
    }
  }
  SetProps(&props);
  return S_OK;
}
  
void CCoder::Free()
{
  ::MidFree(m_OnePosMatchesMemory); m_OnePosMatchesMemory = 0;
  ::MyFree(m_DistanceMemory); m_DistanceMemory = 0;
  ::MyFree(m_Values); m_Values = 0;
  ::MyFree(m_Tables); m_Tables = 0;
}

CCoder::~CCoder()
{
  Free();
  MatchFinder_Free(&_lzInWindow, &g_Alloc);
}

NO_INLINE void CCoder::GetMatches()
{
  if (m_IsMultiPass)
  {
    m_MatchDistances = m_OnePosMatchesMemory + m_Pos;
    if (m_SecondPass)
    {
      m_Pos += *m_MatchDistances + 1;
      return;
    }
  }

  UInt32 distanceTmp[kMatchMaxLen * 2 + 3];
  
  UInt32 numPairs = (_btMode) ?
      Bt3Zip_MatchFinder_GetMatches(&_lzInWindow, distanceTmp):
      Hc3Zip_MatchFinder_GetMatches(&_lzInWindow, distanceTmp);

  *m_MatchDistances = (UInt16)numPairs;
   
  if (numPairs > 0)
  {
    UInt32 i;
    for (i = 0; i < numPairs; i += 2)
    {
      m_MatchDistances[i + 1] = (UInt16)distanceTmp[i];
      m_MatchDistances[i + 2] = (UInt16)distanceTmp[i + 1];
    }
    UInt32 len = distanceTmp[numPairs - 2];
    if (len == m_NumFastBytes && m_NumFastBytes != m_MatchMaxLen)
    {
      UInt32 numAvail = Inline_MatchFinder_GetNumAvailableBytes(&_lzInWindow) + 1;
      const Byte *pby = Inline_MatchFinder_GetPointerToCurrentPos(&_lzInWindow) - 1;
      const Byte *pby2 = pby - (distanceTmp[numPairs - 1] + 1);
      if (numAvail > m_MatchMaxLen)
        numAvail = m_MatchMaxLen;
      for (; len < numAvail && pby[len] == pby2[len]; len++);
      m_MatchDistances[i - 1] = (UInt16)len;
    }
  }
  if (m_IsMultiPass)
    m_Pos += numPairs + 1;
  if (!m_SecondPass)
    m_AdditionalOffset++;
}

void CCoder::MovePos(UInt32 num)
{
  if (!m_SecondPass && num > 0)
  {
    if (_btMode)
      Bt3Zip_MatchFinder_Skip(&_lzInWindow, num);
    else
      Hc3Zip_MatchFinder_Skip(&_lzInWindow, num);
    m_AdditionalOffset += num;
  }
}

static const UInt32 kIfinityPrice = 0xFFFFFFF;

NO_INLINE UInt32 CCoder::Backward(UInt32 &backRes, UInt32 cur)
{
  m_OptimumEndIndex = cur;
  UInt32 posMem = m_Optimum[cur].PosPrev;
  UInt16 backMem = m_Optimum[cur].BackPrev;
  do
  {
    UInt32 posPrev = posMem;
    UInt16 backCur = backMem;
    backMem = m_Optimum[posPrev].BackPrev;
    posMem = m_Optimum[posPrev].PosPrev;
    m_Optimum[posPrev].BackPrev = backCur;
    m_Optimum[posPrev].PosPrev = (UInt16)cur;
    cur = posPrev;
  }
  while (cur > 0);
  backRes = m_Optimum[0].BackPrev;
  m_OptimumCurrentIndex = m_Optimum[0].PosPrev;
  return m_OptimumCurrentIndex;
}

NO_INLINE UInt32 CCoder::GetOptimal(UInt32 &backRes)
{
  if (m_OptimumEndIndex != m_OptimumCurrentIndex)
  {
    UInt32 len = m_Optimum[m_OptimumCurrentIndex].PosPrev - m_OptimumCurrentIndex;
    backRes = m_Optimum[m_OptimumCurrentIndex].BackPrev;
    m_OptimumCurrentIndex = m_Optimum[m_OptimumCurrentIndex].PosPrev;
    return len;
  }
  m_OptimumCurrentIndex = m_OptimumEndIndex = 0;
  
  GetMatches();

  UInt32 lenEnd;
  {
    const UInt32 numDistancePairs = m_MatchDistances[0];
    if (numDistancePairs == 0)
      return 1;
    const UInt16 *matchDistances = m_MatchDistances + 1;
    lenEnd = matchDistances[numDistancePairs - 2];
    
    if (lenEnd > m_NumFastBytes)
    {
      backRes = matchDistances[numDistancePairs - 1];
      MovePos(lenEnd - 1);
      return lenEnd;
    }

    m_Optimum[1].Price = m_LiteralPrices[*(Inline_MatchFinder_GetPointerToCurrentPos(&_lzInWindow) - m_AdditionalOffset)];
    m_Optimum[1].PosPrev = 0;
    
    m_Optimum[2].Price = kIfinityPrice;
    m_Optimum[2].PosPrev = 1;
    
    UInt32 offs = 0;
  
    for (UInt32 i = kMatchMinLen; i <= lenEnd; i++)
    {
      UInt32 distance = matchDistances[offs + 1];
      m_Optimum[i].PosPrev = 0;
      m_Optimum[i].BackPrev = (UInt16)distance;
      m_Optimum[i].Price = m_LenPrices[i - kMatchMinLen] + m_PosPrices[GetPosSlot(distance)];
      if (i == matchDistances[offs])
        offs += 2;
    }
  }

  UInt32 cur = 0;

  for (;;)
  {
    ++cur;
    if (cur == lenEnd || cur == kNumOptsBase || m_Pos >= kMatchArrayLimit)
      return Backward(backRes, cur);
    GetMatches();
    const UInt16 *matchDistances = m_MatchDistances + 1;
    const UInt32 numDistancePairs = m_MatchDistances[0];
    UInt32 newLen = 0;
    if (numDistancePairs != 0)
    {
      newLen = matchDistances[numDistancePairs - 2];
      if (newLen > m_NumFastBytes)
      {
        UInt32 len = Backward(backRes, cur);
        m_Optimum[cur].BackPrev = matchDistances[numDistancePairs - 1];
        m_OptimumEndIndex = cur + newLen;
        m_Optimum[cur].PosPrev = (UInt16)m_OptimumEndIndex;
        MovePos(newLen - 1);
        return len;
      }
    }
    UInt32 curPrice = m_Optimum[cur].Price;
    {
      const UInt32 curAnd1Price = curPrice + m_LiteralPrices[*(Inline_MatchFinder_GetPointerToCurrentPos(&_lzInWindow) + cur - m_AdditionalOffset)];
      COptimal &optimum = m_Optimum[cur + 1];
      if (curAnd1Price < optimum.Price)
      {
        optimum.Price = curAnd1Price;
        optimum.PosPrev = (UInt16)cur;
      }
    }
    if (numDistancePairs == 0)
      continue;
    while (lenEnd < cur + newLen)
      m_Optimum[++lenEnd].Price = kIfinityPrice;
    UInt32 offs = 0;
    UInt32 distance = matchDistances[offs + 1];
    curPrice += m_PosPrices[GetPosSlot(distance)];
    for (UInt32 lenTest = kMatchMinLen; ; lenTest++)
    {
      UInt32 curAndLenPrice = curPrice + m_LenPrices[lenTest - kMatchMinLen];
      COptimal &optimum = m_Optimum[cur + lenTest];
      if (curAndLenPrice < optimum.Price)
      {
        optimum.Price = curAndLenPrice;
        optimum.PosPrev = (UInt16)cur;
        optimum.BackPrev = (UInt16)distance;
      }
      if (lenTest == matchDistances[offs])
      {
        offs += 2;
        if (offs == numDistancePairs)
          break;
        curPrice -= m_PosPrices[GetPosSlot(distance)];
        distance = matchDistances[offs + 1];
        curPrice += m_PosPrices[GetPosSlot(distance)];
      }
    }
  }
}

UInt32 CCoder::GetOptimalFast(UInt32 &backRes)
{
  GetMatches();
  UInt32 numDistancePairs = m_MatchDistances[0];
  if (numDistancePairs == 0)
    return 1;
  UInt32 lenMain = m_MatchDistances[numDistancePairs - 1];
  backRes = m_MatchDistances[numDistancePairs];
  MovePos(lenMain - 1);
  return lenMain;
}

void CTables::InitStructures()
{
  UInt32 i;
  for (i = 0; i < 256; i++)
    litLenLevels[i] = 8;
  litLenLevels[i++] = 13;
  for (;i < kFixedMainTableSize; i++)
    litLenLevels[i] = 5;
  for (i = 0; i < kFixedDistTableSize; i++)
    distLevels[i] = 5;
}

NO_INLINE void CCoder::LevelTableDummy(const Byte *levels, unsigned numLevels, UInt32 *freqs)
{
  unsigned prevLen = 0xFF;
  unsigned nextLen = levels[0];
  unsigned count = 0;
  unsigned maxCount = 7;
  unsigned minCount = 4;
  
  if (nextLen == 0)
  {
    maxCount = 138;
    minCount = 3;
  }
  
  for (unsigned n = 0; n < numLevels; n++)
  {
    unsigned curLen = nextLen;
    nextLen = (n < numLevels - 1) ? levels[n + 1] : 0xFF;
    count++;
    if (count < maxCount && curLen == nextLen)
      continue;
    
    if (count < minCount)
      freqs[curLen] += (UInt32)count;
    else if (curLen != 0)
    {
      if (curLen != prevLen)
      {
        freqs[curLen]++;
        count--;
      }
      freqs[kTableLevelRepNumber]++;
    }
    else if (count <= 10)
      freqs[kTableLevel0Number]++;
    else
      freqs[kTableLevel0Number2]++;

    count = 0;
    prevLen = curLen;
    
    if (nextLen == 0)
    {
      maxCount = 138;
      minCount = 3;
    }
    else if (curLen == nextLen)
    {
      maxCount = 6;
      minCount = 3;
    }
    else
    {
      maxCount = 7;
      minCount = 4;
    }
  }
}

NO_INLINE void CCoder::WriteBits(UInt32 value, unsigned numBits)
{
  m_OutStream.WriteBits(value, numBits);
}

#define WRITE_HF2(codes, lens, i) m_OutStream.WriteBits(codes[i], lens[i])
#define WRITE_HF(i) WriteBits(codes[i], lens[i])

NO_INLINE void CCoder::LevelTableCode(const Byte *levels, unsigned numLevels, const Byte *lens, const UInt32 *codes)
{
  unsigned prevLen = 0xFF;
  unsigned nextLen = levels[0];
  unsigned count = 0;
  unsigned maxCount = 7;
  unsigned minCount = 4;
  
  if (nextLen == 0)
  {
    maxCount = 138;
    minCount = 3;
  }
  
  for (unsigned n = 0; n < numLevels; n++)
  {
    unsigned curLen = nextLen;
    nextLen = (n < numLevels - 1) ? levels[n + 1] : 0xFF;
    count++;
    if (count < maxCount && curLen == nextLen)
      continue;
    
    if (count < minCount)
      for (unsigned i = 0; i < count; i++)
        WRITE_HF(curLen);
    else if (curLen != 0)
    {
      if (curLen != prevLen)
      {
        WRITE_HF(curLen);
        count--;
      }
      WRITE_HF(kTableLevelRepNumber);
      WriteBits(count - 3, 2);
    }
    else if (count <= 10)
    {
      WRITE_HF(kTableLevel0Number);
      WriteBits(count - 3, 3);
    }
    else
    {
      WRITE_HF(kTableLevel0Number2);
      WriteBits(count - 11, 7);
    }

    count = 0;
    prevLen = curLen;
    
    if (nextLen == 0)
    {
      maxCount = 138;
      minCount = 3;
    }
    else if (curLen == nextLen)
    {
      maxCount = 6;
      minCount = 3;
    }
    else
    {
      maxCount = 7;
      minCount = 4;
    }
  }
}

NO_INLINE void CCoder::MakeTables(unsigned maxHuffLen)
{
  Huffman_Generate(mainFreqs, mainCodes, m_NewLevels.litLenLevels, kFixedMainTableSize, maxHuffLen);
  Huffman_Generate(distFreqs, distCodes, m_NewLevels.distLevels, kDistTableSize64, maxHuffLen);
}

NO_INLINE UInt32 Huffman_GetPrice(const UInt32 *freqs, const Byte *lens, UInt32 num)
{
  UInt32 price = 0;
  UInt32 i;
  for (i = 0; i < num; i++)
    price += lens[i] * freqs[i];
  return price;
}

NO_INLINE UInt32 Huffman_GetPrice_Spec(const UInt32 *freqs, const Byte *lens, UInt32 num, const Byte *extraBits, UInt32 extraBase)
{
  return Huffman_GetPrice(freqs, lens, num) +
    Huffman_GetPrice(freqs + extraBase, extraBits, num - extraBase);
}

NO_INLINE UInt32 CCoder::GetLzBlockPrice() const
{
  return
    Huffman_GetPrice_Spec(mainFreqs, m_NewLevels.litLenLevels, kFixedMainTableSize, m_LenDirectBits, kSymbolMatch) +
    Huffman_GetPrice_Spec(distFreqs, m_NewLevels.distLevels, kDistTableSize64, kDistDirectBits, 0);
}

NO_INLINE void CCoder::TryBlock()
{
  memset(mainFreqs, 0, sizeof(mainFreqs));
  memset(distFreqs, 0, sizeof(distFreqs));

  m_ValueIndex = 0;
  UInt32 blockSize = BlockSizeRes;
  BlockSizeRes = 0;
  for (;;)
  {
    if (m_OptimumCurrentIndex == m_OptimumEndIndex)
    {
      if (m_Pos >= kMatchArrayLimit || BlockSizeRes >= blockSize || !m_SecondPass &&
          ((Inline_MatchFinder_GetNumAvailableBytes(&_lzInWindow) == 0) || m_ValueIndex >= m_ValueBlockSize))
        break;
    }
    UInt32 pos;
    UInt32 len;
    if (_fastMode)
      len = GetOptimalFast(pos);
    else
      len = GetOptimal(pos);
    CCodeValue &codeValue = m_Values[m_ValueIndex++];
    if (len >= kMatchMinLen)
    {
      UInt32 newLen = len - kMatchMinLen;
      codeValue.Len = (UInt16)newLen;
      mainFreqs[kSymbolMatch + g_LenSlots[newLen]]++;
      codeValue.Pos = (UInt16)pos;
      distFreqs[GetPosSlot(pos)]++;
    }
    else
    {
      Byte b = *(Inline_MatchFinder_GetPointerToCurrentPos(&_lzInWindow) - m_AdditionalOffset);
      mainFreqs[b]++;
      codeValue.SetAsLiteral();
      codeValue.Pos = b;
    }
    m_AdditionalOffset -= len;
    BlockSizeRes += len;
  }
  mainFreqs[kSymbolEndOfBlock]++;
  m_AdditionalOffset += BlockSizeRes;
  m_SecondPass = true;
}

NO_INLINE void CCoder::SetPrices(const CLevels &levels)
{
  if (_fastMode)
    return;
  UInt32 i;
  for (i = 0; i < 256; i++)
  {
    Byte price = levels.litLenLevels[i];
    m_LiteralPrices[i] = ((price != 0) ? price : kNoLiteralStatPrice);
  }
  
  for (i = 0; i < m_NumLenCombinations; i++)
  {
    UInt32 slot = g_LenSlots[i];
    Byte price = levels.litLenLevels[kSymbolMatch + slot];
    m_LenPrices[i] = (Byte)(((price != 0) ? price : kNoLenStatPrice) + m_LenDirectBits[slot]);
  }
  
  for (i = 0; i < kDistTableSize64; i++)
  {
    Byte price = levels.distLevels[i];
    m_PosPrices[i] = (Byte)(((price != 0) ? price: kNoPosStatPrice) + kDistDirectBits[i]);
  }
}

NO_INLINE void Huffman_ReverseBits(UInt32 *codes, const Byte *lens, UInt32 num)
{
  for (UInt32 i = 0; i < num; i++)
  {
    UInt32 x = codes[i];
    x = ((x & 0x5555) << 1) | ((x & 0xAAAA) >> 1);
    x = ((x & 0x3333) << 2) | ((x & 0xCCCC) >> 2);
    x = ((x & 0x0F0F) << 4) | ((x & 0xF0F0) >> 4);
    codes[i] = (((x & 0x00FF) << 8) | ((x & 0xFF00) >> 8)) >> (16 - lens[i]);
  }
}

NO_INLINE void CCoder::WriteBlock()
{
  Huffman_ReverseBits(mainCodes, m_NewLevels.litLenLevels, kFixedMainTableSize);
  Huffman_ReverseBits(distCodes, m_NewLevels.distLevels, kDistTableSize64);

  for (UInt32 i = 0; i < m_ValueIndex; i++)
  {
    const CCodeValue &codeValue = m_Values[i];
    if (codeValue.IsLiteral())
      WRITE_HF2(mainCodes, m_NewLevels.litLenLevels, codeValue.Pos);
    else
    {
      UInt32 len = codeValue.Len;
      UInt32 lenSlot = g_LenSlots[len];
      WRITE_HF2(mainCodes, m_NewLevels.litLenLevels, kSymbolMatch + lenSlot);
      m_OutStream.WriteBits(len - m_LenStart[lenSlot], m_LenDirectBits[lenSlot]);
      UInt32 dist = codeValue.Pos;
      UInt32 posSlot = GetPosSlot(dist);
      WRITE_HF2(distCodes, m_NewLevels.distLevels, posSlot);
      m_OutStream.WriteBits(dist - kDistStart[posSlot], kDistDirectBits[posSlot]);
    }
  }
  WRITE_HF2(mainCodes, m_NewLevels.litLenLevels, kSymbolEndOfBlock);
}

static UInt32 GetStorePrice(UInt32 blockSize, unsigned bitPosition)
{
  UInt32 price = 0;
  do
  {
    UInt32 nextBitPosition = (bitPosition + kFinalBlockFieldSize + kBlockTypeFieldSize) & 7;
    unsigned numBitsForAlign = nextBitPosition > 0 ? (8 - nextBitPosition): 0;
    UInt32 curBlockSize = (blockSize < (1 << 16)) ? blockSize : (1 << 16) - 1;
    price += kFinalBlockFieldSize + kBlockTypeFieldSize + numBitsForAlign + (2 + 2) * 8 + curBlockSize * 8;
    bitPosition = 0;
    blockSize -= curBlockSize;
  }
  while (blockSize != 0);
  return price;
}

void CCoder::WriteStoreBlock(UInt32 blockSize, UInt32 additionalOffset, bool finalBlock)
{
  do
  {
    UInt32 curBlockSize = (blockSize < (1 << 16)) ? blockSize : (1 << 16) - 1;
    blockSize -= curBlockSize;
    WriteBits((finalBlock && (blockSize == 0) ? NFinalBlockField::kFinalBlock: NFinalBlockField::kNotFinalBlock), kFinalBlockFieldSize);
    WriteBits(NBlockType::kStored, kBlockTypeFieldSize);
    m_OutStream.FlushByte();
    WriteBits((UInt16)curBlockSize, kStoredBlockLengthFieldSize);
    WriteBits((UInt16)~curBlockSize, kStoredBlockLengthFieldSize);
    const Byte *data = Inline_MatchFinder_GetPointerToCurrentPos(&_lzInWindow)- additionalOffset;
    for (UInt32 i = 0; i < curBlockSize; i++)
      m_OutStream.WriteByte(data[i]);
    additionalOffset -= curBlockSize;
  }
  while (blockSize != 0);
}

NO_INLINE UInt32 CCoder::TryDynBlock(unsigned tableIndex, UInt32 numPasses)
{
  CTables &t = m_Tables[tableIndex];
  BlockSizeRes = t.BlockSizeRes;
  UInt32 posTemp = t.m_Pos;
  SetPrices(t);

  for (UInt32 p = 0; p < numPasses; p++)
  {
    m_Pos = posTemp;
    TryBlock();
    unsigned numHuffBits =
        (m_ValueIndex > 18000 ? 12 :
        (m_ValueIndex >  7000 ? 11 :
        (m_ValueIndex >  2000 ? 10 : 9)));
    MakeTables(numHuffBits);
    SetPrices(m_NewLevels);
  }

  (CLevels &)t = m_NewLevels;

  m_NumLitLenLevels = kMainTableSize;
  while (m_NumLitLenLevels > kNumLitLenCodesMin && m_NewLevels.litLenLevels[m_NumLitLenLevels - 1] == 0)
    m_NumLitLenLevels--;
  
  m_NumDistLevels = kDistTableSize64;
  while (m_NumDistLevels > kNumDistCodesMin && m_NewLevels.distLevels[m_NumDistLevels - 1] == 0)
    m_NumDistLevels--;
  
  UInt32 levelFreqs[kLevelTableSize];
  memset(levelFreqs, 0, sizeof(levelFreqs));

  LevelTableDummy(m_NewLevels.litLenLevels, m_NumLitLenLevels, levelFreqs);
  LevelTableDummy(m_NewLevels.distLevels, m_NumDistLevels, levelFreqs);
  
  Huffman_Generate(levelFreqs, levelCodes, levelLens, kLevelTableSize, kMaxLevelBitLength);
  
  m_NumLevelCodes = kNumLevelCodesMin;
  for (UInt32 i = 0; i < kLevelTableSize; i++)
  {
    Byte level = levelLens[kCodeLengthAlphabetOrder[i]];
    if (level > 0 && i >= m_NumLevelCodes)
      m_NumLevelCodes = i + 1;
    m_LevelLevels[i] = level;
  }
  
  return GetLzBlockPrice() +
      Huffman_GetPrice_Spec(levelFreqs, levelLens, kLevelTableSize, kLevelDirectBits, kTableDirectLevels) +
      kNumLenCodesFieldSize + kNumDistCodesFieldSize + kNumLevelCodesFieldSize +
      m_NumLevelCodes * kLevelFieldSize + kFinalBlockFieldSize + kBlockTypeFieldSize;
}

NO_INLINE UInt32 CCoder::TryFixedBlock(unsigned tableIndex)
{
  CTables &t = m_Tables[tableIndex];
  BlockSizeRes = t.BlockSizeRes;
  m_Pos = t.m_Pos;
  m_NewLevels.SetFixedLevels();
  SetPrices(m_NewLevels);
  TryBlock();
  return kFinalBlockFieldSize + kBlockTypeFieldSize + GetLzBlockPrice();
}

NO_INLINE UInt32 CCoder::GetBlockPrice(unsigned tableIndex, unsigned numDivPasses)
{
  CTables &t = m_Tables[tableIndex];
  t.StaticMode = false;
  UInt32 price = TryDynBlock(tableIndex, m_NumPasses);
  t.BlockSizeRes = BlockSizeRes;
  UInt32 numValues = m_ValueIndex;
  UInt32 posTemp = m_Pos;
  UInt32 additionalOffsetEnd = m_AdditionalOffset;
  
  if (m_CheckStatic && m_ValueIndex <= kFixedHuffmanCodeBlockSizeMax)
  {
    const UInt32 fixedPrice = TryFixedBlock(tableIndex);
    t.StaticMode = (fixedPrice < price);
    if (t.StaticMode)
      price = fixedPrice;
  }

  const UInt32 storePrice = GetStorePrice(BlockSizeRes, 0); // bitPosition
  t.StoreMode = (storePrice <= price);
  if (t.StoreMode)
    price = storePrice;

  t.UseSubBlocks = false;

  if (numDivPasses > 1 && numValues >= kDivideCodeBlockSizeMin)
  {
    CTables &t0 = m_Tables[(tableIndex << 1)];
    (CLevels &)t0 = t;
    t0.BlockSizeRes = t.BlockSizeRes >> 1;
    t0.m_Pos = t.m_Pos;
    UInt32 subPrice = GetBlockPrice((tableIndex << 1), numDivPasses - 1);

    UInt32 blockSize2 = t.BlockSizeRes - t0.BlockSizeRes;
    if (t0.BlockSizeRes >= kDivideBlockSizeMin && blockSize2 >= kDivideBlockSizeMin)
    {
      CTables &t1 = m_Tables[(tableIndex << 1) + 1];
      (CLevels &)t1 = t;
      t1.BlockSizeRes = blockSize2;
      t1.m_Pos = m_Pos;
      m_AdditionalOffset -= t0.BlockSizeRes;
      subPrice += GetBlockPrice((tableIndex << 1) + 1, numDivPasses - 1);
      t.UseSubBlocks = (subPrice < price);
      if (t.UseSubBlocks)
        price = subPrice;
    }
  }
  
  m_AdditionalOffset = additionalOffsetEnd;
  m_Pos = posTemp;
  return price;
}

void CCoder::CodeBlock(unsigned tableIndex, bool finalBlock)
{
  CTables &t = m_Tables[tableIndex];
  if (t.UseSubBlocks)
  {
    CodeBlock((tableIndex << 1), false);
    CodeBlock((tableIndex << 1) + 1, finalBlock);
  }
  else
  {
    if (t.StoreMode)
      WriteStoreBlock(t.BlockSizeRes, m_AdditionalOffset, finalBlock);
    else
    {
      WriteBits((finalBlock ? NFinalBlockField::kFinalBlock: NFinalBlockField::kNotFinalBlock), kFinalBlockFieldSize);
      if (t.StaticMode)
      {
        WriteBits(NBlockType::kFixedHuffman, kBlockTypeFieldSize);
        TryFixedBlock(tableIndex);
        unsigned i;
        const unsigned kMaxStaticHuffLen = 9;
        for (i = 0; i < kFixedMainTableSize; i++)
          mainFreqs[i] = (UInt32)1 << (kMaxStaticHuffLen - m_NewLevels.litLenLevels[i]);
        for (i = 0; i < kFixedDistTableSize; i++)
          distFreqs[i] = (UInt32)1 << (kMaxStaticHuffLen - m_NewLevels.distLevels[i]);
        MakeTables(kMaxStaticHuffLen);
      }
      else
      {
        if (m_NumDivPasses > 1 || m_CheckStatic)
          TryDynBlock(tableIndex, 1);
        WriteBits(NBlockType::kDynamicHuffman, kBlockTypeFieldSize);
        WriteBits(m_NumLitLenLevels - kNumLitLenCodesMin, kNumLenCodesFieldSize);
        WriteBits(m_NumDistLevels - kNumDistCodesMin, kNumDistCodesFieldSize);
        WriteBits(m_NumLevelCodes - kNumLevelCodesMin, kNumLevelCodesFieldSize);
        
        for (UInt32 i = 0; i < m_NumLevelCodes; i++)
          WriteBits(m_LevelLevels[i], kLevelFieldSize);
        
        Huffman_ReverseBits(levelCodes, levelLens, kLevelTableSize);
        LevelTableCode(m_NewLevels.litLenLevels, m_NumLitLenLevels, levelLens, levelCodes);
        LevelTableCode(m_NewLevels.distLevels, m_NumDistLevels, levelLens, levelCodes);
      }
      WriteBlock();
    }
    m_AdditionalOffset -= t.BlockSizeRes;
  }
}

SRes Read(void *object, void *data, size_t *size)
{
  const UInt32 kStepSize = (UInt32)1 << 31;
  UInt32 curSize = ((*size < kStepSize) ? (UInt32)*size : kStepSize);
  HRESULT res = ((CSeqInStream *)object)->RealStream->Read(data, curSize, &curSize);
  *size = curSize;
  return (SRes)res;
}

HRESULT CCoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */ , const UInt64 * /* outSize */ , ICompressProgressInfo *progress)
{
  m_CheckStatic = (m_NumPasses != 1 || m_NumDivPasses != 1);
  m_IsMultiPass = (m_CheckStatic || (m_NumPasses != 1 || m_NumDivPasses != 1));

  RINOK(Create());

  m_ValueBlockSize = (7 << 10) + (1 << 12) * m_NumDivPasses;

  UInt64 nowPos = 0;

  _seqInStream.RealStream = inStream;
  _seqInStream.SeqInStream.Read = Read;
  _lzInWindow.stream = &_seqInStream.SeqInStream;

  MatchFinder_Init(&_lzInWindow);
  m_OutStream.SetStream(outStream);
  m_OutStream.Init();

  m_OptimumEndIndex = m_OptimumCurrentIndex = 0;

  CTables &t = m_Tables[1];
  t.m_Pos = 0;
  t.InitStructures();

  m_AdditionalOffset = 0;
  do
  {
    t.BlockSizeRes = kBlockUncompressedSizeThreshold;
    m_SecondPass = false;
    GetBlockPrice(1, m_NumDivPasses);
    CodeBlock(1, Inline_MatchFinder_GetNumAvailableBytes(&_lzInWindow) == 0);
    nowPos += m_Tables[1].BlockSizeRes;
    if (progress != NULL)
    {
      UInt64 packSize = m_OutStream.GetProcessedSize();
      RINOK(progress->SetRatioInfo(&nowPos, &packSize));
    }
  }
  while (Inline_MatchFinder_GetNumAvailableBytes(&_lzInWindow) != 0);
  if (_lzInWindow.result != SZ_OK)
    return _lzInWindow.result;
  return m_OutStream.Flush();
}

HRESULT CCoder::BaseCode(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try { return CodeReal(inStream, outStream, inSize, outSize, progress); }
  catch(const COutBufferException &e) { return e.ErrorCode; }
  catch(...) { return E_FAIL; }
}

STDMETHODIMP CCOMCoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
  { return BaseCode(inStream, outStream, inSize, outSize, progress); }

STDMETHODIMP CCOMCoder::SetCoderProperties(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps)
  { return BaseSetEncoderProperties2(propIDs, props, numProps); }

STDMETHODIMP CCOMCoder64::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
  { return BaseCode(inStream, outStream, inSize, outSize, progress); }

STDMETHODIMP CCOMCoder64::SetCoderProperties(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps)
  { return BaseSetEncoderProperties2(propIDs, props, numProps); }

}}}
// DeflateEncoder.h

#ifndef __DEFLATE_ENCODER_H
#define __DEFLATE_ENCODER_H

#include "../../../C/LzFind.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "BitlEncoder.h"
#include "DeflateConst.h"

namespace NCompress {
namespace NDeflate {
namespace NEncoder {

struct CCodeValue
{
  UInt16 Len;
  UInt16 Pos;
  void SetAsLiteral() { Len = (1 << 15); }
  bool IsLiteral() const { return (Len >= (1 << 15)); }
};

struct COptimal
{
  UInt32 Price;
  UInt16 PosPrev;
  UInt16 BackPrev;
};

const UInt32 kNumOptsBase = 1 << 12;
const UInt32 kNumOpts = kNumOptsBase + kMatchMaxLen;

class CCoder;

struct CTables: public CLevels
{
  bool UseSubBlocks;
  bool StoreMode;
  bool StaticMode;
  UInt32 BlockSizeRes;
  UInt32 m_Pos;
  void InitStructures();
};

typedef struct _CSeqInStream
{
  ISeqInStream SeqInStream;
  ISequentialInStream *RealStream;
} CSeqInStream;

struct CEncProps
{
  int Level;
  int algo;
  int fb;
  int btMode;
  UInt32 mc;
  UInt32 numPasses;

  CEncProps()
  {
    Level = -1;
    mc = 0;
    algo = fb = btMode = -1;
    numPasses = (UInt32)(Int32)-1;
  }
  void Normalize();
};

class CCoder
{
  CMatchFinder _lzInWindow;
  CBitlEncoder m_OutStream;

  CSeqInStream _seqInStream;

public:
  CCodeValue *m_Values;

  UInt16 *m_MatchDistances;
  UInt32 m_NumFastBytes;
  bool _fastMode;
  bool _btMode;

  UInt16 *m_OnePosMatchesMemory;
  UInt16 *m_DistanceMemory;

  UInt32 m_Pos;

  unsigned m_NumPasses;
  unsigned m_NumDivPasses;
  bool m_CheckStatic;
  bool m_IsMultiPass;
  UInt32 m_ValueBlockSize;

  UInt32 m_NumLenCombinations;
  UInt32 m_MatchMaxLen;
  const Byte *m_LenStart;
  const Byte *m_LenDirectBits;

  bool m_Created;
  bool m_Deflate64Mode;

  Byte m_LevelLevels[kLevelTableSize];
  unsigned m_NumLitLenLevels;
  unsigned m_NumDistLevels;
  UInt32 m_NumLevelCodes;
  UInt32 m_ValueIndex;

  bool m_SecondPass;
  UInt32 m_AdditionalOffset;

  UInt32 m_OptimumEndIndex;
  UInt32 m_OptimumCurrentIndex;
  
  Byte  m_LiteralPrices[256];
  Byte  m_LenPrices[kNumLenSymbolsMax];
  Byte  m_PosPrices[kDistTableSize64];

  CLevels m_NewLevels;
  UInt32 mainFreqs[kFixedMainTableSize];
  UInt32 distFreqs[kDistTableSize64];
  UInt32 mainCodes[kFixedMainTableSize];
  UInt32 distCodes[kDistTableSize64];
  UInt32 levelCodes[kLevelTableSize];
  Byte levelLens[kLevelTableSize];

  UInt32 BlockSizeRes;

  CTables *m_Tables;
  COptimal m_Optimum[kNumOpts];

  UInt32 m_MatchFinderCycles;

  void GetMatches();
  void MovePos(UInt32 num);
  UInt32 Backward(UInt32 &backRes, UInt32 cur);
  UInt32 GetOptimal(UInt32 &backRes);
  UInt32 GetOptimalFast(UInt32 &backRes);

  void LevelTableDummy(const Byte *levels, unsigned numLevels, UInt32 *freqs);

  void WriteBits(UInt32 value, unsigned numBits);
  void LevelTableCode(const Byte *levels, unsigned numLevels, const Byte *lens, const UInt32 *codes);

  void MakeTables(unsigned maxHuffLen);
  UInt32 GetLzBlockPrice() const;
  void TryBlock();
  UInt32 TryDynBlock(unsigned tableIndex, UInt32 numPasses);

  UInt32 TryFixedBlock(unsigned tableIndex);

  void SetPrices(const CLevels &levels);
  void WriteBlock();

  HRESULT Create();
  void Free();

  void WriteStoreBlock(UInt32 blockSize, UInt32 additionalOffset, bool finalBlock);
  void WriteTables(bool writeMode, bool finalBlock);
  
  void WriteBlockData(bool writeMode, bool finalBlock);

  UInt32 GetBlockPrice(unsigned tableIndex, unsigned numDivPasses);
  void CodeBlock(unsigned tableIndex, bool finalBlock);

  void SetProps(const CEncProps *props2);
public:
  CCoder(bool deflate64Mode = false);
  ~CCoder();

  HRESULT CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  HRESULT BaseCode(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  HRESULT BaseSetEncoderProperties2(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
};


class CCOMCoder :
  public ICompressCoder,
  public ICompressSetCoderProperties,
  public CMyUnknownImp,
  public CCoder
{
public:
  MY_UNKNOWN_IMP2(ICompressCoder, ICompressSetCoderProperties)
  CCOMCoder(): CCoder(false) {};
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
};

class CCOMCoder64 :
  public ICompressCoder,
  public ICompressSetCoderProperties,
  public CMyUnknownImp,
  public CCoder
{
public:
  MY_UNKNOWN_IMP2(ICompressCoder, ICompressSetCoderProperties)
  CCOMCoder64(): CCoder(true) {};
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
};

}}}

#endif
// DeflateRegister.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "DeflateDecoder.h"
#if !defined(EXTRACT_ONLY) && !defined(DEFLATE_EXTRACT_ONLY)
#include "DeflateEncoder.h"
#endif

namespace NCompress {
namespace NDeflate {

REGISTER_CODEC_CREATE(CreateDec, NDecoder::CCOMCoder)

#if !defined(EXTRACT_ONLY) && !defined(DEFLATE_EXTRACT_ONLY)
REGISTER_CODEC_CREATE(CreateEnc, NEncoder::CCOMCoder)
#else
#define CreateEnc NULL
#endif

REGISTER_CODEC_2(Deflate, CreateDec, CreateEnc, 0x40108, "Deflate")

}}
// DeltaFilter.cpp

#include "StdAfx.h"

#include "../../../C/Delta.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "../Common/RegisterCodec.h"

namespace NCompress {
namespace NDelta {

struct CDelta
{
  unsigned _delta;
  Byte _state[DELTA_STATE_SIZE];

  CDelta(): _delta(1) {}
  void DeltaInit() { Delta_Init(_state); }
};


#ifndef EXTRACT_ONLY

class CEncoder:
  public ICompressFilter,
  public ICompressSetCoderProperties,
  public ICompressWriteCoderProperties,
  CDelta,
  public CMyUnknownImp
{
public:
  MY_UNKNOWN_IMP3(ICompressFilter, ICompressSetCoderProperties, ICompressWriteCoderProperties)
  INTERFACE_ICompressFilter(;)
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
  STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStream);
};

STDMETHODIMP CEncoder::Init()
{
  DeltaInit();
  return S_OK;
}

STDMETHODIMP_(UInt32) CEncoder::Filter(Byte *data, UInt32 size)
{
  Delta_Encode(_state, _delta, data, size);
  return size;
}

STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps)
{
  UInt32 delta = _delta;
  for (UInt32 i = 0; i < numProps; i++)
  {
    const PROPVARIANT &prop = props[i];
    PROPID propID = propIDs[i];
    if (propID >= NCoderPropID::kReduceSize)
      continue;
    if (prop.vt != VT_UI4)
      return E_INVALIDARG;
    switch (propID)
    {
      case NCoderPropID::kDefaultProp:
        delta = (UInt32)prop.ulVal;
        if (delta < 1 || delta > 256)
          return E_INVALIDARG;
        break;
      case NCoderPropID::kNumThreads: break;
      case NCoderPropID::kLevel: break;
      default: return E_INVALIDARG;
    }
  }
  _delta = delta;
  return S_OK;
}

STDMETHODIMP CEncoder::WriteCoderProperties(ISequentialOutStream *outStream)
{
  Byte prop = (Byte)(_delta - 1);
  return outStream->Write(&prop, 1, NULL);
}

#endif


class CDecoder:
  public ICompressFilter,
  public ICompressSetDecoderProperties2,
  CDelta,
  public CMyUnknownImp
{
public:
  MY_UNKNOWN_IMP2(ICompressFilter, ICompressSetDecoderProperties2)
  INTERFACE_ICompressFilter(;)
  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);
};

STDMETHODIMP CDecoder::Init()
{
  DeltaInit();
  return S_OK;
}

STDMETHODIMP_(UInt32) CDecoder::Filter(Byte *data, UInt32 size)
{
  Delta_Decode(_state, _delta, data, size);
  return size;
}

STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *props, UInt32 size)
{
  if (size != 1)
    return E_INVALIDARG;
  _delta = (unsigned)props[0] + 1;
  return S_OK;
}


REGISTER_FILTER_E(Delta,
    CDecoder(),
    CEncoder(),
    3, "Delta")

}}
// DllExports2Compress.cpp

#include "StdAfx.h"

#include "../../Common/MyInitGuid.h"

#include "../ICoder.h"

#include "../Common/RegisterCodec.h"

extern "C"
BOOL WINAPI DllMain(
  #ifdef UNDER_CE
  HANDLE
  #else
  HINSTANCE
  #endif
  /* hInstance */, DWORD /* dwReason */, LPVOID /*lpReserved*/)
{
  return TRUE;
}

STDAPI CreateCoder(const GUID *clsid, const GUID *iid, void **outObject);

STDAPI CreateObject(const GUID *clsid, const GUID *iid, void **outObject)
{
  return CreateCoder(clsid, iid, outObject);
}
// DllExportsCompress.cpp

#include "StdAfx.h"

#include "../../Common/MyInitGuid.h"

#include "../ICoder.h"

#include "../Common/RegisterCodec.h"

static const unsigned kNumCodecsMax = 48;
unsigned g_NumCodecs = 0;
const CCodecInfo *g_Codecs[kNumCodecsMax];
void RegisterCodec(const CCodecInfo *codecInfo) throw()
{
  if (g_NumCodecs < kNumCodecsMax)
    g_Codecs[g_NumCodecs++] = codecInfo;
}

static const unsigned kNumHashersMax = 16;
unsigned g_NumHashers = 0;
const CHasherInfo *g_Hashers[kNumHashersMax];
void RegisterHasher(const CHasherInfo *hashInfo) throw()
{
  if (g_NumHashers < kNumHashersMax)
    g_Hashers[g_NumHashers++] = hashInfo;
}

#ifdef _WIN32
extern "C"
BOOL WINAPI DllMain(
  #ifdef UNDER_CE
  HANDLE
  #else
  HINSTANCE
  #endif
  , DWORD /* dwReason */, LPVOID /*lpReserved*/)
{
  return TRUE;
}
#endif

STDAPI CreateCoder(const GUID *clsid, const GUID *iid, void **outObject);

STDAPI CreateObject(const GUID *clsid, const GUID *iid, void **outObject)
{
  return CreateCoder(clsid, iid, outObject);
}
// Compress/HuffmanDecoder.h

#ifndef __COMPRESS_HUFFMAN_DECODER_H
#define __COMPRESS_HUFFMAN_DECODER_H

#include "../../Common/MyTypes.h"

namespace NCompress {
namespace NHuffman {

template <unsigned kNumBitsMax, UInt32 m_NumSymbols, unsigned kNumTableBits = 9>
class CDecoder
{
  UInt32 _limits[kNumBitsMax + 2];
  UInt32 _poses[kNumBitsMax + 1];
  UInt16 _lens[1 << kNumTableBits];
  UInt16 _symbols[m_NumSymbols];
public:

  bool Build(const Byte *lens) throw()
  {
    UInt32 lenCounts[kNumBitsMax + 1];
    UInt32 tmpPoses[kNumBitsMax + 1];
    
    unsigned i;
    for (i = 0; i <= kNumBitsMax; i++)
      lenCounts[i] = 0;
    
    UInt32 sym;
    
    for (sym = 0; sym < m_NumSymbols; sym++)
      lenCounts[lens[sym]]++;
    
    lenCounts[0] = 0;
    _poses[0] = 0;
    _limits[0] = 0;
    UInt32 startPos = 0;
    const UInt32 kMaxValue = (UInt32)1 << kNumBitsMax;
    
    for (i = 1; i <= kNumBitsMax; i++)
    {
      startPos += lenCounts[i] << (kNumBitsMax - i);
      if (startPos > kMaxValue)
        return false;
      _limits[i] = startPos;
      _poses[i] = _poses[i - 1] + lenCounts[i - 1];
      tmpPoses[i] = _poses[i];
    }

    _limits[kNumBitsMax + 1] = kMaxValue;
    
    for (sym = 0; sym < m_NumSymbols; sym++)
    {
      unsigned len = lens[sym];
      if (len == 0)
        continue;

      unsigned offset = tmpPoses[len];
      _symbols[offset] = (UInt16)sym;
      tmpPoses[len] = offset + 1;

      if (len <= kNumTableBits)
      {
        offset -= _poses[len];
        UInt32 num = (UInt32)1 << (kNumTableBits - len);
        UInt16 val = (UInt16)((sym << 4) | len);
        UInt16 *dest = _lens + (_limits[len - 1] >> (kNumBitsMax - kNumTableBits)) + (offset << (kNumTableBits - len));
        for (UInt32 k = 0; k < num; k++)
          dest[k] = val;
      }
    }
    
    return true;
  }

  bool BuildFull(const Byte *lens, UInt32 numSymbols = m_NumSymbols) throw()
  {
    UInt32 lenCounts[kNumBitsMax + 1];
    UInt32 tmpPoses[kNumBitsMax + 1];
    
    unsigned i;
    for (i = 0; i <= kNumBitsMax; i++)
      lenCounts[i] = 0;
    
    UInt32 sym;
    
    for (sym = 0; sym < numSymbols; sym++)
      lenCounts[lens[sym]]++;
    
    lenCounts[0] = 0;
    _poses[0] = 0;
    _limits[0] = 0;
    UInt32 startPos = 0;
    const UInt32 kMaxValue = (UInt32)1 << kNumBitsMax;
    
    for (i = 1; i <= kNumBitsMax; i++)
    {
      startPos += lenCounts[i] << (kNumBitsMax - i);
      if (startPos > kMaxValue)
        return false;
      _limits[i] = startPos;
      _poses[i] = _poses[i - 1] + lenCounts[i - 1];
      tmpPoses[i] = _poses[i];
    }

    _limits[kNumBitsMax + 1] = kMaxValue;
    
    for (sym = 0; sym < numSymbols; sym++)
    {
      unsigned len = lens[sym];
      if (len == 0)
        continue;

      unsigned offset = tmpPoses[len];
      _symbols[offset] = (UInt16)sym;
      tmpPoses[len] = offset + 1;

      if (len <= kNumTableBits)
      {
        offset -= _poses[len];
        UInt32 num = (UInt32)1 << (kNumTableBits - len);
        UInt16 val = (UInt16)((sym << 4) | len);
        UInt16 *dest = _lens + (_limits[len - 1] >> (kNumBitsMax - kNumTableBits)) + (offset << (kNumTableBits - len));
        for (UInt32 k = 0; k < num; k++)
          dest[k] = val;
      }
    }
    
    return startPos == kMaxValue;
  }

  template <class TBitDecoder>
  UInt32 Decode(TBitDecoder *bitStream) const throw()
  {
    UInt32 val = bitStream->GetValue(kNumBitsMax);
    
    if (val < _limits[kNumTableBits])
    {
      UInt32 pair = _lens[val >> (kNumBitsMax - kNumTableBits)];
      bitStream->MovePos((unsigned)(pair & 0xF));
      return pair >> 4;
    }

    unsigned numBits;
    for (numBits = kNumTableBits + 1; val >= _limits[numBits]; numBits++);
    
    if (numBits > kNumBitsMax)
      return 0xFFFFFFFF;

    bitStream->MovePos(numBits);
    UInt32 index = _poses[numBits] + ((val - _limits[numBits - 1]) >> (kNumBitsMax - numBits));
    return _symbols[index];
  }

  template <class TBitDecoder>
  UInt32 DecodeFull(TBitDecoder *bitStream) const throw()
  {
    UInt32 val = bitStream->GetValue(kNumBitsMax);
    
    if (val < _limits[kNumTableBits])
    {
      UInt32 pair = _lens[val >> (kNumBitsMax - kNumTableBits)];
      bitStream->MovePos((unsigned)(pair & 0xF));
      return pair >> 4;
    }

    unsigned numBits;
    for (numBits = kNumTableBits + 1; val >= _limits[numBits]; numBits++);
    
    bitStream->MovePos(numBits);
    UInt32 index = _poses[numBits] + ((val - _limits[numBits - 1]) >> (kNumBitsMax - numBits));
    return _symbols[index];
  }
};



template <UInt32 m_NumSymbols>
class CDecoder7b
{
  Byte _lens[1 << 7];
public:

  bool Build(const Byte *lens) throw()
  {
    const unsigned kNumBitsMax = 7;
    
    UInt32 lenCounts[kNumBitsMax + 1];
    UInt32 tmpPoses[kNumBitsMax + 1];
    UInt32 _poses[kNumBitsMax + 1];
    UInt32 _limits[kNumBitsMax + 1];
      
    unsigned i;
    for (i = 0; i <= kNumBitsMax; i++)
      lenCounts[i] = 0;
    
    UInt32 sym;
    
    for (sym = 0; sym < m_NumSymbols; sym++)
      lenCounts[lens[sym]]++;
    
    lenCounts[0] = 0;
    _poses[0] = 0;
    _limits[0] = 0;
    UInt32 startPos = 0;
    const UInt32 kMaxValue = (UInt32)1 << kNumBitsMax;
    
    for (i = 1; i <= kNumBitsMax; i++)
    {
      startPos += lenCounts[i] << (kNumBitsMax - i);
      if (startPos > kMaxValue)
        return false;
      _limits[i] = startPos;
      _poses[i] = _poses[i - 1] + lenCounts[i - 1];
      tmpPoses[i] = _poses[i];
    }

    for (sym = 0; sym < m_NumSymbols; sym++)
    {
      unsigned len = lens[sym];
      if (len == 0)
        continue;

      unsigned offset = tmpPoses[len];
      tmpPoses[len] = offset + 1;

      {
        offset -= _poses[len];
        UInt32 num = (UInt32)1 << (kNumBitsMax - len);
        Byte val = (Byte)((sym << 3) | len);
        Byte *dest = _lens + (_limits[len - 1]) + (offset << (kNumBitsMax - len));
        for (UInt32 k = 0; k < num; k++)
          dest[k] = val;
      }
    }

    {
      UInt32 limit = _limits[kNumBitsMax];
      UInt32 num = ((UInt32)1 << kNumBitsMax) - limit;
      Byte *dest = _lens + limit;
      for (UInt32 k = 0; k < num; k++)
        dest[k] = (Byte)(0x1F << 3);
    }
    
    return true;
  }

  template <class TBitDecoder>
  UInt32 Decode(TBitDecoder *bitStream) const throw()
  {
    UInt32 val = bitStream->GetValue(7);
    UInt32 pair = _lens[val];
    bitStream->MovePos((unsigned)(pair & 0x7));
    return pair >> 3;
  }
};

}}

#endif
// ImplodeDecoder.cpp

#include "StdAfx.h"

#include "../../Common/Defs.h"

#include "ImplodeDecoder.h"

namespace NCompress {
namespace NImplode {
namespace NDecoder {

class CException
{
public:
  enum ECauseType
  {
    kData
  } m_Cause;
  CException(ECauseType cause): m_Cause(cause) {}
};

static const int kNumDistanceLowDirectBitsForBigDict = 7;
static const int kNumDistanceLowDirectBitsForSmallDict = 6;

static const int kNumBitsInByte = 8;

// static const int kLevelStructuresNumberFieldSize = kNumBitsInByte;
static const int kLevelStructuresNumberAdditionalValue = 1;

static const int kNumLevelStructureLevelBits = 4;
static const int kLevelStructureLevelAdditionalValue = 1;

static const int kNumLevelStructureRepNumberBits = 4;
static const int kLevelStructureRepNumberAdditionalValue = 1;


static const int kLiteralTableSize = (1 << kNumBitsInByte);
static const int kDistanceTableSize = 64;
static const int kLengthTableSize = 64;

static const UInt32 kHistorySize =
    (1 << MyMax(kNumDistanceLowDirectBitsForBigDict,
                kNumDistanceLowDirectBitsForSmallDict)) *
    kDistanceTableSize; // = 8 KB;

static const int kNumAdditionalLengthBits = 8;

static const UInt32 kMatchMinLenWhenLiteralsOn = 3;
static const UInt32 kMatchMinLenWhenLiteralsOff = 2;

static const UInt32 kMatchMinLenMax = MyMax(kMatchMinLenWhenLiteralsOn,
    kMatchMinLenWhenLiteralsOff);  // 3

// static const UInt32 kMatchMaxLenMax = kMatchMinLenMax + (kLengthTableSize - 1) + (1 << kNumAdditionalLengthBits) - 1;  // or 2

enum
{
  kMatchId = 0,
  kLiteralId = 1
};


CCoder::CCoder():
  m_LiteralDecoder(kLiteralTableSize),
  m_LengthDecoder(kLengthTableSize),
  m_DistanceDecoder(kDistanceTableSize)
{
}

/*
void CCoder::ReleaseStreams()
{
  m_OutWindowStream.ReleaseStream();
  m_InBitStream.ReleaseStream();
}
*/

bool CCoder::ReadLevelItems(NImplode::NHuffman::CDecoder &decoder,
    Byte *levels, int numLevelItems)
{
  int numCodedStructures = m_InBitStream.ReadBits(kNumBitsInByte) +
      kLevelStructuresNumberAdditionalValue;
  int currentIndex = 0;
  for (int i = 0; i < numCodedStructures; i++)
  {
    int level = m_InBitStream.ReadBits(kNumLevelStructureLevelBits) +
      kLevelStructureLevelAdditionalValue;
    int rep = m_InBitStream.ReadBits(kNumLevelStructureRepNumberBits) +
      kLevelStructureRepNumberAdditionalValue;
    if (currentIndex + rep > numLevelItems)
      throw CException(CException::kData);
    for (int j = 0; j < rep; j++)
      levels[currentIndex++] = (Byte)level;
  }
  if (currentIndex != numLevelItems)
    return false;
  return decoder.SetCodeLengths(levels);
}


bool CCoder::ReadTables(void)
{
  if (m_LiteralsOn)
  {
    Byte literalLevels[kLiteralTableSize];
    if (!ReadLevelItems(m_LiteralDecoder, literalLevels, kLiteralTableSize))
      return false;
  }

  Byte lengthLevels[kLengthTableSize];
  if (!ReadLevelItems(m_LengthDecoder, lengthLevels, kLengthTableSize))
    return false;

  Byte distanceLevels[kDistanceTableSize];
  return ReadLevelItems(m_DistanceDecoder, distanceLevels, kDistanceTableSize);
}

/*
class CCoderReleaser
{
  CCoder *m_Coder;
public:
  CCoderReleaser(CCoder *coder): m_Coder(coder) {}
  ~CCoderReleaser() { m_Coder->ReleaseStreams(); }
};
*/

HRESULT CCoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  if (!m_InBitStream.Create(1 << 20))
    return E_OUTOFMEMORY;
  if (!m_OutWindowStream.Create(kHistorySize))
    return E_OUTOFMEMORY;
  if (outSize == NULL)
    return E_INVALIDARG;
  UInt64 pos = 0, unPackSize = *outSize;

  m_OutWindowStream.SetStream(outStream);
  m_OutWindowStream.Init(false);
  m_InBitStream.SetStream(inStream);
  m_InBitStream.Init();
  // CCoderReleaser coderReleaser(this);

  if (!ReadTables())
    return S_FALSE;
  
  while (pos < unPackSize)
  {
    if (progress != NULL && pos % (1 << 16) == 0)
    {
      UInt64 packSize = m_InBitStream.GetProcessedSize();
      RINOK(progress->SetRatioInfo(&packSize, &pos));
    }
    if (m_InBitStream.ReadBits(1) == kMatchId) // match
    {
      UInt32 lowDistBits = m_InBitStream.ReadBits(m_NumDistanceLowDirectBits);
      UInt32 distance = m_DistanceDecoder.DecodeSymbol(&m_InBitStream);
      if (distance >= kDistanceTableSize)
        return S_FALSE;
      distance = (distance << m_NumDistanceLowDirectBits) + lowDistBits;
      UInt32 lengthSymbol = m_LengthDecoder.DecodeSymbol(&m_InBitStream);
      if (lengthSymbol >= kLengthTableSize)
        return S_FALSE;
      UInt32 length = lengthSymbol + m_MinMatchLength;
      if (lengthSymbol == kLengthTableSize - 1) // special symbol = 63
        length += m_InBitStream.ReadBits(kNumAdditionalLengthBits);
      while (distance >= pos && length > 0)
      {
        m_OutWindowStream.PutByte(0);
        pos++;
        length--;
      }
      if (length > 0)
        m_OutWindowStream.CopyBlock(distance, length);
      pos += length;
    }
    else
    {
      Byte b;
      if (m_LiteralsOn)
      {
        UInt32 temp = m_LiteralDecoder.DecodeSymbol(&m_InBitStream);
        if (temp >= kLiteralTableSize)
          return S_FALSE;
        b = (Byte)temp;
      }
      else
        b = (Byte)m_InBitStream.ReadBits(kNumBitsInByte);
      m_OutWindowStream.PutByte(b);
      pos++;
    }
  }
  if (pos > unPackSize)
    return S_FALSE;
  return m_OutWindowStream.Flush();
}

STDMETHODIMP CCoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try { return CodeReal(inStream, outStream, inSize, outSize, progress);  }
  catch(const CLzOutWindowException &e) { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
}

STDMETHODIMP CCoder::SetDecoderProperties2(const Byte *data, UInt32 size)
{
  if (size < 1)
    return E_INVALIDARG;
  Byte flag = data[0];
  m_BigDictionaryOn = ((flag & 2) != 0);
  m_NumDistanceLowDirectBits = m_BigDictionaryOn ?
      kNumDistanceLowDirectBitsForBigDict:
      kNumDistanceLowDirectBitsForSmallDict;
  m_LiteralsOn = ((flag & 4) != 0);
  m_MinMatchLength = m_LiteralsOn ?
      kMatchMinLenWhenLiteralsOn :
      kMatchMinLenWhenLiteralsOff;
  return S_OK;
}

}}}
// ImplodeDecoder.h

#ifndef __COMPRESS_IMPLODE_DECODER_H
#define __COMPRESS_IMPLODE_DECODER_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "ImplodeHuffmanDecoder.h"
#include "LzOutWindow.h"

namespace NCompress {
namespace NImplode {
namespace NDecoder {

class CCoder:
  public ICompressCoder,
  public ICompressSetDecoderProperties2,
  public CMyUnknownImp
{
  CLzOutWindow m_OutWindowStream;
  NBitl::CDecoder<CInBuffer> m_InBitStream;
  
  NImplode::NHuffman::CDecoder m_LiteralDecoder;
  NImplode::NHuffman::CDecoder m_LengthDecoder;
  NImplode::NHuffman::CDecoder m_DistanceDecoder;

  bool m_BigDictionaryOn;
  bool m_LiteralsOn;

  int m_NumDistanceLowDirectBits;
  UInt32 m_MinMatchLength;

  bool ReadLevelItems(NImplode::NHuffman::CDecoder &table, Byte *levels, int numLevelItems);
  bool ReadTables();
  void DeCodeLevelTable(Byte *newLevels, int numLevels);
public:
  CCoder();

  MY_UNKNOWN_IMP1(ICompressSetDecoderProperties2)

  // void ReleaseStreams();
  
  HRESULT CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);
};

}}}

#endif
// ImplodeHuffmanDecoder.cpp

#include "StdAfx.h"

#include "ImplodeHuffmanDecoder.h"

namespace NCompress {
namespace NImplode {
namespace NHuffman {

CDecoder::CDecoder(UInt32 numSymbols):
  m_NumSymbols(numSymbols)
{
  m_Symbols = new UInt32[m_NumSymbols];
}

CDecoder::~CDecoder()
{
  delete []m_Symbols;
}

bool CDecoder::SetCodeLengths(const Byte *codeLengths)
{
  // unsigned lenCounts[kNumBitsInLongestCode + 1], tmpPositions[kNumBitsInLongestCode + 1];
  unsigned lenCounts[kNumBitsInLongestCode + 2], tmpPositions[kNumBitsInLongestCode + 1];
  unsigned i;
  for (i = 0; i <= kNumBitsInLongestCode; i++)
    lenCounts[i] = 0;
  UInt32 symbolIndex;
  for (symbolIndex = 0; symbolIndex < m_NumSymbols; symbolIndex++)
    lenCounts[codeLengths[symbolIndex]]++;
  // lenCounts[0] = 0;
  
  // tmpPositions[0] = m_Positions[0] = m_Limitits[0] = 0;
  m_Limitits[kNumBitsInLongestCode + 1] = 0;
  m_Positions[kNumBitsInLongestCode + 1] = 0;
  lenCounts[kNumBitsInLongestCode + 1] = 0;


  UInt32 startPos = 0;
  static const UInt32 kMaxValue = (1 << kNumBitsInLongestCode);

  for (i = kNumBitsInLongestCode; i > 0; i--)
  {
    startPos += lenCounts[i] << (kNumBitsInLongestCode - i);
    if (startPos > kMaxValue)
      return false;
    m_Limitits[i] = startPos;
    m_Positions[i] = m_Positions[i + 1] + lenCounts[i + 1];
    tmpPositions[i] = m_Positions[i] + lenCounts[i];

  }

  // if _ZIP_MODE do not throw exception for trees containing only one node
  // #ifndef _ZIP_MODE
  if (startPos != kMaxValue)
    return false;
  // #endif

  for (symbolIndex = 0; symbolIndex < m_NumSymbols; symbolIndex++)
    if (codeLengths[symbolIndex] != 0)
      m_Symbols[--tmpPositions[codeLengths[symbolIndex]]] = symbolIndex;
  return true;
}

UInt32 CDecoder::DecodeSymbol(CInBit *inStream)
{
  UInt32 numBits = 0;
  UInt32 value = inStream->GetValue(kNumBitsInLongestCode);
  unsigned i;
  for (i = kNumBitsInLongestCode; i > 0; i--)
  {
    if (value < m_Limitits[i])
    {
      numBits = i;
      break;
    }
  }
  if (i == 0)
    return 0xFFFFFFFF;
  inStream->MovePos(numBits);
  UInt32 index = m_Positions[numBits] +
      ((value - m_Limitits[numBits + 1]) >> (kNumBitsInLongestCode - numBits));
  if (index >= m_NumSymbols)
    return 0xFFFFFFFF;
  return m_Symbols[index];
}

}}}
// ImplodeHuffmanDecoder.h

#ifndef __IMPLODE_HUFFMAN_DECODER_H
#define __IMPLODE_HUFFMAN_DECODER_H

#include "../Common/InBuffer.h"

#include "BitlDecoder.h"

namespace NCompress {
namespace NImplode {
namespace NHuffman {

const unsigned kNumBitsInLongestCode = 16;

typedef NBitl::CDecoder<CInBuffer> CInBit;

class CDecoder
{
  UInt32 m_Limitits[kNumBitsInLongestCode + 2]; // m_Limitits[i] = value limit for symbols with length = i
  UInt32 m_Positions[kNumBitsInLongestCode + 2];   // m_Positions[i] = index in m_Symbols[] of first symbol with length = i
  UInt32 m_NumSymbols; // number of symbols in m_Symbols
  UInt32 *m_Symbols; // symbols: at first with len=1 then 2, ... 15.
public:
  CDecoder(UInt32 numSymbols);
  ~CDecoder();
  
  bool SetCodeLengths(const Byte *codeLengths);
  UInt32 DecodeSymbol(CInBit *inStream);
};

}}}

#endif
// LzOutWindow.cpp

#include "StdAfx.h"

#include "LzOutWindow.h"

void CLzOutWindow::Init(bool solid) throw()
{
  if (!solid)
    COutBuffer::Init();
  #ifdef _NO_EXCEPTIONS
  ErrorCode = S_OK;
  #endif
}
// LzOutWindow.h

#ifndef __LZ_OUT_WINDOW_H
#define __LZ_OUT_WINDOW_H

#include "../Common/OutBuffer.h"

#ifndef _NO_EXCEPTIONS
typedef COutBufferException CLzOutWindowException;
#endif

class CLzOutWindow: public COutBuffer
{
public:
  void Init(bool solid = false) throw();
  
  // distance >= 0, len > 0,
  bool CopyBlock(UInt32 distance, UInt32 len)
  {
    UInt32 pos = _pos - distance - 1;
    if (distance >= _pos)
    {
      if (!_overDict || distance >= _bufSize)
        return false;
      pos += _bufSize;
    }
    if (_limitPos - _pos > len && _bufSize - pos > len)
    {
      const Byte *src = _buf + pos;
      Byte *dest = _buf + _pos;
      _pos += len;
      do
        *dest++ = *src++;
      while (--len != 0);
    }
    else do
    {
      UInt32 pos2;
      if (pos == _bufSize)
        pos = 0;
      pos2 = _pos;
      _buf[pos2++] = _buf[pos++];
      _pos = pos2;
      if (pos2 == _limitPos)
        FlushWithCheck();
    }
    while (--len != 0);
    return true;
  }
  
  void PutByte(Byte b)
  {
    UInt32 pos = _pos;
    _buf[pos++] = b;
    _pos = pos;
    if (pos == _limitPos)
      FlushWithCheck();
  }
  
  Byte GetByte(UInt32 distance) const
  {
    UInt32 pos = _pos - distance - 1;
    if (distance >= _pos)
      pos += _bufSize;
    return _buf[pos];
  }
};

#endif
// LzhDecoder.cpp

#include "StdAfx.h"

#include "LzhDecoder.h"

namespace NCompress{
namespace NLzh {
namespace NDecoder {

static const UInt32 kWindowSizeMin = 1 << 16;

static bool CheckCodeLens(const Byte *lens, unsigned num)
{
  UInt32 sum = 0;
  for (unsigned i = 0; i < num; i++)
  {
    unsigned len = lens[i];
    if (len != 0)
      sum += ((UInt32)1 << (NUM_CODE_BITS - len));
  }
  return sum == ((UInt32)1 << NUM_CODE_BITS);
}

bool CCoder::ReadTP(unsigned num, unsigned numBits, int spec)
{
  _symbolT = -1;

  UInt32 n = _inBitStream.ReadBits(numBits);
  if (n == 0)
  {
    _symbolT = _inBitStream.ReadBits(numBits);
    return ((unsigned)_symbolT < num);
  }

  if (n > num)
    return false;

  {
    Byte lens[NPT];
    unsigned i;
    for (i = 0; i < NPT; i++)
      lens[i] = 0;

    i = 0;
    
    do
    {
      UInt32 val = _inBitStream.GetValue(16);
      unsigned c = val >> 13;
      
      if (c == 7)
      {
        UInt32 mask = 1 << 12;
        while (mask & val)
        {
          mask >>= 1;
          c++;
        }
        if (c > 16)
          return false;
      }
      
      _inBitStream.MovePos(c < 7 ? 3 : c - 3);
      lens[i++] = (Byte)c;
      
      if (i == (unsigned)spec)
        i += _inBitStream.ReadBits(2);
    }
    while (i < n);
    
    if (!CheckCodeLens(lens, NPT))
      return false;
    return _decoderT.Build(lens);
  }
}

static const unsigned NUM_C_BITS = 9;

bool CCoder::ReadC()
{
  _symbolC = -1;

  unsigned n = _inBitStream.ReadBits(NUM_C_BITS);
  
  if (n == 0)
  {
    _symbolC = _inBitStream.ReadBits(NUM_C_BITS);
    return ((unsigned)_symbolC < NC);
  }

  if (n > NC)
    return false;

  {
    Byte lens[NC];

    unsigned i = 0;
  
    do
    {
      UInt32 c = (unsigned)_symbolT;
      if (_symbolT < 0)
        c = _decoderT.Decode(&_inBitStream);
      
      if (c <= 2)
      {
        if (c == 0)
          c = 1;
        else if (c == 1)
          c = _inBitStream.ReadBits(4) + 3;
        else
          c = _inBitStream.ReadBits(NUM_C_BITS) + 20;
    
        if (i + c > n)
          return false;
        
        do
          lens[i++] = 0;
        while (--c);
      }
      else
        lens[i++] = (Byte)(c - 2);
    }
    while (i < n);
    
    while (i < NC)
      lens[i++] = 0;
    
    if (!CheckCodeLens(lens, NC))
      return false;
    return _decoderC.Build(lens);
  }
}

HRESULT CCoder::CodeReal(UInt64 rem, ICompressProgressInfo *progress)
{
  unsigned pbit = (DictSize <= (1 << 14) ? 4 : 5);

  UInt32 blockSize = 0;

  while (rem != 0)
  {
    if (blockSize == 0)
    {
      if (_inBitStream.ExtraBitsWereRead())
        return S_FALSE;

      if (progress)
      {
        UInt64 packSize = _inBitStream.GetProcessedSize();
        UInt64 pos = _outWindow.GetProcessedSize();
        RINOK(progress->SetRatioInfo(&packSize, &pos));
      }
      
      blockSize = _inBitStream.ReadBits(16);
      if (blockSize == 0)
        return S_FALSE;
      
      if (!ReadTP(NT, 5, 3))
        return S_FALSE;
      if (!ReadC())
        return S_FALSE;
      if (!ReadTP(NP, pbit, -1))
        return S_FALSE;
    }
  
    blockSize--;

    UInt32 number = (unsigned)_symbolC;
    if (_symbolC < 0)
      number = _decoderC.Decode(&_inBitStream);

    if (number < 256)
    {
      _outWindow.PutByte((Byte)number);
      rem--;
    }
    else
    {
      UInt32 len = number - 256 + kMatchMinLen;

      UInt32 dist = (unsigned)_symbolT;
      if (_symbolT < 0)
        dist = _decoderT.Decode(&_inBitStream);
      
      if (dist > 1)
      {
        dist--;
        dist = ((UInt32)1 << dist) + _inBitStream.ReadBits((unsigned)dist);
      }
      
      if (dist >= DictSize)
        return S_FALSE;

      if (len > rem)
        len = (UInt32)rem;

      if (!_outWindow.CopyBlock(dist, len))
        return S_FALSE;
      rem -= len;
    }
  }

  if (FinishMode)
  {
    if (blockSize != 0)
      return S_FALSE;
    if (_inBitStream.ReadAlignBits() != 0)
      return S_FALSE;
  }

  if (_inBitStream.ExtraBitsWereRead())
    return S_FALSE;

  return S_OK;
}


STDMETHODIMP CCoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try
  {
    if (!outSize)
      return E_INVALIDARG;
    
    if (!_outWindow.Create(DictSize > kWindowSizeMin ? DictSize : kWindowSizeMin))
      return E_OUTOFMEMORY;
    if (!_inBitStream.Create(1 << 17))
      return E_OUTOFMEMORY;
    
    _outWindow.SetStream(outStream);
    _outWindow.Init(false);
    _inBitStream.SetStream(inStream);
    _inBitStream.Init();
    
    CCoderReleaser coderReleaser(this);
    
    RINOK(CodeReal(*outSize, progress));

    coderReleaser.Disable();
    return _outWindow.Flush();
  }
  catch(const CInBufferException &e) { return e.ErrorCode; }
  catch(const CLzOutWindowException &e) { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
}

}}}
// LzhDecoder.h

#ifndef __COMPRESS_LZH_DECODER_H
#define __COMPRESS_LZH_DECODER_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "../Common/InBuffer.h"

#include "BitmDecoder.h"
#include "HuffmanDecoder.h"
#include "LzOutWindow.h"

namespace NCompress {
namespace NLzh {
namespace NDecoder {

const unsigned kMatchMinLen = 3;
const unsigned kMatchMaxLen = 256;
const unsigned NC = (256 + kMatchMaxLen - kMatchMinLen + 1);
const unsigned NUM_CODE_BITS = 16;
const unsigned NUM_DIC_BITS_MAX = 25;
const unsigned NT = (NUM_CODE_BITS + 3);
const unsigned NP = (NUM_DIC_BITS_MAX + 1);
const unsigned NPT = NP; // Max(NT, NP)

class CCoder:
  public ICompressCoder,
  public CMyUnknownImp
{
  CLzOutWindow _outWindow;
  NBitm::CDecoder<CInBuffer> _inBitStream;

  int _symbolT;
  int _symbolC;

  NHuffman::CDecoder<NUM_CODE_BITS, NPT> _decoderT;
  NHuffman::CDecoder<NUM_CODE_BITS, NC> _decoderC;

  class CCoderReleaser
  {
    CCoder *_coder;
  public:
    CCoderReleaser(CCoder *coder): _coder(coder) {}
    void Disable() { _coder = NULL; }
    ~CCoderReleaser() { if (_coder) _coder->_outWindow.Flush(); }
  };
  friend class CCoderReleaser;

  bool ReadTP(unsigned num, unsigned numBits, int spec);
  bool ReadC();

  HRESULT CodeReal(UInt64 outSize, ICompressProgressInfo *progress);
public:
  MY_UNKNOWN_IMP

  UInt32 DictSize;
  bool FinishMode;

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  void SetDictSize(unsigned dictSize) { DictSize = dictSize; }
  
  CCoder(): DictSize(1 << 16), FinishMode(false) {}

  UInt64 GetInputProcessedSize() const { return _inBitStream.GetProcessedSize(); }
};

}}}

#endif
// Lzma2Decoder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "../Common/StreamUtils.h"

#include "Lzma2Decoder.h"

static HRESULT SResToHRESULT(SRes res)
{
  switch (res)
  {
    case SZ_OK: return S_OK;
    case SZ_ERROR_MEM: return E_OUTOFMEMORY;
    case SZ_ERROR_PARAM: return E_INVALIDARG;
    // case SZ_ERROR_PROGRESS: return E_ABORT;
    case SZ_ERROR_DATA: return S_FALSE;
  }
  return E_FAIL;
}

namespace NCompress {
namespace NLzma2 {

CDecoder::CDecoder():
    _inBuf(NULL),
    _inBufSize(0),
    _inBufSizeNew(1 << 20),
    _outStepSize(1 << 22),
    _outSizeDefined(false),
    _finishMode(false)
{
  Lzma2Dec_Construct(&_state);
}

STDMETHODIMP CDecoder::SetInBufSize(UInt32 , UInt32 size) { _inBufSizeNew = size; return S_OK; }
STDMETHODIMP CDecoder::SetOutBufSize(UInt32 , UInt32 size) { _outStepSize = size; return S_OK; }

CDecoder::~CDecoder()
{
  Lzma2Dec_Free(&_state, &g_Alloc);
  MidFree(_inBuf);
}

STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *prop, UInt32 size)
{
  if (size != 1)
    return E_NOTIMPL;
  
  RINOK(SResToHRESULT(Lzma2Dec_Allocate(&_state, prop[0], &g_Alloc)));
  if (!_inBuf || _inBufSize != _inBufSizeNew)
  {
    MidFree(_inBuf);
    _inBufSize = 0;
    _inBuf = (Byte *)MidAlloc(_inBufSizeNew);
    if (!_inBuf)
      return E_OUTOFMEMORY;
    _inBufSize = _inBufSizeNew;
  }

  return S_OK;
}

STDMETHODIMP CDecoder::GetInStreamProcessedSize(UInt64 *value) { *value = _inSizeProcessed; return S_OK; }
STDMETHODIMP CDecoder::SetInStream(ISequentialInStream *inStream) { _inStream = inStream; return S_OK; }
STDMETHODIMP CDecoder::ReleaseInStream() { _inStream.Release(); return S_OK; }

STDMETHODIMP CDecoder::SetOutStreamSize(const UInt64 *outSize)
{
  _outSizeDefined = (outSize != NULL);
  _outSize = 0;
  if (_outSizeDefined)
    _outSize = *outSize;

  Lzma2Dec_Init(&_state);
  
  _inPos = _inSize = 0;
  _inSizeProcessed = _outSizeProcessed = 0;
  return S_OK;
}

STDMETHODIMP CDecoder::SetFinishMode(UInt32 finishMode)
{
  _finishMode = (finishMode != 0);
  return S_OK;
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream,
    ISequentialOutStream *outStream, const UInt64 *inSize,
    const UInt64 *outSize, ICompressProgressInfo *progress)
{
  if (!_inBuf)
    return S_FALSE;
  SetOutStreamSize(outSize);

  UInt32 step = _outStepSize;
  const UInt32 kOutStepSize_Min = 1 << 12;
  if (step < kOutStepSize_Min)
    step = kOutStepSize_Min;
  
  SizeT wrPos = _state.decoder.dicPos;

  SizeT next = (_state.decoder.dicBufSize - _state.decoder.dicPos < step) ?
      _state.decoder.dicBufSize :
      _state.decoder.dicPos + step;

  HRESULT hres = S_OK;

  for (;;)
  {
    if (_inPos == _inSize)
    {
      _inPos = _inSize = 0;
      hres = inStream->Read(_inBuf, _inBufSize, &_inSize);
      if (hres != S_OK)
        break;
    }

    SizeT dicPos = _state.decoder.dicPos;
    SizeT curSize = next - dicPos;
   
    ELzmaFinishMode finishMode = LZMA_FINISH_ANY;
    if (_outSizeDefined)
    {
      const UInt64 rem = _outSize - _outSizeProcessed;
      if (curSize >= rem)
      {
        curSize = (SizeT)rem;
        if (_finishMode)
          finishMode = LZMA_FINISH_END;
      }
    }

    SizeT inSizeProcessed = _inSize - _inPos;
    ELzmaStatus status;
    SRes res = Lzma2Dec_DecodeToDic(&_state, dicPos + curSize, _inBuf + _inPos, &inSizeProcessed, finishMode, &status);

    _inPos += (UInt32)inSizeProcessed;
    _inSizeProcessed += inSizeProcessed;
    SizeT outSizeProcessed = _state.decoder.dicPos - dicPos;
    _outSizeProcessed += outSizeProcessed;

    bool finished = (inSizeProcessed == 0 && outSizeProcessed == 0
        || status == LZMA_STATUS_FINISHED_WITH_MARK);
    bool outFinished = (_outSizeDefined && _outSizeProcessed >= _outSize);

    if (res != 0
        || _state.decoder.dicPos >= next
        || finished
        || outFinished)
    {
      HRESULT res2 = WriteStream(outStream, _state.decoder.dic + wrPos, _state.decoder.dicPos - wrPos);

      if (_state.decoder.dicPos == _state.decoder.dicBufSize)
        _state.decoder.dicPos = 0;
      
      wrPos = _state.decoder.dicPos;

      next = (_state.decoder.dicBufSize - _state.decoder.dicPos < step) ?
          _state.decoder.dicBufSize :
          _state.decoder.dicPos + step;

      if (res != 0)
        return S_FALSE;
      RINOK(res2);

      if (finished)
      {
        if (status == LZMA_STATUS_FINISHED_WITH_MARK)
        {
          if (_finishMode && inSize && *inSize != _inSizeProcessed)
            return S_FALSE;
          if (finishMode == LZMA_FINISH_END && !outFinished)
            return S_FALSE;
          return S_OK;
        }
        return (finishMode == LZMA_FINISH_END) ? S_FALSE : S_OK;
      }

      if (outFinished && finishMode == LZMA_FINISH_ANY)
        return S_OK;
    }
    
    if (progress)
    {
      RINOK(progress->SetRatioInfo(&_inSizeProcessed, &_outSizeProcessed));
    }
  }

  HRESULT res2 = WriteStream(outStream, _state.decoder.dic + wrPos, _state.decoder.dicPos - wrPos);
  if (hres != S_OK)
    return hres;
  return res2;
}

#ifndef NO_READ_FROM_CODER

STDMETHODIMP CDecoder::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  UInt32 totalProcessed = 0;

  if (processedSize)
    *processedSize = 0;

  for (;;)
  {
    if (_inPos == _inSize)
    {
      _inPos = _inSize = 0;
      RINOK(_inStream->Read(_inBuf, _inBufSize, &_inSize));
    }
    {
      ELzmaFinishMode finishMode = LZMA_FINISH_ANY;
      if (_outSizeDefined)
      {
        const UInt64 rem = _outSize - _outSizeProcessed;
        if (rem <= size)
        {
          size = (UInt32)rem;
          if (_finishMode)
            finishMode = LZMA_FINISH_END;
        }
      }

      SizeT outProcessed = size;
      SizeT inProcessed = _inSize - _inPos;
      
      ELzmaStatus status;
      SRes res = Lzma2Dec_DecodeToBuf(&_state, (Byte *)data, &outProcessed,
          _inBuf + _inPos, &inProcessed, finishMode, &status);

      _inPos += (UInt32)inProcessed;
      _inSizeProcessed += inProcessed;
      _outSizeProcessed += outProcessed;
      size -= (UInt32)outProcessed;
      data = (Byte *)data + outProcessed;
      
      totalProcessed += (UInt32)outProcessed;
      if (processedSize)
        *processedSize = totalProcessed;

      if (res != SZ_OK)
      {
        if (totalProcessed != 0)
          return S_OK;
        return SResToHRESULT(res);
      }
      
      if (inProcessed == 0 && outProcessed == 0)
        return S_OK;
      if (status == LZMA_STATUS_FINISHED_WITH_MARK)
        return S_OK;
      if (outProcessed != 0)
      {
        if (finishMode != LZMA_FINISH_END || _outSize != _outSizeProcessed)
          return S_OK;
      }
    }
  }
}

#endif

}}
// Lzma2Decoder.h

#ifndef __LZMA2_DECODER_H
#define __LZMA2_DECODER_H

#include "../../../C/Lzma2Dec.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

namespace NCompress {
namespace NLzma2 {

class CDecoder:
  public ICompressCoder,
  public ICompressSetDecoderProperties2,
  public ICompressSetFinishMode,
  public ICompressGetInStreamProcessedSize,
  public ICompressSetBufSize,
  #ifndef NO_READ_FROM_CODER
  public ICompressSetInStream,
  public ICompressSetOutStreamSize,
  public ISequentialInStream,
  #endif
  public CMyUnknownImp
{
  CMyComPtr<ISequentialInStream> _inStream;
  Byte *_inBuf;
  UInt32 _inPos;
  UInt32 _inSize;

  bool _finishMode;
  bool _outSizeDefined;
  UInt64 _outSize;

  UInt64 _inSizeProcessed;
  UInt64 _outSizeProcessed;
  
  UInt32 _inBufSize;
  UInt32 _inBufSizeNew;
  UInt32 _outStepSize;

  CLzma2Dec _state;
public:

  MY_QUERYINTERFACE_BEGIN2(ICompressCoder)
  MY_QUERYINTERFACE_ENTRY(ICompressSetDecoderProperties2)
  MY_QUERYINTERFACE_ENTRY(ICompressSetFinishMode)
  MY_QUERYINTERFACE_ENTRY(ICompressGetInStreamProcessedSize)
  MY_QUERYINTERFACE_ENTRY(ICompressSetBufSize)
  #ifndef NO_READ_FROM_CODER
  MY_QUERYINTERFACE_ENTRY(ICompressSetInStream)
  MY_QUERYINTERFACE_ENTRY(ICompressSetOutStreamSize)
  MY_QUERYINTERFACE_ENTRY(ISequentialInStream)
  #endif
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);

  STDMETHOD(SetFinishMode)(UInt32 finishMode);

  STDMETHOD(GetInStreamProcessedSize)(UInt64 *value);

  STDMETHOD(SetInBufSize)(UInt32 streamIndex, UInt32 size);
  STDMETHOD(SetOutBufSize)(UInt32 streamIndex, UInt32 size);

  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
  STDMETHOD(ReleaseInStream)();
  
  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);

  #ifndef NO_READ_FROM_CODER
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  #endif

  CDecoder();
  virtual ~CDecoder();

};

}}

#endif
// Lzma2Encoder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "../Common/CWrappers.h"
#include "../Common/StreamUtils.h"

#include "Lzma2Encoder.h"

namespace NCompress {

namespace NLzma {

HRESULT SetLzmaProp(PROPID propID, const PROPVARIANT &prop, CLzmaEncProps &ep);

}

namespace NLzma2 {

CEncoder::CEncoder()
{
  _encoder = 0;
  _encoder = Lzma2Enc_Create(&g_Alloc, &g_BigAlloc);
  if (_encoder == 0)
    throw 1;
}

CEncoder::~CEncoder()
{
  if (_encoder != 0)
    Lzma2Enc_Destroy(_encoder);
}

HRESULT SetLzma2Prop(PROPID propID, const PROPVARIANT &prop, CLzma2EncProps &lzma2Props)
{
  switch (propID)
  {
    case NCoderPropID::kBlockSize:
    {
      if (prop.vt == VT_UI4)
        lzma2Props.blockSize = prop.ulVal;
      else if (prop.vt == VT_UI8)
      {
        size_t v = (size_t)prop.uhVal.QuadPart;
        if (v != prop.uhVal.QuadPart)
          return E_INVALIDARG;
        lzma2Props.blockSize = v;
      }
      else
        return E_INVALIDARG;
      break;
    }
    case NCoderPropID::kNumThreads:
      if (prop.vt != VT_UI4) return E_INVALIDARG; lzma2Props.numTotalThreads = (int)(prop.ulVal); break;
    default:
      RINOK(NLzma::SetLzmaProp(propID, prop, lzma2Props.lzmaProps));
  }
  return S_OK;
}

STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs,
    const PROPVARIANT *coderProps, UInt32 numProps)
{
  CLzma2EncProps lzma2Props;
  Lzma2EncProps_Init(&lzma2Props);

  for (UInt32 i = 0; i < numProps; i++)
  {
    RINOK(SetLzma2Prop(propIDs[i], coderProps[i], lzma2Props));
  }
  return SResToHRESULT(Lzma2Enc_SetProps(_encoder, &lzma2Props));
}

STDMETHODIMP CEncoder::WriteCoderProperties(ISequentialOutStream *outStream)
{
  Byte prop = Lzma2Enc_WriteProperties(_encoder);
  return WriteStream(outStream, &prop, 1);
}

STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  CSeqInStreamWrap inWrap(inStream);
  CSeqOutStreamWrap outWrap(outStream);
  CCompressProgressWrap progressWrap(progress);

  SRes res = Lzma2Enc_Encode(_encoder, &outWrap.p, &inWrap.p, progress ? &progressWrap.p : NULL);
  if (res == SZ_ERROR_READ && inWrap.Res != S_OK)
    return inWrap.Res;
  if (res == SZ_ERROR_WRITE && outWrap.Res != S_OK)
    return outWrap.Res;
  if (res == SZ_ERROR_PROGRESS && progressWrap.Res != S_OK)
    return progressWrap.Res;
  return SResToHRESULT(res);
}
  
}}
// Lzma2Encoder.h

#ifndef __LZMA2_ENCODER_H
#define __LZMA2_ENCODER_H

#include "../../../C/Lzma2Enc.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

namespace NCompress {
namespace NLzma2 {

class CEncoder:
  public ICompressCoder,
  public ICompressSetCoderProperties,
  public ICompressWriteCoderProperties,
  public CMyUnknownImp
{
  CLzma2EncHandle _encoder;
public:
  MY_UNKNOWN_IMP3(ICompressCoder, ICompressSetCoderProperties, ICompressWriteCoderProperties)
 
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
  STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStream);

  CEncoder();
  virtual ~CEncoder();
};

}}

#endif
// Lzma2Register.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "Lzma2Decoder.h"

#ifndef EXTRACT_ONLY
#include "Lzma2Encoder.h"
#endif

namespace NCompress {
namespace NLzma2 {

REGISTER_CODEC_E(LZMA2,
    CDecoder(),
    CEncoder(),
    0x21,
    "LZMA2")

}}
// LzmaDecoder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "../Common/StreamUtils.h"

#include "LzmaDecoder.h"

static HRESULT SResToHRESULT(SRes res)
{
  switch (res)
  {
    case SZ_OK: return S_OK;
    case SZ_ERROR_MEM: return E_OUTOFMEMORY;
    case SZ_ERROR_PARAM: return E_INVALIDARG;
    case SZ_ERROR_UNSUPPORTED: return E_NOTIMPL;
    case SZ_ERROR_DATA: return S_FALSE;
  }
  return E_FAIL;
}

namespace NCompress {
namespace NLzma {

CDecoder::CDecoder(): _inBuf(0), _propsWereSet(false), _outSizeDefined(false),
    _inBufSize(1 << 20),
    _outBufSize(1 << 22),
    FinishStream(false),
    NeedMoreInput(false)
{
  _inSizeProcessed = 0;
  _inPos = _inSize = 0;
  LzmaDec_Construct(&_state);
}

CDecoder::~CDecoder()
{
  LzmaDec_Free(&_state, &g_Alloc);
  MyFree(_inBuf);
}

STDMETHODIMP CDecoder::SetInBufSize(UInt32 , UInt32 size) { _inBufSize = size; return S_OK; }
STDMETHODIMP CDecoder::SetOutBufSize(UInt32 , UInt32 size) { _outBufSize = size; return S_OK; }

HRESULT CDecoder::CreateInputBuffer()
{
  if (_inBuf == 0 || _inBufSize != _inBufSizeAllocated)
  {
    MyFree(_inBuf);
    _inBuf = (Byte *)MyAlloc(_inBufSize);
    if (_inBuf == 0)
      return E_OUTOFMEMORY;
    _inBufSizeAllocated = _inBufSize;
  }
  return S_OK;
}

STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *prop, UInt32 size)
{
  RINOK(SResToHRESULT(LzmaDec_Allocate(&_state, prop, size, &g_Alloc)));
  _propsWereSet = true;
  return CreateInputBuffer();
}

void CDecoder::SetOutStreamSizeResume(const UInt64 *outSize)
{
  _outSizeDefined = (outSize != NULL);
  if (_outSizeDefined)
    _outSize = *outSize;
  _outSizeProcessed = 0;
  _wrPos = 0;
  LzmaDec_Init(&_state);
}

STDMETHODIMP CDecoder::SetOutStreamSize(const UInt64 *outSize)
{
  _inSizeProcessed = 0;
  _inPos = _inSize = 0;
  NeedMoreInput = false;
  SetOutStreamSizeResume(outSize);
  return S_OK;
}

STDMETHODIMP CDecoder::SetFinishMode(UInt32 finishMode)
{
  FinishStream = (finishMode != 0);
  return S_OK;
}

HRESULT CDecoder::CodeSpec(ISequentialInStream *inStream, ISequentialOutStream *outStream, ICompressProgressInfo *progress)
{
  if (_inBuf == 0 || !_propsWereSet)
    return S_FALSE;

  UInt64 startInProgress = _inSizeProcessed;

  SizeT next = (_state.dicBufSize - _state.dicPos < _outBufSize) ? _state.dicBufSize : (_state.dicPos + _outBufSize);
  for (;;)
  {
    if (_inPos == _inSize)
    {
      _inPos = _inSize = 0;
      RINOK(inStream->Read(_inBuf, _inBufSizeAllocated, &_inSize));
    }

    SizeT dicPos = _state.dicPos;
    SizeT curSize = next - dicPos;
    
    ELzmaFinishMode finishMode = LZMA_FINISH_ANY;
    if (_outSizeDefined)
    {
      const UInt64 rem = _outSize - _outSizeProcessed;
      if (rem <= curSize)
      {
        curSize = (SizeT)rem;
        if (FinishStream)
          finishMode = LZMA_FINISH_END;
      }
    }

    SizeT inSizeProcessed = _inSize - _inPos;
    ELzmaStatus status;
    SRes res = LzmaDec_DecodeToDic(&_state, dicPos + curSize, _inBuf + _inPos, &inSizeProcessed, finishMode, &status);

    _inPos += (UInt32)inSizeProcessed;
    _inSizeProcessed += inSizeProcessed;
    SizeT outSizeProcessed = _state.dicPos - dicPos;
    _outSizeProcessed += outSizeProcessed;

    bool finished = (inSizeProcessed == 0 && outSizeProcessed == 0);
    bool stopDecoding = (_outSizeDefined && _outSizeProcessed >= _outSize);

    if (res != 0 || _state.dicPos == next || finished || stopDecoding)
    {
      HRESULT res2 = WriteStream(outStream, _state.dic + _wrPos, _state.dicPos - _wrPos);

      _wrPos = _state.dicPos;
      if (_state.dicPos == _state.dicBufSize)
      {
        _state.dicPos = 0;
        _wrPos = 0;
      }
      next = (_state.dicBufSize - _state.dicPos < _outBufSize) ? _state.dicBufSize : (_state.dicPos + _outBufSize);

      if (res != 0)
        return S_FALSE;
      RINOK(res2);
      if (stopDecoding)
      {
        if (status == LZMA_STATUS_NEEDS_MORE_INPUT)
          NeedMoreInput = true;
        if (FinishStream &&
              status != LZMA_STATUS_FINISHED_WITH_MARK &&
              status != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK)
          return S_FALSE;
        return S_OK;
      }
      if (finished)
      {
        if (status == LZMA_STATUS_NEEDS_MORE_INPUT)
          NeedMoreInput = true;
        return (status == LZMA_STATUS_FINISHED_WITH_MARK ? S_OK : S_FALSE);
      }
    }
    if (progress)
    {
      UInt64 inSize = _inSizeProcessed - startInProgress;
      RINOK(progress->SetRatioInfo(&inSize, &_outSizeProcessed));
    }
  }
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  if (_inBuf == 0)
    return E_INVALIDARG;
  SetOutStreamSize(outSize);
  return CodeSpec(inStream, outStream, progress);
}

#ifndef NO_READ_FROM_CODER

STDMETHODIMP CDecoder::SetInStream(ISequentialInStream *inStream) { _inStream = inStream; return S_OK; }
STDMETHODIMP CDecoder::ReleaseInStream() { _inStream.Release(); return S_OK; }

STDMETHODIMP CDecoder::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  if (processedSize)
    *processedSize = 0;
  do
  {
    if (_inPos == _inSize)
    {
      _inPos = _inSize = 0;
      RINOK(_inStream->Read(_inBuf, _inBufSizeAllocated, &_inSize));
    }
    {
      SizeT inProcessed = _inSize - _inPos;

      if (_outSizeDefined)
      {
        const UInt64 rem = _outSize - _outSizeProcessed;
        if (rem < size)
          size = (UInt32)rem;
      }

      SizeT outProcessed = size;
      ELzmaStatus status;
      SRes res = LzmaDec_DecodeToBuf(&_state, (Byte *)data, &outProcessed,
          _inBuf + _inPos, &inProcessed, LZMA_FINISH_ANY, &status);
      _inPos += (UInt32)inProcessed;
      _inSizeProcessed += inProcessed;
      _outSizeProcessed += outProcessed;
      size -= (UInt32)outProcessed;
      data = (Byte *)data + outProcessed;
      if (processedSize)
        *processedSize += (UInt32)outProcessed;
      RINOK(SResToHRESULT(res));
      if (inProcessed == 0 && outProcessed == 0)
        return S_OK;
    }
  }
  while (size != 0);
  return S_OK;
}

HRESULT CDecoder::CodeResume(ISequentialOutStream *outStream, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  SetOutStreamSizeResume(outSize);
  return CodeSpec(_inStream, outStream, progress);
}

HRESULT CDecoder::ReadFromInputStream(void *data, UInt32 size, UInt32 *processedSize)
{
  RINOK(CreateInputBuffer());
  if (processedSize)
    *processedSize = 0;
  while (size > 0)
  {
    if (_inPos == _inSize)
    {
      _inPos = _inSize = 0;
      RINOK(_inStream->Read(_inBuf, _inBufSizeAllocated, &_inSize));
      if (_inSize == 0)
        break;
    }
    {
      UInt32 curSize = _inSize - _inPos;
      if (curSize > size)
        curSize = size;
      memcpy(data, _inBuf + _inPos, curSize);
      _inPos += curSize;
      _inSizeProcessed += curSize;
      size -= curSize;
      data = (Byte *)data + curSize;
      if (processedSize)
        *processedSize += curSize;
    }
  }
  return S_OK;
}

#endif

}}
// LzmaDecoder.h

#ifndef __LZMA_DECODER_H
#define __LZMA_DECODER_H

#include "../../../C/LzmaDec.h"

#include "../../Common/MyCom.h"
#include "../ICoder.h"

namespace NCompress {
namespace NLzma {

class CDecoder:
  public ICompressCoder,
  public ICompressSetDecoderProperties2,
  public ICompressSetFinishMode,
  public ICompressSetBufSize,
  #ifndef NO_READ_FROM_CODER
  public ICompressSetInStream,
  public ICompressSetOutStreamSize,
  public ISequentialInStream,
  #endif
  public CMyUnknownImp
{
  CMyComPtr<ISequentialInStream> _inStream;
  Byte *_inBuf;
  UInt32 _inPos;
  UInt32 _inSize;
  CLzmaDec _state;
  bool _propsWereSet;
  bool _outSizeDefined;
  UInt64 _outSize;
  UInt64 _inSizeProcessed;
  UInt64 _outSizeProcessed;

  UInt32 _inBufSizeAllocated;
  UInt32 _inBufSize;
  UInt32 _outBufSize;
  SizeT _wrPos;

  HRESULT CreateInputBuffer();
  HRESULT CodeSpec(ISequentialInStream *inStream, ISequentialOutStream *outStream, ICompressProgressInfo *progress);
  void SetOutStreamSizeResume(const UInt64 *outSize);

public:
  MY_QUERYINTERFACE_BEGIN2(ICompressCoder)
  MY_QUERYINTERFACE_ENTRY(ICompressSetDecoderProperties2)
  MY_QUERYINTERFACE_ENTRY(ICompressSetFinishMode)
  MY_QUERYINTERFACE_ENTRY(ICompressSetBufSize)
  #ifndef NO_READ_FROM_CODER
  MY_QUERYINTERFACE_ENTRY(ICompressSetInStream)
  MY_QUERYINTERFACE_ENTRY(ICompressSetOutStreamSize)
  MY_QUERYINTERFACE_ENTRY(ISequentialInStream)
  #endif
  MY_QUERYINTERFACE_END
  MY_ADDREF_RELEASE

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);
  STDMETHOD(SetFinishMode)(UInt32 finishMode);
  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);
  STDMETHOD(SetInBufSize)(UInt32 streamIndex, UInt32 size);
  STDMETHOD(SetOutBufSize)(UInt32 streamIndex, UInt32 size);

  #ifndef NO_READ_FROM_CODER
  
  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
  STDMETHOD(ReleaseInStream)();
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);

  HRESULT CodeResume(ISequentialOutStream *outStream, const UInt64 *outSize, ICompressProgressInfo *progress);
  HRESULT ReadFromInputStream(void *data, UInt32 size, UInt32 *processedSize);
  UInt64 GetInputProcessedSize() const { return _inSizeProcessed; }

  #endif

  bool FinishStream; // set it before decoding, if you need to decode full LZMA stream
  
  bool NeedMoreInput; // it's set by decoder, if it needs more input data to decode stream

  CDecoder();
  virtual ~CDecoder();

  UInt64 GetOutputProcessedSize() const { return _outSizeProcessed; }
};

}}

#endif
// LzmaEncoder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "../Common/CWrappers.h"
#include "../Common/StreamUtils.h"

#include "LzmaEncoder.h"

namespace NCompress {
namespace NLzma {

CEncoder::CEncoder()
{
  _encoder = NULL;
  _encoder = LzmaEnc_Create(&g_Alloc);
  if (!_encoder)
    throw 1;
}

CEncoder::~CEncoder()
{
  if (_encoder)
    LzmaEnc_Destroy(_encoder, &g_Alloc, &g_BigAlloc);
}

static inline wchar_t GetUpperChar(wchar_t c)
{
  if (c >= 'a' && c <= 'z')
    c -= 0x20;
  return c;
}

static int ParseMatchFinder(const wchar_t *s, int *btMode, int *numHashBytes)
{
  wchar_t c = GetUpperChar(*s++);
  if (c == L'H')
  {
    if (GetUpperChar(*s++) != L'C')
      return 0;
    int numHashBytesLoc = (int)(*s++ - L'0');
    if (numHashBytesLoc < 4 || numHashBytesLoc > 4)
      return 0;
    if (*s != 0)
      return 0;
    *btMode = 0;
    *numHashBytes = numHashBytesLoc;
    return 1;
  }

  if (c != L'B')
    return 0;
  if (GetUpperChar(*s++) != L'T')
    return 0;
  int numHashBytesLoc = (int)(*s++ - L'0');
  if (numHashBytesLoc < 2 || numHashBytesLoc > 4)
    return 0;
  if (*s != 0)
    return 0;
  *btMode = 1;
  *numHashBytes = numHashBytesLoc;
  return 1;
}

#define SET_PROP_32(_id_, _dest_) case NCoderPropID::_id_: ep._dest_ = v; break;

HRESULT SetLzmaProp(PROPID propID, const PROPVARIANT &prop, CLzmaEncProps &ep)
{
  if (propID == NCoderPropID::kMatchFinder)
  {
    if (prop.vt != VT_BSTR)
      return E_INVALIDARG;
    return ParseMatchFinder(prop.bstrVal, &ep.btMode, &ep.numHashBytes) ? S_OK : E_INVALIDARG;
  }
  if (propID > NCoderPropID::kReduceSize)
    return S_OK;
  if (propID == NCoderPropID::kReduceSize)
  {
    if (prop.vt == VT_UI8)
      ep.reduceSize = prop.uhVal.QuadPart;
    return S_OK;
  }
  if (prop.vt != VT_UI4)
    return E_INVALIDARG;
  UInt32 v = prop.ulVal;
  switch (propID)
  {
    case NCoderPropID::kDefaultProp: if (v > 31) return E_INVALIDARG; ep.dictSize = (UInt32)1 << (unsigned)v; break;
    SET_PROP_32(kLevel, level)
    SET_PROP_32(kNumFastBytes, fb)
    SET_PROP_32(kMatchFinderCycles, mc)
    SET_PROP_32(kAlgorithm, algo)
    SET_PROP_32(kDictionarySize, dictSize)
    SET_PROP_32(kPosStateBits, pb)
    SET_PROP_32(kLitPosBits, lp)
    SET_PROP_32(kLitContextBits, lc)
    SET_PROP_32(kNumThreads, numThreads)
    default: return E_INVALIDARG;
  }
  return S_OK;
}

STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs,
    const PROPVARIANT *coderProps, UInt32 numProps)
{
  CLzmaEncProps props;
  LzmaEncProps_Init(&props);

  for (UInt32 i = 0; i < numProps; i++)
  {
    const PROPVARIANT &prop = coderProps[i];
    PROPID propID = propIDs[i];
    switch (propID)
    {
      case NCoderPropID::kEndMarker:
        if (prop.vt != VT_BOOL) return E_INVALIDARG; props.writeEndMark = (prop.boolVal != VARIANT_FALSE); break;
      default:
        RINOK(SetLzmaProp(propID, prop, props));
    }
  }
  return SResToHRESULT(LzmaEnc_SetProps(_encoder, &props));
}

STDMETHODIMP CEncoder::WriteCoderProperties(ISequentialOutStream *outStream)
{
  Byte props[LZMA_PROPS_SIZE];
  size_t size = LZMA_PROPS_SIZE;
  RINOK(LzmaEnc_WriteProperties(_encoder, props, &size));
  return WriteStream(outStream, props, size);
}

STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  CSeqInStreamWrap inWrap(inStream);
  CSeqOutStreamWrap outWrap(outStream);
  CCompressProgressWrap progressWrap(progress);

  SRes res = LzmaEnc_Encode(_encoder, &outWrap.p, &inWrap.p, progress ? &progressWrap.p : NULL, &g_Alloc, &g_BigAlloc);
  _inputProcessed = inWrap.Processed;
  if (res == SZ_ERROR_READ && inWrap.Res != S_OK)
    return inWrap.Res;
  if (res == SZ_ERROR_WRITE && outWrap.Res != S_OK)
    return outWrap.Res;
  if (res == SZ_ERROR_PROGRESS && progressWrap.Res != S_OK)
    return progressWrap.Res;
  return SResToHRESULT(res);
}

}}
// LzmaEncoder.h

#ifndef __LZMA_ENCODER_H
#define __LZMA_ENCODER_H

#include "../../../C/LzmaEnc.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

namespace NCompress {
namespace NLzma {

class CEncoder:
  public ICompressCoder,
  public ICompressSetCoderProperties,
  public ICompressWriteCoderProperties,
  public CMyUnknownImp
{
  CLzmaEncHandle _encoder;
  UInt64 _inputProcessed;
public:
  MY_UNKNOWN_IMP3(ICompressCoder, ICompressSetCoderProperties, ICompressWriteCoderProperties)
    
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
  STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStream);

  CEncoder();
  virtual ~CEncoder();
  UInt64 GetInputProcessedSize() const { return _inputProcessed; }
};

}}

#endif
// LzmaRegister.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "LzmaDecoder.h"

#ifndef EXTRACT_ONLY
#include "LzmaEncoder.h"
#endif

namespace NCompress {
namespace NLzma {

REGISTER_CODEC_E(LZMA,
    CDecoder(),
    CEncoder(),
    0x30101,
    "LZMA")

}}
// LzmsDecoder.cpp
// The code is based on LZMS description from wimlib code

#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "LzmsDecoder.h"

namespace NCompress {
namespace NLzms {

static UInt32 g_PosBases[k_NumPosSyms /* + 1 */];

static Byte g_PosDirectBits[k_NumPosSyms];

static const Byte k_PosRuns[31] =
{
  8, 0, 9, 7, 10, 15, 15, 20, 20, 30, 33, 40, 42, 45, 60, 73,
  80, 85, 95, 105, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
};

static UInt32 g_LenBases[k_NumLenSyms];

static const Byte k_LenDirectBits[k_NumLenSyms] =
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2,
  2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 6,
  7, 8, 9, 10, 16, 30,
};

static struct CInit
{
  CInit()
  {
    {
      unsigned sum = 0;
      for (unsigned i = 0; i < sizeof(k_PosRuns); i++)
      {
        unsigned t = k_PosRuns[i];
        for (unsigned y = 0; y < t; y++)
          g_PosDirectBits[sum + y] = (Byte)i;
        sum += t;
      }
    }
    {
      UInt32 sum = 1;
      for (unsigned i = 0; i < k_NumPosSyms; i++)
      {
        g_PosBases[i] = sum;
        sum += (UInt32)1 << g_PosDirectBits[i];
      }
      // g_PosBases[k_NumPosSyms] = sum;
    }
    {
      UInt32 sum = 1;
      for (unsigned i = 0; i < k_NumLenSyms; i++)
      {
        g_LenBases[i] = sum;
        sum += (UInt32)1 << k_LenDirectBits[i];
      }
    }
  }
} g_Init;

static unsigned GetNumPosSlots(size_t size)
{
  if (size < 2)
    return 0;
  
  size--;

  if (size >= g_PosBases[k_NumPosSyms - 1])
    return k_NumPosSyms;
  unsigned left = 0;
  unsigned right = k_NumPosSyms;
  for (;;)
  {
    unsigned m = (left + right) / 2;
    if (left == m)
      return m + 1;
    if (size >= g_PosBases[m])
      left = m;
    else
      right = m;
  }
}


static const Int32 k_x86_WindowSize = 65535;
static const Int32 k_x86_TransOffset = 1023;

static const size_t k_x86_HistorySize = (1 << 16);

static void x86_Filter(Byte *data, UInt32 size, Int32 *history)
{
  if (size <= 17)
    return;

  Byte isCode[256];
  memset(isCode, 0, 256);
  isCode[0x48] = 1;
  isCode[0x4C] = 1;
  isCode[0xE8] = 1;
  isCode[0xE9] = 1;
  isCode[0xF0] = 1;
  isCode[0xFF] = 1;

  {
    for (size_t i = 0; i < k_x86_HistorySize; i++)
      history[i] = -(Int32)k_x86_WindowSize - 1;
  }

  size -= 16;
  const unsigned kSave = 6;
  const Byte savedByte = data[size + kSave];
  data[size + kSave] = 0xE8;
  Int32 last_x86_pos = -k_x86_TransOffset - 1;

  // first byte is ignored
  Int32 i = 0;
  
  for (;;)
  {
    const Byte *p = data + (UInt32)i;

    for (;;)
    {
      if (isCode[*(++p)]) break;
      if (isCode[*(++p)]) break;
    }
    
    i = (Int32)(p - data);
    if ((UInt32)i >= size)
      break;

    UInt32 codeLen;

    Int32 maxTransOffset = k_x86_TransOffset;
    
    Byte b = p[0];
    
    if (b == 0x48)
    {
      if (p[1] == 0x8B)
      {
        if ((p[2] & 0xF7) != 0x5)
          continue;
        // MOV RAX / RCX, [RIP + disp32]
      }
      else if (p[1] == 0x8D) // LEA
      {
        if ((p[2] & 0x7) != 0x5)
          continue;
        // LEA R**, []
      }
      else
        continue;
      codeLen = 3;
    }
    else if (b == 0x4C)
    {
      if (p[1] != 0x8D || (p[2] & 0x7) != 0x5)
        continue;
      // LEA R*, []
      codeLen = 3;
    }
    else if (b == 0xE8)
    {
      // CALL
      codeLen = 1;
      maxTransOffset /= 2;
    }
    else if (b == 0xE9)
    {
      // JUMP
      i += 4;
      continue;
    }
    else if (b == 0xF0)
    {
      if (p[1] != 0x83 || p[2] != 0x05)
        continue;
      // LOCK ADD [RIP + disp32], imm8
      // LOCK ADD [disp32], imm8
      codeLen = 3;
    }
    else
    // if (b == 0xFF)
    {
      if (p[1] != 0x15)
        continue;
      // CALL [RIP + disp32];
      // CALL [disp32];
      codeLen = 2;
    }

    Int32 *target;
    {
      const Byte *p2 = p + codeLen;
      UInt32 n = GetUi32(p2);
      if (i - last_x86_pos <= maxTransOffset)
      {
        n -= i;
        SetUi32(p2, n);
      }
      target = history + (((UInt32)i + n) & 0xFFFF);
    }

    i += codeLen + sizeof(UInt32) - 1;

    if (i - *target <= k_x86_WindowSize)
      last_x86_pos = i;
    *target = i;
  }

  data[size + kSave] = savedByte;
}



static const int kLenIdNeedInit = -2;

CDecoder::CDecoder():
  _x86_history(NULL)
{
}

CDecoder::~CDecoder()
{
  ::MidFree(_x86_history);
}

#define RIF(x) { if (!(x)) return false; }

#define LIMIT_CHECK if (_bs._buf < _rc.cur) return S_FALSE;
// #define LIMIT_CHECK

#define READ_BITS_CHECK(numDirectBits) \
  if (_bs._buf < _rc.cur) return S_FALSE; \
  if ((size_t)(_bs._buf - _rc.cur) < (numDirectBits >> 3)) return S_FALSE;


#define HUFF_DEC(sym, pp) \
    sym = pp.DecodeFull(&_bs); \
    pp.Freqs[sym]++; \
    if (--pp.RebuildRem == 0) pp.Rebuild();


HRESULT CDecoder::CodeReal(const Byte *in, size_t inSize, Byte *_win, size_t outSize)
{
  // size_t inSizeT = (size_t)(inSize);
  // Byte *_win;
  // size_t _pos;
  _pos = 0;

  CBitDecoder _bs;
  CRangeDecoder _rc;
 
  if (inSize < 8 || (inSize & 1) != 0)
    return S_FALSE;
  _rc.Init(in, inSize);
  if (_rc.code >= _rc.range)
    return S_FALSE;
  _bs.Init(in, inSize);

  {
    {
      {
        for (unsigned i = 0 ; i < k_NumReps + 1; i++)
          _reps[i] = i + 1;
      }

      {
        for (unsigned i = 0 ; i < k_NumReps + 1; i++)
          _deltaReps[i] = i + 1;
      }

      mainState = 0;
      matchState = 0;

      { for (size_t i = 0; i < k_NumMainProbs; i++) mainProbs[i].Init(); }
      { for (size_t i = 0; i < k_NumMatchProbs; i++) matchProbs[i].Init(); }

      {
        for (size_t k = 0; k < k_NumReps; k++)
        {
          lzRepStates[k] = 0;
          for (size_t i = 0; i < k_NumRepProbs; i++)
            lzRepProbs[k][i].Init();
        }
      }
      {
        for (size_t k = 0; k < k_NumReps; k++)
        {
          deltaRepStates[k] = 0;
          for (size_t i = 0; i < k_NumRepProbs; i++)
            deltaRepProbs[k][i].Init();
        }
      }

      m_LitDecoder.Init();
      m_LenDecoder.Init();
      m_PowerDecoder.Init();
      unsigned numPosSyms = GetNumPosSlots(outSize);
      if (numPosSyms < 2)
        numPosSyms = 2;
      m_PosDecoder.Init(numPosSyms);
      m_DeltaDecoder.Init(numPosSyms);
    }
  }

  {
    unsigned prevType = 0;
    
    while (_pos < outSize)
    {
      if (_rc.Decode(&mainState, k_NumMainProbs, mainProbs) == 0)
      {
        UInt32 number;
        HUFF_DEC(number, m_LitDecoder);
        LIMIT_CHECK
        _win[_pos++] = (Byte)number;
        prevType = 0;
      }
      else if (_rc.Decode(&matchState, k_NumMatchProbs, matchProbs) == 0)
      {
        UInt32 distance;
        
        if (_rc.Decode(&lzRepStates[0], k_NumRepProbs, lzRepProbs[0]) == 0)
        {
          UInt32 number;
          HUFF_DEC(number, m_PosDecoder);
          LIMIT_CHECK

          unsigned numDirectBits = g_PosDirectBits[number];
          distance = g_PosBases[number];
          READ_BITS_CHECK(numDirectBits);
          distance += _bs.ReadBits32(numDirectBits);
          // LIMIT_CHECK
          _reps[3] = _reps[2];
          _reps[2] = _reps[1];
          _reps[1] = _reps[0];
          _reps[0] = distance;
        }
        else
        {
          if (_rc.Decode(&lzRepStates[1], k_NumRepProbs, lzRepProbs[1]) == 0)
          {
            if (prevType != 1)
              distance = _reps[0];
            else
            {
              distance = _reps[1];
              _reps[1] = _reps[0];
              _reps[0] = distance;
            }
          }
          else if (_rc.Decode(&lzRepStates[2], k_NumRepProbs, lzRepProbs[2]) == 0)
          {
            if (prevType != 1)
            {
              distance = _reps[1];
              _reps[1] = _reps[0];
              _reps[0] = distance;
            }
            else
            {
              distance = _reps[2];
              _reps[2] = _reps[1];
              _reps[1] = _reps[0];
              _reps[0] = distance;
            }
          }
          else
          {
            if (prevType != 1)
            {
              distance = _reps[2];
              _reps[2] = _reps[1];
              _reps[1] = _reps[0];
              _reps[0] = distance;
            }
            else
            {
              distance = _reps[3];
              _reps[3] = _reps[2];
              _reps[2] = _reps[1];
              _reps[1] = _reps[0];
              _reps[0] = distance;
            }
          }
        }

        UInt32 lenSlot;
        HUFF_DEC(lenSlot, m_LenDecoder);
        LIMIT_CHECK

        UInt32 len = g_LenBases[lenSlot];
        {
          unsigned numDirectBits = k_LenDirectBits[lenSlot];
          READ_BITS_CHECK(numDirectBits);
          len += _bs.ReadBits32(numDirectBits);
        }
        // LIMIT_CHECK

        if (len > outSize - _pos)
          return S_FALSE;

        if (distance > _pos)
          return S_FALSE;

        Byte *dest = _win + _pos;
        const Byte *src = dest - distance;
        _pos += len;
        do
          *dest++ = *src++;
        while (--len);

        prevType = 1;
      }
      else
      {
        UInt64 distance;

        UInt32 power;
        UInt32 distance32;
        
        if (_rc.Decode(&deltaRepStates[0], k_NumRepProbs, deltaRepProbs[0]) == 0)
        {
          HUFF_DEC(power, m_PowerDecoder);
          LIMIT_CHECK

          UInt32 number;
          HUFF_DEC(number, m_DeltaDecoder);
          LIMIT_CHECK

          unsigned numDirectBits = g_PosDirectBits[number];
          distance32 = g_PosBases[number];
          READ_BITS_CHECK(numDirectBits);
          distance32 += _bs.ReadBits32(numDirectBits);
          // LIMIT_CHECK

          distance = ((UInt64)power << 32) | distance32;

          _deltaReps[3] = _deltaReps[2];
          _deltaReps[2] = _deltaReps[1];
          _deltaReps[1] = _deltaReps[0];
          _deltaReps[0] = distance;
        }
        else
        {
          if (_rc.Decode(&deltaRepStates[1], k_NumRepProbs, deltaRepProbs[1]) == 0)
          {
            if (prevType != 2)
              distance = _deltaReps[0];
            else
            {
              distance = _deltaReps[1];
              _deltaReps[1] = _deltaReps[0];
              _deltaReps[0] = distance;
            }
          }
          else if (_rc.Decode(&deltaRepStates[2], k_NumRepProbs, deltaRepProbs[2]) == 0)
          {
            if (prevType != 2)
            {
              distance = _deltaReps[1];
              _deltaReps[1] = _deltaReps[0];
              _deltaReps[0] = distance;
            }
            else
            {
              distance = _deltaReps[2];
              _deltaReps[2] = _deltaReps[1];
              _deltaReps[1] = _deltaReps[0];
              _deltaReps[0] = distance;
            }
          }
          else
          {
            if (prevType != 2)
            {
              distance = _deltaReps[2];
              _deltaReps[2] = _deltaReps[1];
              _deltaReps[1] = _deltaReps[0];
              _deltaReps[0] = distance;
            }
            else
            {
              distance = _deltaReps[3];
              _deltaReps[3] = _deltaReps[2];
              _deltaReps[2] = _deltaReps[1];
              _deltaReps[1] = _deltaReps[0];
              _deltaReps[0] = distance;
            }
          }
          distance32 = (UInt32)_deltaReps[0] & 0xFFFFFFFF;
          power = (UInt32)(_deltaReps[0] >> 32);
        }

        UInt32 dist = (distance32 << power);
        
        UInt32 lenSlot;
        HUFF_DEC(lenSlot, m_LenDecoder);
        LIMIT_CHECK

        UInt32 len = g_LenBases[lenSlot];
        {
          unsigned numDirectBits = k_LenDirectBits[lenSlot];
          READ_BITS_CHECK(numDirectBits);
          len += _bs.ReadBits32(numDirectBits);
        }
        // LIMIT_CHECK

        if (len > outSize - _pos)
          return S_FALSE;

        if (dist > _pos)
          return S_FALSE;
        size_t span = (size_t)1 << power;
        Byte *dest = _win + _pos - span;
        const Byte *src = dest - dist;
        _pos += len;
        do
        {
          *(dest + span) = (Byte)(*(dest) + *(src + span) - *(src));
          src++;
          dest++;
        }
        while (--len);

        prevType = 2;
      }
    }
  }

  _rc.Normalize();
  if (_rc.code != 0)
    return S_FALSE;
  if (_rc.cur > _bs._buf ||
      _rc.cur == _bs._buf && _bs._bitPos != 0)
    return S_FALSE;

  /*
  int delta = (int)(_bs._buf - _rc.cur);
  if (_bs._bitPos != 0)
    delta--;
  if ((delta & 1))
    delta--;
  printf("%d ", delta);
  */

  return S_OK;
}

HRESULT CDecoder::Code(const Byte *in, size_t inSize, Byte *out, size_t outSize)
{
  if (!_x86_history)
  {
    _x86_history = (Int32 *)::MidAlloc(sizeof(Int32) * k_x86_HistorySize);
    if (!_x86_history)
      return E_OUTOFMEMORY;
  }
  HRESULT res;
  // try
  {
    res = CodeReal(in, inSize, out, outSize);
  }
  // catch (...) { res = S_FALSE; }
  x86_Filter(out, (UInt32)_pos, _x86_history);
  return res;
}

}}
// LzmsDecoder.h
// The code is based on LZMS description from wimlib code

#ifndef __LZMS_DECODER_H
#define __LZMS_DECODER_H

// #define SHOW_DEBUG_INFO

#ifdef SHOW_DEBUG_INFO
#include <stdio.h>
#define PRF(x) x
#else
// #define PRF(x)
#endif

#include "../../../C/CpuArch.h"
#include "../../../C/HuffEnc.h"

#include "../../Common/MyBuffer.h"
#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "HuffmanDecoder.h"

namespace NCompress {
namespace NLzms {

class CBitDecoder
{
public:
  const Byte *_buf;
  unsigned _bitPos;

  void Init(const Byte *buf, size_t size) throw()
  {
    _buf = buf + size;
    _bitPos = 0;
  }

  UInt32 GetValue(unsigned numBits) const
  {
    UInt32 v = ((UInt32)_buf[-1] << 16) | ((UInt32)_buf[-2] << 8) | (UInt32)_buf[-3];
    v >>= (24 - numBits - _bitPos);
    return v & ((1 << numBits) - 1);
  }
  
  void MovePos(unsigned numBits)
  {
    _bitPos += numBits;
    _buf -= (_bitPos >> 3);
    _bitPos &= 7;
  }

  UInt32 ReadBits32(unsigned numBits)
  {
    UInt32 mask = (((UInt32)1 << numBits) - 1);
    numBits += _bitPos;
    const Byte *buf = _buf;
    UInt32 v = GetUi32(buf - 4);
    if (numBits > 32)
    {
      v <<= (numBits - 32);
      v |= (UInt32)buf[-5] >> (40 - numBits);
    }
    else
      v >>= (32 - numBits);
    _buf = buf - (numBits >> 3);
    _bitPos = numBits & 7;
    return v & mask;
  }
};


const unsigned k_NumLitSyms = 256;
const unsigned k_NumLenSyms = 54;
const unsigned k_NumPosSyms = 799;
const unsigned k_NumPowerSyms = 8;

const unsigned k_NumProbBits = 6;
const unsigned k_ProbLimit = 1 << k_NumProbBits;
const unsigned k_InitialProb = 48;
const UInt32 k_InitialHist = 0x55555555;

const unsigned k_NumReps = 3;

const unsigned k_NumMainProbs  = 16;
const unsigned k_NumMatchProbs = 32;
const unsigned k_NumRepProbs   = 64;

const unsigned k_NumHuffmanBits = 15;

template <UInt32 m_NumSyms, UInt32 m_RebuildFreq, unsigned numTableBits>
class CHuffDecoder: public NCompress::NHuffman::CDecoder<k_NumHuffmanBits, m_NumSyms, numTableBits>
{
public:
  UInt32 RebuildRem;
  UInt32 NumSyms;
  UInt32 Freqs[m_NumSyms];

  void Generate() throw()
  {
    UInt32 vals[m_NumSyms];
    Byte levels[m_NumSyms];

    // We need to check that our algorithm is OK, when optimal Huffman tree uses more than 15 levels !!!
    Huffman_Generate(Freqs, vals, levels, NumSyms, k_NumHuffmanBits);

    /*
    for (UInt32 i = NumSyms; i < m_NumSyms; i++)
      levels[i] = 0;
    */
    this->BuildFull(levels, NumSyms);
  }
  
  void Rebuild() throw()
  {
    Generate();
    RebuildRem = m_RebuildFreq;
    UInt32 num = NumSyms;
    for (UInt32 i = 0; i < num; i++)
      Freqs[i] = (Freqs[i] >> 1) + 1;
  }

public:
  void Init(UInt32 numSyms = m_NumSyms) throw()
  {
    RebuildRem = m_RebuildFreq;
    NumSyms = numSyms;
    for (UInt32 i = 0; i < numSyms; i++)
      Freqs[i] = 1;
    // for (; i < m_NumSyms; i++) Freqs[i] = 0;
    Generate();
  }
};


struct CProbEntry
{
  UInt32 Prob;
  UInt64 Hist;

  void Init()
  {
    Prob = k_InitialProb;
    Hist = k_InitialHist;
  }

  UInt32 GetProb() const throw()
  {
    UInt32 prob = Prob;
    if (prob == 0)
      prob = 1;
    else if (prob == k_ProbLimit)
      prob = k_ProbLimit - 1;
    return prob;
  }

  void Update(unsigned bit) throw()
  {
    Prob += (Int32)(Hist >> (k_ProbLimit - 1)) - (Int32)bit;
    Hist = (Hist << 1) | bit;
  }
};


struct CRangeDecoder
{
  UInt32 range;
  UInt32 code;
  const Byte *cur;
  // const Byte *end;

  void Init(const Byte *data, size_t /* size */) throw()
  {
    range = 0xFFFFFFFF;
    code = (((UInt32)GetUi16(data)) << 16) | GetUi16(data + 2);
    cur = data + 4;
    // end = data + size;
  }

  void Normalize()
  {
    if (range <= 0xFFFF)
    {
      range <<= 16;
      code <<= 16;
      // if (cur >= end) throw 1;
      code |= GetUi16(cur);
      cur += 2;
    }
  }

  unsigned Decode(UInt32 *state, UInt32 numStates, struct CProbEntry *probs)
  {
    UInt32 st = *state;
    CProbEntry *entry = &probs[st];
    st = (st << 1) & (numStates - 1);

    UInt32 prob = entry->GetProb();

    if (range <= 0xFFFF)
    {
      range <<= 16;
      code <<= 16;
      // if (cur >= end) throw 1;
      code |= GetUi16(cur);
      cur += 2;
    }

    UInt32 bound = (range >> k_NumProbBits) * prob;
    
    if (code < bound)
    {
      range = bound;
      *state = st;
      entry->Update(0);
      return 0;
    }
    else
    {
      range -= bound;
      code -= bound;
      *state = st | 1;
      entry->Update(1);
      return 1;
    }
  }
};


class CDecoder
{
  // CRangeDecoder _rc;
  // CBitDecoder _bs;
  size_t _pos;

  UInt32 _reps[k_NumReps + 1];
  UInt64 _deltaReps[k_NumReps + 1];

  UInt32 mainState;
  UInt32 matchState;
  UInt32 lzRepStates[k_NumReps];
  UInt32 deltaRepStates[k_NumReps];

  struct CProbEntry mainProbs[k_NumMainProbs];
  struct CProbEntry matchProbs[k_NumMatchProbs];
  
  struct CProbEntry lzRepProbs[k_NumReps][k_NumRepProbs];
  struct CProbEntry deltaRepProbs[k_NumReps][k_NumRepProbs];

  CHuffDecoder<k_NumLitSyms, 1024, 9> m_LitDecoder;
  CHuffDecoder<k_NumPosSyms, 1024, 9> m_PosDecoder;
  CHuffDecoder<k_NumLenSyms, 512, 8> m_LenDecoder;
  CHuffDecoder<k_NumPowerSyms, 512, 6> m_PowerDecoder;
  CHuffDecoder<k_NumPosSyms, 1024, 9> m_DeltaDecoder;

  Int32 *_x86_history;

  HRESULT CodeReal(const Byte *in, size_t inSize, Byte *out, size_t outSize);
public:
  CDecoder();
  ~CDecoder();

  HRESULT Code(const Byte *in, size_t inSize, Byte *out, size_t outSize);
  const size_t GetUnpackSize() const { return _pos; }
};

}}

#endif
// Lzx.h

#ifndef __COMPRESS_LZX_H
#define __COMPRESS_LZX_H

namespace NCompress {
namespace NLzx {

const unsigned kBlockType_NumBits = 3;
const unsigned kBlockType_Verbatim = 1;
const unsigned kBlockType_Aligned = 2;
const unsigned kBlockType_Uncompressed = 3;

const unsigned kNumHuffmanBits = 16;
const unsigned kNumReps = 3;

const unsigned kNumLenSlots = 8;
const unsigned kMatchMinLen = 2;
const unsigned kNumLenSymbols = 249;
const unsigned kMatchMaxLen = kMatchMinLen + (kNumLenSlots - 1) + kNumLenSymbols - 1;

const unsigned kNumAlignLevelBits = 3;
const unsigned kNumAlignBits = 3;
const unsigned kAlignTableSize = 1 << kNumAlignBits;

const unsigned kNumPosSlots = 50;
const unsigned kNumPosLenSlots = kNumPosSlots * kNumLenSlots;

const unsigned kMainTableSize = 256 + kNumPosLenSlots;
const unsigned kLevelTableSize = 20;
const unsigned kMaxTableSize = kMainTableSize;

const unsigned kNumLevelBits = 4;

const unsigned kLevelSym_Zero1 = 17;
const unsigned kLevelSym_Zero2 = 18;
const unsigned kLevelSym_Same = 19;

const unsigned kLevelSym_Zero1_Start = 4;
const unsigned kLevelSym_Zero1_NumBits = 4;

const unsigned kLevelSym_Zero2_Start = kLevelSym_Zero1_Start + (1 << kLevelSym_Zero1_NumBits);
const unsigned kLevelSym_Zero2_NumBits = 5;

const unsigned kLevelSym_Same_NumBits = 1;
const unsigned kLevelSym_Same_Start = 4;
 
const unsigned kNumDictBits_Min = 15;
const unsigned kNumDictBits_Max = 21;
const UInt32 kDictSize_Max = (UInt32)1 << kNumDictBits_Max;

const unsigned kNumLinearPosSlotBits = 17;
const unsigned kNumPowerPosSlots = 38;

}}

#endif
// LzxDecoder.cpp

#include "StdAfx.h"

#include <string.h>

// #define SHOW_DEBUG_INFO

#ifdef SHOW_DEBUG_INFO
#include <stdio.h>
#define PRF(x) x
#else
#define PRF(x)
#endif

#include "../../../C/Alloc.h"

#include "LzxDecoder.h"

namespace NCompress {
namespace NLzx {

static void x86_Filter(Byte *data, UInt32 size, UInt32 processedSize, UInt32 translationSize)
{
  const UInt32 kResidue = 10;
  if (size <= kResidue)
    return;
  size -= kResidue;
  
  Byte save = data[size + 4];
  data[size + 4] = 0xE8;
  
  for (UInt32 i = 0;;)
  {
    const Byte *p = data + i;
    for (;;)
    {
      if (*p++ == 0xE8) break;
      if (*p++ == 0xE8) break;
      if (*p++ == 0xE8) break;
      if (*p++ == 0xE8) break;
    }

    i = (UInt32)(p - data);

    if (i > size)
      break;
    {
      Int32 v = GetUi32(p);
      Int32 pos = (Int32)((Int32)1 - (Int32)(processedSize + i));
      i += 4;
      if (v >= pos && v < (Int32)translationSize)
      {
        v += (v >= 0 ? pos : translationSize);
        SetUi32(p, v);
      }
    }
  }

  data[size + 4] = save;
}


CDecoder::CDecoder(bool wimMode):
    _win(NULL),
    _keepHistory(false),
    _skipByte(false),
    _wimMode(wimMode),
    _numDictBits(15),
    _unpackBlockSize(0),
    _x86_buf(NULL),
    _x86_translationSize(0),
    KeepHistoryForNext(true),
    NeedAlloc(true),
    _unpackedData(NULL)
{
}

CDecoder::~CDecoder()
{
  if (NeedAlloc)
    ::MidFree(_win);
  ::MidFree(_x86_buf);
}

HRESULT CDecoder::Flush()
{
  if (_x86_translationSize != 0)
  {
    Byte *destData = _win + _writePos;
    UInt32 curSize = _pos - _writePos;
    if (KeepHistoryForNext)
    {
      if (!_x86_buf)
      {
        // we must change it to support another chunk sizes
        const size_t kChunkSize = (size_t)1 << 15;
        if (curSize > kChunkSize)
          return E_NOTIMPL;
        _x86_buf = (Byte *)::MidAlloc(kChunkSize);
        if (!_x86_buf)
          return E_OUTOFMEMORY;
      }
      memcpy(_x86_buf, destData, curSize);
      _unpackedData = _x86_buf;
      destData = _x86_buf;
    }
    x86_Filter(destData, (UInt32)curSize, _x86_processedSize, _x86_translationSize);
    _x86_processedSize += (UInt32)curSize;
    if (_x86_processedSize >= ((UInt32)1 << 30))
      _x86_translationSize = 0;
  }
 
  return S_OK;
}


UInt32 CDecoder::ReadBits(unsigned numBits) { return _bitStream.ReadBitsSmall(numBits); }

#define RIF(x) { if (!(x)) return false; }

bool CDecoder::ReadTable(Byte *levels, unsigned numSymbols)
{
  {
    Byte levels2[kLevelTableSize];
    for (unsigned i = 0; i < kLevelTableSize; i++)
      levels2[i] = (Byte)ReadBits(kNumLevelBits);
    RIF(_levelDecoder.Build(levels2));
  }
  
  unsigned i = 0;
  do
  {
    UInt32 sym = _levelDecoder.Decode(&_bitStream);
    if (sym <= kNumHuffmanBits)
    {
      int delta = (int)levels[i] - (int)sym;
      delta += (delta < 0) ? (kNumHuffmanBits + 1) : 0;
      levels[i++] = (Byte)delta;
      continue;
    }
    
    unsigned num;
    Byte symbol;

    if (sym < kLevelSym_Same)
    {
      sym -= kLevelSym_Zero1;
      num = kLevelSym_Zero1_Start + ((unsigned)sym << kLevelSym_Zero1_NumBits) +
          (unsigned)ReadBits(kLevelSym_Zero1_NumBits + sym);
      symbol = 0;
    }
    else if (sym == kLevelSym_Same)
    {
      num = kLevelSym_Same_Start + (unsigned)ReadBits(kLevelSym_Same_NumBits);
      sym = _levelDecoder.Decode(&_bitStream);
      if (sym > kNumHuffmanBits)
        return false;
      int delta = (int)levels[i] - (int)sym;
      delta += (delta < 0) ? (kNumHuffmanBits + 1) : 0;
      symbol = (Byte)delta;
    }
    else
      return false;

    unsigned limit = i + num;
    if (limit > numSymbols)
      return false;

    do
      levels[i++] = symbol;
    while (i < limit);
  }
  while (i < numSymbols);

  return true;
}


bool CDecoder::ReadTables(void)
{
  {
    if (_skipByte)
    {
      if (_bitStream.DirectReadByte() != 0)
        return false;
    }

    _bitStream.NormalizeBig();

    unsigned blockType = (unsigned)ReadBits(kBlockType_NumBits);
    if (blockType > kBlockType_Uncompressed)
      return false;
    
    _unpackBlockSize = (1 << 15);
    if (!_wimMode || ReadBits(1) == 0)
    {
      _unpackBlockSize = ReadBits(16);
      // wimlib supports chunks larger than 32KB (unsupported my MS wim).
      if (!_wimMode || _numDictBits >= 16)
      {
        _unpackBlockSize <<= 8;
        _unpackBlockSize |= ReadBits(8);
      }
    }

    PRF(printf("\nBlockSize = %6d   %s  ", _unpackBlockSize, (_pos & 1) ? "@@@" : "   "));

    _isUncompressedBlock = (blockType == kBlockType_Uncompressed);

    _skipByte = false;

    if (_isUncompressedBlock)
    {
      _skipByte = ((_unpackBlockSize & 1) != 0);

      PRF(printf(" UncompressedBlock "));
      if (_unpackBlockSize & 1)
      {
        PRF(printf(" ######### "));
      }

      if (!_bitStream.PrepareUncompressed())
        return false;
      if (_bitStream.GetRem() < kNumReps * 4)
        return false;

      for (unsigned i = 0; i < kNumReps; i++)
      {
        UInt32 rep = _bitStream.ReadUInt32();
        if (rep > _winSize)
          return false;
        _reps[i] = rep;
      }
      
      return true;
    }

    _numAlignBits = 64;

    if (blockType == kBlockType_Aligned)
    {
      Byte levels[kAlignTableSize];
      _numAlignBits = kNumAlignBits;
      for (unsigned i = 0; i < kAlignTableSize; i++)
        levels[i] = (Byte)ReadBits(kNumAlignLevelBits);
      RIF(_alignDecoder.Build(levels));
    }
  }

  RIF(ReadTable(_mainLevels, 256));
  RIF(ReadTable(_mainLevels + 256, _numPosLenSlots));
  unsigned end = 256 + _numPosLenSlots;
  memset(_mainLevels + end, 0, kMainTableSize - end);
  RIF(_mainDecoder.Build(_mainLevels));
  RIF(ReadTable(_lenLevels, kNumLenSymbols));
  return _lenDecoder.Build(_lenLevels);
}


HRESULT CDecoder::CodeSpec(UInt32 curSize)
{
  if (!_keepHistory || !_isUncompressedBlock)
    _bitStream.NormalizeBig();
 
  if (!_keepHistory)
  {
    _skipByte = false;
    _unpackBlockSize = 0;

    memset(_mainLevels, 0, kMainTableSize);
    memset(_lenLevels, 0, kNumLenSymbols);
    
    {
      _x86_translationSize = 12000000;
      if (!_wimMode)
      {
        _x86_translationSize = 0;
        if (ReadBits(1) != 0)
        {
          UInt32 v = ReadBits(16) << 16;
          v |= ReadBits(16);
          _x86_translationSize = v;
        }
      }
      
      _x86_processedSize = 0;
    }

    _reps[0] = 1;
    _reps[1] = 1;
    _reps[2] = 1;
  }

  while (curSize > 0)
  {
    if (_bitStream.WasExtraReadError_Fast())
      return S_FALSE;
    
    if (_unpackBlockSize == 0)
    {
      if (!ReadTables())
        return S_FALSE;
      continue;
    }

    UInt32 next = _unpackBlockSize;
    if (next > curSize)
      next = curSize;
    
    if (_isUncompressedBlock)
    {
      size_t rem = _bitStream.GetRem();
      if (rem == 0)
        return S_FALSE;
      if (next > rem)
        next = (UInt32)rem;
      _bitStream.CopyTo(_win + _pos, next);
      _pos += next;
      curSize -= next;
      _unpackBlockSize -= next;

      /* we don't know where skipByte can be placed, if it's end of chunk:
          1) in current chunk - there are such cab archives, if chunk is last
          2) in next chunk - are there such archives ? */

      if (_skipByte
          && _unpackBlockSize == 0
          && curSize == 0
          && _bitStream.IsOneDirectByteLeft())
      {
        _skipByte = false;
        if (_bitStream.DirectReadByte() != 0)
          return S_FALSE;
      }
      
      continue;
    }

    curSize -= next;
    _unpackBlockSize -= next;
    
    Byte *win = _win;

    while (next > 0)
    {
      if (_bitStream.WasExtraReadError_Fast())
        return S_FALSE;

      UInt32 sym = _mainDecoder.Decode(&_bitStream);
      
      if (sym < 256)
      {
        win[_pos++] = (Byte)sym;
        next--;
        continue;
      }
      {
        sym -= 256;
        if (sym >= _numPosLenSlots)
          return S_FALSE;
        UInt32 posSlot = sym / kNumLenSlots;
        UInt32 lenSlot = sym % kNumLenSlots;
        UInt32 len = kMatchMinLen + lenSlot;
        
        if (lenSlot == kNumLenSlots - 1)
        {
          UInt32 lenTemp = _lenDecoder.Decode(&_bitStream);
          if (lenTemp >= kNumLenSymbols)
            return S_FALSE;
          len = kMatchMinLen + kNumLenSlots - 1 + lenTemp;
        }
        
        UInt32 dist;
        
        if (posSlot < kNumReps)
        {
          dist = _reps[posSlot];
          _reps[posSlot] = _reps[0];
          _reps[0] = dist;
        }
        else
        {
          unsigned numDirectBits;
          
          if (posSlot < kNumPowerPosSlots)
          {
            numDirectBits = (unsigned)(posSlot >> 1) - 1;
            dist = ((2 | (posSlot & 1)) << numDirectBits);
          }
          else
          {
            numDirectBits = kNumLinearPosSlotBits;
            dist = ((posSlot - 0x22) << kNumLinearPosSlotBits);
          }

          if (numDirectBits >= _numAlignBits)
          {
            dist += (_bitStream.ReadBitsSmall(numDirectBits - kNumAlignBits) << kNumAlignBits);
            UInt32 alignTemp = _alignDecoder.Decode(&_bitStream);
            if (alignTemp >= kAlignTableSize)
              return S_FALSE;
            dist += alignTemp;
          }
          else
            dist += _bitStream.ReadBitsBig(numDirectBits);
          
          dist -= kNumReps - 1;
          _reps[2] = _reps[1];
          _reps[1] = _reps[0];
          _reps[0] = dist;
        }

        if (len > next)
          return S_FALSE;

        if (dist > _pos && !_overDict)
          return S_FALSE;

        Byte *dest = win + _pos;
        const UInt32 mask = (_winSize - 1);
        UInt32 srcPos = (_pos - dist) & mask;

        next -= len;
        
        if (len > _winSize - srcPos)
        {
          _pos += len;
          do
          {
            *dest++ = win[srcPos++];
            srcPos &= mask;
          }
          while (--len);
        }
        else
        {
          ptrdiff_t src = (ptrdiff_t)srcPos - (ptrdiff_t)_pos;
          _pos += len;
          const Byte *lim = dest + len;
          *(dest) = *(dest + src);
          dest++;
          do
            *(dest) = *(dest + src);
          while (++dest != lim);
        }
      }
    }
  }

  if (!_bitStream.WasFinishedOK())
    return S_FALSE;

  return S_OK;
}


HRESULT CDecoder::Code(const Byte *inData, size_t inSize, UInt32 outSize)
{
  if (!_keepHistory)
  {
    _pos = 0;
    _overDict = false;
  }
  else if (_pos == _winSize)
  {
    _pos = 0;
    _overDict = true;
  }

  _writePos = _pos;
  _unpackedData = _win + _pos;
  
  if (outSize > _winSize - _pos)
    return S_FALSE;

  PRF(printf("\ninSize = %d", inSize));
  if ((inSize & 1) != 0)
  {
    PRF(printf(" ---------"));
  }

  if (inSize < 1)
    return S_FALSE;

  _bitStream.Init(inData, inSize);

  HRESULT res = CodeSpec(outSize);
  HRESULT res2 = Flush();
  return (res == S_OK ? res2 : res);
}


HRESULT CDecoder::SetParams2(unsigned numDictBits)
{
  _numDictBits = numDictBits;
  if (numDictBits < kNumDictBits_Min || numDictBits > kNumDictBits_Max)
    return E_INVALIDARG;
  unsigned numPosSlots = (numDictBits < 20) ?
      numDictBits * 2 :
      34 + ((unsigned)1 << (numDictBits - 17));
  _numPosLenSlots = numPosSlots * kNumLenSlots;
  return S_OK;
}
  

HRESULT CDecoder::SetParams_and_Alloc(unsigned numDictBits)
{
  RINOK(SetParams2(numDictBits));
  
  UInt32 newWinSize = (UInt32)1 << numDictBits;
 
  if (NeedAlloc)
  {
    if (!_win || newWinSize != _winSize)
    {
      ::MidFree(_win);
      _winSize = 0;
      _win = (Byte *)::MidAlloc(newWinSize);
      if (!_win)
        return E_OUTOFMEMORY;
    }
  }

  _winSize = (UInt32)newWinSize;
  return S_OK;
}

}}
// LzxDecoder.h

#ifndef __LZX_DECODER_H
#define __LZX_DECODER_H

#include "../../../C/CpuArch.h"

#include "../../Common/MyCom.h"

#include "HuffmanDecoder.h"
#include "Lzx.h"

namespace NCompress {
namespace NLzx {

class CBitDecoder
{
  unsigned _bitPos;
  UInt32 _value;
  const Byte *_buf;
  const Byte *_bufLim;
  UInt32 _extraSize;
public:

  void Init(const Byte *data, size_t size)
  {
    _buf = data;
    _bufLim = data + size - 1;
    _bitPos = 0;
    _extraSize = 0;
  }

  size_t GetRem() const { return _bufLim + 1 - _buf; }
  bool WasExtraReadError_Fast() const { return _extraSize > 4; }

  bool WasFinishedOK() const
  {
    if (_buf != _bufLim + 1)
      return false;
    if ((_bitPos >> 4) * 2 != _extraSize)
      return false;
    unsigned numBits = _bitPos & 15;
    return (((_value >> (_bitPos - numBits)) & (((UInt32)1 << numBits) - 1)) == 0);
  }
  
  void NormalizeSmall()
  {
    if (_bitPos <= 16)
    {
      UInt32 val;
      if (_buf >= _bufLim)
      {
        val = 0xFFFF;
        _extraSize += 2;
      }
      else
      {
        val = GetUi16(_buf);
        _buf += 2;
      }
      _value = (_value << 16) | val;
      _bitPos += 16;
    }
  }

  void NormalizeBig()
  {
    if (_bitPos <= 16)
    {
      {
        UInt32 val;
        if (_buf >= _bufLim)
        {
          val = 0xFFFF;
          _extraSize += 2;
        }
        else
        {
          val = GetUi16(_buf);
          _buf += 2;
        }
        _value = (_value << 16) | val;
        _bitPos += 16;
      }
      if (_bitPos <= 16)
      {
        UInt32 val;
        if (_buf >= _bufLim)
        {
          val = 0xFFFF;
          _extraSize += 2;
        }
        else
        {
          val = GetUi16(_buf);
          _buf += 2;
        }
        _value = (_value << 16) | val;
        _bitPos += 16;
      }
    }
  }

  UInt32 GetValue(unsigned numBits) const
  {
    return (_value >> (_bitPos - numBits)) & (((UInt32)1 << numBits) - 1);
  }
  
  void MovePos(unsigned numBits)
  {
    _bitPos -= numBits;
    NormalizeSmall();
  }

  UInt32 ReadBitsSmall(unsigned numBits)
  {
    _bitPos -= numBits;
    UInt32 val = (_value >> _bitPos) & (((UInt32)1 << numBits) - 1);
    NormalizeSmall();
    return val;
  }

  UInt32 ReadBitsBig(unsigned numBits)
  {
    _bitPos -= numBits;
    UInt32 val = (_value >> _bitPos) & (((UInt32)1 << numBits) - 1);
    NormalizeBig();
    return val;
  }

  bool PrepareUncompressed()
  {
    if (_extraSize != 0)
      return false;
    unsigned numBits = _bitPos - 16;
    if (((_value >> 16) & (((UInt32)1 << numBits) - 1)) != 0)
      return false;
    _buf -= 2;
    _bitPos = 0;
    return true;
  }

  UInt32 ReadUInt32()
  {
    UInt32 v = GetUi32(_buf);
    _buf += 4;
    return v;
  }

  void CopyTo(Byte *dest, size_t size)
  {
    memcpy(dest, _buf, size);
    _buf += size;
  }

  bool IsOneDirectByteLeft() const { return _buf == _bufLim && _extraSize == 0; }

  Byte DirectReadByte()
  {
    if (_buf > _bufLim)
    {
      _extraSize++;
      return 0xFF;
    }
    return *_buf++;
  }
};


class CDecoder:
  public IUnknown,
  public CMyUnknownImp
{
  CBitDecoder _bitStream;
  Byte *_win;
  UInt32 _pos;
  UInt32 _winSize;

  bool _overDict;
  bool _isUncompressedBlock;
  bool _skipByte;
  unsigned _numAlignBits;

  UInt32 _reps[kNumReps];
  UInt32 _numPosLenSlots;
  UInt32 _unpackBlockSize;

public:
  bool KeepHistoryForNext;
  bool NeedAlloc;
private:
  bool _keepHistory;
  bool _wimMode;
  unsigned _numDictBits;
  UInt32 _writePos;

  Byte *_x86_buf;
  UInt32 _x86_translationSize;
  UInt32 _x86_processedSize;

  Byte *_unpackedData;
  
  NHuffman::CDecoder<kNumHuffmanBits, kMainTableSize> _mainDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kNumLenSymbols> _lenDecoder;
  NHuffman::CDecoder7b<kAlignTableSize> _alignDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kLevelTableSize, 7> _levelDecoder;

  Byte _mainLevels[kMainTableSize];
  Byte _lenLevels[kNumLenSymbols];

  HRESULT Flush();

  UInt32 ReadBits(unsigned numBits);
  bool ReadTable(Byte *levels, unsigned numSymbols);
  bool ReadTables();

  HRESULT CodeSpec(UInt32 size);
  HRESULT SetParams2(unsigned numDictBits);
public:
  CDecoder(bool wimMode = false);
  ~CDecoder();

  MY_UNKNOWN_IMP

  HRESULT SetExternalWindow(Byte *win, unsigned numDictBits)
  {
    NeedAlloc = false;
    _win = win;
    _winSize = (UInt32)1 << numDictBits;
    return SetParams2(numDictBits);
  }

  void SetKeepHistory(bool keepHistory) { _keepHistory = keepHistory; }

  HRESULT SetParams_and_Alloc(unsigned numDictBits);

  HRESULT Code(const Byte *inData, size_t inSize, UInt32 outSize);
  
  bool WasBlockFinished() const { return _unpackBlockSize == 0; }
  const Byte *GetUnpackData() const { return _unpackedData; }
  const UInt32 GetUnpackSize() const { return _pos - _writePos; }
};

}}

#endif
// Mtf8.h

#ifndef __COMPRESS_MTF8_H
#define __COMPRESS_MTF8_H

#include "../../../C/CpuArch.h"

namespace NCompress {

struct CMtf8Encoder
{
  Byte Buf[256];

  unsigned FindAndMove(Byte v)
  {
    unsigned pos;
    for (pos = 0; Buf[pos] != v; pos++);
    unsigned resPos = pos;
    for (; pos >= 8; pos -= 8)
    {
      Buf[pos] = Buf[pos - 1];
      Buf[pos - 1] = Buf[pos - 2];
      Buf[pos - 2] = Buf[pos - 3];
      Buf[pos - 3] = Buf[pos - 4];
      Buf[pos - 4] = Buf[pos - 5];
      Buf[pos - 5] = Buf[pos - 6];
      Buf[pos - 6] = Buf[pos - 7];
      Buf[pos - 7] = Buf[pos - 8];
    }
    for (; pos != 0; pos--)
      Buf[pos] = Buf[pos - 1];
    Buf[0] = v;
    return resPos;
  }
};

/*
struct CMtf8Decoder
{
  Byte Buf[256];

  void Init(int) {};
  Byte GetHead() const { return Buf[0]; }
  Byte GetAndMove(int pos)
  {
    Byte res = Buf[pos];
    for (; pos >= 8; pos -= 8)
    {
      Buf[pos] = Buf[pos - 1];
      Buf[pos - 1] = Buf[pos - 2];
      Buf[pos - 2] = Buf[pos - 3];
      Buf[pos - 3] = Buf[pos - 4];
      Buf[pos - 4] = Buf[pos - 5];
      Buf[pos - 5] = Buf[pos - 6];
      Buf[pos - 6] = Buf[pos - 7];
      Buf[pos - 7] = Buf[pos - 8];
    }
    for (; pos > 0; pos--)
      Buf[pos] = Buf[pos - 1];
    Buf[0] = res;
    return res;
  }
};
*/

#ifdef MY_CPU_64BIT
typedef UInt64 CMtfVar;
#define MTF_MOVS 3
#else
typedef UInt32 CMtfVar;
#define MTF_MOVS 2
#endif

#define MTF_MASK ((1 << MTF_MOVS) - 1)


struct CMtf8Decoder
{
  CMtfVar Buf[256 >> MTF_MOVS];

  void StartInit() { memset(Buf, 0, sizeof(Buf)); }
  void Add(unsigned pos, Byte val) { Buf[pos >> MTF_MOVS] |= ((CMtfVar)val << ((pos & MTF_MASK) << 3));  }
  Byte GetHead() const { return (Byte)Buf[0]; }
  Byte GetAndMove(unsigned pos)
  {
    UInt32 lim = ((UInt32)pos >> MTF_MOVS);
    pos = (pos & MTF_MASK) << 3;
    CMtfVar prev = (Buf[lim] >> pos) & 0xFF;

    UInt32 i = 0;
    if ((lim & 1) != 0)
    {
      CMtfVar next = Buf[0];
      Buf[0] = (next << 8) | prev;
      prev = (next >> (MTF_MASK << 3));
      i = 1;
      lim -= 1;
    }
    for (; i < lim; i += 2)
    {
      CMtfVar n0 = Buf[i];
      CMtfVar n1 = Buf[i + 1];
      Buf[i    ] = (n0 << 8) | prev;
      Buf[i + 1] = (n1 << 8) | (n0 >> (MTF_MASK << 3));
      prev = (n1 >> (MTF_MASK << 3));
    }
    CMtfVar next = Buf[i];
    CMtfVar mask = (((CMtfVar)0x100 << pos) - 1);
    Buf[i] = (next & ~mask) | (((next << 8) | prev) & mask);
    return (Byte)Buf[0];
  }
};

/*
const int kSmallSize = 64;
class CMtf8Decoder
{
  Byte SmallBuffer[kSmallSize];
  int SmallSize;
  Byte Counts[16];
  int Size;
public:
  Byte Buf[256];

  Byte GetHead() const
  {
    if (SmallSize > 0)
      return SmallBuffer[kSmallSize - SmallSize];
    return Buf[0];
  }

  void Init(int size)
  {
    Size = size;
    SmallSize = 0;
    for (int i = 0; i < 16; i++)
    {
      Counts[i] = ((size >= 16) ? 16 : size);
      size -= Counts[i];
    }
  }

  Byte GetAndMove(int pos)
  {
    if (pos < SmallSize)
    {
      Byte *p = SmallBuffer + kSmallSize - SmallSize;
      Byte res = p[pos];
      for (; pos > 0; pos--)
        p[pos] = p[pos - 1];
      SmallBuffer[kSmallSize - SmallSize] = res;
      return res;
    }
    if (SmallSize == kSmallSize)
    {
      int i = Size - 1;
      int g = 16;
      do
      {
        g--;
        int offset = (g << 4);
        for (int t = Counts[g] - 1; t >= 0; t--, i--)
          Buf[i] = Buf[offset + t];
      }
      while (g != 0);
      
      for (i = kSmallSize - 1; i >= 0; i--)
        Buf[i] = SmallBuffer[i];
      Init(Size);
    }
    pos -= SmallSize;
    int g;
    for (g = 0; pos >= Counts[g]; g++)
      pos -= Counts[g];
    int offset = (g << 4);
    Byte res = Buf[offset + pos];
    for (pos; pos < 16 - 1; pos++)
      Buf[offset + pos] = Buf[offset + pos + 1];
    
    SmallSize++;
    SmallBuffer[kSmallSize - SmallSize] = res;

    Counts[g]--;
    return res;
  }
};
*/

}

#endif
// PpmdDecoder.cpp
// 2009-03-11 : Igor Pavlov : Public domain

#include "StdAfx.h"

#include "../../../C/Alloc.h"
#include "../../../C/CpuArch.h"

#include "../Common/StreamUtils.h"

#include "PpmdDecoder.h"

namespace NCompress {
namespace NPpmd {

static const UInt32 kBufSize = (1 << 20);

enum
{
  kStatus_NeedInit,
  kStatus_Normal,
  kStatus_Finished,
  kStatus_Error
};

CDecoder::~CDecoder()
{
  ::MidFree(_outBuf);
  Ppmd7_Free(&_ppmd, &g_BigAlloc);
}

STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *props, UInt32 size)
{
  if (size < 5)
    return E_INVALIDARG;
  _order = props[0];
  UInt32 memSize = GetUi32(props + 1);
  if (_order < PPMD7_MIN_ORDER ||
      _order > PPMD7_MAX_ORDER ||
      memSize < PPMD7_MIN_MEM_SIZE ||
      memSize > PPMD7_MAX_MEM_SIZE)
    return E_NOTIMPL;
  if (!_inStream.Alloc(1 << 20))
    return E_OUTOFMEMORY;
  if (!Ppmd7_Alloc(&_ppmd, memSize, &g_BigAlloc))
    return E_OUTOFMEMORY;
  return S_OK;
}

HRESULT CDecoder::CodeSpec(Byte *memStream, UInt32 size)
{
  switch (_status)
  {
    case kStatus_Finished: return S_OK;
    case kStatus_Error: return S_FALSE;
    case kStatus_NeedInit:
      _inStream.Init();
      if (!Ppmd7z_RangeDec_Init(&_rangeDec))
      {
        _status = kStatus_Error;
        return S_FALSE;
      }
      _status = kStatus_Normal;
      Ppmd7_Init(&_ppmd, _order);
      break;
  }
  if (_outSizeDefined)
  {
    const UInt64 rem = _outSize - _processedSize;
    if (size > rem)
      size = (UInt32)rem;
  }

  UInt32 i;
  int sym = 0;
  for (i = 0; i != size; i++)
  {
    sym = Ppmd7_DecodeSymbol(&_ppmd, &_rangeDec.p);
    if (_inStream.Extra || sym < 0)
      break;
    memStream[i] = (Byte)sym;
  }

  _processedSize += i;
  if (_inStream.Extra)
  {
    _status = kStatus_Error;
    return _inStream.Res;
  }
  if (sym < 0)
    _status = (sym < -1) ? kStatus_Error : kStatus_Finished;
  return S_OK;
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  if (!_outBuf)
  {
    _outBuf = (Byte *)::MidAlloc(kBufSize);
    if (!_outBuf)
      return E_OUTOFMEMORY;
  }
  
  _inStream.Stream = inStream;
  SetOutStreamSize(outSize);

  do
  {
    const UInt64 startPos = _processedSize;
    HRESULT res = CodeSpec(_outBuf, kBufSize);
    size_t processed = (size_t)(_processedSize - startPos);
    RINOK(WriteStream(outStream, _outBuf, processed));
    RINOK(res);
    if (_status == kStatus_Finished)
      break;
    if (progress)
    {
      UInt64 inSize = _inStream.GetProcessed();
      RINOK(progress->SetRatioInfo(&inSize, &_processedSize));
    }
  }
  while (!_outSizeDefined || _processedSize < _outSize);
  return S_OK;
}

STDMETHODIMP CDecoder::SetOutStreamSize(const UInt64 *outSize)
{
  _outSizeDefined = (outSize != NULL);
  if (_outSizeDefined)
    _outSize = *outSize;
  _processedSize = 0;
  _status = kStatus_NeedInit;
  return S_OK;
}

#ifndef NO_READ_FROM_CODER

STDMETHODIMP CDecoder::SetInStream(ISequentialInStream *inStream)
{
  InSeqStream = inStream;
  _inStream.Stream = inStream;
  return S_OK;
}

STDMETHODIMP CDecoder::ReleaseInStream()
{
  InSeqStream.Release();
  return S_OK;
}

STDMETHODIMP CDecoder::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  const UInt64 startPos = _processedSize;
  HRESULT res = CodeSpec((Byte *)data, size);
  if (processedSize)
    *processedSize = (UInt32)(_processedSize - startPos);
  return res;
}

#endif

}}
// PpmdDecoder.h
// 2009-03-11 : Igor Pavlov : Public domain

#ifndef __COMPRESS_PPMD_DECODER_H
#define __COMPRESS_PPMD_DECODER_H

#include "../../../C/Ppmd7.h"

#include "../../Common/MyCom.h"

#include "../Common/CWrappers.h"

#include "../ICoder.h"

namespace NCompress {
namespace NPpmd {

class CDecoder :
  public ICompressCoder,
  public ICompressSetDecoderProperties2,
  #ifndef NO_READ_FROM_CODER
  public ICompressSetInStream,
  public ICompressSetOutStreamSize,
  public ISequentialInStream,
  #endif
  public CMyUnknownImp
{
  Byte *_outBuf;
  CPpmd7z_RangeDec _rangeDec;
  CByteInBufWrap _inStream;
  CPpmd7 _ppmd;

  Byte _order;
  bool _outSizeDefined;
  int _status;
  UInt64 _outSize;
  UInt64 _processedSize;

  HRESULT CodeSpec(Byte *memStream, UInt32 size);

public:

  #ifndef NO_READ_FROM_CODER
  CMyComPtr<ISequentialInStream> InSeqStream;
  MY_UNKNOWN_IMP4(
      ICompressSetDecoderProperties2,
      ICompressSetInStream,
      ICompressSetOutStreamSize,
      ISequentialInStream)
  #else
  MY_UNKNOWN_IMP1(
      ICompressSetDecoderProperties2)
  #endif

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);
  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);

  #ifndef NO_READ_FROM_CODER
  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
  STDMETHOD(ReleaseInStream)();
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  #endif

  CDecoder(): _outBuf(NULL), _outSizeDefined(false)
  {
    Ppmd7z_RangeDec_CreateVTable(&_rangeDec);
    _rangeDec.Stream = &_inStream.p;
    Ppmd7_Construct(&_ppmd);
  }

  ~CDecoder();
};

}}

#endif
// PpmdEncoder.cpp

#include "StdAfx.h"

#include "../../../C/Alloc.h"
#include "../../../C/CpuArch.h"

#include "../Common/StreamUtils.h"

#include "PpmdEncoder.h"

namespace NCompress {
namespace NPpmd {

static const UInt32 kBufSize = (1 << 20);

static const Byte kOrders[10] = { 3, 4, 4, 5, 5, 6, 8, 16, 24, 32 };

void CEncProps::Normalize(int level)
{
  if (level < 0) level = 5;
  if (level > 9) level = 9;
  if (MemSize == (UInt32)(Int32)-1)
    MemSize = level >= 9 ? ((UInt32)192 << 20) : ((UInt32)1 << (level + 19));
  const unsigned kMult = 16;
  if (MemSize / kMult > ReduceSize)
  {
    for (unsigned i = 16; i <= 31; i++)
    {
      UInt32 m = (UInt32)1 << i;
      if (ReduceSize <= m / kMult)
      {
        if (MemSize > m)
          MemSize = m;
        break;
      }
    }
  }
  if (Order == -1) Order = kOrders[(unsigned)level];
}

CEncoder::CEncoder():
  _inBuf(NULL)
{
  _props.Normalize(-1);
  _rangeEnc.Stream = &_outStream.p;
  Ppmd7_Construct(&_ppmd);
}

CEncoder::~CEncoder()
{
  ::MidFree(_inBuf);
  Ppmd7_Free(&_ppmd, &g_BigAlloc);
}

STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs, const PROPVARIANT *coderProps, UInt32 numProps)
{
  int level = -1;
  CEncProps props;
  for (UInt32 i = 0; i < numProps; i++)
  {
    const PROPVARIANT &prop = coderProps[i];
    PROPID propID = propIDs[i];
    if (propID > NCoderPropID::kReduceSize)
      continue;
    if (propID == NCoderPropID::kReduceSize)
    {
      if (prop.vt == VT_UI8 && prop.uhVal.QuadPart < (UInt32)(Int32)-1)
        props.ReduceSize = (UInt32)prop.uhVal.QuadPart;
      continue;
    }
    if (prop.vt != VT_UI4)
      return E_INVALIDARG;
    UInt32 v = (UInt32)prop.ulVal;
    switch (propID)
    {
      case NCoderPropID::kUsedMemorySize:
        if (v < (1 << 16) || v > PPMD7_MAX_MEM_SIZE || (v & 3) != 0)
          return E_INVALIDARG;
        props.MemSize = v;
        break;
      case NCoderPropID::kOrder:
        if (v < 2 || v > 32)
          return E_INVALIDARG;
        props.Order = (Byte)v;
        break;
      case NCoderPropID::kNumThreads: break;
      case NCoderPropID::kLevel: level = (int)v; break;
      default: return E_INVALIDARG;
    }
  }
  props.Normalize(level);
  _props = props;
  return S_OK;
}

STDMETHODIMP CEncoder::WriteCoderProperties(ISequentialOutStream *outStream)
{
  const UInt32 kPropSize = 5;
  Byte props[kPropSize];
  props[0] = (Byte)_props.Order;
  SetUi32(props + 1, _props.MemSize);
  return WriteStream(outStream, props, kPropSize);
}

HRESULT CEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  if (!_inBuf)
  {
    _inBuf = (Byte *)::MidAlloc(kBufSize);
    if (!_inBuf)
      return E_OUTOFMEMORY;
  }
  if (!_outStream.Alloc(1 << 20))
    return E_OUTOFMEMORY;
  if (!Ppmd7_Alloc(&_ppmd, _props.MemSize, &g_BigAlloc))
    return E_OUTOFMEMORY;

  _outStream.Stream = outStream;
  _outStream.Init();

  Ppmd7z_RangeEnc_Init(&_rangeEnc);
  Ppmd7_Init(&_ppmd, _props.Order);

  UInt64 processed = 0;
  for (;;)
  {
    UInt32 size;
    RINOK(inStream->Read(_inBuf, kBufSize, &size));
    if (size == 0)
    {
      // We don't write EndMark in PPMD-7z.
      // Ppmd7_EncodeSymbol(&_ppmd, &_rangeEnc, -1);
      Ppmd7z_RangeEnc_FlushData(&_rangeEnc);
      return _outStream.Flush();
    }
    for (UInt32 i = 0; i < size; i++)
    {
      Ppmd7_EncodeSymbol(&_ppmd, &_rangeEnc, _inBuf[i]);
      RINOK(_outStream.Res);
    }
    processed += size;
    if (progress)
    {
      UInt64 outSize = _outStream.GetProcessed();
      RINOK(progress->SetRatioInfo(&processed, &outSize));
    }
  }
}

}}
// PpmdEncoder.h

#ifndef __COMPRESS_PPMD_ENCODER_H
#define __COMPRESS_PPMD_ENCODER_H

#include "../../../C/Ppmd7.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "../Common/CWrappers.h"

namespace NCompress {
namespace NPpmd {

struct CEncProps
{
  UInt32 MemSize;
  UInt32 ReduceSize;
  int Order;
  
  CEncProps()
  {
    MemSize = (UInt32)(Int32)-1;
    ReduceSize = (UInt32)(Int32)-1;
    Order = -1;
  }
  void Normalize(int level);
};

class CEncoder :
  public ICompressCoder,
  public ICompressSetCoderProperties,
  public ICompressWriteCoderProperties,
  public CMyUnknownImp
{
  Byte *_inBuf;
  CByteOutBufWrap _outStream;
  CPpmd7z_RangeEnc _rangeEnc;
  CPpmd7 _ppmd;
  CEncProps _props;
public:
  MY_UNKNOWN_IMP3(
      ICompressCoder,
      ICompressSetCoderProperties,
      ICompressWriteCoderProperties)
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
  STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStream);
  CEncoder();
  ~CEncoder();
};

}}

#endif
// PpmdRegister.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "PpmdDecoder.h"

#ifndef EXTRACT_ONLY
#include "PpmdEncoder.h"
#endif

namespace NCompress {
namespace NPpmd {

REGISTER_CODEC_E(PPMD,
    CDecoder(),
    CEncoder(),
    0x30401,
    "PPMD")

}}
// PpmdZip.cpp

#include "StdAfx.h"

#include "../../../C/CpuArch.h"

#include "../Common/RegisterCodec.h"
#include "../Common/StreamUtils.h"

#include "PpmdZip.h"

namespace NCompress {
namespace NPpmdZip {

CDecoder::CDecoder(bool fullFileMode):
  _fullFileMode(fullFileMode)
{
  _ppmd.Stream.In = &_inStream.p;
  Ppmd8_Construct(&_ppmd);
}

CDecoder::~CDecoder()
{
  Ppmd8_Free(&_ppmd, &g_BigAlloc);
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  if (!_outStream.Alloc())
    return E_OUTOFMEMORY;
  if (!_inStream.Alloc(1 << 20))
    return E_OUTOFMEMORY;

  _inStream.Stream = inStream;
  _inStream.Init();

  {
    Byte buf[2];
    for (int i = 0; i < 2; i++)
      buf[i] = _inStream.ReadByte();
    if (_inStream.Extra)
      return S_FALSE;
    
    UInt32 val = GetUi16(buf);
    UInt32 order = (val & 0xF) + 1;
    UInt32 mem = ((val >> 4) & 0xFF) + 1;
    UInt32 restor = (val >> 12);
    if (order < 2 || restor > 2)
      return S_FALSE;
    
    #ifndef PPMD8_FREEZE_SUPPORT
    if (restor == 2)
      return E_NOTIMPL;
    #endif
    
    if (!Ppmd8_Alloc(&_ppmd, mem << 20, &g_BigAlloc))
      return E_OUTOFMEMORY;
    
    if (!Ppmd8_RangeDec_Init(&_ppmd))
      return S_FALSE;
    Ppmd8_Init(&_ppmd, order, restor);
  }

  bool wasFinished = false;
  UInt64 processedSize = 0;
  while (!outSize || processedSize < *outSize)
  {
    size_t size = kBufSize;
    if (outSize != NULL)
    {
      const UInt64 rem = *outSize - processedSize;
      if (size > rem)
        size = (size_t)rem;
    }
    Byte *data = _outStream.Buf;
    size_t i = 0;
    int sym = 0;
    do
    {
      sym = Ppmd8_DecodeSymbol(&_ppmd);
      if (_inStream.Extra || sym < 0)
        break;
      data[i] = (Byte)sym;
    }
    while (++i != size);
    processedSize += i;

    RINOK(WriteStream(outStream, _outStream.Buf, i));

    RINOK(_inStream.Res);
    if (_inStream.Extra)
      return S_FALSE;

    if (sym < 0)
    {
      if (sym != -1)
        return S_FALSE;
      wasFinished = true;
      break;
    }
    if (progress)
    {
      UInt64 inSize = _inStream.GetProcessed();
      RINOK(progress->SetRatioInfo(&inSize, &processedSize));
    }
  }
  RINOK(_inStream.Res);
  if (_fullFileMode)
  {
    if (!wasFinished)
    {
      int res = Ppmd8_DecodeSymbol(&_ppmd);
      RINOK(_inStream.Res);
      if (_inStream.Extra || res != -1)
        return S_FALSE;
    }
    if (!Ppmd8_RangeDec_IsFinishedOK(&_ppmd))
      return S_FALSE;
  }
  return S_OK;
}


// ---------- Encoder ----------

void CEncProps::Normalize(int level)
{
  if (level < 0) level = 5;
  if (level == 0) level = 1;
  if (level > 9) level = 9;
  if (MemSizeMB == (UInt32)(Int32)-1)
    MemSizeMB = (1 << ((level > 8 ? 8 : level) - 1));
  const unsigned kMult = 16;
  if ((MemSizeMB << 20) / kMult > ReduceSize)
  {
    for (UInt32 m = (1 << 20); m <= (1 << 28); m <<= 1)
    {
      if (ReduceSize <= m / kMult)
      {
        m >>= 20;
        if (MemSizeMB > m)
          MemSizeMB = m;
        break;
      }
    }
  }
  if (Order == -1) Order = 3 + level;
  if (Restor == -1)
    Restor = level < 7 ?
      PPMD8_RESTORE_METHOD_RESTART :
      PPMD8_RESTORE_METHOD_CUT_OFF;
}

CEncoder::~CEncoder()
{
  Ppmd8_Free(&_ppmd, &g_BigAlloc);
}

STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs, const PROPVARIANT *coderProps, UInt32 numProps)
{
  int level = -1;
  CEncProps props;
  for (UInt32 i = 0; i < numProps; i++)
  {
    const PROPVARIANT &prop = coderProps[i];
    PROPID propID = propIDs[i];
    if (propID > NCoderPropID::kReduceSize)
      continue;
    if (propID == NCoderPropID::kReduceSize)
    {
      if (prop.vt == VT_UI8 && prop.uhVal.QuadPart < (UInt32)(Int32)-1)
        props.ReduceSize = (UInt32)prop.uhVal.QuadPart;
      continue;
    }
    if (prop.vt != VT_UI4)
      return E_INVALIDARG;
    UInt32 v = (UInt32)prop.ulVal;
    switch (propID)
    {
      case NCoderPropID::kUsedMemorySize:
        if (v < (1 << 20) || v > (1 << 28))
          return E_INVALIDARG;
        props.MemSizeMB = v >> 20;
        break;
      case NCoderPropID::kOrder:
        if (v < PPMD8_MIN_ORDER || v > PPMD8_MAX_ORDER)
          return E_INVALIDARG;
        props.Order = (Byte)v;
        break;
      case NCoderPropID::kNumThreads: break;
      case NCoderPropID::kLevel: level = (int)v; break;
      case NCoderPropID::kAlgorithm:
        if (v > 1)
          return E_INVALIDARG;
        props.Restor = v;
        break;
      default: return E_INVALIDARG;
    }
  }
  props.Normalize(level);
  _props = props;
  return S_OK;
}

CEncoder::CEncoder()
{
  _props.Normalize(-1);
  _ppmd.Stream.Out = &_outStream.p;
  Ppmd8_Construct(&_ppmd);
}

STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  if (!_inStream.Alloc())
    return E_OUTOFMEMORY;
  if (!_outStream.Alloc(1 << 20))
    return E_OUTOFMEMORY;
  if (!Ppmd8_Alloc(&_ppmd, _props.MemSizeMB << 20, &g_BigAlloc))
    return E_OUTOFMEMORY;

  _outStream.Stream = outStream;
  _outStream.Init();

  Ppmd8_RangeEnc_Init(&_ppmd);
  Ppmd8_Init(&_ppmd, _props.Order, _props.Restor);

  UInt32 val = (UInt32)((_props.Order - 1) + ((_props.MemSizeMB - 1) << 4) + (_props.Restor << 12));
  _outStream.WriteByte((Byte)(val & 0xFF));
  _outStream.WriteByte((Byte)(val >> 8));
  RINOK(_outStream.Res);

  UInt64 processed = 0;
  for (;;)
  {
    UInt32 size;
    RINOK(inStream->Read(_inStream.Buf, kBufSize, &size));
    if (size == 0)
    {
      Ppmd8_EncodeSymbol(&_ppmd, -1);
      Ppmd8_RangeEnc_FlushData(&_ppmd);
      return _outStream.Flush();
    }
    for (UInt32 i = 0; i < size; i++)
    {
      Ppmd8_EncodeSymbol(&_ppmd, _inStream.Buf[i]);
      RINOK(_outStream.Res);
    }
    processed += size;
    if (progress != NULL)
    {
      UInt64 outSize = _outStream.GetProcessed();
      RINOK(progress->SetRatioInfo(&processed, &outSize));
    }
  }
}

}}
// PpmdZip.h

#ifndef __COMPRESS_PPMD_ZIP_H
#define __COMPRESS_PPMD_ZIP_H

#include "../../../C/Alloc.h"
#include "../../../C/Ppmd8.h"

#include "../../Common/MyCom.h"

#include "../Common/CWrappers.h"

#include "../ICoder.h"

namespace NCompress {
namespace NPpmdZip {

static const UInt32 kBufSize = (1 << 20);

struct CBuf
{
  Byte *Buf;
  
  CBuf(): Buf(0) {}
  ~CBuf() { ::MidFree(Buf); }
  bool Alloc()
  {
    if (!Buf)
      Buf = (Byte *)::MidAlloc(kBufSize);
    return (Buf != 0);
  }
};

class CDecoder :
  public ICompressCoder,
  public CMyUnknownImp
{
  CByteInBufWrap _inStream;
  CBuf _outStream;
  CPpmd8 _ppmd;
  bool _fullFileMode;
public:
  MY_UNKNOWN_IMP
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  CDecoder(bool fullFileMode);
  ~CDecoder();
};

struct CEncProps
{
  UInt32 MemSizeMB;
  UInt32 ReduceSize;
  int Order;
  int Restor;
  
  CEncProps()
  {
    MemSizeMB = (UInt32)(Int32)-1;
    ReduceSize = (UInt32)(Int32)-1;
    Order = -1;
    Restor = -1;
  }
  void Normalize(int level);
};

class CEncoder :
  public ICompressCoder,
  public ICompressSetCoderProperties,
  public CMyUnknownImp
{
  CByteOutBufWrap _outStream;
  CBuf _inStream;
  CPpmd8 _ppmd;
  CEncProps _props;
public:
  MY_UNKNOWN_IMP1(ICompressSetCoderProperties)
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);
  CEncoder();
  ~CEncoder();
};

}}

#endif
// QuantumDecoder.cpp

#include "StdAfx.h"

#include "../../Common/Defs.h"

#include "QuantumDecoder.h"

namespace NCompress {
namespace NQuantum {

static const unsigned kNumLenSymbols = 27;
static const unsigned kMatchMinLen = 3;
static const unsigned kNumSimplePosSlots = 4;
static const unsigned kNumSimpleLenSlots = 6;

static const UInt16 kUpdateStep = 8;
static const UInt16 kFreqSumMax = 3800;
static const unsigned kReorderCountStart = 4;
static const unsigned kReorderCount = 50;

void CModelDecoder::Init(unsigned numItems)
{
  NumItems = numItems;
  ReorderCount = kReorderCountStart;
  for (unsigned i = 0; i < numItems; i++)
  {
    Freqs[i] = (UInt16)(numItems - i);
    Vals[i] = (Byte)i;
  }
  Freqs[numItems] = 0;
}

unsigned CModelDecoder::Decode(CRangeDecoder *rc)
{
  UInt32 threshold = rc->GetThreshold(Freqs[0]);
  unsigned i;
  for (i = 1; Freqs[i] > threshold; i++);
  
  rc->Decode(Freqs[i], Freqs[i - 1], Freqs[0]);
  unsigned res = Vals[--i];
  
  do
    Freqs[i] += kUpdateStep;
  while (i--);
  
  if (Freqs[0] > kFreqSumMax)
  {
    if (--ReorderCount == 0)
    {
      ReorderCount = kReorderCount;
      for (i = 0; i < NumItems; i++)
        Freqs[i] = (UInt16)(((Freqs[i] - Freqs[i + 1]) + 1) >> 1);
      for (i = 0; i < NumItems - 1; i++)
        for (unsigned j = i + 1; j < NumItems; j++)
          if (Freqs[i] < Freqs[j])
          {
            UInt16 tmpFreq = Freqs[i];
            Byte tmpVal = Vals[i];
            Freqs[i] = Freqs[j];
            Vals[i] = Vals[j];
            Freqs[j] = tmpFreq;
            Vals[j] = tmpVal;
          }
      
      do
        Freqs[i] = (UInt16)(Freqs[i] + Freqs[i + 1]);
      while (i--);
    }
    else
    {
      i = NumItems - 1;
      do
      {
        Freqs[i] >>= 1;
        if (Freqs[i] <= Freqs[i + 1])
          Freqs[i] = (UInt16)(Freqs[i + 1] + 1);
      }
      while (i--);
    }
  }
  
  return res;
}


void CDecoder::Init()
{
  m_Selector.Init(kNumSelectors);
  unsigned i;
  for (i = 0; i < kNumLitSelectors; i++)
    m_Literals[i].Init(kNumLitSymbols);
  unsigned numItems = (_numDictBits == 0 ? 1 : (_numDictBits << 1));
  const unsigned kNumPosSymbolsMax[kNumMatchSelectors] = { 24, 36, 42 };
  for (i = 0; i < kNumMatchSelectors; i++)
    m_PosSlot[i].Init(MyMin(numItems, kNumPosSymbolsMax[i]));
  m_LenSlot.Init(kNumLenSymbols);
}


HRESULT CDecoder::CodeSpec(const Byte *inData, size_t inSize, UInt32 outSize)
{
  if (inSize < 2)
    return S_FALSE;

  CRangeDecoder rc;
  rc.Stream.SetStreamAndInit(inData, inSize);
  rc.Init();

  while (outSize != 0)
  {
    if (rc.Stream.WasExtraRead())
      return S_FALSE;

    unsigned selector = m_Selector.Decode(&rc);
    
    if (selector < kNumLitSelectors)
    {
      Byte b = (Byte)((selector << (8 - kNumLitSelectorBits)) + m_Literals[selector].Decode(&rc));
      _outWindow.PutByte(b);
      outSize--;
    }
    else
    {
      selector -= kNumLitSelectors;
      unsigned len = selector + kMatchMinLen;
    
      if (selector == 2)
      {
        unsigned lenSlot = m_LenSlot.Decode(&rc);
        if (lenSlot >= kNumSimpleLenSlots)
        {
          lenSlot -= 2;
          unsigned numDirectBits = (unsigned)(lenSlot >> 2);
          len += ((4 | (lenSlot & 3)) << numDirectBits) - 2;
          if (numDirectBits < 6)
            len += rc.Stream.ReadBits(numDirectBits);
        }
        else
          len += lenSlot;
      }
      
      UInt32 dist = m_PosSlot[selector].Decode(&rc);
      
      if (dist >= kNumSimplePosSlots)
      {
        unsigned numDirectBits = (unsigned)((dist >> 1) - 1);
        dist = ((2 | (dist & 1)) << numDirectBits) + rc.Stream.ReadBits(numDirectBits);
      }
      
      unsigned locLen = len;
      if (len > outSize)
        locLen = (unsigned)outSize;
      if (!_outWindow.CopyBlock(dist, locLen))
        return S_FALSE;
      outSize -= locLen;
      len -= locLen;
      if (len != 0)
        return S_FALSE;
    }
  }

  return rc.Finish() ? S_OK : S_FALSE;
}

HRESULT CDecoder::Code(const Byte *inData, size_t inSize,
      ISequentialOutStream *outStream, UInt32 outSize,
      bool keepHistory)
{
  try
  {
    _outWindow.SetStream(outStream);
    _outWindow.Init(keepHistory);
    if (!keepHistory)
      Init();
    
    HRESULT res = CodeSpec(inData, inSize, outSize);
    HRESULT res2 = _outWindow.Flush();
    return res != S_OK ? res : res2;
  }
  catch(const CLzOutWindowException &e) { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
}

HRESULT CDecoder::SetParams(unsigned numDictBits)
{
  if (numDictBits > 21)
    return E_INVALIDARG;
  _numDictBits = numDictBits;
  if (!_outWindow.Create((UInt32)1 << _numDictBits))
    return E_OUTOFMEMORY;
  return S_OK;
}

}}
// QuantumDecoder.h

#ifndef __COMPRESS_QUANTUM_DECODER_H
#define __COMPRESS_QUANTUM_DECODER_H

#include "../../Common/MyCom.h"

#include "LzOutWindow.h"

namespace NCompress {
namespace NQuantum {

class CBitDecoder
{
  UInt32 Value;
  bool _extra;
  const Byte *_buf;
  const Byte *_bufLim;
public:
  void SetStreamAndInit(const Byte *inData, size_t inSize)
  {
    _buf = inData;
    _bufLim = inData + inSize;
    Value = 0x10000;
    _extra = false;
  }

  bool WasExtraRead() const { return _extra; }

  bool WasFinishedOK() const
  {
    return !_extra && _buf == _bufLim;
  }
  
  UInt32 ReadBit()
  {
    if (Value >= 0x10000)
    {
      Byte b;
      if (_buf >= _bufLim)
      {
        b = 0xFF;
        _extra = true;
      }
      else
        b = *_buf++;
      Value = 0x100 | b;
    }
    UInt32 res = (Value >> 7) & 1;
    Value <<= 1;
    return res;
  }

  UInt32 ReadStart16Bits()
  {
    // we use check for extra read in another code.
    UInt32 val = ((UInt32)*_buf << 8) | _buf[1];
    _buf += 2;
    return val;
  }

  UInt32 ReadBits(unsigned numBits) // numBits > 0
  {
    UInt32 res = 0;
    do
      res = (res << 1) | ReadBit();
    while (--numBits);
    return res;
  }
};


class CRangeDecoder
{
  UInt32 Low;
  UInt32 Range;
  UInt32 Code;
public:
  CBitDecoder Stream;

  void Init()
  {
    Low = 0;
    Range = 0x10000;
    Code = Stream.ReadStart16Bits();
  }

  bool Finish()
  {
    // do all streams use these two bits at end?
    if (Stream.ReadBit() != 0) return false;
    if (Stream.ReadBit() != 0) return false;
    return Stream.WasFinishedOK();
  }

  UInt32 GetThreshold(UInt32 total) const
  {
    return ((Code + 1) * total - 1) / Range; // & 0xFFFF is not required;
  }

  void Decode(UInt32 start, UInt32 end, UInt32 total)
  {
    UInt32 high = Low + end * Range / total - 1;
    UInt32 offset = start * Range / total;
    Code -= offset;
    Low += offset;
    for (;;)
    {
      if ((Low & 0x8000) != (high & 0x8000))
      {
        if ((Low & 0x4000) == 0 || (high & 0x4000) != 0)
          break;
        Low &= 0x3FFF;
        high |= 0x4000;
      }
      Low = (Low << 1) & 0xFFFF;
      high = ((high << 1) | 1) & 0xFFFF;
      Code = ((Code << 1) | Stream.ReadBit());
    }
    Range = high - Low + 1;
  }
};


const unsigned kNumLitSelectorBits = 2;
const unsigned kNumLitSelectors = (1 << kNumLitSelectorBits);
const unsigned kNumLitSymbols = 1 << (8 - kNumLitSelectorBits);
const unsigned kNumMatchSelectors = 3;
const unsigned kNumSelectors = kNumLitSelectors + kNumMatchSelectors;
const unsigned kNumSymbolsMax = kNumLitSymbols; // 64


class CModelDecoder
{
  unsigned NumItems;
  unsigned ReorderCount;
  UInt16 Freqs[kNumSymbolsMax + 1];
  Byte Vals[kNumSymbolsMax];
public:
  void Init(unsigned numItems);
  unsigned Decode(CRangeDecoder *rc);
};


class CDecoder:
  public IUnknown,
  public CMyUnknownImp
{
  CLzOutWindow _outWindow;
  unsigned _numDictBits;

  CModelDecoder m_Selector;
  CModelDecoder m_Literals[kNumLitSelectors];
  CModelDecoder m_PosSlot[kNumMatchSelectors];
  CModelDecoder m_LenSlot;

  void Init();
  HRESULT CodeSpec(const Byte *inData, size_t inSize, UInt32 outSize);
public:

  MY_UNKNOWN_IMP

  HRESULT Code(const Byte *inData, size_t inSize,
      ISequentialOutStream *outStream, UInt32 outSize,
      bool keepHistory);

  HRESULT SetParams(unsigned numDictBits);
  
  CDecoder(): _numDictBits(0) {}
  virtual ~CDecoder() {}
};

}}

#endif
// Rar1Decoder.cpp
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives
 
#include "StdAfx.h"

#include "Rar1Decoder.h"

namespace NCompress {
namespace NRar1 {

static const UInt32 PosL1[] = {0,0,0,2,3,5,7,11,16,20,24,32,32, 256};
static const UInt32 PosL2[] = {0,0,0,0,5,7,9,13,18,22,26,34,36, 256};
static const UInt32 PosHf0[] = {0,0,0,0,0,8,16,24,33,33,33,33,33, 257};
static const UInt32 PosHf1[] = {0,0,0,0,0,0,4,44,60,76,80,80,127, 257};
static const UInt32 PosHf2[] = {0,0,0,0,0,0,2,7,53,117,233, 257,0};
static const UInt32 PosHf3[] = {0,0,0,0,0,0,0,2,16,218,251, 257,0};
static const UInt32 PosHf4[] = {0,0,0,0,0,0,0,0,0,255, 257,0,0};

static const UInt32 kHistorySize = (1 << 16);

/*
class CCoderReleaser
{
  CDecoder *m_Coder;
public:
  CCoderReleaser(CDecoder *coder): m_Coder(coder) {}
  ~CCoderReleaser() { m_Coder->ReleaseStreams(); }
};
*/

CDecoder::CDecoder(): m_IsSolid(false) { }

void CDecoder::InitStructures()
{
  for (int i = 0; i < kNumRepDists; i++)
    m_RepDists[i] = 0;
  m_RepDistPtr = 0;
  LastLength = 0;
  LastDist = 0;
}

UInt32 CDecoder::ReadBits(int numBits) { return m_InBitStream.ReadBits(numBits); }

HRESULT CDecoder::CopyBlock(UInt32 distance, UInt32 len)
{
  if (len == 0)
    return S_FALSE;
  m_UnpackSize -= len;
  return m_OutWindowStream.CopyBlock(distance, len) ? S_OK : S_FALSE;
}


UInt32 CDecoder::DecodeNum(const UInt32 *posTab)
{
  UInt32 startPos = 2;
  UInt32 num = m_InBitStream.GetValue(12);
  for (;;)
  {
    UInt32 cur = (posTab[startPos + 1] - posTab[startPos]) << (12 - startPos);
    if (num < cur)
      break;
    startPos++;
    num -= cur;
  }
  m_InBitStream.MovePos(startPos);
  return((num >> (12 - startPos)) + posTab[startPos]);
}

static const Byte kShortLen1 [] = {1,3,4,4,5,6,7,8,8,4,4,5,6,6 };
static const Byte kShortLen1a[] = {1,4,4,4,5,6,7,8,8,4,4,5,6,6,4 };
static const Byte kShortLen2 [] = {2,3,3,3,4,4,5,6,6,4,4,5,6,6 };
static const Byte kShortLen2a[] = {2,3,3,4,4,4,5,6,6,4,4,5,6,6,4 };
static const UInt32 kShortXor1[] = {0,0xa0,0xd0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff,0xc0,0x80,0x90,0x98,0x9c,0xb0};
static const UInt32 kShortXor2[] = {0,0x40,0x60,0xa0,0xd0,0xe0,0xf0,0xf8,0xfc,0xc0,0x80,0x90,0x98,0x9c,0xb0};

HRESULT CDecoder::ShortLZ()
{
  UInt32 len, saveLen, dist;
  int distancePlace;
  const Byte *kShortLen;
  const UInt32 *kShortXor;
  NumHuf = 0;

  if (LCount == 2)
  {
    if (ReadBits(1))
      return CopyBlock(LastDist, LastLength);
    LCount = 0;
  }

  UInt32 bitField = m_InBitStream.GetValue(8);

  if (AvrLn1 < 37)
  {
    kShortLen = Buf60 ? kShortLen1a : kShortLen1;
    kShortXor = kShortXor1;
  }
  else
  {
    kShortLen = Buf60 ? kShortLen2a : kShortLen2;
    kShortXor = kShortXor2;
  }

  for (len = 0; ((bitField ^ kShortXor[len]) & (~(0xff >> kShortLen[len]))) != 0; len++);
  m_InBitStream.MovePos(kShortLen[len]);

  if (len >= 9)
  {
    if (len == 9)
    {
      LCount++;
      return CopyBlock(LastDist, LastLength);
    }
    if (len == 14)
    {
      LCount = 0;
      len = DecodeNum(PosL2) + 5;
      dist = 0x8000 + ReadBits(15) - 1;
      LastLength = len;
      LastDist = dist;
      return CopyBlock(dist, len);
    }

    LCount = 0;
    saveLen = len;
    dist = m_RepDists[(m_RepDistPtr - (len - 9)) & 3];
    len = DecodeNum(PosL1) + 2;
    if (len == 0x101 && saveLen == 10)
    {
      Buf60 ^= 1;
      return S_OK;
    }
    if (dist >= 256)
      len++;
    if (dist >= MaxDist3 - 1)
      len++;
  }
  else
  {
    LCount = 0;
    AvrLn1 += len;
    AvrLn1 -= AvrLn1 >> 4;
    
    distancePlace = DecodeNum(PosHf2) & 0xff;
    dist = ChSetA[(unsigned)distancePlace];
    if (--distancePlace != -1)
    {
      PlaceA[dist]--;
      UInt32 lastDistance = ChSetA[(unsigned)distancePlace];
      PlaceA[lastDistance]++;
      ChSetA[(unsigned)distancePlace + 1] = lastDistance;
      ChSetA[(unsigned)distancePlace] = dist;
    }
    len += 2;
  }

  m_RepDists[m_RepDistPtr++] = dist;
  m_RepDistPtr &= 3;
  LastLength = len;
  LastDist = dist;
  return CopyBlock(dist, len);
}


HRESULT CDecoder::LongLZ()
{
  UInt32 len;
  UInt32 dist;
  UInt32 distancePlace, newDistancePlace;
  UInt32 oldAvr2, oldAvr3;

  NumHuf = 0;
  Nlzb += 16;
  if (Nlzb > 0xff)
  {
    Nlzb = 0x90;
    Nhfb >>= 1;
  }
  oldAvr2=AvrLn2;

  if (AvrLn2 >= 122)
    len = DecodeNum(PosL2);
  else if (AvrLn2 >= 64)
    len = DecodeNum(PosL1);
  else
  {
    UInt32 bitField = m_InBitStream.GetValue(16);
    if (bitField < 0x100)
    {
      len = bitField;
      m_InBitStream.MovePos(16);
    }
    else
    {
      for (len = 0; ((bitField << len) & 0x8000) == 0; len++)
        ;
      m_InBitStream.MovePos(len + 1);
    }
  }

  AvrLn2 += len;
  AvrLn2 -= AvrLn2 >> 5;

  if (AvrPlcB > 0x28ff)
    distancePlace = DecodeNum(PosHf2);
  else if (AvrPlcB > 0x6ff)
    distancePlace = DecodeNum(PosHf1);
  else
    distancePlace = DecodeNum(PosHf0);

  AvrPlcB += distancePlace;
  AvrPlcB -= AvrPlcB >> 8;
  
  for (;;)
  {
    dist = ChSetB[distancePlace & 0xff];
    newDistancePlace = NToPlB[dist++ & 0xff]++;
    if (!(dist & 0xff))
      CorrHuff(ChSetB,NToPlB);
    else
      break;
  }

  ChSetB[distancePlace] = ChSetB[newDistancePlace];
  ChSetB[newDistancePlace] = dist;

  dist = ((dist & 0xff00) >> 1) | ReadBits(7);

  oldAvr3 = AvrLn3;
  
  if (len != 1 && len != 4)
    if (len == 0 && dist <= MaxDist3)
    {
      AvrLn3++;
      AvrLn3 -= AvrLn3 >> 8;
    }
    else
      if (AvrLn3 > 0)
        AvrLn3--;
  
  len += 3;
  
  if (dist >= MaxDist3)
    len++;
  if (dist <= 256)
    len += 8;
  
  if (oldAvr3 > 0xb0 || AvrPlc >= 0x2a00 && oldAvr2 < 0x40)
    MaxDist3 = 0x7f00;
  else
    MaxDist3 = 0x2001;
  
  m_RepDists[m_RepDistPtr++] = --dist;
  m_RepDistPtr &= 3;
  LastLength = len;
  LastDist = dist;
  
  return CopyBlock(dist, len);
}


HRESULT CDecoder::HuffDecode()
{
  UInt32 curByte, newBytePlace;
  UInt32 len;
  UInt32 dist;
  int bytePlace;

  if      (AvrPlc > 0x75ff)  bytePlace = DecodeNum(PosHf4);
  else if (AvrPlc > 0x5dff)  bytePlace = DecodeNum(PosHf3);
  else if (AvrPlc > 0x35ff)  bytePlace = DecodeNum(PosHf2);
  else if (AvrPlc > 0x0dff)  bytePlace = DecodeNum(PosHf1);
  else                       bytePlace = DecodeNum(PosHf0);
  
  if (StMode)
  {
    if (--bytePlace == -1)
    {
      if (ReadBits(1))
      {
        NumHuf = StMode = 0;
        return S_OK;
      }
      else
      {
        len = (ReadBits(1)) ? 4 : 3;
        dist = DecodeNum(PosHf2);
        dist = (dist << 5) | ReadBits(5);
        return CopyBlock(dist - 1, len);
      }
    }
  }
  else if (NumHuf++ >= 16 && FlagsCnt == 0)
    StMode = 1;
  
  bytePlace &= 0xff;
  AvrPlc += bytePlace;
  AvrPlc -= AvrPlc >> 8;
  Nhfb+=16;
  
  if (Nhfb > 0xff)
  {
    Nhfb=0x90;
    Nlzb >>= 1;
  }

  m_UnpackSize --;
  m_OutWindowStream.PutByte((Byte)(ChSet[bytePlace] >> 8));

  for (;;)
  {
    curByte = ChSet[bytePlace];
    newBytePlace = NToPl[curByte++ & 0xff]++;
    if ((curByte & 0xff) > 0xa1)
      CorrHuff(ChSet, NToPl);
    else
      break;
  }

  ChSet[bytePlace] = ChSet[newBytePlace];
  ChSet[newBytePlace] = curByte;
  return S_OK;
}


void CDecoder::GetFlagsBuf()
{
  UInt32 flags, newFlagsPlace;
  UInt32 flagsPlace = DecodeNum(PosHf2);

  for (;;)
  {
    flags = ChSetC[flagsPlace];
    FlagBuf = flags >> 8;
    newFlagsPlace = NToPlC[flags++ & 0xff]++;
    if ((flags & 0xff) != 0)
      break;
    CorrHuff(ChSetC, NToPlC);
  }

  ChSetC[flagsPlace] = ChSetC[newFlagsPlace];
  ChSetC[newFlagsPlace] = flags;
}

void CDecoder::InitData()
{
  if (!m_IsSolid)
  {
    AvrPlcB = AvrLn1 = AvrLn2 = AvrLn3 = NumHuf = Buf60 = 0;
    AvrPlc = 0x3500;
    MaxDist3 = 0x2001;
    Nhfb = Nlzb = 0x80;
  }
  FlagsCnt = 0;
  FlagBuf = 0;
  StMode = 0;
  LCount = 0;
}

void CDecoder::CorrHuff(UInt32 *CharSet,UInt32 *NumToPlace)
{
  int i;
  for (i = 7; i >= 0; i--)
    for (int j = 0; j < 32; j++, CharSet++)
      *CharSet = (*CharSet & ~0xff) | i;
  memset(NumToPlace, 0, sizeof(NToPl));
  for (i = 6; i >= 0; i--)
    NumToPlace[i] = (7 - i) * 32;
}

void CDecoder::InitHuff()
{
  for (UInt32 i = 0; i < 256; i++)
  {
    Place[i] = PlaceA[i] = PlaceB[i] = i;
    PlaceC[i] = (~i + 1) & 0xff;
    ChSet[i] = ChSetB[i] = i << 8;
    ChSetA[i] = i;
    ChSetC[i] = ((~i + 1) & 0xff) << 8;
  }
  memset(NToPl, 0, sizeof(NToPl));
  memset(NToPlB, 0, sizeof(NToPlB));
  memset(NToPlC, 0, sizeof(NToPlC));
  CorrHuff(ChSetB, NToPlB);
}

HRESULT CDecoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo * /* progress */)
{
  if (inSize == NULL || outSize == NULL)
    return E_INVALIDARG;

  if (!m_OutWindowStream.Create(kHistorySize))
    return E_OUTOFMEMORY;
  if (!m_InBitStream.Create(1 << 20))
    return E_OUTOFMEMORY;

  m_UnpackSize = (Int64)*outSize;
  m_OutWindowStream.SetStream(outStream);
  m_OutWindowStream.Init(m_IsSolid);
  m_InBitStream.SetStream(inStream);
  m_InBitStream.Init();

  // CCoderReleaser coderReleaser(this);
  InitData();
  if (!m_IsSolid)
  {
    InitStructures();
    InitHuff();
  }
  if (m_UnpackSize > 0)
  {
    GetFlagsBuf();
    FlagsCnt = 8;
  }

  while (m_UnpackSize > 0)
  {
    if (StMode)
    {
      RINOK(HuffDecode());
      continue;
    }

    if (--FlagsCnt < 0)
    {
      GetFlagsBuf();
      FlagsCnt=7;
    }

    if (FlagBuf & 0x80)
    {
      FlagBuf <<= 1;
      if (Nlzb > Nhfb)
      {
        RINOK(LongLZ());
      }
      else
      {
        RINOK(HuffDecode());
      }
    }
    else
    {
      FlagBuf <<= 1;
      if (--FlagsCnt < 0)
      {
        GetFlagsBuf();
        FlagsCnt = 7;
      }
      if (FlagBuf & 0x80)
      {
        FlagBuf <<= 1;
        if (Nlzb > Nhfb)
        {
          RINOK(HuffDecode());
        }
        else
        {
          RINOK(LongLZ());
        }
      }
      else
      {
        FlagBuf <<= 1;
        RINOK(ShortLZ());
      }
    }
  }
  if (m_UnpackSize < 0)
    return S_FALSE;
  return m_OutWindowStream.Flush();
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try { return CodeReal(inStream, outStream, inSize, outSize, progress); }
  catch(const CInBufferException &e) { return e.ErrorCode; }
  catch(const CLzOutWindowException &e) { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
}

STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *data, UInt32 size)
{
  if (size < 1)
    return E_INVALIDARG;
  m_IsSolid = ((data[0] & 1) != 0);
  return S_OK;
}

}}
// Rar1Decoder.h
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives

#ifndef __COMPRESS_RAR1_DECODER_H
#define __COMPRESS_RAR1_DECODER_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "../Common/InBuffer.h"

#include "BitmDecoder.h"
#include "HuffmanDecoder.h"
#include "LzOutWindow.h"

namespace NCompress {
namespace NRar1 {

const UInt32 kNumRepDists = 4;

typedef NBitm::CDecoder<CInBuffer> CBitDecoder;

class CDecoder :
  public ICompressCoder,
  public ICompressSetDecoderProperties2,
  public CMyUnknownImp
{
public:
  CLzOutWindow m_OutWindowStream;
  CBitDecoder m_InBitStream;

  UInt32 m_RepDists[kNumRepDists];
  UInt32 m_RepDistPtr;

  UInt32 LastDist;
  UInt32 LastLength;

  Int64 m_UnpackSize;
  bool m_IsSolid;

  UInt32 ReadBits(int numBits);
  HRESULT CopyBlock(UInt32 distance, UInt32 len);

  UInt32 DecodeNum(const UInt32 *posTab);
  HRESULT ShortLZ();
  HRESULT LongLZ();
  HRESULT HuffDecode();
  void GetFlagsBuf();
  void InitData();
  void InitHuff();
  void CorrHuff(UInt32 *CharSet, UInt32 *NumToPlace);
  void OldUnpWriteBuf();
  
  UInt32 ChSet[256],ChSetA[256],ChSetB[256],ChSetC[256];
  UInt32 Place[256],PlaceA[256],PlaceB[256],PlaceC[256];
  UInt32 NToPl[256],NToPlB[256],NToPlC[256];
  UInt32 FlagBuf,AvrPlc,AvrPlcB,AvrLn1,AvrLn2,AvrLn3;
  int Buf60,NumHuf,StMode,LCount,FlagsCnt;
  UInt32 Nhfb,Nlzb,MaxDist3;

  void InitStructures();

  HRESULT CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

public:
  CDecoder();

  MY_UNKNOWN_IMP1(ICompressSetDecoderProperties2)

  /*
  void ReleaseStreams()
  {
    m_OutWindowStream.ReleaseStream();
    m_InBitStream.ReleaseStream();
  }
  */

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);

};

}}

#endif
// Rar2Decoder.cpp
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives
 
#include "StdAfx.h"

#include "Rar2Decoder.h"

namespace NCompress {
namespace NRar2 {

namespace NMultimedia {

Byte CFilter::Decode(int &channelDelta, Byte deltaByte)
{
  D4 = D3;
  D3 = D2;
  D2 = LastDelta - D1;
  D1 = LastDelta;
  int predictedValue = ((8 * LastChar + K1 * D1 + K2 * D2 + K3 * D3 + K4 * D4 + K5 * channelDelta) >> 3);

  Byte realValue = (Byte)(predictedValue - deltaByte);
  
  {
    int i = ((int)(signed char)deltaByte) << 3;

    Dif[0] += abs(i);
    Dif[1] += abs(i - D1);
    Dif[2] += abs(i + D1);
    Dif[3] += abs(i - D2);
    Dif[4] += abs(i + D2);
    Dif[5] += abs(i - D3);
    Dif[6] += abs(i + D3);
    Dif[7] += abs(i - D4);
    Dif[8] += abs(i + D4);
    Dif[9] += abs(i - channelDelta);
    Dif[10] += abs(i + channelDelta);
  }

  channelDelta = LastDelta = (signed char)(realValue - LastChar);
  LastChar = realValue;

  if (((++ByteCount) & 0x1F) == 0)
  {
    UInt32 minDif = Dif[0];
    UInt32 numMinDif = 0;
    Dif[0] = 0;
    
    for (unsigned i = 1; i < ARRAY_SIZE(Dif); i++)
    {
      if (Dif[i] < minDif)
      {
        minDif = Dif[i];
        numMinDif = i;
      }
      Dif[i] = 0;
    }
    
    switch (numMinDif)
    {
      case 1: if (K1 >= -16) K1--; break;
      case 2: if (K1 <   16) K1++; break;
      case 3: if (K2 >= -16) K2--; break;
      case 4: if (K2 <   16) K2++; break;
      case 5: if (K3 >= -16) K3--; break;
      case 6: if (K3 <   16) K3++; break;
      case 7: if (K4 >= -16) K4--; break;
      case 8: if (K4 <   16) K4++; break;
      case 9: if (K5 >= -16) K5--; break;
      case 10:if (K5 <   16) K5++; break;
    }
  }
  
  return realValue;
}
}

static const UInt32 kHistorySize = 1 << 20;

static const UInt32 kWindowReservSize = (1 << 22) + 256;

CDecoder::CDecoder():
  m_IsSolid(false)
{
}

void CDecoder::InitStructures()
{
  m_MmFilter.Init();
  for (unsigned i = 0; i < kNumRepDists; i++)
    m_RepDists[i] = 0;
  m_RepDistPtr = 0;
  m_LastLength = 0;
  memset(m_LastLevels, 0, kMaxTableSize);
}

UInt32 CDecoder::ReadBits(unsigned numBits) { return m_InBitStream.ReadBits(numBits); }

#define RIF(x) { if (!(x)) return false; }

bool CDecoder::ReadTables(void)
{
  Byte levelLevels[kLevelTableSize];
  Byte newLevels[kMaxTableSize];
  m_AudioMode = (ReadBits(1) == 1);

  if (ReadBits(1) == 0)
    memset(m_LastLevels, 0, kMaxTableSize);
  
  unsigned numLevels;
  
  if (m_AudioMode)
  {
    m_NumChannels = ReadBits(2) + 1;
    if (m_MmFilter.CurrentChannel >= m_NumChannels)
      m_MmFilter.CurrentChannel = 0;
    numLevels = m_NumChannels * kMMTableSize;
  }
  else
    numLevels = kHeapTablesSizesSum;
 
  unsigned i;
  for (i = 0; i < kLevelTableSize; i++)
    levelLevels[i] = (Byte)ReadBits(4);
  RIF(m_LevelDecoder.Build(levelLevels));
  
  i = 0;
  
  while (i < numLevels)
  {
    UInt32 sym = m_LevelDecoder.Decode(&m_InBitStream);
    if (sym < kTableDirectLevels)
    {
      newLevels[i] = (Byte)((sym + m_LastLevels[i]) & kLevelMask);
      i++;
    }
    else
    {
      if (sym == kTableLevelRepNumber)
      {
        unsigned t = ReadBits(2) + 3;
        for (unsigned reps = t; reps > 0 && i < numLevels; reps--, i++)
          newLevels[i] = newLevels[i - 1];
      }
      else
      {
        unsigned num;
        if (sym == kTableLevel0Number)
          num = ReadBits(3) + 3;
        else if (sym == kTableLevel0Number2)
          num = ReadBits(7) + 11;
        else
          return false;
        for (; num > 0 && i < numLevels; num--)
          newLevels[i++] = 0;
      }
    }
  }

  if (m_AudioMode)
    for (i = 0; i < m_NumChannels; i++)
    {
      RIF(m_MMDecoders[i].Build(&newLevels[i * kMMTableSize]));
    }
  else
  {
    RIF(m_MainDecoder.Build(&newLevels[0]));
    RIF(m_DistDecoder.Build(&newLevels[kMainTableSize]));
    RIF(m_LenDecoder.Build(&newLevels[kMainTableSize + kDistTableSize]));
  }
  
  memcpy(m_LastLevels, newLevels, kMaxTableSize);
  return true;
}

bool CDecoder::ReadLastTables()
{
  // it differs a little from pure RAR sources;
  // UInt64 ttt = m_InBitStream.GetProcessedSize() + 2;
  // + 2 works for: return 0xFF; in CInBuffer::ReadByte.
  if (m_InBitStream.GetProcessedSize() + 7 <= m_PackSize) // test it: probably incorrect;
  // if (m_InBitStream.GetProcessedSize() + 2 <= m_PackSize) // test it: probably incorrect;
    if (m_AudioMode)
    {
      UInt32 symbol = m_MMDecoders[m_MmFilter.CurrentChannel].Decode(&m_InBitStream);
      if (symbol == 256)
        return ReadTables();
      if (symbol >= kMMTableSize)
        return false;
    }
    else
    {
      UInt32 sym = m_MainDecoder.Decode(&m_InBitStream);
      if (sym == kReadTableNumber)
        return ReadTables();
      if (sym >= kMainTableSize)
        return false;
    }
  return true;
}

/*
class CCoderReleaser
{
  CDecoder *m_Coder;
public:
  CCoderReleaser(CDecoder *coder): m_Coder(coder) {}
  ~CCoderReleaser()
  {
    m_Coder->ReleaseStreams();
  }
};
*/

bool CDecoder::DecodeMm(UInt32 pos)
{
  while (pos-- > 0)
  {
    UInt32 symbol = m_MMDecoders[m_MmFilter.CurrentChannel].Decode(&m_InBitStream);
    if (symbol == 256)
      return true;
    if (symbol >= kMMTableSize)
      return false;
    /*
    Byte byPredict = m_Predictor.Predict();
    Byte byReal = (Byte)(byPredict - (Byte)symbol);
    m_Predictor.Update(byReal, byPredict);
    */
    Byte byReal = m_MmFilter.Decode((Byte)symbol);
    m_OutWindowStream.PutByte(byReal);
    if (++m_MmFilter.CurrentChannel == m_NumChannels)
      m_MmFilter.CurrentChannel = 0;
  }
  return true;
}

bool CDecoder::DecodeLz(Int32 pos)
{
  while (pos > 0)
  {
    UInt32 sym = m_MainDecoder.Decode(&m_InBitStream);
    UInt32 length, distance;
    if (sym < 256)
    {
      m_OutWindowStream.PutByte(Byte(sym));
      pos--;
      continue;
    }
    else if (sym >= kMatchNumber)
    {
      sym -= kMatchNumber;
      length = kNormalMatchMinLen + UInt32(kLenStart[sym]) +
        m_InBitStream.ReadBits(kLenDirectBits[sym]);
      sym = m_DistDecoder.Decode(&m_InBitStream);
      if (sym >= kDistTableSize)
        return false;
      distance = kDistStart[sym] + m_InBitStream.ReadBits(kDistDirectBits[sym]);
      if (distance >= kDistLimit3)
      {
        length += 2 - ((distance - kDistLimit4) >> 31);
        // length++;
        // if (distance >= kDistLimit4)
        //  length++;
      }
    }
    else if (sym == kRepBothNumber)
    {
      length = m_LastLength;
      if (length == 0)
        return false;
      distance = m_RepDists[(m_RepDistPtr + 4 - 1) & 3];
    }
    else if (sym < kLen2Number)
    {
      distance = m_RepDists[(m_RepDistPtr - (sym - kRepNumber + 1)) & 3];
      sym = m_LenDecoder.Decode(&m_InBitStream);
      if (sym >= kLenTableSize)
        return false;
      length = 2 + kLenStart[sym] + m_InBitStream.ReadBits(kLenDirectBits[sym]);
      if (distance >= kDistLimit2)
      {
        length++;
        if (distance >= kDistLimit3)
        {
          length += 2 - ((distance - kDistLimit4) >> 31);
          // length++;
          // if (distance >= kDistLimit4)
          //   length++;
        }
      }
    }
    else if (sym < kReadTableNumber)
    {
      sym -= kLen2Number;
      distance = kLen2DistStarts[sym] +
        m_InBitStream.ReadBits(kLen2DistDirectBits[sym]);
      length = 2;
    }
    else if (sym == kReadTableNumber)
      return true;
    else
      return false;
    m_RepDists[m_RepDistPtr++ & 3] = distance;
    m_LastLength = length;
    if (!m_OutWindowStream.CopyBlock(distance, length))
      return false;
    pos -= length;
  }
  return true;
}

HRESULT CDecoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  if (inSize == NULL || outSize == NULL)
    return E_INVALIDARG;

  if (!m_OutWindowStream.Create(kHistorySize))
    return E_OUTOFMEMORY;
  if (!m_InBitStream.Create(1 << 20))
    return E_OUTOFMEMORY;

  m_PackSize = *inSize;

  UInt64 pos = 0, unPackSize = *outSize;
  
  m_OutWindowStream.SetStream(outStream);
  m_OutWindowStream.Init(m_IsSolid);
  m_InBitStream.SetStream(inStream);
  m_InBitStream.Init();

  // CCoderReleaser coderReleaser(this);
  if (!m_IsSolid)
  {
    InitStructures();
    if (unPackSize == 0)
    {
      if (m_InBitStream.GetProcessedSize() + 2 <= m_PackSize) // test it: probably incorrect;
        if (!ReadTables())
          return S_FALSE;
      return S_OK;
    }
    if (!ReadTables())
      return S_FALSE;
  }

  UInt64 startPos = m_OutWindowStream.GetProcessedSize();
  while (pos < unPackSize)
  {
    UInt32 blockSize = 1 << 20;
    if (blockSize > unPackSize - pos)
      blockSize = (UInt32)(unPackSize - pos);
    UInt64 blockStartPos = m_OutWindowStream.GetProcessedSize();
    if (m_AudioMode)
    {
      if (!DecodeMm(blockSize))
        return S_FALSE;
    }
    else
    {
      if (!DecodeLz((Int32)blockSize))
        return S_FALSE;
    }
    UInt64 globalPos = m_OutWindowStream.GetProcessedSize();
    pos = globalPos - blockStartPos;
    if (pos < blockSize)
      if (!ReadTables())
        return S_FALSE;
    pos = globalPos - startPos;
    if (progress != 0)
    {
      UInt64 packSize = m_InBitStream.GetProcessedSize();
      RINOK(progress->SetRatioInfo(&packSize, &pos));
    }
  }
  if (pos > unPackSize)
    return S_FALSE;

  if (!ReadLastTables())
    return S_FALSE;
  return m_OutWindowStream.Flush();
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try { return CodeReal(inStream, outStream, inSize, outSize, progress); }
  catch(const CInBufferException &e) { return e.ErrorCode; }
  catch(const CLzOutWindowException &e) { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
}

STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *data, UInt32 size)
{
  if (size < 1)
    return E_INVALIDARG;
  m_IsSolid = ((data[0] & 1) != 0);
  return S_OK;
}

}}
// Rar2Decoder.h
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives

#ifndef __COMPRESS_RAR2_DECODER_H
#define __COMPRESS_RAR2_DECODER_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "../Common/InBuffer.h"

#include "BitmDecoder.h"
#include "HuffmanDecoder.h"
#include "LzOutWindow.h"

namespace NCompress {
namespace NRar2 {

const unsigned kNumRepDists = 4;
const unsigned kDistTableSize = 48;

const unsigned kMMTableSize = 256 + 1;

const UInt32 kMainTableSize = 298;
const UInt32 kLenTableSize = 28;

const UInt32 kDistTableStart = kMainTableSize;
const UInt32 kLenTableStart = kDistTableStart + kDistTableSize;

const UInt32 kHeapTablesSizesSum = kMainTableSize + kDistTableSize + kLenTableSize;

const UInt32 kLevelTableSize = 19;

const UInt32 kMMTablesSizesSum = kMMTableSize * 4;

const UInt32 kMaxTableSize = kMMTablesSizesSum;

const UInt32 kTableDirectLevels = 16;
const UInt32 kTableLevelRepNumber = kTableDirectLevels;
const UInt32 kTableLevel0Number = kTableLevelRepNumber + 1;
const UInt32 kTableLevel0Number2 = kTableLevel0Number + 1;

const UInt32 kLevelMask = 0xF;


const UInt32 kRepBothNumber = 256;
const UInt32 kRepNumber = kRepBothNumber + 1;
const UInt32 kLen2Number = kRepNumber + 4;

const UInt32 kLen2NumNumbers = 8;
const UInt32 kReadTableNumber = kLen2Number + kLen2NumNumbers;
const UInt32 kMatchNumber = kReadTableNumber + 1;

const Byte kLenStart     [kLenTableSize] = {0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224};
const Byte kLenDirectBits[kLenTableSize] = {0,0,0,0,0,0,0,0,1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5};

const UInt32 kDistStart   [kDistTableSize] = {0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576,32768U,49152U,65536,98304,131072,196608,262144,327680,393216,458752,524288,589824,655360,720896,786432,851968,917504,983040};
const Byte kDistDirectBits[kDistTableSize] = {0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,    14,    14,   15,   15,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16,    16};

const Byte kLevelDirectBits[kLevelTableSize] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7};

const Byte kLen2DistStarts[kLen2NumNumbers]={0,4,8,16,32,64,128,192};
const Byte kLen2DistDirectBits[kLen2NumNumbers]={2,2,3, 4, 5, 6,  6,  6};

const UInt32 kDistLimit2 = 0x101 - 1;
const UInt32 kDistLimit3 = 0x2000 - 1;
const UInt32 kDistLimit4 = 0x40000 - 1;

const UInt32 kMatchMaxLen = 255 + 2;
const UInt32 kMatchMaxLenMax = 255 + 5;
const UInt32 kNormalMatchMinLen = 3;

namespace NMultimedia {

struct CFilter
{
  int K1,K2,K3,K4,K5;
  int D1,D2,D3,D4;
  int LastDelta;
  UInt32 Dif[11];
  UInt32 ByteCount;
  int LastChar;

  Byte Decode(int &channelDelta, Byte delta);

  void Init() { memset(this, 0, sizeof(*this)); }

};

const unsigned kNumChanelsMax = 4;

class CFilter2
{
public:
  CFilter  m_Filters[kNumChanelsMax];
  int m_ChannelDelta;
  unsigned CurrentChannel;

  void Init() { memset(this, 0, sizeof(*this)); }
  Byte Decode(Byte delta)
  {
    return m_Filters[CurrentChannel].Decode(m_ChannelDelta, delta);
  }

};

}

typedef NBitm::CDecoder<CInBuffer> CBitDecoder;

const unsigned kNumHuffmanBits = 15;

class CDecoder :
  public ICompressCoder,
  public ICompressSetDecoderProperties2,
  public CMyUnknownImp
{
  CLzOutWindow m_OutWindowStream;
  CBitDecoder m_InBitStream;
  NHuffman::CDecoder<kNumHuffmanBits, kMainTableSize> m_MainDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kDistTableSize> m_DistDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kLenTableSize> m_LenDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kMMTableSize> m_MMDecoders[NMultimedia::kNumChanelsMax];
  NHuffman::CDecoder<kNumHuffmanBits, kLevelTableSize> m_LevelDecoder;

  bool m_AudioMode;

  NMultimedia::CFilter2 m_MmFilter;
  unsigned m_NumChannels;

  UInt32 m_RepDists[kNumRepDists];
  UInt32 m_RepDistPtr;

  UInt32 m_LastLength;
  
  Byte m_LastLevels[kMaxTableSize];

  UInt64 m_PackSize;
  bool m_IsSolid;

  void InitStructures();
  UInt32 ReadBits(unsigned numBits);
  bool ReadTables();
  bool ReadLastTables();

  bool DecodeMm(UInt32 pos);
  bool DecodeLz(Int32 pos);

  HRESULT CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

public:
  CDecoder();

  MY_UNKNOWN_IMP1(ICompressSetDecoderProperties2)

  /*
  void ReleaseStreams()
  {
    m_OutWindowStream.ReleaseStream();
    m_InBitStream.ReleaseStream();
  }
  */

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);

};

}}

#endif
// Rar3Decoder.cpp
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives

/* This code uses Carryless rangecoder (1999): Dmitry Subbotin : Public domain */
 
#include "StdAfx.h"

#include "../../../C/Alloc.h"

#include "../Common/StreamUtils.h"

#include "Rar3Decoder.h"

namespace NCompress {
namespace NRar3 {

static const UInt32 kNumAlignReps = 15;

static const UInt32 kSymbolReadTable = 256;
static const UInt32 kSymbolRep = 259;
static const UInt32 kSymbolLen2 = kSymbolRep + kNumReps;

static const Byte kLenStart     [kLenTableSize] = {0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224};
static const Byte kLenDirectBits[kLenTableSize] = {0,0,0,0,0,0,0,0,1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5};

static const Byte kDistDirectBits[kDistTableSize] =
  {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  18,18,18,18,18,18,18,18,18,18,18,18};

static const Byte kLevelDirectBits[kLevelTableSize] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

static const Byte kLen2DistStarts[kNumLen2Symbols]={0,4,8,16,32,64,128,192};
static const Byte kLen2DistDirectBits[kNumLen2Symbols]={2,2,3, 4, 5, 6,  6,  6};

static const UInt32 kDistLimit3 = 0x2000 - 2;
static const UInt32 kDistLimit4 = 0x40000 - 2;

static const UInt32 kNormalMatchMinLen = 3;

static const UInt32 kVmDataSizeMax = 1 << 16;
static const UInt32 kVmCodeSizeMax = 1 << 16;

extern "C" {

static UInt32 Range_GetThreshold(void *pp, UInt32 total)
{
  CRangeDecoder *p = (CRangeDecoder *)pp;
  return p->Code / (p->Range /= total);
}

static void Range_Decode(void *pp, UInt32 start, UInt32 size)
{
  CRangeDecoder *p = (CRangeDecoder *)pp;
  start *= p->Range;
  p->Low += start;
  p->Code -= start;
  p->Range *= size;
  p->Normalize();
}

static UInt32 Range_DecodeBit(void *pp, UInt32 size0)
{
  CRangeDecoder *p = (CRangeDecoder *)pp;
  if (p->Code / (p->Range >>= 14) < size0)
  {
    Range_Decode(p, 0, size0);
    return 0;
  }
  else
  {
    Range_Decode(p, size0, (1 << 14) - size0);
    return 1;
  }
}

}

CRangeDecoder::CRangeDecoder()
{
  s.GetThreshold = Range_GetThreshold;
  s.Decode = Range_Decode;
  s.DecodeBit = Range_DecodeBit;
}

CDecoder::CDecoder():
  _window(0),
  _winPos(0),
  _wrPtr(0),
  _lzSize(0),
  _writtenFileSize(0),
  _vmData(0),
  _vmCode(0),
  m_IsSolid(false)
{
  Ppmd7_Construct(&_ppmd);
}

CDecoder::~CDecoder()
{
  InitFilters();
  ::MidFree(_vmData);
  ::MidFree(_window);
  Ppmd7_Free(&_ppmd, &g_BigAlloc);
}

HRESULT CDecoder::WriteDataToStream(const Byte *data, UInt32 size)
{
  return WriteStream(_outStream, data, size);
}

HRESULT CDecoder::WriteData(const Byte *data, UInt32 size)
{
  HRESULT res = S_OK;
  if (_writtenFileSize < _unpackSize)
  {
    UInt32 curSize = size;
    UInt64 remain = _unpackSize - _writtenFileSize;
    if (remain < curSize)
      curSize = (UInt32)remain;
    res = WriteDataToStream(data, curSize);
  }
  _writtenFileSize += size;
  return res;
}

HRESULT CDecoder::WriteArea(UInt32 startPtr, UInt32 endPtr)
{
  if (startPtr <= endPtr)
    return WriteData(_window + startPtr, endPtr - startPtr);
  RINOK(WriteData(_window + startPtr, kWindowSize - startPtr));
  return WriteData(_window, endPtr);
}

void CDecoder::ExecuteFilter(int tempFilterIndex, NVm::CBlockRef &outBlockRef)
{
  CTempFilter *tempFilter = _tempFilters[tempFilterIndex];
  tempFilter->InitR[6] = (UInt32)_writtenFileSize;
  NVm::SetValue32(&tempFilter->GlobalData[0x24], (UInt32)_writtenFileSize);
  NVm::SetValue32(&tempFilter->GlobalData[0x28], (UInt32)(_writtenFileSize >> 32));
  CFilter *filter = _filters[tempFilter->FilterIndex];
  if (!filter->IsSupported)
    _unsupportedFilter = true;
  _vm.Execute(filter, tempFilter, outBlockRef, filter->GlobalData);
  delete tempFilter;
  _tempFilters[tempFilterIndex] = 0;
}

HRESULT CDecoder::WriteBuf()
{
  UInt32 writtenBorder = _wrPtr;
  UInt32 writeSize = (_winPos - writtenBorder) & kWindowMask;
  FOR_VECTOR (i, _tempFilters)
  {
    CTempFilter *filter = _tempFilters[i];
    if (!filter)
      continue;
    if (filter->NextWindow)
    {
      filter->NextWindow = false;
      continue;
    }
    UInt32 blockStart = filter->BlockStart;
    UInt32 blockSize = filter->BlockSize;
    if (((blockStart - writtenBorder) & kWindowMask) < writeSize)
    {
      if (writtenBorder != blockStart)
      {
        RINOK(WriteArea(writtenBorder, blockStart));
        writtenBorder = blockStart;
        writeSize = (_winPos - writtenBorder) & kWindowMask;
      }
      if (blockSize <= writeSize)
      {
        UInt32 blockEnd = (blockStart + blockSize) & kWindowMask;
        if (blockStart < blockEnd || blockEnd == 0)
          _vm.SetMemory(0, _window + blockStart, blockSize);
        else
        {
          UInt32 tailSize = kWindowSize - blockStart;
          _vm.SetMemory(0, _window + blockStart, tailSize);
          _vm.SetMemory(tailSize, _window, blockEnd);
        }
        NVm::CBlockRef outBlockRef;
        ExecuteFilter(i, outBlockRef);
        while (i + 1 < _tempFilters.Size())
        {
          CTempFilter *nextFilter = _tempFilters[i + 1];
          if (!nextFilter
              || nextFilter->BlockStart != blockStart
              || nextFilter->BlockSize != outBlockRef.Size
              || nextFilter->NextWindow)
            break;
          _vm.SetMemory(0, _vm.GetDataPointer(outBlockRef.Offset), outBlockRef.Size);
          ExecuteFilter(++i, outBlockRef);
        }
        WriteDataToStream(_vm.GetDataPointer(outBlockRef.Offset), outBlockRef.Size);
        _writtenFileSize += outBlockRef.Size;
        writtenBorder = blockEnd;
        writeSize = (_winPos - writtenBorder) & kWindowMask;
      }
      else
      {
        for (unsigned j = i; j < _tempFilters.Size(); j++)
        {
          CTempFilter *filter2 = _tempFilters[j];
          if (filter2 && filter2->NextWindow)
            filter2->NextWindow = false;
        }
        _wrPtr = writtenBorder;
        return S_OK; // check it
      }
    }
  }
      
  _wrPtr = _winPos;
  return WriteArea(writtenBorder, _winPos);
}

void CDecoder::InitFilters()
{
  _lastFilter = 0;
  unsigned i;
  for (i = 0; i < _tempFilters.Size(); i++)
    delete _tempFilters[i];
  _tempFilters.Clear();
  for (i = 0; i < _filters.Size(); i++)
    delete _filters[i];
  _filters.Clear();
}

static const unsigned MAX_UNPACK_FILTERS = 8192;

bool CDecoder::AddVmCode(UInt32 firstByte, UInt32 codeSize)
{
  CMemBitDecoder inp;
  inp.Init(_vmData, codeSize);

  UInt32 filterIndex;
  
  if (firstByte & 0x80)
  {
    filterIndex = inp.ReadEncodedUInt32();
    if (filterIndex == 0)
      InitFilters();
    else
      filterIndex--;
  }
  else
    filterIndex = _lastFilter;
  
  if (filterIndex > (UInt32)_filters.Size())
    return false;
  _lastFilter = filterIndex;
  bool newFilter = (filterIndex == (UInt32)_filters.Size());

  CFilter *filter;
  if (newFilter)
  {
    // check if too many filters
    if (filterIndex > MAX_UNPACK_FILTERS)
      return false;
    filter = new CFilter;
    _filters.Add(filter);
  }
  else
  {
    filter = _filters[filterIndex];
    filter->ExecCount++;
  }

  unsigned numEmptyItems = 0;
  {
    FOR_VECTOR (i, _tempFilters)
    {
      _tempFilters[i - numEmptyItems] = _tempFilters[i];
      if (!_tempFilters[i])
        numEmptyItems++;
      if (numEmptyItems != 0)
        _tempFilters[i] = NULL;
    }
  }
  if (numEmptyItems == 0)
  {
    _tempFilters.Add(NULL);
    numEmptyItems = 1;
  }
  CTempFilter *tempFilter = new CTempFilter;
  _tempFilters[_tempFilters.Size() - numEmptyItems] = tempFilter;
  tempFilter->FilterIndex = filterIndex;
 
  UInt32 blockStart = inp.ReadEncodedUInt32();
  if (firstByte & 0x40)
    blockStart += 258;
  tempFilter->BlockStart = (blockStart + _winPos) & kWindowMask;
  if (firstByte & 0x20)
    filter->BlockSize = inp.ReadEncodedUInt32();
  tempFilter->BlockSize = filter->BlockSize;
  tempFilter->NextWindow = _wrPtr != _winPos && ((_wrPtr - _winPos) & kWindowMask) <= blockStart;

  memset(tempFilter->InitR, 0, sizeof(tempFilter->InitR));
  tempFilter->InitR[3] = NVm::kGlobalOffset;
  tempFilter->InitR[4] = tempFilter->BlockSize;
  tempFilter->InitR[5] = filter->ExecCount;
  if (firstByte & 0x10)
  {
    UInt32 initMask = inp.ReadBits(NVm::kNumGpRegs);
    for (unsigned i = 0; i < NVm::kNumGpRegs; i++)
      if (initMask & (1 << i))
        tempFilter->InitR[i] = inp.ReadEncodedUInt32();
  }

  bool isOK = true;
  if (newFilter)
  {
    UInt32 vmCodeSize = inp.ReadEncodedUInt32();
    if (vmCodeSize >= kVmCodeSizeMax || vmCodeSize == 0)
      return false;
    for (UInt32 i = 0; i < vmCodeSize; i++)
      _vmCode[i] = (Byte)inp.ReadBits(8);
    isOK = filter->PrepareProgram(_vmCode, vmCodeSize);
  }

  {
    Byte *globalData = &tempFilter->GlobalData[0];
    for (unsigned i = 0; i < NVm::kNumGpRegs; i++)
      NVm::SetValue32(&globalData[i * 4], tempFilter->InitR[i]);
    NVm::SetValue32(&globalData[NVm::NGlobalOffset::kBlockSize], tempFilter->BlockSize);
    NVm::SetValue32(&globalData[NVm::NGlobalOffset::kBlockPos], 0); // It was commented. why?
    NVm::SetValue32(&globalData[NVm::NGlobalOffset::kExecCount], filter->ExecCount);
  }

  if (firstByte & 8)
  {
    UInt32 dataSize = inp.ReadEncodedUInt32();
    if (dataSize > NVm::kGlobalSize - NVm::kFixedGlobalSize)
      return false;
    CRecordVector<Byte> &globalData = tempFilter->GlobalData;
    unsigned requiredSize = (unsigned)(dataSize + NVm::kFixedGlobalSize);
    if (globalData.Size() < requiredSize)
      globalData.ChangeSize_KeepData(requiredSize);
    Byte *dest = &globalData[NVm::kFixedGlobalSize];
    for (UInt32 i = 0; i < dataSize; i++)
      dest[i] = (Byte)inp.ReadBits(8);
  }
  
  return isOK;
}

bool CDecoder::ReadVmCodeLZ()
{
  UInt32 firstByte = ReadBits(8);
  UInt32 length = (firstByte & 7) + 1;
  if (length == 7)
    length = ReadBits(8) + 7;
  else if (length == 8)
    length = ReadBits(16);
  if (length > kVmDataSizeMax)
    return false;
  for (UInt32 i = 0; i < length; i++)
    _vmData[i] = (Byte)ReadBits(8);
  return AddVmCode(firstByte, length);
}

bool CDecoder::ReadVmCodePPM()
{
  int firstByte = DecodePpmSymbol();
  if (firstByte < 0)
    return false;
  UInt32 length = (firstByte & 7) + 1;
  if (length == 7)
  {
    int b1 = DecodePpmSymbol();
    if (b1 < 0)
      return false;
    length = b1 + 7;
  }
  else if (length == 8)
  {
    int b1 = DecodePpmSymbol();
    if (b1 < 0)
      return false;
    int b2 = DecodePpmSymbol();
    if (b2 < 0)
      return false;
    length = b1 * 256 + b2;
  }
  if (length > kVmDataSizeMax)
    return false;
  if (InputEofError_Fast())
    return false;
  for (UInt32 i = 0; i < length; i++)
  {
    int b = DecodePpmSymbol();
    if (b < 0)
      return false;
    _vmData[i] = (Byte)b;
  }
  return AddVmCode(firstByte, length);
}

#define RIF(x) { if (!(x)) return S_FALSE; }

UInt32 CDecoder::ReadBits(int numBits) { return m_InBitStream.BitDecoder.ReadBits(numBits); }

// ---------- PPM ----------

HRESULT CDecoder::InitPPM()
{
  unsigned maxOrder = (unsigned)ReadBits(7);

  bool reset = ((maxOrder & 0x20) != 0);
  int maxMB = 0;
  if (reset)
    maxMB = (Byte)ReadBits(8);
  else
  {
    if (PpmError || !Ppmd7_WasAllocated(&_ppmd))
      return S_FALSE;
  }
  if (maxOrder & 0x40)
    PpmEscChar = (Byte)ReadBits(8);
  m_InBitStream.InitRangeCoder();
  /*
  if (m_InBitStream.m_BitPos != 0)
    return S_FALSE;
  */
  if (reset)
  {
    PpmError = true;
    maxOrder = (maxOrder & 0x1F) + 1;
    if (maxOrder > 16)
      maxOrder = 16 + (maxOrder - 16) * 3;
    if (maxOrder == 1)
    {
      Ppmd7_Free(&_ppmd, &g_BigAlloc);
      return S_FALSE;
    }
    if (!Ppmd7_Alloc(&_ppmd, (maxMB + 1) << 20, &g_BigAlloc))
      return E_OUTOFMEMORY;
    Ppmd7_Init(&_ppmd, maxOrder);
    PpmError = false;
  }
  return S_OK;
}

int CDecoder::DecodePpmSymbol() { return Ppmd7_DecodeSymbol(&_ppmd, &m_InBitStream.s); }

HRESULT CDecoder::DecodePPM(Int32 num, bool &keepDecompressing)
{
  keepDecompressing = false;
  if (PpmError)
    return S_FALSE;
  do
  {
    if (((_wrPtr - _winPos) & kWindowMask) < 260 && _wrPtr != _winPos)
    {
      RINOK(WriteBuf());
      if (_writtenFileSize > _unpackSize)
      {
        keepDecompressing = false;
        return S_OK;
      }
    }
    if (InputEofError_Fast())
      return false;
    int c = DecodePpmSymbol();
    if (c < 0)
    {
      PpmError = true;
      return S_FALSE;
    }
    if (c == PpmEscChar)
    {
      int nextCh = DecodePpmSymbol();
      if (nextCh < 0)
      {
        PpmError = true;
        return S_FALSE;
      }
      if (nextCh == 0)
        return ReadTables(keepDecompressing);
      if (nextCh == 2 || nextCh == -1)
        return S_OK;
      if (nextCh == 3)
      {
        if (!ReadVmCodePPM())
        {
          PpmError = true;
          return S_FALSE;
        }
        continue;
      }
      if (nextCh == 4 || nextCh == 5)
      {
        UInt32 distance = 0;
        UInt32 length = 4;
        if (nextCh == 4)
        {
          for (int i = 0; i < 3; i++)
          {
            int c2 = DecodePpmSymbol();
            if (c2 < 0)
            {
              PpmError = true;
              return S_FALSE;
            }
            distance = (distance << 8) + (Byte)c2;
          }
          distance++;
          length += 28;
        }
        int c2 = DecodePpmSymbol();
        if (c2 < 0)
        {
          PpmError = true;
          return S_FALSE;
        }
        length += c2;
        if (distance >= _lzSize)
          return S_FALSE;
        CopyBlock(distance, length);
        num -= (Int32)length;
        continue;
      }
    }
    PutByte((Byte)c);
    num--;
  }
  while (num >= 0);
  keepDecompressing = true;
  return S_OK;
}

// ---------- LZ ----------

HRESULT CDecoder::ReadTables(bool &keepDecompressing)
{
  keepDecompressing = true;
  m_InBitStream.BitDecoder.AlignToByte();
  if (ReadBits(1) != 0)
  {
    _lzMode = false;
    return InitPPM();
  }

  _lzMode = true;
  PrevAlignBits = 0;
  PrevAlignCount = 0;

  Byte levelLevels[kLevelTableSize];
  Byte newLevels[kTablesSizesSum];

  if (ReadBits(1) == 0)
    memset(m_LastLevels, 0, kTablesSizesSum);

  int i;
  for (i = 0; i < kLevelTableSize; i++)
  {
    UInt32 length = ReadBits(4);
    if (length == 15)
    {
      UInt32 zeroCount = ReadBits(4);
      if (zeroCount != 0)
      {
        zeroCount += 2;
        while (zeroCount-- > 0 && i < kLevelTableSize)
          levelLevels[i++]=0;
        i--;
        continue;
      }
    }
    levelLevels[i] = (Byte)length;
  }
  RIF(m_LevelDecoder.Build(levelLevels));
  i = 0;
  while (i < kTablesSizesSum)
  {
    UInt32 sym = m_LevelDecoder.Decode(&m_InBitStream.BitDecoder);
    if (sym < 16)
    {
      newLevels[i] = Byte((sym + m_LastLevels[i]) & 15);
      i++;
    }
    else if (sym > kLevelTableSize)
      return S_FALSE;
    else
    {
      int num;
      if (((sym - 16) & 1) == 0)
        num = ReadBits(3) + 3;
      else
        num = ReadBits(7) + 11;
      if (sym < 18)
      {
        if (i == 0)
          return S_FALSE;
        for (; num > 0 && i < kTablesSizesSum; num--, i++)
          newLevels[i] = newLevels[i - 1];
      }
      else
      {
        for (; num > 0 && i < kTablesSizesSum; num--)
          newLevels[i++] = 0;
      }
    }
  }
  TablesRead = true;

  // original code has check here:
  /*
  if (InAddr > ReadTop)
  {
    keepDecompressing = false;
    return true;
  }
  */

  RIF(m_MainDecoder.Build(&newLevels[0]));
  RIF(m_DistDecoder.Build(&newLevels[kMainTableSize]));
  RIF(m_AlignDecoder.Build(&newLevels[kMainTableSize + kDistTableSize]));
  RIF(m_LenDecoder.Build(&newLevels[kMainTableSize + kDistTableSize + kAlignTableSize]));

  memcpy(m_LastLevels, newLevels, kTablesSizesSum);
  return S_OK;
}

/*
class CCoderReleaser
{
  CDecoder *m_Coder;
public:
  CCoderReleaser(CDecoder *coder): m_Coder(coder) {}
  ~CCoderReleaser()
  {
    m_Coder->ReleaseStreams();
  }
};
*/

HRESULT CDecoder::ReadEndOfBlock(bool &keepDecompressing)
{
  if (ReadBits(1) != 0)
  {
    // old file
    TablesRead = false;
    return ReadTables(keepDecompressing);
  }
  // new file
  keepDecompressing = false;
  TablesRead = (ReadBits(1) == 0);
  return S_OK;
}

UInt32 kDistStart[kDistTableSize];

class CDistInit
{
public:
  CDistInit() { Init(); }
  void Init()
  {
    UInt32 start = 0;
    for (UInt32 i = 0; i < kDistTableSize; i++)
    {
      kDistStart[i] = start;
      start += (1 << kDistDirectBits[i]);
    }
  }
} g_DistInit;

HRESULT CDecoder::DecodeLZ(bool &keepDecompressing)
{
  UInt32 rep0 = _reps[0];
  UInt32 rep1 = _reps[1];
  UInt32 rep2 = _reps[2];
  UInt32 rep3 = _reps[3];
  UInt32 length = _lastLength;
  for (;;)
  {
    if (((_wrPtr - _winPos) & kWindowMask) < 260 && _wrPtr != _winPos)
    {
      RINOK(WriteBuf());
      if (_writtenFileSize > _unpackSize)
      {
        keepDecompressing = false;
        return S_OK;
      }
    }
    
    if (InputEofError_Fast())
      return S_FALSE;

    UInt32 sym = m_MainDecoder.Decode(&m_InBitStream.BitDecoder);
    if (sym < 256)
    {
      PutByte((Byte)sym);
      continue;
    }
    else if (sym == kSymbolReadTable)
    {
      RINOK(ReadEndOfBlock(keepDecompressing));
      break;
    }
    else if (sym == 257)
    {
      if (!ReadVmCodeLZ())
        return S_FALSE;
      continue;
    }
    else if (sym == 258)
    {
      if (length == 0)
        return S_FALSE;
    }
    else if (sym < kSymbolRep + 4)
    {
      if (sym != kSymbolRep)
      {
        UInt32 distance;
        if (sym == kSymbolRep + 1)
          distance = rep1;
        else
        {
          if (sym == kSymbolRep + 2)
            distance = rep2;
          else
          {
            distance = rep3;
            rep3 = rep2;
          }
          rep2 = rep1;
        }
        rep1 = rep0;
        rep0 = distance;
      }

      const UInt32 sym2 = m_LenDecoder.Decode(&m_InBitStream.BitDecoder);
      if (sym2 >= kLenTableSize)
        return S_FALSE;
      length = 2 + kLenStart[sym2] + m_InBitStream.BitDecoder.ReadBits(kLenDirectBits[sym2]);
    }
    else
    {
      rep3 = rep2;
      rep2 = rep1;
      rep1 = rep0;
      if (sym < 271)
      {
        sym -= 263;
        rep0 = kLen2DistStarts[sym] + m_InBitStream.BitDecoder.ReadBits(kLen2DistDirectBits[sym]);
        length = 2;
      }
      else if (sym < 299)
      {
        sym -= 271;
        length = kNormalMatchMinLen + (UInt32)kLenStart[sym] + m_InBitStream.BitDecoder.ReadBits(kLenDirectBits[sym]);
        const UInt32 sym2 = m_DistDecoder.Decode(&m_InBitStream.BitDecoder);
        if (sym2 >= kDistTableSize)
          return S_FALSE;
        rep0 = kDistStart[sym2];
        int numBits = kDistDirectBits[sym2];
        if (sym2 >= (kNumAlignBits * 2) + 2)
        {
          if (numBits > kNumAlignBits)
            rep0 += (m_InBitStream.BitDecoder.ReadBits(numBits - kNumAlignBits) << kNumAlignBits);
          if (PrevAlignCount > 0)
          {
            PrevAlignCount--;
            rep0 += PrevAlignBits;
          }
          else
          {
            const UInt32 sym3 = m_AlignDecoder.Decode(&m_InBitStream.BitDecoder);
            if (sym3 < (1 << kNumAlignBits))
            {
              rep0 += sym3;
              PrevAlignBits = sym3;
            }
            else if (sym3 == (1 << kNumAlignBits))
            {
              PrevAlignCount = kNumAlignReps;
              rep0 += PrevAlignBits;
            }
            else
              return S_FALSE;
          }
        }
        else
          rep0 += m_InBitStream.BitDecoder.ReadBits(numBits);
        length += ((kDistLimit4 - rep0) >> 31) + ((kDistLimit3 - rep0) >> 31);
      }
      else
        return S_FALSE;
    }
    if (rep0 >= _lzSize)
      return S_FALSE;
    CopyBlock(rep0, length);
  }
  _reps[0] = rep0;
  _reps[1] = rep1;
  _reps[2] = rep2;
  _reps[3] = rep3;
  _lastLength = length;

  return S_OK;
}

HRESULT CDecoder::CodeReal(ICompressProgressInfo *progress)
{
  _writtenFileSize = 0;
  _unsupportedFilter = false;
  if (!m_IsSolid)
  {
    _lzSize = 0;
    _winPos = 0;
    _wrPtr = 0;
    for (int i = 0; i < kNumReps; i++)
      _reps[i] = 0;
    _lastLength = 0;
    memset(m_LastLevels, 0, kTablesSizesSum);
    TablesRead = false;
    PpmEscChar = 2;
    PpmError = true;
    InitFilters();
  }
  if (!m_IsSolid || !TablesRead)
  {
    bool keepDecompressing;
    RINOK(ReadTables(keepDecompressing));
    if (!keepDecompressing)
      return S_OK;
  }

  for (;;)
  {
    bool keepDecompressing;
    if (_lzMode)
    {
      RINOK(DecodeLZ(keepDecompressing))
    }
    else
    {
      RINOK(DecodePPM(1 << 18, keepDecompressing))
    }

    if (InputEofError())
      return S_FALSE;

    UInt64 packSize = m_InBitStream.BitDecoder.GetProcessedSize();
    RINOK(progress->SetRatioInfo(&packSize, &_writtenFileSize));
    if (!keepDecompressing)
      break;
  }
  RINOK(WriteBuf());
  UInt64 packSize = m_InBitStream.BitDecoder.GetProcessedSize();
  RINOK(progress->SetRatioInfo(&packSize, &_writtenFileSize));
  if (_writtenFileSize < _unpackSize)
    return S_FALSE;

  if (_unsupportedFilter)
    return E_NOTIMPL;

  return S_OK;
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try
  {
    if (!inSize)
      return E_INVALIDARG;

    if (!_vmData)
    {
      _vmData = (Byte *)::MidAlloc(kVmDataSizeMax + kVmCodeSizeMax);
      if (!_vmData)
        return E_OUTOFMEMORY;
      _vmCode = _vmData + kVmDataSizeMax;
    }
    
    if (!_window)
    {
      _window = (Byte *)::MidAlloc(kWindowSize);
      if (!_window)
        return E_OUTOFMEMORY;
    }
    if (!m_InBitStream.BitDecoder.Create(1 << 20))
      return E_OUTOFMEMORY;
    if (!_vm.Create())
      return E_OUTOFMEMORY;

    
    m_InBitStream.BitDecoder.SetStream(inStream);
    m_InBitStream.BitDecoder.Init();
    _outStream = outStream;
   
    // CCoderReleaser coderReleaser(this);
    _unpackSize = outSize ? *outSize : (UInt64)(Int64)-1;
    return CodeReal(progress);
  }
  catch(const CInBufferException &e)  { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
  // CNewException is possible here. But probably CNewException is caused
  // by error in data stream.
}

STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *data, UInt32 size)
{
  if (size < 1)
    return E_INVALIDARG;
  m_IsSolid = ((data[0] & 1) != 0);
  return S_OK;
}

}}
// Rar3Decoder.h
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives

/* This code uses Carryless rangecoder (1999): Dmitry Subbotin : Public domain */

#ifndef __COMPRESS_RAR3_DECODER_H
#define __COMPRESS_RAR3_DECODER_H

#include "../../../C/Ppmd7.h"

#include "../../Common/MyCom.h"

#include "../ICoder.h"

#include "../Common/InBuffer.h"

#include "BitmDecoder.h"
#include "HuffmanDecoder.h"
#include "Rar3Vm.h"

namespace NCompress {
namespace NRar3 {

const UInt32 kWindowSize = 1 << 22;
const UInt32 kWindowMask = (kWindowSize - 1);

const UInt32 kNumReps = 4;
const UInt32 kNumLen2Symbols = 8;
const UInt32 kLenTableSize = 28;
const UInt32 kMainTableSize = 256 + 1 + 1 + 1 + kNumReps + kNumLen2Symbols + kLenTableSize;
const UInt32 kDistTableSize = 60;

const int kNumAlignBits = 4;
const UInt32 kAlignTableSize = (1 << kNumAlignBits) + 1;

const UInt32 kLevelTableSize = 20;

const UInt32 kTablesSizesSum = kMainTableSize + kDistTableSize + kAlignTableSize + kLenTableSize;

class CBitDecoder
{
  UInt32 _value;
  unsigned _bitPos;
public:
  CInBuffer Stream;

  bool Create(UInt32 bufSize) { return Stream.Create(bufSize); }
  void SetStream(ISequentialInStream *inStream) { Stream.SetStream(inStream);}

  void Init()
  {
    Stream.Init();
    _bitPos = 0;
    _value = 0;
  }
  
  bool ExtraBitsWereRead() const
  {
    return (Stream.NumExtraBytes > 4 || _bitPos < (Stream.NumExtraBytes << 3));
  }

  UInt64 GetProcessedSize() const { return Stream.GetProcessedSize() - (_bitPos >> 3); }

  void AlignToByte()
  {
    _bitPos &= ~(unsigned)7;
    _value = _value & ((1 << _bitPos) - 1);
  }
  
  UInt32 GetValue(unsigned numBits)
  {
    if (_bitPos < numBits)
    {
      _bitPos += 8;
      _value = (_value << 8) | Stream.ReadByte();
      if (_bitPos < numBits)
      {
        _bitPos += 8;
        _value = (_value << 8) | Stream.ReadByte();
      }
    }
    return _value >> (_bitPos - numBits);
  }
  
  void MovePos(unsigned numBits)
  {
    _bitPos -= numBits;
    _value = _value & ((1 << _bitPos) - 1);
  }
  
  UInt32 ReadBits(unsigned numBits)
  {
    UInt32 res = GetValue(numBits);
    MovePos(numBits);
    return res;
  }
};

const UInt32 kTopValue = (1 << 24);
const UInt32 kBot = (1 << 15);

struct CRangeDecoder
{
  IPpmd7_RangeDec s;
  UInt32 Range;
  UInt32 Code;
  UInt32 Low;
  CBitDecoder BitDecoder;
  SRes Res;

public:
  void InitRangeCoder()
  {
    Code = 0;
    Low = 0;
    Range = 0xFFFFFFFF;
    for (int i = 0; i < 4; i++)
      Code = (Code << 8) | BitDecoder.ReadBits(8);
  }

  void Normalize()
  {
    while ((Low ^ (Low + Range)) < kTopValue ||
       Range < kBot && ((Range = (0 - Low) & (kBot - 1)), 1))
    {
      Code = (Code << 8) | BitDecoder.Stream.ReadByte();
      Range <<= 8;
      Low <<= 8;
    }
  }

  CRangeDecoder();
};

struct CFilter: public NVm::CProgram
{
  CRecordVector<Byte> GlobalData;
  UInt32 BlockStart;
  UInt32 BlockSize;
  UInt32 ExecCount;
  
  CFilter(): BlockStart(0), BlockSize(0), ExecCount(0) {}
};

struct CTempFilter: public NVm::CProgramInitState
{
  UInt32 BlockStart;
  UInt32 BlockSize;
  bool NextWindow;
  
  UInt32 FilterIndex;

  CTempFilter()
  {
    // all filters must contain at least FixedGlobal block
    AllocateEmptyFixedGlobal();
  }
};

const int kNumHuffmanBits = 15;

class CDecoder:
  public ICompressCoder,
  public ICompressSetDecoderProperties2,
  public CMyUnknownImp
{
  CRangeDecoder m_InBitStream;
  Byte *_window;
  UInt32 _winPos;
  UInt32 _wrPtr;
  UInt64 _lzSize;
  UInt64 _unpackSize;
  UInt64 _writtenFileSize; // if it's > _unpackSize, then _unpackSize only written
  ISequentialOutStream *_outStream;
  NHuffman::CDecoder<kNumHuffmanBits, kMainTableSize> m_MainDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kDistTableSize> m_DistDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kAlignTableSize> m_AlignDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kLenTableSize> m_LenDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kLevelTableSize> m_LevelDecoder;

  UInt32 _reps[kNumReps];
  UInt32 _lastLength;
  
  Byte m_LastLevels[kTablesSizesSum];

  Byte *_vmData;
  Byte *_vmCode;
  NVm::CVm _vm;
  CRecordVector<CFilter *> _filters;
  CRecordVector<CTempFilter *>  _tempFilters;
  UInt32 _lastFilter;

  bool m_IsSolid;

  bool _lzMode;
  bool _unsupportedFilter;

  UInt32 PrevAlignBits;
  UInt32 PrevAlignCount;

  bool TablesRead;

  CPpmd7 _ppmd;
  int PpmEscChar;
  bool PpmError;
  
  HRESULT WriteDataToStream(const Byte *data, UInt32 size);
  HRESULT WriteData(const Byte *data, UInt32 size);
  HRESULT WriteArea(UInt32 startPtr, UInt32 endPtr);
  void ExecuteFilter(int tempFilterIndex, NVm::CBlockRef &outBlockRef);
  HRESULT WriteBuf();

  void InitFilters();
  bool AddVmCode(UInt32 firstByte, UInt32 codeSize);
  bool ReadVmCodeLZ();
  bool ReadVmCodePPM();
  
  UInt32 ReadBits(int numBits);

  HRESULT InitPPM();
  int DecodePpmSymbol();
  HRESULT DecodePPM(Int32 num, bool &keepDecompressing);

  HRESULT ReadTables(bool &keepDecompressing);
  HRESULT ReadEndOfBlock(bool &keepDecompressing);
  HRESULT DecodeLZ(bool &keepDecompressing);
  HRESULT CodeReal(ICompressProgressInfo *progress);
  
  bool InputEofError() const { return m_InBitStream.BitDecoder.ExtraBitsWereRead(); }
  bool InputEofError_Fast() const { return (m_InBitStream.BitDecoder.Stream.NumExtraBytes > 2); }

public:
  CDecoder();
  ~CDecoder();

  MY_UNKNOWN_IMP1(ICompressSetDecoderProperties2)

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);

  void CopyBlock(UInt32 distance, UInt32 len)
  {
    _lzSize += len;
    UInt32 pos = (_winPos - distance - 1) & kWindowMask;
    Byte *window = _window;
    UInt32 winPos = _winPos;
    if (kWindowSize - winPos > len && kWindowSize - pos > len)
    {
      const Byte *src = window + pos;
      Byte *dest = window + winPos;
      _winPos += len;
      do
        *dest++ = *src++;
      while (--len != 0);
      return;
    }
    do
    {
      window[winPos] = window[pos];
      winPos = (winPos + 1) & kWindowMask;
      pos = (pos + 1) & kWindowMask;
    }
    while (--len != 0);
    _winPos = winPos;
  }
  
  void PutByte(Byte b)
  {
    _window[_winPos] = b;
    _winPos = (_winPos + 1) & kWindowMask;
    _lzSize++;
  }


};

}}

#endif
// Rar3Vm.cpp
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives

/*
Note:
  Due to performance considerations Rar VM may set Flags C incorrectly
  for some operands (SHL x, 0, ... ).
  Check implementation of concrete VM command
  to see if it sets flags right.
*/

#include "StdAfx.h"

#include <stdlib.h>

#include "../../../C/7zCrc.h"
#include "../../../C/Alloc.h"

#include "../../Common/Defs.h"

#include "Rar3Vm.h"

namespace NCompress {
namespace NRar3 {

UInt32 CMemBitDecoder::ReadBits(unsigned numBits)
{
  UInt32 res = 0;
  for (;;)
  {
    unsigned b = _bitPos < _bitSize ? (unsigned)_data[_bitPos >> 3] : 0;
    unsigned avail = (unsigned)(8 - (_bitPos & 7));
    if (numBits <= avail)
    {
      _bitPos += numBits;
      return res | (b >> (avail - numBits)) & ((1 << numBits) - 1);
    }
    numBits -= avail;
    res |= (UInt32)(b & ((1 << avail) - 1)) << numBits;
    _bitPos += avail;
  }
}

UInt32 CMemBitDecoder::ReadBit() { return ReadBits(1); }

UInt32 CMemBitDecoder::ReadEncodedUInt32()
{
  unsigned v = (unsigned)ReadBits(2);
  UInt32 res = ReadBits(4 << v);
  if (v == 1 && res < 16)
    res = 0xFFFFFF00 | (res << 4) | ReadBits(4);
  return res;
}

namespace NVm {

static const UInt32 kStackRegIndex = kNumRegs - 1;

#ifdef RARVM_VM_ENABLE

static const UInt32 FLAG_C = 1;
static const UInt32 FLAG_Z = 2;
static const UInt32 FLAG_S = 0x80000000;

static const Byte CF_OP0 = 0;
static const Byte CF_OP1 = 1;
static const Byte CF_OP2 = 2;
static const Byte CF_OPMASK = 3;
static const Byte CF_BYTEMODE = 4;
static const Byte CF_JUMP = 8;
static const Byte CF_PROC = 16;
static const Byte CF_USEFLAGS = 32;
static const Byte CF_CHFLAGS = 64;

static const Byte kCmdFlags[]=
{
  /* CMD_MOV   */ CF_OP2 | CF_BYTEMODE,
  /* CMD_CMP   */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_ADD   */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_SUB   */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_JZ    */ CF_OP1 | CF_JUMP | CF_USEFLAGS,
  /* CMD_JNZ   */ CF_OP1 | CF_JUMP | CF_USEFLAGS,
  /* CMD_INC   */ CF_OP1 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_DEC   */ CF_OP1 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_JMP   */ CF_OP1 | CF_JUMP,
  /* CMD_XOR   */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_AND   */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_OR    */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_TEST  */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_JS    */ CF_OP1 | CF_JUMP | CF_USEFLAGS,
  /* CMD_JNS   */ CF_OP1 | CF_JUMP | CF_USEFLAGS,
  /* CMD_JB    */ CF_OP1 | CF_JUMP | CF_USEFLAGS,
  /* CMD_JBE   */ CF_OP1 | CF_JUMP | CF_USEFLAGS,
  /* CMD_JA    */ CF_OP1 | CF_JUMP | CF_USEFLAGS,
  /* CMD_JAE   */ CF_OP1 | CF_JUMP | CF_USEFLAGS,
  /* CMD_PUSH  */ CF_OP1,
  /* CMD_POP   */ CF_OP1,
  /* CMD_CALL  */ CF_OP1 | CF_PROC,
  /* CMD_RET   */ CF_OP0 | CF_PROC,
  /* CMD_NOT   */ CF_OP1 | CF_BYTEMODE,
  /* CMD_SHL   */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_SHR   */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_SAR   */ CF_OP2 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_NEG   */ CF_OP1 | CF_BYTEMODE | CF_CHFLAGS,
  /* CMD_PUSHA */ CF_OP0,
  /* CMD_POPA  */ CF_OP0,
  /* CMD_PUSHF */ CF_OP0 | CF_USEFLAGS,
  /* CMD_POPF  */ CF_OP0 | CF_CHFLAGS,
  /* CMD_MOVZX */ CF_OP2,
  /* CMD_MOVSX */ CF_OP2,
  /* CMD_XCHG  */ CF_OP2 | CF_BYTEMODE,
  /* CMD_MUL   */ CF_OP2 | CF_BYTEMODE,
  /* CMD_DIV   */ CF_OP2 | CF_BYTEMODE,
  /* CMD_ADC   */ CF_OP2 | CF_BYTEMODE | CF_USEFLAGS | CF_CHFLAGS ,
  /* CMD_SBB   */ CF_OP2 | CF_BYTEMODE | CF_USEFLAGS | CF_CHFLAGS ,
  /* CMD_PRINT */ CF_OP0
};

#endif


CVm::CVm(): Mem(NULL) {}

bool CVm::Create()
{
  if (!Mem)
    Mem = (Byte *)::MyAlloc(kSpaceSize + 4);
  return (Mem != NULL);
}

CVm::~CVm()
{
  ::MyFree(Mem);
}

// CVm::Execute can change CProgram object: it clears progarm if VM returns error.

bool CVm::Execute(CProgram *prg, const CProgramInitState *initState,
    CBlockRef &outBlockRef, CRecordVector<Byte> &outGlobalData)
{
  memcpy(R, initState->InitR, sizeof(initState->InitR));
  R[kStackRegIndex] = kSpaceSize;
  R[kNumRegs] = 0;
  Flags = 0;

  UInt32 globalSize = MyMin((UInt32)initState->GlobalData.Size(), kGlobalSize);
  if (globalSize != 0)
    memcpy(Mem + kGlobalOffset, &initState->GlobalData[0], globalSize);
  UInt32 staticSize = MyMin((UInt32)prg->StaticData.Size(), kGlobalSize - globalSize);
  if (staticSize != 0)
    memcpy(Mem + kGlobalOffset + globalSize, &prg->StaticData[0], staticSize);

  bool res = true;
  
  #ifdef RARVM_STANDARD_FILTERS
  if (prg->StandardFilterIndex >= 0)
    ExecuteStandardFilter(prg->StandardFilterIndex);
  else
  #endif
  {
    #ifdef RARVM_VM_ENABLE
    res = ExecuteCode(prg);
    if (!res)
    {
      prg->Commands.Clear();
      prg->Commands.Add(CCommand());
      prg->Commands.Back().OpCode = CMD_RET;
    }
    #else
    res = false;
    #endif
  }
  
  UInt32 newBlockPos = GetFixedGlobalValue32(NGlobalOffset::kBlockPos) & kSpaceMask;
  UInt32 newBlockSize = GetFixedGlobalValue32(NGlobalOffset::kBlockSize) & kSpaceMask;
  if (newBlockPos + newBlockSize >= kSpaceSize)
    newBlockPos = newBlockSize = 0;
  outBlockRef.Offset = newBlockPos;
  outBlockRef.Size = newBlockSize;

  outGlobalData.Clear();
  UInt32 dataSize = GetFixedGlobalValue32(NGlobalOffset::kGlobalMemOutSize);
  dataSize = MyMin(dataSize, kGlobalSize - kFixedGlobalSize);
  if (dataSize != 0)
  {
    dataSize += kFixedGlobalSize;
    outGlobalData.ClearAndSetSize(dataSize);
    memcpy(&outGlobalData[0], Mem + kGlobalOffset, dataSize);
  }

  return res;
}

#ifdef RARVM_VM_ENABLE

#define SET_IP(IP) \
  if ((IP) >= numCommands) return true; \
  if (--maxOpCount <= 0) return false; \
  cmd = commands + (IP);

#define GET_FLAG_S_B(res) (((res) & 0x80) ? FLAG_S : 0)
#define SET_IP_OP1 { UInt32 val = GetOperand32(&cmd->Op1); SET_IP(val); }
#define FLAGS_UPDATE_SZ Flags = res == 0 ? FLAG_Z : res & FLAG_S
#define FLAGS_UPDATE_SZ_B Flags = (res & 0xFF) == 0 ? FLAG_Z : GET_FLAG_S_B(res)

UInt32 CVm::GetOperand32(const COperand *op) const
{
  switch (op->Type)
  {
    case OP_TYPE_REG: return R[op->Data];
    case OP_TYPE_REGMEM: return GetValue32(&Mem[(op->Base + R[op->Data]) & kSpaceMask]);
    default: return op->Data;
  }
}

void CVm::SetOperand32(const COperand *op, UInt32 val)
{
  switch (op->Type)
  {
    case OP_TYPE_REG: R[op->Data] = val; return;
    case OP_TYPE_REGMEM: SetValue32(&Mem[(op->Base + R[op->Data]) & kSpaceMask], val); return;
  }
}

Byte CVm::GetOperand8(const COperand *op) const
{
  switch (op->Type)
  {
    case OP_TYPE_REG: return (Byte)R[op->Data];
    case OP_TYPE_REGMEM: return Mem[(op->Base + R[op->Data]) & kSpaceMask];;
    default: return (Byte)op->Data;
  }
}

void CVm::SetOperand8(const COperand *op, Byte val)
{
  switch (op->Type)
  {
    case OP_TYPE_REG: R[op->Data] = (R[op->Data] & 0xFFFFFF00) | val; return;
    case OP_TYPE_REGMEM: Mem[(op->Base + R[op->Data]) & kSpaceMask] = val; return;
  }
}

UInt32 CVm::GetOperand(bool byteMode, const COperand *op) const
{
  if (byteMode)
    return GetOperand8(op);
  return GetOperand32(op);
}

void CVm::SetOperand(bool byteMode, const COperand *op, UInt32 val)
{
  if (byteMode)
    SetOperand8(op, (Byte)(val & 0xFF));
  else
    SetOperand32(op, val);
}

bool CVm::ExecuteCode(const CProgram *prg)
{
  Int32 maxOpCount = 25000000;
  const CCommand *commands = &prg->Commands[0];
  const CCommand *cmd = commands;
  UInt32 numCommands = prg->Commands.Size();
  if (numCommands == 0)
    return false;

  for (;;)
  {
    switch (cmd->OpCode)
    {
      case CMD_MOV:
        SetOperand32(&cmd->Op1, GetOperand32(&cmd->Op2));
        break;
      case CMD_MOVB:
        SetOperand8(&cmd->Op1, GetOperand8(&cmd->Op2));
        break;
      case CMD_CMP:
        {
          UInt32 v1 = GetOperand32(&cmd->Op1);
          UInt32 res = v1 - GetOperand32(&cmd->Op2);
          Flags = res == 0 ? FLAG_Z : (res > v1) | (res & FLAG_S);
        }
        break;
      case CMD_CMPB:
        {
          Byte v1 = GetOperand8(&cmd->Op1);
          Byte res = (Byte)((v1 - GetOperand8(&cmd->Op2)) & 0xFF);
          Flags = res == 0 ? FLAG_Z : (res > v1) | GET_FLAG_S_B(res);
        }
        break;
      case CMD_ADD:
        {
          UInt32 v1 = GetOperand32(&cmd->Op1);
          UInt32 res = v1 + GetOperand32(&cmd->Op2);
          SetOperand32(&cmd->Op1, res);
          Flags = (res < v1) | (res == 0 ? FLAG_Z : (res & FLAG_S));
        }
        break;
      case CMD_ADDB:
        {
          Byte v1 = GetOperand8(&cmd->Op1);
          Byte res = (Byte)((v1 + GetOperand8(&cmd->Op2)) & 0xFF);
          SetOperand8(&cmd->Op1, (Byte)res);
          Flags = (res < v1) | (res == 0 ? FLAG_Z : GET_FLAG_S_B(res));
        }
        break;
      case CMD_ADC:
        {
          UInt32 v1 = GetOperand(cmd->ByteMode, &cmd->Op1);
          UInt32 FC = (Flags & FLAG_C);
          UInt32 res = v1 + GetOperand(cmd->ByteMode, &cmd->Op2) + FC;
          if (cmd->ByteMode)
            res &= 0xFF;
          SetOperand(cmd->ByteMode, &cmd->Op1, res);
          Flags = (res < v1 || res == v1 && FC) | (res == 0 ? FLAG_Z : (res & FLAG_S));
        }
        break;
      case CMD_SUB:
        {
          UInt32 v1 = GetOperand32(&cmd->Op1);
          UInt32 res = v1 - GetOperand32(&cmd->Op2);
          SetOperand32(&cmd->Op1, res);
          Flags = res == 0 ? FLAG_Z : (res > v1) | (res & FLAG_S);
        }
        break;
      case CMD_SUBB:
        {
          UInt32 v1 = GetOperand8(&cmd->Op1);
          UInt32 res = v1 - GetOperand8(&cmd->Op2);
          SetOperand8(&cmd->Op1, (Byte)res);
          Flags = res == 0 ? FLAG_Z : (res > v1) | (res & FLAG_S);
        }
        break;
      case CMD_SBB:
        {
          UInt32 v1 = GetOperand(cmd->ByteMode, &cmd->Op1);
          UInt32 FC = (Flags & FLAG_C);
          UInt32 res = v1 - GetOperand(cmd->ByteMode, &cmd->Op2) - FC;
          // Flags = res == 0 ? FLAG_Z : (res > v1 || res == v1 && FC) | (res & FLAG_S);
          if (cmd->ByteMode)
            res &= 0xFF;
          SetOperand(cmd->ByteMode, &cmd->Op1, res);
          Flags = (res > v1 || res == v1 && FC) | (res == 0 ? FLAG_Z : (res & FLAG_S));
        }
        break;
      case CMD_INC:
        {
          UInt32 res = GetOperand32(&cmd->Op1) + 1;
          SetOperand32(&cmd->Op1, res);
          FLAGS_UPDATE_SZ;
        }
        break;
      case CMD_INCB:
        {
          Byte res = (Byte)(GetOperand8(&cmd->Op1) + 1);
          SetOperand8(&cmd->Op1, res);;
          FLAGS_UPDATE_SZ_B;
        }
        break;
      case CMD_DEC:
        {
          UInt32 res = GetOperand32(&cmd->Op1) - 1;
          SetOperand32(&cmd->Op1, res);
          FLAGS_UPDATE_SZ;
        }
        break;
      case CMD_DECB:
        {
          Byte res = (Byte)(GetOperand8(&cmd->Op1) - 1);
          SetOperand8(&cmd->Op1, res);;
          FLAGS_UPDATE_SZ_B;
        }
        break;
      case CMD_XOR:
        {
          UInt32 res = GetOperand32(&cmd->Op1) ^ GetOperand32(&cmd->Op2);
          SetOperand32(&cmd->Op1, res);
          FLAGS_UPDATE_SZ;
        }
        break;
      case CMD_XORB:
        {
          Byte res = (Byte)(GetOperand8(&cmd->Op1) ^ GetOperand8(&cmd->Op2));
          SetOperand8(&cmd->Op1, res);
          FLAGS_UPDATE_SZ_B;
        }
        break;
      case CMD_AND:
        {
          UInt32 res = GetOperand32(&cmd->Op1) & GetOperand32(&cmd->Op2);
          SetOperand32(&cmd->Op1, res);
          FLAGS_UPDATE_SZ;
        }
        break;
      case CMD_ANDB:
        {
          Byte res = (Byte)(GetOperand8(&cmd->Op1) & GetOperand8(&cmd->Op2));
          SetOperand8(&cmd->Op1, res);
          FLAGS_UPDATE_SZ_B;
        }
        break;
      case CMD_OR:
        {
          UInt32 res = GetOperand32(&cmd->Op1) | GetOperand32(&cmd->Op2);
          SetOperand32(&cmd->Op1, res);
          FLAGS_UPDATE_SZ;
        }
        break;
      case CMD_ORB:
        {
          Byte res = (Byte)(GetOperand8(&cmd->Op1) | GetOperand8(&cmd->Op2));
          SetOperand8(&cmd->Op1, res);
          FLAGS_UPDATE_SZ_B;
        }
        break;
      case CMD_TEST:
        {
          UInt32 res = GetOperand32(&cmd->Op1) & GetOperand32(&cmd->Op2);
          FLAGS_UPDATE_SZ;
        }
        break;
      case CMD_TESTB:
        {
          Byte res = (Byte)(GetOperand8(&cmd->Op1) & GetOperand8(&cmd->Op2));
          FLAGS_UPDATE_SZ_B;
        }
        break;
      case CMD_NOT:
        SetOperand(cmd->ByteMode, &cmd->Op1, ~GetOperand(cmd->ByteMode, &cmd->Op1));
        break;
      case CMD_NEG:
        {
          UInt32 res = 0 - GetOperand32(&cmd->Op1);
          SetOperand32(&cmd->Op1, res);
          Flags = res == 0 ? FLAG_Z : FLAG_C | (res & FLAG_S);
        }
        break;
      case CMD_NEGB:
        {
          Byte res = (Byte)(0 - GetOperand8(&cmd->Op1));
          SetOperand8(&cmd->Op1, res);
          Flags = res == 0 ? FLAG_Z : FLAG_C | GET_FLAG_S_B(res);
        }
        break;

      case CMD_SHL:
        {
          UInt32 v1 = GetOperand32(&cmd->Op1);
          int v2 = (int)GetOperand32(&cmd->Op2);
          UInt32 res = v1 << v2;
          SetOperand32(&cmd->Op1, res);
          Flags = (res == 0 ? FLAG_Z : (res & FLAG_S)) | ((v1 << (v2 - 1)) & 0x80000000 ? FLAG_C : 0);
        }
        break;
      case CMD_SHLB:
        {
          Byte v1 = GetOperand8(&cmd->Op1);
          int v2 = (int)GetOperand8(&cmd->Op2);
          Byte res = (Byte)(v1 << v2);
          SetOperand8(&cmd->Op1, res);
          Flags = (res == 0 ? FLAG_Z : GET_FLAG_S_B(res)) | ((v1 << (v2 - 1)) & 0x80 ? FLAG_C : 0);
        }
        break;
      case CMD_SHR:
        {
          UInt32 v1 = GetOperand32(&cmd->Op1);
          int v2 = (int)GetOperand32(&cmd->Op2);
          UInt32 res = v1 >> v2;
          SetOperand32(&cmd->Op1, res);
          Flags = (res == 0 ? FLAG_Z : (res & FLAG_S)) | ((v1 >> (v2 - 1)) & FLAG_C);
        }
        break;
      case CMD_SHRB:
        {
          Byte v1 = GetOperand8(&cmd->Op1);
          int v2 = (int)GetOperand8(&cmd->Op2);
          Byte res = (Byte)(v1 >> v2);
          SetOperand8(&cmd->Op1, res);
          Flags = (res == 0 ? FLAG_Z : GET_FLAG_S_B(res)) | ((v1 >> (v2 - 1)) & FLAG_C);
        }
        break;
      case CMD_SAR:
        {
          UInt32 v1 = GetOperand32(&cmd->Op1);
          int v2 = (int)GetOperand32(&cmd->Op2);
          UInt32 res = UInt32(((Int32)v1) >> v2);
          SetOperand32(&cmd->Op1, res);
          Flags= (res == 0 ? FLAG_Z : (res & FLAG_S)) | ((v1 >> (v2 - 1)) & FLAG_C);
        }
        break;
      case CMD_SARB:
        {
          Byte v1 = GetOperand8(&cmd->Op1);
          int v2 = (int)GetOperand8(&cmd->Op2);
          Byte res = (Byte)(((signed char)v1) >> v2);
          SetOperand8(&cmd->Op1, res);
          Flags= (res == 0 ? FLAG_Z : GET_FLAG_S_B(res)) | ((v1 >> (v2 - 1)) & FLAG_C);
        }
        break;

      case CMD_JMP:
        SET_IP_OP1;
        continue;
      case CMD_JZ:
        if ((Flags & FLAG_Z) != 0)
        {
          SET_IP_OP1;
          continue;
        }
        break;
      case CMD_JNZ:
        if ((Flags & FLAG_Z) == 0)
        {
          SET_IP_OP1;
          continue;
        }
        break;
      case CMD_JS:
        if ((Flags & FLAG_S) != 0)
        {
          SET_IP_OP1;
          continue;
        }
        break;
      case CMD_JNS:
        if ((Flags & FLAG_S) == 0)
        {
          SET_IP_OP1;
          continue;
        }
        break;
      case CMD_JB:
        if ((Flags & FLAG_C) != 0)
        {
          SET_IP_OP1;
          continue;
        }
        break;
      case CMD_JBE:
        if ((Flags & (FLAG_C | FLAG_Z)) != 0)
        {
          SET_IP_OP1;
          continue;
        }
        break;
      case CMD_JA:
        if ((Flags & (FLAG_C | FLAG_Z)) == 0)
        {
          SET_IP_OP1;
          continue;
        }
        break;
      case CMD_JAE:
        if ((Flags & FLAG_C) == 0)
        {
          SET_IP_OP1;
          continue;
        }
        break;
      
      case CMD_PUSH:
        R[kStackRegIndex] -= 4;
        SetValue32(&Mem[R[kStackRegIndex] & kSpaceMask], GetOperand32(&cmd->Op1));
        break;
      case CMD_POP:
        SetOperand32(&cmd->Op1, GetValue32(&Mem[R[kStackRegIndex] & kSpaceMask]));
        R[kStackRegIndex] += 4;
        break;
      case CMD_CALL:
        R[kStackRegIndex] -= 4;
        SetValue32(&Mem[R[kStackRegIndex] & kSpaceMask], (UInt32)(cmd - commands + 1));
        SET_IP_OP1;
        continue;

      case CMD_PUSHA:
        {
          for (UInt32 i = 0, SP = R[kStackRegIndex] - 4; i < kNumRegs; i++, SP -= 4)
            SetValue32(&Mem[SP & kSpaceMask], R[i]);
          R[kStackRegIndex] -= kNumRegs * 4;
        }
        break;
      case CMD_POPA:
        {
          for (UInt32 i = 0, SP = R[kStackRegIndex]; i < kNumRegs; i++, SP += 4)
            R[kStackRegIndex - i] = GetValue32(&Mem[SP & kSpaceMask]);
        }
        break;
      case CMD_PUSHF:
        R[kStackRegIndex] -= 4;
        SetValue32(&Mem[R[kStackRegIndex]&kSpaceMask], Flags);
        break;
      case CMD_POPF:
        Flags = GetValue32(&Mem[R[kStackRegIndex] & kSpaceMask]);
        R[kStackRegIndex] += 4;
        break;
      
      case CMD_MOVZX:
        SetOperand32(&cmd->Op1, GetOperand8(&cmd->Op2));
        break;
      case CMD_MOVSX:
        SetOperand32(&cmd->Op1, (UInt32)(Int32)(signed char)GetOperand8(&cmd->Op2));
        break;
      case CMD_XCHG:
        {
          UInt32 v1 = GetOperand(cmd->ByteMode, &cmd->Op1);
          SetOperand(cmd->ByteMode, &cmd->Op1, GetOperand(cmd->ByteMode, &cmd->Op2));
          SetOperand(cmd->ByteMode, &cmd->Op2, v1);
        }
        break;
      case CMD_MUL:
        {
          UInt32 res = GetOperand32(&cmd->Op1) * GetOperand32(&cmd->Op2);
          SetOperand32(&cmd->Op1, res);
        }
        break;
      case CMD_MULB:
        {
          Byte res = (Byte)(GetOperand8(&cmd->Op1) * GetOperand8(&cmd->Op2));
          SetOperand8(&cmd->Op1, res);
        }
        break;
      case CMD_DIV:
        {
          UInt32 divider = GetOperand(cmd->ByteMode, &cmd->Op2);
          if (divider != 0)
          {
            UInt32 res = GetOperand(cmd->ByteMode, &cmd->Op1) / divider;
            SetOperand(cmd->ByteMode, &cmd->Op1, res);
          }
        }
        break;
      
      case CMD_RET:
        {
          if (R[kStackRegIndex] >= kSpaceSize)
            return true;
          UInt32 ip = GetValue32(&Mem[R[kStackRegIndex] & kSpaceMask]);
          SET_IP(ip);
          R[kStackRegIndex] += 4;
          continue;
        }
      case CMD_PRINT:
        break;
    }
    cmd++;
    --maxOpCount;
  }
}

//////////////////////////////////////////////////////
// Read program

static void DecodeArg(CMemBitDecoder &inp, COperand &op, bool byteMode)
{
  if (inp.ReadBit())
  {
    op.Type = OP_TYPE_REG;
    op.Data = inp.ReadBits(kNumRegBits);
  }
  else if (inp.ReadBit() == 0)
  {
    op.Type = OP_TYPE_INT;
    if (byteMode)
      op.Data = inp.ReadBits(8);
    else
      op.Data = inp.ReadEncodedUInt32();
  }
  else
  {
    op.Type = OP_TYPE_REGMEM;
    if (inp.ReadBit() == 0)
    {
      op.Data = inp.ReadBits(kNumRegBits);
      op.Base = 0;
    }
    else
    {
      if (inp.ReadBit() == 0)
        op.Data = inp.ReadBits(kNumRegBits);
      else
        op.Data = kNumRegs;
      op.Base = inp.ReadEncodedUInt32();
    }
  }
}

void CProgram::ReadProgram(const Byte *code, UInt32 codeSize)
{
  CMemBitDecoder inp;
  inp.Init(code, codeSize);

  StaticData.Clear();
  
  if (inp.ReadBit())
  {
    UInt32 dataSize = inp.ReadEncodedUInt32() + 1;
    for (UInt32 i = 0; inp.Avail() && i < dataSize; i++)
      StaticData.Add((Byte)inp.ReadBits(8));
  }
  
  while (inp.Avail())
  {
    Commands.Add(CCommand());
    CCommand *cmd = &Commands.Back();
    
    if (inp.ReadBit() == 0)
      cmd->OpCode = (ECommand)inp.ReadBits(3);
    else
      cmd->OpCode = (ECommand)(8 + inp.ReadBits(5));

    if (kCmdFlags[(unsigned)cmd->OpCode] & CF_BYTEMODE)
      cmd->ByteMode = (inp.ReadBit()) ? true : false;
    else
      cmd->ByteMode = 0;
    
    int opNum = (kCmdFlags[(unsigned)cmd->OpCode] & CF_OPMASK);
    
    if (opNum > 0)
    {
      DecodeArg(inp, cmd->Op1, cmd->ByteMode);
      if (opNum == 2)
        DecodeArg(inp, cmd->Op2, cmd->ByteMode);
      else
      {
        if (cmd->Op1.Type == OP_TYPE_INT && (kCmdFlags[(unsigned)cmd->OpCode] & (CF_JUMP | CF_PROC)))
        {
          int dist = cmd->Op1.Data;
          if (dist >= 256)
            dist -= 256;
          else
          {
            if (dist >= 136)
              dist -= 264;
            else if (dist >= 16)
              dist -= 8;
            else if (dist >= 8)
              dist -= 16;
            dist += Commands.Size() - 1;
          }
          cmd->Op1.Data = dist;
        }
      }
    }

    if (cmd->ByteMode)
    {
      switch (cmd->OpCode)
      {
        case CMD_MOV: cmd->OpCode = CMD_MOVB; break;
        case CMD_CMP: cmd->OpCode = CMD_CMPB; break;
        case CMD_ADD: cmd->OpCode = CMD_ADDB; break;
        case CMD_SUB: cmd->OpCode = CMD_SUBB; break;
        case CMD_INC: cmd->OpCode = CMD_INCB; break;
        case CMD_DEC: cmd->OpCode = CMD_DECB; break;
        case CMD_XOR: cmd->OpCode = CMD_XORB; break;
        case CMD_AND: cmd->OpCode = CMD_ANDB; break;
        case CMD_OR: cmd->OpCode = CMD_ORB; break;
        case CMD_TEST: cmd->OpCode = CMD_TESTB; break;
        case CMD_NEG: cmd->OpCode = CMD_NEGB; break;
        case CMD_SHL: cmd->OpCode = CMD_SHLB; break;
        case CMD_SHR: cmd->OpCode = CMD_SHRB; break;
        case CMD_SAR: cmd->OpCode = CMD_SARB; break;
        case CMD_MUL: cmd->OpCode = CMD_MULB; break;
      }
    }
  }
}

#endif


#ifdef RARVM_STANDARD_FILTERS

enum EStandardFilter
{
  SF_E8,
  SF_E8E9,
  SF_ITANIUM,
  SF_RGB,
  SF_AUDIO,
  SF_DELTA
  // SF_UPCASE
};

static const struct CStandardFilterSignature
{
  UInt32 Length;
  UInt32 CRC;
  EStandardFilter Type;
}
kStdFilters[]=
{
  {  53, 0xad576887, SF_E8 },
  {  57, 0x3cd7e57e, SF_E8E9 },
  { 120, 0x3769893f, SF_ITANIUM },
  {  29, 0x0e06077d, SF_DELTA },
  { 149, 0x1c2c5dc8, SF_RGB },
  { 216, 0xbc85e701, SF_AUDIO }
  // {  40, 0x46b9c560, SF_UPCASE }
};

static int FindStandardFilter(const Byte *code, UInt32 codeSize)
{
  UInt32 crc = CrcCalc(code, codeSize);
  for (unsigned i = 0; i < ARRAY_SIZE(kStdFilters); i++)
  {
    const CStandardFilterSignature &sfs = kStdFilters[i];
    if (sfs.CRC == crc && sfs.Length == codeSize)
      return i;
  }
  return -1;
}

#endif


bool CProgram::PrepareProgram(const Byte *code, UInt32 codeSize)
{
  IsSupported = false;

  #ifdef RARVM_VM_ENABLE
  Commands.Clear();
  #endif
  
  #ifdef RARVM_STANDARD_FILTERS
  StandardFilterIndex = -1;
  #endif

  bool isOK = false;

  Byte xorSum = 0;
  for (UInt32 i = 0; i < codeSize; i++)
    xorSum ^= code[i];

  if (xorSum == 0 && codeSize != 0)
  {
    IsSupported = true;
    isOK = true;
    #ifdef RARVM_STANDARD_FILTERS
    StandardFilterIndex = FindStandardFilter(code, codeSize);
    if (StandardFilterIndex >= 0)
      return true;
    #endif
  
    #ifdef RARVM_VM_ENABLE
    ReadProgram(code + 1, codeSize - 1);
    #else
    IsSupported = false;
    #endif
  }
  
  #ifdef RARVM_VM_ENABLE
  Commands.Add(CCommand());
  Commands.Back().OpCode = CMD_RET;
  #endif
  
  return isOK;
}

void CVm::SetMemory(UInt32 pos, const Byte *data, UInt32 dataSize)
{
  if (pos < kSpaceSize && data != Mem + pos)
    memmove(Mem + pos, data, MyMin(dataSize, kSpaceSize - pos));
}

#ifdef RARVM_STANDARD_FILTERS

static void E8E9Decode(Byte *data, UInt32 dataSize, UInt32 fileOffset, bool e9)
{
  if (dataSize <= 4)
    return;
  dataSize -= 4;
  const UInt32 kFileSize = 0x1000000;
  Byte cmpMask = (Byte)(e9 ? 0xFE : 0xFF);
  for (UInt32 curPos = 0; curPos < dataSize;)
  {
    curPos++;
    if (((*data++) & cmpMask) == 0xE8)
    {
      UInt32 offset = curPos + fileOffset;
      UInt32 addr = (Int32)GetValue32(data);
      if (addr < kFileSize)
        SetValue32(data, addr - offset);
      else if ((Int32)addr < 0 && (Int32)(addr + offset) >= 0)
        SetValue32(data, addr + kFileSize);
      data += 4;
      curPos += 4;
    }
  }
}

static inline UInt32 ItaniumGetOpType(const Byte *data, unsigned bitPos)
{
  return (data[bitPos >> 3] >> (bitPos & 7)) & 0xF;
}

static const Byte kCmdMasks[16] = {4,4,6,6,0,0,7,7,4,4,0,0,4,4,0,0};

static void ItaniumDecode(Byte *data, UInt32 dataSize, UInt32 fileOffset)
{
  UInt32 curPos = 0;
  fileOffset >>= 4;
  while (curPos < dataSize - 21)
  {
    int b = (data[0] & 0x1F) - 0x10;
    if (b >= 0)
    {
      Byte cmdMask = kCmdMasks[b];
      if (cmdMask != 0)
        for (unsigned i = 0; i < 3; i++)
          if (cmdMask & (1 << i))
          {
            unsigned startPos = i * 41 + 18;
            if (ItaniumGetOpType(data, startPos + 24) == 5)
            {
              const UInt32 kMask = 0xFFFFF;
              Byte *p = data + (startPos >> 3);
              UInt32 bitField = ((UInt32)p[0]) | ((UInt32)p[1] <<  8) | ((UInt32)p[2] << 16);
              unsigned inBit = (startPos & 7);
              UInt32 offset = (bitField >> inBit) & kMask;
              UInt32 andMask = ~(kMask << inBit);
              bitField = ((offset - fileOffset) & kMask) << inBit;
              for (unsigned j = 0; j < 3; j++)
              {
                p[j] &= andMask;
                p[j] |= bitField;
                andMask >>= 8;
                bitField >>= 8;
              }
            }
          }
    }
    data += 16;
    curPos += 16;
    fileOffset++;
  }
}

static void DeltaDecode(Byte *data, UInt32 dataSize, UInt32 numChannels)
{
  UInt32 srcPos = 0;
  UInt32 border = dataSize * 2;
  for (UInt32 curChannel = 0; curChannel < numChannels; curChannel++)
  {
    Byte prevByte = 0;
    for (UInt32 destPos = dataSize + curChannel; destPos < border; destPos += numChannels)
      data[destPos] = (prevByte = (Byte)(prevByte - data[srcPos++]));
  }
}

static void RgbDecode(Byte *srcData, UInt32 dataSize, UInt32 width, UInt32 posR)
{
  Byte *destData = srcData + dataSize;
  const UInt32 numChannels = 3;
  for (UInt32 curChannel = 0; curChannel < numChannels; curChannel++)
  {
    Byte prevByte = 0;
    
    for (UInt32 i = curChannel; i < dataSize; i+= numChannels)
    {
      unsigned int predicted;
      if (i < width)
        predicted = prevByte;
      else
      {
        unsigned int upperLeftByte = destData[i - width];
        unsigned int upperByte = destData[i - width + 3];
        predicted = prevByte + upperByte - upperLeftByte;
        int pa = abs((int)(predicted - prevByte));
        int pb = abs((int)(predicted - upperByte));
        int pc = abs((int)(predicted - upperLeftByte));
        if (pa <= pb && pa <= pc)
          predicted = prevByte;
        else
          if (pb <= pc)
            predicted = upperByte;
          else
            predicted = upperLeftByte;
      }
      destData[i] = prevByte = (Byte)(predicted - *(srcData++));
    }
  }
  if (dataSize < 3)
    return;
  for (UInt32 i = posR, border = dataSize - 2; i < border; i += 3)
  {
    Byte g = destData[i + 1];
    destData[i    ] = (Byte)(destData[i    ] + g);
    destData[i + 2] = (Byte)(destData[i + 2] + g);
  }
}

static void AudioDecode(Byte *srcData, UInt32 dataSize, UInt32 numChannels)
{
  Byte *destData = srcData + dataSize;
  for (UInt32 curChannel = 0; curChannel < numChannels; curChannel++)
  {
    UInt32 prevByte = 0, prevDelta = 0, dif[7];
    Int32 D1 = 0, D2 = 0, D3;
    Int32 K1 = 0, K2 = 0, K3 = 0;
    memset(dif, 0, sizeof(dif));
    
    for (UInt32 i = curChannel, byteCount = 0; i < dataSize; i += numChannels, byteCount++)
    {
      D3 = D2;
      D2 = prevDelta - D1;
      D1 = prevDelta;
      
      UInt32 predicted = 8 * prevByte + K1 * D1 + K2 * D2 + K3 * D3;
      predicted = (predicted >> 3) & 0xFF;
      
      UInt32 curByte = *(srcData++);
      
      predicted -= curByte;
      destData[i] = (Byte)predicted;
      prevDelta = (UInt32)(Int32)(signed char)(predicted - prevByte);
      prevByte = predicted;
      
      Int32 D = ((Int32)(signed char)curByte) << 3;
      
      dif[0] += abs(D);
      dif[1] += abs(D - D1);
      dif[2] += abs(D + D1);
      dif[3] += abs(D - D2);
      dif[4] += abs(D + D2);
      dif[5] += abs(D - D3);
      dif[6] += abs(D + D3);
      
      if ((byteCount & 0x1F) == 0)
      {
        UInt32 minDif = dif[0], numMinDif = 0;
        dif[0] = 0;
        for (unsigned j = 1; j < ARRAY_SIZE(dif); j++)
        {
          if (dif[j] < minDif)
          {
            minDif = dif[j];
            numMinDif = j;
          }
          dif[j] = 0;
        }
        switch (numMinDif)
        {
          case 1: if (K1 >= -16) K1--; break;
          case 2: if (K1 <   16) K1++; break;
          case 3: if (K2 >= -16) K2--; break;
          case 4: if (K2 <   16) K2++; break;
          case 5: if (K3 >= -16) K3--; break;
          case 6: if (K3 <   16) K3++; break;
        }
      }
    }
  }
}

/*
static UInt32 UpCaseDecode(Byte *data, UInt32 dataSize)
{
  UInt32 srcPos = 0, destPos = dataSize;
  while (srcPos < dataSize)
  {
    Byte curByte = data[srcPos++];
    if (curByte == 2 && (curByte = data[srcPos++]) != 2)
      curByte -= 32;
    data[destPos++] = curByte;
  }
  return destPos - dataSize;
}
*/

void CVm::ExecuteStandardFilter(unsigned filterIndex)
{
  UInt32 dataSize = R[4];
  if (dataSize >= kGlobalOffset)
    return;
  EStandardFilter filterType = kStdFilters[filterIndex].Type;

  switch (filterType)
  {
    case SF_E8:
    case SF_E8E9:
      E8E9Decode(Mem, dataSize, R[6], (filterType == SF_E8E9));
      break;
    case SF_ITANIUM:
      ItaniumDecode(Mem, dataSize, R[6]);
      break;
    case SF_DELTA:
      if (dataSize >= kGlobalOffset / 2)
        break;
      SetBlockPos(dataSize);
      DeltaDecode(Mem, dataSize, R[0]);
      break;
    case SF_RGB:
      if (dataSize >= kGlobalOffset / 2)
        break;
      {
        UInt32 width = R[0];
        if (width <= 3)
          break;
        SetBlockPos(dataSize);
        RgbDecode(Mem, dataSize, width, R[1]);
      }
      break;
    case SF_AUDIO:
      if (dataSize >= kGlobalOffset / 2)
        break;
      SetBlockPos(dataSize);
      AudioDecode(Mem, dataSize, R[0]);
      break;
    /*
    case SF_UPCASE:
      if (dataSize >= kGlobalOffset / 2)
        break;
      UInt32 destSize = UpCaseDecode(Mem, dataSize);
      SetBlockSize(destSize);
      SetBlockPos(dataSize);
      break;
    */
  }
}

#endif

}}}
// Rar3Vm.h
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives

#ifndef __COMPRESS_RAR3_VM_H
#define __COMPRESS_RAR3_VM_H

#include "../../../C/CpuArch.h"

#include "../../Common/MyVector.h"

#define RARVM_STANDARD_FILTERS
// #define RARVM_VM_ENABLE

namespace NCompress {
namespace NRar3 {

class CMemBitDecoder
{
  const Byte *_data;
  UInt32 _bitSize;
  UInt32 _bitPos;
public:
  void Init(const Byte *data, UInt32 byteSize)
  {
    _data = data;
    _bitSize = (byteSize << 3);
    _bitPos = 0;
  }
  UInt32 ReadBits(unsigned numBits);
  UInt32 ReadBit();
  bool Avail() const { return (_bitPos < _bitSize); }

  UInt32 ReadEncodedUInt32();
};

namespace NVm {

inline UInt32 GetValue32(const void *addr) { return GetUi32(addr); }
inline void SetValue32(void *addr, UInt32 value) { SetUi32(addr, value); }

const unsigned kNumRegBits = 3;
const UInt32 kNumRegs = 1 << kNumRegBits;
const UInt32 kNumGpRegs = kNumRegs - 1;

const UInt32 kSpaceSize = 0x40000;
const UInt32 kSpaceMask = kSpaceSize - 1;
const UInt32 kGlobalOffset = 0x3C000;
const UInt32 kGlobalSize = 0x2000;
const UInt32 kFixedGlobalSize = 64;

namespace NGlobalOffset
{
  const UInt32 kBlockSize = 0x1C;
  const UInt32 kBlockPos  = 0x20;
  const UInt32 kExecCount = 0x2C;
  const UInt32 kGlobalMemOutSize = 0x30;
}


#ifdef RARVM_VM_ENABLE

enum ECommand
{
  CMD_MOV,  CMD_CMP,  CMD_ADD,  CMD_SUB,  CMD_JZ,   CMD_JNZ,  CMD_INC,  CMD_DEC,
  CMD_JMP,  CMD_XOR,  CMD_AND,  CMD_OR,   CMD_TEST, CMD_JS,   CMD_JNS,  CMD_JB,
  CMD_JBE,  CMD_JA,   CMD_JAE,  CMD_PUSH, CMD_POP,  CMD_CALL, CMD_RET,  CMD_NOT,
  CMD_SHL,  CMD_SHR,  CMD_SAR,  CMD_NEG,  CMD_PUSHA,CMD_POPA, CMD_PUSHF,CMD_POPF,
  CMD_MOVZX,CMD_MOVSX,CMD_XCHG, CMD_MUL,  CMD_DIV,  CMD_ADC,  CMD_SBB,  CMD_PRINT,

  CMD_MOVB, CMD_CMPB, CMD_ADDB, CMD_SUBB, CMD_INCB, CMD_DECB,
  CMD_XORB, CMD_ANDB, CMD_ORB,  CMD_TESTB,CMD_NEGB,
  CMD_SHLB, CMD_SHRB, CMD_SARB, CMD_MULB
};

enum EOpType {OP_TYPE_REG, OP_TYPE_INT, OP_TYPE_REGMEM, OP_TYPE_NONE};

// Addr in COperand object can link (point) to CVm object!!!

struct COperand
{
  EOpType Type;
  UInt32 Data;
  UInt32 Base;
  COperand(): Type(OP_TYPE_NONE), Data(0), Base(0) {}
};

struct CCommand
{
  ECommand OpCode;
  bool ByteMode;
  COperand Op1, Op2;
};

#endif


struct CBlockRef
{
  UInt32 Offset;
  UInt32 Size;
};


class CProgram
{
  #ifdef RARVM_VM_ENABLE
  void ReadProgram(const Byte *code, UInt32 codeSize);
public:
  CRecordVector<CCommand> Commands;
  #endif
  
public:
  #ifdef RARVM_STANDARD_FILTERS
  int StandardFilterIndex;
  #endif
  
  bool IsSupported;
  CRecordVector<Byte> StaticData;

  bool PrepareProgram(const Byte *code, UInt32 codeSize);
};


struct CProgramInitState
{
  UInt32 InitR[kNumGpRegs];
  CRecordVector<Byte> GlobalData;

  void AllocateEmptyFixedGlobal()
  {
    GlobalData.ClearAndSetSize(NVm::kFixedGlobalSize);
    memset(&GlobalData[0], 0, NVm::kFixedGlobalSize);
  }
};


class CVm
{
  static UInt32 GetValue(bool byteMode, const void *addr)
  {
    if (byteMode)
      return(*(const Byte *)addr);
    else
      return GetUi32(addr);
  }

  static void SetValue(bool byteMode, void *addr, UInt32 value)
  {
    if (byteMode)
      *(Byte *)addr = (Byte)value;
    else
      SetUi32(addr, value);
  }

  UInt32 GetFixedGlobalValue32(UInt32 globalOffset) { return GetValue(false, &Mem[kGlobalOffset + globalOffset]); }

  void SetBlockSize(UInt32 v) { SetValue(&Mem[kGlobalOffset + NGlobalOffset::kBlockSize], v); }
  void SetBlockPos(UInt32 v) { SetValue(&Mem[kGlobalOffset + NGlobalOffset::kBlockPos], v); }
public:
  static void SetValue(void *addr, UInt32 value) { SetValue(false, addr, value); }

private:

  #ifdef RARVM_VM_ENABLE
  UInt32 GetOperand32(const COperand *op) const;
  void SetOperand32(const COperand *op, UInt32 val);
  Byte GetOperand8(const COperand *op) const;
  void SetOperand8(const COperand *op, Byte val);
  UInt32 GetOperand(bool byteMode, const COperand *op) const;
  void SetOperand(bool byteMode, const COperand *op, UInt32 val);
  bool ExecuteCode(const CProgram *prg);
  #endif
  
  #ifdef RARVM_STANDARD_FILTERS
  void ExecuteStandardFilter(unsigned filterIndex);
  #endif
  
  Byte *Mem;
  UInt32 R[kNumRegs + 1]; // R[kNumRegs] = 0 always (speed optimization)
  UInt32 Flags;

public:
  CVm();
  ~CVm();
  bool Create();
  void SetMemory(UInt32 pos, const Byte *data, UInt32 dataSize);
  bool Execute(CProgram *prg, const CProgramInitState *initState,
      CBlockRef &outBlockRef, CRecordVector<Byte> &outGlobalData);
  const Byte *GetDataPointer(UInt32 offset) const { return Mem + offset; }
};

#endif

}}}
// Rar5Decoder.cpp
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives

#include "StdAfx.h"

// #include <stdio.h>

#include "../Common/StreamUtils.h"

#include "Rar5Decoder.h"

namespace NCompress {
namespace NRar5 {

static const size_t kInputBufSize = 1 << 20;
 
void CBitDecoder::Prepare2() throw()
{
  const unsigned kSize = 16;
  if (_buf > _bufLim)
    return;

  size_t rem = _bufLim - _buf;
  if (rem != 0)
    memmove(_bufBase, _buf, rem);

  _bufLim = _bufBase + rem;
  _processedSize += (_buf - _bufBase);
  _buf = _bufBase;

  if (!_wasFinished)
  {
    UInt32 processed = (UInt32)(kInputBufSize - rem);
    _hres = _stream->Read(_bufLim, (UInt32)processed, &processed);
    _bufLim += processed;
    _wasFinished = (processed == 0);
    if (_hres != S_OK)
    {
      _wasFinished = true;
      // throw CInBufferException(result);
    }
  }

  rem = _bufLim - _buf;
  _bufCheck = _buf;
  if (rem < kSize)
    memset(_bufLim, 0xFF, kSize - rem);
  else
    _bufCheck = _bufLim - kSize;

  SetCheck2();
}


enum FilterType
{
  FILTER_DELTA = 0,
  FILTER_E8,
  FILTER_E8E9,
  FILTER_ARM
};

static const size_t kWriteStep = (size_t)1 << 22;

CDecoder::CDecoder():
    _window(NULL),
    _winPos(0),
    _winSizeAllocated(0),
    _lzSize(0),
    _lzEnd(0),
    _writtenFileSize(0),
    _dictSizeLog(0),
    _isSolid(false),
    _wasInit(false),
    _inputBuf(NULL)
{
}

CDecoder::~CDecoder()
{
  ::MidFree(_window);
  ::MidFree(_inputBuf);
}

HRESULT CDecoder::WriteData(const Byte *data, size_t size)
{
  HRESULT res = S_OK;
  if (!_unpackSize_Defined || _writtenFileSize < _unpackSize)
  {
    size_t cur = size;
    if (_unpackSize_Defined)
    {
      UInt64 rem = _unpackSize - _writtenFileSize;
      if (cur > rem)
        cur = (size_t)rem;
    }
    res = WriteStream(_outStream, data, cur);
    if (res != S_OK)
      _writeError = true;
  }
  _writtenFileSize += size;
  return res;
}

HRESULT CDecoder::ExecuteFilter(const CFilter &f)
{
  bool useDest = false;

  Byte *data = _filterSrc;
  UInt32 dataSize = f.Size;
  
  // printf("\nType = %d offset = %9d  size = %5d", f.Type, (unsigned)(f.Start - _lzFileStart), dataSize);
  
  switch (f.Type)
  {
    case FILTER_E8:
    case FILTER_E8E9:
    {
      // printf("  FILTER_E8");
      if (dataSize > 4)
      {
        dataSize -= 4;
        UInt32 fileOffset = (UInt32)(f.Start - _lzFileStart);
        
        const UInt32 kFileSize = (UInt32)1 << 24;
        Byte cmpMask = (Byte)(f.Type == FILTER_E8 ? 0xFF : 0xFE);
        
        for (UInt32 curPos = 0; curPos < dataSize;)
        {
          curPos++;
          if (((*data++) & cmpMask) == 0xE8)
          {
            UInt32 offset = (curPos + fileOffset) & (kFileSize - 1);
            UInt32 addr = GetUi32(data);
            
            if (addr < kFileSize)
            {
              SetUi32(data, addr - offset);
            }
            else if (addr > ((UInt32)0xFFFFFFFF - offset)) // (addr > ~(offset))
            {
              SetUi32(data, addr + kFileSize);
            }
              
            data += 4;
            curPos += 4;
          }
        }
      }
      break;
    }

    case FILTER_ARM:
    {
      if (dataSize >= 4)
      {
        dataSize -= 4;
        UInt32 fileOffset = (UInt32)(f.Start - _lzFileStart);
        
        for (UInt32 curPos = 0; curPos <= dataSize; curPos += 4)
        {
          Byte *d = data + curPos;
          if (d[3] == 0xEB)
          {
            UInt32 offset = d[0] | ((UInt32)d[1] << 8) | ((UInt32)d[2] << 16);
            offset -= (fileOffset + curPos) >> 2;
            d[0] = (Byte)offset;
            d[1] = (Byte)(offset >> 8);
            d[2] = (Byte)(offset >> 16);
          }
        }
      }
      break;
    }
    
    case FILTER_DELTA:
    {
      // printf("  channels = %d", f.Channels);
      _filterDst.AllocAtLeast(dataSize);
      if (!_filterDst.IsAllocated())
        return E_OUTOFMEMORY;

      Byte *dest = _filterDst;
      UInt32 numChannels = f.Channels;
      
      for (UInt32 curChannel = 0; curChannel < numChannels; curChannel++)
      {
        Byte prevByte = 0;
        for (UInt32 destPos = curChannel; destPos < dataSize; destPos += numChannels)
          dest[destPos] = (prevByte = (Byte)(prevByte - *data++));
      }
      useDest = true;
      break;
    }

    default:
      _unsupportedFilter = true;
  }

  return WriteData(useDest ?
      (const Byte *)_filterDst :
      (const Byte *)_filterSrc,
      f.Size);
}


HRESULT CDecoder::WriteBuf()
{
  DeleteUnusedFilters();

  for (unsigned i = 0; i < _filters.Size();)
  {
    const CFilter &f = _filters[i];
    
    UInt64 blockStart = f.Start;

    size_t lzAvail = (size_t)(_lzSize - _lzWritten);
    if (lzAvail == 0)
      break;
    
    if (blockStart > _lzWritten)
    {
      UInt64 rem = blockStart - _lzWritten;
      size_t size = lzAvail;
      if (size > rem)
        size = (size_t)rem;
      if (size != 0)
      {
        RINOK(WriteData(_window + _winPos - lzAvail, size));
        _lzWritten += size;
      }
      continue;
    }
    
    UInt32 blockSize = f.Size;
    size_t offset = (size_t)(_lzWritten - blockStart);
    if (offset == 0)
    {
      _filterSrc.AllocAtLeast(blockSize);
      if (!_filterSrc.IsAllocated())
        return E_OUTOFMEMORY;
    }
    
    size_t blockRem = (size_t)blockSize - offset;
    size_t size = lzAvail;
    if (size > blockRem)
      size = blockRem;
    memcpy(_filterSrc + offset, _window + _winPos - lzAvail, size);
    _lzWritten += size;
    offset += size;
    if (offset != blockSize)
      return S_OK;

    _numUnusedFilters = ++i;
    RINOK(ExecuteFilter(f));
  }
      
  DeleteUnusedFilters();

  if (!_filters.IsEmpty())
    return S_OK;
  
  size_t lzAvail = (size_t)(_lzSize - _lzWritten);
  RINOK(WriteData(_window + _winPos - lzAvail, lzAvail));
  _lzWritten += lzAvail;
  return S_OK;
}


static UInt32 ReadUInt32(CBitDecoder &bi)
{
  unsigned numBytes = bi.ReadBits9fix(2) + 1;
  UInt32 v = 0;
  for (unsigned i = 0; i < numBytes; i++)
    v += ((UInt32)bi.ReadBits9fix(8) << (i * 8));
  return v;
}


static const unsigned MAX_UNPACK_FILTERS = 8192;

HRESULT CDecoder::AddFilter(CBitDecoder &_bitStream)
{
  DeleteUnusedFilters();

  if (_filters.Size() >= MAX_UNPACK_FILTERS)
  {
    RINOK(WriteBuf());
    DeleteUnusedFilters();
    if (_filters.Size() >= MAX_UNPACK_FILTERS)
    {
      _unsupportedFilter = true;
      InitFilters();
    }
  }

  _bitStream.Prepare();

  CFilter f;
  UInt32 blockStart = ReadUInt32(_bitStream);
  f.Size = ReadUInt32(_bitStream);

  // if (f.Size > ((UInt32)1 << 16)) _unsupportedFilter = true;

  f.Type = (Byte)_bitStream.ReadBits9fix(3);
  f.Channels = 0;
  if (f.Type == FILTER_DELTA)
    f.Channels = (Byte)(_bitStream.ReadBits9fix(5) + 1);
  f.Start = _lzSize + blockStart;

  if (f.Start < _filterEnd)
    _unsupportedFilter = true;
  else
  {
    _filterEnd = f.Start + f.Size;
    if (f.Size != 0)
      _filters.Add(f);
  }

  return S_OK;
}


#define RIF(x) { if (!(x)) return S_FALSE; }

HRESULT CDecoder::ReadTables(CBitDecoder &_bitStream)
{
  if (_progress)
  {
    UInt64 packSize = _bitStream.GetProcessedSize();
    RINOK(_progress->SetRatioInfo(&packSize, &_writtenFileSize));
  }

  _bitStream.AlignToByte();
  _bitStream.Prepare();
  
  unsigned flags = _bitStream.ReadByteInAligned();
  unsigned checkSum = _bitStream.ReadByteInAligned();
  checkSum ^= flags;

  UInt32 blockSize;
  {
    unsigned num = (flags >> 3) & 3;
    if (num == 3)
      return S_FALSE;
    blockSize = _bitStream.ReadByteInAligned();
    if (num > 0)
    {
      blockSize += (UInt32)_bitStream.ReadByteInAligned() << 8;
      if (num > 1)
        blockSize += (UInt32)_bitStream.ReadByteInAligned() << 16;
    }
  }

  checkSum ^= blockSize ^ (blockSize >> 8) ^ (blockSize >> 16);
  if ((Byte)checkSum != 0x5A)
    return S_FALSE;

  unsigned blockSizeBits7 = (flags & 7) + 1;

  if (blockSize == 0 && blockSizeBits7 != 8)
    return S_FALSE;

  blockSize += (blockSizeBits7 >> 3);
  blockSize--;

  _bitStream._blockEndBits7 = (Byte)(blockSizeBits7 & 7);
  _bitStream._blockEnd = _bitStream.GetProcessedSize_Round() + blockSize;

  _bitStream.SetCheck2();

  _isLastBlock = ((flags & 0x40) != 0);

  if ((flags & 0x80) == 0)
  {
    if (!_tableWasFilled && blockSize != 0)
      return S_FALSE;
    return S_OK;
  }

  _tableWasFilled = false;

  {
    Byte lens2[kLevelTableSize];
    
    for (unsigned i = 0; i < kLevelTableSize;)
    {
      _bitStream.Prepare();
      unsigned len = (unsigned)_bitStream.ReadBits9fix(4);
      if (len == 15)
      {
        unsigned num = (unsigned)_bitStream.ReadBits9fix(4);
        if (num != 0)
        {
          num += 2;
          num += i;
          if (num > kLevelTableSize)
            num = kLevelTableSize;
          do
            lens2[i++] = 0;
          while (i < num);
          continue;
        }
      }
      lens2[i++] = (Byte)len;
    }

    if (_bitStream.IsBlockOverRead())
      return S_FALSE;
    
    RIF(m_LevelDecoder.Build(lens2));
  }
  
  Byte lens[kTablesSizesSum];
  unsigned i = 0;
  
  while (i < kTablesSizesSum)
  {
    if (_bitStream._buf >= _bitStream._bufCheck2)
    {
      if (_bitStream._buf >= _bitStream._bufCheck)
        _bitStream.Prepare();
      if (_bitStream.IsBlockOverRead())
        return S_FALSE;
    }
    
    UInt32 sym = m_LevelDecoder.Decode(&_bitStream);
    
    if (sym < 16)
      lens[i++] = (Byte)sym;
    else if (sym > kLevelTableSize)
      return S_FALSE;
    else
    {
      sym -= 16;
      unsigned sh = ((sym & 1) << 2);
      unsigned num = (unsigned)_bitStream.ReadBits9(3 + sh) + 3 + (sh << 1);
      
      num += i;
      if (num > kTablesSizesSum)
        num = kTablesSizesSum;

      if (sym < 2)
      {
        if (i == 0)
        {
          // return S_FALSE;
          continue; // original unRAR
        }
        Byte v = lens[i - 1];
        do
          lens[i++] = v;
        while (i < num);
      }
      else
      {
        do
          lens[i++] = 0;
        while (i < num);
      }
    }
  }

  if (_bitStream.IsBlockOverRead())
    return S_FALSE;
  if (_bitStream.InputEofError())
    return S_FALSE;

  RIF(m_MainDecoder.Build(&lens[0]));
  RIF(m_DistDecoder.Build(&lens[kMainTableSize]));
  RIF(m_AlignDecoder.Build(&lens[kMainTableSize + kDistTableSize]));
  RIF(m_LenDecoder.Build(&lens[kMainTableSize + kDistTableSize + kAlignTableSize]));

  _useAlignBits = false;
  // _useAlignBits = true;
  for (i = 0; i < kAlignTableSize; i++)
    if (lens[kMainTableSize + kDistTableSize + i] != kNumAlignBits)
    {
      _useAlignBits = true;
      break;
    }

  _tableWasFilled = true;
  return S_OK;
}


static inline unsigned SlotToLen(CBitDecoder &_bitStream, unsigned slot)
{
  if (slot < 8)
    return slot + 2;
  unsigned numBits = (slot >> 2) - 1;
  return 2 + ((4 | (slot & 3)) << numBits) + _bitStream.ReadBits9(numBits);
}


static const UInt32 kSymbolRep = 258;
// static const unsigned kMaxMatchLen = 0x1001 + 3;

HRESULT CDecoder::DecodeLZ()
{
  CBitDecoder _bitStream;
  _bitStream._stream = _inStream;
  _bitStream._bufBase = _inputBuf;
  _bitStream.Init();

  UInt32 rep0 = _reps[0];

  UInt32 remLen = 0;

  size_t limit;
  {
    size_t rem = _winSize - _winPos;
    if (rem > kWriteStep)
      rem = kWriteStep;
    limit = _winPos + rem;
  }
  
  for (;;)
  {
    if (_winPos >= limit)
    {
      RINOK(WriteBuf());
      if (_unpackSize_Defined && _writtenFileSize > _unpackSize)
        break; // return S_FALSE;
      
      {
        size_t rem = _winSize - _winPos;
        
        if (rem == 0)
        {
          _winPos = 0;
          rem = _winSize;
        }
        if (rem > kWriteStep)
          rem = kWriteStep;
        limit = _winPos + rem;
      }

      if (remLen != 0)
      {
        size_t winPos = _winPos;
        size_t winMask = _winMask;
        size_t pos = (winPos - (size_t)rep0 - 1) & winMask;
        
        Byte *win = _window;
        do
        {
          if (winPos >= limit)
            break;
          win[winPos] = win[pos];
          winPos++;
          pos = (pos + 1) & winMask;
        }
        while (--remLen != 0);
        
        _lzSize += winPos - _winPos;
        _winPos = winPos;
        continue;
      }
    }

    if (_bitStream._buf >= _bitStream._bufCheck2)
    {
      if (_bitStream.InputEofError())
        break; // return S_FALSE;
      if (_bitStream._buf >= _bitStream._bufCheck)
        _bitStream.Prepare2();

      UInt64 processed = _bitStream.GetProcessedSize_Round();
      if (processed >= _bitStream._blockEnd)
      {
        if (processed > _bitStream._blockEnd)
          break; // return S_FALSE;
        {
          unsigned bits7 = _bitStream.GetProcessedBits7();
          if (bits7 > _bitStream._blockEndBits7)
            break; // return S_FALSE;
          if (bits7 == _bitStream._blockEndBits7)
          {
            if (_isLastBlock)
            {
              _reps[0] = rep0;
              
              if (_bitStream.InputEofError())
                break;
              
              /*
              // packSize can be 15 bytes larger for encrypted archive
              if (_packSize_Defined && _packSize < _bitStream.GetProcessedSize())
                break;
              */
              
              return _bitStream._hres;
              // break;
            }
            RINOK(ReadTables(_bitStream));
            continue;
          }
        }
      }
    }

    UInt32 sym = m_MainDecoder.Decode(&_bitStream);
    
    if (sym < 256)
    {
      size_t winPos = _winPos;
      _window[winPos] = (Byte)sym;
      _winPos = winPos + 1;
      _lzSize++;
      continue;
    }
   
    UInt32 len;

    if (sym < kSymbolRep + kNumReps)
    {
      if (sym >= kSymbolRep)
      {
        if (sym != kSymbolRep)
        {
          UInt32 dist;
          if (sym == kSymbolRep + 1)
            dist = _reps[1];
          else
          {
            if (sym == kSymbolRep + 2)
              dist = _reps[2];
            else
            {
              dist = _reps[3];
              _reps[3] = _reps[2];
            }
            _reps[2] = _reps[1];
          }
          _reps[1] = rep0;
          rep0 = dist;
        }
        
        const UInt32 sym2 = m_LenDecoder.Decode(&_bitStream);
        if (sym2 >= kLenTableSize)
          break; // return S_FALSE;
        len = SlotToLen(_bitStream, sym2);
      }
      else
      {
        if (sym == 256)
        {
          RINOK(AddFilter(_bitStream));
          continue;
        }
        else // if (sym == 257)
        {
          len = _lastLen;
          // if (len = 0), we ignore that symbol, like original unRAR code, but it can mean error in stream.
          // if (len == 0) return S_FALSE;
          if (len == 0)
            continue;
        }
      }
    }
    else if (sym >= kMainTableSize)
      break; // return S_FALSE;
    else
    {
      _reps[3] = _reps[2];
      _reps[2] = _reps[1];
      _reps[1] = rep0;
      len = SlotToLen(_bitStream, sym - (kSymbolRep + kNumReps));
      
      rep0 = m_DistDecoder.Decode(&_bitStream);
      
      if (rep0 >= 4)
      {
        if (rep0 >= _numCorrectDistSymbols)
          break; // return S_FALSE;
        unsigned numBits = (rep0 >> 1) - 1;
        rep0 = (2 | (rep0 & 1)) << numBits;
        
        if (numBits < kNumAlignBits)
          rep0 += _bitStream.ReadBits9(numBits);
        else
        {
          len += (numBits >= 7);
          len += (numBits >= 12);
          len += (numBits >= 17);
        
          if (_useAlignBits)
          {
            // if (numBits > kNumAlignBits)
              rep0 += (_bitStream.ReadBits32(numBits - kNumAlignBits) << kNumAlignBits);
            UInt32 a = m_AlignDecoder.Decode(&_bitStream);
            if (a >= kAlignTableSize)
              break; // return S_FALSE;
            rep0 += a;
          }
          else
            rep0 += _bitStream.ReadBits32(numBits);
        }
      }
    }

    _lastLen = len;

    if (rep0 >= _lzSize)
      _lzError = true;
    
    {
      UInt32 lenCur = len;
      size_t winPos = _winPos;
      size_t pos = (winPos - (size_t)rep0 - 1) & _winMask;
      {
        size_t rem = limit - winPos;
        // size_t rem = _winSize - winPos;

        if (lenCur > rem)
        {
          lenCur = (UInt32)rem;
          remLen = len - lenCur;
        }
      }
      
      Byte *win = _window;
      _lzSize += lenCur;
      _winPos = winPos + lenCur;
      if (_winSize - pos >= lenCur)
      {
        const Byte *src = win + pos;
        Byte *dest = win + winPos;
        do
          *dest++ = *src++;
        while (--lenCur != 0);
      }
      else
      {
        do
        {
          win[winPos] = win[pos];
          winPos++;
          pos = (pos + 1) & _winMask;
        }
        while (--lenCur != 0);
      }
    }
  }
  
  if (_bitStream._hres != S_OK)
    return _bitStream._hres;

  return S_FALSE;
}


HRESULT CDecoder::CodeReal()
{
  _unsupportedFilter = false;
  _lzError = false;
  _writeError = false;

  if (!_isSolid || !_wasInit)
  {
    size_t clearSize = _winSize;
    if (_lzSize < _winSize)
      clearSize = (size_t)_lzSize;
    memset(_window, 0, clearSize);

    _wasInit = true;
    _lzSize = 0;
    _lzWritten = 0;
    _winPos = 0;
    
    for (unsigned i = 0; i < kNumReps; i++)
      _reps[i] = (UInt32)0 - 1;

    _lastLen = 0;
    _tableWasFilled = false;
  }

  _isLastBlock = false;

  InitFilters();

  _filterEnd = 0;
  _writtenFileSize = 0;

  _lzFileStart = _lzSize;
  _lzWritten = _lzSize;
  
  HRESULT res = DecodeLZ();

  HRESULT res2 = S_OK;
  if (!_writeError && res != E_OUTOFMEMORY)
    res2 = WriteBuf();

  /*
  if (res == S_OK)
    if (InputEofError())
      res = S_FALSE;
  */

  if (res == S_OK)
    res = res2;
     
  if (res == S_OK && _unpackSize_Defined && _writtenFileSize != _unpackSize)
    return S_FALSE;
  return res;
}


// Original unRAR claims that maximum possible filter block size is (1 << 16) now,
// and (1 << 17) is minimum win size required to support filter.
// Original unRAR uses (1 << 18) for "extra safety and possible filter area size expansion"
// We can use any win size.

static const unsigned kWinSize_Log_Min = 17;

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try
  {
    if (_dictSizeLog >= sizeof(size_t) * 8)
      return E_NOTIMPL;

    if (!_isSolid)
      _lzEnd = 0;
    else
    {
      if (_lzSize < _lzEnd)
      {
        if (_window)
        {
          UInt64 rem = _lzEnd - _lzSize;
          if (rem >= _winSize)
            memset(_window, 0, _winSize);
          else
          {
            size_t pos = (size_t)_lzSize & _winSize;
            size_t rem2 = _winSize - pos;
            if (rem2 > rem)
              rem2 = (size_t)rem;
            memset(_window + pos, 0, rem2);
            rem -= rem2;
            memset(_window, 0, (size_t)rem);
          }
        }
        _lzEnd &= ((((UInt64)1) << 33) - 1);
        _lzSize = _lzEnd;
        _winPos = (size_t)(_lzSize & _winSize);
      }
      _lzEnd = _lzSize;
    }

    size_t newSize;
    {
      unsigned newSizeLog = _dictSizeLog;
      if (newSizeLog < kWinSize_Log_Min)
        newSizeLog = kWinSize_Log_Min;
      newSize = (size_t)1 << newSizeLog;
      _numCorrectDistSymbols = newSizeLog * 2;
    }

    if (!_window || _winSize != newSize)
    {
      if (!_isSolid && newSize > _winSizeAllocated)
      {
        ::MidFree(_window);
        _window = NULL;
        _winSizeAllocated = 0;
      }

      Byte *win = _window;
      if (!_window || newSize > _winSizeAllocated)
      {
        win = (Byte *)::MidAlloc(newSize);
        if (!win)
          return E_OUTOFMEMORY;
        _winSizeAllocated = newSize;
        memset(win, 0, newSize);
      }
      
      if (_isSolid && _window)
      {
        // original unRAR claims:
        // "Archiving code guarantees that win size does not grow in the same solid stream",
        // but the original unRAR decoder still supports such grow case.
        
        Byte *winOld = _window;
        size_t oldSize = _winSize;
        size_t newMask = newSize - 1;
        size_t oldMask = _winSize - 1;
        size_t winPos = _winPos;
        for (size_t i = 1; i < oldSize; i++) // i < oldSize) ?
          win[(winPos - i) & newMask] = winOld[(winPos - i) & oldMask];
        ::MidFree(_window);
      }
      
      _window = win;
      _winSize = newSize;
    }

    _winMask = _winSize - 1;

    if (!_inputBuf)
    {
      _inputBuf = (Byte *)::MidAlloc(kInputBufSize);
      if (!_inputBuf)
        return E_OUTOFMEMORY;
    }

    _inStream = inStream;
    _outStream = outStream;

    /*
    _packSize = 0;
    _packSize_Defined = (inSize != NULL);
    if (_packSize_Defined)
      _packSize = *inSize;
    */
    
    _unpackSize = 0;
    _unpackSize_Defined = (outSize != NULL);
    if (_unpackSize_Defined)
      _unpackSize = *outSize;

    if ((Int64)_unpackSize >= 0)
      _lzEnd += _unpackSize;
    else
      _lzEnd = 0;
    
    _progress = progress;
    
    HRESULT res = CodeReal();
    
    if (res != S_OK)
      return res;
    if (_lzError)
      return S_FALSE;
    if (_unsupportedFilter)
      return E_NOTIMPL;
    return S_OK;
  }
  // catch(const CInBufferException &e)  { return e.ErrorCode; }
  // catch(...) { return S_FALSE; }
  catch(...) { return E_OUTOFMEMORY; }
  // CNewException is possible here. But probably CNewException is caused
  // by error in data stream.
}

STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *data, UInt32 size)
{
  if (size != 2)
    return E_NOTIMPL;
  _dictSizeLog = (Byte)((data[0] & 0xF) + 17);
  _isSolid = ((data[1] & 1) != 0);
  return S_OK;
}

}}
// Rar5Decoder.h
// According to unRAR license, this code may not be used to develop
// a program that creates RAR archives

#ifndef __COMPRESS_RAR5_DECODER_H
#define __COMPRESS_RAR5_DECODER_H

#include "../../../C/Alloc.h"
#include "../../../C/CpuArch.h"

#include "../../Common/MyBuffer.h"
#include "../../Common/MyCom.h"
#include "../../Common/MyException.h"
#include "../../Common/MyVector.h"

#include "../ICoder.h"

#include "HuffmanDecoder.h"

namespace NCompress {
namespace NRar5 {

class CMidBuffer
{
  Byte *_data;
  size_t _size;

  CLASS_NO_COPY(CMidBuffer)

public:
  CMidBuffer(): _data(NULL), _size(0) {};
  ~CMidBuffer() { ::MidFree(_data); }

  bool IsAllocated() const { return _data != NULL; }
  operator       Byte *()       { return _data; }
  operator const Byte *() const { return _data; }
  size_t Size() const { return _size; }

  void AllocAtLeast(size_t size)
  {
    if (size > _size)
    {
      const size_t kMinSize = (1 << 16);
      if (size < kMinSize)
        size = kMinSize;
      ::MidFree(_data);
      _data = (Byte *)::MidAlloc(size);
      _size = size;
    }
  }
};

/*
struct CInBufferException: public CSystemException
{
  CInBufferException(HRESULT errorCode): CSystemException(errorCode) {}
};
*/

class CBitDecoder
{
public:
  const Byte *_buf;
  unsigned _bitPos;
  bool _wasFinished;
  Byte _blockEndBits7;
  const Byte *_bufCheck2;
  const Byte *_bufCheck;
  Byte *_bufLim;
  Byte *_bufBase;

  UInt64 _processedSize;
  UInt64 _blockEnd;

  ISequentialInStream *_stream;
  HRESULT _hres;

  void SetCheck2()
  {
    _bufCheck2 = _bufCheck;
    if (_bufCheck > _buf)
    {
      UInt64 processed = GetProcessedSize_Round();
      if (_blockEnd < processed)
        _bufCheck2 = _buf;
      else
      {
        UInt64 delta = _blockEnd - processed;
        if ((size_t)(_bufCheck - _buf) > delta)
          _bufCheck2 = _buf + (size_t)delta;
      }
    }
  }

  bool IsBlockOverRead() const
  {
    UInt64 v = GetProcessedSize_Round();
    if (v < _blockEnd)
      return false;
    if (v > _blockEnd)
      return true;
    return _bitPos > _blockEndBits7;
  }

  /*
  CBitDecoder() throw():
      _buf(0),
      _bufLim(0),
      _bufBase(0),
      _stream(0),
      _processedSize(0),
      _wasFinished(false)
      {}
  */

  void Init() throw()
  {
    _blockEnd = 0;
    _blockEndBits7 = 0;

    _bitPos = 0;
    _processedSize = 0;
    _buf = _bufBase;
    _bufLim = _bufBase;
    _bufCheck = _buf;
    _bufCheck2 = _buf;
    _wasFinished = false;
  }

  void Prepare2() throw();

  void Prepare() throw()
  {
    if (_buf >= _bufCheck)
      Prepare2();
  }

  bool ExtraBitsWereRead() const
  {
    return _buf >= _bufLim && (_buf > _bufLim || _bitPos != 0);
  }

  bool InputEofError() const { return ExtraBitsWereRead(); }

  unsigned GetProcessedBits7() const { return _bitPos; }
  UInt64 GetProcessedSize_Round() const { return _processedSize + (_buf - _bufBase); }
  UInt64 GetProcessedSize() const { return _processedSize + (_buf - _bufBase) + ((_bitPos + 7) >> 3); }

  void AlignToByte()
  {
    _buf += (_bitPos + 7) >> 3;
    _bitPos = 0;
  }

  Byte ReadByteInAligned()
  {
    return *_buf++;
  }

  UInt32 GetValue(unsigned numBits)
  {
    UInt32 v = ((UInt32)_buf[0] << 16) | ((UInt32)_buf[1] << 8) | (UInt32)_buf[2];
    v >>= (24 - numBits - _bitPos);
    return v & ((1 << numBits) - 1);
  }
  
  void MovePos(unsigned numBits)
  {
    _bitPos += numBits;
    _buf += (_bitPos >> 3);
    _bitPos &= 7;
  }

  UInt32 ReadBits9(unsigned numBits)
  {
    const Byte *buf = _buf;
    UInt32 v = ((UInt32)buf[0] << 8) | (UInt32)buf[1];
    v &= ((UInt32)0xFFFF >> _bitPos);
    numBits += _bitPos;
    v >>= (16 - numBits);
    _buf = buf + (numBits >> 3);
    _bitPos = numBits & 7;
    return v;
  }

  UInt32 ReadBits9fix(unsigned numBits)
  {
    const Byte *buf = _buf;
    UInt32 v = ((UInt32)buf[0] << 8) | (UInt32)buf[1];
    UInt32 mask = ((1 << numBits) - 1);
    numBits += _bitPos;
    v >>= (16 - numBits);
    _buf = buf + (numBits >> 3);
    _bitPos = numBits & 7;
    return v & mask;
  }

  UInt32 ReadBits32(unsigned numBits)
  {
    UInt32 mask = ((1 << numBits) - 1);
    numBits += _bitPos;
    const Byte *buf = _buf;
    UInt32 v = GetBe32(buf);
    if (numBits > 32)
    {
      v <<= (numBits - 32);
      v |= (UInt32)buf[4] >> (40 - numBits);
    }
    else
      v >>= (32 - numBits);
    _buf = buf + (numBits >> 3);
    _bitPos = numBits & 7;
    return v & mask;
  }
};


struct CFilter
{
  Byte Type;
  Byte Channels;
  UInt32 Size;
  UInt64 Start;
};


const unsigned kNumReps = 4;
const unsigned kLenTableSize = 11 * 4;
const unsigned kMainTableSize = 256 + 1 + 1 + kNumReps + kLenTableSize;
const unsigned kDistTableSize = 64;
const unsigned kNumAlignBits = 4;
const unsigned kAlignTableSize = (1 << kNumAlignBits);
const unsigned kLevelTableSize = 20;
const unsigned kTablesSizesSum = kMainTableSize + kDistTableSize + kAlignTableSize + kLenTableSize;

const unsigned kNumHuffmanBits = 15;

class CDecoder:
  public ICompressCoder,
  public ICompressSetDecoderProperties2,
  public CMyUnknownImp
{
  bool _useAlignBits;
  bool _isLastBlock;
  bool _unpackSize_Defined;
  // bool _packSize_Defined;
  
  bool _unsupportedFilter;
  bool _lzError;
  bool _writeError;
  
  // CBitDecoder _bitStream;
  Byte *_window;
  size_t _winPos;
  size_t _winSize;
  size_t _winMask;

  UInt64 _lzSize;

  unsigned _numCorrectDistSymbols;
  unsigned _numUnusedFilters;

  UInt64 _lzWritten;
  UInt64 _lzFileStart;
  UInt64 _unpackSize;
  // UInt64 _packSize;
  UInt64 _lzEnd;
  UInt64 _writtenFileSize;
  size_t _winSizeAllocated;

  Byte _dictSizeLog;
  bool _tableWasFilled;
  bool _isSolid;
  bool _wasInit;

  UInt32 _reps[kNumReps];
  UInt32 _lastLen;
  
  UInt64 _filterEnd;
  CMidBuffer _filterSrc;
  CMidBuffer _filterDst;

  CRecordVector<CFilter> _filters;

  ISequentialInStream *_inStream;
  ISequentialOutStream *_outStream;
  ICompressProgressInfo *_progress;
  Byte *_inputBuf;

  NHuffman::CDecoder<kNumHuffmanBits, kMainTableSize> m_MainDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kDistTableSize> m_DistDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kAlignTableSize> m_AlignDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kLenTableSize> m_LenDecoder;
  NHuffman::CDecoder<kNumHuffmanBits, kLevelTableSize> m_LevelDecoder;


  void InitFilters()
  {
    _numUnusedFilters = 0;
    _filters.Clear();
  }

  void DeleteUnusedFilters()
  {
    if (_numUnusedFilters != 0)
    {
      _filters.DeleteFrontal(_numUnusedFilters);
      _numUnusedFilters = 0;
    }
  }

  HRESULT WriteData(const Byte *data, size_t size);
  HRESULT ExecuteFilter(const CFilter &f);
  HRESULT WriteBuf();
  HRESULT AddFilter(CBitDecoder &_bitStream);

  HRESULT ReadTables(CBitDecoder &_bitStream);
  HRESULT DecodeLZ();
  HRESULT CodeReal();
  
public:
  CDecoder();
  ~CDecoder();

  MY_UNKNOWN_IMP1(ICompressSetDecoderProperties2)

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);
};

}}

#endif
// RarCodecsRegister.cpp

#include "StdAfx.h"

#include "../Common/RegisterCodec.h"

#include "Rar1Decoder.h"
#include "Rar2Decoder.h"
#include "Rar3Decoder.h"
#include "Rar5Decoder.h"

namespace NCompress {

#define CREATE_CODEC(x) REGISTER_CODEC_CREATE(CreateCodec ## x, NRar ## x::CDecoder())

CREATE_CODEC(1)
CREATE_CODEC(2)
CREATE_CODEC(3)
CREATE_CODEC(5)

#define RAR_CODEC(x, name) { CreateCodec ## x, NULL, 0x40300 + x, "Rar" name, 1, false }

REGISTER_CODECS_VAR
{
  RAR_CODEC(1, "1"),
  RAR_CODEC(2, "2"),
  RAR_CODEC(3, "3"),
  RAR_CODEC(5, "5"),
};

REGISTER_CODECS(Rar)

}
// ShrinkDecoder.cpp


#include "StdAfx.h"

#include <stdio.h>

#include "../../../C/Alloc.h"

#include "../Common/InBuffer.h"
#include "../Common/OutBuffer.h"

#include "BitlDecoder.h"
#include "ShrinkDecoder.h"

namespace NCompress {
namespace NShrink {

static const UInt32 kBufferSize = (1 << 18);
static const unsigned kNumMinBits = 9;

HRESULT CDecoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  NBitl::CBaseDecoder<CInBuffer> inBuffer;
  COutBuffer outBuffer;

  if (!inBuffer.Create(kBufferSize))
    return E_OUTOFMEMORY;
  inBuffer.SetStream(inStream);
  inBuffer.Init();

  if (!outBuffer.Create(kBufferSize))
    return E_OUTOFMEMORY;
  outBuffer.SetStream(outStream);
  outBuffer.Init();

  {
    unsigned i;
    for (i = 0; i < 257; i++)
      _parents[i] = (UInt16)i;
    for (; i < kNumItems; i++)
      _parents[i] = kNumItems;
    for (i = 0; i < kNumItems; i++)
      _suffixes[i] = 0;
  }

  UInt64 prevPos = 0;
  unsigned numBits = kNumMinBits;
  unsigned head = 257;
  int lastSym = -1;
  Byte lastChar2 = 0;

  for (;;)
  {
    UInt32 sym = inBuffer.ReadBits(numBits);
    
    if (inBuffer.ExtraBitsWereRead())
      break;
    
    if (sym == 256)
    {
      sym = inBuffer.ReadBits(numBits);
      if (sym == 1)
      {
        if (numBits >= kNumMaxBits)
          return S_FALSE;
        numBits++;
        continue;
      }
      if (sym != 2)
        return S_FALSE;
      {
        unsigned i;
        for (i = 257; i < kNumItems; i++)
          _stack[i] = 0;
        for (i = 257; i < kNumItems; i++)
        {
          unsigned par = _parents[i];
          if (par != kNumItems)
            _stack[par] = 1;
        }
        for (i = 257; i < kNumItems; i++)
          if (_stack[i] == 0)
            _parents[i] = kNumItems;
       
        head = 257;
       
        continue;
      }
    }

    bool needPrev = false;
    if (head < kNumItems && lastSym >= 0)
    {
      while (head < kNumItems && _parents[head] != kNumItems)
        head++;
      if (head < kNumItems)
      {
        if (head == (unsigned)lastSym)
        {
          // we need to fix the code for that case
          // _parents[head] is not allowed to link to itself
          return E_NOTIMPL;
        }
        needPrev = true;
        _parents[head] = (UInt16)lastSym;
        _suffixes[head] = (Byte)lastChar2;
        head++;
      }
    }

    if (_parents[sym] == kNumItems)
      return S_FALSE;

    lastSym = sym;
    unsigned cur = sym;
    unsigned i = 0;
    
    while (cur >= 256)
    {
      _stack[i++] = _suffixes[cur];
      cur = _parents[cur];
    }
    
    _stack[i++] = (Byte)cur;
    lastChar2 = (Byte)cur;

    if (needPrev)
      _suffixes[head - 1] = (Byte)cur;

    do
      outBuffer.WriteByte(_stack[--i]);
    while (i);
    
    if (progress)
    {
      const UInt64 nowPos = outBuffer.GetProcessedSize();
      if (nowPos - prevPos >= (1 << 18))
      {
        prevPos = nowPos;
        const UInt64 packSize = inBuffer.GetProcessedSize();
        RINOK(progress->SetRatioInfo(&packSize, &nowPos));
      }
    }
  }
  
  return outBuffer.Flush();
}

STDMETHODIMP CDecoder ::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try { return CodeReal(inStream, outStream, inSize, outSize, progress); }
  catch(const CInBufferException &e) { return e.ErrorCode; }
  catch(const COutBufferException &e) { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
}

}}
// ShrinkDecoder.h

#ifndef __COMPRESS_SHRINK_DECODER_H
#define __COMPRESS_SHRINK_DECODER_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"

namespace NCompress {
namespace NShrink {

const unsigned kNumMaxBits = 13;
const unsigned kNumItems = 1 << kNumMaxBits;

class CDecoder :
  public ICompressCoder,
  public CMyUnknownImp
{
  UInt16 _parents[kNumItems];
  Byte _suffixes[kNumItems];
  Byte _stack[kNumItems];

public:
  MY_UNKNOWN_IMP

  HRESULT CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
};

}}

#endif
// XpressDecoder.cpp

#include "StdAfx.h"

// #include <stdio.h>

#include "../../../C/CpuArch.h"

#include "HuffmanDecoder.h"

namespace NCompress {
namespace NXpress {

struct CBitStream
{
  UInt32 Value;
  unsigned BitPos;

  UInt32 GetValue(unsigned numBits) const
  {
    return (Value >> (BitPos - numBits)) & ((1 << numBits) - 1);
  }
  
  void MovePos(unsigned numBits)
  {
    BitPos -= numBits;
  }
};

#define BIT_STREAM_NORMALIZE \
    if (bs.BitPos < 16) { \
      if (in >= lim) return S_FALSE; \
      bs.Value = (bs.Value << 16) | GetUi16(in); \
      in += 2; bs.BitPos += 16; }
 
const unsigned kNumHuffBits = 15;
const unsigned kNumLenSlots = 16;
const unsigned kNumPosSlots = 16;
const unsigned kNumSyms = 256 + kNumPosSlots * kNumLenSlots;

HRESULT Decode(const Byte *in, size_t inSize, Byte *out, size_t outSize)
{
  NCompress::NHuffman::CDecoder<kNumHuffBits, kNumSyms> huff;
  
  if (inSize < kNumSyms / 2 + 4)
    return S_FALSE;
  {
    Byte levels[kNumSyms];
    for (unsigned i = 0; i < kNumSyms / 2; i++)
    {
      Byte b = in[i];
      levels[i * 2] = (Byte)(b & 0xF);
      levels[i * 2 + 1] = (Byte)(b >> 4);
    }
    if (!huff.BuildFull(levels))
      return S_FALSE;
  }


  CBitStream bs;

  const Byte *lim = in + inSize - 1;

  in += kNumSyms / 2;
  bs.Value = (GetUi16(in) << 16) | GetUi16(in + 2);
  in += 4;
  bs.BitPos = 32;

  size_t pos = 0;

  for (;;)
  {
    // printf("\n%d", pos);
    UInt32 sym = huff.DecodeFull(&bs);
    // printf(" sym = %d", sym);
    BIT_STREAM_NORMALIZE

    if (pos >= outSize)
      return (sym == 256 && in == lim + 1) ? S_OK : S_FALSE;

    if (sym < 256)
      out[pos++] = (Byte)sym;
    else
    {
      sym -= 256;
      UInt32 dist = sym / kNumLenSlots;
      UInt32 len = sym & (kNumLenSlots - 1);
      
      if (len == kNumLenSlots - 1)
      {
        if (in > lim)
          return S_FALSE;
        len = *in++;
        if (len == 0xFF)
        {
          if (in >= lim)
            return S_FALSE;
          len = GetUi16(in);
          in += 2;
        }
        else
          len += kNumLenSlots - 1;
      }

      bs.BitPos -= dist;
      dist = (UInt32)1 << dist;
      dist += ((bs.Value >> bs.BitPos) & (dist - 1));

      BIT_STREAM_NORMALIZE
      
      if (len > outSize - pos)
        return S_FALSE;
      if (dist > pos)
        return S_FALSE;

      Byte *dest = out + pos;
      const Byte *src = dest - dist;
      pos += len + 3;
      len += 1;
      *dest++ = *src++;
      *dest++ = *src++;
      do
        *dest++ = *src++;
      while (--len);
    }
  }
}

}}
// XpressDecoder.h

#ifndef __XPRESS_DECODER_H
#define __XPRESS_DECODER_H

namespace NCompress {
namespace NXpress {

HRESULT Decode(const Byte *in, size_t inSize, Byte *out, size_t outSize);

}}

#endif
// ZDecoder.cpp

#include "StdAfx.h"

// #include <stdio.h>

#include "../../../C/Alloc.h"

#include "../Common/InBuffer.h"
#include "../Common/OutBuffer.h"

#include "ZDecoder.h"

namespace NCompress {
namespace NZ {

static const UInt32 kBufferSize = (1 << 20);
static const Byte kNumBitsMask = 0x1F;
static const Byte kBlockModeMask = 0x80;
static const unsigned kNumMinBits = 9;
static const unsigned kNumMaxBits = 16;

void CDecoder::Free()
{
  MyFree(_parents); _parents = 0;
  MyFree(_suffixes); _suffixes = 0;
  MyFree(_stack); _stack = 0;
}

CDecoder::~CDecoder() { Free(); }

HRESULT CDecoder::CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  CInBuffer inBuffer;
  COutBuffer outBuffer;

  PackSize = 0;
  
  if (!inBuffer.Create(kBufferSize))
    return E_OUTOFMEMORY;
  inBuffer.SetStream(inStream);
  inBuffer.Init();

  if (!outBuffer.Create(kBufferSize))
    return E_OUTOFMEMORY;
  outBuffer.SetStream(outStream);
  outBuffer.Init();

  Byte buf[kNumMaxBits + 4];
  {
    if (inBuffer.ReadBytes(buf, 3) < 3)
      return S_FALSE;
    if (buf[0] != 0x1F || buf[1] != 0x9D)
      return S_FALSE;;
  }
  Byte prop = buf[2];

  if ((prop & 0x60) != 0)
    return S_FALSE;
  unsigned maxbits = prop & kNumBitsMask;
  if (maxbits < kNumMinBits || maxbits > kNumMaxBits)
    return S_FALSE;
  UInt32 numItems = 1 << maxbits;
  // Speed optimization: blockSymbol can contain unused velue.

  if (maxbits != _numMaxBits || _parents == 0 || _suffixes == 0 || _stack == 0)
  {
    Free();
    _parents = (UInt16 *)MyAlloc(numItems * sizeof(UInt16)); if (_parents == 0) return E_OUTOFMEMORY;
    _suffixes = (Byte *)MyAlloc(numItems * sizeof(Byte)); if (_suffixes == 0) return E_OUTOFMEMORY;
    _stack = (Byte *)MyAlloc(numItems * sizeof(Byte)); if (_stack == 0) return E_OUTOFMEMORY;
    _numMaxBits = maxbits;
  }

  UInt64 prevPos = 0;
  UInt32 blockSymbol = ((prop & kBlockModeMask) != 0) ? 256 : ((UInt32)1 << kNumMaxBits);
  unsigned numBits = kNumMinBits;
  UInt32 head = (blockSymbol == 256) ? 257 : 256;
  bool needPrev = false;
  unsigned bitPos = 0;
  unsigned numBufBits = 0;

  _parents[256] = 0; // virus protection
  _suffixes[256] = 0;
  HRESULT res = S_OK;

  for (;;)
  {
    if (numBufBits == bitPos)
    {
      numBufBits = (unsigned)inBuffer.ReadBytes(buf, numBits) * 8;
      bitPos = 0;
      UInt64 nowPos = outBuffer.GetProcessedSize();
      if (progress && nowPos - prevPos >= (1 << 13))
      {
        prevPos = nowPos;
        UInt64 packSize = inBuffer.GetProcessedSize();
        RINOK(progress->SetRatioInfo(&packSize, &nowPos));
      }
    }
    unsigned bytePos = bitPos >> 3;
    UInt32 symbol = buf[bytePos] | ((UInt32)buf[bytePos + 1] << 8) | ((UInt32)buf[bytePos + 2] << 16);
    symbol >>= (bitPos & 7);
    symbol &= (1 << numBits) - 1;
    bitPos += numBits;
    if (bitPos > numBufBits)
      break;
    if (symbol >= head)
    {
      res = S_FALSE;
      break;
    }
    if (symbol == blockSymbol)
    {
      numBufBits = bitPos = 0;
      numBits = kNumMinBits;
      head = 257;
      needPrev = false;
      continue;
    }
    UInt32 cur = symbol;
    unsigned i = 0;
    while (cur >= 256)
    {
      _stack[i++] = _suffixes[cur];
      cur = _parents[cur];
    }
    _stack[i++] = (Byte)cur;
    if (needPrev)
    {
      _suffixes[head - 1] = (Byte)cur;
      if (symbol == head - 1)
        _stack[0] = (Byte)cur;
    }
    do
      outBuffer.WriteByte((_stack[--i]));
    while (i > 0);
    if (head < numItems)
    {
      needPrev = true;
      _parents[head++] = (UInt16)symbol;
      if (head > ((UInt32)1 << numBits))
      {
        if (numBits < maxbits)
        {
          numBufBits = bitPos = 0;
          numBits++;
        }
      }
    }
    else
      needPrev = false;
  }
  PackSize = inBuffer.GetProcessedSize();
  HRESULT res2 = outBuffer.Flush();
  return (res == S_OK) ? res2 : res;
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  try { return CodeReal(inStream, outStream, inSize, outSize, progress); }
  catch(const CInBufferException &e) { return e.ErrorCode; }
  catch(const COutBufferException &e) { return e.ErrorCode; }
  catch(...) { return S_FALSE; }
}

bool CheckStream(const Byte *data, size_t size)
{
  if (size < 3)
    return false;
  if (data[0] != 0x1F || data[1] != 0x9D)
    return false;
  Byte prop = data[2];
  if ((prop & 0x60) != 0)
    return false;
  unsigned maxbits = prop & kNumBitsMask;
  if (maxbits < kNumMinBits || maxbits > kNumMaxBits)
    return false;
  UInt32 numItems = 1 << maxbits;
  UInt32 blockSymbol = ((prop & kBlockModeMask) != 0) ? 256 : ((UInt32)1 << kNumMaxBits);
  unsigned numBits = kNumMinBits;
  UInt32 head = (blockSymbol == 256) ? 257 : 256;
  unsigned bitPos = 0;
  unsigned numBufBits = 0;
  Byte buf[kNumMaxBits + 4];
  data += 3;
  size -= 3;
  // printf("\n\n");
  for (;;)
  {
    if (numBufBits == bitPos)
    {
      unsigned num = (numBits < size) ? numBits : (unsigned)size;
      memcpy(buf, data, num);
      data += num;
      size -= num;
      numBufBits = num * 8;
      bitPos = 0;
    }
    unsigned bytePos = bitPos >> 3;
    UInt32 symbol = buf[bytePos] | ((UInt32)buf[bytePos + 1] << 8) | ((UInt32)buf[bytePos + 2] << 16);
    symbol >>= (bitPos & 7);
    symbol &= (1 << numBits) - 1;
    bitPos += numBits;
    if (bitPos > numBufBits)
    {
      // printf("  OK", symbol);
      return true;
    }
    // printf("%3X ", symbol);
    if (symbol >= head)
      return false;
    if (symbol == blockSymbol)
    {
      numBufBits = bitPos = 0;
      numBits = kNumMinBits;
      head = 257;
      continue;
    }
    if (head < numItems)
    {
      head++;
      if (head > ((UInt32)1 << numBits))
      {
        if (numBits < maxbits)
        {
          numBufBits = bitPos = 0;
          numBits++;
        }
      }
    }
  }
}

}}
// ZDecoder.h

#ifndef __COMPRESS_Z_DECODER_H
#define __COMPRESS_Z_DECODER_H

#include "../../Common/MyCom.h"

#include "../ICoder.h"

namespace NCompress {
namespace NZ {

// Z decoder decodes Z data stream, including 3 bytes of header.
  
class CDecoder:
  public ICompressCoder,
  public CMyUnknownImp
{
  UInt16 *_parents;
  Byte *_suffixes;
  Byte *_stack;
  unsigned _numMaxBits;

public:
  CDecoder(): _parents(0), _suffixes(0), _stack(0), /* _prop(0), */ _numMaxBits(0) {};
  ~CDecoder();
  void Free();
  UInt64 PackSize;

  MY_UNKNOWN_IMP1(ICompressCoder)

  HRESULT CodeReal(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
};

/*
  There is no end_of_payload_marker in Z stream.
  Z decoder stops decoding, if it reaches end of input stream.
   
  CheckStream function:
    (size) must be at least 3 bytes (size of Z header).
    if (size) is larger than size of real Z stream in (data), CheckStream can return false.
*/

const unsigned kRecommendedCheckSize = 64;

bool CheckStream(const Byte *data, size_t size);

}}

#endif
// ZlibDecoder.cpp

#include "StdAfx.h"

#include "../Common/StreamUtils.h"

#include "ZlibDecoder.h"

namespace NCompress {
namespace NZlib {

#define DEFLATE_TRY_BEGIN try {
#define DEFLATE_TRY_END } catch(...) { return S_FALSE; }

#define ADLER_MOD 65521
#define ADLER_LOOP_MAX 5550

UInt32 Adler32_Update(UInt32 adler, const Byte *buf, size_t size)
{
  UInt32 a = adler & 0xFFFF;
  UInt32 b = (adler >> 16) & 0xFFFF;
  while (size > 0)
  {
    unsigned curSize = (size > ADLER_LOOP_MAX) ? ADLER_LOOP_MAX : (unsigned )size;
    unsigned i;
    for (i = 0; i < curSize; i++)
    {
      a += buf[i];
      b += a;
    }
    buf += curSize;
    size -= curSize;
    a %= ADLER_MOD;
    b %= ADLER_MOD;
  }
  return (b << 16) + a;
}

STDMETHODIMP COutStreamWithAdler::Write(const void *data, UInt32 size, UInt32 *processedSize)
{
  HRESULT result = S_OK;
  if (_stream)
    result = _stream->Write(data, size, &size);
  _adler = Adler32_Update(_adler, (const Byte *)data, size);
  _size += size;
  if (processedSize)
    *processedSize = size;
  return result;
}

STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
{
  DEFLATE_TRY_BEGIN
  if (!AdlerStream)
    AdlerStream = AdlerSpec = new COutStreamWithAdler;
  if (!DeflateDecoder)
  {
    DeflateDecoderSpec = new NDeflate::NDecoder::CCOMCoder;
    DeflateDecoderSpec->ZlibMode = true;
    DeflateDecoder = DeflateDecoderSpec;
  }

  if (inSize && *inSize < 2)
    return S_FALSE;
  Byte buf[2];
  RINOK(ReadStream_FALSE(inStream, buf, 2));
  if (!IsZlib(buf))
    return S_FALSE;

  AdlerSpec->SetStream(outStream);
  AdlerSpec->Init();
  
  UInt64 inSize2 = 0;
  if (inSize)
    inSize2 = *inSize - 2;

  HRESULT res = DeflateDecoder->Code(inStream, AdlerStream, inSize ? &inSize2 : NULL, outSize, progress);
  AdlerSpec->ReleaseStream();

  if (res == S_OK)
  {
    const Byte *p = DeflateDecoderSpec->ZlibFooter;
    UInt32 adler = ((UInt32)p[0] << 24) | ((UInt32)p[1] << 16) | ((UInt32)p[2] << 8) | p[3];
    if (adler != AdlerSpec->GetAdler())
      return S_FALSE;
  }
  return res;
  DEFLATE_TRY_END
}

}}
// ZlibDecoder.h

#ifndef __ZLIB_DECODER_H
#define __ZLIB_DECODER_H

#include "DeflateDecoder.h"

namespace NCompress {
namespace NZlib {

const UInt32 ADLER_INIT_VAL = 1;

class COutStreamWithAdler:
  public ISequentialOutStream,
  public CMyUnknownImp
{
  CMyComPtr<ISequentialOutStream> _stream;
  UInt32 _adler;
  UInt64 _size;
public:
  MY_UNKNOWN_IMP
  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
  void SetStream(ISequentialOutStream *stream) { _stream = stream; }
  void ReleaseStream() { _stream.Release(); }
  void Init() { _adler = ADLER_INIT_VAL; _size = 0; }
  UInt32 GetAdler() const { return _adler; }
  UInt64 GetSize() const { return _size; }
};

class CDecoder:
  public ICompressCoder,
  public CMyUnknownImp
{
  COutStreamWithAdler *AdlerSpec;
  CMyComPtr<ISequentialOutStream> AdlerStream;
  
  NCompress::NDeflate::NDecoder::CCOMCoder *DeflateDecoderSpec;
  CMyComPtr<ICompressCoder> DeflateDecoder;
public:
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

  UInt64 GetInputProcessedSize() const { return DeflateDecoderSpec->GetInputProcessedSize() + 2; }
  UInt64 GetOutputProcessedSize() const { return AdlerSpec->GetSize(); }

  MY_UNKNOWN_IMP
};

static bool inline IsZlib(const Byte *p)
{
  if ((p[0] & 0xF) != 8) // method
    return false;
  if (((unsigned)p[0] >> 4) > 7) // logar_window_size minus 8.
    return false;
  if ((p[1] & 0x20) != 0) // dictPresent
    return false;
  if ((((UInt32)p[0] << 8) + p[1]) % 31 != 0)
    return false;
  return true;
}

// IsZlib_3bytes checks 2 bytes of zlib header and starting byte of Deflate stream

static bool inline IsZlib_3bytes(const Byte *p)
{
  if (!IsZlib(p))
    return false;
  unsigned val = p[2];
  unsigned blockType = (val >> 1) & 0x3;
  if (blockType == 3) // unsupported block type for deflate
    return false;
  if (blockType == NCompress::NDeflate::NBlockType::kStored && (val >> 3) != 0)
    return false;
  return true;
}

}}

#endif
// ZlibEncoder.cpp

#include "StdAfx.h"

#include "../Common/StreamUtils.h"

#include "ZlibEncoder.h"

namespace NCompress {
namespace NZlib {

#define DEFLATE_TRY_BEGIN try {
#define DEFLATE_TRY_END } catch(...) { return S_FALSE; }

UInt32 Adler32_Update(UInt32 adler, const Byte *buf, size_t size);

STDMETHODIMP CInStreamWithAdler::Read(void *data, UInt32 size, UInt32 *processedSize)
{
  HRESULT result = _stream->Read(data, size, &size);
  _adler = Adler32_Update(_adler, (const Byte *)data, size);
  _size += size;
  if (processedSize != NULL)
    *processedSize = size;
  return result;
}

void CEncoder::Create()
{
  if (!DeflateEncoder)
    DeflateEncoder = DeflateEncoderSpec = new NDeflate::NEncoder::CCOMCoder;
}

STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
    const UInt64 *inSize, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
{
  DEFLATE_TRY_BEGIN
  if (!AdlerStream)
    AdlerStream = AdlerSpec = new CInStreamWithAdler;
  Create();

  {
    Byte buf[2] = { 0x78, 0xDA };
    RINOK(WriteStream(outStream, buf, 2));
  }

  AdlerSpec->SetStream(inStream);
  AdlerSpec->Init();
  HRESULT res = DeflateEncoder->Code(AdlerStream, outStream, inSize, NULL, progress);
  AdlerSpec->ReleaseStream();

  RINOK(res);

  {
    UInt32 a = AdlerSpec->GetAdler();
    Byte buf[4] = { (Byte)(a >> 24), (Byte)(a >> 16), (Byte)(a >> 8), (Byte)(a) };
    return WriteStream(outStream, buf, 4);
  }
  DEFLATE_TRY_END
}

}}
// ZlibEncoder.h

#ifndef __ZLIB_ENCODER_H
#define __ZLIB_ENCODER_H

#include "DeflateEncoder.h"

namespace NCompress {
namespace NZlib {

class CInStreamWithAdler:
  public ISequentialInStream,
  public CMyUnknownImp
{
  CMyComPtr<ISequentialInStream> _stream;
  UInt32 _adler;
  UInt64 _size;
public:
  MY_UNKNOWN_IMP
  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
  void SetStream(ISequentialInStream *stream) { _stream = stream; }
  void ReleaseStream() { _stream.Release(); }
  void Init() { _adler = 1; _size = 0; } // ADLER_INIT_VAL
  UInt32 GetAdler() const { return _adler; }
  UInt64 GetSize() const { return _size; }
};

class CEncoder:
  public ICompressCoder,
  public CMyUnknownImp
{
  CInStreamWithAdler *AdlerSpec;
  CMyComPtr<ISequentialInStream> AdlerStream;
  CMyComPtr<ICompressCoder> DeflateEncoder;
public:
  NCompress::NDeflate::NEncoder::CCOMCoder *DeflateEncoderSpec;
  
  void Create();
  STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
      const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
  UInt64 GetInputProcessedSize() const { return AdlerSpec->GetSize(); }

  MY_UNKNOWN_IMP
};

}}

#endif
The MIT License (MIT)

Copyright (c) 2009-2015 Richard Geldreich, Jr. <richgel99@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

// LzhamRegister.cpp
// Portions of this module are from 7-zip, by Igor Pavlov, which you can download here:
// http://www.7-zip.org/

//#include "StdAfx.h"

#ifndef _WIN32
#define WINAPI /* */
#endif

#include "lzham_core.h" // for LZHAM_64BIT_POINTERS

#include "C/Alloc.h"

//#include "../Common/RegisterCodec.h"
#include "Common/Common.h"
#include "Common/MyCom.h"
#include "7zip/ICoder.h"
#include "7zip/Common/StreamUtils.h"
#include "7zip/Common/RegisterCodec.h"
#include "Windows/System.h"

#include "lzham_static_lib.h"

#if 0
#include <stdio.h>
#define LZHAMCODEC_DEBUG_OUTPUT 1
#endif

#define LZHAM_PROPS_VER (Byte)(LZHAM_DLL_VERSION)

namespace NCompress
{
   namespace NLzham
   {
      struct CProps
      {
         CProps() { clear(); }

         void clear() 
		 { 
			 memset(this, 0, sizeof(*this)); 
			 _ver = LZHAM_PROPS_VER; 
			 _dict_size = 0; 
			 _level = LZHAM_COMP_LEVEL_UBER; 
			 _flags = 0; 
		 }

         Byte _ver;
         Byte _dict_size;
         Byte _level;
         Byte _flags;
         Byte _reserved[1];
      };

      class CDecoder:
         public ICompressCoder,
         public ICompressSetDecoderProperties2,
         public ICompressSetBufSize,
#ifndef NO_READ_FROM_CODER
         public ICompressSetInStream,
         public ICompressSetOutStreamSize,
         public ISequentialInStream,
#endif
         public CMyUnknownImp
      {
         CMyComPtr<ISequentialInStream> _inStream;
         Byte *_inBuf;
         Byte *_outBuf;
         UInt32 _inPos;
         UInt32 _inSize;
         
         lzham_decompress_state_ptr _state;

         CProps _props;
         bool _propsWereSet;
         
         bool _outSizeDefined;
         UInt64 _outSize;
         UInt64 _inSizeProcessed;
         UInt64 _outSizeProcessed;

         UInt32 _inBufSizeAllocated;
         UInt32 _outBufSizeAllocated;
         UInt32 _inBufSize;
         UInt32 _outBufSize;

         HRESULT CreateBuffers();
         HRESULT CodeSpec(ISequentialInStream *inStream, ISequentialOutStream *outStream, ICompressProgressInfo *progress);
         
         HRESULT SetOutStreamSizeResume(const UInt64 *outSize);
         HRESULT CreateDecompressor();

      public:
         MY_QUERYINTERFACE_BEGIN2(ICompressCoder)
            MY_QUERYINTERFACE_ENTRY(ICompressSetDecoderProperties2)
            MY_QUERYINTERFACE_ENTRY(ICompressSetBufSize)
#ifndef NO_READ_FROM_CODER
            MY_QUERYINTERFACE_ENTRY(ICompressSetInStream)
            MY_QUERYINTERFACE_ENTRY(ICompressSetOutStreamSize)
            MY_QUERYINTERFACE_ENTRY(ISequentialInStream)
#endif
            MY_QUERYINTERFACE_END
            MY_ADDREF_RELEASE

            STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
            const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);
         STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);
         STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);
         STDMETHOD(SetInBufSize)(UInt32 streamIndex, UInt32 size);
         STDMETHOD(SetOutBufSize)(UInt32 streamIndex, UInt32 size);

#ifndef NO_READ_FROM_CODER

         STDMETHOD(SetInStream)(ISequentialInStream *inStream);
         STDMETHOD(ReleaseInStream)();
         STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);

         HRESULT CodeResume(ISequentialOutStream *outStream, const UInt64 *outSize, ICompressProgressInfo *progress);
         UInt64 GetInputProcessedSize() const { return _inSizeProcessed; }

#endif
         
         CDecoder();
         virtual ~CDecoder();
      };

      CDecoder::CDecoder(): _inBuf(0), _outBuf(0), _propsWereSet(false), _outSizeDefined(false),
         _inBufSize(1 << 22),
         _outBufSize(1 << 22),
         _state(NULL),
         _inBufSizeAllocated(0),
         _outBufSizeAllocated(0),
         _inSizeProcessed(0),
         _outSizeProcessed(0)
      {
         _inSizeProcessed = 0;
         _inPos = _inSize = 0;
      }

      CDecoder::~CDecoder()
      {
         lzham_decompress_deinit(_state);
         MyFree(_inBuf);
         MyFree(_outBuf);
      }

      STDMETHODIMP CDecoder::SetInBufSize(UInt32 , UInt32 size) 
      { 
         _inBufSize = size; 
         return S_OK; 
      }

      STDMETHODIMP CDecoder::SetOutBufSize(UInt32 , UInt32 size) 
      { 
         _outBufSize = size; 
         return S_OK; 
      }

      HRESULT CDecoder::CreateBuffers()
      {
         if (_inBuf == 0 || _inBufSize != _inBufSizeAllocated)
         {
            MyFree(_inBuf);
            _inBuf = (Byte *)MyAlloc(_inBufSize);
            if (_inBuf == 0)
               return E_OUTOFMEMORY;
            _inBufSizeAllocated = _inBufSize;
         }

         if (_outBuf == 0 || _outBufSize != _outBufSizeAllocated)
         {
            MyFree(_outBuf);
            _outBuf = (Byte *)MyAlloc(_outBufSize);
            if (_outBuf == 0)
               return E_OUTOFMEMORY;
            _outBufSizeAllocated = _outBufSize;
         }

         return S_OK;
      }

      STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *prop, UInt32 size)
      {
         CProps *pProps = (CProps*)prop;

         if (size != sizeof(CProps))
            return E_FAIL;

         if (pProps->_ver != LZHAM_PROPS_VER)
            return E_FAIL;

         memcpy(&_props, pProps, sizeof(CProps));
                  
         _propsWereSet = true;
         
         return CreateBuffers();
      }

      HRESULT CDecoder::CreateDecompressor()
      {
         if (!_propsWereSet)
            return E_FAIL;
         
         lzham_decompress_params params;
         memset(&params, 0, sizeof(params));
         params.m_struct_size = sizeof(lzham_decompress_params);
         params.m_decompress_flags = 0;
         params.m_dict_size_log2 = _props._dict_size ? _props._dict_size : 26;
                  
         _state = lzham_decompress_reinit(_state, &params);
         if (!_state)
            return E_FAIL;

         return S_OK;
      }

      HRESULT CDecoder::SetOutStreamSizeResume(const UInt64 *outSize)
      {
         _outSizeDefined = (outSize != NULL);
         if (_outSizeDefined)
            _outSize = *outSize;
         _outSizeProcessed = 0;

         RINOK(CreateDecompressor());

         return S_OK;
      }

      STDMETHODIMP CDecoder::SetOutStreamSize(const UInt64 *outSize)
      {
         _inSizeProcessed = 0;
         _inPos = _inSize = 0;
         RINOK(SetOutStreamSizeResume(outSize));
         return S_OK;
      }

      HRESULT CDecoder::CodeSpec(ISequentialInStream *inStream, ISequentialOutStream *outStream, ICompressProgressInfo *progress)
      {
         if (_inBuf == 0 || !_propsWereSet)
            return S_FALSE;

         if (!_state)
         {
            if (CreateDecompressor() != S_OK)
               return E_FAIL;
         }

         UInt64 startInProgress = _inSizeProcessed;
         
         for (;;)
         {
            bool eofFlag = false;
            if (_inPos == _inSize)
            {
               _inPos = _inSize = 0;
               RINOK(inStream->Read(_inBuf, _inBufSizeAllocated, &_inSize));
               if (!_inSize)
                  eofFlag = true;
            }

            lzham_uint8 *pIn_bytes = _inBuf + _inPos;
            size_t num_in_bytes = _inSize - _inPos;
            lzham_uint8* pOut_bytes = _outBuf;
            size_t out_num_bytes = _outBufSize;
            if (_outSizeDefined)
            {
               UInt64 out_remaining = _outSize - _outSizeProcessed;
               if (out_num_bytes > out_remaining)
                  out_num_bytes = static_cast<size_t>(out_remaining);
            }
            
            lzham_decompress_status_t status = lzham_decompress(_state, pIn_bytes, &num_in_bytes, pOut_bytes, &out_num_bytes, eofFlag);
            
            if (num_in_bytes)
            {
               _inPos += (UInt32)num_in_bytes;
               _inSizeProcessed += (UInt32)num_in_bytes;
            }
                        
            if (out_num_bytes)
            {
               _outSizeProcessed += out_num_bytes;

               RINOK(WriteStream(outStream, _outBuf, out_num_bytes));
            }
            
            if (status >= LZHAM_DECOMP_STATUS_FIRST_FAILURE_CODE)
               return S_FALSE;

            if (status == LZHAM_DECOMP_STATUS_SUCCESS)
               break;
                        
            UInt64 inSize = _inSizeProcessed - startInProgress;
            if (progress)
            {
               RINOK(progress->SetRatioInfo(&inSize, &_outSizeProcessed));
            }
         }

         return S_OK;
      }

      STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
         const UInt64 * inSize, const UInt64 *outSize, ICompressProgressInfo *progress)
      {
         if (_inBuf == 0)
            return E_INVALIDARG;
         SetOutStreamSize(outSize);
         return CodeSpec(inStream, outStream, progress);
      }
      
#ifndef NO_READ_FROM_CODER
      STDMETHODIMP CDecoder::SetInStream(ISequentialInStream *inStream) 
      { 
         _inStream = inStream; 
         return S_OK; 
      }

      STDMETHODIMP CDecoder::ReleaseInStream() 
      { 
         _inStream.Release(); 
         return S_OK; 
      }

      STDMETHODIMP CDecoder::Read(void *data, UInt32 size, UInt32 *processedSize)
      {
         if (_inBuf == 0 || !_propsWereSet)
            return S_FALSE;

         if (!_state)
         {
            if (CreateDecompressor() != S_OK)
               return E_FAIL;
         }

         if (processedSize)
            *processedSize = 0;

         while (size != 0)
         {
            bool eofFlag = false;
            if (_inPos == _inSize)
            {
               _inPos = _inSize = 0;
               RINOK(_inStream->Read(_inBuf, _inBufSizeAllocated, &_inSize));
               if (!_inSize)
                  eofFlag = true;
            }

            lzham_uint8 *pIn_bytes = _inBuf + _inPos;
            size_t num_in_bytes = _inSize - _inPos;
            lzham_uint8* pOut_bytes = (lzham_uint8*)data;
            size_t out_num_bytes = size;

            lzham_decompress_status_t status = lzham_decompress(_state, pIn_bytes, &num_in_bytes, pOut_bytes, &out_num_bytes, eofFlag);

            if (num_in_bytes)
            {
               _inPos += (UInt32)num_in_bytes;
               _inSizeProcessed += num_in_bytes;
            }

            if (out_num_bytes)
            {
               _outSizeProcessed += out_num_bytes;
               size -= (UInt32)out_num_bytes;
               if (processedSize)
                  *processedSize += (UInt32)out_num_bytes;
            }

            if (status >= LZHAM_DECOMP_STATUS_FIRST_FAILURE_CODE)
               return S_FALSE;

            if (status == LZHAM_DECOMP_STATUS_SUCCESS)
               break;
         }

         return S_OK;
      }

      HRESULT CDecoder::CodeResume(ISequentialOutStream *outStream, const UInt64 *outSize, ICompressProgressInfo *progress)
      {
         RINOK(SetOutStreamSizeResume(outSize));
         return CodeSpec(_inStream, outStream, progress);
      }
#endif

   } // namespace NLzham
} // namespace NCompress

static void *CreateCodec() 
{ 
   return (void *)(ICompressCoder *)(new NCompress::NLzham::CDecoder); 
}

#ifndef EXTRACT_ONLY

namespace NCompress
{
   namespace NLzham
   {
      class CEncoder:
         public ICompressCoder,
         public ICompressSetCoderProperties,
         public ICompressWriteCoderProperties,
         public CMyUnknownImp
      {
         lzham_compress_state_ptr _state;
         CProps _props;
         bool _dictSizeSet;
         int _num_threads;
         
         Byte *_inBuf;
         Byte *_outBuf;
         UInt32 _inPos;
         UInt32 _inSize;

         UInt32 _inBufSizeAllocated;
         UInt32 _outBufSizeAllocated;
         UInt32 _inBufSize;
         UInt32 _outBufSize;

         UInt64 _inSizeProcessed;
         UInt64 _outSizeProcessed;
         
         HRESULT CreateCompressor();
         HRESULT CreateBuffers();

      public:
         MY_UNKNOWN_IMP2(ICompressSetCoderProperties, ICompressWriteCoderProperties)

         STDMETHOD(Code)(ISequentialInStream *inStream, ISequentialOutStream *outStream,
            const UInt64 *inSize, const UInt64 *outSize, ICompressProgressInfo *progress);

         STDMETHOD(SetCoderProperties)(const PROPID *propIDs, const PROPVARIANT *props, UInt32 numProps);

         STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStream);

         CEncoder();
         virtual ~CEncoder();
      };

      CEncoder::CEncoder() :
         _state(NULL),
         _dictSizeSet(false),
         _num_threads(-1),
         _inBuf(NULL),
         _outBuf(NULL),
         _inPos(0),
         _inSize(0),
         _inBufSizeAllocated(0),
         _outBufSizeAllocated(0),
         _inBufSize(1 << 22),
         _outBufSize(1 << 22),
         _inSizeProcessed(0),
         _outSizeProcessed(0)
      {
      }

      CEncoder::~CEncoder()
      {
         lzham_compress_deinit(_state);
         MyFree(_inBuf);
         MyFree(_outBuf);
      }

      STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs,
         const PROPVARIANT *coderProps, UInt32 numProps)
      {
         _props.clear();
         
         for (UInt32 i = 0; i < numProps; i++)
         {
            const PROPVARIANT &prop = coderProps[i];
            PROPID propID = propIDs[i];
            switch (propID)
            {
               //case NCoderPropID::kEndMarker:
               //   if (prop.vt != VT_BOOL) return E_INVALIDARG; props.writeEndMark = (prop.boolVal == VARIANT_TRUE); break;
               case NCoderPropID::kAlgorithm:
               {
                  if (prop.vt != VT_UI4)
                     return E_INVALIDARG;

                  bool val = (UInt32)prop.ulVal != 0;

                  if (prop.boolVal)
                     _props._flags |= LZHAM_COMP_FLAG_DETERMINISTIC_PARSING;
                  else
                     _props._flags &= ~LZHAM_COMP_FLAG_DETERMINISTIC_PARSING;

#if LZHAMCODEC_DEBUG_OUTPUT                  
                  printf("Algorithm: %u\n", prop.ulVal);
#endif

                  break;
               }
               case NCoderPropID::kNumThreads:
               {
                  if (prop.vt != VT_UI4) 
                     return E_INVALIDARG; 
                  _num_threads = prop.ulVal; 

#if LZHAMCODEC_DEBUG_OUTPUT                  
                  printf("Num threads: %u\n", _num_threads);
#endif
                  break;
               }
               case NCoderPropID::kDictionarySize:
               {
                  if (prop.vt != VT_UI4)
                     return E_INVALIDARG;
                  lzham_uint32 bits = 15;
                  while ((1U << bits) < prop.ulVal)
                     bits++;
#if LZHAM_64BIT_POINTERS
                  if (bits > LZHAM_MAX_DICT_SIZE_LOG2_X64)
#else
                  if (bits > LZHAM_MAX_DICT_SIZE_LOG2_X86)
#endif
                  {
                     return E_INVALIDARG;
                  }

                  _props._dict_size = bits; 
                  
#if LZHAMCODEC_DEBUG_OUTPUT                  
                  printf("Dict size: %u\n", bits);
#endif

                  break;
               }
               case NCoderPropID::kLevel: 
               {
                  if (prop.vt != VT_UI4)
                     return E_INVALIDARG;
                                                         
                  switch (prop.ulVal)
                  {
                     case 0:
                        _props._level = 0; if (!_props._dict_size) _props._dict_size = 18;
                        break;
                     case 1:
                        _props._level = 0; if (!_props._dict_size) _props._dict_size = 20;
                        break;
                     case 2:
                        _props._level = 1; if (!_props._dict_size) _props._dict_size = 21;
                        break;
                     case 3:
                        _props._level = 2; if (!_props._dict_size) _props._dict_size = 21;
                        break;
                     case 4:
                        _props._level = 2; if (!_props._dict_size) _props._dict_size = 22;
                        break;
                     case 5:
                        _props._level = 3; if (!_props._dict_size) _props._dict_size = 22;
                        break;
                     case 6:
                        _props._level = 3; if (!_props._dict_size) _props._dict_size = 23;
                        break;
                     case 7:
                        _props._level = 4; if (!_props._dict_size) _props._dict_size = 25;
                        break;
                     case 8:
                        _props._level = 4; if (!_props._dict_size) _props._dict_size = 26;
                        break;
                     case 9:
                        _props._level = 4; if (!_props._dict_size) _props._dict_size = 26;
                        _props._flags |= LZHAM_COMP_FLAG_EXTREME_PARSING;
                        break;
                     default: 
                        return E_INVALIDARG;
                  }

#if LZHAMCODEC_DEBUG_OUTPUT                                                      
                  printf("Level: %u\n", prop.ulVal);
#endif
                  break;
               }
               default:
               {
                  //RINOK(SetLzmaProp(propID, prop, props));
                  break;
               }
            }
         }

         return S_OK;
      }

      STDMETHODIMP CEncoder::WriteCoderProperties(ISequentialOutStream *outStream)
      {
         return WriteStream(outStream, &_props, sizeof(_props));
      }

      HRESULT CEncoder::CreateBuffers()
      {
         if (_inBuf == 0 || _inBufSize != _inBufSizeAllocated)
         {
            MyFree(_inBuf);
            _inBuf = (Byte *)MyAlloc(_inBufSize);
            if (_inBuf == 0)
               return E_OUTOFMEMORY;
            _inBufSizeAllocated = _inBufSize;
         }

         if (_outBuf == 0 || _outBufSize != _outBufSizeAllocated)
         {
            MyFree(_outBuf);
            _outBuf = (Byte *)MyAlloc(_outBufSize);
            if (_outBuf == 0)
               return E_OUTOFMEMORY;
            _outBufSizeAllocated = _outBufSize;
         }

         return S_OK;
      }

      HRESULT CEncoder::CreateCompressor()
      {
         if (_state)
            lzham_compress_deinit(_state);

         lzham_compress_params params;
         memset(&params, 0, sizeof(params));
         params.m_struct_size = sizeof(lzham_compress_params);

#if 0
         SYSTEM_INFO system_info;
         GetSystemInfo(&system_info);

         if (_num_threads < 0)
         {
            if (system_info.dwNumberOfProcessors > 1)
               params.m_max_helper_threads = system_info.dwNumberOfProcessors - 1;
         }
         else if (_num_threads > 1)
         {
            params.m_max_helper_threads = _num_threads - 1;
         }

         if (system_info.dwNumberOfProcessors > 1)
         {
            if (params.m_max_helper_threads > ((int)system_info.dwNumberOfProcessors - 1))
               params.m_max_helper_threads = system_info.dwNumberOfProcessors - 1;
         }
#else
		UInt32 numCPUs = 1;
		#ifndef _7ZIP_ST
		numCPUs = NWindows::NSystem::GetNumberOfProcessors();
		#endif
         if (_num_threads < 0)
         {
            if (numCPUs > 1)
               params.m_max_helper_threads = numCPUs - 1;
         }
         else if (_num_threads > 1)
         {
            params.m_max_helper_threads = _num_threads - 1;
         }

         if (numCPUs > 1)
         {
            if (params.m_max_helper_threads > ((int)numCPUs - 1))
               params.m_max_helper_threads = numCPUs - 1;
         }

#endif

         if (params.m_max_helper_threads > LZHAM_MAX_HELPER_THREADS)
            params.m_max_helper_threads = LZHAM_MAX_HELPER_THREADS;

         params.m_dict_size_log2 = _props._dict_size ? _props._dict_size : 26;

         if (params.m_dict_size_log2 < LZHAM_MIN_DICT_SIZE_LOG2)
            params.m_dict_size_log2 = LZHAM_MIN_DICT_SIZE_LOG2;
         else 
         {
#if LZHAM_64BIT_POINTERS
            if (params.m_dict_size_log2 > LZHAM_MAX_DICT_SIZE_LOG2_X64)
               params.m_dict_size_log2 = LZHAM_MAX_DICT_SIZE_LOG2_X64;
#else
            if (params.m_dict_size_log2 > LZHAM_MAX_DICT_SIZE_LOG2_X86)
               params.m_dict_size_log2 = LZHAM_MAX_DICT_SIZE_LOG2_X86;
#endif
         }

         params.m_compress_flags = (lzham_compress_flags)_props._flags;

         params.m_level = (lzham_compress_level)_props._level;

#if LZHAMCODEC_DEBUG_OUTPUT
         printf("lzham_compress_params:\nmax_helper_threads: %u, dict_size_log2: %u, level: %u, deterministic_parsing: %u, extreme_parsing: %u\n", 
            params.m_max_helper_threads, params.m_dict_size_log2, params.m_level, (_props._flags & LZHAM_COMP_FLAG_DETERMINISTIC_PARSING) != 0, (_props._flags & LZHAM_COMP_FLAG_EXTREME_PARSING) != 0);
#endif

         _state = lzham_compress_init(&params);
         if (!_state)
            return S_FALSE;

         return S_OK;
      }

      STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream, ISequentialOutStream *outStream,
         const UInt64 * /* inSize */, const UInt64 * /* outSize */, ICompressProgressInfo *progress)
      {
         RINOK(CreateCompressor());
         
         RINOK(CreateBuffers());

         UInt64 startInProgress = _inSizeProcessed;
         UInt64 startOutProgress = _outSizeProcessed;

         for (;;)
         {
            bool eofFlag = false;
            if (_inPos == _inSize)
            {
               _inPos = _inSize = 0;
               RINOK(inStream->Read(_inBuf, _inBufSizeAllocated, &_inSize));
               if (!_inSize)
                  eofFlag = true;
            }

            lzham_uint8 *pIn_bytes = _inBuf + _inPos;
            size_t num_in_bytes = _inSize - _inPos;
            lzham_uint8* pOut_bytes = _outBuf;
            size_t out_num_bytes = _outBufSize;
            
            lzham_compress_status_t status = lzham_compress(_state, pIn_bytes, &num_in_bytes, pOut_bytes, &out_num_bytes, eofFlag);

            if (num_in_bytes)
            {
               _inPos += (UInt32)num_in_bytes;
               _inSizeProcessed += (UInt32)num_in_bytes;
            }

            if (out_num_bytes)
            {
               _outSizeProcessed += out_num_bytes;

               RINOK(WriteStream(outStream, _outBuf, out_num_bytes));
            }

            if (status >= LZHAM_COMP_STATUS_FIRST_FAILURE_CODE)
               return S_FALSE;

            if (status == LZHAM_COMP_STATUS_SUCCESS)
               break;

            UInt64 inSize = _inSizeProcessed - startInProgress;
            UInt64 outSize = _outSizeProcessed - startOutProgress;
            if (progress)
            {
               RINOK(progress->SetRatioInfo(&inSize, &outSize));
            }
         }

         return S_OK;
      }
   }
}

static void *CreateCodecOut() 
{ 
   return (void *)(ICompressCoder *)(new NCompress::NLzham::CEncoder);  
}
#else
#define CreateCodecOut 0
#endif

static CCodecInfo g_CodecsInfo[1] =
{ 
   CreateCodec, 
   CreateCodecOut, 
   0x4F71001, 
   "LZHAM", 
   1, 
   false 
};

REGISTER_CODECS(LZHAM)
LZHAM - Lossless Data Compression Codec
=============

<p>Copyright (c) 2009-2015 Richard Geldreich, Jr. - richgel99@gmail.com - MIT License</p>

<p>Note: This is the unstable/experimental LZHAM repo, currently at v1.1. The stable repo (v1.0) is here: https://github.com/richgel999/lzham_codec</p>

<p>LZHAM is a lossless data compression codec written in C/C++ (specifically C++03), with a compression ratio similar to LZMA but with 1.5x-8x faster decompression speed. It officially supports Linux x86/x64, Windows x86/x64, 
OSX, and iOS, with Android support on the way.</p>

<p>Some slightly out of date API documentation is here (I'll be migrating this to github): https://code.google.com/p/lzham/wiki/API_Docs</p>

<h3>Introduction</h3>

<p>LZHAM is a lossless (LZ based) data compression codec optimized for particularly fast decompression at very high compression ratios with a zlib compatible API. 
It's been developed over a period of 3 years and alpha versions have already shipped in many products. (The alpha is here: https://code.google.com/p/lzham/)
LZHAM's decompressor is slower than zlib's, but generally much faster than LZMA's, with a compression ratio that is typically within a few percent of LZMA's and sometimes better.</p>

<p>LZHAM's compressor is intended for offline use, but it is tested alongside the decompressor on mobile devices and is usable on the faster settings.</p>

<p>LZHAM's decompressor currently has a higher cost to initialize than LZMA, so the threshold where LZHAM is typically faster vs. LZMA decompression is between 1000-13,000 of 
*compressed* output bytes, depending on the platform. It is not a good small block compressor: it likes large (10KB-15KB minimum) blocks.</p>

<p>LZHAM has simple support for patch files (delta compression), but this is a side benefit of its design, not its primary use case. Internally it supports LZ matches up 
to ~64KB and very large dictionaries (up to .5 GB).</p>

<p>LZHAM may be valuable to you if you compress data offline and distribute it to many customers, care about read/download times, and decompression speed/low CPU+power use 
are important to you.</p>

<p>I've been profiling LZHAM vs. LZMA and publishing the results on my blog: http://richg42.blogspot.com</p>

<p>Some independent benchmarks of the previous alpha versions: http://heartofcomp.altervista.org/MOC/MOCADE.htm, http://mattmahoney.net/dc/text.html</p>

<p>LZHAM has been integrated into the 7zip archiver (command line and GUI) as a custom codec plugin: http://richg42.blogspot.com/2015/11/lzham-custom-codec-plugin-for-7-zip.html</p>

<h3>10GB Benchmark Results</h3>

Results with [7zip-LZHAM 9.38 32-bit](http://richg42.blogspot.com/2015/02/7zip-938-custom-codec-plugin-for-lzham.html) (64MB dictionary) on [Matt Mahoney's 10GB benchmark](http://mattmahoney.net/dc/10gb.html):

```
LZHAM (-mx=8): 3,577,047,629 Archive Test Time: 70.652 secs
LZHAM (-mx=9): 3,573,782,721 Archive Test Time: 71.292 secs
LZMA  (-mx=9): 3,560,052,414 Archive Test Time: 223.050 secs
7z .ZIP      : 4,681,291,655 Archive Test Time: 73.304 secs (unzip v6 x64 test time: 61.074 secs)
```

<h3>Most Common Question: So how does it compare to other libs like LZ4?</h3>

There is no single compression algorithm that perfectly suites all use cases and practical constraints. LZ4 and LZHAM are tools which lie at completely opposite ends of the spectrum:

* LZ4: A symmetrical codec with very fast compression and decompression but very low ratios. Its compression ratio is typically less than even zlib's (which uses a 21+ year old algorithm). 
LZ4 does a good job of trading off a large amount of compression ratio for very fast overall throughput.
Usage example: Reading LZMA/LZHAM/etc. compressed data from the network and decompressing it, then caching this data locally on disk using LZ4 to reduce disk usage and decrease future loading times.

* LZHAM: A very asymmetrical codec with slow compression speed, but with a very competitive (LZMA-like) compression ratio and reasonably fast decompression speeds (slower than zlib, but faster than LZMA).
LZHAM trades off a lot of compression throughput for very high ratios and higher decompression throughput relative to other codecs in its ratio class (which is LZMA, which runs circles around LZ4's ratio).
Usage example: Compress your product's data once on a build server, distribute it to end users over a slow media like the internet, then decompress it on the end user's device.

<h3>How Much Memory Does It Need?</h3>

For decompression it's easy to compute:
* Buffered mode: decomp_mem = dict_size + ~34KB for work tables
* Unbuffered mode: decomp_mem = ~34KB

I'll be honest here, the compressor is currently an angry beast when it comes to memory. The amount needed depends mostly on the compression level and dict. size. It's *approximately* (max_probes=128 at level -m4):
comp_mem = min(512 * 1024, dict_size / 8) * max_probes * 6 + dict_size * 9 + 22020096

Compression mem usage examples from Windows lzhamtest_x64 (note the equation is pretty off for small dictionary sizes):
* 32KB: 11MB
* 128KB: 21MB
* 512KB: 63MB
* 1MB: 118MB
* 8MB: 478MB
* 64MB: 982MB
* 128MB: 1558MB
* 256MB: 2710MB
* 512MB: 5014MB

<h3>Compressed Bitstream Compatibility</h3>

<p>v1.0's bitstream format is now locked in place, so any future v1.x releases will be backwards/forward compatible with compressed files 
written with v1.0. The only thing that could change this are critical bugfixes.</p>

<p>Note LZHAM v1.x bitstreams are NOT backwards compatible with any of the previous alpha versions on Google Code.</p>

<h3>Platforms/Compiler Support</h3>

LZHAM currently officially supports x86/x64 Linux, iOS, OSX, FreeBSD, and Windows x86/x64. At one time the codec compiled and ran fine on Xbox 360 (PPC, big endian). Android support is coming next.
It should be easy to retarget by modifying the macros in lzham_core.h.</p>

<p>LZHAM has optional support for multithreaded compression. It supports gcc built-ins or MSVC intrinsics for atomic ops. For threading, it supports OSX 
specific Pthreads, generic Pthreads, or Windows API's.</p>

<p>For compilers, I've tested with gcc, clang, and MSVC 2008, 2010, and 2013. In previous alphas I also compiled with TDM-GCC x64.</p>

<h3>API</h3>

LZHAM supports streaming or memory to memory compression/decompression. See include/lzham.h. LZHAM can be linked statically or dynamically, just study the 
headers and the lzhamtest project. 
On Linux/OSX, it's only been tested with static linking so far.

LZHAM also supports a usable subset of the zlib API with extensions, either include/zlib.h or #define LZHAM_DEFINE_ZLIB_API and use include/lzham.h.

<h3>Usage Tips</h3>

* Always try to use the smallest dictionary size that makes sense for the file or block you are compressing, i.e. don't use a 128MB dictionary for a 15KB file. The codec
doesn't automatically choose for you because in streaming scenarios it has no idea how large the file or block will be.
* The larger the dictionary, the more RAM is required during compression and decompression. I would avoid using more than 8-16MB dictionaries on iOS.
* For faster decompression, prefer "unbuffered" decompression mode vs. buffered decompression (avoids a dictionary alloc and extra memcpy()'s), and disable adler-32 checking. Also, use the built-in LZHAM API's, not the
zlib-style API's for fastest decompression.
* Experiment with the "m_table_update_rate" compression/decompression parameter. This setting trades off a small amount of ratio for faster decompression.
Note the m_table_update_rate decompression parameter MUST match the setting used during compression (same for the dictionary size). It's up to you to store this info somehow.
* Avoid using LZHAM on small *compressed* blocks, where small is 1KB-10KB compressed bytes depending on the platform. LZHAM's decompressor is only faster than LZMA's beyond the small block threshold.
Optimizing LZHAM's decompressor to reduce its startup time relative to LZMA is a high priority.
* For best compression (I've seen up to ~4% better), enable the compressor's "extreme" parser, which is much slower but finds cheaper paths through a much denser parse graph.
Note the extreme parser can greatly slow down on files containing large amounts of repeated data/strings, but it is guaranteed to finish.
* The compressor's m_level parameter can make a big impact on compression speed. Level 0 (LZHAM_COMP_LEVEL_FASTEST) uses a much simpler greedy parser, and the other levels use 
near-optimal parsing with different heuristic settings.
* Check out the compressor/decompressor reinit() API's, which are useful if you'll be compressing or decompressing many times. Using the reinit() API's is a lot cheaper than fully 
initializing/deinitializing the entire codec every time.
* LZHAM's compressor is no speed demon. It's usually slower than LZMA's, sometimes by a wide (~2x slower or so) margin. In "extreme" parsing mode, it can be many times slower. 
This codec was designed with offline compression in mind.
* One significant difference between LZMA and LZHAM is how uncompressible files are handled. LZMA usually expands uncompressible files, and its decompressor can bog down and run extremely 
slowly on uncompressible data. LZHAM internally detects when each 512KB block is uncompressible and stores these blocks as uncompressed bytes instead. 
LZHAM's literal decoding is significantly faster than LZMA's, so the more plain literals in the output stream, the faster LZHAM's decompressor runs vs. LZMA's.
* General advice (applies to LZMA and other codecs too): If you are compressing large amounts of serialized game assets, sort the serialized data by asset type and compress the whole thing as a single large "solid" block of data.
Don't compress each individual asset, this will kill your ratio and have a higher decompression startup cost. If you need random access, consider compressing the assets lumped 
together into groups of a few hundred kilobytes (or whatever) each.
* LZHAM is a raw codec. It doesn't include any sort of preprocessing: EXE rel to abs jump transformation, audio predictors, etc. That's up to you
to do, before compression.

<h3>Codec Test App</h3>

lzhamtest_x86/x64 is a simple command line test program that uses the LZHAM codec to compress/decompress single files. 
lzhamtest is not intended as a file archiver or end user tool, it's just a simple testbed.

-- Usage examples:

- Compress single file "source_filename" to "compressed_filename":
	lzhamtest_x64 c source_filename compressed_filename
	
- Decompress single file "compressed_filename" to "decompressed_filename":
    lzhamtest_x64 d compressed_filename decompressed_filename

- Compress single file "source_filename" to "compressed_filename", then verify the compressed file decompresses properly to the source file:
	lzhamtest_x64 -v c source_filename compressed_filename

- Recursively compress all files under specified directory and verify that each file decompresses properly:
	lzhamtest_x64 -v a c:\source_path
	
-- Options	
	
- Set dictionary size used during compressed to 1MB (2^20):
	lzhamtest_x64 -d20 c source_filename compressed_filename
	
Valid dictionary sizes are [15,26] for x86, and [15,29] for x64. (See LZHAM_MIN_DICT_SIZE_LOG2, etc. defines in include/lzham.h.)
The x86 version defaults to 64MB (26), and the x64 version defaults to 256MB (28). I wouldn't recommend setting the dictionary size to 
512MB unless your machine has more than 4GB of physical memory.

- Set compression level to fastest:
	lzhamtest_x64 -m0 c source_filename compressed_filename
	
- Set compression level to uber (the default):
	lzhamtest_x64 -m4 c source_filename compressed_filename
	
- For best possible compression, use -d29 to enable the largest dictionary size (512MB) and the -x option which enables more rigorous (but ~4X slower!) parsing:
	lzhamtest_x64 -d29 -x -m4 c source_filename compressed_filename

See lzhamtest_x86/x64.exe's help text for more command line parameters.

<h3>Compiling LZHAM</h3>

- Linux: Use "cmake ." then "make". The cmake script only supports Linux at the moment. (Sorry, working on build systems is a drag.)
- OSX/iOS: Use the included XCode project. (NOTE: I haven't merged this over yet. It's coming!)
- Windows: Use the included VS 2010 project

IMPORTANT: With clang or gcc compile LZHAM with "No strict aliasing" ENABLED: -fno-strict-aliasing

I DO NOT test or develop the codec with strict aliasing:
* https://lkml.org/lkml/2003/2/26/158
* http://stackoverflow.com/questions/2958633/gcc-strict-aliasing-and-horror-stories

It might work fine, I don't know yet. This is usually not a problem with MSVC, which defaults to strict aliasing being off.

<h3>ANSI C/C++</h3>

LZHAM supports compiling as plain vanilla ANSI C/C++. To see how the codec configures itself check out lzham_core.h and search for "LZHAM_ANSI_CPLUSPLUS". 
All platform specific stuff (unaligned loads, threading, atomic ops, etc.) should be disabled when this macro is defined. Note, the compressor doesn't use threads 
or atomic operations when built this way so it's going to be pretty slow. (The compressor was built from the ground up to be threaded.)

<h3>Known Problems</h3>

<p>LZHAM's decompressor is like a drag racer that needs time to get up to speed. LZHAM is not intended or optimized to be used on "small" blocks of data (less 
than ~10,000 bytes of *compressed* data on desktops, or around 1,000-5,000 on iOS). If your usage case involves calling the codec over and over with tiny blocks 
then LZMA, LZ4, Deflate, etc. are probably better choices.</p>

<p>The decompressor still takes too long to init vs. LZMA. On iOS the cost is not that bad, but on desktop the cost is high. I have reduced the startup cost vs. the 
alpha but there's still work to do.</p>

<p>The compressor is slower than I would like, and doesn't scale as well as it could. I added a reinit() method to make it initialize faster, but it's not a speed demon. 
My focus has been on ratio and decompression speed.</p>

<p>I use tabs=3 spaces, but I think some actual tabs got in the code. I need to run the sources through ClangFormat or whatever.</p>

<h3>Special Thanks</h3>

<p>Thanks to everyone at the http://encode.ru forums. I read these forums as a lurker before working on LZHAM, and I studied every LZ related 
post I could get my hands on. Especially anything related to LZ optimal parsing, which still seems like a black art. LZHAM was my way of 
learning how to implement optimal parsing (and you can see this if you study the progress I made in the early alphas on Google Code).</p>

<p>Also, thanks to Igor Pavlov, the original creator of LZMA and 7zip, for advancing the start of the art in LZ compression.</p>

TARGET_FLAGS=$(CC_SHARED) -DRegisterCodec=DllRegisterCodec -Iinclude -Ilzhamdecomp -Ilzhamcomp -I../../../../

include ../../../../makefile.crc32
include ../../../../makefile.machine

LOCAL_LINK=$(LINK_SHARED)
LIBS=$(LOCAL_LIBS)

include ../../../../makefile.glb


# WARNING : automatically generated by utils/generate.py

PROG=../../../../bin/Codecs/Lzham.so

all: $(PCH_NAME) $(PROG)

LOCAL_FLAGS=$(TARGET_FLAGS) \
  -DEXTERNAL_CODECS \
  -D_FILE_OFFSET_BITS=64 \
  -D_LARGEFILE_SOURCE \
  -D_REENTRANT \
  -DENV_UNIX \
  -DBREAK_HANDLER \
  -DUNICODE \
  -D_UNICODE \
  -DUNIX_USE_WIN_FILE \

SRCS=\
  ../../../../CPP/7zip/Common/StreamUtils.cpp \
  ../../../../CPP/7zip/Compress/CodecExports.cpp \
  ../../../../CPP/7zip/Compress/DllExportsCompress.cpp \
  ../../../../CPP/7zip/Compress/Lzham/LzhamRegister.cpp \
  ../../../../CPP/Common/MyWindows.cpp \
  ../../../../CPP/Windows/System.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzbase.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp_internal.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp_state.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_match_accel.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_pthreads_threading.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_assert.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_checksum.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_huffman_codes.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_lzdecomp.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_lzdecompbase.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_mem.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_platform.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_prefix_coding.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_symbol_codec.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_timer.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_vector.cpp \
  ../../../../CPP/7zip/Compress/Lzham/lzhamlib/lzham_lib.cpp \

SRCS_C=\
  ../../../../C/Alloc.c \

StdAfx.h.gch : ../../../myWindows/StdAfx.h
	rm -f StdAfx.h.gch
	$(CXX) $(CXXFLAGS) ../../../myWindows/StdAfx.h -o StdAfx.h.gch
Alloc.o : ../../../../C/Alloc.c
	$(CC) $(CFLAGS) ../../../../C/Alloc.c
StreamUtils.o : ../../../../CPP/7zip/Common/StreamUtils.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Common/StreamUtils.cpp
CodecExports.o : ../../../../CPP/7zip/Compress/CodecExports.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/CodecExports.cpp
DllExportsCompress.o : ../../../../CPP/7zip/Compress/DllExportsCompress.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/DllExportsCompress.cpp
LzhamRegister.o : ../../../../CPP/7zip/Compress/Lzham/LzhamRegister.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/LzhamRegister.cpp
MyWindows.o : ../../../../CPP/Common/MyWindows.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Common/MyWindows.cpp
System.o : ../../../../CPP/Windows/System.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/Windows/System.cpp
lzham_lzbase.o : ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzbase.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzbase.cpp
lzham_lzcomp.o : ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp.cpp
lzham_lzcomp_internal.o : ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp_internal.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp_internal.cpp
lzham_lzcomp_state.o : ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp_state.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_lzcomp_state.cpp
lzham_match_accel.o : ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_match_accel.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_match_accel.cpp
lzham_pthreads_threading.o : ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_pthreads_threading.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamcomp/lzham_pthreads_threading.cpp
lzham_assert.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_assert.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_assert.cpp
lzham_checksum.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_checksum.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_checksum.cpp
lzham_huffman_codes.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_huffman_codes.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_huffman_codes.cpp
lzham_lzdecomp.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_lzdecomp.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_lzdecomp.cpp
lzham_lzdecompbase.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_lzdecompbase.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_lzdecompbase.cpp
lzham_mem.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_mem.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_mem.cpp
lzham_platform.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_platform.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_platform.cpp
lzham_prefix_coding.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_prefix_coding.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_prefix_coding.cpp
lzham_symbol_codec.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_symbol_codec.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_symbol_codec.cpp
lzham_timer.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_timer.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_timer.cpp
lzham_vector.o : ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_vector.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamdecomp/lzham_vector.cpp
lzham_lib.o : ../../../../CPP/7zip/Compress/Lzham/lzhamlib/lzham_lib.cpp
	$(CXX) $(CXXFLAGS) ../../../../CPP/7zip/Compress/Lzham/lzhamlib/lzham_lib.cpp

OBJS=\
 Alloc.o \
 StreamUtils.o \
 CodecExports.o \
 DllExportsCompress.o \
 LzhamRegister.o \
 MyWindows.o \
 System.o \
 lzham_lzbase.o \
 lzham_lzcomp.o \
 lzham_lzcomp_internal.o \
 lzham_lzcomp_state.o \
 lzham_match_accel.o \
 lzham_pthreads_threading.o \
 lzham_assert.o \
 lzham_checksum.o \
 lzham_huffman_codes.o \
 lzham_lzdecomp.o \
 lzham_lzdecompbase.o \
 lzham_mem.o \
 lzham_platform.o \
 lzham_prefix_coding.o \
 lzham_symbol_codec.o \
 lzham_timer.o \
 lzham_vector.o \
 lzham_lib.o \

// File: lzham.h - Copyright (c) 2009-2012 Richard Geldreich, Jr. <richgel99@gmail.com>
// LZHAM uses the MIT License. See Copyright Notice and license at the end of this file.
//
// This is the main header file, includable from C or C++ files, which defines all the publically available API's, structs, and types used by the LZHAM codec.
//
// Notes:
// 
// As of LZHAM alpha8, there are now two sets of API's:
// - The first (oldest) API directly exposes all of the codec's functionality. See lzham_compress_init(), lzham_decompress_init(), etc. This API has the lowest overhead
//   and is the most tested.
// - The new API implements the most useful/popular subset of the zlib API, but doesn't expose all of the codec's functionality yet. See the lzham_z* functions. 
//   This functionality is provided because most users of compression libraries are already very familiar with the nuts and bolts of the zlib API.
//   For the most common zlib usage cases LZHAM is an almost drop-in replacement for zlib. To make switching from zlib even easier, you can define the LZHAM_DEFINE_ZLIB_API macro, 
//   which causes this header to #define most zlib symbols to their LZHAM equivalents.
//   Note that LZHAM does not actually implement the deflate/inflate algorithm, so it cannot decompress streams created by standard zlib yet (and of course, zlib cannot decompress
//   streams created by LZHAM). Internally, this API is mostly implemented via the older low-level LZHAM API.

#ifndef __LZHAM_H__
#define __LZHAM_H__

#ifdef _MSC_VER
#pragma once
#endif

#include <stdlib.h>

// Upper byte = major version
// Lower byte = minor version
#define LZHAM_DLL_VERSION 0x1011

#if defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__)
	#define LZHAM_64BIT 1
#endif

#if defined(_MSC_VER)
   #define LZHAM_CDECL __cdecl
#else
   #define LZHAM_CDECL
#endif

#ifdef LZHAM_EXPORTS
   #define LZHAM_DLL_EXPORT __declspec(dllexport)
#else
   #define LZHAM_DLL_EXPORT
#endif

#ifdef __cplusplus
extern "C" {
#endif

   typedef unsigned char   lzham_uint8;
   typedef signed int      lzham_int32;
   typedef unsigned int    lzham_uint32;
   typedef unsigned int    lzham_bool;

   // Returns DLL version (LZHAM_DLL_VERSION).
   LZHAM_DLL_EXPORT lzham_uint32 LZHAM_CDECL lzham_get_version(void);

   // User provided memory allocation

   // Custom allocation function must return pointers with LZHAM_MIN_ALLOC_ALIGNMENT (or better).
   #define LZHAM_MIN_ALLOC_ALIGNMENT sizeof(size_t) * 2

   typedef void*  (LZHAM_CDECL *lzham_realloc_func)(void* p, size_t size, size_t* pActual_size, lzham_bool movable, void* pUser_data);
   typedef size_t (LZHAM_CDECL *lzham_msize_func)(void* p, void* pUser_data);

   // Call this function to force LZHAM to use custom memory malloc(), realloc(), free() and msize functions.
   LZHAM_DLL_EXPORT void LZHAM_CDECL lzham_set_memory_callbacks(lzham_realloc_func pRealloc, lzham_msize_func pMSize, void* pUser_data);

   // lzham_flush_t must map directly to the zlib-style API flush types (LZHAM_Z_NO_FLUSH, etc.)
   typedef enum
   {
      LZHAM_NO_FLUSH = 0,
      LZHAM_SYNC_FLUSH = 2,
      LZHAM_FULL_FLUSH = 3,
      LZHAM_FINISH = 4,
      LZHAM_TABLE_FLUSH = 10
   } lzham_flush_t;

   // Compression (keep in sync with g_num_lzx_position_slots[])
   #define LZHAM_MIN_DICT_SIZE_LOG2 15
   #define LZHAM_MAX_DICT_SIZE_LOG2_X86 26
   #define LZHAM_MAX_DICT_SIZE_LOG2_X64 29

   #define LZHAM_MAX_HELPER_THREADS 64

   typedef enum
   {
      LZHAM_COMP_STATUS_NOT_FINISHED = 0,
      LZHAM_COMP_STATUS_NEEDS_MORE_INPUT,
      LZHAM_COMP_STATUS_HAS_MORE_OUTPUT,

      // All the following enums must indicate failure/success.

      LZHAM_COMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE,
      LZHAM_COMP_STATUS_SUCCESS = LZHAM_COMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE,

      LZHAM_COMP_STATUS_FIRST_FAILURE_CODE,
      LZHAM_COMP_STATUS_FAILED = LZHAM_COMP_STATUS_FIRST_FAILURE_CODE,
      LZHAM_COMP_STATUS_FAILED_INITIALIZING,
      LZHAM_COMP_STATUS_INVALID_PARAMETER,
      LZHAM_COMP_STATUS_OUTPUT_BUF_TOO_SMALL,

      LZHAM_COMP_STATUS_FORCE_DWORD = 0xFFFFFFFF
   } lzham_compress_status_t;

   typedef enum 
   {
      LZHAM_COMP_LEVEL_FASTEST = 0,
      LZHAM_COMP_LEVEL_FASTER,
      LZHAM_COMP_LEVEL_DEFAULT,
      LZHAM_COMP_LEVEL_BETTER,
      LZHAM_COMP_LEVEL_UBER,

      LZHAM_TOTAL_COMP_LEVELS,

      LZHAM_COMP_LEVEL_FORCE_DWORD = 0xFFFFFFFF
   } lzham_compress_level;

   // Streaming compression
   typedef void *lzham_compress_state_ptr;

   typedef enum
   {
      LZHAM_COMP_FLAG_EXTREME_PARSING = 2,         // Improves ratio by allowing the compressor's parse graph to grow "higher" (up to 4 parent nodes per output node), but is much slower.
      LZHAM_COMP_FLAG_DETERMINISTIC_PARSING = 4,   // Guarantees that the compressed output will always be the same given the same input and parameters (no variation between runs due to kernel threading scheduling).

      // If enabled, the compressor is free to use any optimizations which could lower the decompression rate (such
      // as adaptively resetting the Huffman table update rate to maximum frequency, which is costly for the decompressor).
      LZHAM_COMP_FLAG_TRADEOFF_DECOMPRESSION_RATE_FOR_COMP_RATIO = 16,
      
      LZHAM_COMP_FLAG_WRITE_ZLIB_STREAM = 32,
      
      LZHAM_COMP_FLAG_FORCE_SINGLE_THREADED_PARSING = 64,

      LZHAM_COMP_FLAG_USE_LOW_MEMORY_MATCH_FINDER = 128,

   } lzham_compress_flags;
		
	typedef enum 
	{
		LZHAM_INSANELY_SLOW_TABLE_UPDATE_RATE = 1, // 1=insanely slow decompression, here for reference, use 2!
		LZHAM_SLOWEST_TABLE_UPDATE_RATE = 2,
		LZHAM_DEFAULT_TABLE_UPDATE_RATE = 8,
		LZHAM_FASTEST_TABLE_UPDATE_RATE = 20
	} lzham_table_update_rate;

   #define LZHAM_EXTREME_PARSING_MAX_BEST_ARRIVALS_MIN (2)
   
   // LZHAM_EXTREME_PARSING_MAX_BEST_ARRIVALS_MAX can be increased by the user (if you recompile lzham), I've tried up to 64.
   #define LZHAM_EXTREME_PARSING_MAX_BEST_ARRIVALS_MAX (8)

   #define LZHAM_MIN_FAST_BYTES (8)
   #define LZHAM_MAX_FAST_BYTES (258)

	// Compression parameters struct.
	// IMPORTANT: The values of m_dict_size_log2, m_table_update_rate, m_table_max_update_interval, and m_table_update_interval_slow_rate MUST
	// match during compression and decompression. The codec does not verify these values for you, if you don't use the same settings during
	// decompression it will fail (usually with a LZHAM_DECOMP_STATUS_FAILED_BAD_CODE error).
	// The seed buffer's contents and size must match the seed buffer used during decompression.
   typedef struct
   {
      lzham_uint32 m_struct_size;            // set to sizeof(lzham_compress_params)
      lzham_uint32 m_dict_size_log2;         // set to the log2(dictionary_size), must range between [LZHAM_MIN_DICT_SIZE_LOG2, LZHAM_MAX_DICT_SIZE_LOG2_X86] for x86 LZHAM_MAX_DICT_SIZE_LOG2_X64 for x64
      lzham_compress_level m_level;          // set to LZHAM_COMP_LEVEL_FASTEST, etc.
		lzham_uint32 m_table_update_rate;		// Controls tradeoff between ratio and decompression throughput. 0=default, or [1,LZHAM_MAX_TABLE_UPDATE_RATE], higher=faster but lower ratio.
      lzham_int32 m_max_helper_threads;      // max # of additional "helper" threads to create, must range between [-1,LZHAM_MAX_HELPER_THREADS], where -1=max practical
      lzham_uint32 m_compress_flags;         // optional compression flags (see lzham_compress_flags enum)
      lzham_uint32 m_num_seed_bytes;         // for delta compression (optional) - number of seed bytes pointed to by m_pSeed_bytes
      const void *m_pSeed_bytes;             // for delta compression (optional) - pointer to seed bytes buffer, must be at least m_num_seed_bytes long
						      
      // Advanced settings - set to 0 if you don't care.
		// m_table_max_update_interval/m_table_update_interval_slow_rate override m_table_update_rate and allow finer control over the table update settings.
		// If either are non-zero they will override whatever m_table_update_rate is set to. Just leave them 0 unless you are specifically customizing them for your data.
						
		// def=0, typical range 12-128 (LZHAM_DEFAULT_TABLE_UPDATE_RATE=64), controls the max interval between table updates, higher=longer max interval (faster decode/lower ratio). Was 16 in prev. releases.
		lzham_uint32 m_table_max_update_interval;
		// def=0, 32 or higher (LZHAM_DEFAULT_TABLE_UPDATE_RATE=64), scaled by 32, controls the slowing of the update update freq, higher=more rapid slowing (faster decode/lower ratio). Was 40 in prev. releases.
		lzham_uint32 m_table_update_interval_slow_rate;

      // If non-zero, must range between LZHAM_EXTREME_PARSING_MAX_BEST_ARRIVALS_MIN and LZHAM_EXTREME_PARSING_MAX_BEST_ARRIVALS_MAX.
      // Field added in version 0x1011
      lzham_uint32 m_extreme_parsing_max_best_arrivals;

      // If non-zero, must range between LZHAM_MIN_FAST_BYTES-LZHAM_MAX_FAST_BYTES.
      // If this is 0, the compressor will either use a fast_bytes setting controlled by m_level, or a for extreme parsing a fixed setting of LZHAM_EXTREME_PARSING_FAST_BYTES (96).
      // Field added in version 0x1011
      lzham_uint32 m_fast_bytes;

   } lzham_compress_params;
   
   // Initializes a compressor. Returns a pointer to the compressor's internal state, or NULL on failure.
   // pParams cannot be NULL. Be sure to initialize the pParams->m_struct_size member to sizeof(lzham_compress_params) (along with the other members to reasonable values) before calling this function.
   // TODO: With large dictionaries this function could take a while (due to memory allocation). I need to add a reinit() API for compression (decompression already has one).
   LZHAM_DLL_EXPORT lzham_compress_state_ptr LZHAM_CDECL lzham_compress_init(const lzham_compress_params *pParams);

   LZHAM_DLL_EXPORT lzham_compress_state_ptr LZHAM_CDECL lzham_compress_reinit(lzham_compress_state_ptr pState);

   // Deinitializes a compressor, releasing all allocated memory.
   // returns adler32 of source data (valid only on success).
   LZHAM_DLL_EXPORT lzham_uint32 LZHAM_CDECL lzham_compress_deinit(lzham_compress_state_ptr pState);

   // Compresses an arbitrarily sized block of data, writing as much available compressed data as possible to the output buffer. 
   // This method may be called as many times as needed, but for best perf. try not to call it with tiny buffers.
   // pState - Pointer to internal compression state, created by lzham_compress_init.
   // pIn_buf, pIn_buf_size - Pointer to input data buffer, and pointer to a size_t containing the number of bytes available in this buffer. 
   //                         On return, *pIn_buf_size will be set to the number of bytes read from the buffer.
   // pOut_buf, pOut_buf_size - Pointer to the output data buffer, and a pointer to a size_t containing the max number of bytes that can be written to this buffer.
   //                         On return, *pOut_buf_size will be set to the number of bytes written to this buffer.
   // no_more_input_bytes_flag - Set to true to indicate that no more input bytes are available to compress (EOF). Once you call this function with this param set to true, it must stay set to true in all future calls.
   //
   // Normal return status codes:
   //    LZHAM_COMP_STATUS_NOT_FINISHED - Compression can continue, but the compressor needs more input, or it needs more room in the output buffer.
   //    LZHAM_COMP_STATUS_NEEDS_MORE_INPUT - Compression can contintue, but the compressor has no more output, and has no input but we're not at EOF. Supply more input to continue.
   // Success/failure return status codes:
   //    LZHAM_COMP_STATUS_SUCCESS - Compression has completed successfully.
   //    LZHAM_COMP_STATUS_FAILED, LZHAM_COMP_STATUS_FAILED_INITIALIZING, LZHAM_COMP_STATUS_INVALID_PARAMETER - Something went wrong.
   LZHAM_DLL_EXPORT lzham_compress_status_t LZHAM_CDECL lzham_compress(
      lzham_compress_state_ptr pState,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size,
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_bool no_more_input_bytes_flag);

   LZHAM_DLL_EXPORT lzham_compress_status_t LZHAM_CDECL lzham_compress2(
      lzham_compress_state_ptr pState,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size,
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_flush_t flush_type);

   // Single function call compression interface.
   // Same return codes as lzham_compress, except this function can also return LZHAM_COMP_STATUS_OUTPUT_BUF_TOO_SMALL.
   LZHAM_DLL_EXPORT lzham_compress_status_t LZHAM_CDECL lzham_compress_memory(
      const lzham_compress_params *pParams,
      lzham_uint8* pDst_buf,
      size_t *pDst_len,
      const lzham_uint8* pSrc_buf,
      size_t src_len,
      lzham_uint32 *pAdler32);

   // Decompression
   typedef enum
   {
      // LZHAM_DECOMP_STATUS_NOT_FINISHED indicates that the decompressor is flushing its internal buffer to the caller's output buffer. 
      // There may be more bytes available to decompress on the next call, but there is no guarantee.
      LZHAM_DECOMP_STATUS_NOT_FINISHED = 0,

      // LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT indicates that the decompressor is trying to flush its internal buffer to the caller's output buffer, 
      // but the caller hasn't provided any space to copy this data to the caller's output buffer. Call the lzham_decompress() again with a non-empty sized output buffer.
      LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT,

      // LZHAM_DECOMP_STATUS_NEEDS_MORE_INPUT indicates that the decompressor has consumed all input bytes, has not encountered an "end of stream" code, 
      // and the caller hasn't set no_more_input_bytes_flag to true, so it's expecting more input to proceed.
      LZHAM_DECOMP_STATUS_NEEDS_MORE_INPUT,

      // All the following enums always (and MUST) indicate failure/success.
      LZHAM_DECOMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE,

      // LZHAM_DECOMP_STATUS_SUCCESS indicates decompression has successfully completed.
      LZHAM_DECOMP_STATUS_SUCCESS = LZHAM_DECOMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE,

      // The remaining status codes indicate a failure of some sort. Most failures are unrecoverable. TODO: Document which codes are recoverable.
      LZHAM_DECOMP_STATUS_FIRST_FAILURE_CODE,

      LZHAM_DECOMP_STATUS_FAILED_INITIALIZING = LZHAM_DECOMP_STATUS_FIRST_FAILURE_CODE,
      LZHAM_DECOMP_STATUS_FAILED_DEST_BUF_TOO_SMALL,
      LZHAM_DECOMP_STATUS_FAILED_EXPECTED_MORE_RAW_BYTES,
      LZHAM_DECOMP_STATUS_FAILED_BAD_CODE,
      LZHAM_DECOMP_STATUS_FAILED_ADLER32,
      LZHAM_DECOMP_STATUS_FAILED_BAD_RAW_BLOCK,
      LZHAM_DECOMP_STATUS_FAILED_BAD_COMP_BLOCK_SYNC_CHECK,
      LZHAM_DECOMP_STATUS_FAILED_BAD_ZLIB_HEADER,
      LZHAM_DECOMP_STATUS_FAILED_NEED_SEED_BYTES,
      LZHAM_DECOMP_STATUS_FAILED_BAD_SEED_BYTES,
      LZHAM_DECOMP_STATUS_FAILED_BAD_SYNC_BLOCK,
      LZHAM_DECOMP_STATUS_INVALID_PARAMETER,
   } lzham_decompress_status_t;
   
   typedef void *lzham_decompress_state_ptr;

   typedef enum
   {
      LZHAM_DECOMP_FLAG_OUTPUT_UNBUFFERED = 1,
      LZHAM_DECOMP_FLAG_COMPUTE_ADLER32 = 2,
      LZHAM_DECOMP_FLAG_READ_ZLIB_STREAM = 4,
   } lzham_decompress_flags;

   // Decompression parameters structure.
   // Notes: 
   // m_dict_size_log2 MUST match the value used during compression!
   // If m_num_seed_bytes != 0, LZHAM_DECOMP_FLAG_OUTPUT_UNBUFFERED must not be set (i.e. static "seed" dictionaries are not compatible with unbuffered decompression).
   // The seed buffer's contents and size must match the seed buffer used during compression.
   // m_table_update_rate (or m_table_max_update_interval/m_table_update_interval_slow_rate) MUST match the values used for compression!
   typedef struct
   {
      lzham_uint32 m_struct_size;            // set to sizeof(lzham_decompress_params)
      lzham_uint32 m_dict_size_log2;         // set to the log2(dictionary_size), must range between [LZHAM_MIN_DICT_SIZE_LOG2, LZHAM_MAX_DICT_SIZE_LOG2_X86] for x86 LZHAM_MAX_DICT_SIZE_LOG2_X64 for x64
		lzham_uint32 m_table_update_rate;		// Controls tradeoff between ratio and decompression throughput. 0=default, or [1,LZHAM_MAX_TABLE_UPDATE_RATE], higher=faster but lower ratio.
      lzham_uint32 m_decompress_flags;       // optional decompression flags (see lzham_decompress_flags enum)
      lzham_uint32 m_num_seed_bytes;         // for delta compression (optional) - number of seed bytes pointed to by m_pSeed_bytes
      const void *m_pSeed_bytes;             // for delta compression (optional) - pointer to seed bytes buffer, must be at least m_num_seed_bytes long

      // Advanced settings - set to 0 if you don't care.
		// m_table_max_update_interval/m_table_update_interval_slow_rate override m_table_update_rate and allow finer control over the table update settings.
		// If either are non-zero they will override whatever m_table_update_rate is set to. Just leave them 0 unless you are specifically customizing them for your data.

      // def=0, typical range 12-128 (LZHAM_DEFAULT_TABLE_UPDATE_RATE=64), controls the max interval between table updates, higher=longer max interval (faster decode/lower ratio). Was 16 in prev. releases.
      lzham_uint32 m_table_max_update_interval;
      // def=0, 32 or higher (LZHAM_DEFAULT_TABLE_UPDATE_RATE=64), scaled by 32, controls the slowing of the update update freq, higher=more rapid slowing (faster decode/lower ratio). Was 40 in prev. releases.
      lzham_uint32 m_table_update_interval_slow_rate;

   } lzham_decompress_params;
   
   // Initializes a decompressor.
   // pParams cannot be NULL. Be sure to initialize the pParams->m_struct_size member to sizeof(lzham_decompress_params) (along with the other members to reasonable values) before calling this function.
   // Note: With large dictionaries this function could take a while (due to memory allocation). To serially decompress multiple streams, it's faster to init a compressor once and 
   // reuse it using by calling lzham_decompress_reinit().
   LZHAM_DLL_EXPORT lzham_decompress_state_ptr LZHAM_CDECL lzham_decompress_init(const lzham_decompress_params *pParams);

   // Quickly re-initializes the decompressor to its initial state given an already allocated/initialized state (doesn't do any memory alloc unless necessary).
   LZHAM_DLL_EXPORT lzham_decompress_state_ptr LZHAM_CDECL lzham_decompress_reinit(lzham_decompress_state_ptr pState, const lzham_decompress_params *pParams);

   // Deinitializes a decompressor.
   // returns adler32 of decompressed data if compute_adler32 was true, otherwise it returns the adler32 from the compressed stream.
   LZHAM_DLL_EXPORT lzham_uint32 LZHAM_CDECL lzham_decompress_deinit(lzham_decompress_state_ptr pState);

   // Decompresses an arbitrarily sized block of compressed data, writing as much available decompressed data as possible to the output buffer. 
   // This method is implemented as a coroutine so it may be called as many times as needed. However, for best perf. try not to call it with tiny buffers.
   // pState - Pointer to internal decompression state, originally created by lzham_decompress_init.
   // pIn_buf, pIn_buf_size - Pointer to input data buffer, and pointer to a size_t containing the number of bytes available in this buffer. 
   //                         On return, *pIn_buf_size will be set to the number of bytes read from the buffer.
   // pOut_buf, pOut_buf_size - Pointer to the output data buffer, and a pointer to a size_t containing the max number of bytes that can be written to this buffer.
   //                         On return, *pOut_buf_size will be set to the number of bytes written to this buffer.
   // no_more_input_bytes_flag - Set to true to indicate that no more input bytes are available to compress (EOF). Once you call this function with this param set to true, it must stay set to true in all future calls.
   // Notes:
   // In unbuffered mode, the output buffer MUST be large enough to hold the entire decompressed stream. Otherwise, you'll receive the
   //  LZHAM_DECOMP_STATUS_FAILED_DEST_BUF_TOO_SMALL error (which is currently unrecoverable during unbuffered decompression).
   // In buffered mode, if the output buffer's size is 0 bytes, the caller is indicating that no more output bytes are expected from the
   //  decompressor. In this case, if the decompressor actually has more bytes you'll receive the LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT
   //  error (which is recoverable in the buffered case - just call lzham_decompress() again with a non-zero size output buffer).
   LZHAM_DLL_EXPORT lzham_decompress_status_t LZHAM_CDECL lzham_decompress(
      lzham_decompress_state_ptr pState,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size,
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_bool no_more_input_bytes_flag);

   // Single function call interface.
   LZHAM_DLL_EXPORT lzham_decompress_status_t LZHAM_CDECL lzham_decompress_memory(
      const lzham_decompress_params *pParams,
      lzham_uint8* pDst_buf,
      size_t *pDst_len,
      const lzham_uint8* pSrc_buf,
      size_t src_len,
      lzham_uint32 *pAdler32);

   // ------------------- zlib-style API Definitions.
   
   // Important note: LZHAM doesn't internally support the Deflate algorithm, but for API compatibility the "Deflate" and "Inflate" names are retained here.

   typedef unsigned long lzham_z_ulong;

   // Heap allocation callbacks.
   // Note that lzham_alloc_func parameter types purposely differ from zlib's: items/size is size_t, not unsigned long.
   typedef void *(*lzham_z_alloc_func)(void *opaque, size_t items, size_t size);
   typedef void (*lzham_z_free_func)(void *opaque, void *address);
   typedef void *(*lzham_z_realloc_func)(void *opaque, void *address, size_t items, size_t size);

   #define LZHAM_Z_ADLER32_INIT (1)
   // lzham_adler32() returns the initial adler-32 value to use when called with ptr==NULL.
   LZHAM_DLL_EXPORT lzham_z_ulong lzham_z_adler32(lzham_z_ulong adler, const unsigned char *ptr, size_t buf_len);

   #define LZHAM_Z_CRC32_INIT (0)
   // lzham_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.
   LZHAM_DLL_EXPORT lzham_z_ulong lzham_z_crc32(lzham_z_ulong crc, const unsigned char *ptr, size_t buf_len);

   // Compression strategies.
   enum 
   { 
      LZHAM_Z_DEFAULT_STRATEGY = 0, 
      LZHAM_Z_FILTERED = 1, 
      LZHAM_Z_HUFFMAN_ONLY = 2, 
      LZHAM_Z_RLE = 3, 
      LZHAM_Z_FIXED = 4 
   };

   // Method
   #define LZHAM_Z_DEFLATED 8
   #define LZHAM_Z_LZHAM 14

   #define LZHAM_Z_VERSION          "10.8.1"
   #define LZHAM_Z_VERNUM           0xA810
   #define LZHAM_Z_VER_MAJOR        10
   #define LZHAM_Z_VER_MINOR        8
   #define LZHAM_Z_VER_REVISION     1
   #define LZHAM_Z_VER_SUBREVISION  0

   // Flush values. 
   // For compression, you typically only need to use LZHAM_NO_FLUSH and LZHAM_FINISH. 
   // LZHAM_Z_SYNC_FLUSH and LZHAM_Z_FULL_FLUSH during compression forces compression of all buffered input.
   //
   // For decompression, you typically only need to use LZHAM_Z_SYNC_FLUSH or LZHAM_Z_FINISH. 
   // LZHAM_Z_FINISH during decompression guarantees that the output buffer is large enough to hold all remaining data to decompress.
   // See http://www.bolet.org/~pornin/deflate-flush.html
   // Must directly map to lzham_flush_t
   enum 
   { 
      LZHAM_Z_NO_FLUSH = 0,       // compression/decompression
      LZHAM_Z_PARTIAL_FLUSH = 1,  // compression/decompression, same as LZHAM_Z_SYNC_FLUSH
      LZHAM_Z_SYNC_FLUSH = 2,     // compression/decompression, when compressing: flush current block (if any), always outputs sync block (aligns output to byte boundary, a 0xFFFF0000 marker will appear in the output stream)
      LZHAM_Z_FULL_FLUSH = 3,     // compression/decompression, when compressing: same as LZHAM_Z_SYNC_FLUSH but also forces a full state flush (LZ dictionary, all symbol statistics)
      LZHAM_Z_FINISH = 4,         // compression/decompression
      LZHAM_Z_BLOCK = 5,          // not supported
      LZHAM_Z_TABLE_FLUSH = 10    // compression only, resets all symbol table update rates to maximum frequency (LZHAM extension)
   };

   // Return status codes. LZHAM_Z_PARAM_ERROR is non-standard.
   enum 
   { 
      LZHAM_Z_OK = 0, 
      LZHAM_Z_STREAM_END = 1, 
      LZHAM_Z_NEED_DICT = 2, 
      LZHAM_Z_ERRNO = -1, 
      LZHAM_Z_STREAM_ERROR = -2, 
      LZHAM_Z_DATA_ERROR = -3, 
      LZHAM_Z_MEM_ERROR = -4, 
      LZHAM_Z_BUF_ERROR = -5, 
      LZHAM_Z_VERSION_ERROR = -6, 
      LZHAM_Z_PARAM_ERROR = -10000 
   };

   // Compression levels.
   enum 
   { 
      LZHAM_Z_NO_COMPRESSION = 0,
      LZHAM_Z_BEST_SPEED = 1,
      LZHAM_Z_BEST_COMPRESSION = 9,
      LZHAM_Z_UBER_COMPRESSION = 10,      // uber = best with extreme parsing (can be very slow)
      LZHAM_Z_DEFAULT_COMPRESSION = -1 
   };

   // Window bits
   // Important note: The zlib-style API's default to 32KB dictionary for API compatibility. For improved compression, be sure to call deflateInit2/inflateInit2 and specify larger custom window_bits values!
   // If changing the calling code isn't practical, unremark LZHAM_Z_API_FORCE_WINDOW_BITS.
   #define LZHAM_Z_DEFAULT_WINDOW_BITS 15

   // Define LZHAM_Z_API_FORCE_WINDOW_BITS to force the entire library to use a constant value for window_bits (helps with porting) in all zlib API's.
   // TODO: Might be useful to provide an API to control this at runtime.
   //#define LZHAM_Z_API_FORCE_WINDOW_BITS 23

   // Data types
   #define LZHAM_Z_BINARY              0
   #define LZHAM_Z_TEXT                1
   #define LZHAM_Z_ASCII               1
   #define LZHAM_Z_UNKNOWN             2
   
   struct lzham_z_internal_state;

   // Compression/decompression stream struct.
   typedef struct
   {
     const unsigned char *next_in;           // pointer to next byte to read
     unsigned int avail_in;                  // number of bytes available at next_in
     lzham_z_ulong total_in;                 // total number of bytes consumed so far

     unsigned char *next_out;                // pointer to next byte to write
     unsigned int avail_out;                 // number of bytes that can be written to next_out
     lzham_z_ulong total_out;                // total number of bytes produced so far

     char *msg;                              // error msg (unused)
     struct lzham_z_internal_state *state;   // internal state, allocated by zalloc/zfree

     // LZHAM does not support per-stream heap callbacks. Use lzham_set_memory_callbacks() instead.
     // These members are ignored - they are here for backwards compatibility with zlib.
     lzham_z_alloc_func zalloc;              // optional heap allocation function (defaults to malloc)
     lzham_z_free_func zfree;                // optional heap free function (defaults to free)
     void *opaque;                           // heap alloc function user pointer

     int data_type;                          // data_type (unused)
     lzham_z_ulong adler;                    // adler32 of the source or uncompressed data
     lzham_z_ulong reserved;                 // not used
   } lzham_z_stream;

   typedef lzham_z_stream *lzham_z_streamp;

   LZHAM_DLL_EXPORT const char *lzham_z_version(void);

   // lzham_deflateInit() initializes a compressor with default options:
   // Parameters:
   //  pStream must point to an initialized lzham_stream struct.
   //  level must be between [LZHAM_NO_COMPRESSION, LZHAM_BEST_COMPRESSION].
   //  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio.
   // Return values:
   //  LZHAM_OK on success.
   //  LZHAM_STREAM_ERROR if the stream is bogus.
   //  LZHAM_PARAM_ERROR if the input parameters are bogus.
   //  LZHAM_MEM_ERROR on out of memory.
   LZHAM_DLL_EXPORT int lzham_z_deflateInit(lzham_z_streamp pStream, int level);

   // lzham_deflateInit2() is like lzham_deflate(), except with more control:
   // Additional parameters:
   //   method must be LZHAM_Z_DEFLATED or LZHAM_Z_LZHAM (LZHAM_Z_DEFLATED will be internally converted to LZHAM_Z_LZHAM with a windowsize of LZHAM_Z_DEFAULT_WINDOW_BITS)
   //   window_bits must be LZHAM_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -LZHAM_Z_DEFAULT_WINDOW_BITS (raw deflate/no header or footer)
   //   mem_level must be between [1, 9] (it's checked but ignored by lzham)
   LZHAM_DLL_EXPORT int lzham_z_deflateInit2(lzham_z_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);
      
   // Quickly resets a compressor without having to reallocate anything. Same as calling lzham_z_deflateEnd() followed by lzham_z_deflateInit()/lzham_z_deflateInit2().
   LZHAM_DLL_EXPORT int lzham_z_deflateReset(lzham_z_streamp pStream);

   // lzham_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible.
   // Parameters:
   //   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
   //   flush may be LZHAM_Z_NO_FLUSH, LZHAM_Z_PARTIAL_FLUSH/LZHAM_Z_SYNC_FLUSH, LZHAM_Z_FULL_FLUSH, or LZHAM_Z_FINISH.
   // Return values:
   //   LZHAM_Z_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full).
   //   LZHAM_Z_STREAM_END if all input has been consumed and all output bytes have been written. Don't call lzham_z_deflate() on the stream anymore.
   //   LZHAM_Z_STREAM_ERROR if the stream is bogus.
   //   LZHAM_Z_PARAM_ERROR if one of the parameters is invalid.
   //   LZHAM_Z_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.)
   LZHAM_DLL_EXPORT int lzham_z_deflate(lzham_z_streamp pStream, int flush);

   // lzham_deflateEnd() deinitializes a compressor:
   // Return values:
   //  LZHAM_Z_OK on success.
   //  LZHAM_Z_STREAM_ERROR if the stream is bogus.
   LZHAM_DLL_EXPORT int lzham_z_deflateEnd(lzham_z_streamp pStream);

   // lzham_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by lzham_z_deflate(), assuming flush is set to only LZHAM_Z_NO_FLUSH or LZHAM_Z_FINISH.
   LZHAM_DLL_EXPORT lzham_z_ulong lzham_z_deflateBound(lzham_z_streamp pStream, lzham_z_ulong source_len);

   // Single-call compression functions lzham_z_compress() and lzham_z_compress2():
   // Returns LZHAM_Z_OK on success, or one of the error codes from lzham_z_deflate() on failure.
   LZHAM_DLL_EXPORT int lzham_z_compress(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len);
   LZHAM_DLL_EXPORT int lzham_z_compress2(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len, int level);

   // lzham_z_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling lzham_z_compress().
   LZHAM_DLL_EXPORT lzham_z_ulong lzham_z_compressBound(lzham_z_ulong source_len);

   // Initializes a decompressor.
   LZHAM_DLL_EXPORT int lzham_z_inflateInit(lzham_z_streamp pStream);

   // lzham_z_inflateInit2() is like lzham_z_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer:
   // window_bits must be LZHAM_Z_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -LZHAM_Z_DEFAULT_WINDOW_BITS (raw stream with no zlib header/footer).
   LZHAM_DLL_EXPORT int lzham_z_inflateInit2(lzham_z_streamp pStream, int window_bits);

   LZHAM_DLL_EXPORT int lzham_z_inflateReset(lzham_z_streamp pStream);

   // Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible.
   // Parameters:
   //   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
   //   flush may be LZHAM_Z_NO_FLUSH, LZHAM_Z_SYNC_FLUSH, or LZHAM_Z_FINISH.
   //   On the first call, if flush is LZHAM_Z_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster).
   //   LZHAM_Z_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data.
   // Return values:
   //   LZHAM_Z_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full.
   //   LZHAM_Z_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified.
   //   LZHAM_Z_STREAM_ERROR if the stream is bogus.
   //   LZHAM_Z_DATA_ERROR if the deflate stream is invalid.
   //   LZHAM_Z_PARAM_ERROR if one of the parameters is invalid.
   //   LZHAM_Z_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call lzham_inflate() again
   //   with more input data, or with more room in the output buffer (except when using single call decompression, described above).
   LZHAM_DLL_EXPORT int lzham_z_inflate(lzham_z_streamp pStream, int flush);

   // Deinitializes a decompressor.
   LZHAM_DLL_EXPORT int lzham_z_inflateEnd(lzham_z_streamp pStream);

   // Single-call decompression.
   // Returns LZHAM_OK on success, or one of the error codes from lzham_inflate() on failure.
   LZHAM_DLL_EXPORT int lzham_z_uncompress(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len);

   // Returns a string description of the specified error code, or NULL if the error code is invalid.
   LZHAM_DLL_EXPORT const char *lzham_z_error(int err);

   // Redefine zlib-compatible names to lzham equivalents, so lzham can be used as a more or less drop-in replacement for the subset of zlib that lzham supports.
   // Define LZHAM_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project.
   #ifdef LZHAM_DEFINE_ZLIB_API
      typedef unsigned char Byte;
      typedef unsigned int uInt;
      typedef lzham_z_ulong uLong;
      typedef Byte Bytef;
      typedef uInt uIntf;
      typedef char charf;
      typedef int intf;
      typedef void *voidpf;
      typedef uLong uLongf;
      typedef void *voidp;
      typedef void *const voidpc;
      #define Z_NULL                0
      #define Z_NO_FLUSH            LZHAM_Z_NO_FLUSH
      #define Z_PARTIAL_FLUSH       LZHAM_Z_PARTIAL_FLUSH
      #define Z_SYNC_FLUSH          LZHAM_Z_SYNC_FLUSH
      #define Z_FULL_FLUSH          LZHAM_Z_FULL_FLUSH
      #define Z_FINISH              LZHAM_Z_FINISH
      #define Z_BLOCK               LZHAM_Z_BLOCK
      #define Z_OK                  LZHAM_Z_OK
      #define Z_STREAM_END          LZHAM_Z_STREAM_END
      #define Z_NEED_DICT           LZHAM_Z_NEED_DICT
      #define Z_ERRNO               LZHAM_Z_ERRNO
      #define Z_STREAM_ERROR        LZHAM_Z_STREAM_ERROR
      #define Z_DATA_ERROR          LZHAM_Z_DATA_ERROR
      #define Z_MEM_ERROR           LZHAM_Z_MEM_ERROR
      #define Z_BUF_ERROR           LZHAM_Z_BUF_ERROR
      #define Z_VERSION_ERROR       LZHAM_Z_VERSION_ERROR
      #define Z_PARAM_ERROR         LZHAM_Z_PARAM_ERROR
      #define Z_NO_COMPRESSION      LZHAM_Z_NO_COMPRESSION
      #define Z_BEST_SPEED          LZHAM_Z_BEST_SPEED
      #define Z_BEST_COMPRESSION    LZHAM_Z_BEST_COMPRESSION
      #define Z_DEFAULT_COMPRESSION LZHAM_Z_DEFAULT_COMPRESSION
      #define Z_DEFAULT_STRATEGY    LZHAM_Z_DEFAULT_STRATEGY
      #define Z_FILTERED            LZHAM_Z_FILTERED
      #define Z_HUFFMAN_ONLY        LZHAM_Z_HUFFMAN_ONLY
      #define Z_RLE                 LZHAM_Z_RLE
      #define Z_FIXED               LZHAM_Z_FIXED
      #define Z_DEFLATED            LZHAM_Z_DEFLATED
      #define Z_DEFAULT_WINDOW_BITS LZHAM_Z_DEFAULT_WINDOW_BITS
      #define alloc_func            lzham_z_alloc_func
      #define free_func             lzham_z_free_func
      #define internal_state        lzham_z_internal_state
      #define z_stream              lzham_z_stream
      #define deflateInit           lzham_z_deflateInit
      #define deflateInit2          lzham_z_deflateInit2
      #define deflateReset          lzham_z_deflateReset
      #define deflate               lzham_z_deflate
      #define deflateEnd            lzham_z_deflateEnd
      #define deflateBound          lzham_z_deflateBound
      #define compress              lzham_z_compress
      #define compress2             lzham_z_compress2
      #define compressBound         lzham_z_compressBound
      #define inflateInit           lzham_z_inflateInit
      #define inflateInit2          lzham_z_inflateInit2
      #define inflateReset          lzham_z_inflateReset
      #define inflate               lzham_z_inflate
      #define inflateEnd            lzham_z_inflateEnd
      #define uncompress            lzham_z_uncompress
      #define crc32                 lzham_z_crc32
      #define adler32               lzham_z_adler32
      #define MAX_WBITS             26
      #define MAX_MEM_LEVEL         9
      #define zError                lzham_z_error
      #define ZLIB_VERSION          LZHAM_Z_VERSION
      #define ZLIB_VERNUM           LZHAM_Z_VERNUM
      #define ZLIB_VER_MAJOR        LZHAM_Z_VER_MAJOR
      #define ZLIB_VER_MINOR        LZHAM_Z_VER_MINOR
      #define ZLIB_VER_REVISION     LZHAM_Z_VER_REVISION
      #define ZLIB_VER_SUBREVISION  LZHAM_Z_VER_SUBREVISION
      #define zlibVersion           lzham_z_version
      #define zlib_version          lzham_z_version()
      #define Z_BINARY              LZHAM_Z_BINARY
      #define Z_TEXT                LZHAM_Z_TEST
      #define Z_ASCII               LZHAM_Z_ASCII
      #define Z_UNKNOWN             LZHAM_Z_UNKNOWN
   #endif // #ifdef LZHAM_DEFINE_ZLIB_API

   // Exported function typedefs, to simplify loading the LZHAM DLL dynamically.
   typedef lzham_uint32 (LZHAM_CDECL *lzham_get_version_func)(void);
   typedef void (LZHAM_CDECL *lzham_set_memory_callbacks_func)(lzham_realloc_func pRealloc, lzham_msize_func pMSize, void* pUser_data);

   typedef lzham_compress_state_ptr (LZHAM_CDECL *lzham_compress_init_func)(const lzham_compress_params *pParams);
   typedef lzham_compress_state_ptr (LZHAM_CDECL *lzham_compress_reinit_func)(lzham_compress_state_ptr pState);
   typedef lzham_uint32 (LZHAM_CDECL *lzham_compress_deinit_func)(lzham_compress_state_ptr pState);
   typedef lzham_compress_status_t (LZHAM_CDECL *lzham_compress_func)(lzham_compress_state_ptr pState, const lzham_uint8 *pIn_buf, size_t *pIn_buf_size, lzham_uint8 *pOut_buf, size_t *pOut_buf_size, lzham_bool no_more_input_bytes_flag);
   typedef lzham_compress_status_t (LZHAM_CDECL *lzham_compress2_func)(lzham_compress_state_ptr pState, const lzham_uint8 *pIn_buf, size_t *pIn_buf_size, lzham_uint8 *pOut_buf, size_t *pOut_buf_size, lzham_flush_t flush_type);
   typedef lzham_compress_status_t (LZHAM_CDECL *lzham_compress_memory_func)(const lzham_compress_params *pParams, lzham_uint8* pDst_buf, size_t *pDst_len, const lzham_uint8* pSrc_buf, size_t src_len, lzham_uint32 *pAdler32);

   typedef lzham_decompress_state_ptr (LZHAM_CDECL *lzham_decompress_init_func)(const lzham_decompress_params *pParams);
   typedef lzham_decompress_state_ptr (LZHAM_CDECL *lzham_decompress_reinit_func)(lzham_compress_state_ptr pState, const lzham_decompress_params *pParams);
   typedef lzham_uint32 (LZHAM_CDECL *lzham_decompress_deinit_func)(lzham_decompress_state_ptr pState);
   typedef lzham_decompress_status_t (LZHAM_CDECL *lzham_decompress_func)(lzham_decompress_state_ptr pState, const lzham_uint8 *pIn_buf, size_t *pIn_buf_size, lzham_uint8 *pOut_buf, size_t *pOut_buf_size, lzham_bool no_more_input_bytes_flag);
   typedef lzham_decompress_status_t (LZHAM_CDECL *lzham_decompress_memory_func)(const lzham_decompress_params *pParams, lzham_uint8* pDst_buf, size_t *pDst_len, const lzham_uint8* pSrc_buf, size_t src_len, lzham_uint32 *pAdler32);

   typedef const char *(LZHAM_CDECL *lzham_z_version_func)(void);
   typedef int (LZHAM_CDECL *lzham_z_deflateInit_func)(lzham_z_streamp pStream, int level);
   typedef int (LZHAM_CDECL *lzham_z_deflateInit2_func)(lzham_z_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);
   typedef int (LZHAM_CDECL *lzham_z_deflateReset_func)(lzham_z_streamp pStream);
   typedef int (LZHAM_CDECL *lzham_z_deflate_func)(lzham_z_streamp pStream, int flush);
   typedef int (LZHAM_CDECL *lzham_z_deflateEnd_func)(lzham_z_streamp pStream);
   typedef lzham_z_ulong (LZHAM_CDECL *lzham_z_deflateBound_func)(lzham_z_streamp pStream, lzham_z_ulong source_len);
   typedef int (LZHAM_CDECL *lzham_z_compress_func)(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len);
   typedef int (LZHAM_CDECL *lzham_z_compress2_func)(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len, int level);
   typedef lzham_z_ulong (LZHAM_CDECL *lzham_z_compressBound_func)(lzham_z_ulong source_len);
   typedef int (LZHAM_CDECL *lzham_z_inflateInit_func)(lzham_z_streamp pStream);
   typedef int (LZHAM_CDECL *lzham_z_inflateInit2_func)(lzham_z_streamp pStream, int window_bits);
   typedef int (LZHAM_CDECL *lzham_z_inflateReset_func)(lzham_z_streamp pStream);
   typedef int (LZHAM_CDECL *lzham_z_inflate_func)(lzham_z_streamp pStream, int flush);
   typedef int (LZHAM_CDECL *lzham_z_inflateEnd_func)(lzham_z_streamp pStream);
   typedef int (LZHAM_CDECL *lzham_z_uncompress_func)(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len);
   typedef const char *(LZHAM_CDECL *lzham_z_error_func)(int err);
   
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
// This optional interface is used by the dynamic/static link helpers defined in lzham_dynamic_lib.h and lzham_static_lib.h.
// It allows code to always call LZHAM the same way, independent of how it was linked into the app (statically or dynamically).
class ilzham
{
   ilzham(const ilzham &other);
   ilzham& operator= (const ilzham &rhs);

public:
   ilzham() { clear(); }

   virtual ~ilzham() { }
   virtual bool load() = 0;
   virtual void unload() = 0;
   virtual bool is_loaded() = 0;

   void clear()
   {
      this->lzham_get_version = NULL;
      this->lzham_set_memory_callbacks = NULL;
      
      this->lzham_compress_init = NULL;
      this->lzham_compress_reinit = NULL;
      this->lzham_compress_deinit = NULL;
      this->lzham_compress = NULL;
      this->lzham_compress2 = NULL;
      this->lzham_compress_memory = NULL;
      
      this->lzham_decompress_init = NULL;
      this->lzham_decompress_reinit = NULL;
      this->lzham_decompress_deinit = NULL;
      this->lzham_decompress = NULL;
      this->lzham_decompress_memory = NULL;

      this->lzham_z_version = NULL;
      this->lzham_z_deflateInit = NULL;
      this->lzham_z_deflateInit2 = NULL;
      this->lzham_z_deflateReset = NULL;
      this->lzham_z_deflate = NULL;
      this->lzham_z_deflateEnd = NULL;
      this->lzham_z_deflateBound = NULL;
      this->lzham_z_compress = NULL;
      this->lzham_z_compress2 = NULL;
      this->lzham_z_compressBound = NULL;
      this->lzham_z_inflateInit = NULL;
      this->lzham_z_inflateInit2 = NULL;
      this->lzham_z_inflate = NULL;
      this->lzham_z_inflateEnd = NULL;
      this->lzham_z_inflateReset = NULL;
      this->lzham_z_uncompress = NULL;
      this->lzham_z_error = NULL;
   }

   lzham_get_version_func           lzham_get_version;
   lzham_set_memory_callbacks_func  lzham_set_memory_callbacks;
   
   lzham_compress_init_func         lzham_compress_init;
   lzham_compress_reinit_func       lzham_compress_reinit;
   lzham_compress_deinit_func       lzham_compress_deinit;
   lzham_compress_func              lzham_compress;
   lzham_compress2_func             lzham_compress2;
   lzham_compress_memory_func       lzham_compress_memory;

   lzham_decompress_init_func       lzham_decompress_init;
   lzham_decompress_reinit_func     lzham_decompress_reinit;
   lzham_decompress_deinit_func     lzham_decompress_deinit;
   lzham_decompress_func            lzham_decompress;
   lzham_decompress_memory_func     lzham_decompress_memory;

   lzham_z_version_func             lzham_z_version;
   lzham_z_deflateInit_func         lzham_z_deflateInit;
   lzham_z_deflateInit2_func        lzham_z_deflateInit2;
   lzham_z_deflateReset_func        lzham_z_deflateReset;
   lzham_z_deflate_func             lzham_z_deflate;
   lzham_z_deflateEnd_func          lzham_z_deflateEnd;
   lzham_z_deflateBound_func        lzham_z_deflateBound;
   lzham_z_compress_func            lzham_z_compress;
   lzham_z_compress2_func           lzham_z_compress2;
   lzham_z_compressBound_func       lzham_z_compressBound;
   lzham_z_inflateInit_func         lzham_z_inflateInit;
   lzham_z_inflateInit2_func        lzham_z_inflateInit2;
   lzham_z_inflateReset_func        lzham_z_inflateReset;
   lzham_z_inflate_func             lzham_z_inflate;
   lzham_z_inflateEnd_func          lzham_z_inflateEnd;
   lzham_z_uncompress_func          lzham_z_uncompress;
   lzham_z_error_func               lzham_z_error;
};
#endif // #ifdef __cplusplus

#endif // #ifndef __LZHAM_H__

// Copyright (c) 2009-2012 Richard Geldreich, Jr. <richgel99@gmail.com>
//
// LZHAM uses the MIT License:
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#pragma once

#define LZHAM_DYNAMIC_LIB 1
#include "lzham.h"

#ifdef _XBOX
   #define LZHAM_DLL_FILENAME       "lzham_x360.dll"
   #define LZHAM_DEBUG_DLL_FILENAME "lzham_x360D.dll"
#else
   // FIXME: This stuff should probably be moved to another header.
   #if LZHAM_64BIT
      #define LZHAM_DLL_FILENAME       "lzham_x64.dll"
      #define LZHAM_DEBUG_DLL_FILENAME "lzham_x64D.dll"
   #else
      #define LZHAM_DLL_FILENAME       "lzham_x86.dll"
      #define LZHAM_DEBUG_DLL_FILENAME "lzham_x86D.dll"
   #endif
#endif

#ifdef __cplusplus
// Simple helper class that demonstrates how to dynamically load the LZHAM DLL.
// The load() method loads the DLL, then initializes the member function pointers in ilzham by calling GetProcAddress() on all exported API's defined in lzham_exports.inc.
class lzham_dll_loader : public ilzham
{
   lzham_dll_loader(const lzham_dll_loader &other);
   lzham_dll_loader& operator= (const lzham_dll_loader &rhs);

public:
   lzham_dll_loader() : ilzham(), m_handle(NULL), m_win32_error(S_OK)
   {
   }

   virtual ~lzham_dll_loader()
   {
      unload();
   }

   enum
   {
      cErrorMissingExport = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x201),
      cErrorUnsupportedDLLVersion = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x202),
   };

   // Assumes LZHAM DLL is in the same path as the executable.
#if defined(_XBOX) || defined(_MSC_VER)
   static void create_module_path(char *pModulePath, int size_in_chars, bool debug_dll)
   {
#ifdef _XBOX   
      char *buf = "D:\\unused.xex";
#else      
      char buf[MAX_PATH];
      GetModuleFileNameA(NULL, buf, sizeof(buf));
#endif
      char drive_buf[_MAX_DRIVE], dir_buf[_MAX_DIR], filename_buf[_MAX_FNAME], ext_buf[_MAX_EXT];
      _splitpath_s(buf, drive_buf, _MAX_DRIVE, dir_buf, _MAX_DIR, NULL, 0, NULL, 0);
      _splitpath_s(debug_dll ? LZHAM_DEBUG_DLL_FILENAME : LZHAM_DLL_FILENAME, NULL, 0, NULL, 0, filename_buf, _MAX_FNAME, ext_buf, _MAX_EXT);
      _makepath_s(pModulePath, size_in_chars, drive_buf, dir_buf, filename_buf, ext_buf);
   }
#else
   static void create_module_path(char *pModulePath, int size_in_chars, bool debug_dll)
   {
      strcpy(pModulePath, debug_dll ? LZHAM_DEBUG_DLL_FILENAME : LZHAM_DLL_FILENAME);
   }
#endif

   virtual bool load()
   {
      HRESULT hres = load(NULL);
      return S_OK == hres;
   }

   HRESULT load(const char* pModulePath)
   {
      unload();
      
      char buf[MAX_PATH];
      if (!pModulePath)
      {
         create_module_path(buf, sizeof(buf), false);
         pModulePath = buf;
      }
      
      m_win32_error = S_OK;

      m_handle = LoadLibraryA(pModulePath);
      if (NULL == m_handle)
      {
         m_win32_error = HRESULT_FROM_WIN32(GetLastError());
         return m_win32_error;
      }

      struct
      {
         const char* pName;
         void** pFunc_ptr;
      }
      funcs[] =
      {
#define LZHAM_DLL_FUNC_NAME(x) { #x, (void**)&x },
#include "lzham_exports.inc"
#undef LZHAM_DLL_FUNC_NAME
      };

      const int cNumFuncs = sizeof(funcs) / sizeof(funcs[0]);

      for (int i = 0; i < cNumFuncs; i++)
      {
#ifdef _XBOX
         if ((*funcs[i].pFunc_ptr = GetProcAddress(m_handle, (LPCSTR)(i + 1))) == NULL)
#else      
         if ((*funcs[i].pFunc_ptr = (void*)GetProcAddress(m_handle, funcs[i].pName)) == NULL)
#endif         
         {
            unload();
            
            m_win32_error = cErrorMissingExport;
            return m_win32_error;
         }
      }

      int dll_ver = lzham_get_version();

      // Ensure DLL's major version is the expected version.
      if ((dll_ver >> 8U) != (LZHAM_DLL_VERSION >> 8U))
      {
         unload();
         
         m_win32_error = cErrorUnsupportedDLLVersion;
         return m_win32_error;
      }

      return S_OK;
   }

   virtual void unload()
   {
      if (m_handle)
      {
         FreeLibrary(m_handle);
         m_handle = NULL;
      }
            
      clear();
      
      m_win32_error = S_OK;
   }
   
   virtual bool is_loaded() { return m_handle != NULL; }
   
   HRESULT get_last_win32_error() { return m_win32_error; }
   
private:
   HMODULE m_handle;
   HRESULT m_win32_error;
};
#endif // #ifdef __cplusplus
// Note: The order here must match the ordinal declarations in lzhamdll.def!
LZHAM_DLL_FUNC_NAME(lzham_get_version)
LZHAM_DLL_FUNC_NAME(lzham_set_memory_callbacks)
LZHAM_DLL_FUNC_NAME(lzham_compress_init)
LZHAM_DLL_FUNC_NAME(lzham_compress_reinit)
LZHAM_DLL_FUNC_NAME(lzham_compress)
LZHAM_DLL_FUNC_NAME(lzham_compress2)
LZHAM_DLL_FUNC_NAME(lzham_compress_deinit)
LZHAM_DLL_FUNC_NAME(lzham_compress_memory)
LZHAM_DLL_FUNC_NAME(lzham_decompress_init)
LZHAM_DLL_FUNC_NAME(lzham_decompress)
LZHAM_DLL_FUNC_NAME(lzham_decompress_deinit)
LZHAM_DLL_FUNC_NAME(lzham_decompress_memory)
LZHAM_DLL_FUNC_NAME(lzham_decompress_reinit)
LZHAM_DLL_FUNC_NAME(lzham_z_version)
LZHAM_DLL_FUNC_NAME(lzham_z_deflateInit)
LZHAM_DLL_FUNC_NAME(lzham_z_deflateInit2)
LZHAM_DLL_FUNC_NAME(lzham_z_deflateReset)
LZHAM_DLL_FUNC_NAME(lzham_z_deflate)
LZHAM_DLL_FUNC_NAME(lzham_z_deflateEnd)
LZHAM_DLL_FUNC_NAME(lzham_z_deflateBound)
LZHAM_DLL_FUNC_NAME(lzham_z_compress)
LZHAM_DLL_FUNC_NAME(lzham_z_compress2)
LZHAM_DLL_FUNC_NAME(lzham_z_compressBound)
LZHAM_DLL_FUNC_NAME(lzham_z_inflateInit)
LZHAM_DLL_FUNC_NAME(lzham_z_inflateInit2)
LZHAM_DLL_FUNC_NAME(lzham_z_inflateReset)
LZHAM_DLL_FUNC_NAME(lzham_z_inflate)
LZHAM_DLL_FUNC_NAME(lzham_z_inflateEnd)
LZHAM_DLL_FUNC_NAME(lzham_z_uncompress)
LZHAM_DLL_FUNC_NAME(lzham_z_error)
#pragma once

#define LZHAM_STATIC_LIB 1
#include "lzham.h"

#ifdef __cplusplus
// Like lzham_dynamic_lib, except it sets the function pointer members to point directly to the C functions in lzhamlib
class lzham_static_lib : public ilzham
{
   lzham_static_lib(const lzham_static_lib &other);
   lzham_static_lib& operator= (const lzham_static_lib &rhs);

public:
   lzham_static_lib() : ilzham() { }

   virtual ~lzham_static_lib() { }
   
   virtual bool load()
   {
      this->lzham_get_version = ::lzham_get_version;
      this->lzham_set_memory_callbacks = ::lzham_set_memory_callbacks;
      this->lzham_compress_init = ::lzham_compress_init;
      this->lzham_compress_deinit = ::lzham_compress_deinit;
      this->lzham_compress = ::lzham_compress;
      this->lzham_compress2 = ::lzham_compress2;
      this->lzham_compress_reinit = ::lzham_compress_reinit;
      this->lzham_compress_memory = ::lzham_compress_memory;
      this->lzham_decompress_init = ::lzham_decompress_init;
      this->lzham_decompress_reinit = ::lzham_decompress_reinit;
      this->lzham_decompress_deinit = ::lzham_decompress_deinit;
      this->lzham_decompress = ::lzham_decompress;
      this->lzham_decompress_memory = ::lzham_decompress_memory;

      this->lzham_z_version = ::lzham_z_version;
      this->lzham_z_deflateInit = ::lzham_z_deflateInit;
      this->lzham_z_deflateInit2 = ::lzham_z_deflateInit2;
      this->lzham_z_deflateReset = ::lzham_z_deflateReset;
      this->lzham_z_deflate = ::lzham_z_deflate;
      this->lzham_z_deflateEnd = ::lzham_z_deflateEnd;
      this->lzham_z_deflateBound = ::lzham_z_deflateBound;
      this->lzham_z_compress = ::lzham_z_compress;
      this->lzham_z_compress2 = ::lzham_z_compress2;
      this->lzham_z_compressBound = ::lzham_z_compressBound;
      this->lzham_z_inflateInit = ::lzham_z_inflateInit;
      this->lzham_z_inflateInit2 = ::lzham_z_inflateInit2;
      this->lzham_z_inflate = ::lzham_z_inflate;
      this->lzham_z_inflateEnd = ::lzham_z_inflateEnd;
      this->lzham_z_inflateReset = ::lzham_z_inflateReset;
      this->lzham_z_uncompress = ::lzham_z_uncompress;
      this->lzham_z_error = ::lzham_z_error;

      return true;
   }
   
   virtual void unload() { clear(); }
   
   virtual bool is_loaded() { return lzham_get_version != NULL; }
};
#endif // __cplusplus
#define LZHAM_DEFINE_ZLIB_API
#include "lzham.h"PROJECT(lzhamcomp)
cmake_minimum_required(VERSION 2.8)
option(BUILD_X64 "build 64-bit" TRUE)

message("Initial BUILD_X64=${BUILD_X64}")
message("Initial CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}")

if( NOT CMAKE_BUILD_TYPE )
  set( CMAKE_BUILD_TYPE Release )
endif( NOT CMAKE_BUILD_TYPE )

message( ${PROJECT_NAME} " build type: " ${CMAKE_BUILD_TYPE} )

if (BUILD_X64)
	message("Building 64-bit")
else()
	message("Building 32-bit")
endif(BUILD_X64)

set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -Wall -Wextra")
set(CMAKE_C_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -Wall -Wextra")

set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -Wall -Wextra -O3 -fomit-frame-pointer -fexpensive-optimizations")
set(CMAKE_C_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -Wall -Wextra")

set(SRC_LIST 
	lzham_lzbase.cpp
	lzham_lzbase.h
	lzham_lzcomp.cpp
	lzham_lzcomp_internal.cpp
	lzham_lzcomp_internal.h
	lzham_lzcomp_state.cpp
	lzham_match_accel.cpp
	lzham_match_accel.h
	lzham_null_threading.h
	lzham_pthreads_threading.cpp
	lzham_pthreads_threading.h
	lzham_threading.h)

if (WIN32)
  list (APPEND SRC_LIST lzham_win32_threading.cpp)
endif ()

# -fno-strict-aliasing is *required* to compile LZHAM
set(GCC_COMPILE_FLAGS "-fno-strict-aliasing -D_LARGEFILE64_SOURCE=1 -D_FILE_OFFSET_BITS=64")

if (NOT BUILD_X64)
	set(GCC_COMPILE_FLAGS "${GCC_COMPILE_FLAGS} -m32")
endif()

set(CMAKE_EXE_LINKER_FLAGS  "${CMAKE_EXE_LINKER_FLAGS} ${GCC_LINK_FLAGS}")

set(CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} ${GCC_COMPILE_FLAGS}")
set(CMAKE_C_FLAGS_RELEASE  "${CMAKE_C_FLAGS_RELEASE} ${GCC_COMPILE_FLAGS} -DNDEBUG")
set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} ${GCC_COMPILE_FLAGS} -D_DEBUG")

set(CMAKE_CXX_FLAGS  "${CMAKE_CXX_FLAGS} ${GCC_COMPILE_FLAGS}")
set(CMAKE_CXX_FLAGS_RELEASE  "${CMAKE_CXX_FLAGS_RELEASE} ${GCC_COMPILE_FLAGS} -DNDEBUG")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} ${GCC_COMPILE_FLAGS} -D_DEBUG")

include_directories(
	${PROJECT_SOURCE_DIR}/../lzhamdecomp 
	${PROJECT_SOURCE_DIR}/../include)

#set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin_linux)

add_library(${PROJECT_NAME} ${SRC_LIST})
target_link_libraries(${PROJECT_NAME} lzhamdecomp pthread)
install(TARGETS ${PROJECT_NAME} LIBRARY DESTINATION lib${LIB_SUFFIX} ARCHIVE DESTINATION lib${LIB_SUFFIX} RUNTIME DESTINATION bin)
// File: lzham_comp.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once
#include "lzham.h"

namespace lzham
{
   lzham_compress_state_ptr LZHAM_CDECL lzham_lib_compress_init(const lzham_compress_params *pParams);
   
   lzham_compress_state_ptr LZHAM_CDECL lzham_lib_compress_reinit(lzham_compress_state_ptr p);
   
   lzham_uint32 LZHAM_CDECL lzham_lib_compress_deinit(lzham_compress_state_ptr p);
   
   lzham_compress_status_t LZHAM_CDECL lzham_lib_compress(
      lzham_compress_state_ptr p,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size, 
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_bool no_more_input_bytes_flag);

   lzham_compress_status_t LZHAM_CDECL lzham_lib_compress2(
      lzham_compress_state_ptr p,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size, 
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_flush_t flush_type);
   
   lzham_compress_status_t LZHAM_CDECL lzham_lib_compress_memory(const lzham_compress_params *pParams, lzham_uint8* pDst_buf, size_t *pDst_len, const lzham_uint8* pSrc_buf, size_t src_len, lzham_uint32 *pAdler32);

   int lzham_lib_z_deflateInit(lzham_z_streamp pStream, int level);
   int lzham_lib_z_deflateInit2(lzham_z_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);
   int lzham_lib_z_deflateReset(lzham_z_streamp pStream);
   int lzham_lib_z_deflate(lzham_z_streamp pStream, int flush);
   int lzham_lib_z_deflateEnd(lzham_z_streamp pStream);
   lzham_z_ulong lzham_lib_z_deflateBound(lzham_z_streamp pStream, lzham_z_ulong source_len);
   int lzham_lib_z_compress2(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len, int level);
   int lzham_lib_z_compress(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len);
   lzham_z_ulong lzham_lib_z_compressBound(lzham_z_ulong source_len);

} // namespace lzham
// File: lzham_lzbase.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_lzbase.h"

namespace lzham
{
	uint8 CLZBase::m_slot_tab0[4096] = 
	{
		0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9,
		10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
		12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
		13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
		14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
		14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
		15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
		15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
		16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
		16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
		16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
		16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
		17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
		17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
		17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
		17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
		18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
		18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
		18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
		18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
		18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
		18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
		18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
		18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23
	};

	uint8 CLZBase::m_slot_tab1[512] = 
	{
		0, 0, 24, 25, 26, 26, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31,
		32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
		34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
		35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
		36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
		36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
		37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
		37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
		38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
		38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
		38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
		38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
		39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
		39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
		39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
		39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39
	};

	uint8 CLZBase::m_slot_tab2[256] =
	{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 41, 41, 41,
		42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
		44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
		45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
		46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
		46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
		47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
		47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47
	};

   void CLZBase::init_slot_tabs()
   {
#if 0
      for (uint i = 0; i < m_num_lzx_slots; i++)
      {
         //printf("%u: 0x%08X - 0x%08X, %u\n", i, m_lzx_position_base[i], m_lzx_position_base[i] + (1 << m_lzx_position_extra_bits[i]) - 1, m_lzx_position_extra_bits[i]);

         uint lo = m_lzx_position_base[i];
         uint hi = lo + m_lzx_position_extra_mask[i];

         uint8* pTab;
         uint shift;
         uint n; LZHAM_NOTE_UNUSED(n);

         if (hi < 0x1000)
         {
            pTab = m_slot_tab0;
            shift = 0;
            n = sizeof(m_slot_tab0);
         }
         else if (hi < 0x100000)
         {
            pTab = m_slot_tab1;
            shift = 11;
            n = sizeof(m_slot_tab1);
         }
         else if (hi < 0x1000000)
         {
            pTab = m_slot_tab2;
            shift = 16;
            n = sizeof(m_slot_tab2);
         }
         else
            break;

         lo >>= shift;
         hi >>= shift;

         LZHAM_ASSERT(hi < n);
         memset(pTab + lo, (uint8)i, hi - lo + 1);
      }

		for (uint i = 0; i < 256; i++)
		{
			printf("%u, ", m_slot_tab2[i]);
			if ((i & 31) == 31) printf("\n");
		}
#endif

#ifdef LZHAM_BUILD_DEBUG      
      uint slot, ofs;
      for (uint i = 1; i < m_num_lzx_slots; i++) 
      {
         compute_lzx_position_slot(m_lzx_position_base[i], slot, ofs);
         LZHAM_ASSERT(slot == i);

         compute_lzx_position_slot(m_lzx_position_base[i] + m_lzx_position_extra_mask[i], slot, ofs);
         LZHAM_ASSERT(slot == i);
      }

      for (uint i = 1; i <= (m_dict_size-1); i += 512U*1024U)
      {
         compute_lzx_position_slot(i, slot, ofs);
         LZHAM_ASSERT(i == m_lzx_position_base[slot] + ofs);
      }

      compute_lzx_position_slot(m_dict_size - 1, slot, ofs);
      LZHAM_ASSERT((m_dict_size - 1) == m_lzx_position_base[slot] + ofs);
#endif      
   }

} //namespace lzham

// File: lzham_lzbase.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

#include "lzham_lzdecompbase.h"

//#define LZHAM_LZVERIFY
//#define LZHAM_DISABLE_RAW_BLOCKS

namespace lzham
{

   struct CLZBase : CLZDecompBase
   {
      static uint8 m_slot_tab0[4096];
      static uint8 m_slot_tab1[512];
      static uint8 m_slot_tab2[256];

      void init_slot_tabs();

      inline void compute_lzx_position_slot(uint dist, uint& slot, uint& ofs)
      {
         uint s;
         if (dist < 0x1000)
            s = m_slot_tab0[dist];
         else if (dist < 0x100000)
            s = m_slot_tab1[dist >> 11];
         else if (dist < 0x1000000)
            s = m_slot_tab2[dist >> 16];
         else if (dist < 0x2000000)
            s = 48 + ((dist - 0x1000000) >> 23);
         else if (dist < 0x4000000)
            s = 50 + ((dist - 0x2000000) >> 24);
         else 
            s = 52 + ((dist - 0x4000000) >> 25);

         ofs = (dist - m_lzx_position_base[s]) & m_lzx_position_extra_mask[s];
         slot = s;

         LZHAM_ASSERT(s < m_num_lzx_slots);
         LZHAM_ASSERT((m_lzx_position_base[slot] + ofs) == dist);
         LZHAM_ASSERT(ofs < (1U << m_lzx_position_extra_bits[slot]));
      }
   };

} // namespace lzham
// File: lzham_lzcomp.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham.h"
#include "lzham_comp.h"
#include "lzham_lzcomp_internal.h"

using namespace lzham;

namespace lzham
{
   struct lzham_compress_state
   {
      lzham_compress_state(lzham_malloc_context malloc_context) : 
         m_tp(malloc_context),
         m_malloc_context(malloc_context),
         m_compressor(malloc_context)
      {
      }

      // task_pool requires 8 or 16 alignment
      task_pool m_tp;
      
      lzham_malloc_context m_malloc_context;

      lzcompressor m_compressor;

      uint m_dict_size_log2;

      const uint8 *m_pIn_buf;
      size_t *m_pIn_buf_size;
      uint8 *m_pOut_buf;
      size_t *m_pOut_buf_size;

      size_t m_comp_data_ofs;

      bool m_finished_compression;

      lzham_compress_params m_params;

      lzham_compress_status_t m_status;
   };
   
   static lzham_compress_status_t create_internal_init_params(lzcompressor::init_params &internal_params, const lzham_compress_params *pParams)
   {
      if ((pParams->m_dict_size_log2 < CLZBase::cMinDictSizeLog2) || (pParams->m_dict_size_log2 > CLZBase::cMaxDictSizeLog2))
      {
         LZHAM_LOG_ERROR(6000);
         return LZHAM_COMP_STATUS_INVALID_PARAMETER;
      }
      
      if (pParams->m_extreme_parsing_max_best_arrivals > cMaxParseNodeStates)
      {
         LZHAM_LOG_ERROR(6001);
         return LZHAM_COMP_STATUS_INVALID_PARAMETER;
      }
      
      if (pParams->m_extreme_parsing_max_best_arrivals <= 1)
         internal_params.m_extreme_parsing_max_best_arrivals = cDefaultMaxParseNodeStates;
      else
         internal_params.m_extreme_parsing_max_best_arrivals = pParams->m_extreme_parsing_max_best_arrivals;			     

      if (pParams->m_fast_bytes > 0)
         internal_params.m_fast_bytes_override = math::clamp<uint>(pParams->m_fast_bytes, LZHAM_MIN_FAST_BYTES, LZHAM_MAX_FAST_BYTES);

      internal_params.m_dict_size_log2 = pParams->m_dict_size_log2;
      
      if (pParams->m_max_helper_threads < 0)
         internal_params.m_max_helper_threads = lzham_get_max_helper_threads();
      else
         internal_params.m_max_helper_threads = pParams->m_max_helper_threads;
      internal_params.m_max_helper_threads = LZHAM_MIN(LZHAM_MAX_HELPER_THREADS, internal_params.m_max_helper_threads);

      internal_params.m_lzham_compress_flags = pParams->m_compress_flags;

      if (pParams->m_num_seed_bytes)
      {
         if ((!pParams->m_pSeed_bytes) || (pParams->m_num_seed_bytes > (1U << pParams->m_dict_size_log2)))
         {
            LZHAM_LOG_ERROR(6002);
            return LZHAM_COMP_STATUS_INVALID_PARAMETER;
         }

         internal_params.m_num_seed_bytes = pParams->m_num_seed_bytes;
         internal_params.m_pSeed_bytes = pParams->m_pSeed_bytes;
      }

      switch (pParams->m_level)
      {
         case LZHAM_COMP_LEVEL_FASTEST:   internal_params.m_compression_level = cCompressionLevelFastest; break;
         case LZHAM_COMP_LEVEL_FASTER:    internal_params.m_compression_level = cCompressionLevelFaster; break;
         case LZHAM_COMP_LEVEL_DEFAULT:   internal_params.m_compression_level = cCompressionLevelDefault; break;
         case LZHAM_COMP_LEVEL_BETTER:    internal_params.m_compression_level = cCompressionLevelBetter; break;
         case LZHAM_COMP_LEVEL_UBER:      internal_params.m_compression_level = cCompressionLevelUber; break;
         default:
            LZHAM_LOG_ERROR(6003);
            return LZHAM_COMP_STATUS_INVALID_PARAMETER;
      };

		if (pParams->m_table_max_update_interval || pParams->m_table_update_interval_slow_rate)
		{
			internal_params.m_table_max_update_interval = pParams->m_table_max_update_interval;
			internal_params.m_table_update_interval_slow_rate = pParams->m_table_update_interval_slow_rate;
		}
		else 
		{
			uint rate = pParams->m_table_update_rate;
			if (!rate)
				rate = LZHAM_DEFAULT_TABLE_UPDATE_RATE;
			rate = math::clamp<uint>(rate, 1, LZHAM_FASTEST_TABLE_UPDATE_RATE) - 1;
			internal_params.m_table_max_update_interval = g_table_update_settings[rate].m_max_update_interval;
			internal_params.m_table_update_interval_slow_rate = g_table_update_settings[rate].m_slow_rate;
		}

      return LZHAM_COMP_STATUS_SUCCESS;
   }

   lzham_compress_state_ptr LZHAM_CDECL lzham_lib_compress_init(const lzham_compress_params *pParams)
   {
      if ((!pParams) || (pParams->m_struct_size != sizeof(lzham_compress_params)))
      {
         LZHAM_LOG_ERROR(6004);
         return NULL;
      }

      if ((pParams->m_dict_size_log2 < CLZBase::cMinDictSizeLog2) || (pParams->m_dict_size_log2 > CLZBase::cMaxDictSizeLog2))
      {
         LZHAM_LOG_ERROR(6005);
         return NULL;
      }

      lzcompressor::init_params internal_params;
      lzham_compress_status_t status = create_internal_init_params(internal_params, pParams);
      if (status != LZHAM_COMP_STATUS_SUCCESS)
      {
         LZHAM_LOG_ERROR(6006);
         return NULL;
      }

      lzham_malloc_context malloc_context = lzham_create_malloc_context(0);

      lzham_compress_state *pState = lzham_new<lzham_compress_state>(malloc_context, malloc_context);
      if (!pState)
      {
         lzham_destroy_malloc_context(malloc_context);
         LZHAM_LOG_ERROR(6007);
         return NULL;
      }

      pState->m_params = *pParams;

      pState->m_pIn_buf = NULL;
      pState->m_pIn_buf_size = NULL;
      pState->m_pOut_buf = NULL;
      pState->m_pOut_buf_size = NULL;
      pState->m_status = LZHAM_COMP_STATUS_NOT_FINISHED;
      pState->m_comp_data_ofs = 0;
      pState->m_finished_compression = false;

      if (internal_params.m_max_helper_threads)
      {
         if (!pState->m_tp.init(internal_params.m_max_helper_threads))
         {
            lzham_delete(malloc_context, pState);
            lzham_destroy_malloc_context(malloc_context);
            LZHAM_LOG_ERROR(6008);
            return NULL;
         }
         if (pState->m_tp.get_num_threads() >= internal_params.m_max_helper_threads)
         {
            internal_params.m_pTask_pool = &pState->m_tp;
         }
         else
         {
            internal_params.m_max_helper_threads = 0;
         }
      }

      if (!pState->m_compressor.init(internal_params))
      {
         lzham_delete(malloc_context, pState);
         lzham_destroy_malloc_context(malloc_context);
         LZHAM_LOG_ERROR(6009);
         return NULL;
      }

      return pState;
   }

   lzham_compress_state_ptr LZHAM_CDECL lzham_lib_compress_reinit(lzham_compress_state_ptr p)
   {
      lzham_compress_state *pState = static_cast<lzham_compress_state*>(p);
      if (pState)
      {
         if (!pState->m_compressor.reset())
         {
            LZHAM_LOG_ERROR(6010);
            return NULL;
         }

         pState->m_pIn_buf = NULL;
         pState->m_pIn_buf_size = NULL;
         pState->m_pOut_buf = NULL;
         pState->m_pOut_buf_size = NULL;
         pState->m_status = LZHAM_COMP_STATUS_NOT_FINISHED;
         pState->m_comp_data_ofs = 0;
         pState->m_finished_compression = false;
      }

      return pState;
   }

   lzham_uint32 LZHAM_CDECL lzham_lib_compress_deinit(lzham_compress_state_ptr p)
   {
      lzham_compress_state *pState = static_cast<lzham_compress_state *>(p);
      if (!pState)
      {
         LZHAM_LOG_ERROR(6011);
         return 0;
      }

      uint32 adler32 = pState->m_compressor.get_src_adler32();

      lzham_malloc_context malloc_context = pState->m_malloc_context;

      lzham_delete(malloc_context, pState);
      lzham_destroy_malloc_context(malloc_context);
      
      return adler32;
   }

   lzham_compress_status_t LZHAM_CDECL lzham_lib_compress(
      lzham_compress_state_ptr p,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size,
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_bool no_more_input_bytes_flag)
   {
      return lzham_lib_compress2(p, pIn_buf, pIn_buf_size, pOut_buf, pOut_buf_size, no_more_input_bytes_flag ? LZHAM_FINISH : LZHAM_NO_FLUSH);
   }

   lzham_compress_status_t LZHAM_CDECL lzham_lib_compress2(
      lzham_compress_state_ptr p,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size,
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_flush_t flush_type)
   {
      lzham_compress_state *pState = static_cast<lzham_compress_state*>(p);

      if ((!pState) || (!pState->m_params.m_dict_size_log2) || (pState->m_status >= LZHAM_COMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE) || (!pIn_buf_size) || (!pOut_buf_size))
      {
         LZHAM_LOG_ERROR(6012);
         return LZHAM_COMP_STATUS_INVALID_PARAMETER;
      }

      if ((*pIn_buf_size) && (!pIn_buf))
      {
         LZHAM_LOG_ERROR(6013);
         return LZHAM_COMP_STATUS_INVALID_PARAMETER;
      }

      if ((!*pOut_buf_size) || (!pOut_buf))
      {
         LZHAM_LOG_ERROR(6014);
         return LZHAM_COMP_STATUS_INVALID_PARAMETER;
      }

      byte_vec &comp_data = pState->m_compressor.get_compressed_data();
      size_t num_bytes_written_to_out_buf = 0;
      if (pState->m_comp_data_ofs < comp_data.size())
      {
         size_t n = LZHAM_MIN(comp_data.size() - pState->m_comp_data_ofs, *pOut_buf_size);

         memcpy(pOut_buf, comp_data.get_ptr() + pState->m_comp_data_ofs, n);

         pState->m_comp_data_ofs += n;

         const bool has_no_more_output = (pState->m_comp_data_ofs >= comp_data.size());
         if (has_no_more_output)
         {
            pOut_buf += n;
            *pOut_buf_size -= n;
            num_bytes_written_to_out_buf += n;
         }
         else
         {
            *pIn_buf_size = 0;
            *pOut_buf_size = n;
            pState->m_status = LZHAM_COMP_STATUS_HAS_MORE_OUTPUT;
            return pState->m_status;
         }
      }

      comp_data.try_resize(0);
      pState->m_comp_data_ofs = 0;

      if (pState->m_finished_compression)
      {
         if ((*pIn_buf_size) || (flush_type != LZHAM_FINISH))
         {
            pState->m_status = LZHAM_COMP_STATUS_INVALID_PARAMETER;
            LZHAM_LOG_ERROR(6015);
            return pState->m_status;
         }

         *pIn_buf_size = 0;
         *pOut_buf_size = num_bytes_written_to_out_buf;

         pState->m_status = LZHAM_COMP_STATUS_SUCCESS;
         return pState->m_status;
      }

      const size_t cMaxBytesToPutPerIteration = 4*1024*1024;
      size_t bytes_to_put = LZHAM_MIN(cMaxBytesToPutPerIteration, *pIn_buf_size);
      const bool consumed_entire_input_buf = (bytes_to_put == *pIn_buf_size);

      if (bytes_to_put)
      {
         if (!pState->m_compressor.put_bytes(pIn_buf, (uint)bytes_to_put))
         {
            *pIn_buf_size = 0;
            *pOut_buf_size = num_bytes_written_to_out_buf;
            pState->m_status = LZHAM_COMP_STATUS_FAILED;
            LZHAM_LOG_ERROR(6016);
            return pState->m_status;
         }
      }

      if ((consumed_entire_input_buf) && (flush_type != LZHAM_NO_FLUSH))
      {
         if ((flush_type == LZHAM_SYNC_FLUSH) || (flush_type == LZHAM_FULL_FLUSH) || (flush_type == LZHAM_TABLE_FLUSH))
         {
            if (!pState->m_compressor.flush(flush_type))
            {
               *pIn_buf_size = 0;
               *pOut_buf_size = num_bytes_written_to_out_buf;
               pState->m_status = LZHAM_COMP_STATUS_FAILED;
               LZHAM_LOG_ERROR(6017);
               return pState->m_status;
            }
         }
         else if (!pState->m_finished_compression)
         {
            if (!pState->m_compressor.put_bytes(NULL, 0))
            {
               *pIn_buf_size = 0;
               *pOut_buf_size = num_bytes_written_to_out_buf;
               pState->m_status = LZHAM_COMP_STATUS_FAILED;
               LZHAM_LOG_ERROR(6018);
               return pState->m_status;
            }
            pState->m_finished_compression = true;
         }
      }

      size_t num_comp_bytes_to_output = LZHAM_MIN(comp_data.size() - pState->m_comp_data_ofs, *pOut_buf_size);
      if (num_comp_bytes_to_output)
      {
         memcpy(pOut_buf, comp_data.get_ptr() + pState->m_comp_data_ofs, num_comp_bytes_to_output);

         pState->m_comp_data_ofs += num_comp_bytes_to_output;
      }

      *pIn_buf_size = bytes_to_put;
      *pOut_buf_size = num_bytes_written_to_out_buf + num_comp_bytes_to_output;

      const bool has_no_more_output = (pState->m_comp_data_ofs >= comp_data.size());
      if ((has_no_more_output) && (flush_type == LZHAM_FINISH) && (pState->m_finished_compression))
         pState->m_status = LZHAM_COMP_STATUS_SUCCESS;
      else if ((has_no_more_output) && (consumed_entire_input_buf) && (flush_type == LZHAM_NO_FLUSH))
         pState->m_status = LZHAM_COMP_STATUS_NEEDS_MORE_INPUT;
      else
         pState->m_status = has_no_more_output ? LZHAM_COMP_STATUS_NOT_FINISHED : LZHAM_COMP_STATUS_HAS_MORE_OUTPUT;

      return pState->m_status;
   }

   lzham_compress_status_t LZHAM_CDECL lzham_lib_compress_memory(const lzham_compress_params *pParams, lzham_uint8* pDst_buf, size_t *pDst_len, const lzham_uint8* pSrc_buf, size_t src_len, lzham_uint32 *pAdler32)
   {
      if ((!pParams) || (!pDst_len))
      {
         LZHAM_LOG_ERROR(6019);
         return LZHAM_COMP_STATUS_INVALID_PARAMETER;
      }

      if (src_len)
      {
         if (!pSrc_buf)
         {
            LZHAM_LOG_ERROR(6020);
            return LZHAM_COMP_STATUS_INVALID_PARAMETER;
         }
      }

      if (sizeof(size_t) > sizeof(uint32))
      {
         if (src_len > cUINT32_MAX)
         {
            LZHAM_LOG_ERROR(6021);
            return LZHAM_COMP_STATUS_INVALID_PARAMETER;
         }
      }

      lzcompressor::init_params internal_params;
      lzham_compress_status_t status = create_internal_init_params(internal_params, pParams);
      if (status != LZHAM_COMP_STATUS_SUCCESS)
      {
         LZHAM_LOG_ERROR(6022);
         return status;
      }

      lzham_malloc_context malloc_context = lzham_create_malloc_context(0);

      task_pool *pTP = NULL;
      if (internal_params.m_max_helper_threads)
      {
         pTP = lzham_new<task_pool>(malloc_context, malloc_context);
         if (!pTP->init(internal_params.m_max_helper_threads))
         {
            lzham_destroy_malloc_context(malloc_context);
            LZHAM_LOG_ERROR(6023);
            return LZHAM_COMP_STATUS_FAILED_INITIALIZING;
         }

         internal_params.m_pTask_pool = pTP;
      }

      lzcompressor *pCompressor = lzham_new<lzcompressor>(malloc_context, malloc_context);
      if (!pCompressor)
      {
         lzham_delete(malloc_context, pTP);
         lzham_destroy_malloc_context(malloc_context);
         LZHAM_LOG_ERROR(6024);
         return LZHAM_COMP_STATUS_FAILED_INITIALIZING;
      }

      if (!pCompressor->init(internal_params))
      {
         lzham_delete(malloc_context, pTP);
         lzham_delete(malloc_context, pCompressor);
         lzham_destroy_malloc_context(malloc_context);
         LZHAM_LOG_ERROR(6025);
         return LZHAM_COMP_STATUS_INVALID_PARAMETER;
      }

      if (src_len)
      {
         if (!pCompressor->put_bytes(pSrc_buf, static_cast<uint32>(src_len)))
         {
            *pDst_len = 0;
            lzham_delete(malloc_context, pTP);
            lzham_delete(malloc_context, pCompressor);
            lzham_destroy_malloc_context(malloc_context);
            LZHAM_LOG_ERROR(6026);
            return LZHAM_COMP_STATUS_FAILED;
         }
      }

      if (!pCompressor->put_bytes(NULL, 0))
      {
         *pDst_len = 0;
         lzham_delete(malloc_context, pTP);
         lzham_delete(malloc_context, pCompressor);
         lzham_destroy_malloc_context(malloc_context);
         LZHAM_LOG_ERROR(6027);
         return LZHAM_COMP_STATUS_FAILED;
      }

      const byte_vec &comp_data = pCompressor->get_compressed_data();

      size_t dst_buf_size = *pDst_len;
      *pDst_len = comp_data.size();

      if (pAdler32)
         *pAdler32 = pCompressor->get_src_adler32();

      if (comp_data.size() > dst_buf_size)
      {
         lzham_delete(malloc_context, pTP);
         lzham_delete(malloc_context, pCompressor);
         lzham_destroy_malloc_context(malloc_context);
         LZHAM_LOG_ERROR(6028);
         return LZHAM_COMP_STATUS_OUTPUT_BUF_TOO_SMALL;
      }

      memcpy(pDst_buf, comp_data.get_ptr(), comp_data.size());

      lzham_delete(malloc_context, pTP);
      lzham_delete(malloc_context, pCompressor);
      lzham_destroy_malloc_context(malloc_context);
      return LZHAM_COMP_STATUS_SUCCESS;
   }

   // ----------------- zlib-style API's

   int lzham_lib_z_deflateInit(lzham_z_streamp pStream, int level)
   {
      return lzham_lib_z_deflateInit2(pStream, level, LZHAM_Z_LZHAM, LZHAM_Z_DEFAULT_WINDOW_BITS, 9, LZHAM_Z_DEFAULT_STRATEGY);
   }

   int lzham_lib_z_deflateInit2(lzham_z_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
   {
      LZHAM_NOTE_UNUSED(strategy);

      if (!pStream)
      {
         LZHAM_LOG_ERROR(6029);
         return LZHAM_Z_STREAM_ERROR;
      }
      if ((mem_level < 1) || (mem_level > 9))
      {
         LZHAM_LOG_ERROR(6030);
         return LZHAM_Z_PARAM_ERROR;
      }
      if ((method != LZHAM_Z_DEFLATED) && (method != LZHAM_Z_LZHAM))
      {
         LZHAM_LOG_ERROR(6031);
         return LZHAM_Z_PARAM_ERROR;
      }

      if (level == LZHAM_Z_DEFAULT_COMPRESSION)
         level = 9;

      if (method == LZHAM_Z_DEFLATED)
      {
         // Force Deflate to LZHAM with default window_bits.
         method = LZHAM_Z_LZHAM;
         window_bits = LZHAM_Z_DEFAULT_WINDOW_BITS;
      }

#ifdef LZHAM_Z_API_FORCE_WINDOW_BITS
      window_bits = LZHAM_Z_API_FORCE_WINDOW_BITS;
#endif

      int max_window_bits = LZHAM_64BIT_POINTERS ? LZHAM_MAX_DICT_SIZE_LOG2_X64 : LZHAM_MAX_DICT_SIZE_LOG2_X86;
      if ((labs(window_bits) < LZHAM_MIN_DICT_SIZE_LOG2) || (labs(window_bits) > max_window_bits))
      {
         LZHAM_LOG_ERROR(6032);
         return LZHAM_Z_PARAM_ERROR;
      }

      lzham_compress_params comp_params;

      utils::zero_object(comp_params);
      comp_params.m_struct_size = sizeof(lzham_compress_params);

      comp_params.m_level = LZHAM_COMP_LEVEL_UBER;
      if (level <= 1)
         comp_params.m_level = LZHAM_COMP_LEVEL_FASTEST;
      else if (level <= 3)
         comp_params.m_level = LZHAM_COMP_LEVEL_FASTER;
      else if (level <= 5)
         comp_params.m_level = LZHAM_COMP_LEVEL_DEFAULT;
      else if (level <= 7)
         comp_params.m_level = LZHAM_COMP_LEVEL_BETTER;

      if (level == 10)
         comp_params.m_compress_flags |= LZHAM_COMP_FLAG_EXTREME_PARSING;

      // Use all CPU's. TODO: This is not always the best idea depending on the dictionary size and the # of bytes to compress.
      comp_params.m_max_helper_threads = -1;

      comp_params.m_dict_size_log2 = static_cast<lzham_uint32>(labs(window_bits));

      if (window_bits > 0)
         comp_params.m_compress_flags |= LZHAM_COMP_FLAG_WRITE_ZLIB_STREAM;

      pStream->data_type = 0;
      pStream->adler = LZHAM_Z_ADLER32_INIT;
      pStream->msg = NULL;
      pStream->reserved = 0;
      pStream->total_in = 0;
      pStream->total_out = 0;

      lzham_compress_state_ptr pComp = lzham_lib_compress_init(&comp_params);
      if (!pComp)
      {
         LZHAM_LOG_ERROR(6033);
         return LZHAM_Z_PARAM_ERROR;
      }

      pStream->state = (struct lzham_z_internal_state *)pComp;

      return LZHAM_Z_OK;
   }

   int lzham_lib_z_deflateReset(lzham_z_streamp pStream)
   {
      if (!pStream)
      {
         LZHAM_LOG_ERROR(6034);
         return LZHAM_Z_STREAM_ERROR;
      }

      lzham_compress_state_ptr pComp = (lzham_compress_state_ptr)pStream->state;
      if (!pComp)
      {
         LZHAM_LOG_ERROR(6035);
         return LZHAM_Z_STREAM_ERROR;
      }

      pComp = lzham_lib_compress_reinit(pComp);
      if (!pComp)
      {
         LZHAM_LOG_ERROR(6036);
         return LZHAM_Z_STREAM_ERROR;
      }

      pStream->state = (struct lzham_z_internal_state *)pComp;

      return LZHAM_Z_OK;
   }

   int lzham_lib_z_deflate(lzham_z_streamp pStream, int flush)
   {
      if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > LZHAM_Z_FINISH) || (!pStream->next_out))
      {
         LZHAM_LOG_ERROR(6037);
         return LZHAM_Z_STREAM_ERROR;
      }

      if (!pStream->avail_out)
      {
         LZHAM_LOG_ERROR(6038);
         return LZHAM_Z_BUF_ERROR;
      }

      if (flush == LZHAM_Z_PARTIAL_FLUSH)
         flush = LZHAM_Z_SYNC_FLUSH;

      int lzham_status = LZHAM_Z_OK;
      lzham_z_ulong orig_total_in = pStream->total_in, orig_total_out = pStream->total_out;
      for ( ; ; )
      {
         size_t in_bytes = pStream->avail_in, out_bytes = pStream->avail_out;

         lzham_compress_state_ptr pComp = (lzham_compress_state_ptr)pStream->state;
         lzham_compress_state *pState = static_cast<lzham_compress_state*>(pComp);

         lzham_compress_status_t status = lzham_lib_compress2(
            pComp,
            pStream->next_in, &in_bytes,
            pStream->next_out, &out_bytes,
            (lzham_flush_t)flush);

         pStream->next_in += (uint)in_bytes;
         pStream->avail_in -= (uint)in_bytes;
         pStream->total_in += (uint)in_bytes;

         pStream->next_out += (uint)out_bytes;
         pStream->avail_out -= (uint)out_bytes;
         pStream->total_out += (uint)out_bytes;

         pStream->adler = pState->m_compressor.get_src_adler32();

         if (status >= LZHAM_COMP_STATUS_FIRST_FAILURE_CODE)
         {
            lzham_status = LZHAM_Z_STREAM_ERROR;
            LZHAM_LOG_ERROR(6039);
            break;
         }
         else if (status == LZHAM_COMP_STATUS_SUCCESS)
         {
            lzham_status = LZHAM_Z_STREAM_END;
            break;
         }
         else if (!pStream->avail_out)
            break;
         else if ((!pStream->avail_in) && (flush != LZHAM_Z_FINISH))
         {
            if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
               break;
            LZHAM_LOG_ERROR(6040);
            return LZHAM_Z_BUF_ERROR; // Can't make forward progress without some input.
         }
      }
      return lzham_status;
   }

   int lzham_lib_z_deflateEnd(lzham_z_streamp pStream)
   {
      if (!pStream)
      {
         LZHAM_LOG_ERROR(6041);
         return LZHAM_Z_STREAM_ERROR;
      }

      lzham_compress_state_ptr pComp = (lzham_compress_state_ptr)pStream->state;
      if (pComp)
      {
         pStream->adler = lzham_lib_compress_deinit(pComp);

         pStream->state = NULL;
      }

      return LZHAM_Z_OK;
   }

   lzham_z_ulong lzham_lib_z_deflateBound(lzham_z_streamp pStream, lzham_z_ulong source_len)
   {
      LZHAM_NOTE_UNUSED(pStream);
      return 64 + source_len + ((source_len + 4095) / 4096) * 4;
   }

   int lzham_lib_z_compress2(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len, int level)
   {
      int status;
      lzham_z_stream stream;
      memset(&stream, 0, sizeof(stream));

      // In case lzham_z_ulong is 64-bits (argh I hate longs).
      if ((source_len | *pDest_len) > 0xFFFFFFFFU)
      {
         LZHAM_LOG_ERROR(6042);
         return LZHAM_Z_PARAM_ERROR;
      }

      stream.next_in = pSource;
      stream.avail_in = (uint)source_len;
      stream.next_out = pDest;
      stream.avail_out = (uint)*pDest_len;

      status = lzham_lib_z_deflateInit(&stream, level);
      if (status != LZHAM_Z_OK)
      {
         LZHAM_LOG_ERROR(6043);
         return status;
      }

      status = lzham_lib_z_deflate(&stream, LZHAM_Z_FINISH);
      if (status != LZHAM_Z_STREAM_END)
      {
         lzham_lib_z_deflateEnd(&stream);
         return (status == LZHAM_Z_OK) ? LZHAM_Z_BUF_ERROR : status;
      }

      *pDest_len = stream.total_out;
      return lzham_lib_z_deflateEnd(&stream);
   }

   int lzham_lib_z_compress(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len)
   {
      return lzham_lib_z_compress2(pDest, pDest_len, pSource, source_len, (int)LZHAM_Z_DEFAULT_COMPRESSION);
   }

   lzham_z_ulong lzham_lib_z_compressBound(lzham_z_ulong source_len)
   {
      return lzham_lib_z_deflateBound(NULL, source_len);
   }

} // namespace lzham
// File: lzham_lzcomp_internal.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_lzcomp_internal.h"
#include "lzham_checksum.h"
#include "lzham_timer.h"
#include "lzham_lzbase.h"
#include <string.h>

// Update and print high-level coding statistics if set to 1.
// TODO: Add match distance coding statistics.
#define LZHAM_UPDATE_STATS                   0

// Only parse on the main thread, for easier debugging.
#define LZHAM_FORCE_SINGLE_THREADED_PARSING  0

// Verify all computed match costs against the generic/slow state::get_cost() method.
#define LZHAM_VERIFY_MATCH_COSTS             0

// Set to 1 to force all blocks to be uncompressed (raw).
#define LZHAM_FORCE_ALL_RAW_BLOCKS           0

#define LZHAM_EXTREME_PARSING_FAST_BYTES     96

namespace lzham
{
   static comp_settings s_level_settings[cCompressionLevelCount] =
   {
      // cCompressionLevelFastest
      {
         8,                               // m_fast_bytes
         1,                               // m_match_accel_max_matches_per_probe
         2,                               // m_match_accel_max_probes
      },
      // cCompressionLevelFaster
      {
         24,                              // m_fast_bytes
         6,                               // m_match_accel_max_matches_per_probe
         12,                              // m_match_accel_max_probes
      },
      // cCompressionLevelDefault
      {
         32,                              // m_fast_bytes
         UINT_MAX,                        // m_match_accel_max_matches_per_probe
         16,                              // m_match_accel_max_probes
      },
      // cCompressionLevelBetter
      {
         48,                              // m_fast_bytes
         UINT_MAX,                        // m_match_accel_max_matches_per_probe
         32,                              // m_match_accel_max_probes
      },
      // cCompressionLevelUber
      {
         64,                              // m_fast_bytes
         UINT_MAX,                        // m_match_accel_max_matches_per_probe
         cMatchAccelMaxSupportedProbes,   // m_match_accel_max_probes
      }
   };

   lzcompressor::lzcompressor(lzham_malloc_context malloc_context) :
      m_malloc_context(malloc_context),
      m_src_size(-1),
      m_src_adler32(0),
      m_accel(malloc_context),
      m_codec(malloc_context),
      m_block_buf(malloc_context),
      m_comp_buf(malloc_context),
      m_step(0),
      m_block_start_dict_ofs(0),
      m_block_index(0),
      m_finished(false),
      m_use_task_pool(false),
      m_use_extreme_parsing(false),
      m_start_of_block_state(malloc_context),
      m_state(malloc_context),
      m_fast_bytes(128),
      m_num_parse_threads(0)
   {
      LZHAM_VERIFY( ((uint32_ptr)this & (LZHAM_GET_ALIGNMENT(lzcompressor) - 1)) == 0);

      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_parse_thread_state); i++)
         m_parse_thread_state[i].set_malloc_context(malloc_context);
   }

   bool lzcompressor::init_seed_bytes()
   {
      uint cur_seed_ofs = 0;

      while (cur_seed_ofs < m_params.m_num_seed_bytes)
      {
         uint total_bytes_remaining = m_params.m_num_seed_bytes - cur_seed_ofs;
         uint num_bytes_to_add = math::minimum(total_bytes_remaining, m_params.m_block_size);

         if (!m_accel.add_bytes_begin(num_bytes_to_add, static_cast<const uint8*>(m_params.m_pSeed_bytes) + cur_seed_ofs))
         {
            LZHAM_LOG_ERROR(7000);
            return false;
         }
         m_accel.add_bytes_end();

         m_accel.advance_bytes(num_bytes_to_add);

         cur_seed_ofs += num_bytes_to_add;
      }

      return true;
   }

   bool lzcompressor::raw_parse_thread_state::init(lzcompressor& lzcomp, const lzcompressor::init_params &params)
   {
      if (!m_state.init(lzcomp, params.m_table_max_update_interval, params.m_table_update_interval_slow_rate))
         return false;

      if (lzcomp.m_use_extreme_parsing)
      {
         for (uint j = 0; j < LZHAM_ARRAY_SIZE(m_nodes); j++)
            m_nodes[j].clear();
      }
      else
      {
         node_state *pNodes = reinterpret_cast<node_state*>(m_nodes);

         memset(pNodes, 0xFF, (1 + cMaxParseGraphNodes) * sizeof(node_state));
      }

      return true;
   }

   bool lzcompressor::init(const init_params& params)
   {
      clear();

      if ((params.m_dict_size_log2 < CLZBase::cMinDictSizeLog2) || (params.m_dict_size_log2 > CLZBase::cMaxDictSizeLog2))
      {
         LZHAM_LOG_ERROR(7001);
         return false;
      }

      if ((params.m_compression_level < 0) || (params.m_compression_level > cCompressionLevelCount))
      {
         LZHAM_LOG_ERROR(7002);
         return false;
      }

      m_params = params;
      m_use_task_pool = (m_params.m_pTask_pool) && (m_params.m_pTask_pool->get_num_threads() != 0) && (m_params.m_max_helper_threads > 0);

      m_use_extreme_parsing = ((m_params.m_lzham_compress_flags & LZHAM_COMP_FLAG_EXTREME_PARSING) && (m_params.m_compression_level == cCompressionLevelUber));

      if (!m_use_task_pool)
         m_params.m_max_helper_threads = 0;

      m_settings = s_level_settings[params.m_compression_level];

      m_fast_bytes = m_use_extreme_parsing ? LZHAM_EXTREME_PARSING_FAST_BYTES : m_settings.m_fast_bytes;
      if (m_params.m_fast_bytes_override)
      {
         m_fast_bytes = math::clamp<uint>(m_params.m_fast_bytes_override, 8, CLZBase::cMaxMatchLen + 1);
      }

      const uint dict_size = 1U << m_params.m_dict_size_log2;

      if (params.m_num_seed_bytes)
      {
         if (!params.m_pSeed_bytes)
         {
            LZHAM_LOG_ERROR(7003);
            return false;
         }
         if (params.m_num_seed_bytes > dict_size)
         {
            LZHAM_LOG_ERROR(7004);
            return false;
         }
      }

      uint max_block_size = dict_size / 8;
      if (m_params.m_block_size > max_block_size)
      {
         m_params.m_block_size = max_block_size;
      }

      m_num_parse_threads = 1;

#if !LZHAM_FORCE_SINGLE_THREADED_PARSING
      if ((m_params.m_max_helper_threads > 0) && ((m_params.m_lzham_compress_flags & LZHAM_COMP_FLAG_FORCE_SINGLE_THREADED_PARSING) == 0))
      {
         LZHAM_ASSUME(cMaxParseThreads >= 4);

         if (m_params.m_block_size < 16384)
            m_num_parse_threads = LZHAM_MIN(cMaxParseThreads, m_params.m_max_helper_threads + 1);
         else if ((m_params.m_max_helper_threads <= 5) || (m_params.m_compression_level == cCompressionLevelFastest))
            m_num_parse_threads = 1;
         else
            m_num_parse_threads = m_use_extreme_parsing ? 4 : 2;
      }
#endif

      int num_parse_jobs = m_num_parse_threads - 1;
      uint match_accel_helper_threads = LZHAM_MAX(0, (int)m_params.m_max_helper_threads - num_parse_jobs);
      match_accel_helper_threads = LZHAM_MIN(match_accel_helper_threads, cMatchAccelMaxSupportedThreads);

      LZHAM_ASSERT(m_num_parse_threads >= 1);
      LZHAM_ASSERT(m_num_parse_threads <= cMaxParseThreads);

      if (!m_use_task_pool)
      {
         LZHAM_ASSERT(!match_accel_helper_threads && (m_num_parse_threads == 1));
      }
      else
      {
         LZHAM_ASSERT((match_accel_helper_threads + (m_num_parse_threads - 1)) <= m_params.m_max_helper_threads);
      }

      uint accel_flags = 0;
      if (m_params.m_lzham_compress_flags & LZHAM_COMP_FLAG_DETERMINISTIC_PARSING)
         accel_flags |= search_accelerator::cFlagDeterministic;

      if (m_params.m_compression_level > cCompressionLevelFastest)
      {
         if ((m_params.m_lzham_compress_flags & LZHAM_COMP_FLAG_USE_LOW_MEMORY_MATCH_FINDER) == 0)
            accel_flags |= search_accelerator::cFlagHash24;

         accel_flags |= search_accelerator::cFlagLen2Matches;
      }

      if (!m_accel.init(this, params.m_pTask_pool, match_accel_helper_threads, dict_size, m_settings.m_match_accel_max_matches_per_probe, false, m_settings.m_match_accel_max_probes, accel_flags))
      {
         LZHAM_LOG_ERROR(7005);
         return false;
      }

      init_position_slots(params.m_dict_size_log2);
      init_slot_tabs();

      if (!m_state.init(*this, m_params.m_table_max_update_interval, m_params.m_table_update_interval_slow_rate))
      {
         LZHAM_LOG_ERROR(7006);
         return false;
      }

      if (!m_block_buf.try_reserve(m_params.m_block_size))
      {
         LZHAM_LOG_ERROR(7007);
         return false;
      }

      if (!m_comp_buf.try_reserve(m_params.m_block_size*2))
      {
         LZHAM_LOG_ERROR(7008);
         return false;
      }

      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_parse_thread_state); i++)
      {
         if (!m_parse_thread_state[i].init(*this, m_params))
         {
            LZHAM_LOG_ERROR(7009);
            return false;
         }
      }

      if (params.m_num_seed_bytes)
      {
         if (!init_seed_bytes())
         {
            LZHAM_LOG_ERROR(7010);
            return false;
         }
      }

      if (!send_zlib_header())
      {
         LZHAM_LOG_ERROR(7011);
         return false;
      }

      m_src_size = 0;

      return true;
   }

   // See http://www.gzip.org/zlib/rfc-zlib.html
   // Method is set to 14 (LZHAM) and CINFO is (window_size - 15).
   bool lzcompressor::send_zlib_header()
   {
      if ((m_params.m_lzham_compress_flags & LZHAM_COMP_FLAG_WRITE_ZLIB_STREAM) == 0)
         return true;

      // set CM (method) and CINFO (dictionary size) fields
      int cmf = LZHAM_Z_LZHAM | ((m_params.m_dict_size_log2 - 15) << 4);

      // set FLEVEL by mapping LZHAM's compression level to zlib's
      int flg = 0;
      switch (m_params.m_compression_level)
      {
         case LZHAM_COMP_LEVEL_FASTEST:
         {
            flg = 0 << 6;
            break;
         }
         case LZHAM_COMP_LEVEL_FASTER:
         {
            flg = 1 << 6;
            break;
         }
         case LZHAM_COMP_LEVEL_DEFAULT:
         case LZHAM_COMP_LEVEL_BETTER:
         {
            flg = 2 << 6;
            break;
         }
         default:
         {
            flg = 3 << 6;
            break;
         }
      }

      // set FDICT flag
      if (m_params.m_pSeed_bytes)
         flg |= 32;

      int check = ((cmf << 8) + flg) % 31;
      if (check)
         flg += (31 - check);

      LZHAM_ASSERT(0 == (((cmf << 8) + flg) % 31));
      if (!m_comp_buf.try_push_back(static_cast<uint8>(cmf)))
         return false;
      if (!m_comp_buf.try_push_back(static_cast<uint8>(flg)))
         return false;

      if (m_params.m_pSeed_bytes)
      {
         // send adler32 of DICT
         uint dict_adler32 = adler32(m_params.m_pSeed_bytes, m_params.m_num_seed_bytes);
         for (uint i = 0; i < 4; i++)
         {
            if (!m_comp_buf.try_push_back(static_cast<uint8>(dict_adler32 >> 24)))
               return false;
            dict_adler32 <<= 8;
         }
      }

      return true;
   }

   void lzcompressor::clear()
   {
      m_codec.clear();
      m_src_size = -1;
      m_src_adler32 = cInitAdler32;
      m_block_buf.clear();
      m_comp_buf.clear();

      m_step = 0;
      m_finished = false;
      m_use_task_pool = false;
      m_use_extreme_parsing = false;
      m_block_start_dict_ofs = 0;
      m_block_index = 0;
      m_state.clear();
      m_num_parse_threads = 0;
      m_fast_bytes = 128;

      for (uint i = 0; i < cMaxParseThreads; i++)
      {
         parse_thread_state &parse_state = m_parse_thread_state[i];
         parse_state.m_state.clear();

         for (uint j = 0; j <= cMaxParseGraphNodes; j++)
            parse_state.m_nodes[j].clear();

         parse_state.m_start_ofs = 0;
         parse_state.m_bytes_to_match = 0;
         parse_state.m_best_decisions.clear();
         parse_state.m_issue_reset_state_partial = false;
         parse_state.m_emit_decisions_backwards = false;
         parse_state.m_failed = false;
         parse_state.m_parse_early_out_thresh = UINT_MAX;
         parse_state.m_bytes_actually_parsed = 0;
      }
   }

   bool lzcompressor::reset()
   {
      if (m_src_size < 0)
         return false;

      m_accel.reset();
      m_codec.reset();
      m_stats.clear();
      m_src_size = 0;
      m_src_adler32 = cInitAdler32;
      m_block_buf.try_resize(0);
      m_comp_buf.try_resize(0);

      m_step = 0;
      m_finished = false;
      m_block_start_dict_ofs = 0;
      m_block_index = 0;
      m_state.reset();

      if (m_params.m_num_seed_bytes)
      {
         if (!init_seed_bytes())
         {
            LZHAM_LOG_ERROR(7012);
            return false;
         }
      }

      return send_zlib_header();
   }

   bool lzcompressor::code_decision(lzdecision lzdec, uint& cur_ofs, uint& bytes_to_match)
   {
#ifdef LZHAM_LZDEBUG
      if (!m_codec.encode_bits(CLZBase::cLZHAMDebugSyncMarkerValue, CLZBase::cLZHAMDebugSyncMarkerBits)) return false;
      if (!m_codec.encode_bits(lzdec.is_match(), 1)) return false;
      if (!m_codec.encode_bits(lzdec.get_len(), 17)) return false;
      if (!m_codec.encode_bits(m_state.m_cur_state, 4)) return false;
#endif

#ifdef LZHAM_LZVERIFY
      if (lzdec.is_match())
      {
         uint match_dist = lzdec.get_match_dist(m_state);

         LZHAM_VERIFY(m_accel[cur_ofs] == m_accel[(cur_ofs - match_dist) & (m_accel.get_max_dict_size() - 1)]);
      }
#endif

      const uint len = lzdec.get_len();

      if (!m_state.encode(m_codec, *this, m_accel, lzdec))
      {
         LZHAM_LOG_ERROR(7013);
         return false;
      }

      cur_ofs += len;
      LZHAM_ASSERT(bytes_to_match >= len);
      bytes_to_match -= len;

      //m_accel.advance_bytes(len);

      m_step++;

      return true;
   }

   bool lzcompressor::send_sync_block(lzham_flush_t flush_type)
   {
      m_codec.reset();

      if (!m_codec.start_encoding(128))
      {
         LZHAM_LOG_ERROR(7014);
         return false;
      }

#ifdef LZHAM_LZDEBUG
      if (!m_codec.encode_bits(166, 12))
      {
         LZHAM_LOG_ERROR(7015);
         return false;
      }
#endif

      if (!m_codec.encode_bits(cSyncBlock, cBlockHeaderBits))
      {
         LZHAM_LOG_ERROR(7016);
         return false;
      }

      int flush_code = 0;
      switch (flush_type)
      {
         case LZHAM_FULL_FLUSH:
            flush_code = 2;
            break;
         case LZHAM_TABLE_FLUSH:
            flush_code = 1;
            break;
         case LZHAM_SYNC_FLUSH:
            flush_code = 3;
            break;
         case LZHAM_NO_FLUSH:
         case LZHAM_FINISH:
            flush_code = 0;
            break;
      }
      if (!m_codec.encode_bits(flush_code, cBlockFlushTypeBits))
      {
         LZHAM_LOG_ERROR(7017);
         return false;
      }

      if (!m_codec.encode_align_to_byte())
      {
         LZHAM_LOG_ERROR(7018);
         return false;
      }
      if (!m_codec.encode_bits(0x0000, 16))
      {
         LZHAM_LOG_ERROR(7019);
         return false;
      }
      if (!m_codec.encode_bits(0xFFFF, 16))
      {
         LZHAM_LOG_ERROR(7020);
         return false;
      }
      if (!m_codec.stop_encoding(true))
      {
         LZHAM_LOG_ERROR(7021);
         return false;
      }
      if (!m_comp_buf.append(m_codec.get_encoding_buf()))
      {
         LZHAM_LOG_ERROR(7022);
         return false;
      }

      m_block_index++;
      return true;
   }

   bool lzcompressor::flush(lzham_flush_t flush_type)
   {
      LZHAM_ASSERT(!m_finished);
      if (m_finished)
      {
         LZHAM_LOG_ERROR(7023);
         return false;
      }

      bool status = true;
      if (m_block_buf.size())
      {
         status = compress_block(m_block_buf.get_ptr(), m_block_buf.size());

         m_block_buf.try_resize(0);
      }

      if (status)
      {
         status = send_sync_block(flush_type);

         if (LZHAM_FULL_FLUSH == flush_type)
         {
            m_accel.flush();
            m_state.reset();
         }
      }

      lzham_flush_buffered_printf();

      return status;
   }

   bool lzcompressor::put_bytes(const void* pBuf, uint buf_len)
   {
      LZHAM_ASSERT(!m_finished);
      if (m_finished)
      {
         LZHAM_LOG_ERROR(7024);
         return false;
      }

      bool status = true;

      if (!pBuf)
      {
         // Last block - flush whatever's left and send the final block.
         if (m_block_buf.size())
         {
            status = compress_block(m_block_buf.get_ptr(), m_block_buf.size());

            m_block_buf.try_resize(0);
         }

         if (status)
         {
            if (!send_final_block())
            {
               status = false;
               LZHAM_LOG_ERROR(7025);
            }
         }

         m_finished = true;
      }
      else
      {
         // Compress blocks.
         const uint8 *pSrcBuf = static_cast<const uint8*>(pBuf);
         uint num_src_bytes_remaining = buf_len;

         while (num_src_bytes_remaining)
         {
            const uint num_bytes_to_copy = LZHAM_MIN(num_src_bytes_remaining, m_params.m_block_size - m_block_buf.size());

            if (num_bytes_to_copy == m_params.m_block_size)
            {
               LZHAM_ASSERT(!m_block_buf.size());

               // Full-block available - compress in-place.
               status = compress_block(pSrcBuf, num_bytes_to_copy);
            }
            else
            {
               // Less than a full block available - append to already accumulated bytes.
               if (!m_block_buf.append(static_cast<const uint8 *>(pSrcBuf), num_bytes_to_copy))
               {
                  LZHAM_LOG_ERROR(7026);
                  return false;
               }

               LZHAM_ASSERT(m_block_buf.size() <= m_params.m_block_size);

               if (m_block_buf.size() == m_params.m_block_size)
               {
                  status = compress_block(m_block_buf.get_ptr(), m_block_buf.size());

                  m_block_buf.try_resize(0);
               }
            }

            if (!status)
            {
               LZHAM_LOG_ERROR(7027);
               return false;
            }

            pSrcBuf += num_bytes_to_copy;
            num_src_bytes_remaining -= num_bytes_to_copy;
         }
      }

      lzham_flush_buffered_printf();

      return status;
   }

   bool lzcompressor::send_final_block()
   {
      if (!m_codec.start_encoding(16))
      {
         LZHAM_LOG_ERROR(7028);
         return false;
      }

#ifdef LZHAM_LZDEBUG
      if (!m_codec.encode_bits(166, 12))
      {
         LZHAM_LOG_ERROR(7029);
         return false;
      }
#endif

      if (!m_block_index)
      {
         if (!send_configuration())
         {
            LZHAM_LOG_ERROR(7030);
            return false;
         }
      }

      if (!m_codec.encode_bits(cEOFBlock, cBlockHeaderBits))
      {
         LZHAM_LOG_ERROR(7031);
         return false;
      }

      if (!m_codec.encode_align_to_byte())
      {
         LZHAM_LOG_ERROR(7032);
         return false;
      }

      if (!m_codec.encode_bits(m_src_adler32, 32))
      {
         LZHAM_LOG_ERROR(7033);
         return false;
      }

      if (!m_codec.stop_encoding(true))
      {
         LZHAM_LOG_ERROR(7034);
         return false;
      }

      if (m_comp_buf.empty())
      {
         m_comp_buf.swap(m_codec.get_encoding_buf());
      }
      else
      {
         if (!m_comp_buf.append(m_codec.get_encoding_buf()))
         {
            LZHAM_LOG_ERROR(7035);
            return false;
         }
      }

      m_block_index++;

#if LZHAM_UPDATE_STATS
      m_stats.print();
#endif

      return true;
   }

   bool lzcompressor::send_configuration()
   {
      // TODO: Currently unused.
      //if (!m_codec.encode_bits(m_settings.m_fast_adaptive_huffman_updating, 1))
      //   return false;
      //if (!m_codec.encode_bits(0, 1))
      //   return false;

      return true;
   }

   void lzcompressor::node::add_state(
      int parent_index, int parent_state_index,
      const lzdecision &lzdec, const state &parent_state,
      bit_cost_t total_cost,
      uint total_complexity, uint max_parse_node_states)
   {
      state_base trial_state;
      parent_state.save_partial_state(trial_state);
      trial_state.partial_advance(lzdec);

      for (int i = m_num_node_states - 1; i >= 0; i--)
      {
         node_state &cur_node_state = m_node_states[i];
         if (cur_node_state.m_saved_state == trial_state)
         {
            if ( (total_cost < cur_node_state.m_total_cost) ||
                 ((total_cost == cur_node_state.m_total_cost) && (total_complexity < cur_node_state.m_total_complexity)) )
            {
               cur_node_state.m_parent_index = static_cast<int16>(parent_index);
               cur_node_state.m_parent_state_index = static_cast<int8>(parent_state_index);
               cur_node_state.m_lzdec = lzdec;
               cur_node_state.m_total_cost = total_cost;
               cur_node_state.m_total_complexity = total_complexity;

               while (i > 0)
               {
                  if ((m_node_states[i].m_total_cost < m_node_states[i - 1].m_total_cost) ||
                      ((m_node_states[i].m_total_cost == m_node_states[i - 1].m_total_cost) && (m_node_states[i].m_total_complexity < m_node_states[i - 1].m_total_complexity)))
                  {
                     std::swap(m_node_states[i], m_node_states[i - 1]);
                     i--;
                  }
                  else
                     break;
               }
            }

            return;
         }
      }

      int insert_index;
      for (insert_index = m_num_node_states; insert_index > 0; insert_index--)
      {
         node_state &cur_node_state = m_node_states[insert_index - 1];

         if ( (total_cost > cur_node_state.m_total_cost) ||
              ((total_cost == cur_node_state.m_total_cost) && (total_complexity >= cur_node_state.m_total_complexity)) )
         {
            break;
         }
      }

      if (insert_index == static_cast<int>(max_parse_node_states))
         return;

      uint num_behind = m_num_node_states - insert_index;
      uint num_to_move = (m_num_node_states < max_parse_node_states) ? num_behind : (num_behind - 1);
      if (num_to_move)
      {
         LZHAM_ASSERT((insert_index + 1 + num_to_move) <= max_parse_node_states);
         memmove(&m_node_states[insert_index + 1], &m_node_states[insert_index], sizeof(node_state) * num_to_move);
      }

      node_state *pNew_node_state = &m_node_states[insert_index];
      pNew_node_state->m_parent_index = static_cast<int16>(parent_index);
      pNew_node_state->m_parent_state_index = static_cast<uint8>(parent_state_index);
      pNew_node_state->m_lzdec = lzdec;
      pNew_node_state->m_total_cost = total_cost;
      pNew_node_state->m_total_complexity = total_complexity;
      pNew_node_state->m_saved_state = trial_state;

      m_num_node_states = LZHAM_MIN(m_num_node_states + 1, static_cast<uint>(max_parse_node_states));

#ifdef LZHAM_LZVERIFY
      for (uint i = 0; i < (m_num_node_states - 1); ++i)
      {
         node_state &a = m_node_states[i];
         node_state &b = m_node_states[i + 1];
         LZHAM_VERIFY(
            (a.m_total_cost < b.m_total_cost) ||
            ((a.m_total_cost == b.m_total_cost) && (a.m_total_complexity <= b.m_total_complexity)) );
      }
#endif
   }

   // The "extreme" parser tracks the best cMaxParseNodeStates (default 4) candidate LZ decisions per lookahead character.
   // This allows the compressor to make locally suboptimal decisions that ultimately result in a better parse.
   // It assumes the input statistics are locally stationary over the input block to parse.
   bool lzcompressor::extreme_parse(parse_thread_state &parse_state)
   {
      LZHAM_ASSERT(parse_state.m_bytes_to_match <= cMaxParseGraphNodes);

      parse_state.m_failed = false;
      parse_state.m_emit_decisions_backwards = true;

      node *pNodes = parse_state.m_nodes;

#ifdef LZHAM_BUILD_DEBUG
      for (uint i = 0; i < (cMaxParseGraphNodes + 1); i++)
      {
         LZHAM_ASSERT(pNodes[i].m_num_node_states == 0);
      }
#endif

      state &approx_state = *parse_state.m_pState;

      pNodes[0].m_num_node_states = 1;
      node_state &first_node_state = pNodes[0].m_node_states[0];
      approx_state.save_partial_state(first_node_state.m_saved_state);
      first_node_state.m_parent_index = -1;
      first_node_state.m_parent_state_index = -1;
      first_node_state.m_total_cost = 0;
      first_node_state.m_total_complexity = 0;

      const uint bytes_to_parse = parse_state.m_bytes_to_match;

      const uint lookahead_start_ofs = m_accel.get_lookahead_pos() & m_accel.get_max_dict_size_mask();

      uint cur_dict_ofs = parse_state.m_start_ofs;
      uint cur_lookahead_ofs = cur_dict_ofs - lookahead_start_ofs;
      uint cur_node_index = 0;

      enum { cMaxFullMatches = cMatchAccelMaxSupportedProbes };
      uint match_lens[cMaxFullMatches];
      uint match_distances[cMaxFullMatches];

      bit_cost_t lzdec_bitcosts[cMaxMatchLen + 1];

      node prev_lit_node;
      prev_lit_node.clear();

      node *pMax_node_in_graph = &pNodes[0];

      while (cur_node_index < bytes_to_parse)
      {
         node* pCur_node = &pNodes[cur_node_index];

         if ((cur_node_index >= parse_state.m_parse_early_out_thresh) && (pCur_node == pMax_node_in_graph))
         {
            // If the best path *must* pass through this node, and we're far enough along, and we're parsing using a single thread, then exit so we can move all our state forward.
            if (pCur_node->m_num_node_states == 1)
               break;
         }

         const uint max_admissable_match_len = LZHAM_MIN(static_cast<uint>(CLZBase::cMaxMatchLen), bytes_to_parse - cur_node_index);
         const uint find_dict_size = m_accel.get_cur_dict_size() + cur_lookahead_ofs;

         const uint lit_pred0 = approx_state.get_pred_char(m_accel, cur_dict_ofs, 1);

         const uint8* pLookahead = &m_accel.m_dict[cur_dict_ofs];

         // full matches
         uint max_full_match_len = 0;
         uint num_full_matches = 0;
         uint len2_match_dist = 0;

         if (max_admissable_match_len >= CLZBase::cMinMatchLen)
         {
            const dict_match* pMatches = m_accel.find_matches(cur_lookahead_ofs);
            if (pMatches)
            {
               for ( ; ; )
               {
                  uint match_len = pMatches->get_len();
                  LZHAM_ASSERT((pMatches->get_dist() > 0) && (pMatches->get_dist() <= m_dict_size));
                  match_len = LZHAM_MIN(match_len, max_admissable_match_len);

                  if (match_len > max_full_match_len)
                  {
                     max_full_match_len = match_len;

                     match_lens[num_full_matches] = match_len;
                     match_distances[num_full_matches] = pMatches->get_dist();
                     num_full_matches++;
                  }

                  if (pMatches->is_last())
                     break;
                  pMatches++;
               }
            }

            len2_match_dist = m_accel.get_len2_match(cur_lookahead_ofs);
         }

         uint ahead_bytes = 1;
         for (uint cur_node_state_index = 0; cur_node_state_index < pCur_node->m_num_node_states; cur_node_state_index++)
         {
            node_state &cur_node_state = pCur_node->m_node_states[cur_node_state_index];

            if (cur_node_index)
            {
               LZHAM_ASSERT(cur_node_state.m_parent_index >= 0);

               approx_state.restore_partial_state(cur_node_state.m_saved_state);
            }

            uint is_match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(approx_state.m_cur_state);

            const bit_cost_t cur_node_total_cost = cur_node_state.m_total_cost;
            const uint cur_node_total_complexity = cur_node_state.m_total_complexity;

            // rep matches
            uint match_hist_max_len = 0;
            uint match_hist_min_match_len = 1;
            for (uint rep_match_index = 0; rep_match_index < cMatchHistSize; rep_match_index++)
            {
               uint hist_match_len = 0;

               uint dist = approx_state.m_match_hist[rep_match_index];
               if (dist <= find_dict_size)
               {
                  const uint comp_pos = static_cast<uint>((m_accel.m_lookahead_pos + cur_lookahead_ofs - dist) & m_accel.m_max_dict_size_mask);
                  const uint8* pComp = &m_accel.m_dict[comp_pos];

                  for (hist_match_len = 0; hist_match_len < max_admissable_match_len; hist_match_len++)
                     if (pComp[hist_match_len] != pLookahead[hist_match_len])
                        break;
               }

               if (hist_match_len >= match_hist_min_match_len)
               {
                  match_hist_max_len = math::maximum(match_hist_max_len, hist_match_len);

                  approx_state.get_rep_match_costs(cur_dict_ofs, lzdec_bitcosts, rep_match_index, match_hist_min_match_len, hist_match_len, is_match_model_index);

                  uint rep_match_total_complexity = cur_node_total_complexity + (cRep0Complexity + rep_match_index);
                  for (uint l = match_hist_min_match_len; l <= hist_match_len; l++)
                  {
#if LZHAM_VERIFY_MATCH_COSTS
                     {
                        lzdecision actual_dec(cur_dict_ofs, l, -((int)rep_match_index + 1));
                        bit_cost_t actual_cost = approx_state.get_cost(*this, m_accel, actual_dec);
                        LZHAM_ASSERT(actual_cost == lzdec_bitcosts[l]);
                     }
#endif
                     node& dst_node = pCur_node[l];

                     bit_cost_t rep_match_total_cost = cur_node_total_cost + lzdec_bitcosts[l];

                     dst_node.add_state(cur_node_index, cur_node_state_index, lzdecision(cur_dict_ofs, l, -((int)rep_match_index + 1)), approx_state, rep_match_total_cost, rep_match_total_complexity, parse_state.m_max_parse_node_states);
                     pMax_node_in_graph = LZHAM_MAX(pMax_node_in_graph, &dst_node);
                  }
               }

               match_hist_min_match_len = CLZBase::cMinMatchLen;
            }

            if (match_hist_max_len >= m_fast_bytes)
            {
               ahead_bytes = match_hist_max_len;
               break;
            }

            uint min_truncate_match_len = match_hist_max_len;

            // nearest len2 match
            if (len2_match_dist)
            {
               lzdecision lzdec(cur_dict_ofs, 2, len2_match_dist);
               bit_cost_t actual_cost = approx_state.get_cost(*this, m_accel, lzdec);
               pCur_node[2].add_state(cur_node_index, cur_node_state_index, lzdec, approx_state, cur_node_total_cost + actual_cost, cur_node_total_complexity + cShortMatchComplexity, parse_state.m_max_parse_node_states);
               pMax_node_in_graph = LZHAM_MAX(pMax_node_in_graph, &pCur_node[2]);

               min_truncate_match_len = LZHAM_MAX(min_truncate_match_len, 2);
            }

            // full matches
            if (max_full_match_len > min_truncate_match_len)
            {
               uint prev_max_match_len = LZHAM_MAX(1, min_truncate_match_len);
               for (uint full_match_index = 0; full_match_index < num_full_matches; full_match_index++)
               {
                  uint end_len = match_lens[full_match_index];
                  if (end_len <= min_truncate_match_len)
                     continue;

                  uint start_len = prev_max_match_len + 1;
                  uint match_dist = match_distances[full_match_index];

                  LZHAM_ASSERT(start_len <= end_len);

                  approx_state.get_full_match_costs(*this, cur_dict_ofs, lzdec_bitcosts, match_dist, start_len, end_len, is_match_model_index);

                  for (uint l = start_len; l <= end_len; l++)
                  {
                     uint match_complexity = (l >= cLongMatchComplexityLenThresh) ? cLongMatchComplexity : cShortMatchComplexity;

#if LZHAM_VERIFY_MATCH_COSTS
                     {
                        lzdecision actual_dec(cur_dict_ofs, l, match_dist);
                        bit_cost_t actual_cost = approx_state.get_cost(*this, m_accel, actual_dec);
                        LZHAM_ASSERT(actual_cost == lzdec_bitcosts[l]);
                     }
#endif
                     node& dst_node = pCur_node[l];

                     bit_cost_t match_total_cost = cur_node_total_cost + lzdec_bitcosts[l];
                     uint match_total_complexity = cur_node_total_complexity + match_complexity;

                     dst_node.add_state( cur_node_index, cur_node_state_index, lzdecision(cur_dict_ofs, l, match_dist), approx_state, match_total_cost, match_total_complexity, parse_state.m_max_parse_node_states);
                     pMax_node_in_graph = LZHAM_MAX(pMax_node_in_graph, &dst_node);
                  }

                  prev_max_match_len = end_len;
               }

               if (max_full_match_len >= m_fast_bytes)
               {
                  ahead_bytes = max_full_match_len;
                  break;
               }
            }

            // literal
            bit_cost_t lit_cost = approx_state.get_lit_cost(*this, m_accel, cur_dict_ofs, lit_pred0, is_match_model_index);
            bit_cost_t lit_total_cost = cur_node_total_cost + lit_cost;
            uint lit_total_complexity = cur_node_total_complexity + cLitComplexity;
#if LZHAM_VERIFY_MATCH_COSTS
            {
               lzdecision actual_dec(cur_dict_ofs, 0, 0);
               bit_cost_t actual_cost = approx_state.get_cost(*this, m_accel, actual_dec);
               LZHAM_ASSERT(actual_cost == lit_cost);
            }
#endif

            pCur_node[1].add_state(cur_node_index, cur_node_state_index, lzdecision(cur_dict_ofs, 0, 0), approx_state, lit_total_cost, lit_total_complexity, parse_state.m_max_parse_node_states);
            pMax_node_in_graph = LZHAM_MAX(pMax_node_in_graph, &pCur_node[1]);

         } // cur_node_state_index

         cur_dict_ofs += ahead_bytes;
         cur_lookahead_ofs += ahead_bytes;
         cur_node_index += ahead_bytes;
      }

      LZHAM_ASSERT(static_cast<int>(cur_node_index) == (pMax_node_in_graph - pNodes));
      uint bytes_actually_parsed = cur_node_index;

      // Now get the optimal decisions by starting from the goal node.
      // m_best_decisions is filled backwards.
      if (!parse_state.m_best_decisions.try_reserve(bytes_actually_parsed))
      {
         parse_state.m_failed = true;

         for (uint i = 0; i <= bytes_actually_parsed; i++)
            pNodes[i].clear();

         LZHAM_LOG_ERROR(7036);

         return false;
      }

      bit_cost_t lowest_final_cost = cBitCostMax; //math::cNearlyInfinite;
      int node_state_index = 0;
      node_state *pLast_node_states = pNodes[bytes_actually_parsed].m_node_states;
      for (uint i = 0; i < pNodes[bytes_actually_parsed].m_num_node_states; i++)
      {
         if (pLast_node_states[i].m_total_cost < lowest_final_cost)
         {
            lowest_final_cost = pLast_node_states[i].m_total_cost;
            node_state_index = i;
         }
      }

      int node_index = bytes_actually_parsed;
      lzdecision *pDst_dec = parse_state.m_best_decisions.get_ptr();
      do
      {
         LZHAM_ASSERT((node_index >= 0) && (node_index <= (int)cMaxParseGraphNodes));

         node& cur_node = pNodes[node_index];
         const node_state &cur_node_state = cur_node.m_node_states[node_state_index];

         *pDst_dec++ = cur_node_state.m_lzdec;

         node_index = cur_node_state.m_parent_index;
         node_state_index = cur_node_state.m_parent_state_index;

      } while (node_index > 0);

      parse_state.m_best_decisions.try_resize_no_construct(static_cast<uint>(pDst_dec - parse_state.m_best_decisions.get_ptr()));
      parse_state.m_bytes_actually_parsed = bytes_actually_parsed;

      for (uint i = 0; i <= bytes_actually_parsed; i++)
         pNodes[i].clear();

      return true;
   }

   // Parsing notes:
   // The regular "optimal" parser only tracks the single cheapest candidate LZ decision per lookahead character.
   // This function finds the shortest path through an extremely dense node graph using a streamlined/simplified Dijkstra's algorithm with some coding heuristics.
   // Graph edges are LZ "decisions", cost is measured in fractional bits needed to code each graph edge, and graph nodes are lookahead characters.
   // There is no need to track visited/unvisted nodes, or find the next cheapest unvisted node in each iteration. The search always proceeds sequentially, visiting each lookahead character in turn from left/right.
   // The major CPU expense of this function is the complexity of LZ decision cost evaluation, so a lot of implementation effort is spent here reducing this overhead.
   // To simplify the problem, it assumes the input statistics are locally stationary over the input block to parse. (Otherwise, it would need to store, track, and update
   // unique symbol statistics for each lookahead character, which would be very costly.)
   // This function always sequentially pushes "forward" the unvisited node horizon. This horizon frequently collapses to a single node, which guarantees that the shortest path through the
   // graph must pass through this node. LZMA tracks cumulative bitprices relative to this node, while LZHAM currently always tracks cumulative bitprices relative to the first node in the lookahead buffer.
   // In very early versions of LZHAM the parse was much more understandable (straight Dijkstra with almost no bit price optimizations or coding heuristics).
   bool lzcompressor::optimal_parse(parse_thread_state &parse_state)
   {
      LZHAM_ASSERT(parse_state.m_bytes_to_match <= cMaxParseGraphNodes);

      parse_state.m_failed = false;
      parse_state.m_emit_decisions_backwards = true;

      node_state *pNodes = reinterpret_cast<node_state*>(parse_state.m_nodes);
      pNodes[0].m_parent_index = -1;
      pNodes[0].m_total_cost = 0;
      pNodes[0].m_total_complexity = 0;

#ifdef LZHAM_BUILD_DEBUG
      for (uint i = 1; i < (cMaxParseGraphNodes + 1); i++)
      {
         LZHAM_ASSERT(pNodes[i].m_total_cost == cUINT64_MAX);
         LZHAM_ASSERT(pNodes[i].m_total_complexity == UINT_MAX);
         LZHAM_ASSERT(pNodes[i].m_parent_index == -1);
      }
#endif

      state &approx_state = *parse_state.m_pState;

      const uint bytes_to_parse = parse_state.m_bytes_to_match;

      const uint lookahead_start_ofs = m_accel.get_lookahead_pos() & m_accel.get_max_dict_size_mask();

      uint cur_dict_ofs = parse_state.m_start_ofs;
      uint cur_lookahead_ofs = cur_dict_ofs - lookahead_start_ofs;
      uint cur_node_index = 0;

      enum { cMaxFullMatches = cMatchAccelMaxSupportedProbes };
      uint match_lens[cMaxFullMatches];
      uint match_distances[cMaxFullMatches];

      bit_cost_t lzdec_bitcosts[cMaxMatchLen + 1];

      node_state *pMax_node_in_graph = &pNodes[0];

      while (cur_node_index < bytes_to_parse)
      {
         node_state* pCur_node = &pNodes[cur_node_index];

         if ((cur_node_index >= parse_state.m_parse_early_out_thresh) && (pCur_node == pMax_node_in_graph))
         {
            // If the best path *must* pass through this node, and we're far enough along, and we're parsing using a single thread, then exit so we can move all our state forward.
            break;
         }

         const uint max_admissable_match_len = LZHAM_MIN(static_cast<uint>(CLZBase::cMaxMatchLen), bytes_to_parse - cur_node_index);
         const uint find_dict_size = m_accel.m_cur_dict_size + cur_lookahead_ofs;

         if (cur_node_index)
         {
            LZHAM_ASSERT(pCur_node->m_parent_index >= 0);

            // Move to this node's state using the lowest cost LZ decision found.
            approx_state.restore_partial_state(pCur_node->m_saved_state);
            approx_state.partial_advance(pCur_node->m_lzdec);
         }

         const bit_cost_t cur_node_total_cost = pCur_node->m_total_cost;
         // This assert includes a fudge factor - make sure we don't overflow our scaled costs.
         LZHAM_ASSERT((cBitCostMax - cur_node_total_cost) > (cBitCostScale * 64));
         const uint cur_node_total_complexity = pCur_node->m_total_complexity;

         const uint lit_pred0 = approx_state.get_pred_char(m_accel, cur_dict_ofs, 1);
         uint is_match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(approx_state.m_cur_state);

         const uint8* pLookahead = &m_accel.m_dict[cur_dict_ofs];

         // rep matches
         uint match_hist_max_len = 0;
         uint match_hist_min_match_len = 1;
         for (uint rep_match_index = 0; rep_match_index < cMatchHistSize; rep_match_index++)
         {
            uint hist_match_len = 0;

            uint dist = approx_state.m_match_hist[rep_match_index];
            if (dist <= find_dict_size)
            {
               const uint comp_pos = static_cast<uint>((m_accel.m_lookahead_pos + cur_lookahead_ofs - dist) & m_accel.m_max_dict_size_mask);
               const uint8* pComp = &m_accel.m_dict[comp_pos];

               for (hist_match_len = 0; hist_match_len < max_admissable_match_len; hist_match_len++)
                  if (pComp[hist_match_len] != pLookahead[hist_match_len])
                     break;
            }

            if (hist_match_len >= match_hist_min_match_len)
            {
               match_hist_max_len = math::maximum(match_hist_max_len, hist_match_len);

               approx_state.get_rep_match_costs(cur_dict_ofs, lzdec_bitcosts, rep_match_index, match_hist_min_match_len, hist_match_len, is_match_model_index);

               uint rep_match_total_complexity = cur_node_total_complexity + (cRep0Complexity + rep_match_index);
               for (uint l = match_hist_min_match_len; l <= hist_match_len; l++)
               {
#if LZHAM_VERIFY_MATCH_COSTS
                  {
                     lzdecision actual_dec(cur_dict_ofs, l, -((int)rep_match_index + 1));
                     bit_cost_t actual_cost = approx_state.get_cost(*this, m_accel, actual_dec);
                     LZHAM_ASSERT(actual_cost == lzdec_bitcosts[l]);
                  }
#endif
                  node_state& dst_node = pCur_node[l];

                  bit_cost_t rep_match_total_cost = cur_node_total_cost + lzdec_bitcosts[l];

                  if ((rep_match_total_cost > dst_node.m_total_cost) || ((rep_match_total_cost == dst_node.m_total_cost) && (rep_match_total_complexity >= dst_node.m_total_complexity)))
                     continue;

                  dst_node.m_total_cost = rep_match_total_cost;
                  dst_node.m_total_complexity = rep_match_total_complexity;
                  dst_node.m_parent_index = (uint16)cur_node_index;
                  approx_state.save_partial_state(dst_node.m_saved_state);
                  dst_node.m_lzdec.init(cur_dict_ofs, l, -((int)rep_match_index + 1));
                  dst_node.m_lzdec.m_len = l;

                  pMax_node_in_graph = LZHAM_MAX(pMax_node_in_graph, &dst_node);
               }
            }

            match_hist_min_match_len = CLZBase::cMinMatchLen;
         }

         uint max_match_len = match_hist_max_len;

         if (max_match_len >= m_fast_bytes)
         {
            cur_dict_ofs += max_match_len;
            cur_lookahead_ofs += max_match_len;
            cur_node_index += max_match_len;
            continue;
         }

         // full matches
         if (max_admissable_match_len >= CLZBase::cMinMatchLen)
         {
            uint num_full_matches = 0;

            if (match_hist_max_len < 2)
            {
               // Get the nearest len2 match if we didn't find a rep len2.
               uint len2_match_dist = m_accel.get_len2_match(cur_lookahead_ofs);
               if (len2_match_dist)
               {
                  bit_cost_t cost = approx_state.get_len2_match_cost(*this, cur_dict_ofs, len2_match_dist, is_match_model_index);

#if LZHAM_VERIFY_MATCH_COSTS
                  {
                     lzdecision actual_dec(cur_dict_ofs, 2, len2_match_dist);
                     bit_cost_t actual_cost = approx_state.get_cost(*this, m_accel, actual_dec);
                     LZHAM_ASSERT(actual_cost == cost);
                  }
#endif

                  node_state& dst_node = pCur_node[2];

                  bit_cost_t match_total_cost = cur_node_total_cost + cost;
                  uint match_total_complexity = cur_node_total_complexity + cShortMatchComplexity;

                  if ((match_total_cost < dst_node.m_total_cost) || ((match_total_cost == dst_node.m_total_cost) && (match_total_complexity < dst_node.m_total_complexity)))
                  {
                     dst_node.m_total_cost = match_total_cost;
                     dst_node.m_total_complexity = match_total_complexity;
                     dst_node.m_parent_index = (uint16)cur_node_index;
                     approx_state.save_partial_state(dst_node.m_saved_state);
                     dst_node.m_lzdec.init(cur_dict_ofs, 2, len2_match_dist);

                     pMax_node_in_graph = LZHAM_MAX(pMax_node_in_graph, &dst_node);
                  }

                  max_match_len = 2;
               }
            }

            const uint min_truncate_match_len = max_match_len;

            // Now get all full matches: the nearest matches at each match length. (Actually, we don't
            // always get the nearest match. The match finder favors those matches which have the lowest value
            // in the nibble of each match distance, all other things being equal, to help exploit how the lowest
            // nibble of match distances is separately coded.)
            const dict_match* pMatches = m_accel.find_matches(cur_lookahead_ofs);
            if (pMatches)
            {
               for ( ; ; )
               {
                  uint match_len = pMatches->get_len();
                  LZHAM_ASSERT((pMatches->get_dist() > 0) && (pMatches->get_dist() <= m_dict_size));
                  match_len = LZHAM_MIN(match_len, max_admissable_match_len);

                  if (match_len > max_match_len)
                  {
                     max_match_len = match_len;

                     match_lens[num_full_matches] = match_len;
                     match_distances[num_full_matches] = pMatches->get_dist();
                     num_full_matches++;
                  }

                  if (pMatches->is_last())
                     break;
                  pMatches++;
               }
            }

            if (num_full_matches)
            {
               uint prev_max_match_len = LZHAM_MAX(1, min_truncate_match_len);
               for (uint full_match_index = 0; full_match_index < num_full_matches; full_match_index++)
               {
                  uint start_len = prev_max_match_len + 1;
                  uint end_len = match_lens[full_match_index];
                  uint match_dist = match_distances[full_match_index];

                  LZHAM_ASSERT(start_len <= end_len);

                  approx_state.get_full_match_costs(*this, cur_dict_ofs, lzdec_bitcosts, match_dist, start_len, end_len, is_match_model_index);

                  for (uint l = start_len; l <= end_len; l++)
                  {
                     uint match_complexity = (l >= cLongMatchComplexityLenThresh) ? cLongMatchComplexity : cShortMatchComplexity;

#if LZHAM_VERIFY_MATCH_COSTS
                     {
                        lzdecision actual_dec(cur_dict_ofs, l, match_dist);
                        bit_cost_t actual_cost = approx_state.get_cost(*this, m_accel, actual_dec);
                        LZHAM_ASSERT(actual_cost == lzdec_bitcosts[l]);
                     }
#endif
                     node_state& dst_node = pCur_node[l];

                     bit_cost_t match_total_cost = cur_node_total_cost + lzdec_bitcosts[l];
                     uint match_total_complexity = cur_node_total_complexity + match_complexity;

                     if ((match_total_cost > dst_node.m_total_cost) || ((match_total_cost == dst_node.m_total_cost) && (match_total_complexity >= dst_node.m_total_complexity)))
                        continue;

                     dst_node.m_total_cost = match_total_cost;
                     dst_node.m_total_complexity = match_total_complexity;
                     dst_node.m_parent_index = (uint16)cur_node_index;
                     approx_state.save_partial_state(dst_node.m_saved_state);
                     dst_node.m_lzdec.init(cur_dict_ofs, l, match_dist);

                     pMax_node_in_graph = LZHAM_MAX(pMax_node_in_graph, &dst_node);
                  }

                  prev_max_match_len = end_len;
               }
            }
         }

         if (max_match_len >= m_fast_bytes)
         {
            cur_dict_ofs += max_match_len;
            cur_lookahead_ofs += max_match_len;
            cur_node_index += max_match_len;
            continue;
         }

         // literal
         bit_cost_t lit_cost = approx_state.get_lit_cost(*this, m_accel, cur_dict_ofs, lit_pred0, is_match_model_index);
         bit_cost_t lit_total_cost = cur_node_total_cost + lit_cost;
         uint lit_total_complexity = cur_node_total_complexity + cLitComplexity;
#if LZHAM_VERIFY_MATCH_COSTS
         {
            lzdecision actual_dec(cur_dict_ofs, 0, 0);
            bit_cost_t actual_cost = approx_state.get_cost(*this, m_accel, actual_dec);
            LZHAM_ASSERT(actual_cost == lit_cost);
         }
#endif
         if ((lit_total_cost < pCur_node[1].m_total_cost) || ((lit_total_cost == pCur_node[1].m_total_cost) && (lit_total_complexity < pCur_node[1].m_total_complexity)))
         {
            pCur_node[1].m_total_cost = lit_total_cost;
            pCur_node[1].m_total_complexity = lit_total_complexity;
            pCur_node[1].m_parent_index = (int16)cur_node_index;
            approx_state.save_partial_state(pCur_node[1].m_saved_state);
            pCur_node[1].m_lzdec.init(cur_dict_ofs, 0, 0);

            pMax_node_in_graph = LZHAM_MAX(pMax_node_in_graph, &pCur_node[1]);
         }

         cur_dict_ofs++;
         cur_lookahead_ofs++;
         cur_node_index++;

      } // graph search

      LZHAM_ASSERT(static_cast<int>(cur_node_index) == (pMax_node_in_graph - pNodes));
      uint bytes_actually_parsed = cur_node_index;

      // Now get the optimal decisions by starting from the goal node.
      // m_best_decisions is filled backwards.
      if (!parse_state.m_best_decisions.try_reserve(bytes_actually_parsed))
      {
         parse_state.m_failed = true;

         memset(pNodes, 0xFF, (pMax_node_in_graph - pNodes + 1) * sizeof(node_state));

         LZHAM_LOG_ERROR(7037);

         return false;
      }

      int node_index = bytes_actually_parsed;
      lzdecision *pDst_dec = parse_state.m_best_decisions.get_ptr();
      do
      {
         LZHAM_ASSERT((node_index >= 0) && (node_index <= (int)cMaxParseGraphNodes));
         node_state& cur_node = pNodes[node_index];

         *pDst_dec++ = cur_node.m_lzdec;

         node_index = cur_node.m_parent_index;

      } while (node_index > 0);

      parse_state.m_best_decisions.try_resize_no_construct(static_cast<uint>(pDst_dec - parse_state.m_best_decisions.get_ptr()));

      parse_state.m_bytes_actually_parsed = bytes_actually_parsed;

      memset(pNodes, 0xFF, (pMax_node_in_graph - pNodes + 1) * sizeof(node_state));

      return true;
   }

   void lzcompressor::parse_job_callback(uint64 data, void* pData_ptr)
   {
      const uint parse_job_index = (uint)data;
      parse_thread_state &parse_state = m_parse_thread_state[parse_job_index];

      scoped_perf_section parse_job_timer(cVarArgs, "parse_job_callback %u", parse_job_index);

      LZHAM_NOTE_UNUSED(pData_ptr);

      if (m_use_extreme_parsing)
         extreme_parse(parse_state);
      else
         optimal_parse(parse_state);

      if (parse_state.m_use_semaphore)
      {
         parse_state.m_finished.release();
      }
   }

   // ofs is the absolute dictionary offset, must be >= the lookahead offset.
   // TODO: Doesn't find len2 matches
   int lzcompressor::enumerate_lz_decisions(uint ofs, const state& cur_state, lzham::vector<lzpriced_decision>& decisions, uint min_match_len, uint max_match_len)
   {
      LZHAM_ASSERT(min_match_len >= 1);

      uint start_ofs = m_accel.get_lookahead_pos() & m_accel.get_max_dict_size_mask();
      LZHAM_ASSERT(ofs >= start_ofs);
      const uint lookahead_ofs = ofs - start_ofs;

      uint largest_index = 0;
      uint largest_len;
      bit_cost_t largest_cost;

      if (min_match_len <= 1)
      {
         if (!decisions.try_resize(1))
         {
            LZHAM_LOG_ERROR(7038);
            return -1;
         }

         lzpriced_decision& lit_dec = decisions[0];
         lit_dec.init(ofs, 0, 0, 0);
         lit_dec.m_cost = cur_state.get_cost(*this, m_accel, lit_dec);
         largest_cost = lit_dec.m_cost;

         largest_len = 1;
      }
      else
      {
         if (!decisions.try_resize(0))
         {
            LZHAM_LOG_ERROR(7039);
            return -1;
         }

         largest_len = 0;
         largest_cost = cBitCostMax;
      }

      uint match_hist_max_len = 0;

      // Add rep matches.
      for (uint i = 0; i < cMatchHistSize; i++)
      {
         uint hist_match_len = m_accel.get_match_len(lookahead_ofs, cur_state.m_match_hist[i], max_match_len);
         if (hist_match_len < min_match_len)
            continue;

         if ( ((hist_match_len == 1) && (i == 0)) || (hist_match_len >= CLZBase::cMinMatchLen) )
         {
            match_hist_max_len = math::maximum(match_hist_max_len, hist_match_len);

            lzpriced_decision dec(ofs, hist_match_len, -((int)i + 1));
            dec.m_cost = cur_state.get_cost(*this, m_accel, dec);

            if (!decisions.try_push_back(dec))
            {
               LZHAM_LOG_ERROR(7040);
               return -1;
            }

            if ( (hist_match_len > largest_len) || ((hist_match_len == largest_len) && (dec.m_cost < largest_cost)) )
            {
               largest_index = decisions.size() - 1;
               largest_len = hist_match_len;
               largest_cost = dec.m_cost;
            }
         }
      }

      // Now add full matches.
      if ((max_match_len >= CLZBase::cMinMatchLen) && (match_hist_max_len < m_fast_bytes))
      {
         const dict_match* pMatches = m_accel.find_matches(lookahead_ofs);

         if (pMatches)
         {
            for ( ; ; )
            {
               uint match_len = math::minimum(pMatches->get_len(), max_match_len);
               LZHAM_ASSERT((pMatches->get_dist() > 0) && (pMatches->get_dist() <= m_dict_size));

               // Full matches are very likely to be more expensive than rep matches of the same length, so don't bother evaluating them.
               if ((match_len >= min_match_len) && (match_len > match_hist_max_len))
               {
                  if ((max_match_len > CLZBase::cMaxMatchLen) && (match_len == CLZBase::cMaxMatchLen))
                  {
                     match_len = m_accel.get_match_len(lookahead_ofs, pMatches->get_dist(), max_match_len, CLZBase::cMaxMatchLen);
                  }

                  lzpriced_decision dec(ofs, match_len, pMatches->get_dist());
                  dec.m_cost = cur_state.get_cost(*this, m_accel, dec);

                  if (!decisions.try_push_back(dec))
                  {
                     LZHAM_LOG_ERROR(7041);
                     return -1;
                  }

                  if ( (match_len > largest_len) || ((match_len == largest_len) && (dec.get_cost() < largest_cost)) )
                  {
                     largest_index = decisions.size() - 1;
                     largest_len = match_len;
                     largest_cost = dec.get_cost();
                  }
               }
               if (pMatches->is_last())
                  break;
               pMatches++;
            }
         }
      }

      return largest_index;
   }

   bool lzcompressor::greedy_parse(parse_thread_state &parse_state)
   {
      parse_state.m_failed = true;
      parse_state.m_emit_decisions_backwards = false;

      const uint bytes_to_parse = parse_state.m_bytes_to_match;

      const uint lookahead_start_ofs = m_accel.get_lookahead_pos() & m_accel.get_max_dict_size_mask();

      uint cur_dict_ofs = parse_state.m_start_ofs;
      uint cur_lookahead_ofs = cur_dict_ofs - lookahead_start_ofs;
      uint cur_ofs = 0;

      state &approx_state = *parse_state.m_pState;

      lzham::vector<lzpriced_decision> &decisions = parse_state.m_temp_decisions;

      if (!decisions.try_reserve(384))
      {
         LZHAM_LOG_ERROR(7042);
         return false;
      }

      if (!parse_state.m_best_decisions.try_resize(0))
      {
         LZHAM_LOG_ERROR(7043);
         return false;
      }

      while (cur_ofs < bytes_to_parse)
      {
         const uint max_admissable_match_len = LZHAM_MIN(static_cast<uint>(CLZBase::cMaxHugeMatchLen), bytes_to_parse - cur_ofs);

         int largest_dec_index = enumerate_lz_decisions(cur_dict_ofs, approx_state, decisions, 1, max_admissable_match_len);
         if (largest_dec_index < 0)
         {
            LZHAM_LOG_ERROR(7044);
            return false;
         }

         const lzpriced_decision &dec = decisions[largest_dec_index];

         if (!parse_state.m_best_decisions.try_push_back(dec))
         {
            LZHAM_LOG_ERROR(7045);
            return false;
         }

         approx_state.partial_advance(dec);

         uint match_len = dec.get_len();
         LZHAM_ASSERT(match_len <= max_admissable_match_len);
         cur_dict_ofs += match_len;
         cur_lookahead_ofs += match_len;
         cur_ofs += match_len;

         if (parse_state.m_best_decisions.size() >= parse_state.m_max_greedy_decisions)
         {
            parse_state.m_greedy_parse_total_bytes_coded = cur_ofs;
            parse_state.m_bytes_actually_parsed = cur_ofs;
            parse_state.m_greedy_parse_gave_up = true;
            return false;
         }
      }

      parse_state.m_greedy_parse_total_bytes_coded = cur_ofs;

      LZHAM_ASSERT(cur_ofs == bytes_to_parse);

      parse_state.m_failed = false;
      parse_state.m_bytes_actually_parsed = parse_state.m_bytes_to_match;

      return true;
   }

   bool lzcompressor::compress_block(const void* pBuf, uint buf_len)
   {
      uint cur_ofs = 0;
      uint bytes_remaining = buf_len;
      while (bytes_remaining)
      {
         uint bytes_to_compress = math::minimum(m_accel.get_max_add_bytes(), bytes_remaining);
         if (!compress_block_internal(static_cast<const uint8*>(pBuf) + cur_ofs, bytes_to_compress))
         {
            LZHAM_LOG_ERROR(7046);
            return false;
         }

         cur_ofs += bytes_to_compress;
         bytes_remaining -= bytes_to_compress;
      }
      return true;
   }

   bool lzcompressor::compress_block_internal(const void* pBuf, uint buf_len)
   {
      scoped_perf_section compress_block_timer(cVarArgs, "****** compress_block %u", m_block_index);

      LZHAM_ASSERT(pBuf);
      LZHAM_ASSERT(buf_len <= m_params.m_block_size);

      LZHAM_ASSERT(m_src_size >= 0);
      if (m_src_size < 0)
         return false;

      m_src_size += buf_len;

      // Important: Don't do any expensive work until after add_bytes_begin() is called, to increase parallelism.
      if (!m_accel.add_bytes_begin(buf_len, static_cast<const uint8*>(pBuf)))
      {
         LZHAM_LOG_ERROR(7047);
         return false;
      }

      bool computed_adler32 = false;

      m_start_of_block_state = m_state;

      m_block_start_dict_ofs = m_accel.get_lookahead_pos() & (m_accel.get_max_dict_size() - 1);

      uint cur_dict_ofs = m_block_start_dict_ofs;

      uint bytes_to_match = buf_len;

      if (!m_codec.start_encoding((buf_len * 9) / 8))
      {
         LZHAM_LOG_ERROR(7048);
         return false;
      }

      if (!m_block_index)
      {
         if (!send_configuration())
         {
            LZHAM_LOG_ERROR(7049);
            return false;
         }
      }

#ifdef LZHAM_LZDEBUG
      m_codec.encode_bits(166, 12);
#endif

      if (!m_codec.encode_bits(cCompBlock, cBlockHeaderBits))
      {
         LZHAM_LOG_ERROR(7050);
         return false;
      }

      if (!m_codec.encode_arith_init())
      {
         LZHAM_LOG_ERROR(7051);
         return false;
      }

      m_state.start_of_block(m_accel, cur_dict_ofs, m_block_index);

      bool emit_reset_update_rate_command = false;

      if (m_params.m_lzham_compress_flags & LZHAM_COMP_FLAG_TRADEOFF_DECOMPRESSION_RATE_FOR_COMP_RATIO)
      {
         emit_reset_update_rate_command = true;

         m_state.reset_update_rate();
      }

      // TODO: We could also issue a full huff/arith table reset (code 2), and see if that actually improves the block's compression.
      m_codec.encode_bits(emit_reset_update_rate_command ? 1 : 0, cBlockFlushTypeBits);

      //coding_stats initial_stats(m_stats);

      uint initial_step = m_step;

      while (bytes_to_match)
      {
         const uint cAvgAcceptableGreedyMatchLen = 384;
         if ((m_params.m_pSeed_bytes) && (bytes_to_match >= cAvgAcceptableGreedyMatchLen))
         {
            parse_thread_state &greedy_parse_state = m_parse_thread_state[cMaxParseThreads];

            greedy_parse_state.m_pState = &greedy_parse_state.m_state;
            greedy_parse_state.m_state = m_state;
            greedy_parse_state.m_state.m_cur_ofs = cur_dict_ofs;

            greedy_parse_state.m_issue_reset_state_partial = false;
            greedy_parse_state.m_start_ofs = cur_dict_ofs;
            greedy_parse_state.m_bytes_to_match = LZHAM_MIN(bytes_to_match, static_cast<uint>(CLZBase::cMaxHugeMatchLen));

            greedy_parse_state.m_max_greedy_decisions = LZHAM_MAX((bytes_to_match / cAvgAcceptableGreedyMatchLen), 2);
            greedy_parse_state.m_greedy_parse_gave_up = false;
            greedy_parse_state.m_greedy_parse_total_bytes_coded = 0;

            greedy_parse_state.m_parse_early_out_thresh = UINT_MAX;
            greedy_parse_state.m_bytes_actually_parsed = 0;

            greedy_parse_state.m_use_semaphore = false;

            if (!greedy_parse(greedy_parse_state))
            {
               if (!greedy_parse_state.m_greedy_parse_gave_up)
               {
                  LZHAM_LOG_ERROR(7052);
                  return false;
               }
            }

            uint num_greedy_decisions_to_code = 0;

            const lzham::vector<lzdecision> &best_decisions = greedy_parse_state.m_best_decisions;

            if (!greedy_parse_state.m_greedy_parse_gave_up)
               num_greedy_decisions_to_code = best_decisions.size();
            else
            {
               uint num_small_decisions = 0;
               uint total_match_len = 0;
               uint max_match_len = 0;

               uint i;
               for (i = 0; i < best_decisions.size(); i++)
               {
                  const lzdecision &dec = best_decisions[i];
                  if (dec.get_len() <= CLZBase::cMaxMatchLen)
                  {
                     num_small_decisions++;
                     if (num_small_decisions > 16)
                        break;
                  }

                  total_match_len += dec.get_len();
                  max_match_len = LZHAM_MAX(max_match_len, dec.get_len());
               }

               if (max_match_len > CLZBase::cMaxMatchLen)
               {
                  if ((total_match_len / i) >= cAvgAcceptableGreedyMatchLen)
                  {
                     num_greedy_decisions_to_code = i;
                  }
               }
            }

            if (num_greedy_decisions_to_code)
            {
               for (uint i = 0; i < num_greedy_decisions_to_code; i++)
               {
                  LZHAM_ASSERT(best_decisions[i].m_pos == (int)cur_dict_ofs);
                  //LZHAM_ASSERT(i >= 0);
                  LZHAM_ASSERT(i < best_decisions.size());

#if LZHAM_UPDATE_STATS
                  bit_cost_t cost = m_state.get_cost(*this, m_accel, best_decisions[i]);
                  m_stats.update(best_decisions[i], m_state, m_accel, cost);
#endif

                  if (!code_decision(best_decisions[i], cur_dict_ofs, bytes_to_match))
                  {
                     LZHAM_LOG_ERROR(7053);
                     return false;
                  }

                  m_accel.advance_bytes(best_decisions[i].get_len());
               }

               if ((!greedy_parse_state.m_greedy_parse_gave_up) || (!bytes_to_match))
			   {
				   if (!computed_adler32)
				   {
					   computed_adler32 = true;

					   scoped_perf_section add_bytes_timer("adler32");
					   m_src_adler32 = adler32(pBuf, buf_len, m_src_adler32);
				   }

                  continue;
			   }
            }
         }

         uint num_parse_jobs = LZHAM_MIN(m_num_parse_threads, (bytes_to_match + cMaxParseGraphNodes - 1) / cMaxParseGraphNodes);
         if ((m_params.m_lzham_compress_flags & LZHAM_COMP_FLAG_DETERMINISTIC_PARSING) == 0)
         {
            if (m_use_task_pool && m_accel.get_max_helper_threads())
            {
               // Increase the number of active parse jobs as the match finder finishes up to keep CPU utilization up.
               num_parse_jobs += m_accel.get_num_completed_helper_threads();
               num_parse_jobs = LZHAM_MIN(num_parse_jobs, cMaxParseThreads);
            }
         }

         // Don't bother threading if the remaining bytes to parse is too small.
         if ((bytes_to_match < 1536) || (m_params.m_lzham_compress_flags & LZHAM_COMP_FLAG_FORCE_SINGLE_THREADED_PARSING))
            num_parse_jobs = 1;

         // Update the coding statistics more frequently near the beginning of streams.
         if ((!m_block_index) && ((cur_dict_ofs - m_block_start_dict_ofs) < cMaxParseGraphNodes * 4))
            num_parse_jobs = 1;

         uint parse_thread_start_ofs = cur_dict_ofs;
         uint parse_thread_total_size = LZHAM_MIN(bytes_to_match, cMaxParseGraphNodes * num_parse_jobs);

         uint parse_thread_remaining = parse_thread_total_size;

         state_base saved_state;
         if (num_parse_jobs == 1)
            m_state.save_partial_state(saved_state);

         for (uint parse_thread_index = 0; parse_thread_index < num_parse_jobs; parse_thread_index++)
         {
            parse_thread_state &parse_thread = m_parse_thread_state[parse_thread_index];

            if (num_parse_jobs == 1)
            {
               parse_thread.m_pState = &m_state;
            }
            else
            {
               parse_thread.m_pState = &parse_thread.m_state;
               parse_thread.m_state = m_state;
            }

            parse_thread.m_pState->m_cur_ofs = parse_thread_start_ofs;

            if (parse_thread_index > 0)
            {
               parse_thread.m_pState->reset_state_partial();
               parse_thread.m_issue_reset_state_partial = true;
            }
            else
            {
               parse_thread.m_issue_reset_state_partial = false;
            }

            parse_thread.m_start_ofs = parse_thread_start_ofs;
            if (parse_thread_index == (num_parse_jobs - 1))
               parse_thread.m_bytes_to_match = parse_thread_remaining;
            else
               parse_thread.m_bytes_to_match = parse_thread_total_size / num_parse_jobs;

            parse_thread.m_bytes_to_match = LZHAM_MIN(parse_thread.m_bytes_to_match, cMaxParseGraphNodes);
            LZHAM_ASSERT(parse_thread.m_bytes_to_match > 0);

            parse_thread.m_max_parse_node_states = m_params.m_extreme_parsing_max_best_arrivals;
            parse_thread.m_max_greedy_decisions = UINT_MAX;
            parse_thread.m_greedy_parse_gave_up = false;

            parse_thread.m_parse_early_out_thresh = UINT_MAX;
            parse_thread.m_bytes_actually_parsed = 0;

            parse_thread.m_use_semaphore = ((m_use_task_pool) && (num_parse_jobs > 1)) && (parse_thread_index > 0);

            if ((m_params.m_compression_level == cCompressionLevelUber) && (num_parse_jobs == 1))
            {
               // Allow the parsers to exit early if they encounter a graph bottleneck, so we can move the coding statistics forward before parsing again.
               parse_thread.m_parse_early_out_thresh = (m_params.m_lzham_compress_flags & LZHAM_COMP_FLAG_EXTREME_PARSING) ? 16 : 64;
            }

            parse_thread_start_ofs += parse_thread.m_bytes_to_match;
            parse_thread_remaining -= parse_thread.m_bytes_to_match;
         }

         {
            scoped_perf_section parse_timer("parsing");

            if ((m_use_task_pool) && (num_parse_jobs > 1))
            {
               {
                  scoped_perf_section queue_task_timer("queuing parse tasks");

                  if (!m_params.m_pTask_pool->queue_multiple_object_tasks(this, &lzcompressor::parse_job_callback, 1, num_parse_jobs - 1))
                     return false;
               }

               parse_job_callback(0, NULL);
            }
            else
            {
               for (uint parse_thread_index = 0; parse_thread_index < num_parse_jobs; parse_thread_index++)
               {
                  parse_job_callback(parse_thread_index, NULL);
               }
            }
         }

         if (num_parse_jobs == 1)
            m_state.restore_partial_state(saved_state);

         if (!computed_adler32)
         {
            computed_adler32 = true;

            scoped_perf_section add_bytes_timer("adler32");
            m_src_adler32 = adler32(pBuf, buf_len, m_src_adler32);
         }

#define LZHAM_RELEASE_SEMAPHORES for (uint pti = 1; pti < num_parse_jobs; pti++) if (m_parse_thread_state[pti].m_use_semaphore) { m_parse_thread_state[pti].m_finished.wait(); m_parse_thread_state[pti].m_use_semaphore = false; }

         {
            scoped_perf_section coding_timer("coding");

            uint total_bytes_parsed = 0;

            for (uint parse_thread_index = 0; parse_thread_index < num_parse_jobs; parse_thread_index++)
            {
               parse_thread_state &parse_thread = m_parse_thread_state[parse_thread_index];

               if (parse_thread.m_use_semaphore)
               {
                  scoped_perf_section sect(cVarArgs, "Waiting for parser %u", parse_thread_index);
                  m_parse_thread_state[parse_thread_index].m_finished.wait();
                  m_parse_thread_state[parse_thread_index].m_use_semaphore = false;
               }

               if (parse_thread.m_failed)
               {
                  LZHAM_RELEASE_SEMAPHORES
                  LZHAM_LOG_ERROR(7054);
                  return false;
               }

               const lzham::vector<lzdecision> &best_decisions = parse_thread.m_best_decisions;

               if (parse_thread.m_issue_reset_state_partial)
               {
                  if (!m_state.encode_reset_state_partial(m_codec, m_accel, cur_dict_ofs))
                  {
                     LZHAM_RELEASE_SEMAPHORES
                     LZHAM_LOG_ERROR(7055);
                     return false;
                  }
                  m_step++;
               }

               if (best_decisions.size())
               {
                  int i = 0;
                  int end_dec_index = static_cast<int>(best_decisions.size()) - 1;
                  int dec_step = 1;
                  if (parse_thread.m_emit_decisions_backwards)
                  {
                     i = static_cast<int>(best_decisions.size()) - 1;
                     end_dec_index = 0;
                     dec_step = -1;
                     LZHAM_ASSERT(best_decisions.back().m_pos == (int)parse_thread.m_start_ofs);
                  }
                  else
                  {
                     LZHAM_ASSERT(best_decisions.front().m_pos == (int)parse_thread.m_start_ofs);
                  }

                  // Loop rearranged to avoid bad x64 codegen problem with MSVC2008.
                  for ( ; ; )
                  {
                     LZHAM_ASSERT(best_decisions[i].m_pos == (int)cur_dict_ofs);
                     LZHAM_ASSERT(i >= 0);
                     LZHAM_ASSERT(i < (int)best_decisions.size());

#if LZHAM_UPDATE_STATS
                     bit_cost_t cost = m_state.get_cost(*this, m_accel, best_decisions[i]);
                     m_stats.update(best_decisions[i], m_state, m_accel, cost);
                     //m_state.print(m_codec, *this, m_accel, best_decisions[i]);
#endif

                     if (!code_decision(best_decisions[i], cur_dict_ofs, bytes_to_match))
                     {
                        LZHAM_RELEASE_SEMAPHORES
                        LZHAM_LOG_ERROR(7056);
                        return false;
                     }

                     total_bytes_parsed += best_decisions[i].get_len();

                     if (i == end_dec_index)
                        break;
                     i += dec_step;
                  }

                  LZHAM_NOTE_UNUSED(i);
               }

               LZHAM_ASSERT(cur_dict_ofs == parse_thread.m_start_ofs + parse_thread.m_bytes_actually_parsed);

            } // parse_thread_index

            m_accel.advance_bytes(total_bytes_parsed);

         } // coding

      } // while (bytes_to_match)

      {
         scoped_perf_section add_bytes_timer("add_bytes_end");
         m_accel.add_bytes_end();
      }

      if (!m_state.encode_eob(m_codec, m_accel, cur_dict_ofs))
      {
         LZHAM_LOG_ERROR(7057);
         return false;
      }

#ifdef LZHAM_LZDEBUG
      if (!m_codec.encode_bits(366, 12))
      {
         LZHAM_LOG_ERROR(7058);
         return false;
      }
#endif

      {
         scoped_perf_section stop_encoding_timer("stop_encoding");
         if (!m_codec.stop_encoding(true))
         {
            LZHAM_LOG_ERROR(7059);
            return false;
         }
      }

      // Coded the entire block - now see if it makes more sense to just send a raw/uncompressed block.

      uint compressed_size = m_codec.get_encoding_buf().size();
      LZHAM_NOTE_UNUSED(compressed_size);

      //bool used_raw_block = false;

#if !LZHAM_FORCE_ALL_RAW_BLOCKS
   #if (defined(LZHAM_DISABLE_RAW_BLOCKS) || defined(LZHAM_LZDEBUG))
       if (0)
   #else
       // TODO: Allow the user to control this threshold, i.e. if less than 1% then just store uncompressed.
       if (compressed_size >= buf_len)
   #endif
#endif
      {
         // Failed to compress the block, so go back to our original state and just code a raw block.
         m_state = m_start_of_block_state;
         m_step = initial_step;
         //m_stats = initial_stats;

         m_codec.reset();

         if (!m_codec.start_encoding(buf_len + 16))
         {
            LZHAM_LOG_ERROR(7060);
            return false;
         }

         if (!m_block_index)
         {
            if (!send_configuration())
            {
               LZHAM_LOG_ERROR(7061);
               return false;
            }
         }

#ifdef LZHAM_LZDEBUG
         if (!m_codec.encode_bits(166, 12))
         {
            LZHAM_LOG_ERROR(7062);
            return false;
         }
#endif

         if (!m_codec.encode_bits(cRawBlock, cBlockHeaderBits))
         {
            LZHAM_LOG_ERROR(7063);
            return false;
         }

         LZHAM_ASSERT(buf_len <= 0x1000000);
         if (!m_codec.encode_bits(buf_len - 1, 24))
         {
            LZHAM_LOG_ERROR(7064);
            return false;
         }

         // Write buf len check bits, to help increase the probability of detecting corrupted data more early.
         uint buf_len0 = (buf_len - 1) & 0xFF;
         uint buf_len1 = ((buf_len - 1) >> 8) & 0xFF;
         uint buf_len2 = ((buf_len - 1) >> 16) & 0xFF;
         if (!m_codec.encode_bits((buf_len0 ^ buf_len1) ^ buf_len2, 8))
         {
            LZHAM_LOG_ERROR(7065);
            return false;
         }

         if (!m_codec.encode_align_to_byte())
         {
            LZHAM_LOG_ERROR(7066);
            return false;
         }

         const uint8* pSrc = m_accel.get_ptr(m_block_start_dict_ofs);

         for (uint i = 0; i < buf_len; i++)
         {
            if (!m_codec.encode_bits(*pSrc++, 8))
            {
               LZHAM_LOG_ERROR(7067);
               return false;
            }
         }

         if (!m_codec.stop_encoding(true))
         {
            LZHAM_LOG_ERROR(7068);
            return false;
         }

         //used_raw_block = true;
         emit_reset_update_rate_command = false;
      }

      {
         scoped_perf_section append_timer("append");

         if (m_comp_buf.empty())
         {
            m_comp_buf.swap(m_codec.get_encoding_buf());
         }
         else
         {
            if (!m_comp_buf.append(m_codec.get_encoding_buf()))
            {
               LZHAM_LOG_ERROR(7069);
               return false;
            }
         }
      }

#if LZHAM_UPDATE_STATS
      LZHAM_VERIFY(m_stats.m_total_bytes == m_src_size);
      if (emit_reset_update_rate_command)
         m_stats.m_total_update_rate_resets++;
#endif

      m_block_index++;

      return true;
   }

} // namespace lzham
// File: lzham_lzcomp_internal.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once
#include "lzham_match_accel.h"
#include "lzham_symbol_codec.h"
#include "lzham_lzbase.h"

namespace lzham
{
   typedef lzham::vector<uint8> byte_vec;

   const uint cMaxParseGraphNodes = 3072;
   const uint cMaxParseThreads = 8;
      
   const uint cMaxParseNodeStates = LZHAM_EXTREME_PARSING_MAX_BEST_ARRIVALS_MAX;
   const uint cDefaultMaxParseNodeStates = 4;
   
   enum compression_level
   {
      cCompressionLevelFastest,
      cCompressionLevelFaster,
      cCompressionLevelDefault,
      cCompressionLevelBetter,
      cCompressionLevelUber,

      cCompressionLevelCount
   };

   struct comp_settings
   {
      uint m_fast_bytes;
      uint m_match_accel_max_matches_per_probe;
      uint m_match_accel_max_probes;
   };
     
   class lzcompressor : public CLZBase
   {
      LZHAM_NO_COPY_OR_ASSIGNMENT_OP(lzcompressor);

   public:
      lzcompressor(lzham_malloc_context malloc_context);

      struct init_params
      {
         enum
         {
            cMinDictSizeLog2 = CLZBase::cMinDictSizeLog2,
            cMaxDictSizeLog2 = CLZBase::cMaxDictSizeLog2,
            cDefaultBlockSize = 1024U*512U
         };

         init_params() :
            m_pTask_pool(NULL),
            m_max_helper_threads(0),
            m_compression_level(cCompressionLevelDefault),
            m_dict_size_log2(22),
            m_block_size(cDefaultBlockSize),
            m_lzham_compress_flags(0),
            m_pSeed_bytes(0),
            m_num_seed_bytes(0),
            m_table_max_update_interval(0),
            m_table_update_interval_slow_rate(0),
            m_extreme_parsing_max_best_arrivals(cDefaultMaxParseNodeStates),
            m_fast_bytes_override(0)
         {
         }

         task_pool* m_pTask_pool;
         uint m_max_helper_threads;

         compression_level m_compression_level;
         uint m_dict_size_log2;

         uint m_block_size;
			                  
         uint m_lzham_compress_flags;

         const void *m_pSeed_bytes;
         uint m_num_seed_bytes;
			         
         uint m_table_max_update_interval;
         uint m_table_update_interval_slow_rate;

         uint m_extreme_parsing_max_best_arrivals;
         uint m_fast_bytes_override;
      };

      bool init(const init_params& params);
      void clear();

      // sync, or sync+dictionary flush 
      bool flush(lzham_flush_t flush_type);

      bool reset();

      bool put_bytes(const void* pBuf, uint buf_len);

      const byte_vec& get_compressed_data() const   { return m_comp_buf; }
            byte_vec& get_compressed_data()         { return m_comp_buf; }

      uint32 get_src_adler32() const { return m_src_adler32; }

   private:
      lzham_malloc_context m_malloc_context;

      class state;
      
      enum
      {
         cLitComplexity = 1,
         cRep0Complexity = 2,
         cRep3Complexity = 5,
         
         cLongMatchComplexity = 6,
         cLongMatchComplexityLenThresh = 9,
         
         cShortMatchComplexity = 7
      };

      struct lzdecision
      {
         int m_pos;  // dict position where decision was evaluated
         int m_len;  // 0 if literal, 1+ if match
         int m_dist; // <0 if match rep, else >=1 is match dist
         
         inline lzdecision() { }
         inline lzdecision(int pos, int len, int dist) : m_pos(pos), m_len(len), m_dist(dist) { }
         
         inline void init(int pos, int len, int dist) { m_pos = pos; m_len = len; m_dist = dist; }

         inline bool is_lit() const { return !m_len; }
         inline bool is_match() const { return m_len > 0; } // may be a rep or full match
         inline bool is_full_match() const { return (m_len > 0) && (m_dist >= 1); }
         inline uint get_len() const { return math::maximum<uint>(m_len, 1); }
         inline bool is_rep() const { return m_dist < 0; }
         inline bool is_rep0() const { return m_dist == -1; }

         uint get_match_dist(const state& s) const;

         inline uint get_complexity() const
         {
            if (is_lit())
               return cLitComplexity;
            else if (is_rep())
            {
               LZHAM_ASSUME(cRep0Complexity == 2);
               return 1 + -m_dist;  // 2, 3, 4, or 5
            }
            else if (get_len() >= cLongMatchComplexityLenThresh)
               return cLongMatchComplexity;
            else
               return cShortMatchComplexity;
         }

         inline uint get_min_codable_len() const
         {
            if (is_lit() || is_rep0())
               return 1;
            else
               return CLZBase::cMinMatchLen;
         }
      };

      struct lzpriced_decision : lzdecision
      {
         lzpriced_decision() { }

         inline lzpriced_decision(int pos, int len, int dist) : lzdecision(pos, len, dist) { }
         inline lzpriced_decision(int pos, int len, int dist, bit_cost_t cost) : lzdecision(pos, len, dist), m_cost(cost) { }
         
         inline void init(int pos, int len, int dist, bit_cost_t cost) { lzdecision::init(pos, len, dist); m_cost = cost; }

         inline bit_cost_t get_cost() const { return m_cost; }

         bit_cost_t m_cost;
      };
      
      struct state_base
      {
         uint m_cur_ofs;
         uint m_cur_state;
         uint m_match_hist[CLZBase::cMatchHistSize];
         
         inline bool operator== (const state_base &rhs) const
         {
            if (m_cur_state != rhs.m_cur_state)
               return false;
            for (uint i = 0; i < CLZBase::cMatchHistSize; i++)
               if (m_match_hist[i] != rhs.m_match_hist[i])
                  return false;
            return true;
         }

         void partial_advance(const lzdecision& lzdec);
         
         inline void save_partial_state(state_base& dst) const
         {
            dst.m_cur_ofs = m_cur_ofs;
            dst.m_cur_state = m_cur_state;
            memcpy(dst.m_match_hist, m_match_hist, sizeof(m_match_hist));
         }

         inline void restore_partial_state(const state_base& src)
         {
            m_cur_ofs = src.m_cur_ofs;
            m_cur_state = src.m_cur_state;
            memcpy(m_match_hist, src.m_match_hist, sizeof(m_match_hist));
         }
      };

      class state : public state_base
      {
      public:
         state(lzham_malloc_context malloc_context = NULL);

         lzham_malloc_context get_malloc_context() const { return m_malloc_context; }
         
         void set_malloc_context(lzham_malloc_context context)
         {
            m_malloc_context = context;
          
            m_lit_table.set_malloc_context(m_malloc_context);
            m_delta_lit_table.set_malloc_context(m_malloc_context);
            m_main_table.set_malloc_context(m_malloc_context);
            for (uint i = 0; i < 2; i++)
            {
               m_rep_len_table[i].set_malloc_context(m_malloc_context);
               m_large_len_table[i].set_malloc_context(m_malloc_context);
            }
            m_dist_lsb_table.set_malloc_context(m_malloc_context);
         }

         void clear();
         
         bool init(CLZBase& lzbase, uint table_max_update_interval, uint table_update_interval_slow_rate);
         void reset();
         
         bit_cost_t get_cost(CLZBase& lzbase, const search_accelerator& dict, const lzdecision& lzdec) const;
         bit_cost_t get_len2_match_cost(CLZBase& lzbase, uint dict_pos, uint len2_match_dist, uint is_match_model_index);
         bit_cost_t get_lit_cost(CLZBase& lzbase, const search_accelerator& dict, uint dict_pos, uint lit_pred0, uint is_match_model_index) const;

         // Returns actual cost.
         void get_rep_match_costs(uint dict_pos, bit_cost_t *pBitcosts, uint match_hist_index, int min_len, int max_len, uint is_match_model_index) const;
         void get_full_match_costs(CLZBase& lzbase, uint dict_pos, bit_cost_t *pBitcosts, uint match_dist, int min_len, int max_len, uint is_match_model_index) const;

         bit_cost_t update_stats(CLZBase& lzbase, const search_accelerator& dict, const lzdecision& lzdec);

         bool advance(CLZBase& lzbase, const search_accelerator& dict, const lzdecision& lzdec);
         bool encode(symbol_codec& codec, CLZBase& lzbase, const search_accelerator& dict, const lzdecision& lzdec);

         void print(symbol_codec& codec, CLZBase& lzbase, const search_accelerator& dict, const lzdecision& lzdec);

         bool encode_eob(symbol_codec& codec, const search_accelerator& dict, uint dict_pos);
         bool encode_reset_state_partial(symbol_codec& codec, const search_accelerator& dict, uint dict_pos);

         void update_match_hist(uint match_dist);
         int find_match_dist(uint match_hist) const;

         void reset_state_partial();
         void start_of_block(const search_accelerator& dict, uint cur_ofs, uint block_index);
         
         void reset_update_rate();
         void reset_tables();

         uint get_pred_char(const search_accelerator& dict, int pos, int backward_ofs) const;

         inline bool will_reference_last_match(const lzdecision& lzdec) const
         {
            return (!lzdec.is_match()) &&  (m_cur_state >= CLZBase::cNumLitStates);
         }

         lzham_malloc_context m_malloc_context;
         
         uint m_block_start_dict_ofs;

         adaptive_bit_model m_is_match_model[CLZBase::cNumStates];

         adaptive_bit_model m_is_rep_model[CLZBase::cNumStates];
         adaptive_bit_model m_is_rep0_model[CLZBase::cNumStates];
         adaptive_bit_model m_is_rep0_single_byte_model[CLZBase::cNumStates];
         adaptive_bit_model m_is_rep1_model[CLZBase::cNumStates];
         adaptive_bit_model m_is_rep2_model[CLZBase::cNumStates];
         
         quasi_adaptive_huffman_data_model m_lit_table;
         quasi_adaptive_huffman_data_model m_delta_lit_table;

         quasi_adaptive_huffman_data_model m_main_table;
         quasi_adaptive_huffman_data_model m_rep_len_table[2];
         quasi_adaptive_huffman_data_model m_large_len_table[2];
         quasi_adaptive_huffman_data_model m_dist_lsb_table;
      };

      class tracked_stat
      {
      public:
         tracked_stat() { clear(); }

         void clear() { m_num = 0; m_total = 0.0f; m_total2 = 0.0f; m_min_val = 9e+99; m_max_val = -9e+99; }
         
         void update(double val) { m_num++; m_total += val; m_total2 += val * val; m_min_val = LZHAM_MIN(m_min_val, val); m_max_val = LZHAM_MAX(m_max_val, val); }

         tracked_stat &operator += (double val) { update(val); return *this; }
         operator double() const { return m_total; }
         
         uint64 get_number_of_values() { return m_num; }
         uint32 get_number_of_values32() { return static_cast<uint32>(LZHAM_MIN(UINT_MAX, m_num)); }
         double get_total() const { return m_total; }
         double get_average() const { return m_num ? m_total / m_num : 0.0f; };
         double get_std_dev() const { return m_num ? sqrt( m_num * m_total2 - m_total * m_total ) / m_num: 0.0f; }
         double get_min_val() const { return m_num ? m_min_val : 0.0f; }
         double get_max_val() const { return m_num ? m_max_val : 0.0f; }

      private:
         uint64 m_num;
         double m_total;
         double m_total2;
         double m_min_val;
         double m_max_val;
      };

      struct coding_stats
      {
         coding_stats() { clear(); }

         void clear();

         void update(const lzdecision& lzdec, const state& cur_state, const search_accelerator& dict, bit_cost_t cost);
         void print();

         uint m_total_bytes;
         uint m_total_contexts;
         double m_total_cost;

         tracked_stat m_context_stats;

         double m_total_match_bits_cost;
         double m_worst_match_bits_cost;
         double m_total_is_match0_bits_cost;
         double m_total_is_match1_bits_cost;
         
         uint m_total_truncated_matches;
         uint m_match_truncation_len_hist[CLZBase::cMaxMatchLen + 1];
         uint m_match_truncation_hist[CLZBase::cMaxMatchLen + 1];
         uint m_match_type_truncation_hist[CLZBase::cNumStates][5];
         uint m_match_type_was_not_truncated_hist[CLZBase::cNumStates][5];
                           
         uint m_total_nonmatches;
         uint m_total_matches;
         
         tracked_stat m_lit_stats;
         tracked_stat m_delta_lit_stats;
         
         tracked_stat m_rep_stats[CLZBase::cMatchHistSize];
         tracked_stat m_rep0_len1_stats;
         tracked_stat m_rep0_len2_plus_stats;

         tracked_stat m_full_match_stats[cMaxMatchLen + 1];
                  
         uint m_total_far_len2_matches;
         uint m_total_near_len2_matches;

         uint m_total_update_rate_resets;

         uint m_max_len2_dist;
      };

      init_params m_params;
      comp_settings m_settings;

      int64 m_src_size;
      uint32 m_src_adler32;

      search_accelerator m_accel;

      symbol_codec m_codec;

      coding_stats m_stats;

      byte_vec m_block_buf;
      byte_vec m_comp_buf;

      uint m_step;

      uint m_block_start_dict_ofs;

      uint m_block_index;

      bool m_finished;
      bool m_use_task_pool;
      bool m_use_extreme_parsing;
            
      struct node_state
      {
         LZHAM_FORCE_INLINE void clear()
         {
            m_total_cost = cBitCostMax; //math::cNearlyInfinite;
            m_total_complexity = UINT_MAX;
         }
         
         // the lzdecision that led from parent to this node_state
         lzdecision m_lzdec;                 
         
         // This is either the state of the parent node (optimal parsing), or the state of the child node (extreme parsing).
         state::state_base m_saved_state;     
         
         // Total cost to arrive at this node state.
         bit_cost_t m_total_cost;                 
         uint m_total_complexity;
         
         // Parent node index.
         int16 m_parent_index;               
         
         // Parent node state index (only valid when extreme parsing).
         int8 m_parent_state_index;          
      };

      struct node
      {
         LZHAM_FORCE_INLINE void clear()
         {
            m_num_node_states = 0;
         }
         
         uint m_num_node_states;                                    
         
         node_state m_node_states[cMaxParseNodeStates];
         
         void add_state(int parent_index, int parent_state_index, const lzdecision &lzdec, const state &parent_state, bit_cost_t total_cost, uint total_complexity, uint max_parse_node_states);
      };

      state m_start_of_block_state;             // state at start of block
      
      state m_state;                            // main thread's current coding state

      struct raw_parse_thread_state
      {
         uint m_start_ofs;
         uint m_bytes_to_match;

         state m_state;
         state *m_pState;

         node m_nodes[cMaxParseGraphNodes + 1];
                                   
         lzham::vector<lzdecision> m_best_decisions;
         bool m_emit_decisions_backwards;

         lzham::vector<lzpriced_decision> m_temp_decisions;

         uint m_max_parse_node_states;
         uint m_max_greedy_decisions;
         uint m_greedy_parse_total_bytes_coded;

         uint m_parse_early_out_thresh;
         uint m_bytes_actually_parsed;

         bool m_greedy_parse_gave_up;
         
         bool m_issue_reset_state_partial;
         bool m_failed;
         bool m_use_semaphore;

         semaphore m_finished;

         bool init(lzcompressor& lzcomp, const lzcompressor::init_params &params);
                  
         void set_malloc_context(lzham_malloc_context malloc_context)
         {
            m_state.set_malloc_context(malloc_context);
            m_best_decisions.set_malloc_context(malloc_context);
            m_temp_decisions.set_malloc_context(malloc_context);
         }
      };

      struct parse_thread_state : raw_parse_thread_state
      {
         uint8 m_unused_alignment_array[128 - (sizeof(raw_parse_thread_state) & 127)];
      };

      uint m_fast_bytes;

      uint m_num_parse_threads;
      parse_thread_state m_parse_thread_state[cMaxParseThreads + 1]; // +1 extra for the greedy parser thread (only used for delta compression)
                                    
      bool send_zlib_header();
      bool init_seed_bytes();
      bool send_final_block();
      bool send_configuration();
      bool extreme_parse(parse_thread_state &parse_state);
      bool optimal_parse(parse_thread_state &parse_state);
      int enumerate_lz_decisions(uint ofs, const state& cur_state, lzham::vector<lzpriced_decision>& decisions, uint min_match_len, uint max_match_len);
      bool greedy_parse(parse_thread_state &parse_state);
      void parse_job_callback(uint64 data, void* pData_ptr);
      bool compress_block(const void* pBuf, uint buf_len);
      bool compress_block_internal(const void* pBuf, uint buf_len);
      bool code_decision(lzdecision lzdec, uint& cur_ofs, uint& bytes_to_match);
      bool send_sync_block(lzham_flush_t flush_type);
   };

} // namespace lzham



// File: lzham_lzcomp_state.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_lzcomp_internal.h"

namespace lzham
{
   static uint get_huge_match_code_len(uint len)
   {
      LZHAM_ASSERT((len > CLZBase::cMaxMatchLen) && (len <= CLZBase::cMaxHugeMatchLen));
      len -= (CLZBase::cMaxMatchLen + 1);

      if (len < 256)
         return 1 + 8;
      else if (len < (256 + 1024))
         return 2 + 10;
      else if (len < (256 + 1024 + 4096))
         return 3 + 12;
      else
         return 3 + 16;
   }

   static uint get_huge_match_code_bits(uint len)
   {
      LZHAM_ASSERT((len > CLZBase::cMaxMatchLen) && (len <= CLZBase::cMaxHugeMatchLen));
      len -= (CLZBase::cMaxMatchLen + 1);

      uint c;
      if (len < 256)
         c = len;
      else if (len < (256 + 1024))
      {
         uint r = (len - 256);
         LZHAM_ASSERT(r <= 1023);
         c = r | (2 << 10);
      }
      else if (len < (256 + 1024 + 4096))
      {
         uint r = (len - (256 + 1024));
         LZHAM_ASSERT(r <= 4095);
         c = r | (6 << 12);
      }
      else
      {
         uint r = (len - (256 + 1024 + 4096));
         LZHAM_ASSERT(r <= 65535);
         c = r | (7 << 16);
      }

      return c;
   }

   uint lzcompressor::lzdecision::get_match_dist(const state& cur_state) const
   {
      if (!is_match())
         return 0;
      else if (is_rep())
      {
         int index = -m_dist - 1;
         LZHAM_ASSERT(index < CLZBase::cMatchHistSize);
         return cur_state.m_match_hist[index];
      }
      else
         return m_dist;
   }

   lzcompressor::state::state(lzham_malloc_context malloc_context) :
      m_malloc_context(malloc_context),
      m_lit_table(malloc_context),
      m_delta_lit_table(malloc_context),
      m_main_table(malloc_context),
      m_dist_lsb_table(malloc_context)
   {
      for (uint i = 0; i < 2; i++)
      {
         m_rep_len_table[i].set_malloc_context(malloc_context);
         m_large_len_table[i].set_malloc_context(malloc_context);
      }

		m_cur_ofs = 0;
		m_cur_state = 0;
		m_block_start_dict_ofs = 0;

		m_match_hist[0] = 1;
		m_match_hist[1] = 1;
		m_match_hist[2] = 1;
		m_match_hist[3] = 1;
   }

   void lzcompressor::state::clear()
   {
      m_cur_ofs = 0;
      m_cur_state = 0;
      m_block_start_dict_ofs = 0;

      for (uint i = 0; i < 2; i++)
      {
         m_rep_len_table[i].clear();
         m_large_len_table[i].clear();
      }
      m_main_table.clear();
      m_dist_lsb_table.clear();

		m_lit_table.clear();
      m_delta_lit_table.clear();

      m_match_hist[0] = 1;
      m_match_hist[1] = 1;
      m_match_hist[2] = 1;
      m_match_hist[3] = 1;
   }

   void lzcompressor::state::reset()
   {
      m_cur_ofs = 0;
      m_cur_state = 0;
      m_block_start_dict_ofs = 0;

      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_match_model); i++) 
         m_is_match_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep_model); i++) 
         m_is_rep_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep0_model); i++) 
         m_is_rep0_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep0_single_byte_model); i++) 
         m_is_rep0_single_byte_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep1_model); i++) 
         m_is_rep1_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep2_model); i++) 
         m_is_rep2_model[i].clear();
      
      for (uint i = 0; i < 2; i++)
      {
         m_rep_len_table[i].reset();
         m_large_len_table[i].reset();
      }
      m_main_table.reset();
      m_dist_lsb_table.reset();

      m_lit_table.reset();
      m_delta_lit_table.reset();
      
      m_match_hist[0] = 1;
      m_match_hist[1] = 1;
      m_match_hist[2] = 1;
      m_match_hist[3] = 1;
   }

   bool lzcompressor::state::init(CLZBase& lzbase, uint table_max_update_interval, uint table_update_interval_slow_rate)
   {
      m_cur_ofs = 0;
      m_cur_state = 0;

      if (!m_rep_len_table[0].init2(m_malloc_context, true, CLZBase::cNumHugeMatchCodes + (CLZBase::cMaxMatchLen - CLZBase::cMinMatchLen + 1), table_max_update_interval, table_update_interval_slow_rate, NULL))
      {
         LZHAM_LOG_ERROR(8000);
         return false;
      }
      if (!m_rep_len_table[1].assign(m_rep_len_table[0])) 
      {
         LZHAM_LOG_ERROR(8001);
         return false;
      }
      
      if (!m_large_len_table[0].init2(m_malloc_context, true, CLZBase::cNumHugeMatchCodes + CLZBase::cLZXNumSecondaryLengths, table_max_update_interval, table_update_interval_slow_rate, NULL))
      {
         LZHAM_LOG_ERROR(8002);
         return false;
      }
      if (!m_large_len_table[1].assign(m_large_len_table[0])) 
      {
         LZHAM_LOG_ERROR(8003);
         return false;
      }

      if (!m_main_table.init2(m_malloc_context, true, CLZBase::cLZXNumSpecialLengths + (lzbase.m_num_lzx_slots - CLZBase::cLZXLowestUsableMatchSlot) * 8, table_max_update_interval, table_update_interval_slow_rate, NULL))
      {
         LZHAM_LOG_ERROR(8004);
         return false;
      }
      if (!m_dist_lsb_table.init2(m_malloc_context, true, 16, table_max_update_interval, table_update_interval_slow_rate, NULL))
      {
         LZHAM_LOG_ERROR(8005);
         return false;
      }

      if (!m_lit_table.init2(m_malloc_context, true, 256, table_max_update_interval, table_update_interval_slow_rate, NULL))
      {
         LZHAM_LOG_ERROR(8006);
         return false;
      }
      
      if (!m_delta_lit_table.init2(m_malloc_context, true, 256, table_max_update_interval, table_update_interval_slow_rate, NULL))
      {
         LZHAM_LOG_ERROR(8007);  
         return false;
      }
      
      m_match_hist[0] = 1;
      m_match_hist[1] = 1;
      m_match_hist[2] = 1;
      m_match_hist[3] = 1;

      return true;
   }

   void lzcompressor::state_base::partial_advance(const lzdecision& lzdec)
   {
      if (lzdec.m_len == 0)
      {
         if (m_cur_state < 4) m_cur_state = 0; else if (m_cur_state < 10) m_cur_state -= 3; else m_cur_state -= 6;
      }
      else
      {
         if (lzdec.m_dist < 0)
         {
            int match_hist_index = -lzdec.m_dist - 1;

            if (!match_hist_index)
            {
               if (lzdec.m_len == 1)
               {
                  m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? 9 : 11;
               }
               else
               {
                  m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? 8 : 11;
               }
            }
            else
            {
               if (match_hist_index == 1)
               {
                  std::swap(m_match_hist[0], m_match_hist[1]);
               }
               else if (match_hist_index == 2)
               {
                  int dist = m_match_hist[2];
                  m_match_hist[2] = m_match_hist[1];
                  m_match_hist[1] = m_match_hist[0];
                  m_match_hist[0] = dist;
               }
               else
               {
                  LZHAM_ASSERT(match_hist_index == 3);

                  int dist = m_match_hist[3];
                  m_match_hist[3] = m_match_hist[2];
                  m_match_hist[2] = m_match_hist[1];
                  m_match_hist[1] = m_match_hist[0];
                  m_match_hist[0] = dist;
               }

               m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? 8 : 11;
            }
         }
         else
         {
            // full
            LZHAM_ASSUME(CLZBase::cMatchHistSize == 4);
            m_match_hist[3] = m_match_hist[2];
            m_match_hist[2] = m_match_hist[1];
            m_match_hist[1] = m_match_hist[0];
            m_match_hist[0] = lzdec.m_dist;

            m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? CLZBase::cNumLitStates : CLZBase::cNumLitStates + 3;
         }
      }

      m_cur_ofs = lzdec.m_pos + lzdec.get_len();
   }

   uint lzcompressor::state::get_pred_char(const search_accelerator& dict, int pos, int backward_ofs) const
   {
      LZHAM_ASSERT(pos >= (int)m_block_start_dict_ofs);
      int limit = pos - m_block_start_dict_ofs;
      if (backward_ofs > limit)
         return 0;
      return dict[pos - backward_ofs];
   }

   bit_cost_t lzcompressor::state::get_cost(CLZBase& lzbase, const search_accelerator& dict, const lzdecision& lzdec) const
   {
      //const uint lit_pred0 = get_pred_char(dict, lzdec.m_pos, 1);

      uint is_match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(m_cur_state);
      LZHAM_ASSERT(is_match_model_index < LZHAM_ARRAY_SIZE(m_is_match_model));
      bit_cost_t cost = m_is_match_model[is_match_model_index].get_cost(lzdec.is_match());

      if (!lzdec.is_match())
      {
         const uint lit = dict[lzdec.m_pos];

         if (m_cur_state < CLZBase::cNumLitStates)
         {
            // literal
            cost += m_lit_table.get_cost(lit);
         }
         else
         {
            // delta literal
            const uint rep_lit0 = dict[(lzdec.m_pos - m_match_hist[0]) & dict.m_max_dict_size_mask];
            
            uint delta_lit = rep_lit0 ^ lit;
				            
            cost += m_delta_lit_table.get_cost(delta_lit);
         }
      }
      else
      {
         // match
         if (lzdec.m_dist < 0)
         {
            // rep match
            cost += m_is_rep_model[m_cur_state].get_cost(1);

            int match_hist_index = -lzdec.m_dist - 1;

            if (!match_hist_index)
            {
               // rep0 match
               cost += m_is_rep0_model[m_cur_state].get_cost(1);

               if (lzdec.m_len == 1)
               {
                  // single byte rep0
                  cost += m_is_rep0_single_byte_model[m_cur_state].get_cost(1);
               }
               else
               {
                  // normal rep0
                  cost += m_is_rep0_single_byte_model[m_cur_state].get_cost(0);

                  if (lzdec.m_len > CLZBase::cMaxMatchLen)
                  {
                     cost += get_huge_match_code_len(lzdec.m_len) + m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates].get_cost((CLZBase::cMaxMatchLen + 1) - CLZBase::cMinMatchLen);
                  }
                  else
                  {
                     cost += m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates].get_cost(lzdec.m_len - CLZBase::cMinMatchLen);
                  }
               }
            }
            else
            {
               if (lzdec.m_len > CLZBase::cMaxMatchLen)
               {
                  cost += get_huge_match_code_len(lzdec.m_len) + m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates].get_cost((CLZBase::cMaxMatchLen + 1) - CLZBase::cMinMatchLen);
               }
               else
               {
                  cost += m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates].get_cost(lzdec.m_len - CLZBase::cMinMatchLen);
               }

               // rep1-rep3 match
               cost += m_is_rep0_model[m_cur_state].get_cost(0);

               if (match_hist_index == 1)
               {
                  // rep1
                  cost += m_is_rep1_model[m_cur_state].get_cost(1);
               }
               else
               {
                  cost += m_is_rep1_model[m_cur_state].get_cost(0);

                  if (match_hist_index == 2)
                  {
                     // rep2
                     cost += m_is_rep2_model[m_cur_state].get_cost(1);
                  }
                  else
                  {
                     LZHAM_ASSERT(match_hist_index == 3);
                     // rep3
                     cost += m_is_rep2_model[m_cur_state].get_cost(0);
                  }
               }
            }
         }
         else
         {
            cost += m_is_rep_model[m_cur_state].get_cost(0);

            LZHAM_ASSERT(lzdec.m_len >= CLZBase::cMinMatchLen);

            // full match
            uint match_slot, match_extra;
            lzbase.compute_lzx_position_slot(lzdec.m_dist, match_slot, match_extra);

            uint match_low_sym = 0;
            if (lzdec.m_len >= 9)
            {
               match_low_sym = 7;
               if (lzdec.m_len > CLZBase::cMaxMatchLen)
               {
                  cost += get_huge_match_code_len(lzdec.m_len) + m_large_len_table[m_cur_state >= CLZBase::cNumLitStates].get_cost((CLZBase::cMaxMatchLen + 1) - 9);
               }
               else
               {
                  cost += m_large_len_table[m_cur_state >= CLZBase::cNumLitStates].get_cost(lzdec.m_len - 9);
               }
            }
            else
               match_low_sym = lzdec.m_len - 2;

            uint match_high_sym = 0;

            LZHAM_ASSERT(match_slot >= CLZBase::cLZXLowestUsableMatchSlot && (match_slot < lzbase.m_num_lzx_slots));
            match_high_sym = match_slot - CLZBase::cLZXLowestUsableMatchSlot;

            uint main_sym = match_low_sym | (match_high_sym << 3);

            cost += m_main_table.get_cost(CLZBase::cLZXNumSpecialLengths + main_sym);

            uint num_extra_bits = lzbase.m_lzx_position_extra_bits[match_slot];
            if (num_extra_bits < 3)
               cost += convert_to_scaled_bitcost(num_extra_bits);
            else
            {
               if (num_extra_bits > 4)
                  cost += convert_to_scaled_bitcost(num_extra_bits - 4);

               cost += m_dist_lsb_table.get_cost(match_extra & 15);
            }
         }
      }

      return cost;
   }

   bit_cost_t lzcompressor::state::get_len2_match_cost(CLZBase& lzbase, uint dict_pos, uint len2_match_dist, uint is_match_model_index)
   {
      LZHAM_NOTE_UNUSED(dict_pos);

      bit_cost_t cost = m_is_match_model[is_match_model_index].get_cost(1);

      cost += m_is_rep_model[m_cur_state].get_cost(0);

      // full match
      uint match_slot, match_extra;
      lzbase.compute_lzx_position_slot(len2_match_dist, match_slot, match_extra);

      const uint match_len = 2;
      uint match_low_sym = match_len - 2;

      uint match_high_sym = 0;

      LZHAM_ASSERT(match_slot >= CLZBase::cLZXLowestUsableMatchSlot && (match_slot < lzbase.m_num_lzx_slots));
      match_high_sym = match_slot - CLZBase::cLZXLowestUsableMatchSlot;

      uint main_sym = match_low_sym | (match_high_sym << 3);

      cost += m_main_table.get_cost(CLZBase::cLZXNumSpecialLengths + main_sym);

      uint num_extra_bits = lzbase.m_lzx_position_extra_bits[match_slot];
      if (num_extra_bits < 3)
         cost += convert_to_scaled_bitcost(num_extra_bits);
      else
      {
         if (num_extra_bits > 4)
            cost += convert_to_scaled_bitcost(num_extra_bits - 4);

         cost += m_dist_lsb_table.get_cost(match_extra & 15);
      }

      return cost;
   }

   bit_cost_t lzcompressor::state::get_lit_cost(CLZBase& lzbase, const search_accelerator& dict, uint dict_pos, uint lit_pred0, uint is_match_model_index) const
   {
		LZHAM_NOTE_UNUSED(lzbase);
		LZHAM_NOTE_UNUSED(lit_pred0);

      bit_cost_t cost = m_is_match_model[is_match_model_index].get_cost(0);

      const uint lit = dict[dict_pos];

      if (m_cur_state < CLZBase::cNumLitStates)
      {
         // literal
         cost += m_lit_table.get_cost(lit);
      }
      else
      {
         // delta literal
         const uint rep_lit0 = dict[(dict_pos - m_match_hist[0]) & dict.m_max_dict_size_mask];
         
         uint delta_lit = rep_lit0 ^ lit;

         cost += m_delta_lit_table.get_cost(delta_lit);
      }

      return cost;
   }

   void lzcompressor::state::get_rep_match_costs(uint dict_pos, bit_cost_t *pBitcosts, uint match_hist_index, int min_len, int max_len, uint is_match_model_index) const
   {
      LZHAM_NOTE_UNUSED(dict_pos);
      // match
      const quasi_adaptive_huffman_data_model &rep_len_table = m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates];

      bit_cost_t base_cost = m_is_match_model[is_match_model_index].get_cost(1);

      base_cost += m_is_rep_model[m_cur_state].get_cost(1);

      if (!match_hist_index)
      {
         // rep0 match
         base_cost += m_is_rep0_model[m_cur_state].get_cost(1);
      }
      else
      {
         // rep1-rep3 matches
         base_cost += m_is_rep0_model[m_cur_state].get_cost(0);

         if (match_hist_index == 1)
         {
            // rep1
            base_cost += m_is_rep1_model[m_cur_state].get_cost(1);
         }
         else
         {
            base_cost += m_is_rep1_model[m_cur_state].get_cost(0);

            if (match_hist_index == 2)
            {
               // rep2
               base_cost += m_is_rep2_model[m_cur_state].get_cost(1);
            }
            else
            {
               // rep3
               base_cost += m_is_rep2_model[m_cur_state].get_cost(0);
            }
         }
      }

      // rep match
      if (!match_hist_index)
      {
         if (min_len == 1)
         {
            // single byte rep0
            pBitcosts[1] = base_cost + m_is_rep0_single_byte_model[m_cur_state].get_cost(1);
            min_len++;
         }

         bit_cost_t rep0_match_base_cost = base_cost + m_is_rep0_single_byte_model[m_cur_state].get_cost(0);
         for (int match_len = min_len; match_len <= max_len; match_len++)
         {
            // normal rep0
            if (match_len > CLZBase::cMaxMatchLen)
            {
               pBitcosts[match_len] = get_huge_match_code_len(match_len) + rep0_match_base_cost + rep_len_table.get_cost((CLZBase::cMaxMatchLen + 1) - CLZBase::cMinMatchLen);
            }
            else
            {
               pBitcosts[match_len] = rep0_match_base_cost + rep_len_table.get_cost(match_len - CLZBase::cMinMatchLen);
            }
         }
      }
      else
      {
         for (int match_len = min_len; match_len <= max_len; match_len++)
         {
            if (match_len > CLZBase::cMaxMatchLen)
            {
               pBitcosts[match_len] = get_huge_match_code_len(match_len) + base_cost + rep_len_table.get_cost((CLZBase::cMaxMatchLen + 1) - CLZBase::cMinMatchLen);
            }
            else
            {
               pBitcosts[match_len] = base_cost + rep_len_table.get_cost(match_len - CLZBase::cMinMatchLen);
            }
         }
      }
   }

   void lzcompressor::state::get_full_match_costs(CLZBase& lzbase, uint dict_pos, bit_cost_t *pBitcosts, uint match_dist, int min_len, int max_len, uint is_match_model_index) const
   {
      LZHAM_NOTE_UNUSED(dict_pos);
      LZHAM_ASSERT(min_len >= CLZBase::cMinMatchLen);

      bit_cost_t cost = m_is_match_model[is_match_model_index].get_cost(1);

      cost += m_is_rep_model[m_cur_state].get_cost(0);

      uint match_slot, match_extra;
      lzbase.compute_lzx_position_slot(match_dist, match_slot, match_extra);
      LZHAM_ASSERT(match_slot >= CLZBase::cLZXLowestUsableMatchSlot && (match_slot < lzbase.m_num_lzx_slots));

      uint num_extra_bits = lzbase.m_lzx_position_extra_bits[match_slot];

      if (num_extra_bits < 3)
         cost += convert_to_scaled_bitcost(num_extra_bits);
      else
      {
         if (num_extra_bits > 4)
            cost += convert_to_scaled_bitcost(num_extra_bits - 4);

         cost += m_dist_lsb_table.get_cost(match_extra & 15);
      }

      uint match_high_sym = match_slot - CLZBase::cLZXLowestUsableMatchSlot;

      const quasi_adaptive_huffman_data_model &large_len_table = m_large_len_table[m_cur_state >= CLZBase::cNumLitStates];

      for (int match_len = min_len; match_len <= max_len; match_len++)
      {
         bit_cost_t len_cost = cost;

         uint match_low_sym = 0;
         if (match_len >= 9)
         {
            match_low_sym = 7;
            if (match_len > CLZBase::cMaxMatchLen)
            {
               len_cost += get_huge_match_code_len(match_len) + large_len_table.get_cost((CLZBase::cMaxMatchLen + 1) - 9);
            }
            else
            {
               len_cost += large_len_table.get_cost(match_len - 9);
            }
         }
         else
            match_low_sym = match_len - 2;

         uint main_sym = match_low_sym | (match_high_sym << 3);

         pBitcosts[match_len] = len_cost + m_main_table.get_cost(CLZBase::cLZXNumSpecialLengths + main_sym);
      }
   }

   bool lzcompressor::state::advance(CLZBase& lzbase, const search_accelerator& dict, const lzdecision& lzdec)
   {
      //const uint lit_pred0 = get_pred_char(dict, lzdec.m_pos, 1);

      uint is_match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(m_cur_state);
      m_is_match_model[is_match_model_index].update(lzdec.is_match());

      if (!lzdec.is_match())
      {
         const uint lit = dict[lzdec.m_pos];

         if (m_cur_state < CLZBase::cNumLitStates)
         {
            // literal
            if (!m_lit_table.update_sym(lit)) 
            {
               LZHAM_LOG_ERROR(8008);
               return false;
            }
         }
         else
         {
            // delta literal
            const uint rep_lit0 = dict[(lzdec.m_pos - m_match_hist[0]) & dict.m_max_dict_size_mask];
            
            uint delta_lit = rep_lit0 ^ lit;
				            
            if (!m_delta_lit_table.update_sym(delta_lit)) 
            {
               LZHAM_LOG_ERROR(8009);
               return false;
            }
         }

         if (m_cur_state < 4) m_cur_state = 0; else if (m_cur_state < 10) m_cur_state -= 3; else m_cur_state -= 6;
      }
      else
      {
         // match
         if (lzdec.m_dist < 0)
         {
            // rep match
            m_is_rep_model[m_cur_state].update(1);

            int match_hist_index = -lzdec.m_dist - 1;

            if (!match_hist_index)
            {
               // rep0 match
               m_is_rep0_model[m_cur_state].update(1);

               if (lzdec.m_len == 1)
               {
                  // single byte rep0
                  m_is_rep0_single_byte_model[m_cur_state].update(1);

                  m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? 9 : 11;
               }
               else
               {
                  // normal rep0
                  m_is_rep0_single_byte_model[m_cur_state].update(0);

                  if (lzdec.m_len > CLZBase::cMaxMatchLen)
                  {
                     if (!m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates].update_sym((CLZBase::cMaxMatchLen + 1) - CLZBase::cMinMatchLen)) 
                     {
                        LZHAM_LOG_ERROR(8010);
                        return false;
                     }
                  }
                  else
                  {
                     if (!m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates].update_sym(lzdec.m_len - CLZBase::cMinMatchLen)) 
                     {
                        LZHAM_LOG_ERROR(8011);
                        return false;
                     }
                  }

                  m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? 8 : 11;
               }
            }
            else
            {
               // rep1-rep3 match
               m_is_rep0_model[m_cur_state].update(0);

               if (lzdec.m_len > CLZBase::cMaxMatchLen)
               {
                  if (!m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates].update_sym((CLZBase::cMaxMatchLen + 1) - CLZBase::cMinMatchLen)) 
                  {
                     LZHAM_LOG_ERROR(8012);
                     return false;
                  }
               }
               else
               {
                  if (!m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates].update_sym(lzdec.m_len - CLZBase::cMinMatchLen)) 
                  {
                     LZHAM_LOG_ERROR(8013);
                     return false;
                  }
               }

               if (match_hist_index == 1)
               {
                  // rep1
                  m_is_rep1_model[m_cur_state].update(1);

                  std::swap(m_match_hist[0], m_match_hist[1]);
               }
               else
               {
                  m_is_rep1_model[m_cur_state].update(0);

                  if (match_hist_index == 2)
                  {
                     // rep2
                     m_is_rep2_model[m_cur_state].update(1);

                     int dist = m_match_hist[2];
                     m_match_hist[2] = m_match_hist[1];
                     m_match_hist[1] = m_match_hist[0];
                     m_match_hist[0] = dist;
                  }
                  else
                  {
                     // rep3
                     m_is_rep2_model[m_cur_state].update(0);

                     int dist = m_match_hist[3];
                     m_match_hist[3] = m_match_hist[2];
                     m_match_hist[2] = m_match_hist[1];
                     m_match_hist[1] = m_match_hist[0];
                     m_match_hist[0] = dist;
                  }
               }

               m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? 8 : 11;
            }
         }
         else
         {
            m_is_rep_model[m_cur_state].update(0);

            LZHAM_ASSERT(lzdec.m_len >= CLZBase::cMinMatchLen);

            // full match
            uint match_slot, match_extra;
            lzbase.compute_lzx_position_slot(lzdec.m_dist, match_slot, match_extra);

            uint match_low_sym = 0;
            int large_len_sym = -1;
            if (lzdec.m_len >= 9)
            {
               match_low_sym = 7;

               large_len_sym = lzdec.m_len - 9;
            }
            else
               match_low_sym = lzdec.m_len - 2;

            uint match_high_sym = 0;

            LZHAM_ASSERT(match_slot >= CLZBase::cLZXLowestUsableMatchSlot && (match_slot < lzbase.m_num_lzx_slots));
            match_high_sym = match_slot - CLZBase::cLZXLowestUsableMatchSlot;

            uint main_sym = match_low_sym | (match_high_sym << 3);

            if (!m_main_table.update_sym(CLZBase::cLZXNumSpecialLengths + main_sym)) 
            {
               LZHAM_LOG_ERROR(8014);
               return false;
            }

            if (large_len_sym >= 0)
            {
               if (lzdec.m_len > CLZBase::cMaxMatchLen)
               {
                  if (!m_large_len_table[m_cur_state >= CLZBase::cNumLitStates].update_sym((CLZBase::cMaxMatchLen + 1) - 9)) 
                  {
                     LZHAM_LOG_ERROR(8015);
                     return false;
                  }
               }
               else
               {
                  if (!m_large_len_table[m_cur_state >= CLZBase::cNumLitStates].update_sym(large_len_sym)) 
                  {
                     LZHAM_LOG_ERROR(8016);
                     return false;
                  }
               }
            }

            uint num_extra_bits = lzbase.m_lzx_position_extra_bits[match_slot];
            if (num_extra_bits >= 3)
            {
               if (!m_dist_lsb_table.update_sym(match_extra & 15)) 
               {
                  LZHAM_LOG_ERROR(8017);
                  return false;
               }
            }

            update_match_hist(lzdec.m_dist);

            m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? CLZBase::cNumLitStates : CLZBase::cNumLitStates + 3;
         }
      }

      m_cur_ofs = lzdec.m_pos + lzdec.get_len();
      return true;
   }

   bool lzcompressor::state::encode(symbol_codec& codec, CLZBase& lzbase, const search_accelerator& dict, const lzdecision& lzdec)
   {
      //const uint lit_pred0 = get_pred_char(dict, lzdec.m_pos, 1);

      uint is_match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(m_cur_state);
      if (!codec.encode(lzdec.is_match(), m_is_match_model[is_match_model_index])) 
      {
         LZHAM_LOG_ERROR(8018);
         return false;
      }

      if (!lzdec.is_match())
      {
         const uint lit = dict[lzdec.m_pos];

#ifdef LZHAM_LZDEBUG
         if (!codec.encode_bits(lit, 8)) 
         {
            LZHAM_LOG_ERROR(8019);  
            return false;
         }
#endif

         if (m_cur_state < CLZBase::cNumLitStates)
         {
            // literal
            if (!codec.encode(lit, m_lit_table)) 
            {
               LZHAM_LOG_ERROR(8020);
               return false;
            }
         }
         else
         {
            // delta literal
            const uint rep_lit0 = dict[(lzdec.m_pos - m_match_hist[0]) & dict.m_max_dict_size_mask];
            
            uint delta_lit = rep_lit0 ^ lit;

#ifdef LZHAM_LZDEBUG
            if (!codec.encode_bits(rep_lit0, 8)) 
            {
               LZHAM_LOG_ERROR(8021);
               return false;
            }
#endif

            if (!codec.encode(delta_lit, m_delta_lit_table)) 
            {
               LZHAM_LOG_ERROR(8022);
               return false;
            }
         }

         if (m_cur_state < 4) m_cur_state = 0; else if (m_cur_state < 10) m_cur_state -= 3; else m_cur_state -= 6;
      }
      else
      {
         // match
         if (lzdec.m_dist < 0)
         {
            // rep match
            if (!codec.encode(1, m_is_rep_model[m_cur_state])) 
            {
               LZHAM_LOG_ERROR(8023);
               return false;
            }

            int match_hist_index = -lzdec.m_dist - 1;

            if (!match_hist_index)
            {
               // rep0 match
               if (!codec.encode(1, m_is_rep0_model[m_cur_state])) 
               {
                  LZHAM_LOG_ERROR(8024);
                  return false;
               }

               if (lzdec.m_len == 1)
               {
                  // single byte rep0
                  if (!codec.encode(1, m_is_rep0_single_byte_model[m_cur_state])) 
                  {
                     LZHAM_LOG_ERROR(8025);
                     return false;
                  }

                  m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? 9 : 11;
               }
               else
               {
                  // normal rep0
                  if (!codec.encode(0, m_is_rep0_single_byte_model[m_cur_state])) 
                  {
                     LZHAM_LOG_ERROR(8026);
                     return false;
                  }

                  if (lzdec.m_len > CLZBase::cMaxMatchLen)
                  {
                     if (!codec.encode((CLZBase::cMaxMatchLen + 1) - CLZBase::cMinMatchLen, m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates])) 
                     {
                        LZHAM_LOG_ERROR(8027);
                        return false;
                     }
                     if (!codec.encode_bits(get_huge_match_code_bits(lzdec.m_len), get_huge_match_code_len(lzdec.m_len))) 
                     {
                        LZHAM_LOG_ERROR(8028);
                        return false;
                     }
                  }
                  else
                  {
                     if (!codec.encode(lzdec.m_len - CLZBase::cMinMatchLen, m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates])) 
                     {
                        LZHAM_LOG_ERROR(8029);
                        return false;
                     }
                  }

                  m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? 8 : 11;
               }
            }
            else
            {
               // rep1-rep3 match
               if (!codec.encode(0, m_is_rep0_model[m_cur_state])) 
               {
                  LZHAM_LOG_ERROR(8030);
                  return false;
               }

               if (lzdec.m_len > CLZBase::cMaxMatchLen)
               {
                  if (!codec.encode((CLZBase::cMaxMatchLen + 1) - CLZBase::cMinMatchLen, m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates])) 
                  {
                     LZHAM_LOG_ERROR(8031);
                     return false;
                  }
                  if (!codec.encode_bits(get_huge_match_code_bits(lzdec.m_len), get_huge_match_code_len(lzdec.m_len))) 
                  {
                     LZHAM_LOG_ERROR(8032);
                     return false;
                  }
               }
               else
               {
                  if (!codec.encode(lzdec.m_len - CLZBase::cMinMatchLen, m_rep_len_table[m_cur_state >= CLZBase::cNumLitStates])) 
                  {
                     LZHAM_LOG_ERROR(8033);
                     return false;
                  }
               }

               if (match_hist_index == 1)
               {
                  // rep1
                  if (!codec.encode(1, m_is_rep1_model[m_cur_state])) 
                  {
                     LZHAM_LOG_ERROR(8034);
                     return false;
                  }

                  std::swap(m_match_hist[0], m_match_hist[1]);
               }
               else
               {
                  if (!codec.encode(0, m_is_rep1_model[m_cur_state])) 
                  {  
                     LZHAM_LOG_ERROR(8035);
                     return false;
                  }

                  if (match_hist_index == 2)
                  {
                     // rep2
                     if (!codec.encode(1, m_is_rep2_model[m_cur_state])) 
                     {
                        LZHAM_LOG_ERROR(8036);
                        return false;
                     }

                     int dist = m_match_hist[2];
                     m_match_hist[2] = m_match_hist[1];
                     m_match_hist[1] = m_match_hist[0];
                     m_match_hist[0] = dist;
                  }
                  else
                  {
                     // rep3
                     if (!codec.encode(0, m_is_rep2_model[m_cur_state])) 
                     {
                        LZHAM_LOG_ERROR(8037);  
                        return false;
                     }

                     int dist = m_match_hist[3];
                     m_match_hist[3] = m_match_hist[2];
                     m_match_hist[2] = m_match_hist[1];
                     m_match_hist[1] = m_match_hist[0];
                     m_match_hist[0] = dist;
                  }
               }

               m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? 8 : 11;
            }
         }
         else
         {
            if (!codec.encode(0, m_is_rep_model[m_cur_state])) 
            {
               LZHAM_LOG_ERROR(8038);
               return false;
            }

            LZHAM_ASSERT(lzdec.m_len >= CLZBase::cMinMatchLen);

            // full match
            uint match_slot, match_extra;
            lzbase.compute_lzx_position_slot(lzdec.m_dist, match_slot, match_extra);

            uint match_low_sym = 0;
            int large_len_sym = -1;
            if (lzdec.m_len >= 9)
            {
               match_low_sym = 7;

               large_len_sym = lzdec.m_len - 9;
            }
            else
               match_low_sym = lzdec.m_len - 2;

            uint match_high_sym = 0;

            LZHAM_ASSERT(match_slot >= CLZBase::cLZXLowestUsableMatchSlot && (match_slot < lzbase.m_num_lzx_slots));
            match_high_sym = match_slot - CLZBase::cLZXLowestUsableMatchSlot;

            uint main_sym = match_low_sym | (match_high_sym << 3);

            if (!codec.encode(CLZBase::cLZXNumSpecialLengths + main_sym, m_main_table)) 
            {  
               LZHAM_LOG_ERROR(8039);
               return false;
            }

            if (large_len_sym >= 0)
            {
               if (lzdec.m_len > CLZBase::cMaxMatchLen)
               {
                  if (!codec.encode((CLZBase::cMaxMatchLen + 1) - 9, m_large_len_table[m_cur_state >= CLZBase::cNumLitStates])) 
                  {
                     LZHAM_LOG_ERROR(8040);
                     return false;
                  }
                  if (!codec.encode_bits(get_huge_match_code_bits(lzdec.m_len), get_huge_match_code_len(lzdec.m_len))) 
                  {
                     LZHAM_LOG_ERROR(8041);
                     return false;
                  }
               }
               else
               {
                  if (!codec.encode(large_len_sym, m_large_len_table[m_cur_state >= CLZBase::cNumLitStates])) 
                  {
                     LZHAM_LOG_ERROR(8042);
                     return false;
                  }
               }
            }

            uint num_extra_bits = lzbase.m_lzx_position_extra_bits[match_slot];
            if (num_extra_bits < 3)
            {
               if (!codec.encode_bits(match_extra, num_extra_bits)) 
               {
                  LZHAM_LOG_ERROR(8043);
                  return false;
               }
            }
            else
            {
               if (num_extra_bits > 4)
               {
                  if (!codec.encode_bits((match_extra >> 4), num_extra_bits - 4)) 
                  {
                     LZHAM_LOG_ERROR(8044);
                     return false;
                  }
               }

               if (!codec.encode(match_extra & 15, m_dist_lsb_table)) 
               {
                  LZHAM_LOG_ERROR(8045);
                  return false;
               }
            }

            update_match_hist(lzdec.m_dist);

            m_cur_state = (m_cur_state < CLZBase::cNumLitStates) ? CLZBase::cNumLitStates : CLZBase::cNumLitStates + 3;
         }

#ifdef LZHAM_LZDEBUG
         if (!codec.encode_bits(m_match_hist[0], 29)) 
         {
            LZHAM_LOG_ERROR(8046);
            return false;
         }
#endif
      }

      m_cur_ofs = lzdec.m_pos + lzdec.get_len();
      return true;
   }

   void lzcompressor::state::print(symbol_codec& codec, CLZBase& lzbase, const search_accelerator& dict, const lzdecision& lzdec)
   {
      LZHAM_NOTE_UNUSED(codec), LZHAM_NOTE_UNUSED(lzbase), LZHAM_NOTE_UNUSED(dict);

      const uint lit_pred0 = get_pred_char(dict, lzdec.m_pos, 1);

      uint is_match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(m_cur_state);

      printf("  pos: %u, state: %u, match_pred: %u, is_match_model_index: %u, is_match: %u, cost: %f\n",
         lzdec.m_pos,
         m_cur_state,
         lit_pred0, is_match_model_index, lzdec.is_match(), get_cost(lzbase, dict, lzdec) / (float)cBitCostScale);

      if (!lzdec.is_match())
      {
         const uint lit = dict[lzdec.m_pos];

         if (m_cur_state < CLZBase::cNumLitStates)
         {
            printf("---Regular lit: %u '%c'\n",
               lit, ((lit >= 32) && (lit <= 127)) ? lit : '.');
         }
         else
         {
            // delta literal
            const uint rep_lit0 = dict[(lzdec.m_pos - m_match_hist[0]) & dict.m_max_dict_size_mask];
            
            uint delta_lit = rep_lit0 ^ lit;

            printf("***Delta lit: %u '%c', Mismatch: %u '%c', Delta: 0x%02X\n",
               lit, ((lit >= 32) && (lit <= 127)) ? lit : '.',
               rep_lit0, ((rep_lit0 >= 32) && (rep_lit0 <= 127)) ? rep_lit0 : '.',
               delta_lit);
         }
      }
      else
      {
         uint actual_match_len = dict.get_match_len(0, lzdec.get_match_dist(*this), CLZBase::cMaxMatchLen);
         LZHAM_ASSERT(actual_match_len >= lzdec.get_len());

         // match
         if (lzdec.m_dist < 0)
         {
            int match_hist_index = -lzdec.m_dist - 1;

            if (!match_hist_index)
            {
               if (lzdec.m_len == 1)
               {
                  printf("!!!Rep 0 len1\n");
               }
               else
               {
                  printf("!!!Rep 0 full len %u\n", lzdec.m_len);
               }
            }
            else
            {
               printf("!!!Rep %u full len %u\n", match_hist_index, lzdec.m_len);
            }
         }
         else
         {
            LZHAM_ASSERT(lzdec.m_len >= CLZBase::cMinMatchLen);

            // full match
            uint match_slot, match_extra;
            lzbase.compute_lzx_position_slot(lzdec.m_dist, match_slot, match_extra);

            uint match_low_sym = 0; LZHAM_NOTE_UNUSED(match_low_sym);
            int large_len_sym = -1; LZHAM_NOTE_UNUSED(large_len_sym);
            if (lzdec.m_len >= 9)
            {
               match_low_sym = 7;

               large_len_sym = lzdec.m_len - 9;
            }
            else
               match_low_sym = lzdec.m_len - 2;

            uint match_high_sym = 0; LZHAM_NOTE_UNUSED(match_high_sym);

            LZHAM_ASSERT(match_slot >= CLZBase::cLZXLowestUsableMatchSlot && (match_slot < lzbase.m_num_lzx_slots));
            match_high_sym = match_slot - CLZBase::cLZXLowestUsableMatchSlot;

            //uint main_sym = match_low_sym | (match_high_sym << 3);

            uint num_extra_bits = lzbase.m_lzx_position_extra_bits[match_slot];
            printf("^^^Full match Len %u Dist %u, Slot %u, ExtraBits: %u", lzdec.m_len, lzdec.m_dist, match_slot, num_extra_bits);

            if (num_extra_bits < 3)
            {
            }
            else
            {
               printf("  (Low 4 bits: %u vs. %u)", lzdec.m_dist & 15, match_extra & 15);
            }
            printf("\n");
         }

         if (actual_match_len > lzdec.get_len())
         {
            printf("  TRUNCATED match, actual len is %u, shortened by %u\n", actual_match_len, actual_match_len - lzdec.get_len());
         }
      }
   }

   bool lzcompressor::state::encode_eob(symbol_codec& codec, const search_accelerator& dict, uint dict_pos)
   {
      LZHAM_NOTE_UNUSED(dict);
      LZHAM_NOTE_UNUSED(dict_pos);

#ifdef LZHAM_LZDEBUG
      if (!codec.encode_bits(CLZBase::cLZHAMDebugSyncMarkerValue, CLZBase::cLZHAMDebugSyncMarkerBits)) 
      {
         LZHAM_LOG_ERROR(8047);
         return false;
      }
      if (!codec.encode_bits(1, 1)) 
      {
         LZHAM_LOG_ERROR(8048);
         return false;
      }
      if (!codec.encode_bits(0, 17)) 
      {
         LZHAM_LOG_ERROR(8049);
         return false;
      }
      if (!codec.encode_bits(m_cur_state, 4)) 
      {
         LZHAM_LOG_ERROR(8050);
         return false;
      }
#endif

      //const uint match_pred = get_pred_char(dict, dict_pos, 1);
      uint is_match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(m_cur_state);
      if (!codec.encode(1, m_is_match_model[is_match_model_index])) 
      {
         LZHAM_LOG_ERROR(8051);
         return false;
      }

      // full match
      if (!codec.encode(0, m_is_rep_model[m_cur_state])) 
      {
         LZHAM_LOG_ERROR(8052);     
         return false;
      }

      return codec.encode(CLZBase::cLZXSpecialCodeEndOfBlockCode, m_main_table);
   }

   bool lzcompressor::state::encode_reset_state_partial(symbol_codec& codec, const search_accelerator& dict, uint dict_pos)
   {
      LZHAM_NOTE_UNUSED(dict);
      LZHAM_NOTE_UNUSED(dict_pos);

#ifdef LZHAM_LZDEBUG
      if (!codec.encode_bits(CLZBase::cLZHAMDebugSyncMarkerValue, CLZBase::cLZHAMDebugSyncMarkerBits)) 
      {  
         LZHAM_LOG_ERROR(8053);
         return false;  
      }
      if (!codec.encode_bits(1, 1)) 
      {
         LZHAM_LOG_ERROR(8054);  
         return false;
      }
      if (!codec.encode_bits(0, 17)) 
      {
         LZHAM_LOG_ERROR(8055);  
         return false;
      }
      if (!codec.encode_bits(m_cur_state, 4)) 
      {  
         LZHAM_LOG_ERROR(8056);
         return false;
      }
#endif

      //const uint match_pred = get_pred_char(dict, dict_pos, 1);
      uint is_match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(m_cur_state);
      if (!codec.encode(1, m_is_match_model[is_match_model_index])) 
      {
         LZHAM_LOG_ERROR(8057);
         return false;
      }

      // full match
      if (!codec.encode(0, m_is_rep_model[m_cur_state])) 
      {
         LZHAM_LOG_ERROR(8058);  
         return false;
      }

      if (!codec.encode(CLZBase::cLZXSpecialCodePartialStateReset, m_main_table))
      {
         LZHAM_LOG_ERROR(8059);
         return false;
      }

      reset_state_partial();
      return true;
   }

   void lzcompressor::state::update_match_hist(uint match_dist)
   {
      LZHAM_ASSUME(CLZBase::cMatchHistSize == 4);
      m_match_hist[3] = m_match_hist[2];
      m_match_hist[2] = m_match_hist[1];
      m_match_hist[1] = m_match_hist[0];
      m_match_hist[0] = match_dist;
   }

   int lzcompressor::state::find_match_dist(uint match_dist) const
   {
      for (uint match_hist_index = 0; match_hist_index < CLZBase::cMatchHistSize; match_hist_index++)
         if (match_dist == m_match_hist[match_hist_index])
            return match_hist_index;

      return -1;
   }

   void lzcompressor::state::reset_state_partial()
   {
      LZHAM_ASSUME(CLZBase::cMatchHistSize == 4);
      m_match_hist[0] = 1;
      m_match_hist[1] = 1;
      m_match_hist[2] = 1;
      m_match_hist[3] = 1;
      m_cur_state = 0;
   }

   void lzcompressor::state::start_of_block(const search_accelerator& dict, uint cur_ofs, uint block_index)
   {
      LZHAM_NOTE_UNUSED(dict), LZHAM_NOTE_UNUSED(block_index);

      reset_state_partial();

      m_cur_ofs = cur_ofs;
      m_block_start_dict_ofs = cur_ofs;
   }

   void lzcompressor::state::reset_update_rate()
   {
      m_lit_table.reset_update_rate();
      m_delta_lit_table.reset_update_rate();

      m_main_table.reset_update_rate();

      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_rep_len_table); i++)
         m_rep_len_table[i].reset_update_rate();

      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_large_len_table); i++)
         m_large_len_table[i].reset_update_rate();

      m_dist_lsb_table.reset_update_rate();
   }

   void lzcompressor::state::reset_tables()
   {
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_match_model); i++) 
         m_is_match_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep_model); i++) 
         m_is_rep_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep0_model); i++) 
         m_is_rep0_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep0_single_byte_model); i++) 
         m_is_rep0_single_byte_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep1_model); i++) 
         m_is_rep1_model[i].clear();
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_rep2_model); i++) 
         m_is_rep2_model[i].clear();

      for (uint i = 0; i < 2; i++)
      {
         m_rep_len_table[i].reset();
         m_large_len_table[i].reset();
      }
      m_main_table.reset();
      m_dist_lsb_table.reset();

      m_lit_table.reset();
      m_delta_lit_table.reset();
   }

   void lzcompressor::coding_stats::clear()
   {
      m_total_bytes = 0;
      m_total_contexts = 0;
      m_total_match_bits_cost = 0;
      m_worst_match_bits_cost = 0;
      m_total_is_match0_bits_cost = 0;
      m_total_is_match1_bits_cost = 0;
      m_context_stats.clear();

      m_total_nonmatches = 0;
      m_total_matches = 0;
      m_total_cost = 0.0f;

      m_lit_stats.clear();
      m_delta_lit_stats.clear();

      m_rep0_len1_stats.clear();
      for (uint i = 0; i < CLZBase::cMatchHistSize; i++)
         m_rep_stats[i].clear();
      m_rep0_len1_stats.clear();
      m_rep0_len2_plus_stats.clear();

      for (uint i = 0; i <= CLZBase::cMaxMatchLen; i++)
         m_full_match_stats[i].clear();

      m_total_far_len2_matches = 0;
      m_total_near_len2_matches = 0;

      m_total_truncated_matches = 0;
      utils::zero_object(m_match_truncation_len_hist);
      utils::zero_object(m_match_truncation_hist);
      utils::zero_object(m_match_type_truncation_hist);
      utils::zero_object(m_match_type_was_not_truncated_hist);

      m_total_update_rate_resets = 0;

      m_max_len2_dist = 0;
   }

   void lzcompressor::coding_stats::print()
   {
      if (!m_total_contexts)
         return;

      printf("-----------\n");
      printf("Coding statistics:\n");
      printf("Total update rate resets: %u\n", m_total_update_rate_resets);
      printf("Total Bytes: %u, Total Contexts: %u, Total Cost: %f bits (%f bytes)\nContext ave cost: %f StdDev: %f Min: %f Max: %f\n", m_total_bytes, m_total_contexts, m_total_cost, m_total_cost / 8.0f, m_context_stats.get_average(), m_context_stats.get_std_dev(), m_context_stats.get_min_val(), m_context_stats.get_max_val());
      printf("Ave bytes per context: %f\n", m_total_bytes / (float)m_total_contexts);

      printf("IsMatch:\n");
      printf("  Total: %u, Cost: %f (%f bytes), Ave. Cost: %f, Worst Cost: %f\n",
         m_total_contexts, m_total_match_bits_cost, m_total_match_bits_cost / 8.0f, m_total_match_bits_cost / math::maximum<uint>(1, m_total_contexts), m_worst_match_bits_cost);

      printf("  IsMatch(0): %u, Cost: %f (%f bytes), Ave. Cost: %f\n",
         m_total_nonmatches, m_total_is_match0_bits_cost, m_total_is_match0_bits_cost / 8.0f, m_total_is_match0_bits_cost / math::maximum<uint>(1, m_total_nonmatches));

      printf("  IsMatch(1): %u, Cost: %f (%f bytes), Ave. Cost: %f\n",
         m_total_matches, m_total_is_match1_bits_cost, m_total_is_match1_bits_cost / 8.0f, m_total_is_match1_bits_cost / math::maximum<uint>(1, m_total_matches));

      printf("Literal stats:\n");
      printf("  Count: %u, Cost: %f (%f bytes), Ave: %f StdDev: %f Min: %f Max: %f\n", m_lit_stats.get_number_of_values32(), m_lit_stats.get_total(), m_lit_stats.get_total() / 8.0f, m_lit_stats.get_average(), m_lit_stats.get_std_dev(), m_lit_stats.get_min_val(), m_lit_stats.get_max_val());

      printf("Delta literal stats:\n");
      printf("  Count: %u, Cost: %f (%f bytes), Ave: %f StdDev: %f Min: %f Max: %f\n", m_delta_lit_stats.get_number_of_values32(), m_delta_lit_stats.get_total(), m_delta_lit_stats.get_total() / 8.0f, m_delta_lit_stats.get_average(), m_delta_lit_stats.get_std_dev(), m_delta_lit_stats.get_min_val(), m_delta_lit_stats.get_max_val());

      printf("Rep0 Len1 stats:\n");
      printf("  Count: %u, Cost: %f (%f bytes), Ave. Cost: %f StdDev: %f Min: %f Max: %f\n", m_rep0_len1_stats.get_number_of_values32(), m_rep0_len1_stats.get_total(), m_rep0_len1_stats.get_total() / 8.0f, m_rep0_len1_stats.get_average(), m_rep0_len1_stats.get_std_dev(), m_rep0_len1_stats.get_min_val(), m_rep0_len1_stats.get_max_val());

      printf("Rep0 Len2+ stats:\n");
      printf("  Count: %u, Cost: %f (%f bytes), Ave. Cost: %f StdDev: %f Min: %f Max: %f\n", m_rep0_len2_plus_stats.get_number_of_values32(), m_rep0_len2_plus_stats.get_total(), m_rep0_len2_plus_stats.get_total() / 8.0f, m_rep0_len2_plus_stats.get_average(), m_rep0_len2_plus_stats.get_std_dev(), m_rep0_len2_plus_stats.get_min_val(), m_rep0_len2_plus_stats.get_max_val());

      for (uint i = 0; i < CLZBase::cMatchHistSize; i++)
      {
         printf("Rep %u stats:\n", i);
         printf("  Count: %u, Cost: %f (%f bytes), Ave. Cost: %f StdDev: %f Min: %f Max: %f\n", m_rep_stats[i].get_number_of_values32(), m_rep_stats[i].get_total(), m_rep_stats[i].get_total() / 8.0f, m_rep_stats[i].get_average(), m_rep_stats[i].get_std_dev(), m_rep_stats[i].get_min_val(), m_rep_stats[i].get_max_val());
      }

      for (uint i = CLZBase::cMinMatchLen; i <= CLZBase::cMaxMatchLen; i++)
      {
         printf("Match %u: Total: %u, Cost: %f (%f bytes), Ave: %f StdDev: %f Min: %f Max: %f\n", i,
            m_full_match_stats[i].get_number_of_values32(), m_full_match_stats[i].get_total(), m_full_match_stats[i].get_total() / 8.0f,
            m_full_match_stats[i].get_average(), m_full_match_stats[i].get_std_dev(), m_full_match_stats[i].get_min_val(), m_full_match_stats[i].get_max_val());
      }

      printf("Total near len2 matches: %u, total far len2 matches: %u\n", m_total_near_len2_matches, m_total_far_len2_matches);
      printf("Total matches: %u, truncated matches: %u\n", m_total_matches, m_total_truncated_matches);
      printf("Max full match len2 distance: %u\n", m_max_len2_dist);

#if 0
      printf("Size of truncation histogram:\n");
      for (uint i = 0; i <= CLZBase::cMaxMatchLen; i++)
      {
         printf("%05u ", m_match_truncation_len_hist[i]);
         if ((i & 15) == 15) printf("\n");
      }
      printf("\n");

      printf("Number of truncations per encoded match length histogram:\n");
      for (uint i = 0; i <= CLZBase::cMaxMatchLen; i++)
      {
         printf("%05u ", m_match_truncation_hist[i]);
         if ((i & 15) == 15) printf("\n");
      }
      printf("\n");

      for (uint s = 0; s < CLZBase::cNumStates; s++)
      {
         printf("-- Match type truncation hist for state %u:\n", s);
         for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_match_type_truncation_hist[s]); i++)
         {
            printf("%u truncated (%3.1f%%), %u not truncated\n", m_match_type_truncation_hist[s][i], 100.0f * (float)m_match_type_truncation_hist[s][i] / (m_match_type_truncation_hist[s][i] + m_match_type_was_not_truncated_hist[s][i]), m_match_type_was_not_truncated_hist[s][i]);
         }
      }
#endif
   }

   void lzcompressor::coding_stats::update(const lzdecision& lzdec, const state& cur_state, const search_accelerator& dict, bit_cost_t cost)
   {
      m_total_bytes += lzdec.get_len();
      m_total_contexts++;

      float cost_in_bits = cost / (float)cBitCostScale;
      LZHAM_ASSERT(cost_in_bits > 0.0f);
      m_total_cost += cost_in_bits;

      m_context_stats.update(cost_in_bits);

      //uint match_pred = cur_state.get_pred_char(dict, lzdec.m_pos, 1);
      uint is_match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(cur_state.m_cur_state);

      if (lzdec.m_len == 0)
      {
         float match_bit_cost = cur_state.m_is_match_model[is_match_model_index].get_cost(0) / (float)cBitCostScale;

         m_total_is_match0_bits_cost += match_bit_cost;
         m_total_match_bits_cost += match_bit_cost;
         m_worst_match_bits_cost = math::maximum<double>(m_worst_match_bits_cost, static_cast<double>(match_bit_cost));
         m_total_nonmatches++;

         if (cur_state.m_cur_state < CLZBase::cNumLitStates)
         {
            m_lit_stats.update(cost_in_bits);
         }
         else
         {
            m_delta_lit_stats.update(cost_in_bits);
         }
      }
      else if (lzdec.m_len <= CLZBase::cMaxMatchLen)
      {
         const uint match_len = lzdec.get_len();

         {
            uint match_dist = lzdec.get_match_dist(cur_state);

            uint cur_lookahead_size = dict.get_lookahead_size();

            uint actual_match_len = dict.get_match_len(0, match_dist, LZHAM_MIN(cur_lookahead_size, static_cast<uint>(CLZBase::cMaxMatchLen)));
            LZHAM_VERIFY(match_len <= actual_match_len);

            m_total_truncated_matches += match_len < actual_match_len;
            m_match_truncation_len_hist[math::maximum<int>(0, actual_match_len - match_len)]++;

            uint type_index = 4;
            if (!lzdec.is_full_match())
            {
               LZHAM_ASSUME(CLZBase::cMatchHistSize == 4);
               type_index = -lzdec.m_dist - 1;
            }

            if (actual_match_len > match_len)
            {
               m_match_truncation_hist[match_len]++;

               m_match_type_truncation_hist[cur_state.m_cur_state][type_index]++;
            }
            else
            {
               m_match_type_was_not_truncated_hist[cur_state.m_cur_state][type_index]++;
            }
         }

         float match_bit_cost = cur_state.m_is_match_model[is_match_model_index].get_cost(1) / (float)cBitCostScale;
         m_total_is_match1_bits_cost += match_bit_cost;
         m_total_match_bits_cost += match_bit_cost;
         m_worst_match_bits_cost = math::maximum<double>(m_worst_match_bits_cost, static_cast<double>(match_bit_cost));
         m_total_matches++;

         if (lzdec.m_dist < 0)
         {
            // rep match
            int match_hist_index = -lzdec.m_dist - 1;
            LZHAM_ASSERT(match_hist_index < CLZBase::cMatchHistSize);

            m_rep_stats[match_hist_index].update(cost_in_bits);

            if (!match_hist_index)
            {
               // rep0 match
               if (lzdec.m_len == 1)
               {
                  m_rep0_len1_stats.update(cost_in_bits);
               }
               else
               {
                  m_rep0_len2_plus_stats.update(cost_in_bits);
               }
            }
         }
         else
         {
            m_full_match_stats[math::minimum<int>(cMaxMatchLen, match_len)].update(cost_in_bits);

            if (match_len == 2)
            {
               if (lzdec.m_dist <= 512)
                  m_total_near_len2_matches++;
               else
                  m_total_far_len2_matches++;

               m_max_len2_dist = LZHAM_MAX((int)m_max_len2_dist, lzdec.m_dist);
            }
         }
      }
      else
      {
         // TODO: Handle huge matches.
      }
   }
} // namespace lzham
// File: lzham_match_accel.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_match_accel.h"
#include "lzham_timer.h"

static const int cHashSize24 = 0x1000000;
static const int cHashSize16 = 0x10000;

namespace lzham
{
   static inline uint32 hash2_to_12(uint c0, uint c1) { return c0 ^ (c1 << 4); }

   #define LZHAM_HASH3_16(c0, c1, c2) ((((uint)c0) | (((uint)c1) << 8U)) ^ (((uint)c2) << 4U))
   #define LZHAM_HASH3_24(c0, c1, c2) (((uint)c0) | (((uint)c1) << 8U) | (((uint)c2) << 16U))
      
   search_accelerator::search_accelerator(lzham_malloc_context malloc_context) :
      m_malloc_context(malloc_context),
      m_pLZBase(NULL),
      m_pTask_pool(NULL),
      m_max_helper_threads(0),
      m_max_dict_size(0),
      m_max_dict_size_mask(0),
      m_lookahead_pos(0),
      m_lookahead_size(0),
      m_cur_dict_size(0),
      m_dict(malloc_context), 
      m_hash(malloc_context), 
      m_nodes(malloc_context), 
      m_matches(malloc_context), 
      m_match_refs(malloc_context), 
      m_digram_hash(malloc_context),
      m_digram_next(malloc_context),
      m_fill_lookahead_pos(0),
      m_fill_lookahead_size(0),
      m_fill_dict_size(0),
      m_max_probes(0),
      m_max_matches(0),
      m_all_matches(false),
      m_deterministic(false),
      m_len2_matches(false),
      m_hash24(false),
      m_next_match_ref(0),
      m_num_completed_helper_threads(0)
   {
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_thread_dict_offsets); i++)
         m_thread_dict_offsets[i].set_malloc_context(malloc_context);
   }

   bool search_accelerator::init(CLZBase* pLZBase, task_pool* pPool, uint max_helper_threads, uint max_dict_size, uint max_matches, bool all_matches, uint max_probes, uint flags)
   {
      LZHAM_ASSERT(pLZBase);
      LZHAM_ASSERT(max_dict_size && math::is_power_of_2(max_dict_size));
      LZHAM_ASSERT(max_probes);

      m_max_probes = LZHAM_MIN(cMatchAccelMaxSupportedProbes, max_probes);
      
      m_deterministic = (flags & cFlagDeterministic) != 0;
      m_len2_matches = (flags & cFlagLen2Matches) != 0;
      m_hash24 = (flags & cFlagHash24) != 0;

      m_pLZBase = pLZBase;
      m_pTask_pool = max_helper_threads ? pPool : NULL;
      m_max_helper_threads = m_pTask_pool ? max_helper_threads : 0;
      m_max_matches = LZHAM_MIN(m_max_probes, max_matches);
      m_all_matches = all_matches;

      m_max_dict_size = max_dict_size;
      m_max_dict_size_mask = m_max_dict_size - 1;
      m_cur_dict_size = 0;
      m_lookahead_size = 0;
      m_lookahead_pos = 0;
      m_fill_lookahead_pos = 0;
      m_fill_lookahead_size = 0;
      m_fill_dict_size = 0;
      m_num_completed_helper_threads = 0;

      if (!m_dict.try_resize_no_construct(max_dict_size + LZHAM_MIN(m_max_dict_size, static_cast<uint>(CLZBase::cMaxHugeMatchLen))))
      {
         LZHAM_LOG_ERROR(9000);
         return false;
      }

      if (!m_hash.try_resize_no_construct(m_hash24 ? cHashSize24 : cHashSize16))
      {
         LZHAM_LOG_ERROR(9001);
         return false;
      }

      memset(m_hash.get_ptr(), 0, m_hash.size_in_bytes());

      if (!m_nodes.try_resize_no_construct(max_dict_size))
      {
         LZHAM_LOG_ERROR(9002);
         return false;
      }

      for (uint i = 0; i < max_helper_threads; i++)
      {
         if (!m_thread_dict_offsets[i].try_reserve(256 * 1024))
         {
            LZHAM_LOG_ERROR(9003);
            return false;
         }
      }
               
      // Shouldn't be necessary
      //if (m_deterministic)
      //   memset(m_nodes.get_ptr(), 0, m_nodes.size_in_bytes());

      return true;
   }

   void search_accelerator::reset()
   {
      m_cur_dict_size = 0;
      m_lookahead_size = 0;
      m_lookahead_pos = 0;
      m_fill_lookahead_pos = 0;
      m_fill_lookahead_size = 0;
      m_fill_dict_size = 0;
      m_num_completed_helper_threads = 0;

      // Clearing the hash tables is only necessary for determinism (otherwise, it's possible the matches returned after a reset will depend on the data processes before the reset).
      if (m_hash.size()) 
         memset(m_hash.get_ptr(), 0, m_hash.size_in_bytes());
      
      if (m_digram_hash.size())
         memset(m_digram_hash.get_ptr(), 0, m_digram_hash.size_in_bytes());
      
      // Shouldn't be necessary
      //if (m_deterministic)
      //   memset(m_nodes.get_ptr(), 0, m_nodes.size_in_bytes());
   }

   void search_accelerator::flush()
   {
      m_cur_dict_size = 0;
   }

   uint search_accelerator::get_max_add_bytes() const
   {
      uint add_pos = static_cast<uint>(m_lookahead_pos & (m_max_dict_size - 1));
      return m_max_dict_size - add_pos;
   }

   static uint8 g_hamming_dist[256] =
   {
      0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
      4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
   };
      
   void search_accelerator::find_all_matches_callback_st(uint64 data, void* pData_ptr)
   {
      scoped_perf_section find_all_matches_timer("find_all_matches_callback_st");

      LZHAM_NOTE_UNUSED(data);
      LZHAM_NOTE_UNUSED(pData_ptr);
      
      dict_match temp_matches[cMatchAccelMaxSupportedProbes * 2];

      uint fill_lookahead_pos = m_fill_lookahead_pos;
      uint fill_dict_size = m_fill_dict_size;
      uint fill_lookahead_size = m_fill_lookahead_size;

      uint c0 = 0, c1 = 0;
      if (fill_lookahead_size >= 2)
      {
         c0 = m_dict[fill_lookahead_pos & m_max_dict_size_mask];
         c1 = m_dict[(fill_lookahead_pos & m_max_dict_size_mask) + 1];
      }

      const uint8* pDict = m_dict.get_ptr();

      while (fill_lookahead_size >= 3)
      {
         uint insert_pos = fill_lookahead_pos & m_max_dict_size_mask;

         uint c2 = pDict[insert_pos + 2];

         uint h;
         if (m_hash24)
            h = LZHAM_HASH3_24(c0, c1, c2);
         else
            h = LZHAM_HASH3_16(c0, c1, c2);

         c0 = c1;
         c1 = c2;

         dict_match *pDstMatch = temp_matches;

         uint cur_pos = m_hash[h];
         m_hash[h] = static_cast<uint>(fill_lookahead_pos);

         uint *pLeft = &m_nodes[insert_pos].m_left;
         uint *pRight = &m_nodes[insert_pos].m_right;

         const uint max_match_len = LZHAM_MIN(static_cast<uint>(CLZBase::cMaxMatchLen), fill_lookahead_size);
         uint best_match_len = 2;

         const uint8* pIns = &pDict[insert_pos];

         uint n = m_max_probes;
         for ( ; ; )
         {
            uint delta_pos = fill_lookahead_pos - cur_pos;
            if ((n-- == 0) || (!delta_pos) || (delta_pos >= fill_dict_size))
            {
               *pLeft = 0;
               *pRight = 0;
               break;
            }

            uint pos = cur_pos & m_max_dict_size_mask;
                                                            
            // Unfortunately, the initial compare match_len must be 0 because of the way we hash and truncate matches at the end of each block.
            uint match_len = 0;
            const uint8* pComp = &pDict[pos];

#if LZHAM_PLATFORM_X360 || (LZHAM_USE_UNALIGNED_INT_LOADS == 0) || LZHAM_BIG_ENDIAN_CPU
            for ( ; match_len < max_match_len; match_len++)
               if (pComp[match_len] != pIns[match_len])
                  break;
#else
            // Compare a qword at a time for a bit more efficiency.
            uint64 x = *reinterpret_cast<const uint64 *>(pComp);
            uint64 y = *reinterpret_cast<const uint64 *>(pIns);
            if ((max_match_len >= 8) && (x == y))
            {
               const uint64* pComp_cur = reinterpret_cast<const uint64*>(pComp) + 1;
               const uint64* pIns_cur = reinterpret_cast<const uint64*>(pIns) + 1;
                              
               const uint64* pComp_end = reinterpret_cast<const uint64*>(pComp + max_match_len - 7);
               while (pComp_cur < pComp_end)
               {
                  if (*pComp_cur != *pIns_cur)
                     break;
                  ++pComp_cur;
                  ++pIns_cur;
               }

               uint alt_match_len = static_cast<uint>(reinterpret_cast<const uint8*>(pComp_cur) - reinterpret_cast<const uint8*>(pComp));
               for ( ; alt_match_len < max_match_len; alt_match_len++)
                  if (pComp[alt_match_len] != pIns[alt_match_len])
                     break;

               match_len = alt_match_len;
            }
            else
            {
               if ((uint32)x == (uint32)y)
               {
                  x >>= 32;
                  y >>= 32;
                  match_len += 4;
               }

               if ((uint16)x == (uint16)y)
               {
                  x >>= 16;
                  y >>= 16;
                  match_len += 2;
               }
               
               if ((uint8)x == (uint8)y)
                  match_len++;
               
               match_len = math::minimum(match_len, max_match_len);
            }
#endif

#ifdef LZVERIFY
            uint check_match_len;
            for (check_match_len = 0; check_match_len < max_match_len; check_match_len++)
               if (pComp[check_match_len] != pIns[check_match_len])
                  break;
            LZHAM_VERIFY(match_len == check_match_len);
#endif

            node *pNode = &m_nodes[pos];

            if (match_len > best_match_len)
            {
               pDstMatch->m_len = static_cast<uint16>(match_len - CLZBase::cMinMatchLen);
               pDstMatch->m_dist = delta_pos;
               pDstMatch++;

               best_match_len = match_len;

               if (match_len == max_match_len)
               {
                  *pLeft = pNode->m_left;
                  *pRight = pNode->m_right;
                  break;
               }
            }
            else if (m_all_matches)
            {
               pDstMatch->m_len = static_cast<uint16>(match_len - CLZBase::cMinMatchLen);
               pDstMatch->m_dist = delta_pos;
               pDstMatch++;
            }
            else if ((best_match_len > 2) && (best_match_len == match_len))
            {
               uint bestMatchDist = pDstMatch[-1].m_dist;
               uint compMatchDist = delta_pos;

               uint bestMatchSlot, bestMatchSlotOfs;
               m_pLZBase->compute_lzx_position_slot(bestMatchDist, bestMatchSlot, bestMatchSlotOfs);

               uint compMatchSlot, compMatchOfs;
               m_pLZBase->compute_lzx_position_slot(compMatchDist, compMatchSlot, compMatchOfs);

               // If both matches uses the same match slot, choose the one with the offset containing the lowest nibble as these bits separately entropy coded.
               // This could choose a match which is further away in the absolute sense, but closer in a coding sense.
               if ( (compMatchSlot < bestMatchSlot) ||
                  ((compMatchSlot >= 8) && (compMatchSlot == bestMatchSlot) && ((compMatchOfs & 15) < (bestMatchSlotOfs & 15))) )
               {
                  LZHAM_ASSERT((pDstMatch[-1].m_len + (uint)CLZBase::cMinMatchLen) == best_match_len);
                  pDstMatch[-1].m_dist = delta_pos;
               }
               else if ((match_len < max_match_len) && (compMatchSlot <= bestMatchSlot))
               {
                  // Choose the match which has lowest hamming distance in the mismatch byte for a tiny win on binary files.
                  // TODO: This competes against the prev. optimization.
                  uint desired_mismatch_byte = pIns[match_len];

                  uint cur_mismatch_byte = pDict[(insert_pos - bestMatchDist + match_len) & m_max_dict_size_mask];
                  uint cur_mismatch_dist = g_hamming_dist[cur_mismatch_byte ^ desired_mismatch_byte];

                  uint new_mismatch_byte = pComp[match_len];
                  uint new_mismatch_dist = g_hamming_dist[new_mismatch_byte ^ desired_mismatch_byte];
                  if (new_mismatch_dist < cur_mismatch_dist)
                  {
                     LZHAM_ASSERT((pDstMatch[-1].m_len + (uint)CLZBase::cMinMatchLen) == best_match_len);
                     pDstMatch[-1].m_dist = delta_pos;
                  }
               }
            }

            uint new_pos;
            if (pComp[match_len] < pIns[match_len])
            {
               *pLeft = cur_pos;
               pLeft = &pNode->m_right;
               new_pos = pNode->m_right;
            }
            else
            {
               *pRight = cur_pos;
               pRight = &pNode->m_left;
               new_pos = pNode->m_left;
            }
            if (new_pos == cur_pos)
               break;
            cur_pos = new_pos;
         }

         const uint num_matches = (uint)(pDstMatch - temp_matches);

         if (num_matches)
         {
            pDstMatch[-1].m_dist |= 0x80000000;

            const uint num_matches_to_write = LZHAM_MIN(num_matches, m_max_matches);

            const uint match_ref_ofs = m_next_match_ref;
            
            m_next_match_ref += num_matches_to_write;

            memcpy(&m_matches[match_ref_ofs],
                   temp_matches + (num_matches - num_matches_to_write),
                   sizeof(temp_matches[0]) * num_matches_to_write);

            m_match_refs[static_cast<uint>(fill_lookahead_pos - m_fill_lookahead_pos)] = match_ref_ofs;
         }
         else
         {
            m_match_refs[static_cast<uint>(fill_lookahead_pos - m_fill_lookahead_pos)] = -2;
         }

         fill_lookahead_pos++;
         fill_lookahead_size--;
         fill_dict_size++;
      }

      while (fill_lookahead_size)
      {
         uint insert_pos = fill_lookahead_pos & m_max_dict_size_mask;
         m_nodes[insert_pos].m_left = 0;
         m_nodes[insert_pos].m_right = 0;

         m_match_refs[static_cast<uint>(fill_lookahead_pos - m_fill_lookahead_pos)] = -2;

         fill_lookahead_pos++;
         fill_lookahead_size--;
         fill_dict_size++;
      }
      
      m_num_completed_helper_threads++;
   }

   void search_accelerator::find_all_matches_callback_mt(uint64 data, void* pData_ptr)
   {
      scoped_perf_section find_all_matches_timer(cVarArgs, "find_all_matches_callback_mt %u", (uint)data);

      LZHAM_NOTE_UNUSED(pData_ptr);
      const uint thread_index = (uint)data;

      dict_match temp_matches[cMatchAccelMaxSupportedProbes * 2];
            
      const uint8* pDict = m_dict.get_ptr();
            
      const uint *pDict_ofsets = m_thread_dict_offsets[thread_index].get_ptr();
      const uint num_dict_offsets = m_thread_dict_offsets[thread_index].size();

      for (uint i = 0; i < num_dict_offsets; i++)
      {
         uint lookahead_ofs = *pDict_ofsets++;
         uint fill_lookahead_pos = m_fill_lookahead_pos + lookahead_ofs;
         uint fill_dict_size = m_fill_dict_size + lookahead_ofs;
         LZHAM_ASSERT(m_fill_lookahead_size > lookahead_ofs);
         uint fill_lookahead_size = m_fill_lookahead_size - lookahead_ofs;
         
         const uint max_match_len = LZHAM_MIN(static_cast<uint>(CLZBase::cMaxMatchLen), fill_lookahead_size);

         uint insert_pos = fill_lookahead_pos & m_max_dict_size_mask;

         uint c0 = pDict[insert_pos];
         uint c1 = pDict[insert_pos + 1];
         uint c2 = pDict[insert_pos + 2];

         uint h;
         if (m_hash24)
            h = LZHAM_HASH3_24(c0, c1, c2);
         else
            h = LZHAM_HASH3_16(c0, c1, c2);

         dict_match* pDstMatch = temp_matches;

         uint cur_pos = m_hash[h];
         m_hash[h] = static_cast<uint>(fill_lookahead_pos);

         uint *pLeft = &m_nodes[insert_pos].m_left;
         uint *pRight = &m_nodes[insert_pos].m_right;
                  
         uint best_match_len = 2;

         const uint8* pIns = &pDict[insert_pos];

         uint n = m_max_probes;
         for ( ; ; )
         {
            uint delta_pos = fill_lookahead_pos - cur_pos;
            if ((n-- == 0) || (!delta_pos) || (delta_pos >= fill_dict_size))
            {
               *pLeft = 0;
               *pRight = 0;
               break;
            }

            uint pos = cur_pos & m_max_dict_size_mask;
                                                            
            // Unfortunately, the initial compare match_len must be 0 because of the way we hash and truncate matches at the end of each block.
            uint match_len = 0;
            const uint8* pComp = &pDict[pos];

#if LZHAM_PLATFORM_X360 || (LZHAM_USE_UNALIGNED_INT_LOADS == 0) || LZHAM_BIG_ENDIAN_CPU
            for ( ; match_len < max_match_len; match_len++)
               if (pComp[match_len] != pIns[match_len])
                  break;
#else
            // Compare a qword at a time for a bit more efficiency.
            uint64 x = *reinterpret_cast<const uint64 *>(pComp);
            uint64 y = *reinterpret_cast<const uint64 *>(pIns);
            if ((max_match_len >= 8) && (x == y))
            {
               const uint64* pComp_cur = reinterpret_cast<const uint64*>(pComp) + 1;
               const uint64* pIns_cur = reinterpret_cast<const uint64*>(pIns) + 1;
                              
               const uint64* pComp_end = reinterpret_cast<const uint64*>(pComp + max_match_len - 7);
               while (pComp_cur < pComp_end)
               {
                  if (*pComp_cur != *pIns_cur)
                     break;
                  ++pComp_cur;
                  ++pIns_cur;
               }

               uint alt_match_len = static_cast<uint>(reinterpret_cast<const uint8*>(pComp_cur) - reinterpret_cast<const uint8*>(pComp));
               for ( ; alt_match_len < max_match_len; alt_match_len++)
                  if (pComp[alt_match_len] != pIns[alt_match_len])
                     break;

               match_len = alt_match_len;
            }
            else
            {
               if ((uint32)x == (uint32)y)
               {
                  x >>= 32;
                  y >>= 32;
                  match_len += 4;
               }

               if ((uint16)x == (uint16)y)
               {
                  x >>= 16;
                  y >>= 16;
                  match_len += 2;
               }
               
               if ((uint8)x == (uint8)y)
                  match_len++;
               
               match_len = math::minimum(match_len, max_match_len);
            }
#endif

#ifdef LZVERIFY
            uint check_match_len;
            for (check_match_len = 0; check_match_len < max_match_len; check_match_len++)
               if (pComp[check_match_len] != pIns[check_match_len])
                  break;
            LZHAM_VERIFY(match_len == check_match_len);
#endif

            node *pNode = &m_nodes[pos];

            if (match_len > best_match_len)
            {
               pDstMatch->m_len = static_cast<uint16>(match_len - CLZBase::cMinMatchLen);
               pDstMatch->m_dist = delta_pos;
               pDstMatch++;

               best_match_len = match_len;

               if (match_len == max_match_len)
               {
                  *pLeft = pNode->m_left;
                  *pRight = pNode->m_right;
                  break;
               }
            }
            else if (m_all_matches)
            {
               pDstMatch->m_len = static_cast<uint16>(match_len - CLZBase::cMinMatchLen);
               pDstMatch->m_dist = delta_pos;
               pDstMatch++;
            }
            else if ((best_match_len > 2) && (best_match_len == match_len))
            {
               uint bestMatchDist = pDstMatch[-1].m_dist;
               uint compMatchDist = delta_pos;

               uint bestMatchSlot, bestMatchSlotOfs;
               m_pLZBase->compute_lzx_position_slot(bestMatchDist, bestMatchSlot, bestMatchSlotOfs);

               uint compMatchSlot, compMatchOfs;
               m_pLZBase->compute_lzx_position_slot(compMatchDist, compMatchSlot, compMatchOfs);

               // If both matches uses the same match slot, choose the one with the offset containing the lowest nibble as these bits separately entropy coded.
               // This could choose a match which is further away in the absolute sense, but closer in a coding sense.
               if ( (compMatchSlot < bestMatchSlot) ||
                  ((compMatchSlot >= 8) && (compMatchSlot == bestMatchSlot) && ((compMatchOfs & 15) < (bestMatchSlotOfs & 15))) )
               {
                  LZHAM_ASSERT((pDstMatch[-1].m_len + (uint)CLZBase::cMinMatchLen) == best_match_len);
                  pDstMatch[-1].m_dist = delta_pos;
               }
               else if ((match_len < max_match_len) && (compMatchSlot <= bestMatchSlot))
               {
                  // Choose the match which has lowest hamming distance in the mismatch byte for a tiny win on binary files.
                  // TODO: This competes against the prev. optimization.
                  uint desired_mismatch_byte = pIns[match_len];

                  uint cur_mismatch_byte = pDict[(insert_pos - bestMatchDist + match_len) & m_max_dict_size_mask];
                  uint cur_mismatch_dist = g_hamming_dist[cur_mismatch_byte ^ desired_mismatch_byte];

                  uint new_mismatch_byte = pComp[match_len];
                  uint new_mismatch_dist = g_hamming_dist[new_mismatch_byte ^ desired_mismatch_byte];
                  if (new_mismatch_dist < cur_mismatch_dist)
                  {
                     LZHAM_ASSERT((pDstMatch[-1].m_len + (uint)CLZBase::cMinMatchLen) == best_match_len);
                     pDstMatch[-1].m_dist = delta_pos;
                  }
               }
            }

            uint new_pos;
            if (pComp[match_len] < pIns[match_len])
            {
               *pLeft = cur_pos;
               pLeft = &pNode->m_right;
               new_pos = pNode->m_right;
            }
            else
            {
               *pRight = cur_pos;
               pRight = &pNode->m_left;
               new_pos = pNode->m_left;
            }
            if (new_pos == cur_pos)
               break;
            cur_pos = new_pos;
         }

         const uint num_matches = (uint)(pDstMatch - temp_matches);

         if (num_matches)
         {
            pDstMatch[-1].m_dist |= 0x80000000;

            const uint num_matches_to_write = LZHAM_MIN(num_matches, m_max_matches);

            const uint match_ref_ofs = static_cast<uint>(atomic_exchange_add(&m_next_match_ref, num_matches_to_write));

            memcpy(&m_matches[match_ref_ofs],
                   temp_matches + (num_matches - num_matches_to_write),
                   sizeof(temp_matches[0]) * num_matches_to_write);

            // FIXME: This is going to really hurt on platforms requiring export barriers.
            LZHAM_MEMORY_EXPORT_BARRIER

            atomic_exchange32((atomic32_t*)&m_match_refs[static_cast<uint>(fill_lookahead_pos - m_fill_lookahead_pos)], match_ref_ofs);
         }
         else
         {
            atomic_exchange32((atomic32_t*)&m_match_refs[static_cast<uint>(fill_lookahead_pos - m_fill_lookahead_pos)], -2);
         }
      }
                  
      atomic_increment32(&m_num_completed_helper_threads);
   }

   bool search_accelerator::find_len2_matches()
   {
      if (!m_digram_hash.size())
      {
         if (!m_digram_hash.try_resize(cDigramHashSize))
         {
            LZHAM_LOG_ERROR(9004);
            return false;
         }
      }

      if (m_digram_next.size() < m_lookahead_size)
      {
         if (!m_digram_next.try_resize(m_lookahead_size))
         {
            LZHAM_LOG_ERROR(9005);
            return false;
         }
      }

      uint lookahead_dict_pos = m_lookahead_pos & m_max_dict_size_mask;

      for (int lookahead_ofs = 0; lookahead_ofs < ((int)m_lookahead_size - 1); ++lookahead_ofs, ++lookahead_dict_pos)
      {
         uint c0 = m_dict[lookahead_dict_pos];
         uint c1 = m_dict[lookahead_dict_pos + 1];

         uint h = hash2_to_12(c0, c1) & (cDigramHashSize - 1);

         m_digram_next[lookahead_ofs] = m_digram_hash[h];
         m_digram_hash[h] = m_lookahead_pos + lookahead_ofs;
      }

      m_digram_next[m_lookahead_size - 1] = 0;

      return true;
   }

   uint search_accelerator::get_len2_match(uint lookahead_ofs)
   {
      if ((m_fill_lookahead_size - lookahead_ofs) < 2)
         return 0;
      if (!m_digram_next.size())
         return 0;

      uint cur_pos = m_lookahead_pos + lookahead_ofs;

      uint next_match_pos = m_digram_next[cur_pos - m_fill_lookahead_pos];

      uint match_dist = cur_pos - next_match_pos;

      if ((!match_dist) || (match_dist > CLZBase::cMaxLen2MatchDist) || (match_dist > (m_cur_dict_size + lookahead_ofs)))
         return 0;

      const uint8* pCur = &m_dict[cur_pos & m_max_dict_size_mask];
      const uint8* pMatch = &m_dict[next_match_pos & m_max_dict_size_mask];

      if ((pCur[0] == pMatch[0]) && (pCur[1] == pMatch[1]))
         return match_dist;

      return 0;
   }

   static inline uint32 bitmix32(uint32 a)                    
   {                      
      a -= (a << 6);                                  
      a ^= (a >> 17);                                 
      a -= (a << 9);                                  
      a ^= (a << 4);                                  
      a -= (a << 3);                                  
      a ^= (a << 10);                                 
      a ^= (a >> 15);                                 
      return a;                                       
   }                                                   
   
   bool search_accelerator::find_all_matches(uint num_bytes)
   {
      if (!m_matches.try_resize_no_construct(m_max_probes * num_bytes))
      {
         LZHAM_LOG_ERROR(9006);
         return false;
      }

      if (!m_match_refs.try_resize_no_construct(num_bytes))
      {
         LZHAM_LOG_ERROR(9007);
         return false;
      }

      memset(m_match_refs.get_ptr(), 0xFF, m_match_refs.size_in_bytes());

      m_fill_lookahead_pos = m_lookahead_pos;
      m_fill_lookahead_size = num_bytes;
      m_fill_dict_size = m_cur_dict_size;

      m_next_match_ref = 0;

      if ((!m_pTask_pool) || (m_max_helper_threads < 1) || (num_bytes < 1024))
      {
         find_all_matches_callback_st(0, NULL);
         
         m_num_completed_helper_threads = 0;
      }
      else
      {
         for (uint i = num_bytes - 2; i < num_bytes; i++)
         {
            uint fill_lookahead_pos = m_fill_lookahead_pos + i;
            uint insert_pos = fill_lookahead_pos & m_max_dict_size_mask;
            m_nodes[insert_pos].m_left = 0;
            m_nodes[insert_pos].m_right = 0;

            m_match_refs[static_cast<uint>(fill_lookahead_pos - m_fill_lookahead_pos)] = -2;
         }

         for (uint i = 0; i < m_max_helper_threads; i++)
            m_thread_dict_offsets[i].try_resize(0);

         uint bytes_to_add = num_bytes - 2;

         scoped_perf_section sect(cVarArgs, "****** find_all_matches_prep %u", bytes_to_add);
                       
         const uint8* pDict = &m_dict[m_lookahead_pos & m_max_dict_size_mask];
                     
         if (m_hash24)
         {
            uint t = (pDict[0] << 8) | (pDict[1] << 16);

            if (math::is_power_of_2(m_max_helper_threads))
            {
               const uint bitmask = (m_max_helper_threads - 1);
               for (uint i = 0; i < bytes_to_add; i++)
               {
                  t = (t >> 8) | (pDict[2] << 16);

                  LZHAM_ASSERT(t == LZHAM_HASH3_24(pDict[0], pDict[1], pDict[2]));

                  uint thread_index = bitmix32(t) & bitmask;

                  if (!m_thread_dict_offsets[thread_index].try_push_back(i))
                  {
                     LZHAM_LOG_ERROR(9008);
                     return false;
                  }

                  pDict++;
               }
            }
            else
            {
               for (uint i = 0; i < bytes_to_add; i++)
               {
                  t = (t >> 8) | (pDict[2] << 16);

                  LZHAM_ASSERT(t == LZHAM_HASH3_24(pDict[0], pDict[1], pDict[2]));

                  uint thread_index = bitmix32(t) % m_max_helper_threads;

                  if (!m_thread_dict_offsets[thread_index].try_push_back(i))
                  {
                     LZHAM_LOG_ERROR(9009);
                     return false;
                  }

                  pDict++;
               }
            }
         }
         else
         {
            uint c0 = pDict[0];
            uint c1 = pDict[1];
                  
            for (uint i = 0; i < bytes_to_add; i++)
            {
               uint c2 = pDict[2];
               
               uint t = LZHAM_HASH3_16(c0, c1, c2);

               c0 = c1;
               c1 = c2;
                                                            
               uint thread_index = bitmix32(t) % m_max_helper_threads;

               if (!m_thread_dict_offsets[thread_index].try_push_back(i))
               {
                  LZHAM_LOG_ERROR(9010);
                  return false;
               }
               
               pDict++;
            }
         }
         
         m_num_completed_helper_threads = 0;
         
         if (!m_pTask_pool->queue_multiple_object_tasks(this, &search_accelerator::find_all_matches_callback_mt, 0, m_max_helper_threads))
         {
            LZHAM_LOG_ERROR(9011);
            return false;
         }
      }

      return m_len2_matches ? find_len2_matches() : true;
   }

   bool search_accelerator::add_bytes_begin(uint num_bytes, const uint8* pBytes)
   {
      LZHAM_ASSERT(num_bytes <= m_max_dict_size);
      LZHAM_ASSERT(!m_lookahead_size);

      uint add_pos = m_lookahead_pos & m_max_dict_size_mask;
      LZHAM_ASSERT((add_pos + num_bytes) <= m_max_dict_size);

      memcpy(&m_dict[add_pos], pBytes, num_bytes);

      uint dict_bytes_to_mirror = LZHAM_MIN(static_cast<uint>(CLZBase::cMaxHugeMatchLen), m_max_dict_size);
      if (add_pos < dict_bytes_to_mirror)
         memcpy(&m_dict[m_max_dict_size], &m_dict[0], dict_bytes_to_mirror);

      m_lookahead_size = num_bytes;

      uint max_possible_dict_size = m_max_dict_size - num_bytes;
      m_cur_dict_size = LZHAM_MIN(m_cur_dict_size, max_possible_dict_size);

      m_next_match_ref = 0;

      return find_all_matches(num_bytes);
   }

   void search_accelerator::add_bytes_end()
   {
      if (m_pTask_pool)
      {
         m_pTask_pool->join();
      }

      LZHAM_ASSERT((uint)m_next_match_ref <= m_matches.size());
   }

   dict_match* search_accelerator::find_matches(uint lookahead_ofs, bool spin)
   {
      LZHAM_ASSERT(lookahead_ofs < m_lookahead_size);

      const uint match_ref_ofs = static_cast<uint>(m_lookahead_pos - m_fill_lookahead_pos + lookahead_ofs);

      int match_ref;
      uint spin_count = 0;

      // This may spin until the match finder job(s) catch up to the caller's lookahead position.
      for ( ; ; )
      {
         match_ref = static_cast<int>(m_match_refs[match_ref_ofs]);
         if (match_ref == -2)
            return NULL;
         else if (match_ref != -1)
            break;

         spin_count++;
         const uint cMaxSpinCount = 1000;
         if ((spin) && (spin_count < cMaxSpinCount))
         {
            lzham_yield_processor();
            lzham_yield_processor();
            lzham_yield_processor();
            lzham_yield_processor();
            lzham_yield_processor();
            lzham_yield_processor();
            lzham_yield_processor();
            lzham_yield_processor();

            LZHAM_MEMORY_IMPORT_BARRIER
         }
         else
         {
            scoped_perf_section sect("find_matches_sleep");

            spin_count = cMaxSpinCount;

            lzham_sleep(1);
         }
      }

      LZHAM_MEMORY_IMPORT_BARRIER

      return &m_matches[match_ref];
   }

   void search_accelerator::advance_bytes(uint num_bytes)
   {
      LZHAM_ASSERT(num_bytes <= m_lookahead_size);

      m_lookahead_pos += num_bytes;
      m_lookahead_size -= num_bytes;

      m_cur_dict_size += num_bytes;
      LZHAM_ASSERT(m_cur_dict_size <= m_max_dict_size);
   }
}
// File: lzham_match_accel.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once
#include "lzham_lzbase.h"
#include "lzham_threading.h"

namespace lzham
{
   const uint cMatchAccelMaxSupportedProbes = 128;
   const uint cMatchAccelMaxSupportedThreads = 32;
      
   struct node
   {
      uint m_left;
      uint m_right;
   };
   
   LZHAM_DEFINE_BITWISE_MOVABLE(node);
   
#pragma pack(push, 1)      
   struct dict_match
   {
      uint m_dist;
      uint16 m_len;

      inline uint get_dist() const { return m_dist & 0x7FFFFFFF; }
      inline uint get_len() const { return m_len + 2; }
      inline bool is_last() const { return (int)m_dist < 0; }
   };
#pragma pack(pop)  

   LZHAM_DEFINE_BITWISE_MOVABLE(dict_match);
   
   class search_accelerator
   {
      LZHAM_NO_COPY_OR_ASSIGNMENT_OP(search_accelerator);

   public:
      search_accelerator(lzham_malloc_context malloc_context);

      lzham_malloc_context get_malloc_context() const { return m_malloc_context; }

      // If all_matches is true, the match finder returns all found matches with no filtering.
      // Otherwise, the finder will tend to return lists of matches with mostly unique lengths.
      // For each length, it will discard matches with worse distances (in the coding sense).
      enum 
      {
         cFlagDeterministic = 1,
         cFlagLen2Matches = 2,
         cFlagHash24 = 4
      };

      bool init(CLZBase* pLZBase, task_pool* pPool, uint max_helper_threads, uint max_dict_size, uint max_matches, bool all_matches, uint max_probes, uint flags);
      
      void reset();
      void flush();
      
      inline uint get_max_dict_size() const { return m_max_dict_size; }
      inline uint get_max_dict_size_mask() const { return m_max_dict_size_mask; }
      inline uint get_cur_dict_size() const { return m_cur_dict_size; }
      
      inline uint get_lookahead_pos() const { return m_lookahead_pos; }
      inline uint get_lookahead_size() const { return m_lookahead_size; }
      
      inline uint get_char(int delta_pos) const { return m_dict[(m_lookahead_pos + delta_pos) & m_max_dict_size_mask]; }
      inline uint get_char(uint cur_dict_pos, int delta_pos) const { return m_dict[(cur_dict_pos + delta_pos) & m_max_dict_size_mask]; }
      inline const uint8* get_ptr(uint pos) const { return &m_dict[pos]; }
      
      uint get_max_helper_threads() const { return m_max_helper_threads; }
      
      inline uint operator[](uint pos) const { return m_dict[pos]; }
            
      uint get_max_add_bytes() const;
      bool add_bytes_begin(uint num_bytes, const uint8* pBytes);
      inline atomic32_t get_num_completed_helper_threads() const { return m_num_completed_helper_threads; }
      void add_bytes_end();

      // Returns the lookahead's raw position/size/dict_size at the time add_bytes_begin() is called.
      inline uint get_fill_lookahead_pos() const { return m_fill_lookahead_pos; }
      inline uint get_fill_lookahead_size() const { return m_fill_lookahead_size; }
      inline uint get_fill_dict_size() const { return m_fill_dict_size; }
      
      uint get_len2_match(uint lookahead_ofs);
      dict_match* find_matches(uint lookahead_ofs, bool spin = true);
            
      void advance_bytes(uint num_bytes);
      
      LZHAM_FORCE_INLINE uint get_match_len(uint lookahead_ofs, int dist, uint max_match_len, uint start_match_len = 0) const
      {
         LZHAM_ASSERT(lookahead_ofs < m_lookahead_size);
         LZHAM_ASSERT(start_match_len <= max_match_len);
         LZHAM_ASSERT(max_match_len <= (get_lookahead_size() - lookahead_ofs));

         const int find_dict_size = m_cur_dict_size + lookahead_ofs;
         if (dist > find_dict_size)
            return 0;

         const uint comp_pos = static_cast<uint>((m_lookahead_pos + lookahead_ofs - dist) & m_max_dict_size_mask);
         const uint lookahead_pos = (m_lookahead_pos + lookahead_ofs) & m_max_dict_size_mask;
         
         const uint8* pComp = &m_dict[comp_pos];
         const uint8* pLookahead = &m_dict[lookahead_pos];
         
         uint match_len;
         for (match_len = start_match_len; match_len < max_match_len; match_len++)
            if (pComp[match_len] != pLookahead[match_len])
               break;

         return match_len;
      }
                  
   public:
      lzham_malloc_context m_malloc_context;

      CLZBase* m_pLZBase;
      task_pool* m_pTask_pool;
      uint m_max_helper_threads;
   
      uint m_max_dict_size;
      uint m_max_dict_size_mask;
      
      uint m_lookahead_pos;
      uint m_lookahead_size;
                  
      uint m_cur_dict_size;
            
      lzham::vector<uint8> m_dict;
            
      lzham::vector<uint> m_hash;
      lzham::vector<node> m_nodes;

      lzham::vector<dict_match> m_matches;
      lzham::vector<atomic32_t> m_match_refs;
                  
      enum { cDigramHashSize = 4096 };
      lzham::vector<uint> m_digram_hash;
      lzham::vector<uint> m_digram_next;

      lzham::vector<uint> m_thread_dict_offsets[cMatchAccelMaxSupportedThreads];
                                          
      uint m_fill_lookahead_pos;
      uint m_fill_lookahead_size;
      uint m_fill_dict_size;
      
      uint m_max_probes;
      uint m_max_matches;
      
      bool m_all_matches;

      bool m_deterministic;
      bool m_len2_matches;
      bool m_hash24;
                  
      volatile atomic32_t m_next_match_ref;
      
      volatile atomic32_t m_num_completed_helper_threads;
                  
      void find_all_matches_callback_st(uint64 data, void* pData_ptr);
      void find_all_matches_callback_mt(uint64 data, void* pData_ptr);
      bool find_all_matches(uint num_bytes);
      bool find_len2_matches();
   };

} // namespace lzham
// File: lzham_task_pool_null.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

namespace lzham
{
   class semaphore
   {
      LZHAM_NO_COPY_OR_ASSIGNMENT_OP(semaphore);

   public:
      inline semaphore(long initialCount = 0, long maximumCount = 1, const char* pName = NULL)
      {
         (void)initialCount, (void)maximumCount, (void)pName;
      }

      inline ~semaphore()
      {
      }

      inline void release(long releaseCount = 1, long *pPreviousCount = NULL)
      {
         (void)releaseCount, (void)pPreviousCount;
      }

      inline bool wait(uint32 milliseconds = cUINT32_MAX)
      {
         (void)milliseconds;
         return true;
      }      
   };   

   class task_pool
   {
   public:
      inline task_pool(lzham_malloc_context malloc_context) { 
(void)malloc_context; }
      inline task_pool(uint num_threads) { (void)num_threads; }
      inline ~task_pool() { }

      inline bool init(uint num_threads) { (void)num_threads; return true; }
      inline void deinit();

      inline uint get_num_threads() const { return 0; }
      inline uint get_num_outstanding_tasks() const { return 0; }

      // C-style task callback
      typedef void (*task_callback_func)(uint64 data, void* pData_ptr);
      inline bool queue_task(task_callback_func pFunc, uint64 data = 0, void* pData_ptr = NULL)
      {
         pFunc(data, pData_ptr);
         return true;
      }

      class executable_task
      {
      public:
         virtual void execute_task(uint64 data, void* pData_ptr) = 0;
      };

      // It's the caller's responsibility to delete pObj within the execute_task() method, if needed!
      inline bool queue_task(executable_task* pObj, uint64 data = 0, void* pData_ptr = NULL)
      {
         pObj->execute_task(data, pData_ptr);
         return true;
      }

      template<typename S, typename T>
      inline bool queue_object_task(S* pObject, T pObject_method, uint64 data = 0, void* pData_ptr = NULL)
      {
         (pObject->*pObject_method)(data, pData_ptr);
         return true;
      }

      template<typename S, typename T>
      inline bool queue_multiple_object_tasks(S* pObject, T pObject_method, uint64 first_data, uint num_tasks, void* pData_ptr = NULL)
      {
         for (uint i = 0; i < num_tasks; i++)
         {
            (pObject->*pObject_method)(first_data + i, pData_ptr);
         }
         return true;
      }

      void join() { }
   };
   
   inline void lzham_sleep(unsigned int milliseconds)
   {
      (void)milliseconds;
   }

   inline uint lzham_get_max_helper_threads()
   {
      return 0;
   }

} // namespace lzham
// File: lzham_task_pool_pthreads.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_pthreads_threading.h"
#include "lzham_timer.h"

#ifdef WIN32
#include <process.h>
#endif

#if defined(__GNUC__) && !defined(__APPLE__) && !defined(__MINGW32__) && !defined(__FreeBSD__)
#include <sys/sysinfo.h>
#endif

#if LZHAM_USE_PTHREADS_API

#ifdef WIN32
#pragma comment(lib, "../ext/libpthread/lib/pthreadVC2.lib")
#endif

namespace lzham
{
   task_pool::task_pool(lzham_malloc_context malloc_context) :
      m_task_stack(malloc_context),
      m_num_threads(0),
      m_tasks_available(0, 32767),
      m_malloc_context(malloc_context),
      m_num_outstanding_tasks(0),
      m_exit_flag(false)
   {
      utils::zero_object(m_threads);
   }

   task_pool::task_pool(lzham_malloc_context malloc_context, uint num_threads) :
      m_task_stack(malloc_context),
      m_num_threads(0),
      m_tasks_available(0, 32767),
      m_malloc_context(malloc_context),
      m_num_outstanding_tasks(0),
      m_exit_flag(false)
   {
      utils::zero_object(m_threads);

      bool status = init(num_threads);
      LZHAM_VERIFY(status);
   }

   task_pool::~task_pool()
   {
      deinit();
   }

   bool task_pool::init(uint num_threads)
   {
      LZHAM_ASSERT(num_threads <= cMaxThreads);
      num_threads = math::minimum<uint>(num_threads, cMaxThreads);

      deinit();

      bool succeeded = true;

      m_num_threads = 0;
      while (m_num_threads < num_threads)
      {
         int status = pthread_create(&m_threads[m_num_threads], NULL, thread_func, this);
         if (status)
         {
            succeeded = false;
            break;
         }

         m_num_threads++;
      }

      if (!succeeded)
      {
         deinit();
         return false;
      }

      return true;
   }

   void task_pool::deinit()
   {
      if (m_num_threads)
      {
         join();

         atomic_exchange32(&m_exit_flag, true);

         m_tasks_available.release(m_num_threads);

         for (uint i = 0; i < m_num_threads; i++)
            pthread_join(m_threads[i], NULL);

         m_num_threads = 0;

         atomic_exchange32(&m_exit_flag, false);
      }

      m_task_stack.clear();
      m_num_outstanding_tasks = 0;
   }

   bool task_pool::queue_task(task_callback_func pFunc, uint64 data, void* pData_ptr)
   {
      LZHAM_ASSERT(m_num_threads);
      LZHAM_ASSERT(pFunc);

      task tsk;
      tsk.m_callback = pFunc;
      tsk.m_data = data;
      tsk.m_pData_ptr = pData_ptr;
      tsk.m_flags = 0;

      if (!m_task_stack.try_push(tsk))
         return false;

      atomic_increment32(&m_num_outstanding_tasks);

      m_tasks_available.release(1);

      return true;
   }

   // It's the object's responsibility to delete pObj within the execute_task() method, if needed!
   bool task_pool::queue_task(executable_task* pObj, uint64 data, void* pData_ptr)
   {
      LZHAM_ASSERT(m_num_threads);
      LZHAM_ASSERT(pObj);

      task tsk;
      tsk.m_pObj = pObj;
      tsk.m_data = data;
      tsk.m_pData_ptr = pData_ptr;
      tsk.m_flags = cTaskFlagObject;

      if (!m_task_stack.try_push(tsk))
         return false;

      atomic_increment32(&m_num_outstanding_tasks);

      m_tasks_available.release(1);

      return true;
   }

   void task_pool::process_task(task& tsk)
   {
      if (tsk.m_flags & cTaskFlagObject)
         tsk.m_pObj->execute_task(tsk.m_data, tsk.m_pData_ptr);
      else
         tsk.m_callback(tsk.m_data, tsk.m_pData_ptr);

      atomic_decrement32(&m_num_outstanding_tasks);
   }

   void task_pool::join()
   {
      task tsk;
      while (atomic_add32(&m_num_outstanding_tasks, 0) > 0)
      {
         if (m_task_stack.pop(tsk))
         {
            process_task(tsk);
         }
         else
         {
            lzham_sleep(1);
         }
      }
   }

   void * task_pool::thread_func(void *pContext)
   {
      task_pool* pPool = static_cast<task_pool*>(pContext);
      task tsk;

      for ( ; ; )
      {
         if (!pPool->m_tasks_available.wait())
            break;

         if (pPool->m_exit_flag)
            break;

         if (pPool->m_task_stack.pop(tsk))
         {
            pPool->process_task(tsk);
         }
      }

      return NULL;
   }

   uint lzham_get_max_helper_threads()
   {
#if defined(__APPLE__) || defined(__FreeBSD__)
      int num_procs = static_cast<int>(sysconf(_SC_NPROCESSORS_ONLN));
      return (num_procs >= 1) ? (num_procs - 1) : 0;
#elif (1)
      uint num_procs = get_nprocs();
      return num_procs ? (num_procs - 1) : 0;
#else
      printf("TODO: lzham_get_max_helper_threads(): Implement system specific func to determine the max # of helper threads\n");
      // Just assume a dual-core machine.
      return 1;
#endif
   }

} // namespace lzham

#endif // LZHAM_USE_PTHREADS_API
// File: lzham_task_pool_pthreads.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

#if LZHAM_USE_PTHREADS_API

#if LZHAM_NO_ATOMICS
#error No atomic operations defined in lzham_platform.h!
#endif

#ifdef __APPLE__
   #include <libkern/OSAtomic.h>
#endif

#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <sys/time.h>

#define LZHAM_RND_CONG(jcong)  (69069U * jcong + 1234567U)

namespace lzham
{
   // semaphore

#ifdef __APPLE__
   class semaphore
   {
      LZHAM_NO_COPY_OR_ASSIGNMENT_OP(semaphore);

   public:
      inline semaphore(long initialCount = 0, long maximumCount = 1)
      {
         LZHAM_NOTE_UNUSED(maximumCount);
         LZHAM_ASSERT(maximumCount >= initialCount);

         for (uint tries = 0; tries < 16; tries++)
         {
            struct timeval tp;
            struct timezone tzp;
            gettimeofday(&tp, &tzp);
            uint x = tp.tv_usec;

            // Argh this stinks. Try to choose a name that won't conflict with anything the calling process uses.
            for (uint i = 0; i < sizeof(m_name) - 1; i++)
            {
               x = LZHAM_RND_CONG(x);
               char c = 'A' + (static_cast<uint8>(x ^ (x >> 20)) % 26);
               m_name[i] = c;
            }
            m_name[sizeof(m_name) - 1] = '\0';

            m_pSem = sem_open(m_name, O_CREAT | O_EXCL, S_IRWXU, initialCount);
            if (m_pSem != SEM_FAILED)
               break;
         }

         if (m_pSem == SEM_FAILED)
         {
            LZHAM_FAIL("semaphore: sem_init() failed");
         }
      }

      inline ~semaphore()
      {
         sem_close(m_pSem);
         sem_unlink(m_name);
      }

      inline void release(long releaseCount = 1)
      {
         LZHAM_ASSERT(releaseCount >= 1);

         int status = 0;
#ifdef WIN32
         if (1 == releaseCount)
            status = sem_post(m_pSem);
         else
            status = sem_post_multiple(m_pSem, releaseCount);
#else
         while (releaseCount > 0)
         {
            status = sem_post(m_pSem);
            if (status)
               break;
            releaseCount--;
         }
#endif

         if (status)
         {
            LZHAM_FAIL("semaphore: sem_post() or sem_post_multiple() failed");
         }
      }

      inline bool wait()
      {
         int status = sem_wait(m_pSem);

         if (status)
         {
            if (errno != ETIMEDOUT)
            {
               LZHAM_FAIL("semaphore: sem_wait() or sem_timedwait() failed");
            }
            return false;
         }

         return true;
      }

   private:
      sem_t *m_pSem;
      char m_name[16];
   };
#else
   class semaphore
   {
      LZHAM_NO_COPY_OR_ASSIGNMENT_OP(semaphore);

   public:
      inline semaphore(long initialCount = 0, long maximumCount = 1, const char* pName = NULL)
      {
         LZHAM_NOTE_UNUSED(maximumCount), LZHAM_NOTE_UNUSED(pName);
         LZHAM_ASSERT(maximumCount >= initialCount);
         if (sem_init(&m_sem, 0, initialCount))
         {
            LZHAM_FAIL("semaphore: sem_init() failed");
         }
      }

      inline ~semaphore()
      {
         sem_destroy(&m_sem);
      }

      inline void release(long releaseCount = 1)
      {
         LZHAM_ASSERT(releaseCount >= 1);

         int status = 0;
#ifdef WIN32
         if (1 == releaseCount)
            status = sem_post(&m_sem);
         else
            status = sem_post_multiple(&m_sem, releaseCount);
#else
         while (releaseCount > 0)
         {
            status = sem_post(&m_sem);
            if (status)
               break;
            releaseCount--;
         }
#endif

         if (status)
         {
            LZHAM_FAIL("semaphore: sem_post() or sem_post_multiple() failed");
         }
      }

      inline bool wait(uint32 milliseconds = cUINT32_MAX)
      {
         int status;
         if (milliseconds == cUINT32_MAX)
         {
            status = sem_wait(&m_sem);
         }
         else
         {
            struct timespec interval;
            interval.tv_sec = milliseconds / 1000;
            interval.tv_nsec = (milliseconds % 1000) * 1000000L;
            status = sem_timedwait(&m_sem, &interval);
         }

         if (status)
         {
            if (errno != ETIMEDOUT)
            {
               LZHAM_FAIL("semaphore: sem_wait() or sem_timedwait() failed");
            }
            return false;
         }

         return true;
      }

   private:
      sem_t m_sem;
   };
#endif
   
   // spinlock   

#ifdef __APPLE__
   class spinlock
   {
   public:
      inline spinlock() : m_lock(0)
      {
      }

      inline ~spinlock()
      {
      }

      inline void lock()
      {
         OSSpinLockLock(&m_lock);
      }

      inline void unlock()
      {
         OSSpinLockUnlock(&m_lock);
      }

   private:

      OSSpinLock m_lock;
   };
#else
   class spinlock
   {
   public:
      inline spinlock()
      {
         if (pthread_spin_init(&m_spinlock, 0))
         {
            LZHAM_FAIL("spinlock: pthread_spin_init() failed");
         }
      }

      inline ~spinlock()
      {
         pthread_spin_destroy(&m_spinlock);
      }

      inline void lock()
      {
         if (pthread_spin_lock(&m_spinlock))
         {
            LZHAM_FAIL("spinlock: pthread_spin_lock() failed");
         }
      }

      inline void unlock()
      {
         if (pthread_spin_unlock(&m_spinlock))
         {
            LZHAM_FAIL("spinlock: pthread_spin_unlock() failed");
         }
      }

   private:
      pthread_spinlock_t m_spinlock;
   };
#endif // __APPLE__

   // Thread safe stack

   template<typename T, uint cMaxSize>
   class tsstack
   {
   public:
      inline tsstack(lzham_malloc_context malloc_context) :
         m_top(0)
      {
         LZHAM_NOTE_UNUSED(malloc_context);
      }

      inline ~tsstack()
      {
      }

      inline void clear()
      {
         m_spinlock.lock();
         m_top = 0;
         m_spinlock.unlock();
      }

      inline bool try_push(const T& obj)
      {
         bool result = false;
         m_spinlock.lock();
         if (m_top < (int)cMaxSize)
         {
            m_stack[m_top++] = obj;
            result = true;
         }
         m_spinlock.unlock();
         return result;
      }

      inline bool pop(T& obj)
      {
         bool result = false;
         m_spinlock.lock();
         if (m_top > 0)
         {
            obj = m_stack[--m_top];
            result = true;
         }
         m_spinlock.unlock();
         return result;
      }

   private:
      spinlock m_spinlock;
      T m_stack[cMaxSize];
      int m_top;
   };
   
   // Simple task pool

   class task_pool
   {
   public:
      task_pool(lzham_malloc_context malloc_context);
      task_pool(lzham_malloc_context malloc_context, uint num_threads);
      ~task_pool();

      lzham_malloc_context get_malloc_context() const { return m_malloc_context; }

      enum { cMaxThreads = LZHAM_MAX_HELPER_THREADS };
      bool init(uint num_threads);
      void deinit();

      inline uint get_num_threads() const { return m_num_threads; }
      inline uint get_num_outstanding_tasks() const { return static_cast<uint>(m_num_outstanding_tasks); }

      // C-style task callback
      typedef void (*task_callback_func)(uint64 data, void* pData_ptr);
      bool queue_task(task_callback_func pFunc, uint64 data = 0, void* pData_ptr = NULL);

      class executable_task
      {
      public:
         virtual void execute_task(uint64 data, void* pData_ptr) = 0;
      };

      // It's the caller's responsibility to delete pObj within the execute_task() method, if needed!
      bool queue_task(executable_task* pObj, uint64 data = 0, void* pData_ptr = NULL);

      template<typename S, typename T>
      inline bool queue_object_task(S* pObject, T pObject_method, uint64 data = 0, void* pData_ptr = NULL);

      template<typename S, typename T>
      inline bool queue_multiple_object_tasks(S* pObject, T pObject_method, uint64 first_data, uint num_tasks, void* pData_ptr = NULL);

      void join();

   private:
      struct task
      {
         inline task() : m_data(0), m_pData_ptr(NULL), m_pObj(NULL), m_flags(0) { }

         uint64 m_data;
         void* m_pData_ptr;

         union
         {
            task_callback_func m_callback;
            executable_task* m_pObj;
         };

         uint m_flags;
      };

      tsstack<task, cMaxThreads> m_task_stack;

      uint m_num_threads;
      pthread_t m_threads[cMaxThreads];

      semaphore m_tasks_available;
      
      lzham_malloc_context m_malloc_context;

      enum task_flags
      {
         cTaskFlagObject = 1
      };

      volatile atomic32_t m_num_outstanding_tasks;
      volatile atomic32_t m_exit_flag;

      void process_task(task& tsk);

      static void* thread_func(void *pContext);
   };

   enum object_task_flags
   {
      cObjectTaskFlagDefault = 0,
      cObjectTaskFlagDeleteAfterExecution = 1
   };

   template<typename T>
   class object_task : public task_pool::executable_task
   {
   public:
      object_task(lzham_malloc_context malloc_context, uint flags = cObjectTaskFlagDefault) :
         m_malloc_context(malloc_context),
         m_pObject(NULL),
         m_pMethod(NULL),
         m_flags(flags)
      {
      }

      typedef void (T::*object_method_ptr)(uint64 data, void* pData_ptr);

      object_task(lzham_malloc_context malloc_context, T* pObject, object_method_ptr pMethod, uint flags = cObjectTaskFlagDefault) :
         m_malloc_context(malloc_context),
         m_pObject(pObject),
         m_pMethod(pMethod),
         m_flags(flags)
      {
         LZHAM_ASSERT(pObject && pMethod);
      }

      void init(lzham_malloc_context malloc_context, T* pObject, object_method_ptr pMethod, uint flags = cObjectTaskFlagDefault)
      {
         LZHAM_ASSERT(pObject && pMethod);
         
         m_malloc_context = malloc_context;
         m_pObject = pObject;
         m_pMethod = pMethod;
         m_flags = flags;
      }

      lzham_malloc_context get_malloc_context() const { return m_malloc_context; }

      T* get_object() const { return m_pObject; }
      object_method_ptr get_method() const { return m_pMethod; }

      virtual void execute_task(uint64 data, void* pData_ptr)
      {
         (m_pObject->*m_pMethod)(data, pData_ptr);

         if (m_flags & cObjectTaskFlagDeleteAfterExecution)
            lzham_delete(m_malloc_context, this);
      }

   protected:
      lzham_malloc_context m_malloc_context;
      T* m_pObject;

      object_method_ptr m_pMethod;

      uint m_flags;
   };

   template<typename S, typename T>
   inline bool task_pool::queue_object_task(S* pObject, T pObject_method, uint64 data, void* pData_ptr)
   {
      object_task<S> *pTask = lzham_new< object_task<S> >(m_malloc_context, m_malloc_context, pObject, pObject_method, cObjectTaskFlagDeleteAfterExecution);
      if (!pTask)
         return false;
      return queue_task(pTask, data, pData_ptr);
   }

   template<typename S, typename T>
   inline bool task_pool::queue_multiple_object_tasks(S* pObject, T pObject_method, uint64 first_data, uint num_tasks, void* pData_ptr)
   {
      LZHAM_ASSERT(m_num_threads);
      LZHAM_ASSERT(pObject);
      LZHAM_ASSERT(num_tasks);
      if (!num_tasks)
         return true;

      bool status = true;

      uint total_to_release = 0;

      for (int i = num_tasks - 1; i >= 0; --i)
      {
         task tsk;

         tsk.m_pObj = lzham_new< object_task<S> >(m_malloc_context, m_malloc_context, pObject, pObject_method, cObjectTaskFlagDeleteAfterExecution);
         if (!tsk.m_pObj)
         {
            status = false;
            break;
         }

         tsk.m_data = first_data + i;
         tsk.m_pData_ptr = pData_ptr;
         tsk.m_flags = cTaskFlagObject;

         if (!m_task_stack.try_push(tsk))
         {
            status = false;
            break;
         }

         total_to_release++;
      }

      if (total_to_release)
      {
         atomic_add32(&m_num_outstanding_tasks, total_to_release);

         m_tasks_available.release(total_to_release);
      }

      return status;
   }
   
   // Sleep

   inline void lzham_sleep(unsigned int milliseconds)
   {
#ifdef WIN32
      struct timespec interval;
      interval.tv_sec = milliseconds / 1000;
      interval.tv_nsec = (milliseconds % 1000) * 1000000L;
      pthread_delay_np(&interval);
#else
      while (milliseconds)
      {
         int msecs_to_sleep = LZHAM_MIN(milliseconds, 1000);
         usleep(msecs_to_sleep * 1000);
         milliseconds -= msecs_to_sleep;
      }
#endif
   }

   // Returns number of helper threads we can add to the process on the current system (i.e. for a 4 CPU system this returns 3).
   uint lzham_get_max_helper_threads();

} // namespace lzham

#endif // LZHAM_USE_PTHREADS_API
// File: lzham_threading.h
// See Copyright Notice and license at the end of include/lzham.h

#if LZHAM_USE_WIN32_API
   #include "lzham_win32_threading.h"
#elif LZHAM_USE_PTHREADS_API
   #include "lzham_pthreads_threading.h"
#else
   #include "lzham_null_threading.h"
#endif


// File: lzham_task_pool_win32.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_win32_threading.h"
#include "lzham_timer.h"
#include "lzham_lzcomp_internal.h"
#include <process.h>

#if LZHAM_USE_WIN32_API

namespace lzham
{
   task_pool::task_pool(lzham_malloc_context malloc_context) :
      m_malloc_context(malloc_context),
      m_task_stack(malloc_context),
      m_num_threads(0),
      m_tasks_available(0, 32767),
      m_num_outstanding_tasks(0),
      m_exit_flag(false)
   {
      utils::zero_object(m_threads);
   }

   task_pool::task_pool(lzham_malloc_context malloc_context, uint num_threads) :
      m_malloc_context(malloc_context),
      m_task_stack(malloc_context),
      m_num_threads(0),
      m_tasks_available(0, 32767),
      m_num_outstanding_tasks(0),
      m_exit_flag(false)
   {
      utils::zero_object(m_threads);

      bool status = init(num_threads);
      LZHAM_VERIFY(status);
   }

   task_pool::~task_pool()
   {
      deinit();
   }

   bool task_pool::init(uint num_threads)
   {
      LZHAM_ASSERT(num_threads <= cMaxThreads);
      num_threads = math::minimum<uint>(num_threads, cMaxThreads);

      deinit();

      bool succeeded = true;

      m_num_threads = 0;
      while (m_num_threads < num_threads)
      {
         m_threads[m_num_threads] = (HANDLE)_beginthreadex(NULL, 32768, thread_func, this, 0, NULL);
         LZHAM_ASSERT(m_threads[m_num_threads] != 0);

         if (!m_threads[m_num_threads])
         {
            succeeded = false;
            LZHAM_LOG_ERROR(10000);
            break;
         }

         m_num_threads++;
      }

      if (!succeeded)
      {
         deinit();
         return false;
      }

      return true;
   }

   void task_pool::deinit()
   {
      if (m_num_threads)
      {
         join();

         atomic_exchange32(&m_exit_flag, true);

         m_tasks_available.release(m_num_threads);

         for (uint i = 0; i < m_num_threads; i++)
         {
            if (m_threads[i])
            {
               for ( ; ; )
               {
                  DWORD result = WaitForSingleObject(m_threads[i], 30000);
                  if ((result == WAIT_OBJECT_0) || (result == WAIT_ABANDONED))
                     break;
               }

               CloseHandle(m_threads[i]);
               m_threads[i] = NULL;
            }
         }

         m_num_threads = 0;

         atomic_exchange32(&m_exit_flag, false);
      }

      m_task_stack.clear();
      m_num_outstanding_tasks = 0;
   }

   bool task_pool::queue_task(task_callback_func pFunc, uint64 data, void* pData_ptr)
   {
      LZHAM_ASSERT(m_num_threads);
      LZHAM_ASSERT(pFunc);

      task tsk;
      tsk.m_callback = pFunc;
      tsk.m_data = data;
      tsk.m_pData_ptr = pData_ptr;
      tsk.m_flags = 0;

      if (!m_task_stack.try_push(tsk))
      {
         LZHAM_LOG_ERROR(10001);
         return false;
      }

      atomic_increment32(&m_num_outstanding_tasks);

      m_tasks_available.release(1);

      return true;
   }

   // It's the object's responsibility to delete pObj within the execute_task() method, if needed!
   bool task_pool::queue_task(executable_task* pObj, uint64 data, void* pData_ptr)
   {
      LZHAM_ASSERT(m_num_threads);
      LZHAM_ASSERT(pObj);

      task tsk;
      tsk.m_pObj = pObj;
      tsk.m_data = data;
      tsk.m_pData_ptr = pData_ptr;
      tsk.m_flags = cTaskFlagObject;

      if (!m_task_stack.try_push(tsk))
      {
         LZHAM_LOG_ERROR(10002);
         return false;
      }

      atomic_increment32(&m_num_outstanding_tasks);

      m_tasks_available.release(1);

      return true;
   }

   void task_pool::process_task(task& tsk)
   {
      if (tsk.m_flags & cTaskFlagObject)
         tsk.m_pObj->execute_task(tsk.m_data, tsk.m_pData_ptr);
      else
         tsk.m_callback(tsk.m_data, tsk.m_pData_ptr);

      atomic_decrement32(&m_num_outstanding_tasks);
   }

   void task_pool::join()
   {
      while (atomic_add32(&m_num_outstanding_tasks, 0) > 0)
      {
         task tsk;
         if (m_task_stack.pop(tsk))
         {
            process_task(tsk);
         }
         else
         {
            lzham_sleep(1);
         }
      }
   }

   unsigned __stdcall task_pool::thread_func(void* pContext)
   {
      task_pool* pPool = static_cast<task_pool*>(pContext);

      for ( ; ; )
      {
         if (!pPool->m_tasks_available.wait())
            break;

         if (pPool->m_exit_flag)
            break;

         task tsk;
         if (pPool->m_task_stack.pop(tsk))
         {
            pPool->process_task(tsk);
         }
      }

      _endthreadex(0);
      return 0;
   }

   static uint g_num_processors;

   uint lzham_get_max_helper_threads()
   {
      if (!g_num_processors)
      {
         SYSTEM_INFO system_info;
         GetSystemInfo(&system_info);
         g_num_processors = system_info.dwNumberOfProcessors;
      }

      if (g_num_processors > 1)
      {
         // use all CPU's
         return LZHAM_MIN((uint)task_pool::cMaxThreads, g_num_processors - 1);
      }

      return 0;
   }

} // namespace lzham

#endif // LZHAM_USE_WIN32_API
// File: lzham_task_pool_win32.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

#if LZHAM_USE_WIN32_API

#if LZHAM_NO_ATOMICS
#error No atomic operations defined in lzham_platform.h!
#endif

namespace lzham
{
   class semaphore
   {
      LZHAM_NO_COPY_OR_ASSIGNMENT_OP(semaphore);

   public:
      semaphore(long initialCount = 0, long maximumCount = 1, const char* pName = NULL)
      {
         m_handle = CreateSemaphoreA(NULL, initialCount, maximumCount, pName);
         if (NULL == m_handle)
         {
            LZHAM_LOG_ERROR(10004);
            LZHAM_FAIL("semaphore: CreateSemaphore() failed");
         }
      }

      ~semaphore()
      {
         if (m_handle)
         {
            CloseHandle(m_handle);
            m_handle = NULL;
         }
      }

      inline HANDLE get_handle(void) const { return m_handle; }

      void release(long releaseCount = 1)
      {
         if (0 == ReleaseSemaphore(m_handle, releaseCount, NULL))
         {
            LZHAM_LOG_ERROR(10005);
            LZHAM_FAIL("semaphore: ReleaseSemaphore() failed");
         }
      }

      bool wait(uint32 milliseconds = cUINT32_MAX)
      {
         LZHAM_ASSUME(INFINITE == cUINT32_MAX);

         DWORD result = WaitForSingleObject(m_handle, milliseconds);

         if (WAIT_FAILED == result)
         {
            LZHAM_LOG_ERROR(10003);
            LZHAM_FAIL("semaphore: WaitForSingleObject() failed");
         }

         return WAIT_OBJECT_0 == result;
      }

   private:
      HANDLE m_handle;
   };

   template<typename T>
   class tsstack
   {
   public:
      inline tsstack(lzham_malloc_context malloc_context, bool use_freelist = true) :
         m_malloc_context(malloc_context),
         m_use_freelist(use_freelist)
      {
         LZHAM_VERIFY(((ptr_bits_t)this & (LZHAM_GET_ALIGNMENT(tsstack) - 1)) == 0);
         InitializeSListHead(&m_stack_head);
         InitializeSListHead(&m_freelist_head);
      }

      inline ~tsstack()
      {
         clear();
      }

      inline void clear()
      {
         for ( ; ; )
         {
            node* pNode = (node*)InterlockedPopEntrySList(&m_stack_head);
            if (!pNode)
               break;

            LZHAM_MEMORY_IMPORT_BARRIER

            helpers::destruct(&pNode->m_obj);

            lzham_free(m_malloc_context, pNode);
         }

         flush_freelist();
      }

      inline void flush_freelist()
      {
         if (!m_use_freelist)
            return;

         for ( ; ; )
         {
            node* pNode = (node*)InterlockedPopEntrySList(&m_freelist_head);
            if (!pNode)
               break;

            LZHAM_MEMORY_IMPORT_BARRIER

            lzham_free(m_malloc_context, pNode);
         }
      }

      inline bool try_push(const T& obj)
      {
         node* pNode = alloc_node();
         if (!pNode)
            return false;

         helpers::construct(&pNode->m_obj, obj);

         LZHAM_MEMORY_EXPORT_BARRIER

         InterlockedPushEntrySList(&m_stack_head, &pNode->m_slist_entry);

         return true;
      }

      inline bool pop(T& obj)
      {
         node* pNode = (node*)InterlockedPopEntrySList(&m_stack_head);
         if (!pNode)
            return false;

         LZHAM_MEMORY_IMPORT_BARRIER

         obj = pNode->m_obj;

         helpers::destruct(&pNode->m_obj);

         free_node(pNode);

         return true;
      }

   private:
      SLIST_HEADER m_stack_head;
      SLIST_HEADER m_freelist_head;
      
      struct node
      {
         SLIST_ENTRY m_slist_entry;
         T m_obj;
      };

      lzham_malloc_context m_malloc_context;

      bool m_use_freelist;

      inline node* alloc_node()
      {
         node* pNode = m_use_freelist ? (node*)InterlockedPopEntrySList(&m_freelist_head) : NULL;

         if (!pNode)
            pNode = (node*)lzham_malloc(m_malloc_context, sizeof(node));

         return pNode;
      }

      inline void free_node(node* pNode)
      {
         if (m_use_freelist)
            InterlockedPushEntrySList(&m_freelist_head, &pNode->m_slist_entry);
         else
            lzham_free(m_malloc_context, pNode);
      }
   };

   class task_pool
   {
      LZHAM_NO_COPY_OR_ASSIGNMENT_OP(task_pool);

   public:
      task_pool(lzham_malloc_context malloc_context);
      task_pool(lzham_malloc_context malloc_context, uint num_threads);
      ~task_pool();

      lzham_malloc_context get_malloc_context() const { return m_malloc_context; }

      enum { cMaxThreads = LZHAM_MAX_HELPER_THREADS };
      bool init(uint num_threads);
      void deinit();

      inline uint get_num_threads() const { return m_num_threads; }
      inline uint get_num_outstanding_tasks() const { return m_num_outstanding_tasks; }

      // C-style task callback
      typedef void (*task_callback_func)(uint64 data, void* pData_ptr);
      bool queue_task(task_callback_func pFunc, uint64 data = 0, void* pData_ptr = NULL);

      class executable_task
      {
      public:
         virtual void execute_task(uint64 data, void* pData_ptr) = 0;
      };

      // It's the caller's responsibility to delete pObj within the execute_task() method, if needed!
      bool queue_task(executable_task* pObj, uint64 data = 0, void* pData_ptr = NULL);

      template<typename S, typename T>
      inline bool queue_object_task(S* pObject, T pObject_method, uint64 data = 0, void* pData_ptr = NULL);

      template<typename S, typename T>
      inline bool queue_multiple_object_tasks(S* pObject, T pObject_method, uint64 first_data, uint num_tasks, void* pData_ptr = NULL);

      void join();

   private:
      struct task
      {
         //inline task() : m_data(0), m_pData_ptr(NULL), m_pObj(NULL), m_flags(0) { }

         uint64 m_data;
         void* m_pData_ptr;

         union
         {
            task_callback_func m_callback;
            executable_task* m_pObj;
         };

         uint m_flags;
      };

      lzham_malloc_context m_malloc_context;

      tsstack<task> m_task_stack;

      uint m_num_threads;
      HANDLE m_threads[cMaxThreads];

      semaphore m_tasks_available;

      enum task_flags
      {
         cTaskFlagObject = 1
      };

      volatile atomic32_t m_num_outstanding_tasks;
      volatile atomic32_t m_exit_flag;

      void process_task(task& tsk);

      static unsigned __stdcall thread_func(void* pContext);
   };

   enum object_task_flags
   {
      cObjectTaskFlagDefault = 0,
      cObjectTaskFlagDeleteAfterExecution = 1
   };

   template<typename T>
   class object_task : public task_pool::executable_task
   {
   public:
      object_task(lzham_malloc_context malloc_context, uint flags = cObjectTaskFlagDefault) :
         m_malloc_context(malloc_context),
         m_pObject(NULL),
         m_pMethod(NULL),
         m_flags(flags)
      {
      }

      typedef void (T::*object_method_ptr)(uint64 data, void* pData_ptr);

      object_task(lzham_malloc_context malloc_context, T* pObject, object_method_ptr pMethod, uint flags = cObjectTaskFlagDefault) :
         m_malloc_context(malloc_context),
         m_pObject(pObject),
         m_pMethod(pMethod),
         m_flags(flags)
      {
         LZHAM_ASSERT(pObject && pMethod);
      }

      void init(lzham_malloc_context malloc_context, T* pObject, object_method_ptr pMethod, uint flags = cObjectTaskFlagDefault)
      {
         LZHAM_ASSERT(pObject && pMethod);

         m_malloc_context = malloc_context;
         m_pObject = pObject;
         m_pMethod = pMethod;
         m_flags = flags;
      }

      T* get_object() const { return m_pObject; }
      object_method_ptr get_method() const { return m_pMethod; }

      virtual void execute_task(uint64 data, void* pData_ptr)
      {
         (m_pObject->*m_pMethod)(data, pData_ptr);

         if (m_flags & cObjectTaskFlagDeleteAfterExecution)
            lzham_delete(m_malloc_context, this);
      }

   protected:
      lzham_malloc_context m_malloc_context;
      T* m_pObject;

      object_method_ptr m_pMethod;

      uint m_flags;
   };

   template<typename S, typename T>
   inline bool task_pool::queue_object_task(S* pObject, T pObject_method, uint64 data, void* pData_ptr)
   {
      object_task<S> *pTask = lzham_new< object_task<S> >(m_malloc_context, m_malloc_context, pObject, pObject_method, cObjectTaskFlagDeleteAfterExecution);
      if (!pTask)
         return false;
      return queue_task(pTask, data, pData_ptr);
   }

   template<typename S, typename T>
   inline bool task_pool::queue_multiple_object_tasks(S* pObject, T pObject_method, uint64 first_data, uint num_tasks, void* pData_ptr)
   {
      LZHAM_ASSERT(m_num_threads);
      LZHAM_ASSERT(pObject);
      LZHAM_ASSERT(num_tasks);
      if (!num_tasks)
         return true;

      bool status = true;

      uint total_to_release = 0;

      for (int i = num_tasks - 1; i >= 0; --i)
      {
         task tsk;

         tsk.m_pObj = lzham_new< object_task<S> >(m_malloc_context, m_malloc_context, pObject, pObject_method, cObjectTaskFlagDeleteAfterExecution);
         if (!tsk.m_pObj)
         {
            status = false;
            break;
         }

         tsk.m_data = first_data + i;
         tsk.m_pData_ptr = pData_ptr;
         tsk.m_flags = cTaskFlagObject;

         if (!m_task_stack.try_push(tsk))
         {
            status = false;
            break;
         }

         total_to_release++;
      }

      if (total_to_release)
      {
         atomic_add32(&m_num_outstanding_tasks, total_to_release);

         m_tasks_available.release(total_to_release);
      }

      return status;
   }

   inline void lzham_sleep(unsigned int milliseconds)
   {
      Sleep(milliseconds);
   }

   uint lzham_get_max_helper_threads();

} // namespace lzham

#endif // LZHAM_USE_WIN32_API
﻿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{8DA0CD46-791D-48D7-AE92-728338501500}</ProjectGuid>
    <RootNamespace>lzhamcomp</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)lib\x86D\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)lib\x64D\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)lib\x86\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)lib\x64\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_x86D</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_x64D</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\include;..\lzhamdecomp;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x86D.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\include;..\lzhamdecomp;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x64D.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>Full</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <AdditionalIncludeDirectories>..\include;..\lzhamdecomp;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x86.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Full</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <AdditionalIncludeDirectories>..\include;..\lzhamdecomp;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <FloatingPointModel>Fast</FloatingPointModel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x64.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="lzham_lzbase.cpp" />
    <ClCompile Include="lzham_lzcomp.cpp" />
    <ClCompile Include="lzham_lzcomp_internal.cpp" />
    <ClCompile Include="lzham_lzcomp_state.cpp" />
    <ClCompile Include="lzham_match_accel.cpp" />
    <ClCompile Include="lzham_win32_threading.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lzham_comp.h" />
    <ClInclude Include="lzham_lzbase.h" />
    <ClInclude Include="lzham_lzcomp_internal.h" />
    <ClInclude Include="lzham_match_accel.h" />
    <ClInclude Include="lzham_null_threading.h" />
    <ClInclude Include="lzham_pthreads_threading.h" />
    <ClInclude Include="lzham_threading.h" />
    <ClInclude Include="lzham_win32_threading.h" />
    <ClInclude Include="..\include\lzham.h" />
    <ClInclude Include="..\include\lzham_dynamic_lib.h" />
    <ClInclude Include="..\include\lzham_static_lib.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\include\lzham_exports.inc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>PROJECT(lzhamdecomp)
cmake_minimum_required(VERSION 2.8)
option(BUILD_X64 "build 64-bit" TRUE)

message("Initial BUILD_X64=${BUILD_X64}")
message("Initial CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}")

if( NOT CMAKE_BUILD_TYPE )
  set( CMAKE_BUILD_TYPE Release )
endif( NOT CMAKE_BUILD_TYPE )

message( ${PROJECT_NAME} " build type: " ${CMAKE_BUILD_TYPE} )

if (BUILD_X64)
	message("Building 64-bit")
else()
	message("Building 32-bit")
endif(BUILD_X64)

set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -Wall -Wextra")
set(CMAKE_C_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -Wall -Wextra")

set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -Wall -Wextra -O3 -fomit-frame-pointer -fexpensive-optimizations")
set(CMAKE_C_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -Wall -Wextra")

set(SRC_LIST 
    ../include/lzham_dynamic_lib.h
    ../include/lzham_static_lib.h
    ../include/lzham.h
    ../include/lzham_exports.inc
    ../include/zlib.h
    lzham_assert.cpp       
    lzham_assert.h         
    lzham_checksum.cpp     
    lzham_checksum.h       
    lzham_config.h         
    lzham_core.h           
    lzham_decomp.h
    lzham_helpers.h        
    lzham_huffman_codes.cpp
    lzham_huffman_codes.h  
    lzham_lzdecompbase.cpp 
    lzham_lzdecompbase.h   
    lzham_lzdecomp.cpp     
    lzham_math.h           
    lzham_mem.cpp          
    lzham_mem.h            
    lzham_platform.cpp     
    lzham_platform.h       
    lzham_prefix_coding.cpp
    lzham_prefix_coding.h  
    lzham_symbol_codec.cpp 
    lzham_symbol_codec.h   
    lzham_timer.cpp        
    lzham_timer.h          
    lzham_traits.h         
    lzham_types.h          
    lzham_utils.h          
    lzham_vector.cpp       
    lzham_vector.h)

# -fno-strict-aliasing is *required* to compile LZHAM
set(GCC_COMPILE_FLAGS "-fno-strict-aliasing -D_LARGEFILE64_SOURCE=1 -D_FILE_OFFSET_BITS=64")

if (NOT BUILD_X64)
	set(GCC_COMPILE_FLAGS "${GCC_COMPILE_FLAGS} -m32")
endif()

set(CMAKE_EXE_LINKER_FLAGS  "${CMAKE_EXE_LINKER_FLAGS} ${GCC_LINK_FLAGS}")

set(CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} ${GCC_COMPILE_FLAGS}")
set(CMAKE_C_FLAGS_RELEASE  "${CMAKE_C_FLAGS_RELEASE} ${GCC_COMPILE_FLAGS} -DNDEBUG")
set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} ${GCC_COMPILE_FLAGS} -D_DEBUG")

set(CMAKE_CXX_FLAGS  "${CMAKE_CXX_FLAGS} ${GCC_COMPILE_FLAGS}")
set(CMAKE_CXX_FLAGS_RELEASE  "${CMAKE_CXX_FLAGS_RELEASE} ${GCC_COMPILE_FLAGS} -DNDEBUG")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} ${GCC_COMPILE_FLAGS} -D_DEBUG")

include_directories(
	${PROJECT_SOURCE_DIR}/../lzhamdecomp 
	${PROJECT_SOURCE_DIR}/../include)

#set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin_linux)

add_library(${PROJECT_NAME} ${SRC_LIST})
install(TARGETS ${PROJECT_NAME} LIBRARY DESTINATION lib${LIB_SUFFIX} ARCHIVE DESTINATION lib${LIB_SUFFIX} RUNTIME DESTINATION bin)
// File: lzham_assert.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"

static bool g_fail_exceptions;
static bool g_exit_on_failure = true;

void lzham_enable_fail_exceptions(bool enabled)
{
   g_fail_exceptions = enabled;
}

void lzham_assert(const char* pExp, const char* pFile, unsigned line)
{
   char buf[512];

   sprintf_s(buf, sizeof(buf), "%s(%u): Assertion failed: \"%s\"\n", pFile, line, pExp);

   lzham_output_debug_string(buf);

   printf("%s", buf);

   if (lzham_is_debugger_present())
      lzham_debug_break();
}

void lzham_fail(const char* pExp, const char* pFile, unsigned line)
{
   char buf[512];

   sprintf_s(buf, sizeof(buf), "%s(%u): Failure: \"%s\"\n", pFile, line, pExp);

   lzham_output_debug_string(buf);

   printf("%s", buf);

   if (lzham_is_debugger_present())
      lzham_debug_break();

#if LZHAM_USE_WIN32_API
   if (g_fail_exceptions)
      RaiseException(LZHAM_FAIL_EXCEPTION_CODE, 0, 0, NULL);
   else
#endif
   if (g_exit_on_failure)
      exit(EXIT_FAILURE);
}

void lzham_trace(const char* pFmt, va_list args)
{
   if (lzham_is_debugger_present())
   {
      char buf[512];
      vsprintf_s(buf, sizeof(buf), pFmt, args);

      lzham_output_debug_string(buf);
   }
}

void lzham_trace(const char* pFmt, ...)
{
   va_list args;
   va_start(args, pFmt);
   lzham_trace(pFmt, args);
   va_end(args);
}

#if LZHAM_ERROR_LOGGING
#if LZHAM_VERBOSE_ERROR_LOGGING
void lzham_log_error(const char *pFunc, const char *pFile, int line, const char *pMsg, int idx)
{
   fprintf(stderr, "\nlzham_log_error: %i %s file: %s line: %u func %s\n", idx, pMsg ? pMsg : "", pFile, line, pFunc);
}
#else
void lzham_log_error(int idx)
{
   fprintf(stderr, "\nlzham_log_error: %i\n", idx);
}
#endif
#endif
// File: lzham_assert.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

#if LZHAM_ERROR_LOGGING
   #if LZHAM_VERBOSE_ERROR_LOGGING
      #define LZHAM_LOG_ERROR(idx) do { lzham_log_error(__FUNCTION__, __FILE__, __LINE__, "", idx); } while(0)
   #else
      #define LZHAM_LOG_ERROR(idx) do { lzham_log_error(idx); } while(0)
   #endif
#else
   #define LZHAM_LOG_ERROR(idx)
#endif

#if LZHAM_ERROR_LOGGING
   #if LZHAM_VERBOSE_ERROR_LOGGING
      void lzham_log_error(const char *pFunc, const char *pFile, int line, const char *pMsg, int idx);
   #else
      void lzham_log_error(int idx);
   #endif
#endif

const unsigned int LZHAM_FAIL_EXCEPTION_CODE = 256U;
void lzham_enable_fail_exceptions(bool enabled);

void lzham_assert(const char* pExp, const char* pFile, unsigned line);
void lzham_fail(const char* pExp, const char* pFile, unsigned line);

#ifdef NDEBUG
   #define LZHAM_ASSERT(x) ((void)0)
#else
   #define LZHAM_ASSERT(_exp) (void)( (!!(_exp)) || (lzham_assert(#_exp, __FILE__, __LINE__), 0) )
   #define LZHAM_ASSERTS_ENABLED 1
#endif

#define LZHAM_VERIFY(_exp) (void)( (!!(_exp)) || (lzham_assert(#_exp, __FILE__, __LINE__), 0) )

#define LZHAM_FAIL(msg) do { lzham_fail(#msg, __FILE__, __LINE__); } while(0)

#define LZHAM_ASSERT_OPEN_RANGE(x, l, h) LZHAM_ASSERT((x >= l) && (x < h))
#define LZHAM_ASSERT_CLOSED_RANGE(x, l, h) LZHAM_ASSERT((x >= l) && (x <= h))

void lzham_trace(const char* pFmt, va_list args);
void lzham_trace(const char* pFmt, ...);

// Borrowed from boost libraries.
template <bool x>  struct assume_failure;
template <> struct assume_failure<true> { enum { blah = 1 }; };
template<int x> struct assume_try { };

#define LZHAM_JOINER_FINAL(a, b) a##b
#define LZHAM_JOINER(a, b) LZHAM_JOINER_FINAL(a, b)
#define LZHAM_JOIN(a, b) LZHAM_JOINER(a, b)
#if defined(__GNUC__)
   #define LZHAM_ASSUME(p) typedef assume_try < sizeof(assume_failure< (bool)(p) > ) > LZHAM_JOIN(assume_typedef, __COUNTER__) __attribute__((unused))
#else
   #define LZHAM_ASSUME(p) typedef assume_try < sizeof(assume_failure< (bool)(p) > ) > LZHAM_JOIN(assume_typedef, __COUNTER__)
#endif
// File: lzham_checksum.cpp
#include "lzham_core.h"
#include "lzham_checksum.h"

namespace lzham
{
   // Originally from the public domain stb.h header.
   uint adler32(const void* pBuf, size_t buflen, uint adler32)
   {
      if (!pBuf)
         return cInitAdler32;

      const uint8* buffer = static_cast<const uint8*>(pBuf);
      
      const unsigned long ADLER_MOD = 65521;
      unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
      size_t blocklen;
      unsigned long i;

      blocklen = buflen % 5552;
      while (buflen) 
      {
         for (i=0; i + 7 < blocklen; i += 8) 
         {
            s1 += buffer[0], s2 += s1;
            s1 += buffer[1], s2 += s1;
            s1 += buffer[2], s2 += s1;
            s1 += buffer[3], s2 += s1;
            s1 += buffer[4], s2 += s1;
            s1 += buffer[5], s2 += s1;
            s1 += buffer[6], s2 += s1;
            s1 += buffer[7], s2 += s1;

            buffer += 8;
         }

         for (; i < blocklen; ++i)
            s1 += *buffer++, s2 += s1;

         s1 %= ADLER_MOD, s2 %= ADLER_MOD;
         buflen -= blocklen;
         blocklen = 5552;
      }
      return static_cast<uint>((s2 << 16) + s1);
   }

   // Karl Malbrain's compact CRC-32, with pre and post conditioning. 
   // See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": 
   // http://www.geocities.com/malbrain/
   static const lzham_uint32 s_crc32[16] = 
   { 
      0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
      0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c 
   };
   
   uint crc32(uint crc, const lzham_uint8 *ptr, size_t buf_len)
   {
      if (!ptr) 
         return cInitCRC32;

      crc = ~crc; 
      while (buf_len--) 
      { 
         lzham_uint8 b = *ptr++; 
         crc = (crc >> 4) ^ s_crc32[(crc & 0xF) ^ (b & 0xF)]; 
         crc = (crc >> 4) ^ s_crc32[(crc & 0xF) ^ (b >> 4)]; 
      }
      return ~crc;
   }

  
} // namespace lzham

// File: lzham_checksum.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

namespace lzham
{
   const uint cInitAdler32 = 1U;
   uint adler32(const void* pBuf, size_t buflen, uint adler32 = cInitAdler32);
   
   const uint cInitCRC32 = 0U;
   uint crc32(uint crc, const lzham_uint8 *ptr, size_t buf_len);
   
}  // namespace lzham
// File: lzham_config.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

#if defined(_DEBUG) || defined(DEBUG)
   #define LZHAM_BUILD_DEBUG
   
   #ifndef DEBUG
      #define DEBUG
   #endif
#else
   #define LZHAM_BUILD_RELEASE
   
   #ifndef NDEBUG
      #define NDEBUG
   #endif
   
   #ifdef DEBUG
      #error DEBUG cannot be defined in LZHAM_BUILD_RELEASE
   #endif
#endif

// HACK HACK
#define LZHAM_BUFFERED_PRINTF 0
#define LZHAM_PERF_SECTIONS 0// File: lzham_core.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

#if defined(_MSC_VER)
   #pragma warning (disable: 4127) // conditional expression is constant
#endif

// If LZHAM_ERROR_LOGGING is 1, LZHAM will write a short internal error codes to stderr when something goes wrong. These codes can be very useful for postmortem debugging.
#ifndef LZHAM_ERROR_LOGGING
    #define LZHAM_ERROR_LOGGING 0
#endif

// If LZHAM_VERBOSE_ERROR_LOGGING, LZHAM will also write the function, file and line # along with the error code to stderr.
#ifndef LZHAM_VERBOSE_ERROR_LOGGING
    #define LZHAM_VERBOSE_ERROR_LOGGING 0
#endif

// Enable this when first porting to new platforms - disables all threading and atomic ops in compressor:
//#define LZHAM_ANSI_CPLUSPLUS 1

#if defined(__FreeBSD__) || defined(__NetBSD__)
   // TODO: I compile and do minimal testing on FreeBSD v10.1 x86, but I haven't enabled threading there yet. (Should be easy because OSX is already supported with threading.)
   #define LZHAM_ANSI_CPLUSPLUS 1
#endif

#if defined(__APPLE__) && defined(__MACH__)
   // Apple OSX and iOS
   #include <TargetConditionals.h>
#endif

#if defined(_XBOX) && !defined(LZHAM_ANSI_CPLUSPLUS)
   // --- X360 - This hasn't been tested since early an alpha.
   #include <xtl.h>
   #define _HAS_EXCEPTIONS 0
   #define NOMINMAX

   #define LZHAM_PLATFORM_X360 1
   #define LZHAM_USE_WIN32_API 1
   #define LZHAM_USE_WIN32_ATOMIC_FUNCTIONS 1
   #define LZHAM_64BIT_POINTERS 0
   #define LZHAM_CPU_HAS_64BIT_REGISTERS 1
   #define LZHAM_BIG_ENDIAN_CPU 1
   #define LZHAM_USE_UNALIGNED_INT_LOADS 1
   #define LZHAM_RESTRICT __restrict
   #define LZHAM_FORCE_INLINE __forceinline
   #define LZHAM_NOTE_UNUSED(x) (void)x

   #define LZHAM_PRIi64 "I64i"
   #define LZHAM_PRIu64 "I64u"

#elif defined(WIN32) && !defined(LZHAM_ANSI_CPLUSPLUS)
   // --- Windows: MSVC or MinGW, x86 or x64, Win32 API's for threading and Win32 Interlocked API's or GCC built-ins for atomic ops.
   #ifdef NDEBUG
      // Ensure checked iterators are disabled.
      #define _SECURE_SCL 0
      #define _HAS_ITERATOR_DEBUGGING 0
   #endif
   #ifndef _DLL
      // If we're using the DLL form of the run-time libs, we're also going to be enabling exceptions because we'll be building CLR apps.
      // Otherwise, we disable exceptions for a small speed boost.
      #define _HAS_EXCEPTIONS 0
   #endif
   #define NOMINMAX

    #ifndef _WIN32_WINNT
      #define _WIN32_WINNT 0x500
   #endif

   #ifndef WIN32_LEAN_AND_MEAN
      #define WIN32_LEAN_AND_MEAN
   #endif

   #include <windows.h>

   #define LZHAM_USE_WIN32_API 1

   #if defined(__MINGW32__) || defined(__MINGW64__)
      #define LZHAM_USE_GCC_ATOMIC_BUILTINS 1
   #else
      #define LZHAM_USE_WIN32_ATOMIC_FUNCTIONS 1
   #endif

   #define LZHAM_PLATFORM_PC 1

   #ifdef _WIN64
      #define LZHAM_PLATFORM_PC_X64 1
      #define LZHAM_64BIT_POINTERS 1
      #define LZHAM_CPU_HAS_64BIT_REGISTERS 1
      #define LZHAM_LITTLE_ENDIAN_CPU 1
   #else
      #define LZHAM_PLATFORM_PC_X86 1
      #define LZHAM_64BIT_POINTERS 0
      #define LZHAM_CPU_HAS_64BIT_REGISTERS 0
      #define LZHAM_LITTLE_ENDIAN_CPU 1
   #endif

   #define LZHAM_USE_UNALIGNED_INT_LOADS 1
   #define LZHAM_RESTRICT __restrict
   #define LZHAM_FORCE_INLINE __forceinline

   #if defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
      #define LZHAM_USE_MSVC_INTRINSICS 1
   #endif

   #define LZHAM_NOTE_UNUSED(x) (void)x

   #define LZHAM_PRIi64 "I64i"
   #define LZHAM_PRIu64 "I64u"

#elif defined(__APPLE__) && !defined(LZHAM_ANSI_CPLUSPLUS)
   // --- Apple: iOS or OSX
   #if (TARGET_IPHONE_SIMULATOR == 1) || (TARGET_OS_IPHONE == 1)
      #define LZHAM_PLATFORM_PC 0

      #if defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__)
         #define LZHAM_PLATFORM_PC_X64 0
         #define LZHAM_64BIT_POINTERS 1
         #define LZHAM_CPU_HAS_64BIT_REGISTERS 1
      #else
         #define LZHAM_PLATFORM_PC_X86 0
         #define LZHAM_64BIT_POINTERS 0
         #define LZHAM_CPU_HAS_64BIT_REGISTERS 0
      #endif

      #define LZHAM_USE_UNALIGNED_INT_LOADS 0

      #if __BIG_ENDIAN__
         #define LZHAM_BIG_ENDIAN_CPU 1
      #else
         #define LZHAM_LITTLE_ENDIAN_CPU 1
      #endif

      #define LZHAM_USE_PTHREADS_API 1
      #define LZHAM_USE_GCC_ATOMIC_BUILTINS 1

      #define LZHAM_RESTRICT

      #if defined(__clang__)
         #define LZHAM_FORCE_INLINE inline
      #else
         #define LZHAM_FORCE_INLINE inline __attribute__((__always_inline__,__gnu_inline__))
      #endif

      #define LZHAM_NOTE_UNUSED(x) (void)x

      #define LZHAM_PRIi64 PRIi64
      #define LZHAM_PRIu64 PRIu64

   #elif (TARGET_OS_MAC == 1)
      #define LZHAM_PLATFORM_PC 1

      #if defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__)
         #define LZHAM_PLATFORM_PC_X64 1
         #define LZHAM_64BIT_POINTERS 1
         #define LZHAM_CPU_HAS_64BIT_REGISTERS 1
      #else
         #define LZHAM_PLATFORM_PC_X86 1
         #define LZHAM_64BIT_POINTERS 0
         #define LZHAM_CPU_HAS_64BIT_REGISTERS 0
      #endif

      #define LZHAM_USE_UNALIGNED_INT_LOADS 1

      #if __BIG_ENDIAN__
         #define LZHAM_BIG_ENDIAN_CPU 1
      #else
         #define LZHAM_LITTLE_ENDIAN_CPU 1
      #endif

      #define LZHAM_USE_PTHREADS_API 1
      #define LZHAM_USE_GCC_ATOMIC_BUILTINS 1

      #define LZHAM_RESTRICT

      #if defined(__clang__)
         #define LZHAM_FORCE_INLINE inline
      #else
         #define LZHAM_FORCE_INLINE inline __attribute__((__always_inline__,__gnu_inline__))
      #endif

      #define LZHAM_NOTE_UNUSED(x) (void)x

      #define LZHAM_PRIi64 PRIi64
      #define LZHAM_PRIu64 PRIu64
   #elif
      #error TODO: Unknown Apple target
   #endif

#elif (defined(__linux__) || defined(__CYGWIN__) ) && (defined(__i386__) || defined(__x86_64__)) && !defined(LZHAM_ANSI_CPLUSPLUS)
   // --- Generic GCC/clang path for x86/x64, clang or GCC, Linux, OSX, FreeBSD or NetBSD, pthreads for threading, GCC built-ins for atomic ops.
   #define LZHAM_PLATFORM_PC 1

   #if defined(_LP64) || defined(__LP64__) || defined(__x86_64__)
      // 64-bit build assumes pointers are always 64-bit
      #define LZHAM_PLATFORM_PC_X64 1
      #define LZHAM_64BIT_POINTERS 1
      #define LZHAM_CPU_HAS_64BIT_REGISTERS 1
   #else
      #define LZHAM_PLATFORM_PC_X86 1
      #define LZHAM_64BIT_POINTERS 0
      #define LZHAM_CPU_HAS_64BIT_REGISTERS 0
   #endif

   #define LZHAM_USE_UNALIGNED_INT_LOADS 1

   #if __BIG_ENDIAN__
      #define LZHAM_BIG_ENDIAN_CPU 1
   #else
      #define LZHAM_LITTLE_ENDIAN_CPU 1
   #endif

   #define LZHAM_USE_PTHREADS_API 1
   #define LZHAM_USE_GCC_ATOMIC_BUILTINS 1

   #define LZHAM_RESTRICT

   #if defined(__clang__)
      #define LZHAM_FORCE_INLINE inline
   #else
      #define LZHAM_FORCE_INLINE inline __attribute__((__always_inline__,__gnu_inline__))
   #endif

   #define LZHAM_NOTE_UNUSED(x) (void)x

   #define LZHAM_PRIi64 PRIi64
   #define LZHAM_PRIu64 PRIu64
#else

#ifndef _MSC_VER
   #warning Building as vanilla ANSI-C/C++, multi-threaded compression is disabled! Please configure lzhamdecomp/lzham_core.h.
#endif

   // --- Vanilla ANSI-C/C++
   // No threading support, unaligned loads are NOT okay, no atomic ops.
   #if defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__)
      #define LZHAM_64BIT_POINTERS 1
      #define LZHAM_CPU_HAS_64BIT_REGISTERS 1
   #else
      #define LZHAM_64BIT_POINTERS 0
      #define LZHAM_CPU_HAS_64BIT_REGISTERS 0
   #endif

   #define LZHAM_USE_UNALIGNED_INT_LOADS 0

   #if __BIG_ENDIAN__
      #define LZHAM_BIG_ENDIAN_CPU 1
   #else
      #define LZHAM_LITTLE_ENDIAN_CPU 1
   #endif

   #define LZHAM_USE_GCC_ATOMIC_BUILTINS 0
   #define LZHAM_USE_WIN32_ATOMIC_FUNCTIONS 0

   #define LZHAM_RESTRICT
   #define LZHAM_FORCE_INLINE inline

   #define LZHAM_NOTE_UNUSED(x) (void)x

   #define LZHAM_PRIi64 PRIi64
   #define LZHAM_PRIu64 PRIu64
#endif

#if LZHAM_LITTLE_ENDIAN_CPU
   const bool c_lzham_little_endian_platform = true;
#else
   const bool c_lzham_little_endian_platform = false;
#endif

const bool c_lzham_big_endian_platform = !c_lzham_little_endian_platform;

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#if !defined(__APPLE__) && !defined(__FreeBSD__)
#include <malloc.h>
#endif
#include <stdarg.h>
#include <memory.h>
#include <limits.h>
#include <algorithm>
#include <errno.h>

#ifndef _MSC_VER
   #ifndef __STDC_FORMAT_MACROS
      #define __STDC_FORMAT_MACROS
   #endif
   // Needed for PRIi64 and PRIu64
   #include <inttypes.h>
#endif

#include "lzham.h"
#include "lzham_config.h"
#include "lzham_types.h"
#include "lzham_assert.h"
#include "lzham_platform.h"

#include "lzham_helpers.h"
#include "lzham_traits.h"
#include "lzham_mem.h"
#include "lzham_math.h"
#include "lzham_utils.h"
#include "lzham_vector.h"
// File: lzham_decomp.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once
#include "lzham.h"

namespace lzham
{
   void LZHAM_CDECL lzham_lib_set_memory_callbacks(lzham_realloc_func pRealloc, lzham_msize_func pMSize, void* pUser_data);
   
   lzham_decompress_state_ptr LZHAM_CDECL lzham_lib_decompress_init(const lzham_decompress_params *pParams);

   lzham_decompress_state_ptr LZHAM_CDECL lzham_lib_decompress_reinit(lzham_decompress_state_ptr pState, const lzham_decompress_params *pParams);

   lzham_uint32 LZHAM_CDECL lzham_lib_decompress_deinit(lzham_decompress_state_ptr pState);

   lzham_decompress_status_t LZHAM_CDECL lzham_lib_decompress(
      lzham_decompress_state_ptr pState,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size, 
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_bool no_more_input_bytes_flag);
      
   lzham_decompress_status_t LZHAM_CDECL lzham_lib_decompress_memory(const lzham_decompress_params *pParams, 
      lzham_uint8* pDst_buf, size_t *pDst_len, 
      const lzham_uint8* pSrc_buf, size_t src_len, lzham_uint32 *pAdler32);

   int LZHAM_CDECL lzham_lib_z_inflateInit2(lzham_z_streamp pStream, int window_bits);
   int LZHAM_CDECL lzham_lib_z_inflateInit(lzham_z_streamp pStream);
   int LZHAM_CDECL lzham_lib_z_inflateReset(lzham_z_streamp pStream);
   int LZHAM_CDECL lzham_lib_z_inflate(lzham_z_streamp pStream, int flush);
   int LZHAM_CDECL lzham_lib_z_inflateEnd(lzham_z_streamp pStream);
   int LZHAM_CDECL lzham_lib_z_uncompress(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len);

   const char * LZHAM_CDECL lzham_lib_z_error(int err);
   lzham_z_ulong lzham_lib_z_adler32(lzham_z_ulong adler, const unsigned char *ptr, size_t buf_len);
   lzham_z_ulong LZHAM_CDECL lzham_lib_z_crc32(lzham_z_ulong crc, const lzham_uint8 *ptr, size_t buf_len);

} // namespace lzham
// File: lzham_helpers.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

#define LZHAM_NO_COPY_OR_ASSIGNMENT_OP(c) c(const c&); c& operator= (const c&);

namespace lzham
{
   namespace helpers
   {
      template<typename T> struct rel_ops
      {
         friend inline bool operator!=(const T& x, const T& y) { return (!(x == y)); }
         friend inline bool operator> (const T& x, const T& y) { return (y < x); }
         friend inline bool operator<=(const T& x, const T& y) { return (!(y < x)); }
         friend inline bool operator>=(const T& x, const T& y) { return (!(x < y)); }
      };

      template <typename T>
      inline T* construct(T* p)
      {
         return new (static_cast<void*>(p)) T;
      }

      template <typename T, typename U>
      inline T* construct(T* p, const U& init)
      {
         return new (static_cast<void*>(p)) T(init);
      }

      template <typename T> 
      inline void construct_array(T* p, uint n);
      
      template <typename T, typename U>
      inline void construct_array(T* p, uint n, const U& init)
      {
         T* q = p + n;
         for ( ; p != q; ++p)
            new (static_cast<void*>(p)) T(init);
      }

      template <typename T>
      inline void destruct(T* p)
      {
         LZHAM_NOTE_UNUSED(p);
         p->~T();
      }

      template <typename T> 
      inline void destruct_array(T* p, uint n);

   }  // namespace helpers

}  // namespace lzham
// File: huffman_codes.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_huffman_codes.h"

namespace lzham
{
   void code_size_histogram::init(uint num_syms, const uint8* pCodesizes)
   {
      const uint8 *p = pCodesizes;

      for (uint i = num_syms >> 2; i; --i)
      {
         uint a = p[0]; 
         uint b = p[1];
         uint c = p[2];
         uint d = p[3];
         m_num_codes[a]++;
         m_num_codes[b]++;
         m_num_codes[c]++;
         m_num_codes[d]++;
         p += 4;
      }

      for (uint i = num_syms & 3; i; --i)
         m_num_codes[*p++]++;

      LZHAM_ASSERT(static_cast<uint>(p - pCodesizes) == num_syms);
   }

   struct sym_freq
   {
      uint m_freq;
      uint16 m_left;
      uint16 m_right;

      inline bool operator< (const sym_freq& other) const
      {
         return m_freq > other.m_freq;
      }
   };
   
   static inline sym_freq* radix_sort_syms(uint num_syms, sym_freq* syms0, sym_freq* syms1)
   {  
      const uint cMaxPasses = 2;
      uint hist[256 * cMaxPasses];
            
      memset(hist, 0, sizeof(hist[0]) * 256 * cMaxPasses);

      {
         sym_freq* p = syms0;
         sym_freq* q = syms0 + (num_syms >> 1) * 2;

         for ( ; p != q; p += 2)
         {
            const uint freq0 = p[0].m_freq;
            const uint freq1 = p[1].m_freq;

            hist[        freq0         & 0xFF]++;
            hist[256 + ((freq0 >>  8) & 0xFF)]++;

            hist[        freq1        & 0xFF]++;
            hist[256 + ((freq1 >>  8) & 0xFF)]++;
         }
      
         if (num_syms & 1)
         {
            const uint freq = p->m_freq;

            hist[        freq        & 0xFF]++;
            hist[256 + ((freq >>  8) & 0xFF)]++;
         }
      }
      
      sym_freq* pCur_syms = syms0;
      sym_freq* pNew_syms = syms1;
      
      const uint total_passes = (hist[256] == num_syms) ? 1 : cMaxPasses;

      for (uint pass = 0; pass < total_passes; pass++)
      {
         const uint* pHist = &hist[pass << 8];

         uint offsets[256];

         uint cur_ofs = 0;
         for (uint i = 0; i < 256; i += 2)
         {
            offsets[i] = cur_ofs;
            cur_ofs += pHist[i];

            offsets[i+1] = cur_ofs;
            cur_ofs += pHist[i+1];
         }

         const uint pass_shift = pass << 3;

         sym_freq* p = pCur_syms;
         sym_freq* q = pCur_syms + (num_syms >> 1) * 2;

         for ( ; p != q; p += 2)
         {
            uint c0 = p[0].m_freq;
            uint c1 = p[1].m_freq;
            
            if (pass)
            {
               c0 >>= 8;
               c1 >>= 8;
            }
            
            c0 &= 0xFF;
            c1 &= 0xFF;

            if (c0 == c1)
            {
               uint dst_offset0 = offsets[c0];

               offsets[c0] = dst_offset0 + 2;

               pNew_syms[dst_offset0] = p[0];
               pNew_syms[dst_offset0 + 1] = p[1];
            }
            else
            {
               uint dst_offset0 = offsets[c0]++;
               uint dst_offset1 = offsets[c1]++;

               pNew_syms[dst_offset0] = p[0];
               pNew_syms[dst_offset1] = p[1];
            }
         }

         if (num_syms & 1)
         {
            uint c = ((p->m_freq) >> pass_shift) & 0xFF;

            uint dst_offset = offsets[c];
            offsets[c] = dst_offset + 1;

            pNew_syms[dst_offset] = *p;
         }

         sym_freq* t = pCur_syms;
         pCur_syms = pNew_syms;
         pNew_syms = t;
      }            

#if LZHAM_ASSERTS_ENABLED
      uint prev_freq = 0;
      for (uint i = 0; i < num_syms; i++)
      {
         LZHAM_ASSERT(!(pCur_syms[i].m_freq < prev_freq));
         prev_freq = pCur_syms[i].m_freq;
      }
#endif
      
      return pCur_syms;
   }
   
   struct huffman_work_tables
   {
      enum { cMaxInternalNodes = cHuffmanMaxSupportedSyms };
      
      sym_freq syms0[cHuffmanMaxSupportedSyms + 1 + cMaxInternalNodes];
      sym_freq syms1[cHuffmanMaxSupportedSyms + 1 + cMaxInternalNodes];

#if !USE_CALCULATE_MINIMUM_REDUNDANCY                  
      uint16 queue[cMaxInternalNodes];
#endif      
   };
   
   uint get_generate_huffman_codes_table_size()
   {
      return sizeof(huffman_work_tables);
   }

   // calculate_minimum_redundancy() written by Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk November 1996.
   static void calculate_minimum_redundancy(int A[], int n) 
	{
		int root;                  /* next root node to be used */
		int leaf;                  /* next leaf to be used */
		int next;                  /* next value to be assigned */
		int avbl;                  /* number of available nodes */
		int used;                  /* number of internal nodes */
		int dpth;                  /* current depth of leaves */

		/* check for pathological cases */
		if (n==0) { return; }
		if (n==1) { A[0] = 0; return; }

		/* first pass, left to right, setting parent pointers */
		A[0] += A[1]; root = 0; leaf = 2;
		for (next=1; next < n-1; next++) {
			/* select first item for a pairing */
			if (leaf>=n || A[root]<A[leaf]) {
				A[next] = A[root]; A[root++] = next;
			} else
				A[next] = A[leaf++];

			/* add on the second item */
			if (leaf>=n || (root<next && A[root]<A[leaf])) {
				A[next] += A[root]; A[root++] = next;
			} else
				A[next] += A[leaf++];
		}

		/* second pass, right to left, setting internal depths */
		A[n-2] = 0;
		for (next=n-3; next>=0; next--)
			A[next] = A[A[next]]+1;

		/* third pass, right to left, setting leaf depths */
		avbl = 1; used = dpth = 0; root = n-2; next = n-1;
		while (avbl>0) {
			while (root>=0 && A[root]==dpth) {
				used++; root--;
			}
			while (avbl>used) {
				A[next--] = dpth; avbl--;
			}
			avbl = 2*used; dpth++; used = 0;
		}
   }

   bool generate_huffman_codes(void* pContext, uint num_syms, const uint16* pFreq, uint8* pCodesizes, uint& max_code_size, uint& total_freq_ret, code_size_histogram &code_size_hist)
   {
      if ((!num_syms) || (num_syms > cHuffmanMaxSupportedSyms))
         return false;
                  
      huffman_work_tables& state = *static_cast<huffman_work_tables*>(pContext);;
            
      uint max_freq = 0;
      uint total_freq = 0;
      
      uint num_used_syms = 0;
      for (uint i = 0; i < num_syms; i++)
      {
         uint freq = pFreq[i];
         
         if (!freq)
            pCodesizes[i] = 0;
         else
         {
            total_freq += freq;
            max_freq = math::maximum(max_freq, freq);
            
            sym_freq& sf = state.syms0[num_used_syms];
            sf.m_left = (uint16)i;
            sf.m_right = cUINT16_MAX;
            sf.m_freq = freq;
            num_used_syms++;
         }            
      }
      
      total_freq_ret = total_freq;

      if (num_used_syms == 1)
      {
         pCodesizes[state.syms0[0].m_left] = 1;
         return true;
      }

      sym_freq* syms = radix_sort_syms(num_used_syms, state.syms0, state.syms1);
      
      int x[cHuffmanMaxSupportedSyms];
      for (uint i = 0; i < num_used_syms; i++)
         x[i] = syms[i].m_freq;
      
      calculate_minimum_redundancy(x, num_used_syms);
      
      uint max_len = 0;
      for (uint i = 0; i < num_used_syms; i++)
      {
         uint len = x[i];
         max_len = math::maximum(len, max_len);
         code_size_hist.m_num_codes[LZHAM_MIN(len, (uint)code_size_histogram::cMaxUnlimitedHuffCodeSize)]++;
         pCodesizes[syms[i].m_left] = static_cast<uint8>(len);
      }
      max_code_size = max_len;
                  
      return true;
   }

} // namespace lzham

// File: lzham_huffman_codes.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

namespace lzham
{
   //const uint cHuffmanMaxSupportedSyms = 600;
   const uint cHuffmanMaxSupportedSyms = 1024;

   const uint cMaxExpectedHuffCodeSize = 16;

   struct code_size_histogram
   {
      enum { cMaxUnlimitedHuffCodeSize = 32 };
      uint m_num_codes[cMaxUnlimitedHuffCodeSize + 1];

      void clear() { utils::zero_object(m_num_codes); }

      void init(uint num_syms, const uint8* pCodesizes);

      inline void init(uint code_size0, uint total_syms0, uint code_size1, uint total_syms1)
      {
         m_num_codes[code_size0] += total_syms0;
         m_num_codes[code_size1] += total_syms1;
      }
   };
   
   uint get_generate_huffman_codes_table_size();
   
   bool generate_huffman_codes(void* pContext, uint num_syms, const uint16* pFreq, uint8* pCodesizes, uint& max_code_size, uint& total_freq_ret, code_size_histogram &code_size_hist);

} // namespace lzham
// File: lzham_lzdecomp.cpp
// See Copyright Notice and license at the end of include/lzham.h
//
// See "Coroutines in C":
// http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
// Also see "Protothreads - Lightweight, Stackless Threads in C":
// http://www.sics.se/~adam/pt/
#include "lzham_core.h"
#include "lzham_decomp.h"
#include "lzham_symbol_codec.h"
#include "lzham_checksum.h"
#include "lzham_lzdecompbase.h"

using namespace lzham;

// We currently only really need ~35K, adding a few K as a fudge factor.
#define LZHAM_DECOMP_MEMORY_ARENA_SIZE (38*1024)

namespace lzham
{
   static const uint8 s_literal_next_state[24] =
   {
      0, 0, 0, 0, 1, 2, 3, // 0-6: literal states
      4, 5, 6, 4, 5,       // 7-11: match states
      7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10   // 12-23: unused
   };
   
   static const uint s_huge_match_base_len[4] = { CLZDecompBase::cMaxMatchLen + 1, CLZDecompBase::cMaxMatchLen + 1 + 256, CLZDecompBase::cMaxMatchLen + 1 + 256 + 1024, CLZDecompBase::cMaxMatchLen + 1 + 256 + 1024 + 4096 };
   static const uint8 s_huge_match_code_len[4] = { 8, 10, 12, 16 };

   struct lzham_decompressor
   {
      lzham_decompressor(lzham_malloc_context malloc_context) : 
         m_malloc_context(malloc_context),
         m_codec(malloc_context),
         m_lit_table(malloc_context),
         m_delta_lit_table(malloc_context),
         m_main_table(malloc_context),
         m_dist_lsb_table(malloc_context)
      {
         for (uint i = 0; i < 2; i++)
         {
            m_rep_len_table[i].set_malloc_context(malloc_context);
            m_large_len_table[i].set_malloc_context(malloc_context);
         }
      }

      void init();
      
      template<bool unbuffered> lzham_decompress_status_t decompress();
      
      void reset_huff_tables();
      void reset_arith_tables();
      void reset_all_tables();
      void reset_huffman_table_update_rates();

      lzham_malloc_context m_malloc_context;

      int m_state;

      CLZDecompBase m_lzBase;
      symbol_codec m_codec;

      uint32 m_raw_decomp_buf_size;
      uint8 *m_pRaw_decomp_buf;
      uint8 *m_pDecomp_buf;
      uint32 m_decomp_adler32;

      const uint8 *m_pIn_buf;
      size_t *m_pIn_buf_size;
      uint8 *m_pOut_buf;
      size_t *m_pOut_buf_size;
      bool m_no_more_input_bytes_flag;

      uint8 *m_pOrig_out_buf;
      size_t m_orig_out_buf_size;

      lzham_decompress_params m_params;

      lzham_decompress_status_t m_status;
                              
      quasi_adaptive_huffman_data_model m_lit_table;
      quasi_adaptive_huffman_data_model m_delta_lit_table;
      quasi_adaptive_huffman_data_model m_main_table;
      quasi_adaptive_huffman_data_model m_rep_len_table[2];
      quasi_adaptive_huffman_data_model m_large_len_table[2];
      quasi_adaptive_huffman_data_model m_dist_lsb_table;

      adaptive_bit_model m_is_match_model[CLZDecompBase::cNumStates];
      adaptive_bit_model m_is_rep_model[CLZDecompBase::cNumStates];
      adaptive_bit_model m_is_rep0_model[CLZDecompBase::cNumStates];
      adaptive_bit_model m_is_rep0_single_byte_model[CLZDecompBase::cNumStates];
      adaptive_bit_model m_is_rep1_model[CLZDecompBase::cNumStates];
      adaptive_bit_model m_is_rep2_model[CLZDecompBase::cNumStates];
      
      uint m_dst_ofs;
      uint m_dst_highwater_ofs;

      uint m_step;
      uint m_block_step;
      uint m_initial_step;

      uint m_block_index;

      int m_match_hist0;
      int m_match_hist1;
      int m_match_hist2;
      int m_match_hist3;
      uint m_cur_state;

      uint m_start_block_dst_ofs;
            
      uint m_block_type;

      const uint8 *m_pFlush_src;
      size_t m_flush_num_bytes_remaining;
      size_t m_flush_n;

      uint m_seed_bytes_to_ignore_when_flushing;

      uint m_file_src_file_adler32;

      uint m_rep_lit0;
      uint m_match_len;
      uint m_match_slot;
      uint m_extra_bits;
      uint m_num_extra_bits;

      uint m_src_ofs;
      const uint8* m_pCopy_src;
      uint m_num_raw_bytes_remaining;

      uint m_debug_is_match;
      uint m_debug_match_len;
      uint m_debug_match_dist;
      uint m_debug_lit;

      lzham_decompress_status_t m_z_last_status;
      uint m_z_first_call;
      uint m_z_has_flushed;
      uint m_z_cmf;
      uint m_z_flg;
      uint m_z_dict_adler32;

      uint m_tmp;
   };

   // Ordinarily I dislike macros like this, but in this case I think using them makes the decompression function easier to follow.

   // Coroutine helpers.
   #define LZHAM_CR_INITIAL_STATE 0
   #define LZHAM_CR_BEGIN(state) switch( state ) { case LZHAM_CR_INITIAL_STATE:
   #define LZHAM_CR_RETURN(state, result) do { state = __LINE__; return (result); case __LINE__:; } while (0)
   #define LZHAM_CR_FINISH }

   // Helpers to save/restore local variables (hopefully CPU registers) to memory.
   #define LZHAM_RESTORE_STATE LZHAM_RESTORE_LOCAL_STATE \
      match_hist0 = m_match_hist0; match_hist1 = m_match_hist1; match_hist2 = m_match_hist2; match_hist3 = m_match_hist3; \
      cur_state = m_cur_state; dst_ofs = m_dst_ofs;
      
   #define LZHAM_SAVE_STATE LZHAM_SAVE_LOCAL_STATE \
      m_match_hist0 = match_hist0; m_match_hist1 = match_hist1; m_match_hist2 = match_hist2; m_match_hist3 = match_hist3; \
      m_cur_state = cur_state; m_dst_ofs = dst_ofs;
      
   // Helper that coroutine returns to the caller with a request for more input bytes.
   #define LZHAM_DECODE_NEEDS_BYTES \
      LZHAM_SAVE_STATE \
      for ( ; ; ) \
      { \
         *m_pIn_buf_size = static_cast<size_t>(m_codec.decode_get_bytes_consumed()); \
         *m_pOut_buf_size = 0; \
         LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_NEEDS_MORE_INPUT); \
         m_codec.decode_set_input_buffer(m_pIn_buf, *m_pIn_buf_size, m_pIn_buf, m_no_more_input_bytes_flag); \
         if ((m_codec.m_decode_buf_eof) || (m_codec.m_decode_buf_size)) break; \
      } \
      LZHAM_RESTORE_STATE

   #if LZHAM_PLATFORM_X360
      #define LZHAM_BULK_MEMCPY XMemCpy
      #define LZHAM_MEMCPY memcpy
   #else
      #define LZHAM_BULK_MEMCPY memcpy
      #define LZHAM_MEMCPY memcpy
   #endif

   // Flush the output buffer/dictionary by doing a coroutine return to the caller.
   // Buffered mode only.
   #define LZHAM_FLUSH_DICT_TO_OUTPUT_BUFFER(dict_ofs) \
      LZHAM_SAVE_STATE \
      m_pFlush_src = m_pDecomp_buf + m_seed_bytes_to_ignore_when_flushing + m_dst_highwater_ofs; \
      m_flush_num_bytes_remaining = dict_ofs - m_seed_bytes_to_ignore_when_flushing - m_dst_highwater_ofs; \
      m_seed_bytes_to_ignore_when_flushing = 0; \
      m_dst_highwater_ofs = dict_ofs & dict_size_mask; \
      while (m_flush_num_bytes_remaining) \
      { \
         m_flush_n = LZHAM_MIN(m_flush_num_bytes_remaining, *m_pOut_buf_size); \
         if (0 == (m_params.m_decompress_flags & LZHAM_DECOMP_FLAG_COMPUTE_ADLER32)) \
         { \
            LZHAM_BULK_MEMCPY(m_pOut_buf, m_pFlush_src, m_flush_n); \
         } \
         else \
         { \
            size_t copy_ofs = 0; \
            while (copy_ofs < m_flush_n) \
            { \
               const uint cBytesToMemCpyPerIteration = 8192U; \
               size_t bytes_to_copy = LZHAM_MIN((size_t)(m_flush_n - copy_ofs), cBytesToMemCpyPerIteration); \
               LZHAM_MEMCPY(m_pOut_buf + copy_ofs, m_pFlush_src + copy_ofs, bytes_to_copy); \
               m_decomp_adler32 = adler32(m_pFlush_src + copy_ofs, bytes_to_copy, m_decomp_adler32); \
               copy_ofs += bytes_to_copy; \
            } \
         } \
         *m_pIn_buf_size = static_cast<size_t>(m_codec.decode_get_bytes_consumed()); \
         *m_pOut_buf_size = m_flush_n; \
         LZHAM_CR_RETURN(m_state, m_flush_n ? LZHAM_DECOMP_STATUS_NOT_FINISHED : LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT); \
         m_codec.decode_set_input_buffer(m_pIn_buf, *m_pIn_buf_size, m_pIn_buf, m_no_more_input_bytes_flag); \
         m_pFlush_src += m_flush_n; \
         m_flush_num_bytes_remaining -= m_flush_n; \
      } \
      LZHAM_RESTORE_STATE

   #define LZHAM_DECOMPRESS_DECODE_ADAPTIVE_SYMBOL(codec, result, model) LZHAM_SYMBOL_CODEC_DECODE_ADAPTIVE_HUFFMAN(codec, result, model)
   
   //------------------------------------------------------------------------------------------------------------------
   void lzham_decompressor::init()
   {
      m_lzBase.init_position_slots(m_params.m_dict_size_log2);

#ifdef LZHAM_LZDEBUG
      if (m_pDecomp_buf)
         memset(m_pDecomp_buf, 0xCE, 1U << m_params.m_dict_size_log2);
#endif

      m_state = LZHAM_CR_INITIAL_STATE;
      m_step = 0;
      m_block_step = 0;
      m_block_index = 0;
      m_initial_step = 0;
            
      m_dst_ofs = 0;
      m_dst_highwater_ofs = 0;

      m_pIn_buf = NULL;
      m_pIn_buf_size = NULL;
      m_pOut_buf = NULL;
      m_pOut_buf_size = NULL;
      m_no_more_input_bytes_flag = false;
      m_status = LZHAM_DECOMP_STATUS_NOT_FINISHED;
      m_pOrig_out_buf = NULL;
      m_orig_out_buf_size = 0;
      m_decomp_adler32 = cInitAdler32;
      m_seed_bytes_to_ignore_when_flushing = 0;
      
      m_z_last_status = LZHAM_DECOMP_STATUS_NOT_FINISHED;
      m_z_first_call = 1;
      m_z_has_flushed = 0;
      m_z_cmf = 0;
      m_z_flg = 0;
      m_z_dict_adler32 = 0;

      m_tmp = 0;

      m_match_hist0 = 0;
      m_match_hist1 = 0;
      m_match_hist2 = 0;
      m_match_hist3 = 0;
      m_cur_state = 0;
      
      m_start_block_dst_ofs = 0;
      m_block_type = 0;
      m_flush_num_bytes_remaining = 0;
      m_flush_n = 0;
      m_file_src_file_adler32 = 0;
      m_rep_lit0 = 0;
      m_match_len = 0;
      m_match_slot = 0;
      m_extra_bits = 0;
      m_num_extra_bits = 0;
      m_src_ofs = 0;
      m_pCopy_src = NULL;
      m_num_raw_bytes_remaining = 0;
      
      m_codec.clear();
   }

   void lzham_decompressor::reset_huff_tables()
   {
      m_lit_table.reset();
     m_delta_lit_table.reset();
      
      m_main_table.reset();

      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_rep_len_table); i++)
         m_rep_len_table[i].reset();

      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_large_len_table); i++)
         m_large_len_table[i].reset();

      m_dist_lsb_table.reset();
   }

   void lzham_decompressor::reset_arith_tables()
   {
      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_is_match_model); i++)
         m_is_match_model[i].clear();

      for (uint i = 0; i < CLZDecompBase::cNumStates; i++)
      {
         m_is_rep_model[i].clear();
         m_is_rep0_model[i].clear();
         m_is_rep0_single_byte_model[i].clear();
         m_is_rep1_model[i].clear();
         m_is_rep2_model[i].clear();
      }
   }

   void lzham_decompressor::reset_all_tables()
   {
      reset_huff_tables();

      reset_arith_tables();
   }

   void lzham_decompressor::reset_huffman_table_update_rates()
   {
      m_lit_table.reset_update_rate();
      m_delta_lit_table.reset_update_rate();

      m_main_table.reset_update_rate();

      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_rep_len_table); i++)
         m_rep_len_table[i].reset_update_rate();

      for (uint i = 0; i < LZHAM_ARRAY_SIZE(m_large_len_table); i++)
         m_large_len_table[i].reset_update_rate();

      m_dist_lsb_table.reset_update_rate();
   }
      
   //------------------------------------------------------------------------------------------------------------------
   // Decompression method. Implemented as a coroutine so it can be paused and resumed to support streaming.
   //------------------------------------------------------------------------------------------------------------------
   template<bool unbuffered>
   lzham_decompress_status_t lzham_decompressor::decompress()
   {
      // Important: This function is a coroutine. ANY locals variables that need to be preserved across coroutine
      // returns must be either be a member variable, or a local which is saved/restored to a member variable at
      // the right times. (This makes this function difficult to follow and freaking ugly due to the macros of doom - but hey it works.)
      // The most often used variables are in locals so the compiler hopefully puts them into CPU registers.
      symbol_codec &codec = m_codec;
      const uint dict_size = 1U << m_params.m_dict_size_log2;
      const uint dict_size_mask = unbuffered ? UINT_MAX : (dict_size - 1);

      int match_hist0 = 0, match_hist1 = 0, match_hist2 = 0, match_hist3 = 0;
      uint cur_state = 0, dst_ofs = 0;
      
      const size_t out_buf_size = *m_pOut_buf_size;
      
      uint8* pDst = unbuffered ? reinterpret_cast<uint8*>(m_pOut_buf) : reinterpret_cast<uint8*>(m_pDecomp_buf);
      uint8* pDst_end = unbuffered ?  (reinterpret_cast<uint8*>(m_pOut_buf) + out_buf_size) : (reinterpret_cast<uint8*>(m_pDecomp_buf) + dict_size);      
      
      LZHAM_SYMBOL_CODEC_DECODE_DECLARE(codec);

#define LZHAM_SAVE_LOCAL_STATE
#define LZHAM_RESTORE_LOCAL_STATE

      // Important: Do not use any switch() statements below here.
      LZHAM_CR_BEGIN(m_state)

      if ((!unbuffered) && (m_params.m_num_seed_bytes))
      {
         LZHAM_BULK_MEMCPY(pDst, m_params.m_pSeed_bytes, m_params.m_num_seed_bytes);
         dst_ofs += m_params.m_num_seed_bytes;
         if (dst_ofs >= dict_size)
            dst_ofs = 0;
         else
            m_seed_bytes_to_ignore_when_flushing = dst_ofs;
      }
      
      if (!m_codec.start_decoding(m_pIn_buf, *m_pIn_buf_size, m_no_more_input_bytes_flag, NULL, NULL))
      {
         LZHAM_LOG_ERROR(1020);
         return LZHAM_DECOMP_STATUS_FAILED_INITIALIZING;
      }

      LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec);

      {
         if (m_params.m_decompress_flags & LZHAM_DECOMP_FLAG_READ_ZLIB_STREAM)
         {
            uint check;
            LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, m_z_cmf, 8);
            LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, m_z_flg, 8);
            check = ((m_z_cmf << 8) + m_z_flg) % 31;
            if ((check != 0) || ((m_z_cmf & 15) != LZHAM_Z_LZHAM))
            {
               LZHAM_LOG_ERROR(1021);
               return LZHAM_DECOMP_STATUS_FAILED_BAD_ZLIB_HEADER;
            }
            if (m_z_flg & 32)
            {
               if ((!m_params.m_pSeed_bytes) || (unbuffered))
               {
                  LZHAM_LOG_ERROR(1022);
                  return LZHAM_DECOMP_STATUS_FAILED_NEED_SEED_BYTES;
               }
               m_z_dict_adler32 = 0;
               for (m_tmp = 0; m_tmp < 4; ++m_tmp)
               {
                  uint n; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, n, 8);
                  m_z_dict_adler32 = (m_z_dict_adler32 << 8) | n;
               }
               if (adler32(m_params.m_pSeed_bytes, m_params.m_num_seed_bytes) != m_z_dict_adler32)
               {
                  LZHAM_LOG_ERROR(1023);
                  return LZHAM_DECOMP_STATUS_FAILED_BAD_SEED_BYTES;
               }
            }
         }

         {
            // Was written by lzcompressor::send_configuration().
            //uint tmp;
            //LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, tmp, 2);
         }

         uint max_update_interval = m_params.m_table_max_update_interval, update_interval_slow_rate =  m_params.m_table_update_interval_slow_rate;
         if (!max_update_interval && !update_interval_slow_rate)
         {
            uint rate = m_params.m_table_update_rate;
            if (!rate)
               rate = LZHAM_DEFAULT_TABLE_UPDATE_RATE;
            rate = math::clamp<uint>(rate, 1, LZHAM_FASTEST_TABLE_UPDATE_RATE) - 1;
            max_update_interval = g_table_update_settings[rate].m_max_update_interval;
            update_interval_slow_rate = g_table_update_settings[rate].m_slow_rate;
         }

         bool succeeded = m_lit_table.init2(m_malloc_context, false, 256, max_update_interval, update_interval_slow_rate, NULL);
         succeeded = succeeded && m_delta_lit_table.assign(m_lit_table);
         
         succeeded = succeeded && m_main_table.init2(m_malloc_context, false, CLZDecompBase::cLZXNumSpecialLengths + (m_lzBase.m_num_lzx_slots - CLZDecompBase::cLZXLowestUsableMatchSlot) * 8, max_update_interval, update_interval_slow_rate, NULL);

         succeeded = succeeded && m_rep_len_table[0].init2(m_malloc_context, false, CLZDecompBase::cNumHugeMatchCodes + (CLZDecompBase::cMaxMatchLen - CLZDecompBase::cMinMatchLen + 1), max_update_interval, update_interval_slow_rate, NULL);
         succeeded = succeeded && m_rep_len_table[1].assign(m_rep_len_table[0]);

         succeeded = succeeded && m_large_len_table[0].init2(m_malloc_context, false, CLZDecompBase::cNumHugeMatchCodes + CLZDecompBase::cLZXNumSecondaryLengths, max_update_interval, update_interval_slow_rate, NULL);
         succeeded = succeeded && m_large_len_table[1].assign(m_large_len_table[0]);

         succeeded = succeeded && m_dist_lsb_table.init2(m_malloc_context, false, 16, max_update_interval, update_interval_slow_rate, NULL);
         if (!succeeded)
         {
            LZHAM_LOG_ERROR(1024);
            return LZHAM_DECOMP_STATUS_FAILED_INITIALIZING;
         }
      }
      
      // Output block loop.
      do
      {
#ifdef LZHAM_LZDEBUG
         uint outer_sync_marker; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, k, 12);
         LZHAM_VERIFY(outer_sync_marker == 166);
#endif
         
         // Decode block type.
         LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, m_block_type, CLZDecompBase::cBlockHeaderBits);

         if (m_block_type == CLZDecompBase::cSyncBlock)
         {
            // Sync block
            // Reset either the symbol table update rates, or all statistics, then force a coroutine return to give the caller a chance to handle the output right now.
            LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, m_tmp, CLZDecompBase::cBlockFlushTypeBits);

            // See lzcompressor::send_sync_block() (TODO: make these an enum)
            if (m_tmp == 1)
               reset_huffman_table_update_rates();
            else if (m_tmp == 2)
               reset_all_tables();

            LZHAM_SYMBOL_CODEC_DECODE_ALIGN_TO_BYTE(codec);

            uint n; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, n, 16);
            if (n != 0)
            {
               LZHAM_SYMBOL_CODEC_DECODE_END(codec);
               *m_pIn_buf_size = static_cast<size_t>(codec.decode_get_bytes_consumed());
               *m_pOut_buf_size = 0;
               for ( ; ; ) { LZHAM_LOG_ERROR(1025); LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_FAILED_BAD_SYNC_BLOCK); }
            }

            LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, n, 16);
            if (n != 0xFFFF)
            {
               LZHAM_SYMBOL_CODEC_DECODE_END(codec);
               *m_pIn_buf_size = static_cast<size_t>(codec.decode_get_bytes_consumed());
               *m_pOut_buf_size = 0;
               for ( ; ; ) { LZHAM_LOG_ERROR(1026); LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_FAILED_BAD_SYNC_BLOCK); }
            }
            
            // See lzcompressor::send_sync_block() (TODO: make these an enum)            
            if ((m_tmp == 2) || (m_tmp == 3))
            {
               // It's a sync or full flush, so immediately give caller whatever output we have. Also gives the caller a chance to reposition the input stream ptr somewhere else before continuing.
               LZHAM_SYMBOL_CODEC_DECODE_END(codec);

               if ((!unbuffered) && (dst_ofs))
               {
                  LZHAM_FLUSH_DICT_TO_OUTPUT_BUFFER(dst_ofs);
               }
               else
               {
                  if (unbuffered)
                  {
                     LZHAM_ASSERT(dst_ofs >= m_dst_highwater_ofs);
                  }
                  else
                  {
                     LZHAM_ASSERT(!m_dst_highwater_ofs);
                  }
                  
                  // unbuffered, or dst_ofs==0
                  *m_pIn_buf_size = static_cast<size_t>(codec.decode_get_bytes_consumed());
                  *m_pOut_buf_size = dst_ofs - m_dst_highwater_ofs;
                  
                  // Partial/sync flushes in unbuffered mode details:
                  // We assume the caller doesn't move the output buffer between calls AND the pointer to the output buffer input parameter won't change between calls (i.e.
                  // it *always* points to the beginning of the decompressed stream). The caller will need to track the current output buffer offset.
                  m_dst_highwater_ofs = dst_ofs;
                  
                  LZHAM_SAVE_STATE
                  LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_NOT_FINISHED);
                  LZHAM_RESTORE_STATE
                  
                  m_codec.decode_set_input_buffer(m_pIn_buf, *m_pIn_buf_size, m_pIn_buf, m_no_more_input_bytes_flag);
               }
               
               LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec);
            }
         }
         else if (m_block_type == CLZDecompBase::cRawBlock)
         {
            // Raw block handling is complex because we ultimately want to (safely) handle as many bytes as possible using a small number of memcpy()'s.
            uint num_raw_bytes_remaining;
            num_raw_bytes_remaining = 0;
            
#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE m_num_raw_bytes_remaining = num_raw_bytes_remaining;
#define LZHAM_RESTORE_LOCAL_STATE num_raw_bytes_remaining = m_num_raw_bytes_remaining;

            // Determine how large this raw block is.
            LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, num_raw_bytes_remaining, 24);
            
            // Get and verify raw block length check bits.
            uint num_raw_bytes_check_bits; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, num_raw_bytes_check_bits, 8);
            uint raw_bytes_remaining0, raw_bytes_remaining1, raw_bytes_remaining2;
            raw_bytes_remaining0 = num_raw_bytes_remaining & 0xFF;
            raw_bytes_remaining1 = (num_raw_bytes_remaining >> 8) & 0xFF;
            raw_bytes_remaining2 = (num_raw_bytes_remaining >> 16) & 0xFF;
            if (num_raw_bytes_check_bits != ((raw_bytes_remaining0 ^ raw_bytes_remaining1) ^ raw_bytes_remaining2))
            {
               LZHAM_SYMBOL_CODEC_DECODE_END(codec);
               *m_pIn_buf_size = static_cast<size_t>(codec.decode_get_bytes_consumed());
               *m_pOut_buf_size = 0;
               for ( ; ; ) { LZHAM_LOG_ERROR(1027); LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_FAILED_BAD_RAW_BLOCK); }
            }
            
            num_raw_bytes_remaining++;
            
            // Discard any partial bytes from the bit buffer (align up to the next byte).
            LZHAM_SYMBOL_CODEC_DECODE_ALIGN_TO_BYTE(codec);
            
            // Flush any full bytes from the bit buffer.
            do
            {
               int b;
               LZHAM_SYMBOL_CODEC_DECODE_REMOVE_BYTE_FROM_BIT_BUF(codec, b);
               if (b < 0)
                  break;

               if ((unbuffered) && (dst_ofs >= out_buf_size))
               {
                  LZHAM_SYMBOL_CODEC_DECODE_END(codec);
                  *m_pIn_buf_size = static_cast<size_t>(codec.decode_get_bytes_consumed());
                  *m_pOut_buf_size = 0;
                  for ( ; ; ) { LZHAM_LOG_ERROR(1028); LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_FAILED_DEST_BUF_TOO_SMALL); }
               }

               pDst[dst_ofs++] = static_cast<uint8>(b);

               if ((!unbuffered) && (dst_ofs > dict_size_mask))
               {
                  LZHAM_SYMBOL_CODEC_DECODE_END(codec);
                  LZHAM_FLUSH_DICT_TO_OUTPUT_BUFFER(dict_size);
                  LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec);
                  dst_ofs = 0;
               }

               num_raw_bytes_remaining--;
            } while (num_raw_bytes_remaining);

            LZHAM_SYMBOL_CODEC_DECODE_END(codec);

            // Now handle the bulk of the raw data with memcpy().
            while (num_raw_bytes_remaining)
            {
               uint64 in_buf_ofs, in_buf_remaining;
               in_buf_ofs = codec.decode_get_bytes_consumed();
               in_buf_remaining = *m_pIn_buf_size - in_buf_ofs;

               while (!in_buf_remaining)
               {
                  // We need more bytes from the caller.
                  *m_pIn_buf_size = static_cast<size_t>(in_buf_ofs);
                  *m_pOut_buf_size = 0;

                  if (m_no_more_input_bytes_flag)
                  {
                     for ( ; ; ) { LZHAM_LOG_ERROR(1029); LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_FAILED_EXPECTED_MORE_RAW_BYTES); }
                  }

                  LZHAM_SAVE_STATE
                  LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_NEEDS_MORE_INPUT);
                  LZHAM_RESTORE_STATE

                  m_codec.decode_set_input_buffer(m_pIn_buf, *m_pIn_buf_size, m_pIn_buf, m_no_more_input_bytes_flag);

                  in_buf_ofs = 0;
                  in_buf_remaining = *m_pIn_buf_size;
               }

               // Determine how many bytes we can safely memcpy() in a single call.
               uint num_bytes_to_copy;
               num_bytes_to_copy = static_cast<uint>(LZHAM_MIN(num_raw_bytes_remaining, in_buf_remaining));
               if (!unbuffered)
                  num_bytes_to_copy = LZHAM_MIN(num_bytes_to_copy, dict_size - dst_ofs);

               if ((unbuffered) && ((dst_ofs + num_bytes_to_copy) > out_buf_size))
               {
                  // Output buffer is not large enough.
                  *m_pIn_buf_size = static_cast<size_t>(in_buf_ofs);
                  *m_pOut_buf_size = 0;
                  for ( ; ; ) { LZHAM_LOG_ERROR(1030); LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_FAILED_DEST_BUF_TOO_SMALL); }
               }

               // Copy the raw bytes.
               LZHAM_BULK_MEMCPY(pDst + dst_ofs, m_pIn_buf + in_buf_ofs, num_bytes_to_copy);

               in_buf_ofs += num_bytes_to_copy;
               num_raw_bytes_remaining -= num_bytes_to_copy;

               codec.decode_set_input_buffer(m_pIn_buf, *m_pIn_buf_size, m_pIn_buf + in_buf_ofs, m_no_more_input_bytes_flag);

               dst_ofs += num_bytes_to_copy;

               if ((!unbuffered) && (dst_ofs > dict_size_mask))
               {
                  LZHAM_ASSERT(dst_ofs == dict_size);

                  LZHAM_FLUSH_DICT_TO_OUTPUT_BUFFER(dict_size);

                  dst_ofs = 0;
               }
            }

            LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec);

#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE
#define LZHAM_RESTORE_LOCAL_STATE
         }
         else if (m_block_type == CLZDecompBase::cCompBlock)
         {
            LZHAM_SYMBOL_CODEC_DECODE_ARITH_START(codec)

            match_hist0 = 1;
            match_hist1 = 1;
            match_hist2 = 1;
            match_hist3 = 1;
            cur_state = 0;
                        
            m_start_block_dst_ofs = dst_ofs;

            {
               uint block_flush_type; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, block_flush_type, CLZDecompBase::cBlockFlushTypeBits);
               if (block_flush_type == 1)
                  reset_huffman_table_update_rates();
               else if (block_flush_type == 2)
                  reset_all_tables();
            }

#ifdef LZHAM_LZDEBUG
            m_initial_step = m_step;
            m_block_step = 0;
            for ( ; ; m_step++, m_block_step++)
#else
            for ( ; ; )
#endif
            {
#ifdef LZHAM_LZDEBUG
               uint sync_marker; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, x, CLZDecompBase::cLZHAMDebugSyncMarkerBits);
               LZHAM_VERIFY(sync_marker == CLZDecompBase::cLZHAMDebugSyncMarkerValue);

               LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, m_debug_is_match, 1);
               LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, m_debug_match_len, 17);

               uint debug_cur_state; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, debug_cur_state, 4);
               LZHAM_VERIFY(cur_state == debug_cur_state);
#endif

               // Read "is match" bit.
               uint match_model_index;
               match_model_index = LZHAM_IS_MATCH_MODEL_INDEX(cur_state);
               LZHAM_ASSERT(match_model_index < LZHAM_ARRAY_SIZE(m_is_match_model));

               uint is_match_bit; LZHAM_SYMBOL_CODEC_DECODE_ARITH_BIT(codec, is_match_bit, m_is_match_model[match_model_index]);

#ifdef LZHAM_LZDEBUG
               LZHAM_VERIFY(is_match_bit == m_debug_is_match);
#endif

               if (LZHAM_BUILTIN_EXPECT(!is_match_bit, 0))
               {
                  // Handle literal.

#ifdef LZHAM_LZDEBUG
                  LZHAM_VERIFY(m_debug_match_len == 1);
#endif

#ifdef LZHAM_LZDEBUG
                  LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, m_debug_lit, 8);
#endif
                  
                  if ((unbuffered) && (LZHAM_BUILTIN_EXPECT(dst_ofs >= out_buf_size, 0)))
                  {
                     LZHAM_SYMBOL_CODEC_DECODE_END(codec);
                     *m_pIn_buf_size = static_cast<size_t>(codec.decode_get_bytes_consumed());
                     *m_pOut_buf_size = 0;
                     for ( ; ; ) { LZHAM_LOG_ERROR(1031); LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_FAILED_DEST_BUF_TOO_SMALL); }
                  }

                  if (LZHAM_BUILTIN_EXPECT(cur_state < CLZDecompBase::cNumLitStates, 1))
                  {
                     // Regular literal
                     uint r; LZHAM_DECOMPRESS_DECODE_ADAPTIVE_SYMBOL(codec, r, m_lit_table);
                     pDst[dst_ofs] = static_cast<uint8>(r);

#ifdef LZHAM_LZDEBUG
                     LZHAM_VERIFY(pDst[dst_ofs] == m_debug_lit);
#endif
                  }
                  else
                  {
                     // Delta literal
                     uint match_hist0_ofs, rep_lit0;

                     // Determine delta literal's partial context.
                     match_hist0_ofs = dst_ofs - match_hist0;
                     rep_lit0 = pDst[match_hist0_ofs & dict_size_mask];
                                          
#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE m_rep_lit0 = rep_lit0;
#define LZHAM_RESTORE_LOCAL_STATE rep_lit0 = m_rep_lit0;

#ifdef LZHAM_LZDEBUG
                     uint debug_rep_lit0; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, debug_rep_lit0, 8);
                     LZHAM_VERIFY(debug_rep_lit0 == rep_lit0);
#endif

                     uint r; LZHAM_DECOMPRESS_DECODE_ADAPTIVE_SYMBOL(codec, r, m_delta_lit_table);
                     r ^= rep_lit0;
                     pDst[dst_ofs] = static_cast<uint8>(r);

#ifdef LZHAM_LZDEBUG
                     LZHAM_VERIFY(pDst[dst_ofs] == m_debug_lit);
#endif

#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE
#define LZHAM_RESTORE_LOCAL_STATE
                  }

                  cur_state = s_literal_next_state[cur_state];

                  dst_ofs++;
                  if ((!unbuffered) && (LZHAM_BUILTIN_EXPECT(dst_ofs > dict_size_mask, 0)))
                  {
                     LZHAM_SYMBOL_CODEC_DECODE_END(codec);
                     LZHAM_FLUSH_DICT_TO_OUTPUT_BUFFER(dict_size);
                     LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec);
                     dst_ofs = 0;
                  }
               }
               else
               {
                  // Handle match.
                  uint match_len;
                  match_len = 1;

#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE m_match_len = match_len;
#define LZHAM_RESTORE_LOCAL_STATE match_len = m_match_len;

                  // Determine if match is a rep_match, and if so what type.
                  uint is_rep; LZHAM_SYMBOL_CODEC_DECODE_ARITH_BIT(codec, is_rep, m_is_rep_model[cur_state]);
                  if (LZHAM_BUILTIN_EXPECT(is_rep, 1))
                  {
                     uint is_rep0; LZHAM_SYMBOL_CODEC_DECODE_ARITH_BIT(codec, is_rep0, m_is_rep0_model[cur_state]);
                     if (LZHAM_BUILTIN_EXPECT(is_rep0, 1))
                     {
                        uint is_rep0_len1; LZHAM_SYMBOL_CODEC_DECODE_ARITH_BIT(codec, is_rep0_len1, m_is_rep0_single_byte_model[cur_state]);
                        if (LZHAM_BUILTIN_EXPECT(is_rep0_len1, 1))
                        {
                           cur_state = (cur_state < CLZDecompBase::cNumLitStates) ? 9 : 11;
                        }
                        else
                        {
                           LZHAM_DECOMPRESS_DECODE_ADAPTIVE_SYMBOL(codec, match_len, m_rep_len_table[cur_state >= CLZDecompBase::cNumLitStates]);
                           match_len += CLZDecompBase::cMinMatchLen;
                           
                           if (match_len == (CLZDecompBase::cMaxMatchLen + 1))
                           {
                              // Decode "huge" match length.
                              match_len = 0;
                              do 
                              {
                                 uint b; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, b, 1); 
                                 if (!b)
                                    break;
                                 match_len++;
                              } while (match_len < 3);
                              uint k; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, k, s_huge_match_code_len[match_len]);
                              match_len = s_huge_match_base_len[match_len] + k;
                           }

                           cur_state = (cur_state < CLZDecompBase::cNumLitStates) ? 8 : 11;
                        }
                     }
                     else
                     {
                        LZHAM_DECOMPRESS_DECODE_ADAPTIVE_SYMBOL(codec, match_len, m_rep_len_table[cur_state >= CLZDecompBase::cNumLitStates]);
                        match_len += CLZDecompBase::cMinMatchLen;
                        
                        if (match_len == (CLZDecompBase::cMaxMatchLen + 1))
                        {
                           // Decode "huge" match length.
                           match_len = 0;
                           do 
                           {
                              uint b; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, b, 1); 
                              if (!b)
                                 break;
                              match_len++;
                           } while (match_len < 3);
                           uint k; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, k, s_huge_match_code_len[match_len]);
                           match_len = s_huge_match_base_len[match_len] + k;
                        }

                        uint is_rep1; LZHAM_SYMBOL_CODEC_DECODE_ARITH_BIT(codec, is_rep1, m_is_rep1_model[cur_state]);
                        if (LZHAM_BUILTIN_EXPECT(is_rep1, 1))
                        {
                           uint temp = match_hist1;
                           match_hist1 = match_hist0;
                           match_hist0 = temp;
                        }
                        else
                        {
                           uint is_rep2; LZHAM_SYMBOL_CODEC_DECODE_ARITH_BIT(codec, is_rep2, m_is_rep2_model[cur_state]);

                           if (LZHAM_BUILTIN_EXPECT(is_rep2, 1))
                           {
                              // rep2
                              uint temp = match_hist2;
                              match_hist2 = match_hist1;
                              match_hist1 = match_hist0;
                              match_hist0 = temp;
                           }
                           else
                           {
                              // rep3
                              uint temp = match_hist3;
                              match_hist3 = match_hist2;
                              match_hist2 = match_hist1;
                              match_hist1 = match_hist0;
                              match_hist0 = temp;
                           }
                        }

                        cur_state = (cur_state < CLZDecompBase::cNumLitStates) ? 8 : 11;
                     }
                  }
                  else
                  {
                     // Handle normal/full match.
                     uint sym; LZHAM_DECOMPRESS_DECODE_ADAPTIVE_SYMBOL(codec, sym, m_main_table);
                     sym -= CLZDecompBase::cLZXNumSpecialLengths;

                     if (LZHAM_BUILTIN_EXPECT(static_cast<int>(sym) < 0, 0))
                     {
                        // Handle special symbols.
                        if (static_cast<int>(sym) == (CLZDecompBase::cLZXSpecialCodeEndOfBlockCode - CLZDecompBase::cLZXNumSpecialLengths))
                           break;
                        else
                        {
                           // Must be cLZXSpecialCodePartialStateReset.
                           match_hist0 = 1;
                           match_hist1 = 1;
                           match_hist2 = 1;
                           match_hist3 = 1;
                           cur_state = 0;
                           continue;
                        }
                     }

                     // Low 3 bits of symbol = match length category, higher bits = distance category.
                     match_len = (sym & 7) + 2;

                     uint match_slot;
                     match_slot = (sym >> 3) + CLZDecompBase::cLZXLowestUsableMatchSlot;

#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE m_match_len = match_len; m_match_slot = match_slot;
#define LZHAM_RESTORE_LOCAL_STATE match_len = m_match_len; match_slot = m_match_slot;

                     if (LZHAM_BUILTIN_EXPECT(match_len == 9, 0))
                     {
                        // Match is >= 9 bytes, decode the actual length.
                        uint e; LZHAM_DECOMPRESS_DECODE_ADAPTIVE_SYMBOL(codec, e, m_large_len_table[cur_state >= CLZDecompBase::cNumLitStates]);
                        match_len += e;
                        
                        if (match_len == (CLZDecompBase::cMaxMatchLen + 1))
                        {
                           // Decode "huge" match length.
                           match_len = 0;
                           do 
                           {
                              uint b; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, b, 1); 
                              if (!b)
                                 break;
                              match_len++;
                           } while (match_len < 3);
                           uint k; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, k, s_huge_match_code_len[match_len]);
                           match_len = s_huge_match_base_len[match_len] + k;
                        }
                     }

                     uint num_extra_bits;
                     num_extra_bits = m_lzBase.m_lzx_position_extra_bits[match_slot];

                     uint extra_bits;

#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE m_match_len = match_len; m_match_slot = match_slot; m_num_extra_bits = num_extra_bits;
#define LZHAM_RESTORE_LOCAL_STATE match_len = m_match_len; match_slot = m_match_slot; num_extra_bits = m_num_extra_bits;

                     if (LZHAM_BUILTIN_EXPECT(num_extra_bits < 3, 0))
                     {
                        LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, extra_bits, num_extra_bits);
                     }
                     else
                     {
                        extra_bits = 0;
                        if (LZHAM_BUILTIN_EXPECT(num_extra_bits > 4, 1))
                        {
                           LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, extra_bits, num_extra_bits - 4);
                           extra_bits <<= 4;
                        }

#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE m_match_len = match_len; m_match_slot = match_slot; m_extra_bits = extra_bits;
#define LZHAM_RESTORE_LOCAL_STATE match_len = m_match_len; match_slot = m_match_slot; extra_bits = m_extra_bits;

                        uint j; LZHAM_DECOMPRESS_DECODE_ADAPTIVE_SYMBOL(codec, j, m_dist_lsb_table);
                        extra_bits += j;
                     }

                     match_hist3 = match_hist2;
                     match_hist2 = match_hist1;
                     match_hist1 = match_hist0;
                     match_hist0 = m_lzBase.m_lzx_position_base[match_slot] + extra_bits;

                     cur_state = (cur_state < CLZDecompBase::cNumLitStates) ? CLZDecompBase::cNumLitStates : CLZDecompBase::cNumLitStates + 3;

#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE m_match_len = match_len;
#define LZHAM_RESTORE_LOCAL_STATE match_len = m_match_len;
                  }

                  // We have the match's length and distance, now do the copy.

#ifdef LZHAM_LZDEBUG
                  LZHAM_VERIFY(match_len == m_debug_match_len);
                  LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, m_debug_match_dist, 25);
                  uint d; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, d, 4);
                  m_debug_match_dist = (m_debug_match_dist << 4) | d;
                  LZHAM_VERIFY((uint)match_hist0 == m_debug_match_dist);
#endif
                  if ( (unbuffered) && LZHAM_BUILTIN_EXPECT((((size_t)match_hist0 > dst_ofs) || ((dst_ofs + match_len) > out_buf_size)), 0) )
                  {
                     LZHAM_LOG_ERROR(1032);
                     LZHAM_SYMBOL_CODEC_DECODE_END(codec);
                     *m_pIn_buf_size = static_cast<size_t>(codec.decode_get_bytes_consumed());
                     *m_pOut_buf_size = 0;
                     for ( ; ; ) { LZHAM_CR_RETURN(m_state, LZHAM_DECOMP_STATUS_FAILED_BAD_CODE); }
                  }

                  uint src_ofs;
                  const uint8* pCopy_src;
                  src_ofs = (dst_ofs - match_hist0) & dict_size_mask;
                  pCopy_src = pDst + src_ofs;
                                    
#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE m_match_len = match_len; m_src_ofs = src_ofs; m_pCopy_src = pCopy_src;
#define LZHAM_RESTORE_LOCAL_STATE match_len = m_match_len; src_ofs = m_src_ofs; pCopy_src = m_pCopy_src;

                  if ( (!unbuffered) && LZHAM_BUILTIN_EXPECT( ((LZHAM_MAX(src_ofs, dst_ofs) + match_len) > dict_size_mask), 0) )
                  {
                     // Match source or destination wraps around the end of the dictionary to the beginning, so handle the copy one byte at a time.
                     do
                     {
                        pDst[dst_ofs++] = *pCopy_src++;

                        if (LZHAM_BUILTIN_EXPECT(pCopy_src == pDst_end, 0))
                           pCopy_src = pDst;

                        if (LZHAM_BUILTIN_EXPECT(dst_ofs > dict_size_mask, 0))
                        {
                           LZHAM_SYMBOL_CODEC_DECODE_END(codec);
                           LZHAM_FLUSH_DICT_TO_OUTPUT_BUFFER(dict_size);
                           LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec);
                           dst_ofs = 0;
                        }

                        match_len--;
                     } while (LZHAM_BUILTIN_EXPECT(match_len > 0, 1));
                  }
                  else
                  {
                     uint8* pCopy_dst = pDst + dst_ofs;
                     if (LZHAM_BUILTIN_EXPECT(match_hist0 == 1, 0))
                     {
                        // Handle byte runs.
                        uint8 c = *pCopy_src;
                        if (LZHAM_BUILTIN_EXPECT(match_len < 8, 1))
                        {
                           for (int i = match_len; i > 0; i--)
                              *pCopy_dst++ = c;
                        }
                        else
                        {
                           memset(pCopy_dst, c, match_len);
                        }
                     }
                     else
                     {
                        // Handle matches of length 2 or higher.
                        if (LZHAM_BUILTIN_EXPECT(((match_len < 8) || ((int)match_len > match_hist0)), 1))
                        {
                           for (int i = match_len; i > 0; i--)
                              *pCopy_dst++ = *pCopy_src++;
                        }
                        else
                        {
                           LZHAM_MEMCPY(pCopy_dst, pCopy_src, match_len);
                        }
                     }
                     dst_ofs += match_len;
                  }
               } // lit or match

#undef LZHAM_SAVE_LOCAL_STATE
#undef LZHAM_RESTORE_LOCAL_STATE
#define LZHAM_SAVE_LOCAL_STATE
#define LZHAM_RESTORE_LOCAL_STATE
            } // for ( ; ; )

#ifdef LZHAM_LZDEBUG
            uint end_sync_marker; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, end_sync_marker, 12);
            LZHAM_VERIFY(end_sync_marker == 366);
#endif
            LZHAM_SYMBOL_CODEC_DECODE_ALIGN_TO_BYTE(codec);
         }
         else if (m_block_type == CLZDecompBase::cEOFBlock)
         {
            // Received EOF.
            m_status = LZHAM_DECOMP_STATUS_SUCCESS;
         }
         else
         {
            LZHAM_LOG_ERROR(1033);
            // This block type is currently undefined.
            m_status = LZHAM_DECOMP_STATUS_FAILED_BAD_CODE;
         }

         m_block_index++;

      } while (m_status == LZHAM_DECOMP_STATUS_NOT_FINISHED);

      if ((!unbuffered) && (dst_ofs))
      {
         LZHAM_SYMBOL_CODEC_DECODE_END(codec);
         LZHAM_FLUSH_DICT_TO_OUTPUT_BUFFER(dst_ofs);
         LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec);
      }

      if (m_status == LZHAM_DECOMP_STATUS_SUCCESS)
      {
         LZHAM_SYMBOL_CODEC_DECODE_ALIGN_TO_BYTE(codec);

         LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, m_file_src_file_adler32, 16);
         uint l; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, l, 16);
         m_file_src_file_adler32 = (m_file_src_file_adler32 << 16) | l;

         if (m_params.m_decompress_flags & LZHAM_DECOMP_FLAG_COMPUTE_ADLER32)
         {
            if (unbuffered)
            {
               m_decomp_adler32 = adler32(pDst, dst_ofs, cInitAdler32);
            }

            if (m_file_src_file_adler32 != m_decomp_adler32)
            {
               LZHAM_LOG_ERROR(1034);
               m_status = LZHAM_DECOMP_STATUS_FAILED_ADLER32;
            }
         }
         else
         {
            m_decomp_adler32 = m_file_src_file_adler32;
         }
      }

      LZHAM_SYMBOL_CODEC_DECODE_END(codec);

      *m_pIn_buf_size = static_cast<size_t>(codec.stop_decoding());
      *m_pOut_buf_size = unbuffered ? (dst_ofs - m_dst_highwater_ofs) : 0;
      m_dst_highwater_ofs = dst_ofs;

      LZHAM_CR_RETURN(m_state, m_status);

      for ( ; ; )
      {
         *m_pIn_buf_size = 0;
         *m_pOut_buf_size = 0;
         LZHAM_CR_RETURN(m_state, m_status);
      }

      LZHAM_CR_FINISH

      return m_status;
   }

   static bool check_params(const lzham_decompress_params *pParams)
   {
      if ((!pParams) || (pParams->m_struct_size != sizeof(lzham_decompress_params)))
      {
         LZHAM_LOG_ERROR(1000);
         return false;
      }

      if ((pParams->m_dict_size_log2 < CLZDecompBase::cMinDictSizeLog2) || (pParams->m_dict_size_log2 > CLZDecompBase::cMaxDictSizeLog2))
      {
         LZHAM_LOG_ERROR(1001);
         return false;
      }

      if (pParams->m_num_seed_bytes)
      {
         if (((pParams->m_decompress_flags & LZHAM_DECOMP_FLAG_OUTPUT_UNBUFFERED) != 0) || (!pParams->m_pSeed_bytes))
         {
            LZHAM_LOG_ERROR(1002);
            return false;
         }
         if (pParams->m_num_seed_bytes > (1U << pParams->m_dict_size_log2))
         {
            LZHAM_LOG_ERROR(1003);
            return false;
         }
      }
      return true;
   }
   
   lzham_decompress_state_ptr LZHAM_CDECL lzham_lib_decompress_init(const lzham_decompress_params *pParams)
   {
      LZHAM_ASSUME(CLZDecompBase::cMinDictSizeLog2 == LZHAM_MIN_DICT_SIZE_LOG2);
      LZHAM_ASSUME(CLZDecompBase::cMaxDictSizeLog2 == LZHAM_MAX_DICT_SIZE_LOG2_X64);

      if (!check_params(pParams))
         return NULL;

      lzham_malloc_context malloc_context = lzham_create_malloc_context(LZHAM_DECOMP_MEMORY_ARENA_SIZE);
      
      lzham_decompressor *pState = lzham_new<lzham_decompressor>(malloc_context, malloc_context);
      if (!pState)
      {
         lzham_destroy_malloc_context(malloc_context);
         return NULL;
      }
      
      pState->m_params = *pParams;

      if (pState->m_params.m_decompress_flags & LZHAM_DECOMP_FLAG_OUTPUT_UNBUFFERED)
      {
         pState->m_pRaw_decomp_buf = NULL;
         pState->m_raw_decomp_buf_size = 0;
         pState->m_pDecomp_buf = NULL;
      }
      else
      {
         uint32 decomp_buf_size = 1U << pState->m_params.m_dict_size_log2;
         pState->m_pRaw_decomp_buf = static_cast<uint8*>(lzham_malloc(malloc_context, decomp_buf_size + 15));
         if (!pState->m_pRaw_decomp_buf)
         {
            lzham_delete(malloc_context, pState);
            lzham_destroy_malloc_context(malloc_context);
            return NULL;
         }
         pState->m_raw_decomp_buf_size = decomp_buf_size;
         pState->m_pDecomp_buf = math::align_up_pointer(pState->m_pRaw_decomp_buf, 16);
      }

      pState->init();
      
      return pState;
   }

   lzham_decompress_state_ptr LZHAM_CDECL lzham_lib_decompress_reinit(lzham_decompress_state_ptr p, const lzham_decompress_params *pParams)
   {
      if (!p)
         return lzham_lib_decompress_init(pParams);
      
      lzham_decompressor *pState = static_cast<lzham_decompressor *>(p);

      if (!check_params(pParams))
         return NULL;
      
      if (pState->m_params.m_decompress_flags & LZHAM_DECOMP_FLAG_OUTPUT_UNBUFFERED)
      {
         lzham_free(pState->m_malloc_context, pState->m_pRaw_decomp_buf);
         pState->m_pRaw_decomp_buf = NULL;
         pState->m_raw_decomp_buf_size = 0;
         pState->m_pDecomp_buf = NULL;
      }
      else
      {
         uint32 new_dict_size = 1U << pState->m_params.m_dict_size_log2;
         if ((!pState->m_pRaw_decomp_buf) || (pState->m_raw_decomp_buf_size < new_dict_size))
         {
            uint8 *pNew_dict = static_cast<uint8*>(lzham_realloc(pState->m_malloc_context, pState->m_pRaw_decomp_buf, new_dict_size + 15));
            if (!pNew_dict)
               return NULL;
            pState->m_pRaw_decomp_buf = pNew_dict;
            pState->m_raw_decomp_buf_size = new_dict_size;
            pState->m_pDecomp_buf = math::align_up_pointer(pState->m_pRaw_decomp_buf, 16);
         }
      }
      
      pState->m_params = *pParams;

      pState->init();

      pState->reset_arith_tables();
      return pState;
   }

   uint32 LZHAM_CDECL lzham_lib_decompress_deinit(lzham_decompress_state_ptr p)
   {
      lzham_decompressor *pState = static_cast<lzham_decompressor *>(p);
      if (!pState)
         return 0;

      uint32 adler32 = pState->m_decomp_adler32;

      lzham_malloc_context malloc_context = pState->m_malloc_context;

      lzham_free(malloc_context, pState->m_pRaw_decomp_buf);
      lzham_delete(malloc_context, pState);
      lzham_destroy_malloc_context(malloc_context);

      return adler32;
   }

   lzham_decompress_status_t LZHAM_CDECL lzham_lib_decompress(
      lzham_decompress_state_ptr p,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size,
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_bool no_more_input_bytes_flag)
   {
      lzham_decompressor *pState = static_cast<lzham_decompressor *>(p);

      if ((!pState) || (!pState->m_params.m_dict_size_log2) || (!pIn_buf_size) || (!pOut_buf_size))
      {
         return LZHAM_DECOMP_STATUS_INVALID_PARAMETER;
      }

      if ((*pIn_buf_size) && (!pIn_buf))
      {
         return LZHAM_DECOMP_STATUS_INVALID_PARAMETER;
      }

      if ((*pOut_buf_size) && (!pOut_buf))
      {
         return LZHAM_DECOMP_STATUS_INVALID_PARAMETER;
      }

      pState->m_pIn_buf = pIn_buf;
      pState->m_pIn_buf_size = pIn_buf_size;
      pState->m_pOut_buf = pOut_buf;
      pState->m_pOut_buf_size = pOut_buf_size;
      pState->m_no_more_input_bytes_flag = (no_more_input_bytes_flag != 0);

      if (pState->m_params.m_decompress_flags & LZHAM_DECOMP_FLAG_OUTPUT_UNBUFFERED)
      {
         if (!pState->m_pOrig_out_buf)
         {
            pState->m_pOrig_out_buf = pOut_buf;
            pState->m_orig_out_buf_size = *pOut_buf_size;
         }
         else
         {
            // In unbuffered mode, the caller is not allowed to move the output buffer and the output pointer MUST always point to the beginning of the output buffer.
            // Also, the output buffer size must indicate the full size of the output buffer. The decompressor will track the current output offset, and during partial/sync
            // flushes it'll report how many bytes it has written since the call. 
            if ((pState->m_pOrig_out_buf != pOut_buf) || (pState->m_orig_out_buf_size != *pOut_buf_size))
            {
               return LZHAM_DECOMP_STATUS_INVALID_PARAMETER;
            }
         }
      }

      lzham_decompress_status_t status;

      if (pState->m_params.m_decompress_flags & LZHAM_DECOMP_FLAG_OUTPUT_UNBUFFERED)
         status = pState->decompress<true>();
      else
         status = pState->decompress<false>();
      
      return status;
   }

   lzham_decompress_status_t LZHAM_CDECL lzham_lib_decompress_memory(const lzham_decompress_params *pParams, lzham_uint8* pDst_buf, size_t *pDst_len, const lzham_uint8* pSrc_buf, size_t src_len, lzham_uint32 *pAdler32)
   {
      if (!pParams)
         return LZHAM_DECOMP_STATUS_INVALID_PARAMETER;

      lzham_decompress_params params(*pParams);
      params.m_decompress_flags |= LZHAM_DECOMP_FLAG_OUTPUT_UNBUFFERED;

      lzham_decompress_state_ptr pState = lzham_lib_decompress_init(&params);
      if (!pState)
         return LZHAM_DECOMP_STATUS_FAILED_INITIALIZING;

      lzham_decompress_status_t status = lzham_lib_decompress(pState, pSrc_buf, &src_len, pDst_buf, pDst_len, true);

      uint32 adler32 = lzham_lib_decompress_deinit(pState);
      if (pAdler32)
         *pAdler32 = adler32;

      return status;
   }

   // ----------------- zlib-style API's

   int LZHAM_CDECL lzham_lib_z_inflateInit(lzham_z_streamp pStream)
   {
      return lzham_lib_z_inflateInit2(pStream, LZHAM_Z_DEFAULT_WINDOW_BITS);
   }

   int LZHAM_CDECL lzham_lib_z_inflateInit2(lzham_z_streamp pStream, int window_bits)
   {
      if (!pStream) 
         return LZHAM_Z_STREAM_ERROR;
      
#ifdef LZHAM_Z_API_FORCE_WINDOW_BITS
      window_bits = LZHAM_Z_API_FORCE_WINDOW_BITS;
#endif      

      int max_window_bits = LZHAM_64BIT_POINTERS ? LZHAM_MAX_DICT_SIZE_LOG2_X64 : LZHAM_MAX_DICT_SIZE_LOG2_X86;
      if (labs(window_bits) > max_window_bits)
         return LZHAM_Z_PARAM_ERROR;

      if (labs(window_bits) < LZHAM_MIN_DICT_SIZE_LOG2)
         window_bits = (window_bits < 0) ? -LZHAM_MIN_DICT_SIZE_LOG2 : LZHAM_MIN_DICT_SIZE_LOG2;
      
      lzham_decompress_params params;
      utils::zero_object(params);
      params.m_struct_size = sizeof(lzham_decompress_params);
      params.m_dict_size_log2 = static_cast<lzham_uint32>(labs(window_bits));
      
      params.m_decompress_flags = LZHAM_DECOMP_FLAG_COMPUTE_ADLER32;
      if (window_bits > 0)
         params.m_decompress_flags |= LZHAM_DECOMP_FLAG_READ_ZLIB_STREAM;
      
      lzham_decompress_state_ptr pState = lzham_lib_decompress_init(&params);
      if (!pState)
         return LZHAM_Z_MEM_ERROR;
      pStream->state = static_cast<lzham_z_internal_state *>(pState);

      pStream->data_type = 0;
      pStream->adler = LZHAM_Z_ADLER32_INIT;
      pStream->msg = NULL;
      pStream->total_in = 0;
      pStream->total_out = 0;
      pStream->reserved = 0;
            
      return LZHAM_Z_OK;
   }
   
   int LZHAM_CDECL lzham_lib_z_inflateReset(lzham_z_streamp pStream)
   {
      if ((!pStream) || (!pStream->state)) 
         return LZHAM_Z_STREAM_ERROR;

      lzham_decompress_state_ptr pState = static_cast<lzham_decompress_state_ptr>(pStream->state);
      lzham_decompressor *pDecomp = static_cast<lzham_decompressor *>(pState);
      
      lzham_decompress_params params(pDecomp->m_params);

      if (!lzham_lib_decompress_reinit(pState, &params))
         return LZHAM_Z_STREAM_ERROR;

      return LZHAM_Z_OK;
   }

   int LZHAM_CDECL lzham_lib_z_inflate(lzham_z_streamp pStream, int flush)
   {
      if ((!pStream) || (!pStream->state)) 
         return LZHAM_Z_STREAM_ERROR;
            
      if ((flush == LZHAM_Z_PARTIAL_FLUSH) || (flush == LZHAM_Z_FULL_FLUSH))
         flush = LZHAM_Z_SYNC_FLUSH;
      if (flush)
      {
         if ((flush != LZHAM_Z_SYNC_FLUSH) && (flush != LZHAM_Z_FINISH)) 
            return LZHAM_Z_STREAM_ERROR;
      }

      size_t orig_avail_in = pStream->avail_in;

      lzham_decompress_state_ptr pState = static_cast<lzham_decompress_state_ptr>(pStream->state);
      lzham_decompressor *pDecomp = static_cast<lzham_decompressor *>(pState);
      if (pDecomp->m_z_last_status >= LZHAM_DECOMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE)
         return LZHAM_Z_DATA_ERROR;

      if (pDecomp->m_z_has_flushed && (flush != LZHAM_Z_FINISH)) 
         return LZHAM_Z_STREAM_ERROR;
      pDecomp->m_z_has_flushed |= (flush == LZHAM_Z_FINISH);

      lzham_decompress_status_t status;
      for ( ; ; )
      {
         size_t in_bytes = pStream->avail_in;
         size_t out_bytes = pStream->avail_out;
         lzham_bool no_more_input_bytes_flag = (flush == LZHAM_Z_FINISH);
         status = lzham_lib_decompress(pState, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, no_more_input_bytes_flag);
         
         pDecomp->m_z_last_status = status;

         pStream->next_in += (uint)in_bytes; 
         pStream->avail_in -= (uint)in_bytes;
         pStream->total_in += (uint)in_bytes; 
         pStream->adler = pDecomp->m_decomp_adler32;

         pStream->next_out += (uint)out_bytes;
         pStream->avail_out -= (uint)out_bytes;
         pStream->total_out += (uint)out_bytes;
                  
         if (status >= LZHAM_DECOMP_STATUS_FIRST_FAILURE_CODE)
         {
            if (status == LZHAM_DECOMP_STATUS_FAILED_NEED_SEED_BYTES)
               return LZHAM_Z_NEED_DICT;
            else 
               return LZHAM_Z_DATA_ERROR; // Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well).
         }
         
         if ((status == LZHAM_DECOMP_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
            return LZHAM_Z_BUF_ERROR; // Signal caller that we can't make forward progress without supplying more input, or by setting flush to LZHAM_Z_FINISH.
         else if (flush == LZHAM_Z_FINISH)
         {
            // Caller has indicated that all remaining input was at next_in, and all remaining output will fit entirely in next_out.
            // (The output buffer at next_out MUST be large to hold the remaining uncompressed data when flush==LZHAM_Z_FINISH).
            if (status == LZHAM_DECOMP_STATUS_SUCCESS)
               return LZHAM_Z_STREAM_END;
            // If status is LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT, there must be at least 1 more byte on the way but the caller to lzham_decompress() supplied an empty output buffer.
            // Something is wrong because the caller's output buffer should be large enough to hold the entire decompressed stream when flush==LZHAM_Z_FINISH.
            else if (status == LZHAM_DECOMP_STATUS_HAS_MORE_OUTPUT)
               return LZHAM_Z_BUF_ERROR;
         }
         else if ((status == LZHAM_DECOMP_STATUS_SUCCESS) || (!pStream->avail_in) || (!pStream->avail_out))
            break;
      }

      return (status == LZHAM_DECOMP_STATUS_SUCCESS) ? LZHAM_Z_STREAM_END : LZHAM_Z_OK;
   }

   int LZHAM_CDECL lzham_lib_z_inflateEnd(lzham_z_streamp pStream)
   {
      if (!pStream)
         return LZHAM_Z_STREAM_ERROR;

      lzham_decompress_state_ptr pState = static_cast<lzham_decompress_state_ptr>(pStream->state);
      if (pState)
      {
         pStream->adler = lzham_lib_decompress_deinit(pState);
         pStream->state = NULL;
      }

      return LZHAM_Z_OK;
   }

   int LZHAM_CDECL lzham_lib_z_uncompress(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len)
   {
      lzham_z_stream stream;
      int status;
      memset(&stream, 0, sizeof(stream));

      // In case lzham_z_ulong is 64-bits (argh I hate longs).
      if ((source_len | *pDest_len) > 0xFFFFFFFFU) 
         return LZHAM_Z_PARAM_ERROR;

      stream.next_in = pSource;
      stream.avail_in = (uint)source_len;
      stream.next_out = pDest;
      stream.avail_out = (uint)*pDest_len;

      status = lzham_lib_z_inflateInit(&stream);
      if (status != LZHAM_Z_OK)
         return status;

      status = lzham_lib_z_inflate(&stream, LZHAM_Z_FINISH);
      if (status != LZHAM_Z_STREAM_END)
      {
         lzham_lib_z_inflateEnd(&stream);
         return ((status == LZHAM_Z_BUF_ERROR) && (!stream.avail_in)) ? LZHAM_Z_DATA_ERROR : status;
      }
      *pDest_len = stream.total_out;

      return lzham_lib_z_inflateEnd(&stream);
   }

   const char * LZHAM_CDECL lzham_lib_z_error(int err)
   {
      static struct 
      { 
         int m_err; 
         const char *m_pDesc; 
      } 
      s_error_descs[] =
      {
         { LZHAM_Z_OK, "" }, 
         { LZHAM_Z_STREAM_END, "stream end" }, 
         { LZHAM_Z_NEED_DICT, "need dictionary" }, 
         { LZHAM_Z_ERRNO, "file error" }, 
         { LZHAM_Z_STREAM_ERROR, "stream error" },
         { LZHAM_Z_DATA_ERROR, "data error" }, 
         { LZHAM_Z_MEM_ERROR, "out of memory" }, 
         { LZHAM_Z_BUF_ERROR, "buf error" }, 
         { LZHAM_Z_VERSION_ERROR, "version error" }, 
         { LZHAM_Z_PARAM_ERROR, "parameter error" }
      };
      for (uint i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i) 
         if (s_error_descs[i].m_err == err) 
            return s_error_descs[i].m_pDesc;
      return NULL;
   }

   lzham_z_ulong lzham_lib_z_adler32(lzham_z_ulong adler, const unsigned char *ptr, size_t buf_len)
   {
      return adler32(ptr, buf_len, static_cast<uint>(adler));
   }

   lzham_z_ulong LZHAM_CDECL lzham_lib_z_crc32(lzham_z_ulong crc, const lzham_uint8 *ptr, size_t buf_len)
   {
      return crc32(static_cast<uint>(crc), ptr, buf_len);
   }

} // namespace lzham
// File: lzham_lzdecompbase.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_lzdecompbase.h"

namespace lzham
{
	// Keep in sync with LZHAM_DEFAULT_ADAPT_RATE, and LZHAM_DEFAULT_TABLE_UPDATE_RATE, etc.
	table_update_settings g_table_update_settings[] =
	{
		{ 4, 32 },   // crazy slow!
		{ 5, 33 },
		{ 6, 34 },
		{ 7, 35 },
		{ 8, 36 },
      
		{ 16, 48 },
		{ 32, 72 },
		{ 64, 64 }, // codec's internal default
		{ 98, 80 },
		{ 128, 96 },
      
		{ 192, 112 },
		{ 256, 128 },
      { 512, 128+16*2 },
      { 1024, 128+16*4 },
      { 2048, 128+16*6 },
      
      { 2048, 128+16*8 },
      { 2048, 128+16*10 },
      { 2048, 128+16*12 },
      { 2048, 128+16*14 },
      { 2048, 128+16*16 }
	};

	uint CLZDecompBase::m_lzx_position_base[CLZDecompBase::cLZXMaxPositionSlots] = 
	{
		0x0, 0x1, 0x2, 0x3, 0x4, 0x6, 0x8, 0xC, 0x10, 0x18, 0x20, 0x30, 0x40, 0x60, 0x80, 0xC0,
		0x100, 0x180, 0x200, 0x300, 0x400, 0x600, 0x800, 0xC00, 0x1000, 0x1800, 0x2000, 0x3000, 0x4000, 0x6000, 0x8000, 0xC000,
		0x10000, 0x18000, 0x20000, 0x30000, 0x40000, 0x60000, 0x80000, 0xC0000, 0x100000, 0x180000, 0x200000, 0x300000, 0x400000, 0x600000, 0x800000, 0xC00000,
		0x1000000, 0x1800000, 0x2000000, 0x3000000, 0x4000000, 0x6000000, 0x8000000, 0xA000000, 0xC000000, 0xE000000, 0x10000000, 0x12000000, 0x14000000, 0x16000000, 0x18000000, 0x1A000000,
		0x1C000000, 0x1E000000, 0x20000000, 0x22000000, 0x24000000, 0x26000000, 0x28000000, 0x2A000000, 0x2C000000, 0x2E000000, 0x30000000, 0x32000000, 0x34000000, 0x36000000, 0x38000000, 0x3A000000,
		0x3C000000, 0x3E000000, 0x40000000, 0x42000000, 0x44000000, 0x46000000, 0x48000000, 0x4A000000, 0x4C000000, 0x4E000000, 0x50000000, 0x52000000, 0x54000000, 0x56000000, 0x58000000, 0x5A000000,
		0x5C000000, 0x5E000000, 0x60000000, 0x62000000, 0x64000000, 0x66000000, 0x68000000, 0x6A000000, 0x6C000000, 0x6E000000, 0x70000000, 0x72000000, 0x74000000, 0x76000000, 0x78000000, 0x7A000000,
		0x7C000000, 0x7E000000, 0x80000000, 0x82000000, 0x84000000, 0x86000000, 0x88000000, 0x8A000000, 0x8C000000, 0x8E000000, 0x90000000, 0x92000000, 0x94000000, 0x96000000, 0x98000000, 0x9A000000,
	};

	uint CLZDecompBase::m_lzx_position_extra_mask[CLZDecompBase::cLZXMaxPositionSlots] =
	{
		0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x3, 0x3, 0x7, 0x7, 0xF, 0xF, 0x1F, 0x1F, 0x3F, 0x3F,
		0x7F, 0x7F, 0xFF, 0xFF, 0x1FF, 0x1FF, 0x3FF, 0x3FF, 0x7FF, 0x7FF, 0xFFF, 0xFFF, 0x1FFF, 0x1FFF, 0x3FFF, 0x3FFF,
		0x7FFF, 0x7FFF, 0xFFFF, 0xFFFF, 0x1FFFF, 0x1FFFF, 0x3FFFF, 0x3FFFF, 0x7FFFF, 0x7FFFF, 0xFFFFF, 0xFFFFF, 0x1FFFFF, 0x1FFFFF, 0x3FFFFF, 0x3FFFFF,
		0x7FFFFF, 0x7FFFFF, 0xFFFFFF, 0xFFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF,
		0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF,
		0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF,
		0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF,
		0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF, 0x1FFFFFF
	};

	uint8 CLZDecompBase::m_lzx_position_extra_bits[CLZDecompBase::cLZXMaxPositionSlots] =
	{
		0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x2, 0x2, 0x3, 0x3, 0x4, 0x4, 0x5, 0x5, 0x6, 0x6,
		0x7, 0x7, 0x8, 0x8, 0x9, 0x9, 0xA, 0xA, 0xB, 0xB, 0xC, 0xC, 0xD, 0xD, 0xE, 0xE,
		0xF, 0xF, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 0x16,
		0x17, 0x17, 0x18, 0x18, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
		0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
		0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
		0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
		0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19
	};

	static const uint8 g_num_lzx_position_slots[] = { 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 58, 66 };

   void CLZDecompBase::init_position_slots(uint dict_size_log2)
   {
		LZHAM_ASSERT(dict_size_log2 >= LZHAM_MIN_DICT_SIZE_LOG2);
		LZHAM_ASSERT(dict_size_log2 <= LZHAM_MAX_DICT_SIZE_LOG2_X64);
		LZHAM_ASSERT((sizeof(g_table_update_settings) / sizeof(g_table_update_settings[0])) == LZHAM_FASTEST_TABLE_UPDATE_RATE);

		//for (dict_size_log2 = LZHAM_MIN_DICT_SIZE_LOG2; dict_size_log2 <= LZHAM_MAX_DICT_SIZE_LOG2_X64; dict_size_log2++) {

      m_dict_size_log2 = dict_size_log2;
      m_dict_size = 1U << dict_size_log2;
      m_num_lzx_slots = g_num_lzx_position_slots[dict_size_log2  - LZHAM_MIN_DICT_SIZE_LOG2];

#if 0
		int i, j;
      for (i = 0, j = 0; i < cLZXMaxPositionSlots; i += 2) 
      {
         m_lzx_position_extra_bits[i] = (uint8)j;
         m_lzx_position_extra_bits[i + 1] = (uint8)j; 

         if ((i != 0) && (j < 25))  
            j++; 
      }

      for (i = 0, j = 0; i < cLZXMaxPositionSlots; i++) 
      {
         m_lzx_position_base[i] = j;
         m_lzx_position_extra_mask[i] = (1 << m_lzx_position_extra_bits[i]) - 1;
         j += (1 << m_lzx_position_extra_bits[i]);
      }

		for (uint i = 0; i < cLZXMaxPositionSlots; i++)
		{
			printf("0x%X, ", m_lzx_position_base[i]);
			if ((i & 15) == 15) printf("\n");
		}
#endif

#if 0
      m_num_lzx_slots = 0;         
      
      const uint largest_dist = m_dict_size - 1;
      for (i = 0; i < cLZXMaxPositionSlots; i++)
      {
         if ( (largest_dist >= m_lzx_position_base[i]) &&
              (largest_dist < (m_lzx_position_base[i] + (1 << m_lzx_position_extra_bits[i])) ) )
         {
            m_num_lzx_slots = i + 1;
            break;
         }              
      }
      
      LZHAM_VERIFY(m_num_lzx_slots);
#endif

		//printf("%u, ", m_num_lzx_slots); }
   }
	  
} //namespace lzham
// File: lzham_lzdecompbase.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

//#define LZHAM_LZDEBUG

#define LZHAM_IS_MATCH_MODEL_INDEX(cur_state) (cur_state)

namespace lzham
{
	struct table_update_settings
	{
		uint16 m_max_update_interval;
		uint16 m_slow_rate;
	};
	extern table_update_settings g_table_update_settings[];

   struct CLZDecompBase
   {
      enum 
      {
         cMinMatchLen = 2U,
         cMaxMatchLen = 257U,
         
         cMaxHugeMatchLen = 65536,
                           
         cMinDictSizeLog2 = 15,
         cMaxDictSizeLog2 = 29,
                  
         cMatchHistSize = 4,
         cMaxLen2MatchDist = 2047
      };
         
      enum 
      {
         cLZXNumSecondaryLengths = 249,
         
         cNumHugeMatchCodes = 1,
         cMaxHugeMatchCodeBits = 16,
                                    
         cLZXNumSpecialLengths = 2,
         
         cLZXLowestUsableMatchSlot = 1,
         cLZXMaxPositionSlots = 128
      };
      
      enum
      {
         cLZXSpecialCodeEndOfBlockCode = 0,
         cLZXSpecialCodePartialStateReset = 1
      };
      
      enum
      {  
         cLZHAMDebugSyncMarkerValue = 666,
         cLZHAMDebugSyncMarkerBits = 12
      };

      enum
      {
         cBlockHeaderBits = 2,
         cBlockCheckBits = 4,
         cBlockFlushTypeBits = 2,
         
         cSyncBlock = 0,
         cCompBlock = 1,
         cRawBlock = 2,
         cEOFBlock = 3
      };
      
      enum
      {
         cNumStates = 12,
         cNumLitStates = 7,
      };
				      
      uint m_dict_size_log2;
      uint m_dict_size;
      
      uint m_num_lzx_slots;

      static uint m_lzx_position_base[cLZXMaxPositionSlots];
      static uint m_lzx_position_extra_mask[cLZXMaxPositionSlots];
      static uint8 m_lzx_position_extra_bits[cLZXMaxPositionSlots];
		            
      void init_position_slots(uint dict_size_log2);
   };
   
} // namespace lzham
// File: lzham_math.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

#if defined(LZHAM_USE_MSVC_INTRINSICS) && !defined(__MINGW32__)
   #include <intrin.h>
   #if defined(_MSC_VER)
      #pragma intrinsic(_BitScanReverse)
   #endif
#endif

namespace lzham
{
   namespace math
   {
      // Yes I know these should probably be pass by ref, not val:
      // http://www.stepanovpapers.com/notes.pdf
      // Just don't use them on non-simple (non built-in) types!
      template<typename T> inline T minimum(T a, T b) { return (a < b) ? a : b; }

      template<typename T> inline T minimum(T a, T b, T c) { return minimum(minimum(a, b), c); }

      template<typename T> inline T maximum(T a, T b) { return (a > b) ? a : b; }

      template<typename T> inline T maximum(T a, T b, T c) { return maximum(maximum(a, b), c); }

      template<typename T> inline T clamp(T value, T low, T high) { return (value < low) ? low : ((value > high) ? high : value); }

      inline bool is_power_of_2(uint32 x) { return x && ((x & (x - 1U)) == 0U); }
      inline bool is_power_of_2(uint64 x) { return x && ((x & (x - 1U)) == 0U); }

      template<typename T> inline T align_up_pointer(T p, uint alignment)
      {
         LZHAM_ASSERT(is_power_of_2(alignment));
         ptr_bits_t q = reinterpret_cast<ptr_bits_t>(p);
         q = (q + alignment - 1) & (~((uint_ptr)alignment - 1));
         return reinterpret_cast<T>(q);
      }

      // From "Hackers Delight"
      // val remains unchanged if it is already a power of 2.
      inline uint32 next_pow2(uint32 val)
      {
         val--;
         val |= val >> 16;
         val |= val >> 8;
         val |= val >> 4;
         val |= val >> 2;
         val |= val >> 1;
         return val + 1;
      }

      // val remains unchanged if it is already a power of 2.
      inline uint64 next_pow2(uint64 val)
      {
         val--;
         val |= val >> 32;
         val |= val >> 16;
         val |= val >> 8;
         val |= val >> 4;
         val |= val >> 2;
         val |= val >> 1;
         return val + 1;
      }

      inline uint floor_log2i(uint v)
      {
         uint l = 0;
         while (v > 1U)
         {
            v >>= 1;
            l++;
         }
         return l;
      }

      inline uint ceil_log2i(uint v)
      {
         uint l = floor_log2i(v);
         if ((l != cIntBits) && (v > (1U << l)))
            l++;
         return l;
      }

      // Returns the total number of bits needed to encode v.
      inline uint total_bits(uint v)
      {
         unsigned long l = 0;
#if defined(__MINGW32__)
         if (v)
         {
            l = 32 -__builtin_clz(v);
         }
#elif defined(LZHAM_USE_MSVC_INTRINSICS)
         if (_BitScanReverse(&l, v))
         {
            l++;
         }
         else
         {
            l = 0;
         }
#else
         while (v > 0U)
         {
            v >>= 1;
            l++;
         }
#endif
         return static_cast<uint>(l);
      }

		inline uint compute_mask_size(uint x)
		{
			uint l = 0;
			while (x)
			{
				x &= (x - 1);
				l++;
			}
			return l;
		}

		inline uint compute_mask_shift(uint x)
		{
			if (!x)
				return 0;

			uint l = 0;
			while ((x & 1) == 0)
			{
				x >>= 1;
				l++;
			}

			return l;
		}

   }

} // namespace lzham

// File: lzham_mem.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"

#ifdef __APPLE__
   #include <malloc/malloc.h>
#elif defined(__FreeBSD__) || defined(__NetBSD__)
   #include <malloc_np.h>
   #if defined(__FreeBSD__)
      #define malloc(size) aligned_alloc((LZHAM_MIN_ALLOC_ALIGNMENT), (size))
   #endif
#else
   #include <malloc.h>
#endif

using namespace lzham;

// Purposely less than 2^15, the min dictionary size.
#define LZHAM_MAX_ARENA_ALLOC_SIZE 32767

#define LZHAM_MEM_STATS 0

#ifndef LZHAM_USE_WIN32_API
   #ifdef _MSC_VER
      // LZHAM currently needs _msize/malloc_size/malloc_usable_size to function, so it can't be 100% ANSI C++.
   #elif defined(__APPLE__)
      #define _msize malloc_size
   #else
      #define _msize malloc_usable_size
   #endif
#endif

namespace lzham
{
   #if LZHAM_64BIT_POINTERS
      const uint64 MAX_POSSIBLE_BLOCK_SIZE = 0x400000000ULL;
   #else
      const uint32 MAX_POSSIBLE_BLOCK_SIZE = 0x7FFF0000U;
   #endif

   class simple_spinlock
   {
      volatile atomic32_t m_lock;

   public:
      simple_spinlock() : m_lock(0) { }

      ~simple_spinlock() { }

      void lock()
      {
         for ( ; ; )
         {
            if (atomic_compare_exchange32(&m_lock, 1, 0) == 0)
               break;
         }

         LZHAM_MEMORY_IMPORT_BARRIER;
      }

      void unlock()
      {
         LZHAM_MEMORY_EXPORT_BARRIER;

         atomic_decrement32(&m_lock);
      }
   };
      
   static void* lzham_default_realloc(void* p, size_t size, size_t* pActual_size, lzham_bool movable, void* pUser_data)
   {
      LZHAM_NOTE_UNUSED(pUser_data);

      void* p_new;

      if (!p)
      {
         p_new = malloc(size);
         LZHAM_ASSERT( (reinterpret_cast<ptr_bits_t>(p_new) & (LZHAM_MIN_ALLOC_ALIGNMENT - 1)) == 0 );

         if (pActual_size)
            *pActual_size = p_new ? _msize(p_new) : 0;
      }
      else if (!size)
      {
         free(p);
         p_new = NULL;

         if (pActual_size)
            *pActual_size = 0;
      }
      else
      {
         void* p_final_block = p;
#ifdef WIN32
         p_new = _expand(p, size);
#else
         p_new = NULL;
#endif

         if (p_new)
         {
            LZHAM_ASSERT( (reinterpret_cast<ptr_bits_t>(p_new) & (LZHAM_MIN_ALLOC_ALIGNMENT - 1)) == 0 );
            p_final_block = p_new;
         }
         else if (movable)
         {
            p_new = realloc(p, size);

            if (p_new)
            {
               LZHAM_ASSERT( (reinterpret_cast<ptr_bits_t>(p_new) & (LZHAM_MIN_ALLOC_ALIGNMENT - 1)) == 0 );
               p_final_block = p_new;
            }
         }

         if (pActual_size)
            *pActual_size = _msize(p_final_block);
      }

      return p_new;
   }

   static size_t lzham_default_msize(void* p, void* pUser_data)
   {
      LZHAM_NOTE_UNUSED(pUser_data);
      return p ? _msize(p) : 0;
   }

   static lzham_realloc_func        g_pRealloc = lzham_default_realloc;
   static lzham_msize_func          g_pMSize   = lzham_default_msize;
   static void*                     g_pUser_data;

   void LZHAM_CDECL lzham_lib_set_memory_callbacks(lzham_realloc_func pRealloc, lzham_msize_func pMSize, void* pUser_data)
   {
      if ((!pRealloc) || (!pMSize))
      {
         g_pRealloc = lzham_default_realloc;
         g_pMSize = lzham_default_msize;
         g_pUser_data = NULL;
      }
      else
      {
         g_pRealloc = pRealloc;
         g_pMSize = pMSize;
         g_pUser_data = pUser_data;
      }
   }

   static inline void lzham_mem_error(lzham_malloc_context context, const char* p_msg)
   {
      LZHAM_NOTE_UNUSED(context);
      lzham_assert(p_msg, __FILE__, __LINE__);
      
      LZHAM_LOG_ERROR(2000);
   }

   struct malloc_context
   {
      enum { cSig = 0x5749ABCD };
      uint m_sig;

      uint m_arena_size;
      
      simple_spinlock m_lock;

      int64 m_total_blocks;
      int64 m_cur_allocated;
      int64 m_max_blocks;
      int64 m_max_allocated;

      uint m_arena_ofs;

      uint8 m_arena[1];

      void init(uint arena_size)
      {
         m_sig = cSig;

         m_arena_size = arena_size;
         m_arena_ofs = 0;
                  
         m_total_blocks = 0;
         m_cur_allocated = 0;
         m_max_blocks = 0;
         m_max_allocated = 0;

         if (arena_size)
         {
            uint alignment_mask = (LZHAM_MIN_ALLOC_ALIGNMENT - 1);
            m_arena_ofs = (LZHAM_MIN_ALLOC_ALIGNMENT - (reinterpret_cast<uint64>(m_arena) & alignment_mask)) & alignment_mask;
         }
      }

      void lock() { m_lock.lock(); }
      void unlock() { m_lock.unlock(); }

      bool ptr_is_in_arena(void *p) const
      {
         if ((p < m_arena) || (p >= (m_arena + m_arena_size)))
            return false;
         return true;
      }

      // Important: only the decompressor uses an arena, and it's only single threaded, so this DOES NOT take the context lock.
      void *arena_alloc(size_t size)
      {
         if ((!m_arena_size) || (size > LZHAM_MAX_ARENA_ALLOC_SIZE))
            return NULL;
         
         uint arena_remaining = m_arena_size - m_arena_ofs;
         
         size_t total_needed = (size + LZHAM_MIN_ALLOC_ALIGNMENT + (LZHAM_MIN_ALLOC_ALIGNMENT - 1)) & ~(LZHAM_MIN_ALLOC_ALIGNMENT - 1);
         if (arena_remaining < total_needed)
            return NULL;

         void *p = m_arena + (m_arena_ofs + LZHAM_MIN_ALLOC_ALIGNMENT);
         static_cast<uint32 *>(p)[-1] = static_cast<uint32>(size);
         
         m_arena_ofs += static_cast<uint>(total_needed);
         
         return p;
      }

      uint arena_msize(const void *p) const
      {
         return static_cast<const uint32 *>(p)[-1];
      }

#if LZHAM_MEM_STATS
      void update_total_allocated(int block_delta, int64 byte_delta)
      {
         lock();

         m_total_blocks += block_delta;
         m_cur_allocated += byte_delta;
         m_max_blocks = math::maximum(m_max_blocks, m_total_blocks);
         m_max_allocated = math::maximum(m_max_allocated, m_cur_allocated);

         unlock();
      }
#endif // LZHAM_MEM_STATS
   };

   lzham_malloc_context lzham_create_malloc_context(uint arena_size)
   {
      malloc_context *p = static_cast<malloc_context *>((*g_pRealloc)(NULL, (sizeof(malloc_context) - 1) + arena_size + LZHAM_MIN_ALLOC_ALIGNMENT, NULL, true, g_pUser_data));
      helpers::construct(p);
      p->init(arena_size);
      return p;
   }

   void lzham_destroy_malloc_context(lzham_malloc_context context)
   {
      LZHAM_ASSERT(context);
      if (context)
      {
         malloc_context *p = static_cast<malloc_context *>(context);
         LZHAM_VERIFY(p->m_sig == malloc_context::cSig);

         lzham_print_mem_stats(p);
                           
         helpers::destruct(p);
         p->m_sig = 0xDEADDEAD;

         (*g_pRealloc)(p, 0, NULL, true, g_pUser_data);
      }
   }
            
   void* lzham_malloc(lzham_malloc_context context, size_t size, size_t* pActual_size)
   {
      LZHAM_VERIFY(context);
      
      size = (size + sizeof(uint32) - 1U) & ~(sizeof(uint32) - 1U);
      if (!size)
         size = sizeof(uint32);

      if (size > MAX_POSSIBLE_BLOCK_SIZE)
      {
         lzham_mem_error(context, "lzham_malloc: size too big");
         return NULL;
      }

      size_t actual_size = size;
      uint8* p_new;

      malloc_context *pContext = static_cast<malloc_context *>(context);

      LZHAM_VERIFY(pContext->m_sig == malloc_context::cSig);

      p_new = static_cast<uint8 *>(pContext->arena_alloc(size));
      if (!p_new)
      {
         p_new = static_cast<uint8*>((*g_pRealloc)(NULL, size, &actual_size, true, g_pUser_data));
      }

      if (pActual_size)
         *pActual_size = actual_size;

      if ((!p_new) || (actual_size < size))
      {
         lzham_mem_error(context, "lzham_malloc: out of memory");
         return NULL;
      }

      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(p_new) & (LZHAM_MIN_ALLOC_ALIGNMENT - 1)) == 0);

#if LZHAM_MEM_STATS
      pContext->update_total_allocated(1, static_cast<int64>(actual_size));
#endif

      return p_new;
   }

   void* lzham_realloc(lzham_malloc_context context, void* p, size_t size, size_t* pActual_size, bool movable)
   {
      LZHAM_VERIFY(context);

      if ((ptr_bits_t)p & (LZHAM_MIN_ALLOC_ALIGNMENT - 1))
      {
         lzham_mem_error(context, "lzham_realloc: bad ptr");
         return NULL;
      }

      if (size > MAX_POSSIBLE_BLOCK_SIZE)
      {
         lzham_mem_error(context, "lzham_malloc: size too big");
         return NULL;
      }

#if LZHAM_MEM_STATS
      size_t cur_size = p ? (*g_pMSize)(p, g_pUser_data) : 0;
#endif

      size_t actual_size = size;
      void *p_new;
      
      malloc_context *pContext = static_cast<malloc_context *>(context);
      
      LZHAM_VERIFY(pContext->m_sig == malloc_context::cSig);

      if (pContext->ptr_is_in_arena(p))
      {
         if (!movable)
            return NULL;
         
         uint prev_size = pContext->arena_msize(p);
         if (size <= prev_size)
         {
            p_new = p;
         }
         else
         {
            p_new = static_cast<uint8 *>(pContext->arena_alloc(size));
            if (!p_new)
            {
               p_new = (*g_pRealloc)(NULL, size, &actual_size, true, g_pUser_data);
            }
          
            memcpy(p_new, p, prev_size);
         }
      }
      else
      {
         p_new = NULL;

         if (!p)
            p_new = static_cast<uint8 *>(pContext->arena_alloc(size));
         
         if (!p_new)
            p_new = (*g_pRealloc)(p, size, &actual_size, movable, g_pUser_data);
      }

      if (pActual_size)
         *pActual_size = actual_size;

      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(p_new) & (LZHAM_MIN_ALLOC_ALIGNMENT - 1)) == 0);

#if LZHAM_MEM_STATS
      int num_new_blocks = 0;
      if (p)
      {
         if (!p_new)
            num_new_blocks = -1;
      }
      else if (p_new)
      {
         num_new_blocks = 1;
      }
      pContext->update_total_allocated(num_new_blocks, static_cast<int64>(actual_size) - static_cast<int64>(cur_size));
#endif

      return p_new;
   }

   void lzham_free(lzham_malloc_context context, void* p)
   {
      if (!p)
         return;
      
      LZHAM_VERIFY(context);

      if (reinterpret_cast<ptr_bits_t>(p) & (LZHAM_MIN_ALLOC_ALIGNMENT - 1))
      {
         lzham_mem_error(context, "lzham_free: bad ptr");
         return;
      }
      
      malloc_context *pContext = static_cast<malloc_context *>(context);
      
      LZHAM_VERIFY(pContext->m_sig == malloc_context::cSig);

#if LZHAM_MEM_STATS
      size_t cur_size = lzham_msize(context, p);
      pContext->update_total_allocated(-1, -static_cast<int64>(cur_size));
#endif
      
      if (!pContext->ptr_is_in_arena(p))
      {
         (*g_pRealloc)(p, 0, NULL, true, g_pUser_data);
      }
   }

   size_t lzham_msize(lzham_malloc_context context, void* p)
   {
      if (!p)
         return 0;

      if (reinterpret_cast<ptr_bits_t>(p) & (LZHAM_MIN_ALLOC_ALIGNMENT - 1))
      {
         lzham_mem_error(context, "lzham_msize: bad ptr");
         return 0;
      }

      malloc_context *pContext = static_cast<malloc_context *>(context);
      LZHAM_VERIFY(pContext->m_sig == malloc_context::cSig);

      if (pContext->ptr_is_in_arena(p))
      {
         return pContext->arena_msize(p);
      }
      else
      {
         return (*g_pMSize)(p, g_pUser_data);
      }
   }
      
   void lzham_print_mem_stats(lzham_malloc_context context)
   {
      LZHAM_VERIFY(context);

#if LZHAM_MEM_STATS
      malloc_context *pContext = static_cast<malloc_context *>(context);
      
      LZHAM_VERIFY(pContext->m_sig == malloc_context::cSig);

      printf("Current blocks: %u, allocated: %" LZHAM_PRIu64 ", max ever allocated: %" LZHAM_PRIi64 "\n", pContext->m_total_blocks, (int64)pContext->m_cur_allocated, (int64)pContext->m_max_allocated);
      printf("Max used arena: %u\n", pContext->m_arena_ofs);
      printf("Max blocks: %" LZHAM_PRIu64 "\n", pContext->m_max_blocks);
#endif
   }

} // namespace lzham

// File: lzham_mem.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

namespace lzham
{
   typedef void *lzham_malloc_context;

   lzham_malloc_context lzham_create_malloc_context(uint arena_size);
   void lzham_destroy_malloc_context(lzham_malloc_context context);
   
   void*    lzham_malloc(lzham_malloc_context context, size_t size, size_t* pActual_size = NULL);
   void*    lzham_realloc(lzham_malloc_context context, void* p, size_t size, size_t* pActual_size = NULL, bool movable = true);
   void     lzham_free(lzham_malloc_context context, void* p);
   size_t   lzham_msize(lzham_malloc_context context, void* p);

   template<typename T>
   inline T* lzham_new(lzham_malloc_context context)
   {
      T* p = static_cast<T*>(lzham_malloc(context, sizeof(T)));
      if (!p) return NULL;
      if (LZHAM_IS_SCALAR_TYPE(T))
         return p;
      return helpers::construct(p);
   }
     
   template<typename T, typename A>
   inline T* lzham_new(lzham_malloc_context context, const A& init0)
   {
      T* p = static_cast<T*>(lzham_malloc(context, sizeof(T)));
      if (!p) return NULL;
      return new (static_cast<void*>(p)) T(init0); 
   }
   
   template<typename T, typename A, typename B>
   inline T* lzham_new(lzham_malloc_context context, const A& init0, const B& init1)
   {
      T* p = static_cast<T*>(lzham_malloc(context, sizeof(T)));
      if (!p) return NULL;
      return new (static_cast<void*>(p)) T(init0, init1); 
   }
   
   template<typename T, typename A, typename B, typename C>
   inline T* lzham_new(lzham_malloc_context context, const A& init0, const B& init1, const C& init2)
   {
      T* p = static_cast<T*>(lzham_malloc(context, sizeof(T)));
      if (!p) return NULL;
      return new (static_cast<void*>(p)) T(init0, init1, init2); 
   }
   
   template<typename T, typename A, typename B, typename C, typename D>
   inline T* lzham_new(lzham_malloc_context context, const A& init0, const B& init1, const C& init2, const D& init3)
   {
      T* p = static_cast<T*>(lzham_malloc(context, sizeof(T)));
      if (!p) return NULL;
      return new (static_cast<void*>(p)) T(init0, init1, init2, init3); 
   }

   template<typename T>
   inline T* lzham_new_array(lzham_malloc_context context, uint32 num)
   {
      if (!num) num = 1;

      uint8* q = static_cast<uint8*>(lzham_malloc(context, LZHAM_MIN_ALLOC_ALIGNMENT + sizeof(T) * num));
      if (!q)
         return NULL;

      T* p = reinterpret_cast<T*>(q + LZHAM_MIN_ALLOC_ALIGNMENT);

      reinterpret_cast<uint32*>(p)[-1] = num;
      reinterpret_cast<uint32*>(p)[-2] = ~num;

      if (!LZHAM_IS_SCALAR_TYPE(T))
      {
         helpers::construct_array(p, num);
      }
      return p;
   }

   template<typename T> 
   inline void lzham_delete(lzham_malloc_context context, T* p)
   {
      if (p) 
      {
         if (!LZHAM_IS_SCALAR_TYPE(T))
         {
            helpers::destruct(p);
         }
         lzham_free(context, p);
      }         
   }

   template<typename T> 
   inline void lzham_delete_array(lzham_malloc_context context, T* p)
   {
      if (p)
      {
         const uint32 num = reinterpret_cast<uint32*>(p)[-1];
         const uint32 num_check = reinterpret_cast<uint32*>(p)[-2];
         LZHAM_ASSERT(num && (num == ~num_check));
         if (num == ~num_check)
         {
            if (!LZHAM_IS_SCALAR_TYPE(T))
            {
               helpers::destruct_array(p, num);
            }

            lzham_free(context, reinterpret_cast<uint8*>(p) - LZHAM_MIN_ALLOC_ALIGNMENT);
         }
      }
   }   
   
   void lzham_print_mem_stats(lzham_malloc_context context);

} // namespace lzham
// File: platform.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_timer.h"
#include <assert.h>

#if LZHAM_PLATFORM_X360
#include <xbdm.h>
#endif

#define LZHAM_FORCE_DEBUGGER_PRESENT 0

#ifndef _MSC_VER
int sprintf_s(char *buffer, size_t sizeOfBuffer, const char *format, ...)
{
   if (!sizeOfBuffer)
      return 0;

   va_list args;
   va_start(args, format);
   int c = vsnprintf(buffer, sizeOfBuffer, format, args);
   va_end(args);

   buffer[sizeOfBuffer - 1] = '\0';

   if (c < 0)
      return static_cast<int>(sizeOfBuffer - 1);

   return LZHAM_MIN(c, (int)sizeOfBuffer - 1);
}
int vsprintf_s(char *buffer, size_t sizeOfBuffer, const char *format, va_list args)
{
   if (!sizeOfBuffer)
      return 0;

   int c = vsnprintf(buffer, sizeOfBuffer, format, args);

   buffer[sizeOfBuffer - 1] = '\0';

   if (c < 0)
      return static_cast<int>(sizeOfBuffer - 1);

   return LZHAM_MIN(c, (int)sizeOfBuffer - 1);
}
#endif // __GNUC__

bool lzham_is_debugger_present(void)
{
#if LZHAM_PLATFORM_X360
   return DmIsDebuggerPresent() != 0;
#elif LZHAM_USE_WIN32_API
   return IsDebuggerPresent() != 0;
#elif LZHAM_FORCE_DEBUGGER_PRESENT
   return true;
#else
   return false;
#endif
}

void lzham_debug_break(void)
{
#if LZHAM_USE_WIN32_API
   DebugBreak();
#elif (TARGET_OS_MAC == 1) && (TARGET_IPHONE_SIMULATOR == 0) && (TARGET_OS_IPHONE == 0)
//   __asm {int 3}
//   __asm("int $3")
   assert(0);   
#else
   assert(0);
#endif
}

void lzham_output_debug_string(const char* p)
{
   LZHAM_NOTE_UNUSED(p);
#if LZHAM_USE_WIN32_API
   OutputDebugStringA(p);
#else
   fputs(p, stderr);
#endif
}

#if LZHAM_BUFFERED_PRINTF
#include <vector>
// This stuff was a quick hack only intended for debugging/development.
namespace lzham
{
   struct buffered_str
   {
      enum { cBufSize = 256 };
      char m_buf[cBufSize];
   };

   static std::vector<buffered_str> g_buffered_strings;
   static volatile long g_buffered_string_locked;
   
   static void lock_buffered_strings()
   {
      while (atomic_exchange32(&g_buffered_string_locked, 1) == 1)
      {
         lzham_yield_processor();
         lzham_yield_processor();
         lzham_yield_processor();
         lzham_yield_processor();
      }

      LZHAM_MEMORY_IMPORT_BARRIER
   }
   
   static void unlock_buffered_strings()
   {
      LZHAM_MEMORY_EXPORT_BARRIER

      atomic_exchange32(&g_buffered_string_locked, 0);
   }

   void lzham_buffered_printf(const char *format, ...)
   {
      format;
   
      char buf[lzham::buffered_str::cBufSize];
   
      va_list args;
      va_start(args, format);
      vsnprintf_s(buf, sizeof(buf), sizeof(buf), format, args);
      va_end(args);   

      buf[sizeof(buf) - 1] = '\0';
   
      lzham::lock_buffered_strings();
   
      if (!lzham::g_buffered_strings.capacity())
      {
         lzham::g_buffered_strings.reserve(2048);
      }

      lzham::g_buffered_strings.resize(lzham::g_buffered_strings.size() + 1);
      memcpy(lzham::g_buffered_strings.back().m_buf, buf, sizeof(buf));

      lzham::unlock_buffered_strings();
   }

   void lzham_flush_buffered_printf()
   {
      lzham::lock_buffered_strings();

      for (lzham::uint i = 0; i < lzham::g_buffered_strings.size(); i++)
      {
         printf("%s", lzham::g_buffered_strings[i].m_buf);
      }

      lzham::g_buffered_strings.resize(0);

      lzham::unlock_buffered_strings();
   }

} // namespace lzham
#endif   

// File: lzham_platform.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

bool lzham_is_debugger_present(void);
void lzham_debug_break(void);
void lzham_output_debug_string(const char* p);

// actually in lzham_assert.cpp
void lzham_assert(const char* pExp, const char* pFile, unsigned line);
void lzham_fail(const char* pExp, const char* pFile, unsigned line);

#ifdef WIN32
   #define LZHAM_BREAKPOINT DebuggerBreak();
   #define LZHAM_BUILTIN_EXPECT(c, v) c
#elif defined(__GNUC__)
   #define LZHAM_BREAKPOINT asm("int $3");
   #define LZHAM_BUILTIN_EXPECT(c, v) __builtin_expect(c, v)
#else
   #define LZHAM_BREAKPOINT
   #define LZHAM_BUILTIN_EXPECT(c, v) c
#endif

#if defined(__GNUC__) && LZHAM_PLATFORM_PC
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void lzham_yield_processor()
{
   __asm__ __volatile__("pause");
}
#elif LZHAM_PLATFORM_X360
#define lzham_yield_processor() \
   YieldProcessor(); \
   __asm { or r0, r0, r0 } \
   YieldProcessor(); \
   __asm { or r1, r1, r1 } \
   YieldProcessor(); \
   __asm { or r0, r0, r0 } \
   YieldProcessor(); \
   __asm { or r1, r1, r1 } \
   YieldProcessor(); \
   __asm { or r0, r0, r0 } \
   YieldProcessor(); \
   __asm { or r1, r1, r1 } \
   YieldProcessor(); \
   __asm { or r0, r0, r0 } \
   YieldProcessor(); \
   __asm { or r1, r1, r1 }
#else
LZHAM_FORCE_INLINE void lzham_yield_processor()
{
#if LZHAM_USE_MSVC_INTRINSICS
   #if LZHAM_PLATFORM_PC_X64
      _mm_pause();
   #else
      YieldProcessor();
   #endif
#else
   // No implementation
#endif
}
#endif

#ifndef _MSC_VER
   int sprintf_s(char *buffer, size_t sizeOfBuffer, const char *format, ...);
   int vsprintf_s(char *buffer, size_t sizeOfBuffer, const char *format, va_list args);
#endif

#if LZHAM_PLATFORM_X360
   #define LZHAM_MEMORY_EXPORT_BARRIER MemoryBarrier();
#else
   // Barriers shouldn't be necessary on x86/x64.
   // TODO: Should use __sync_synchronize() on other platforms that support GCC.
   #define LZHAM_MEMORY_EXPORT_BARRIER
#endif

#if LZHAM_PLATFORM_X360
   #define LZHAM_MEMORY_IMPORT_BARRIER MemoryBarrier();
#else
   // Barriers shouldn't be necessary on x86/x64.
   // TODO: Should use __sync_synchronize() on other platforms that support GCC.
   #define LZHAM_MEMORY_IMPORT_BARRIER
#endif

// Note: It's very important that LZHAM_READ_BIG_ENDIAN_UINT32() is fast on the target platform.
// This is used to read every DWORD from the input stream.

#if LZHAM_USE_UNALIGNED_INT_LOADS
   #if LZHAM_BIG_ENDIAN_CPU
      #define LZHAM_READ_BIG_ENDIAN_UINT32(p) *reinterpret_cast<const uint32*>(p)
   #else
      #if defined(LZHAM_USE_MSVC_INTRINSICS)
         #define LZHAM_READ_BIG_ENDIAN_UINT32(p) _byteswap_ulong(*reinterpret_cast<const uint32*>(p))
      #elif defined(__GNUC__)
         #define LZHAM_READ_BIG_ENDIAN_UINT32(p) __builtin_bswap32(*reinterpret_cast<const uint32*>(p))
      #else
         #define LZHAM_READ_BIG_ENDIAN_UINT32(p) utils::swap32(*reinterpret_cast<const uint32*>(p))
      #endif
   #endif
#else
   #define LZHAM_READ_BIG_ENDIAN_UINT32(p) ((reinterpret_cast<const uint8*>(p)[0] << 24) | (reinterpret_cast<const uint8*>(p)[1] << 16) | (reinterpret_cast<const uint8*>(p)[2] << 8) | (reinterpret_cast<const uint8*>(p)[3]))
#endif

#if LZHAM_USE_WIN32_ATOMIC_FUNCTIONS
   extern "C" __int64 _InterlockedCompareExchange64(__int64 volatile * Destination, __int64 Exchange, __int64 Comperand);
   #if defined(_MSC_VER)
      #pragma intrinsic(_InterlockedCompareExchange64)
   #endif
#endif // LZHAM_USE_WIN32_ATOMIC_FUNCTIONS

namespace lzham
{
#if LZHAM_USE_WIN32_ATOMIC_FUNCTIONS
   typedef LONG atomic32_t;
   typedef LONGLONG atomic64_t;

   // Returns the original value.
   inline atomic32_t atomic_compare_exchange32(atomic32_t volatile *pDest, atomic32_t exchange, atomic32_t comparand)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return InterlockedCompareExchange(pDest, exchange, comparand);
   }

   // Returns the original value.
   inline atomic64_t atomic_compare_exchange64(atomic64_t volatile *pDest, atomic64_t exchange, atomic64_t comparand)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 7) == 0);
      return _InterlockedCompareExchange64(pDest, exchange, comparand);
   }

   // Returns the resulting incremented value.
   inline atomic32_t atomic_increment32(atomic32_t volatile *pDest)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return InterlockedIncrement(pDest);
   }

   // Returns the resulting decremented value.
   inline atomic32_t atomic_decrement32(atomic32_t volatile *pDest)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return InterlockedDecrement(pDest);
   }

   // Returns the original value.
   inline atomic32_t atomic_exchange32(atomic32_t volatile *pDest, atomic32_t val)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return InterlockedExchange(pDest, val);
   }

   // Returns the resulting value.
   inline atomic32_t atomic_add32(atomic32_t volatile *pDest, atomic32_t val)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return InterlockedExchangeAdd(pDest, val) + val;
   }

   // Returns the original value.
   inline atomic32_t atomic_exchange_add(atomic32_t volatile *pDest, atomic32_t val)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return InterlockedExchangeAdd(pDest, val);
   }
#elif LZHAM_USE_GCC_ATOMIC_BUILTINS
   typedef long atomic32_t;
   typedef long long atomic64_t;

   // Returns the original value.
   inline atomic32_t atomic_compare_exchange32(atomic32_t volatile *pDest, atomic32_t exchange, atomic32_t comparand)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return __sync_val_compare_and_swap(pDest, comparand, exchange);
   }

   // Returns the original value.
   inline atomic64_t atomic_compare_exchange64(atomic64_t volatile *pDest, atomic64_t exchange, atomic64_t comparand)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 7) == 0);
      return __sync_val_compare_and_swap(pDest, comparand, exchange);
   }

   // Returns the resulting incremented value.
   inline atomic32_t atomic_increment32(atomic32_t volatile *pDest)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return __sync_add_and_fetch(pDest, 1);
   }

   // Returns the resulting decremented value.
   inline atomic32_t atomic_decrement32(atomic32_t volatile *pDest)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return __sync_sub_and_fetch(pDest, 1);
   }

   // Returns the original value.
   inline atomic32_t atomic_exchange32(atomic32_t volatile *pDest, atomic32_t val)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return __sync_lock_test_and_set(pDest, val);
   }

   // Returns the resulting value.
   inline atomic32_t atomic_add32(atomic32_t volatile *pDest, atomic32_t val)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return __sync_add_and_fetch(pDest, val);
   }

   // Returns the original value.
   inline atomic32_t atomic_exchange_add(atomic32_t volatile *pDest, atomic32_t val)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return __sync_fetch_and_add(pDest, val);
   }
#else
   #define LZHAM_NO_ATOMICS 1

   // Atomic ops not supported - but try to do something reasonable. Assumes no threading at all.
   typedef long atomic32_t;
   typedef long long atomic64_t;

   inline atomic32_t atomic_compare_exchange32(atomic32_t volatile *pDest, atomic32_t exchange, atomic32_t comparand)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      atomic32_t cur = *pDest;
      if (cur == comparand)
         *pDest = exchange;
      return cur;
   }

   inline atomic64_t atomic_compare_exchange64(atomic64_t volatile *pDest, atomic64_t exchange, atomic64_t comparand)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 7) == 0);
      atomic64_t cur = *pDest;
      if (cur == comparand)
         *pDest = exchange;
      return cur;
   }

   inline atomic32_t atomic_increment32(atomic32_t volatile *pDest)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return (*pDest += 1);
   }

   inline atomic32_t atomic_decrement32(atomic32_t volatile *pDest)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return (*pDest -= 1);
   }

   inline atomic32_t atomic_exchange32(atomic32_t volatile *pDest, atomic32_t val)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      atomic32_t cur = *pDest;
      *pDest = val;
      return cur;
   }

   inline atomic32_t atomic_add32(atomic32_t volatile *pDest, atomic32_t val)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      return (*pDest += val);
   }

   inline atomic32_t atomic_exchange_add(atomic32_t volatile *pDest, atomic32_t val)
   {
      LZHAM_ASSERT((reinterpret_cast<ptr_bits_t>(pDest) & 3) == 0);
      atomic32_t cur = *pDest;
      *pDest += val;
      return cur;
   }

#endif

#if LZHAM_BUFFERED_PRINTF
   void lzham_buffered_printf(const char *format, ...);
   void lzham_flush_buffered_printf();
#else
   inline void lzham_buffered_printf(const char *format, ...) { (void)format; }
   inline void lzham_flush_buffered_printf() { }
#endif

} // namespace lzham
// File: lzham_prefix_coding.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_prefix_coding.h"

#ifdef LZHAM_BUILD_DEBUG
   //#define TEST_DECODER_TABLES
#endif

namespace lzham
{
   namespace prefix_coding
   {
      bool limit_max_code_size(uint num_syms, uint8* pCodesizes, uint max_code_size)
      {
         const uint cMaxEverCodeSize = 34;            
         
         if ((!num_syms) || (num_syms > cMaxSupportedSyms) || (max_code_size < 1) || (max_code_size > cMaxEverCodeSize))
         {
            LZHAM_LOG_ERROR(3000);
            return false;
         }
         
         uint num_codes[cMaxEverCodeSize + 1];
         utils::zero_object(num_codes);

         bool should_limit = false;
         
         for (uint i = 0; i < num_syms; i++)
         {
            uint c = pCodesizes[i];
            
            LZHAM_ASSERT(c <= cMaxEverCodeSize);
            
            num_codes[c]++;
            if (c > max_code_size)
               should_limit = true;
         }
         
         if (!should_limit)
            return true;
         
         uint ofs = 0;
         uint next_sorted_ofs[cMaxEverCodeSize + 1];
         for (uint i = 1; i <= cMaxEverCodeSize; i++)
         {
            next_sorted_ofs[i] = ofs;
            ofs += num_codes[i];
         }
            
         if ((ofs < 2) || (ofs > cMaxSupportedSyms))
            return true;
         
         if (ofs > (1U << max_code_size))
         {
            LZHAM_LOG_ERROR(3001);
            return false;
         }
                           
         for (uint i = max_code_size + 1; i <= cMaxEverCodeSize; i++)
            num_codes[max_code_size] += num_codes[i];
         
         // Technique of adjusting tree to enforce maximum code size from LHArc. 
			// (If you remember what LHArc was, you've been doing this for a LONG time.)
         
         uint total = 0;
         for (uint i = max_code_size; i; --i)
            total += (num_codes[i] << (max_code_size - i));

         if (total == (1U << max_code_size))  
            return true;
            
         do
         {
            num_codes[max_code_size]--;

            uint i;
            for (i = max_code_size - 1; i; --i)
            {
               if (!num_codes[i])
                  continue;
               num_codes[i]--;          
               num_codes[i + 1] += 2;   
               break;
            }
            if (!i)
            {
               LZHAM_LOG_ERROR(3002);
               return false;
            }

            total--;   
         } while (total != (1U << max_code_size));
         
         uint8 new_codesizes[cMaxSupportedSyms];
         uint8* p = new_codesizes;
         for (uint i = 1; i <= max_code_size; i++)
         {
            uint n = num_codes[i];
            if (n)
            {
               memset(p, i, n);
               p += n;
            }
         }
                                             
         for (uint i = 0; i < num_syms; i++)
         {
            const uint c = pCodesizes[i];
            if (c)
            {
               uint next_ofs = next_sorted_ofs[c];
               next_sorted_ofs[c] = next_ofs + 1;
            
               pCodesizes[i] = static_cast<uint8>(new_codesizes[next_ofs]);
            }
         }
            
         return true;
      }
            
      bool generate_codes(uint num_syms, const uint8* pCodesizes, uint16* pCodes)
      {
         uint num_codes[cMaxExpectedHuffCodeSize + 1];
         utils::zero_object(num_codes);

         for (uint i = 0; i < num_syms; i++)
         {
            uint c = pCodesizes[i];
            LZHAM_ASSERT(c <= cMaxExpectedHuffCodeSize);
            num_codes[c]++;
         }

         uint code = 0;

         uint next_code[cMaxExpectedHuffCodeSize + 1];
         next_code[0] = 0;
         
         for (uint i = 1; i <= cMaxExpectedHuffCodeSize; i++)
         {
            next_code[i] = code;
            
            code = (code + num_codes[i]) << 1;
         }

         if (code != (1 << (cMaxExpectedHuffCodeSize + 1)))
         {
            uint t = 0;
            for (uint i = 1; i <= cMaxExpectedHuffCodeSize; i++)
            {
               t += num_codes[i];
               if (t > 1)
               {
                  LZHAM_LOG_ERROR(3003);
                  return false;
               }
            }
         }

         for (uint i = 0; i < num_syms; i++)
         {
            uint c = pCodesizes[i];
            
            LZHAM_ASSERT(!c || (next_code[c] <= cUINT16_MAX));
            
            pCodes[i] = static_cast<uint16>(next_code[c]++);
            
            LZHAM_ASSERT(!c || (math::total_bits(pCodes[i]) <= pCodesizes[i]));
         }
         
         return true;
      }

      static const uint16 g_uint16_sequence[cMaxSupportedSyms] =
      {
         0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
         16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
         48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
         80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
         112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
         144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
         176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
         208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
         240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271,
         272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303,
         304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335,
         336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367,
         368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399,
         400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431,
         432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463,
         464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495,
         496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
         528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559,
         560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591,
         592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623,
         624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655,
         656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687,
         688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719,
         720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751,
         752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783,
         784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815,
         816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847,
         848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879,
         880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911,
         912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943,
         944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975,
         976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007,
         1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023 
      };
                       
      bool generate_decoder_tables(uint num_syms, const uint8* pCodesizes, decoder_tables* pTables, uint table_bits, const code_size_histogram &code_size_histo, bool sym_freq_all_ones)
      {
         uint min_codes[cMaxExpectedHuffCodeSize];
         
         if ((!num_syms) || (table_bits > cMaxTableBits))
         {
            LZHAM_LOG_ERROR(3004);
            return false;
         }
            
         pTables->m_num_syms = num_syms;
      
         uint sorted_positions[cMaxExpectedHuffCodeSize + 1];
               
         uint next_code = 0;

         uint total_used_syms = 0;
         uint max_code_size = 0;
         uint min_code_size = UINT_MAX;
         for (uint i = 1; i <= cMaxExpectedHuffCodeSize; i++)
         {
            const uint n = code_size_histo.m_num_codes[i];
            
            if (!n)
               pTables->m_max_codes[i - 1] = 0;//UINT_MAX;
            else
            {
               min_code_size = math::minimum(min_code_size, i);
               max_code_size = math::maximum(max_code_size, i);
                  
               min_codes[i - 1] = next_code;
               
               pTables->m_max_codes[i - 1] = next_code + n - 1;
               pTables->m_max_codes[i - 1] = 1 + ((pTables->m_max_codes[i - 1] << (16 - i)) | ((1 << (16 - i)) - 1));
               
               pTables->m_val_ptrs[i - 1] = total_used_syms;
               
               sorted_positions[i] = total_used_syms;
               
               next_code += n;
               total_used_syms += n;
            }

            next_code <<= 1;
         }
         
         pTables->m_total_used_syms = total_used_syms;

         if (total_used_syms > pTables->m_cur_sorted_symbol_order_size)
         {
            pTables->m_cur_sorted_symbol_order_size = total_used_syms;
            
            if (!math::is_power_of_2(total_used_syms))
               pTables->m_cur_sorted_symbol_order_size = math::minimum<uint>(num_syms, math::next_pow2(total_used_syms));
            
            if (pTables->m_sorted_symbol_order)
            {
               lzham_delete_array(pTables->m_malloc_context, pTables->m_sorted_symbol_order);
               pTables->m_sorted_symbol_order = NULL;
            }
            
            pTables->m_sorted_symbol_order = lzham_new_array<uint16>(pTables->m_malloc_context, pTables->m_cur_sorted_symbol_order_size);
            if (!pTables->m_sorted_symbol_order)
            {
               LZHAM_LOG_ERROR(3005);
               return false;
            }
         }
         
         pTables->m_min_code_size = static_cast<uint8>(min_code_size);
         pTables->m_max_code_size = static_cast<uint8>(max_code_size);

         if (sym_freq_all_ones)
         {
            if (min_code_size == max_code_size)
            {
               memcpy(pTables->m_sorted_symbol_order, g_uint16_sequence, num_syms * sizeof(uint16));
            }
            else
            {
               LZHAM_ASSERT((min_code_size + 1) == max_code_size);
               LZHAM_ASSERT(pCodesizes[0] == max_code_size);
               LZHAM_ASSERT(pCodesizes[code_size_histo.m_num_codes[max_code_size]] == min_code_size);
                              
               memcpy(pTables->m_sorted_symbol_order + sorted_positions[max_code_size], g_uint16_sequence, code_size_histo.m_num_codes[max_code_size] * sizeof(uint16));
               
               memcpy(pTables->m_sorted_symbol_order + sorted_positions[min_code_size], g_uint16_sequence + code_size_histo.m_num_codes[max_code_size], code_size_histo.m_num_codes[min_code_size] * sizeof(uint16));
            }

#ifdef LZHAM_BUILD_DEBUG
            for (uint i = 0; i < num_syms; i++)
            {
               uint c = pCodesizes[i];
               LZHAM_ASSERT(code_size_histo.m_num_codes[c]);

               uint sorted_pos = sorted_positions[c]++;

               LZHAM_ASSERT(sorted_pos < total_used_syms);

               LZHAM_ASSERT(pTables->m_sorted_symbol_order[sorted_pos] == i);
            }
#endif
         }
         else
         {
            for (uint i = 0; i < num_syms; i++)
            {
               uint c = pCodesizes[i];
               LZHAM_ASSERT(code_size_histo.m_num_codes[c]);
               
               uint sorted_pos = sorted_positions[c]++;
               
               LZHAM_ASSERT(sorted_pos < total_used_syms);
               
               pTables->m_sorted_symbol_order[sorted_pos] = static_cast<uint16>(i);
            }
         }

         if (table_bits <= pTables->m_min_code_size)
            table_bits = 0;                                       
         pTables->m_table_bits = table_bits;
                  
         if (table_bits)
         {
            uint table_size = 1 << table_bits;
            if (table_size > pTables->m_cur_lookup_size)
            {
               pTables->m_cur_lookup_size = table_size;
               
               if (pTables->m_lookup)
               {
                  lzham_delete_array(pTables->m_malloc_context, pTables->m_lookup);
                  pTables->m_lookup = NULL;
               }
                  
               pTables->m_lookup = lzham_new_array<uint32>(pTables->m_malloc_context, table_size);
               if (!pTables->m_lookup)
               {
                  LZHAM_LOG_ERROR(3006);
                  return false;
               }
            }
                        
            memset(pTables->m_lookup, 0xFF, static_cast<uint>(sizeof(pTables->m_lookup[0])) * (1UL << table_bits));
            
            for (uint codesize = 1; codesize <= table_bits; codesize++)
            {
               if (!code_size_histo.m_num_codes[codesize])
                  continue;
               
               const uint fillsize = table_bits - codesize;
               const uint fillnum = 1 << fillsize;
               
               const uint min_code = min_codes[codesize - 1];
               const uint max_code = pTables->get_unshifted_max_code(codesize);
               const uint val_ptr = pTables->m_val_ptrs[codesize - 1];
                      
               for (uint code = min_code; code <= max_code; code++)
               {
                  const uint sym_index = pTables->m_sorted_symbol_order[ val_ptr + code - min_code ];
                  LZHAM_ASSERT( pCodesizes[sym_index] == codesize );
                  
                  for (uint j = 0; j < fillnum; j++)
                  {
                     const uint t = j + (code << fillsize);
                     
                     LZHAM_ASSERT(t < (1U << table_bits));
                     
                     LZHAM_ASSERT(pTables->m_lookup[t] == cUINT32_MAX);
                     
                     pTables->m_lookup[t] = sym_index | (codesize << 16U);
                  }
               }
            }
         }         
         
         for (uint i = 0; i < cMaxExpectedHuffCodeSize; i++)
            pTables->m_val_ptrs[i] -= min_codes[i];
         
         pTables->m_table_max_code = 0;
         pTables->m_decode_start_code_size = pTables->m_min_code_size;

         if (table_bits)
         {
            uint i;
            for (i = table_bits; i >= 1; i--)
            {
               if (code_size_histo.m_num_codes[i])
               {
                  pTables->m_table_max_code = pTables->m_max_codes[i - 1];
                  break;
               }
            }
            if (i >= 1)
            {
               pTables->m_decode_start_code_size = table_bits + 1;
               for (i = table_bits + 1; i <= max_code_size; i++)
               {
                  if (code_size_histo.m_num_codes[i])
                  {
                     pTables->m_decode_start_code_size = i;
                     break;
                  }
               }
            }
         }

         // sentinels
         pTables->m_max_codes[cMaxExpectedHuffCodeSize] = UINT_MAX;
         pTables->m_val_ptrs[cMaxExpectedHuffCodeSize] = 0xFFFFF;

         pTables->m_table_shift = 32 - pTables->m_table_bits;

         return true;
      }
               
   } // namespace prefix_codig

} // namespace lzham


// File: lzham_prefix_coding.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once
#include "lzham_huffman_codes.h"

namespace lzham
{
   namespace prefix_coding
   {
      const uint cMaxSupportedSyms = 1024;
      
      // This value can be tuned for a specific CPU.
      const uint cMaxTableBits = 11;

      bool limit_max_code_size(uint num_syms, uint8* pCodesizes, uint max_code_size);

      bool generate_codes(uint num_syms, const uint8* pCodesizes, uint16* pCodes);
            
      class decoder_tables
      {
      public:
         inline decoder_tables(lzham_malloc_context malloc_context) :
            m_malloc_context(malloc_context),
            m_table_shift(0), m_table_max_code(0), m_decode_start_code_size(0), m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL)
         {
         }

         inline decoder_tables(const decoder_tables& other) :
            m_malloc_context(other.m_malloc_context),
            m_table_shift(0), m_table_max_code(0), m_decode_start_code_size(0), m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL)
         {
            *this = other;
         }

         inline decoder_tables& operator= (const decoder_tables& rhs)
         {
            assign(rhs);
            return *this;
         }

         inline bool assign(const decoder_tables& rhs)
         {
            if (this == &rhs)
               return true;

            if (m_malloc_context != rhs.m_malloc_context)
            {
               clear();

               m_malloc_context = rhs.m_malloc_context;
            }

            uint32* pCur_lookup = m_lookup;
            uint16* pCur_sorted_symbol_order = m_sorted_symbol_order;

            memcpy(this, &rhs, sizeof(*this));

            if ((pCur_lookup) && (pCur_sorted_symbol_order) && (rhs.m_cur_lookup_size == m_cur_lookup_size) && (rhs.m_cur_sorted_symbol_order_size == m_cur_sorted_symbol_order_size))
            {
               m_lookup = pCur_lookup;
               m_sorted_symbol_order = pCur_sorted_symbol_order;

               memcpy(m_lookup, rhs.m_lookup, sizeof(m_lookup[0]) * m_cur_lookup_size);
               memcpy(m_sorted_symbol_order, rhs.m_sorted_symbol_order, sizeof(m_sorted_symbol_order[0]) * m_cur_sorted_symbol_order_size);
            }
            else
            {
               lzham_delete_array(m_malloc_context, pCur_lookup);
               m_lookup = NULL;

               if (rhs.m_lookup)
               {
                  m_lookup = lzham_new_array<uint32>(m_malloc_context, m_cur_lookup_size);
                  if (!m_lookup)
                     return false;
                  memcpy(m_lookup, rhs.m_lookup, sizeof(m_lookup[0]) * m_cur_lookup_size);
               }

               lzham_delete_array(m_malloc_context, pCur_sorted_symbol_order);
               m_sorted_symbol_order = NULL;

               if (rhs.m_sorted_symbol_order)
               {
                  m_sorted_symbol_order = lzham_new_array<uint16>(m_malloc_context, m_cur_sorted_symbol_order_size);
                  if (!m_sorted_symbol_order)
                     return false;
                  memcpy(m_sorted_symbol_order, rhs.m_sorted_symbol_order, sizeof(m_sorted_symbol_order[0]) * m_cur_sorted_symbol_order_size);
               }
            }

            return true;
         }
         
         inline void clear()
         {
            if (m_lookup)
            {
               lzham_delete_array(m_malloc_context, m_lookup);
               m_lookup = 0;
               m_cur_lookup_size = 0;
            }

            if (m_sorted_symbol_order)
            {
               lzham_delete_array(m_malloc_context, m_sorted_symbol_order);
               m_sorted_symbol_order = NULL;
               m_cur_sorted_symbol_order_size = 0;
            }
         }

         inline ~decoder_tables()
         {
            if (m_lookup)
               lzham_delete_array(m_malloc_context, m_lookup);

            if (m_sorted_symbol_order)
               lzham_delete_array(m_malloc_context, m_sorted_symbol_order);
         }

         // DO NOT use any complex classes here - it is bitwise copied.
         
         lzham_malloc_context m_malloc_context;

         uint                 m_num_syms;
         uint                 m_total_used_syms;
         uint                 m_table_bits;
         uint                 m_table_shift;
         uint                 m_table_max_code;
         uint                 m_decode_start_code_size;

         uint8                m_min_code_size;
         uint8                m_max_code_size;

         uint                 m_max_codes[cMaxExpectedHuffCodeSize + 1];
         int                  m_val_ptrs[cMaxExpectedHuffCodeSize + 1];

         uint                 m_cur_lookup_size;
         uint32*              m_lookup;

         uint                 m_cur_sorted_symbol_order_size;
         uint16*              m_sorted_symbol_order;

         inline uint get_unshifted_max_code(uint len) const
         {
            LZHAM_ASSERT( (len >= 1) && (len <= cMaxExpectedHuffCodeSize) );
            uint k = m_max_codes[len - 1];
            if (!k)
               return UINT_MAX;
            return (k - 1) >> (16 - len);
         }
      };

      bool generate_decoder_tables(uint num_syms, const uint8* pCodesizes, decoder_tables* pTables, uint table_bits, const code_size_histogram &code_size_histo, bool sym_freq_all_ones);

   } // namespace prefix_coding

} // namespace lzham
// File: lzham_symbol_codec.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_symbol_codec.h"
#include "lzham_huffman_codes.h"

// Was 16 in previous versions.
#define LZHAM_DEFAULT_MAX_UPDATE_INTERVAL 64

// Was 40 in previous versions
// Keep in sync with default setting in g_table_update_settings[]
#define LZHAM_DEFAULT_ADAPT_RATE 64U

namespace lzham
{
   // Using a fixed table to convert from scaled probability to scaled bits for determinism across compilers/run-time libs/platforms.
   uint32 g_prob_cost[cSymbolCodecArithProbScale] = 
   {
      0x0,0xB000000,0xA000000,0x96A3FE6,0x9000000,0x8AD961F,0x86A3FE6,0x8315130,0x8000000,0x7D47FCC,0x7AD961F,
      0x78A62B0,0x76A3FE6,0x74CAFFC,0x7315130,0x717D605,0x7000000,0x6E99C09,0x6D47FCC,0x6C087D3,0x6AD961F,0x69B9116,
      0x68A62B0,0x679F7D8,0x66A3FE6,0x65B2C3E,0x64CAFFC,0x63EBFB1,0x6315130,0x6245B5C,0x617D605,0x60BB9CA,0x6000000,
      0x5F4A296,0x5E99C09,0x5DEE74F,0x5D47FCC,0x5CA6144,0x5C087D3,0x5B6EFE1,0x5AD961F,0x5A47779,0x59B9116,0x592E050,
      0x58A62B0,0x58215EA,0x579F7D8,0x5720677,0x56A3FE6,0x562A260,0x55B2C3E,0x553DBEF,0x54CAFFC,0x545A701,0x53EBFB1,
      0x537F8CF,0x5315130,0x52AC7B8,0x5245B5C,0x51E0B1B,0x517D605,0x511BB33,0x50BB9CA,0x505D0FC,0x5000000,0x4FA461A,
      0x4F4A296,0x4EF14C7,0x4E99C09,0x4E437BE,0x4DEE74F,0x4D9AA2C,0x4D47FCC,0x4CF67A8,0x4CA6144,0x4C56C23,0x4C087D3,
      0x4BBB3E1,0x4B6EFE1,0x4B23B6D,0x4AD961F,0x4A8FF97,0x4A47779,0x49FFD6A,0x49B9116,0x4973228,0x492E050,0x48E9B41,
      0x48A62B0,0x4863655,0x48215EA,0x47E012C,0x479F7D8,0x475F9B0,0x4720677,0x46E1DF1,0x46A3FE6,0x4666C1D,0x462A260,
      0x45EE27C,0x45B2C3E,0x4577F74,0x453DBEF,0x4504180,0x44CAFFC,0x4492735,0x445A701,0x4422F38,0x43EBFB1,0x43B5846,
      0x437F8CF,0x434A129,0x4315130,0x42E08C0,0x42AC7B8,0x4278DF7,0x4245B5C,0x4212FC7,0x41E0B1B,0x41AED39,0x417D605,
      0x414C561,0x411BB33,0x40EB75F,0x40BB9CA,0x408C25C,0x405D0FC,0x402E58F,0x4000000,0x3FD2036,0x3FA461A,0x3F77197,
      0x3F4A296,0x3F1D903,0x3EF14C7,0x3EC55D0,0x3E99C09,0x3E6E75F,0x3E437BE,0x3E18D14,0x3DEE74F,0x3DC465D,0x3D9AA2C,
      0x3D712AC,0x3D47FCC,0x3D1F17A,0x3CF67A8,0x3CCE246,0x3CA6144,0x3C7E492,0x3C56C23,0x3C2F7E8,0x3C087D3,0x3BE1BD5,
      0x3BBB3E1,0x3B94FE9,0x3B6EFE1,0x3B493BC,0x3B23B6D,0x3AFE6E7,0x3AD961F,0x3AB4908,0x3A8FF97,0x3A6B9C0,0x3A47779,
      0x3A238B5,0x39FFD6A,0x39DC58E,0x39B9116,0x3995FF7,0x3973228,0x395079E,0x392E050,0x390BC34,0x38E9B41,0x38C7D6E,
      0x38A62B0,0x3884B01,0x3863655,0x38424A6,0x38215EA,0x3800A1A,0x37E012C,0x37BFB18,0x379F7D8,0x377F762,0x375F9B0,
      0x373FEBA,0x3720677,0x37010E1,0x36E1DF1,0x36C2DA0,0x36A3FE6,0x36854BC,0x3666C1D,0x3648600,0x362A260,0x360C136,
      0x35EE27C,0x35D062B,0x35B2C3E,0x35954AD,0x3577F74,0x355AC8C,0x353DBEF,0x3520D98,0x3504180,0x34E77A4,0x34CAFFC,
      0x34AEA83,0x3492735,0x347660B,0x345A701,0x343EA12,0x3422F38,0x340766F,0x33EBFB1,0x33D0AFA,0x33B5846,0x339A78E,
      0x337F8CF,0x3364C05,0x334A129,0x332F839,0x3315130,0x32FAC09,0x32E08C0,0x32C6751,0x32AC7B8,0x32929F1,0x3278DF7,
      0x325F3C6,0x3245B5C,0x322C4B2,0x3212FC7,0x31F9C96,0x31E0B1B,0x31C7B53,0x31AED39,0x31960CB,0x317D605,0x3164CE2,
      0x314C561,0x3133F7D,0x311BB33,0x310387F,0x30EB75F,0x30D37CE,0x30BB9CA,0x30A3D50,0x308C25C,0x30748EC,0x305D0FC,
      0x3045A88,0x302E58F,0x301720E,0x3000000,0x2FE8F64,0x2FD2036,0x2FBB274,0x2FA461A,0x2F8DB27,0x2F77197,0x2F60968,
      0x2F4A296,0x2F33D20,0x2F1D903,0x2F0763B,0x2EF14C7,0x2EDB4A5,0x2EC55D0,0x2EAF848,0x2E99C09,0x2E84111,0x2E6E75F,
      0x2E58EEE,0x2E437BE,0x2E2E1CB,0x2E18D14,0x2E03996,0x2DEE74F,0x2DD963D,0x2DC465D,0x2DAF7AD,0x2D9AA2C,0x2D85DD7,
      0x2D712AC,0x2D5C8A9,0x2D47FCC,0x2D33812,0x2D1F17A,0x2D0AC02,0x2CF67A8,0x2CE246A,0x2CCE246,0x2CBA13A,0x2CA6144,
      0x2C92262,0x2C7E492,0x2C6A7D4,0x2C56C23,0x2C43180,0x2C2F7E8,0x2C1BF5A,0x2C087D3,0x2BF5151,0x2BE1BD5,0x2BCE75A,
      0x2BBB3E1,0x2BA8166,0x2B94FE9,0x2B81F68,0x2B6EFE1,0x2B5C153,0x2B493BC,0x2B3671A,0x2B23B6D,0x2B110B1,0x2AFE6E7,
      0x2AEBE0C,0x2AD961F,0x2AC6F1E,0x2AB4908,0x2AA23DC,0x2A8FF97,0x2A7DC39,0x2A6B9C0,0x2A5982B,0x2A47779,0x2A357A7,
      0x2A238B5,0x2A11AA1,0x29FFD6A,0x29EE10F,0x29DC58E,0x29CAAE6,0x29B9116,0x29A781C,0x2995FF7,0x29848A6,0x2973228,
      0x2961C7B,0x295079E,0x293F390,0x292E050,0x291CDDD,0x290BC34,0x28FAB56,0x28E9B41,0x28D8BF4,0x28C7D6E,0x28B6FAD,
      0x28A62B0,0x2895677,0x2884B01,0x287404B,0x2863655,0x2852D1F,0x28424A6,0x2831CEA,0x28215EA,0x2810FA5,0x2800A1A,
      0x27F0547,0x27E012C,0x27CFDC7,0x27BFB18,0x27AF91E,0x279F7D8,0x278F744,0x277F762,0x276F831,0x275F9B0,0x274FBDE,
      0x273FEBA,0x2730242,0x2720677,0x2710B57,0x27010E1,0x26F1715,0x26E1DF1,0x26D2575,0x26C2DA0,0x26B3670,0x26A3FE6,
      0x26949FF,0x26854BC,0x267601C,0x2666C1D,0x26578BE,0x2648600,0x26393E1,0x262A260,0x261B17D,0x260C136,0x25FD18C,
      0x25EE27C,0x25DF407,0x25D062B,0x25C18E8,0x25B2C3E,0x25A402A,0x25954AD,0x25869C6,0x2577F74,0x25695B6,0x255AC8C,
      0x254C3F4,0x253DBEF,0x252F47B,0x2520D98,0x2512744,0x2504180,0x24F5C4B,0x24E77A4,0x24D9389,0x24CAFFC,0x24BCCFA,
      0x24AEA83,0x24A0897,0x2492735,0x248465C,0x247660B,0x2468643,0x245A701,0x244C847,0x243EA12,0x2430C63,0x2422F38,
      0x2415292,0x240766F,0x23F9ACF,0x23EBFB1,0x23DE515,0x23D0AFA,0x23C3160,0x23B5846,0x23A7FAB,0x239A78E,0x238CFF0,
      0x237F8CF,0x237222C,0x2364C05,0x2357659,0x234A129,0x233CC74,0x232F839,0x2322478,0x2315130,0x2307E61,0x22FAC09,
      0x22EDA29,0x22E08C0,0x22D37CE,0x22C6751,0x22B974A,0x22AC7B8,0x229F89B,0x22929F1,0x2285BBA,0x2278DF7,0x226C0A6,
      0x225F3C6,0x2252758,0x2245B5C,0x2238FCF,0x222C4B2,0x221FA05,0x2212FC7,0x22065F7,0x21F9C96,0x21ED3A2,0x21E0B1B,
      0x21D4301,0x21C7B53,0x21BB410,0x21AED39,0x21A26CD,0x21960CB,0x2189B33,0x217D605,0x217113F,0x2164CE2,0x21588EE,
      0x214C561,0x214023B,0x2133F7D,0x2127D25,0x211BB33,0x210F9A6,0x210387F,0x20F77BD,0x20EB75F,0x20DF765,0x20D37CE,
      0x20C789B,0x20BB9CA,0x20AFB5C,0x20A3D50,0x2097FA6,0x208C25C,0x2080574,0x20748EC,0x2068CC4,0x205D0FC,0x2051593,
      0x2045A88,0x2039FDD,0x202E58F,0x2022BA0,0x201720E,0x200B8D8,0x2000000,0x1FF4784,0x1FE8F64,0x1FDD79F,0x1FD2036,
      0x1FC6928,0x1FBB274,0x1FAFC1A,0x1FA461A,0x1F99074,0x1F8DB27,0x1F82633,0x1F77197,0x1F6BD53,0x1F60968,0x1F555D3,
      0x1F4A296,0x1F3EFB0,0x1F33D20,0x1F28AE6,0x1F1D903,0x1F12774,0x1F0763B,0x1EFC557,0x1EF14C7,0x1EE648C,0x1EDB4A5,
      0x1ED0511,0x1EC55D0,0x1EBA6E3,0x1EAF848,0x1EA49FF,0x1E99C09,0x1E8EE64,0x1E84111,0x1E79410,0x1E6E75F,0x1E63AFE,
      0x1E58EEE,0x1E4E32E,0x1E437BE,0x1E38C9D,0x1E2E1CB,0x1E23748,0x1E18D14,0x1E0E32E,0x1E03996,0x1DF904C,0x1DEE74F,
      0x1DE3E9F,0x1DD963D,0x1DCEE27,0x1DC465D,0x1DB9EDF,0x1DAF7AD,0x1DA50C7,0x1D9AA2C,0x1D903DC,0x1D85DD7,0x1D7B81C,
      0x1D712AC,0x1D66D86,0x1D5C8A9,0x1D52416,0x1D47FCC,0x1D3DBCA,0x1D33812,0x1D294A2,0x1D1F17A,0x1D14E9B,0x1D0AC02,
      0x1D009B2,0x1CF67A8,0x1CEC5E6,0x1CE246A,0x1CD8335,0x1CCE246,0x1CC419D,0x1CBA13A,0x1CB011C,0x1CA6144,0x1C9C1B0,
      0x1C92262,0x1C88358,0x1C7E492,0x1C74611,0x1C6A7D4,0x1C609DA,0x1C56C23,0x1C4CEB0,0x1C43180,0x1C39493,0x1C2F7E8,
      0x1C25B80,0x1C1BF5A,0x1C12375,0x1C087D3,0x1BFEC71,0x1BF5151,0x1BEB673,0x1BE1BD5,0x1BD8177,0x1BCE75A,0x1BC4D7D,
      0x1BBB3E1,0x1BB1A84,0x1BA8166,0x1B9E888,0x1B94FE9,0x1B8B789,0x1B81F68,0x1B78786,0x1B6EFE1,0x1B6587B,0x1B5C153,
      0x1B52A69,0x1B493BC,0x1B3FD4D,0x1B3671A,0x1B2D125,0x1B23B6D,0x1B1A5F1,0x1B110B1,0x1B07BAE,0x1AFE6E7,0x1AF525C,
      0x1AEBE0C,0x1AE29F8,0x1AD961F,0x1AD0281,0x1AC6F1E,0x1ABDBF6,0x1AB4908,0x1AAB655,0x1AA23DC,0x1A9919C,0x1A8FF97,
      0x1A86DCB,0x1A7DC39,0x1A74AE0,0x1A6B9C0,0x1A628DA,0x1A5982B,0x1A507B6,0x1A47779,0x1A3E774,0x1A357A7,0x1A2C812,
      0x1A238B5,0x1A1A98F,0x1A11AA1,0x1A08BEA,0x19FFD6A,0x19F6F21,0x19EE10F,0x19E5333,0x19DC58E,0x19D381F,0x19CAAE6,
      0x19C1DE3,0x19B9116,0x19B047E,0x19A781C,0x199EBEF,0x1995FF7,0x198D434,0x19848A6,0x197BD4D,0x1973228,0x196A737,
      0x1961C7B,0x19591F3,0x195079E,0x1947D7D,0x193F390,0x19369D7,0x192E050,0x19256FD,0x191CDDD,0x19144EF,0x190BC34,
      0x19033AC,0x18FAB56,0x18F2333,0x18E9B41,0x18E1382,0x18D8BF4,0x18D0498,0x18C7D6E,0x18BF675,0x18B6FAD,0x18AE916,
      0x18A62B0,0x189DC7C,0x1895677,0x188D0A4,0x1884B01,0x187C58E,0x187404B,0x186BB38,0x1863655,0x185B1A2,0x1852D1F,
      0x184A8CB,0x18424A6,0x183A0B1,0x1831CEA,0x1829953,0x18215EA,0x18192B0,0x1810FA5,0x1808CC8,0x1800A1A,0x17F8799,
      0x17F0547,0x17E8322,0x17E012C,0x17D7F63,0x17CFDC7,0x17C7C59,0x17BFB18,0x17B7A05,0x17AF91E,0x17A7865,0x179F7D8,
      0x1797778,0x178F744,0x178773D,0x177F762,0x17777B4,0x176F831,0x17678DB,0x175F9B0,0x1757AB1,0x174FBDE,0x1747D36,
      0x173FEBA,0x1738068,0x1730242,0x1728447,0x1720677,0x17188D2,0x1710B57,0x1708E07,0x17010E1,0x16F93E6,0x16F1715,
      0x16E9A6E,0x16E1DF1,0x16DA19E,0x16D2575,0x16CA976,0x16C2DA0,0x16BB1F3,0x16B3670,0x16ABB16,0x16A3FE6,0x169C4DE,
      0x16949FF,0x168CF49,0x16854BC,0x167DA58,0x167601C,0x166E608,0x1666C1D,0x165F25A,0x16578BE,0x164FF4B,0x1648600,
      0x1640CDD,0x16393E1,0x1631B0D,0x162A260,0x16229DB,0x161B17D,0x1613946,0x160C136,0x160494D,0x15FD18C,0x15F59F0,
      0x15EE27C,0x15E6B2E,0x15DF407,0x15D7D06,0x15D062B,0x15C8F77,0x15C18E8,0x15BA280,0x15B2C3E,0x15AB621,0x15A402A,
      0x159CA59,0x15954AD,0x158DF27,0x15869C6,0x157F48A,0x1577F74,0x1570A82,0x15695B6,0x156210E,0x155AC8C,0x155382E,
      0x154C3F4,0x1544FDF,0x153DBEF,0x1536823,0x152F47B,0x15280F7,0x1520D98,0x1519A5C,0x1512744,0x150B450,0x1504180,
      0x14FCED4,0x14F5C4B,0x14EE9E6,0x14E77A4,0x14E0585,0x14D9389,0x14D21B1,0x14CAFFC,0x14C3E69,0x14BCCFA,0x14B5BAD,
      0x14AEA83,0x14A797C,0x14A0897,0x14997D5,0x1492735,0x148B6B7,0x148465C,0x147D622,0x147660B,0x146F616,0x1468643,
      0x1461691,0x145A701,0x1453793,0x144C847,0x144591C,0x143EA12,0x1437B2A,0x1430C63,0x1429DBD,0x1422F38,0x141C0D5,
      0x1415292,0x140E470,0x140766F,0x140088F,0x13F9ACF,0x13F2D30,0x13EBFB1,0x13E5253,0x13DE515,0x13D77F8,0x13D0AFA,
      0x13C9E1D,0x13C3160,0x13BC4C3,0x13B5846,0x13AEBE8,0x13A7FAB,0x13A138D,0x139A78E,0x1393BAF,0x138CFF0,0x1386450,
      0x137F8CF,0x1378D6E,0x137222C,0x136B709,0x1364C05,0x135E11F,0x1357659,0x1350BB2,0x134A129,0x13436C0,0x133CC74,
      0x1336248,0x132F839,0x1328E4A,0x1322478,0x131BAC5,0x1315130,0x130E7B9,0x1307E61,0x1301526,0x12FAC09,0x12F430A,
      0x12EDA29,0x12E7166,0x12E08C0,0x12DA038,0x12D37CE,0x12CCF81,0x12C6751,0x12BFF3F,0x12B974A,0x12B2F73,0x12AC7B8,
      0x12A601B,0x129F89B,0x1299137,0x12929F1,0x128C2C7,0x1285BBA,0x127F4CA,0x1278DF7,0x1272740,0x126C0A6,0x1265A28,
      0x125F3C6,0x1258D81,0x1252758,0x124C14C,0x1245B5C,0x123F587,0x1238FCF,0x1232A33,0x122C4B2,0x1225F4E,0x121FA05,
      0x12194D8,0x1212FC7,0x120CAD1,0x12065F7,0x1200139,0x11F9C96,0x11F380E,0x11ED3A2,0x11E6F51,0x11E0B1B,0x11DA700,
      0x11D4301,0x11CDF1C,0x11C7B53,0x11C17A4,0x11BB410,0x11B5097,0x11AED39,0x11A89F6,0x11A26CD,0x119C3BF,0x11960CB,
      0x118FDF2,0x1189B33,0x118388F,0x117D605,0x1177395,0x117113F,0x116AF04,0x1164CE2,0x115EADB,0x11588EE,0x115271A,
      0x114C561,0x11463C1,0x114023B,0x113A0CF,0x1133F7D,0x112DE44,0x1127D25,0x1121C1F,0x111BB33,0x1115A60,0x110F9A6,
      0x1109906,0x110387F,0x10FD811,0x10F77BD,0x10F1781,0x10EB75F,0x10E5755,0x10DF765,0x10D978D,0x10D37CE,0x10CD828,
      0x10C789B,0x10C1926,0x10BB9CA,0x10B5A87,0x10AFB5C,0x10A9C4A,0x10A3D50,0x109DE6F,0x1097FA6,0x10920F5,0x108C25C,
      0x10863DC,0x1080574,0x107A724,0x10748EC,0x106EACC,0x1068CC4,0x1062ED4,0x105D0FC,0x105733B,0x1051593,0x104B802,
      0x1045A88,0x103FD27,0x1039FDD,0x10342AA,0x102E58F,0x102888C,0x1022BA0,0x101CECB,0x101720E,0x1011567,0x100B8D8,
      0x1005C61,0x1000000,0xFFA3B6,0xFF4784,0xFEEB68,0xFE8F64,0xFE3376,0xFDD79F,0xFD7BDF,0xFD2036,0xFCC4A3,
      0xFC6928,0xFC0DC2,0xFBB274,0xFB573C,0xFAFC1A,0xFAA10F,0xFA461A,0xF9EB3C,0xF99074,0xF935C2,0xF8DB27,
      0xF880A2,0xF82633,0xF7CBDA,0xF77197,0xF7176A,0xF6BD53,0xF66353,0xF60968,0xF5AF93,0xF555D3,0xF4FC2A,
      0xF4A296,0xF44918,0xF3EFB0,0xF3965D,0xF33D20,0xF2E3F9,0xF28AE6,0xF231EA,0xF1D903,0xF18031,0xF12774,
      0xF0CECD,0xF0763B,0xF01DBF,0xEFC557,0xEF6D05,0xEF14C7,0xEEBC9F,0xEE648C,0xEE0C8E,0xEDB4A5,0xED5CD0,
      0xED0511,0xECAD66,0xEC55D0,0xEBFE4F,0xEBA6E3,0xEB4F8B,0xEAF848,0xEAA119,0xEA49FF,0xE9F2FA,0xE99C09,
      0xE9452D,0xE8EE64,0xE897B1,0xE84111,0xE7EA86,0xE79410,0xE73DAD,0xE6E75F,0xE69124,0xE63AFE,0xE5E4EC,
      0xE58EEE,0xE53904,0xE4E32E,0xE48D6C,0xE437BE,0xE3E223,0xE38C9D,0xE3372A,0xE2E1CB,0xE28C80,0xE23748,
      0xE1E224,0xE18D14,0xE13817,0xE0E32E,0xE08E58,0xE03996,0xDFE4E7,0xDF904C,0xDF3BC4,0xDEE74F,0xDE92ED,
      0xDE3E9F,0xDDEA64,0xDD963D,0xDD4228,0xDCEE27,0xDC9A38,0xDC465D,0xDBF295,0xDB9EDF,0xDB4B3D,0xDAF7AD,
      0xDAA431,0xDA50C7,0xD9FD70,0xD9AA2C,0xD956FB,0xD903DC,0xD8B0D0,0xD85DD7,0xD80AF1,0xD7B81C,0xD7655B,
      0xD712AC,0xD6C010,0xD66D86,0xD61B0E,0xD5C8A9,0xD57656,0xD52416,0xD4D1E7,0xD47FCC,0xD42DC2,0xD3DBCA,
      0xD389E5,0xD33812,0xD2E651,0xD294A2,0xD24305,0xD1F17A,0xD1A001,0xD14E9B,0xD0FD46,0xD0AC02,0xD05AD1,
      0xD009B2,0xCFB8A4,0xCF67A8,0xCF16BE,0xCEC5E6,0xCE751F,0xCE246A,0xCDD3C7,0xCD8335,0xCD32B5,0xCCE246,
      0xCC91E9,0xCC419D,0xCBF163,0xCBA13A,0xCB5122,0xCB011C,0xCAB127,0xCA6144,0xCA1171,0xC9C1B0,0xC97200,
      0xC92262,0xC8D2D4,0xC88358,0xC833ED,0xC7E492,0xC79549,0xC74611,0xC6F6EA,0xC6A7D4,0xC658CE,0xC609DA,
      0xC5BAF6,0xC56C23,0xC51D61,0xC4CEB0,0xC48010,0xC43180,0xC3E301,0xC39493,0xC34635,0xC2F7E8,0xC2A9AC,
      0xC25B80,0xC20D64,0xC1BF5A,0xC1715F,0xC12375,0xC0D59C,0xC087D3,0xC03A1A,0xBFEC71,0xBF9ED9,0xBF5151,
      0xBF03DA,0xBEB673,0xBE691B,0xBE1BD5,0xBDCE9E,0xBD8177,0xBD3461,0xBCE75A,0xBC9A64,0xBC4D7D,0xBC00A7,
      0xBBB3E1,0xBB672A,0xBB1A84,0xBACDED,0xBA8166,0xBA34EF,0xB9E888,0xB99C31,0xB94FE9,0xB903B1,0xB8B789,
      0xB86B71,0xB81F68,0xB7D36F,0xB78786,0xB73BAC,0xB6EFE1,0xB6A427,0xB6587B,0xB60CDF,0xB5C153,0xB575D6,
      0xB52A69,0xB4DF0B,0xB493BC,0xB4487D,0xB3FD4D,0xB3B22C,0xB3671A,0xB31C18,0xB2D125,0xB28641,0xB23B6D,
      0xB1F0A7,0xB1A5F1,0xB15B4A,0xB110B1,0xB0C628,0xB07BAE,0xB03143,0xAFE6E7,0xAF9C9A,0xAF525C,0xAF082C,
      0xAEBE0C,0xAE73FA,0xAE29F8,0xADE004,0xAD961F,0xAD4C49,0xAD0281,0xACB8C8,0xAC6F1E,0xAC2583,0xABDBF6,
      0xAB9278,0xAB4908,0xAAFFA7,0xAAB655,0xAA6D11,0xAA23DC,0xA9DAB5,0xA9919C,0xA94893,0xA8FF97,0xA8B6AA,
      0xA86DCB,0xA824FB,0xA7DC39,0xA79386,0xA74AE0,0xA70249,0xA6B9C0,0xA67146,0xA628DA,0xA5E07B,0xA5982B,
      0xA54FEA,0xA507B6,0xA4BF90,0xA47779,0xA42F6F,0xA3E774,0xA39F87,0xA357A7,0xA30FD6,0xA2C812,0xA2805D,
      0xA238B5,0xA1F11B,0xA1A98F,0xA16211,0xA11AA1,0xA0D33F,0xA08BEA,0xA044A4,0x9FFD6A,0x9FB63F,0x9F6F21,
      0x9F2811,0x9EE10F,0x9E9A1B,0x9E5333,0x9E0C5A,0x9DC58E,0x9D7ED0,0x9D381F,0x9CF17C,0x9CAAE6,0x9C645E,
      0x9C1DE3,0x9BD776,0x9B9116,0x9B4AC3,0x9B047E,0x9ABE46,0x9A781C,0x9A31FF,0x99EBEF,0x99A5EC,0x995FF7,
      0x991A0F,0x98D434,0x988E67,0x9848A6,0x9802F3,0x97BD4D,0x9777B4,0x973228,0x96ECA9,0x96A737,0x9661D3,
      0x961C7B,0x95D730,0x9591F3,0x954CC2,0x95079E,0x94C287,0x947D7D,0x943880,0x93F390,0x93AEAD,0x9369D7,
      0x93250D,0x92E050,0x929BA0,0x9256FD,0x921266,0x91CDDD,0x91895F,0x9144EF,0x91008B,0x90BC34,0x9077EA,
      0x9033AC,0x8FEF7B,0x8FAB56,0x8F673E,0x8F2333,0x8EDF34,0x8E9B41,0x8E575B,0x8E1382,0x8DCFB5,0x8D8BF4,
      0x8D4840,0x8D0498,0x8CC0FD,0x8C7D6E,0x8C39EB,0x8BF675,0x8BB30B,0x8B6FAD,0x8B2C5B,0x8AE916,0x8AA5DD,
      0x8A62B0,0x8A1F90,0x89DC7C,0x899973,0x895677,0x891388,0x88D0A4,0x888DCC,0x884B01,0x880841,0x87C58E,
      0x8782E6,0x87404B,0x86FDBC,0x86BB38,0x8678C1,0x863655,0x85F3F6,0x85B1A2,0x856F5B,0x852D1F,0x84EAEF,
      0x84A8CB,0x8466B3,0x8424A6,0x83E2A6,0x83A0B1,0x835EC8,0x831CEA,0x82DB19,0x829953,0x825799,0x8215EA,
      0x81D448,0x8192B0,0x815125,0x810FA5,0x80CE31,0x808CC8,0x804B6B,0x800A1A,0x7FC8D4,0x7F8799,0x7F466A,
      0x7F0547,0x7EC42F,0x7E8322,0x7E4221,0x7E012C,0x7DC041,0x7D7F63,0x7D3E8F,0x7CFDC7,0x7CBD0B,0x7C7C59,
      0x7C3BB3,0x7BFB18,0x7BBA89,0x7B7A05,0x7B398C,0x7AF91E,0x7AB8BC,0x7A7865,0x7A3819,0x79F7D8,0x79B7A2,
      0x797778,0x793759,0x78F744,0x78B73B,0x78773D,0x78374A,0x77F762,0x77B786,0x7777B4,0x7737ED,0x76F831,
      0x76B881,0x7678DB,0x763940,0x75F9B0,0x75BA2B,0x757AB1,0x753B42,0x74FBDE,0x74BC84,0x747D36,0x743DF2,
      0x73FEBA,0x73BF8C,0x738068,0x734150,0x730242,0x72C33F,0x728447,0x72455A,0x720677,0x71C79F,0x7188D2,
      0x714A0F,0x710B57,0x70CCAA,0x708E07,0x704F6F,0x7010E1,0x6FD25E,0x6F93E6,0x6F5578,0x6F1715,0x6ED8BC,
      0x6E9A6E,0x6E5C2B,0x6E1DF1,0x6DDFC3,0x6DA19E,0x6D6385,0x6D2575,0x6CE770,0x6CA976,0x6C6B86,0x6C2DA0,
      0x6BEFC4,0x6BB1F3,0x6B742D,0x6B3670,0x6AF8BE,0x6ABB16,0x6A7D79,0x6A3FE6,0x6A025D,0x69C4DE,0x69876A,
      0x6949FF,0x690C9F,0x68CF49,0x6891FE,0x6854BC,0x681785,0x67DA58,0x679D35,0x67601C,0x67230D,0x66E608,
      0x66A90D,0x666C1D,0x662F36,0x65F25A,0x65B587,0x6578BE,0x653C00,0x64FF4B,0x64C2A1,0x648600,0x644969,
      0x640CDD,0x63D05A,0x6393E1,0x635772,0x631B0D,0x62DEB2,0x62A260,0x626619,0x6229DB,0x61EDA7,0x61B17D,
      0x61755D,0x613946,0x60FD39,0x60C136,0x60853D,0x60494D,0x600D68,0x5FD18C,0x5F95B9,0x5F59F0,0x5F1E31,
      0x5EE27C,0x5EA6D0,0x5E6B2E,0x5E2F96,0x5DF407,0x5DB882,0x5D7D06,0x5D4194,0x5D062B,0x5CCACC,0x5C8F77,
      0x5C542B,0x5C18E8,0x5BDDAF,0x5BA280,0x5B675A,0x5B2C3E,0x5AF12B,0x5AB621,0x5A7B21,0x5A402A,0x5A053D,
      0x59CA59,0x598F7E,0x5954AD,0x5919E5,0x58DF27,0x58A472,0x5869C6,0x582F23,0x57F48A,0x57B9FA,0x577F74,
      0x5744F6,0x570A82,0x56D018,0x5695B6,0x565B5E,0x56210E,0x55E6C8,0x55AC8C,0x557258,0x55382E,0x54FE0C,
      0x54C3F4,0x5489E5,0x544FDF,0x5415E2,0x53DBEF,0x53A204,0x536823,0x532E4A,0x52F47B,0x52BAB5,0x5280F7,
      0x524743,0x520D98,0x51D3F5,0x519A5C,0x5160CC,0x512744,0x50EDC6,0x50B450,0x507AE4,0x504180,0x500826,
      0x4FCED4,0x4F958B,0x4F5C4B,0x4F2314,0x4EE9E6,0x4EB0C0,0x4E77A4,0x4E3E90,0x4E0585,0x4DCC83,0x4D9389,
      0x4D5A99,0x4D21B1,0x4CE8D2,0x4CAFFC,0x4C772E,0x4C3E69,0x4C05AD,0x4BCCFA,0x4B944F,0x4B5BAD,0x4B2314,
      0x4AEA83,0x4AB1FB,0x4A797C,0x4A4105,0x4A0897,0x49D031,0x4997D5,0x495F80,0x492735,0x48EEF2,0x48B6B7,
      0x487E85,0x48465C,0x480E3B,0x47D622,0x479E13,0x47660B,0x472E0C,0x46F616,0x46BE28,0x468643,0x464E66,
      0x461691,0x45DEC5,0x45A701,0x456F46,0x453793,0x44FFE9,0x44C847,0x4490AD,0x44591C,0x442193,0x43EA12,
      0x43B29A,0x437B2A,0x4343C2,0x430C63,0x42D50C,0x429DBD,0x426676,0x422F38,0x41F802,0x41C0D5,0x4189AF,
      0x415292,0x411B7D,0x40E470,0x40AD6B,0x40766F,0x403F7B,0x40088F,0x3FD1AB,0x3F9ACF,0x3F63FB,0x3F2D30,
      0x3EF66D,0x3EBFB1,0x3E88FE,0x3E5253,0x3E1BB0,0x3DE515,0x3DAE83,0x3D77F8,0x3D4175,0x3D0AFA,0x3CD488,
      0x3C9E1D,0x3C67BB,0x3C3160,0x3BFB0E,0x3BC4C3,0x3B8E80,0x3B5846,0x3B2213,0x3AEBE8,0x3AB5C5,0x3A7FAB,
      0x3A4998,0x3A138D,0x39DD89,0x39A78E,0x39719B,0x393BAF,0x3905CC,0x38CFF0,0x389A1C,0x386450,0x382E8C,
      0x37F8CF,0x37C31B,0x378D6E,0x3757C9,0x37222C,0x36EC96,0x36B709,0x368183,0x364C05,0x36168E,0x35E11F,
      0x35ABB9,0x357659,0x354102,0x350BB2,0x34D66A,0x34A129,0x346BF1,0x3436C0,0x340196,0x33CC74,0x33975A,
      0x336248,0x332D3D,0x32F839,0x32C33E,0x328E4A,0x32595D,0x322478,0x31EF9B,0x31BAC5,0x3185F7,0x315130,
      0x311C71,0x30E7B9,0x30B309,0x307E61,0x3049C0,0x301526,0x2FE094,0x2FAC09,0x2F7786,0x2F430A,0x2F0E96,
      0x2EDA29,0x2EA5C4,0x2E7166,0x2E3D0F,0x2E08C0,0x2DD479,0x2DA038,0x2D6BFF,0x2D37CE,0x2D03A4,0x2CCF81,
      0x2C9B66,0x2C6751,0x2C3345,0x2BFF3F,0x2BCB41,0x2B974A,0x2B635B,0x2B2F73,0x2AFB92,0x2AC7B8,0x2A93E6,
      0x2A601B,0x2A2C57,0x29F89B,0x29C4E5,0x299137,0x295D90,0x2929F1,0x28F658,0x28C2C7,0x288F3D,0x285BBA,
      0x28283F,0x27F4CA,0x27C15D,0x278DF7,0x275A98,0x272740,0x26F3EF,0x26C0A6,0x268D63,0x265A28,0x2626F4,
      0x25F3C6,0x25C0A0,0x258D81,0x255A69,0x252758,0x24F44F,0x24C14C,0x248E50,0x245B5C,0x24286E,0x23F587,
      0x23C2A8,0x238FCF,0x235CFD,0x232A33,0x22F76F,0x22C4B2,0x2291FD,0x225F4E,0x222CA6,0x21FA05,0x21C76B,
      0x2194D8,0x21624C,0x212FC7,0x20FD49,0x20CAD1,0x209861,0x2065F7,0x203395,0x200139,0x1FCEE4,0x1F9C96,
      0x1F6A4F,0x1F380E,0x1F05D5,0x1ED3A2,0x1EA176,0x1E6F51,0x1E3D32,0x1E0B1B,0x1DD90A,0x1DA700,0x1D74FD,
      0x1D4301,0x1D110B,0x1CDF1C,0x1CAD34,0x1C7B53,0x1C4978,0x1C17A4,0x1BE5D7,0x1BB410,0x1B8250,0x1B5097,
      0x1B1EE5,0x1AED39,0x1ABB94,0x1A89F6,0x1A585E,0x1A26CD,0x19F542,0x19C3BF,0x199241,0x1960CB,0x192F5B,
      0x18FDF2,0x18CC8F,0x189B33,0x1869DE,0x18388F,0x180746,0x17D605,0x17A4C9,0x177395,0x174267,0x17113F,
      0x16E01E,0x16AF04,0x167DF0,0x164CE2,0x161BDC,0x15EADB,0x15B9E1,0x1588EE,0x155801,0x15271A,0x14F63A,
      0x14C561,0x14948E,0x1463C1,0x1432FB,0x14023B,0x13D182,0x13A0CF,0x137023,0x133F7D,0x130EDD,0x12DE44,
      0x12ADB1,0x127D25,0x124C9F,0x121C1F,0x11EBA6,0x11BB33,0x118AC6,0x115A60,0x112A00,0x10F9A6,0x10C953,
      0x109906,0x1068BF,0x10387F,0x100845,0xFD811,0xFA7E4,0xF77BD,0xF479C,0xF1781,0xEE76D,0xEB75F,
      0xE8757,0xE5755,0xE275A,0xDF765,0xDC776,0xD978D,0xD67AA,0xD37CE,0xD07F8,0xCD828,0xCA85E,
      0xC789B,0xC48DD,0xC1926,0xBE975,0xBB9CA,0xB8A26,0xB5A87,0xB2AEF,0xAFB5C,0xACBD0,0xA9C4A,
      0xA6CCA,0xA3D50,0xA0DDC,0x9DE6F,0x9AF07,0x97FA6,0x9504A,0x920F5,0x8F1A6,0x8C25C,0x89319,
      0x863DC,0x834A5,0x80574,0x7D649,0x7A724,0x77805,0x748EC,0x719D9,0x6EACC,0x6BBC5,0x68CC4,
      0x65DC9,0x62ED4,0x5FFE5,0x5D0FC,0x5A218,0x5733B,0x54464,0x51593,0x4E6C7,0x4B802,0x48942,
      0x45A88,0x42BD5,0x3FD27,0x3CE7F,0x39FDD,0x37141,0x342AA,0x3141A,0x2E58F,0x2B70B,0x2888C,
      0x25A13,0x22BA0,0x1FD33,0x1CECB,0x1A069,0x1720E,0x143B8,0x11567,0xE71D,0xB8D8,0x8A9A,
      0x5C61,0x2E2D
   };
   
#define LZHAM_CREATE_PROB_COST_TABLE 0

#if LZHAM_CREATE_PROB_COST_TABLE
	class arith_prob_cost_initializer
	{
	public:
		arith_prob_cost_initializer()
		{
			const double cInvLn2 = 1.4426950408889634073599246810019; // 1.0/ln(2)

			for (uint i = 0; i < cSymbolCodecArithProbScale; i++)
			{
            double flBits = i ? (-log(i * (1.0 / cSymbolCodecArithProbScale)) * cInvLn2) : 0;
				g_prob_cost[i] = static_cast<uint32>(floor(.5f + flBits * cBitCostScale));
            printf("0x%X,", g_prob_cost[i]);
            if ((i % 11) == 10) printf("\n");
			}
         printf("\n");
		}
	};
   static arith_prob_cost_initializer g_prob_cost_initializer;
#endif

   quasi_adaptive_huffman_data_model::quasi_adaptive_huffman_data_model(lzham_malloc_context malloc_context, bool encoding, uint total_syms, uint max_update_interval, uint adapt_rate) :
      m_malloc_context(malloc_context),
      m_initial_sym_freq(malloc_context),
      m_sym_freq(malloc_context),
      m_codes(malloc_context),
      m_code_sizes(malloc_context),
      m_pDecode_tables(NULL),
      m_total_syms(0),
      m_max_cycle(0),
      m_update_cycle(0),
      m_symbols_until_update(0),
      m_total_count(0),
      m_decoder_table_bits(0),
      m_max_update_interval(static_cast<uint16>(max_update_interval)),
      m_adapt_rate(static_cast<uint16>(adapt_rate)),
      m_encoding(encoding)
   {
      if (total_syms)
      {
         init2(malloc_context, encoding, total_syms, max_update_interval, adapt_rate, NULL);
      }
   }

   quasi_adaptive_huffman_data_model::quasi_adaptive_huffman_data_model(const quasi_adaptive_huffman_data_model& other) :
      m_malloc_context(other.m_malloc_context),
      m_initial_sym_freq(other.m_malloc_context),
      m_sym_freq(other.m_malloc_context),
      m_codes(other.m_malloc_context),
      m_code_sizes(other.m_malloc_context),
      m_pDecode_tables(NULL),
      m_total_syms(0),
      m_max_cycle(0),
      m_update_cycle(0),
      m_symbols_until_update(0),
      m_total_count(0),
      m_decoder_table_bits(0),
      m_max_update_interval(0),
      m_adapt_rate(0),
      m_encoding(false)
   {
      *this = other;
   }

   quasi_adaptive_huffman_data_model::~quasi_adaptive_huffman_data_model()
   {
      if (m_pDecode_tables)
         lzham_delete(m_malloc_context, m_pDecode_tables);
   }

   bool quasi_adaptive_huffman_data_model::assign(const quasi_adaptive_huffman_data_model& rhs)
   {
      if (this == &rhs)
         return true;

      if (m_malloc_context != rhs.m_malloc_context)
      {
         clear();

         m_malloc_context = rhs.m_malloc_context;

         m_initial_sym_freq.set_malloc_context(m_malloc_context);
         m_sym_freq.set_malloc_context(m_malloc_context);
         m_codes.set_malloc_context(m_malloc_context);
         m_code_sizes.set_malloc_context(m_malloc_context);
      }

      m_total_syms = rhs.m_total_syms;

      m_max_cycle = rhs.m_max_cycle;
      m_update_cycle = rhs.m_update_cycle;
      m_symbols_until_update = rhs.m_symbols_until_update;

      m_total_count = rhs.m_total_count;

      m_sym_freq = rhs.m_sym_freq;
      m_initial_sym_freq = rhs.m_initial_sym_freq;

      m_codes = rhs.m_codes;
      m_code_sizes = rhs.m_code_sizes;

      if (rhs.m_pDecode_tables)
      {
         if (m_pDecode_tables)
         {
            if (!m_pDecode_tables->assign(*rhs.m_pDecode_tables))
            {
               clear();
               return false;
            }
         }
         else
         {
            m_pDecode_tables = lzham_new<prefix_coding::decoder_tables>(m_malloc_context, *rhs.m_pDecode_tables);
            if (!m_pDecode_tables)
            {
               clear();
               LZHAM_LOG_ERROR(4000);
               return false;
            }
         }
      }
      else if (m_pDecode_tables)
      {
         lzham_delete(m_malloc_context, m_pDecode_tables);
         m_pDecode_tables = NULL;
      }

      m_decoder_table_bits = rhs.m_decoder_table_bits;
      m_encoding = rhs.m_encoding;
      m_max_update_interval = rhs.m_max_update_interval;
      m_adapt_rate = rhs.m_adapt_rate;

      return true;
   }

   quasi_adaptive_huffman_data_model& quasi_adaptive_huffman_data_model::operator= (const quasi_adaptive_huffman_data_model& rhs)
   {
      assign(rhs);
      return *this;
   }

   void quasi_adaptive_huffman_data_model::clear()
   {
      m_sym_freq.clear();
      m_initial_sym_freq.clear();
      m_codes.clear();
      m_code_sizes.clear();

      m_max_cycle = 0;
      m_total_syms = 0;
      m_update_cycle = 0;
      m_symbols_until_update = 0;
      m_decoder_table_bits = 0;
      m_total_count = 0;

      if (m_pDecode_tables)
      {
         lzham_delete(m_malloc_context, m_pDecode_tables);
         m_pDecode_tables = NULL;
      }

      m_max_update_interval = 0;
      m_adapt_rate = 0;
   }

   bool quasi_adaptive_huffman_data_model::init2(lzham_malloc_context malloc_context, bool encoding, uint total_syms, uint max_update_interval, uint adapt_rate, const uint16 *pInitial_sym_freq)
   {
      LZHAM_ASSERT(max_update_interval <= 0xFFFF);
      LZHAM_ASSERT(adapt_rate <= 0xFFFF);

      if (malloc_context != m_malloc_context)
      {
         clear();

         m_malloc_context = malloc_context;

         m_initial_sym_freq.set_malloc_context(m_malloc_context);
         m_sym_freq.set_malloc_context(m_malloc_context);
         m_codes.set_malloc_context(m_malloc_context);
         m_code_sizes.set_malloc_context(m_malloc_context);
      }

      m_encoding = encoding;
      m_max_update_interval = static_cast<uint16>(max_update_interval);
      m_adapt_rate = static_cast<uint16>(adapt_rate);
      m_symbols_until_update = 0;

      if (!m_sym_freq.try_resize(total_syms))
      {
         clear();
         LZHAM_LOG_ERROR(4001);
         return false;
      }
      
      if (pInitial_sym_freq)
      {
         if (!m_initial_sym_freq.try_resize(total_syms))
         {
            clear();
            LZHAM_LOG_ERROR(4002);
            return false;
         }
         memcpy(m_initial_sym_freq.begin(), pInitial_sym_freq, total_syms * m_initial_sym_freq.size_in_bytes());
      }

      if (!m_code_sizes.try_resize(total_syms))
      {
         clear();
         LZHAM_LOG_ERROR(4003);
         return false;
      }

      m_total_syms = total_syms;
      
      uint max_table_bits = 0;

      if (m_total_syms <= 8)
         max_table_bits = 4;
      else
         max_table_bits = 1 + math::ceil_log2i(m_total_syms);

      m_decoder_table_bits = static_cast<uint8>(math::minimum(max_table_bits, prefix_coding::cMaxTableBits));
      
      if (m_encoding)
      {
         lzham_delete(m_malloc_context, m_pDecode_tables);
         m_pDecode_tables = NULL;

         if (!m_codes.try_resize(total_syms))
         {
            clear();
            LZHAM_LOG_ERROR(4004);
            return false;
         }
      }
      else if (!m_pDecode_tables)
      {
         m_pDecode_tables = lzham_new<prefix_coding::decoder_tables>(m_malloc_context, m_malloc_context);
         if (!m_pDecode_tables)
         {
            clear();
            LZHAM_LOG_ERROR(4005);
            return false;
         }
      }

      m_max_cycle = (LZHAM_MAX(24, m_total_syms) + 6) * (m_max_update_interval ? m_max_update_interval : LZHAM_DEFAULT_MAX_UPDATE_INTERVAL);

      m_max_cycle = LZHAM_MIN(m_max_cycle, 32767);

      reset();

      return true;
   }

   bool quasi_adaptive_huffman_data_model::reset()
   {
      if (!m_total_syms)
         return true;

      bool sym_freq_all_ones = false;

      if (m_initial_sym_freq.size())
      {
         m_update_cycle = 0;
         for (uint i = 0; i < m_total_syms; i++)
         {
            uint sym_freq = m_initial_sym_freq[i];
            m_sym_freq[i] = static_cast<uint16>(sym_freq);
            
            // Slam m_update_cycle to a specific value so update_tables() sets m_total_count to the proper value
            m_update_cycle += sym_freq;
         }
      }
      else
      {
#if LZHAM_LITTLE_ENDIAN_CPU         
         // &m_sym_freq[0] should be aligned to at least 8 bytes due to LZHAM_MIN_ALLOC_ALIGNMENT
         uint64 x = 0x0001000100010001ULL;
         x = (x << 32U) | x;

         uint64 *p = reinterpret_cast<uint64 *>(&m_sym_freq[0]);

         for (uint64 *q = p + ((m_total_syms >> 3) * 2); p != q; p += 2)
         {
            p[0] = x;
            p[1] = x;
         }

         uint16 *r = reinterpret_cast<uint16 *>(p);
         for (uint i = (m_total_syms & 7); i; --i)
            *r++ = 1;

#ifdef LZHAM_BUILD_DEBUG
         for (uint i = 0; i < m_total_syms; i++)
         {
            LZHAM_ASSERT(m_sym_freq[i] == 1);
         }
#endif

#else
         for (uint i = 0; i < m_total_syms; i++)
            m_sym_freq[i] = 1;
#endif

         // Slam m_update_cycle to a specific value so update_tables() sets m_total_count to the proper value
         m_update_cycle = m_total_syms;
         
         sym_freq_all_ones = true;
      }

      m_total_count = 0;
      m_symbols_until_update = 0;
            
      if (!update_tables(LZHAM_MIN(m_max_cycle, 16), sym_freq_all_ones)) // this was 8 in the alphas
      {
         LZHAM_LOG_ERROR(4006);
         return false;
      }
                                 
      return true;
   }

   void quasi_adaptive_huffman_data_model::rescale()
   {
      uint total_freq = 0;

      for (uint i = 0; i < m_total_syms; i++)
      {
         uint freq = (m_sym_freq[i] + 1) >> 1;
         total_freq += freq;
         m_sym_freq[i] = static_cast<uint16>(freq);
      }

      m_total_count = total_freq;
   }

   void quasi_adaptive_huffman_data_model::reset_update_rate()
   {
      m_total_count += (m_update_cycle - m_symbols_until_update);

#ifdef LZHAM_BUILD_DEBUG
      uint actual_total = 0;
      for (uint i = 0; i < m_sym_freq.size(); i++)
         actual_total += m_sym_freq[i];
      LZHAM_ASSERT(actual_total == m_total_count);
#endif

      if (m_total_count > m_total_syms)
         rescale();

      m_symbols_until_update = m_update_cycle = LZHAM_MIN(8, m_update_cycle);
   }
      
   bool quasi_adaptive_huffman_data_model::update_tables(int force_update_cycle, bool sym_freq_all_ones)
   {
      LZHAM_ASSERT(!m_symbols_until_update);
      m_total_count += m_update_cycle;
      LZHAM_ASSERT(m_total_count <= 65535);

      while (m_total_count >= 32768)
         rescale();

      uint max_code_size = 0;

      code_size_histogram code_size_hist;
      code_size_hist.clear();
      
      if ((sym_freq_all_ones) && (m_total_syms >= 2))
      {
         // Shortcut building the Huffman codes if we know all the sym freqs are 1.
         uint base_code_size = math::floor_log2i(m_total_syms);
         uint num_left = m_total_syms - (1 << base_code_size);
         num_left *= 2;
         if (num_left > m_total_syms)
            num_left = m_total_syms;

         memset(&m_code_sizes[0], base_code_size + 1, num_left);
         memset(&m_code_sizes[num_left], base_code_size, m_total_syms - num_left);  
         
         code_size_hist.init(base_code_size, m_total_syms - num_left, base_code_size + 1, num_left);
            
         max_code_size = base_code_size + (num_left ? 1 : 0);
      }

      bool status = false;
      if (!max_code_size)
      {
         uint table_size = get_generate_huffman_codes_table_size();
         void *pTables = alloca(table_size);

         uint total_freq = 0;                  
         status = generate_huffman_codes(pTables, m_total_syms, &m_sym_freq[0], &m_code_sizes[0], max_code_size, total_freq, code_size_hist);
         LZHAM_ASSERT(status);
         LZHAM_ASSERT(total_freq == m_total_count);
         if ((!status) || (total_freq != m_total_count))
         {
            LZHAM_LOG_ERROR(4007);
            return false;
         }

         if (max_code_size > cMaxExpectedHuffCodeSize)
         {
            status = prefix_coding::limit_max_code_size(m_total_syms, &m_code_sizes[0], cMaxExpectedHuffCodeSize);
            LZHAM_ASSERT(status);
            if (!status)
            {
               LZHAM_LOG_ERROR(4008);
               return false;
            }
               
            code_size_hist.clear();
            code_size_hist.init(m_total_syms, &m_code_sizes[0]);

            for (max_code_size = cMaxExpectedHuffCodeSize; max_code_size >= 1; max_code_size--)
               if (code_size_hist.m_num_codes[max_code_size])
                  break;
         }
      }

#ifdef LZHAM_BUILD_DEBUG
{
      uint check_max_code_size = 0;
      uint check_total_syms[cMaxExpectedHuffCodeSize + 1];
      utils::zero_object(check_total_syms);
      for (uint i = 0; i < m_total_syms; i++)
      {
         uint code_size = m_code_sizes[i];
         check_max_code_size = math::maximum(check_max_code_size, code_size);
         check_total_syms[code_size]++;
      }
      LZHAM_ASSERT(max_code_size == check_max_code_size);
      for (uint i = 0; i < (cMaxExpectedHuffCodeSize + 1); i++)
      {
         LZHAM_ASSERT(code_size_hist.m_num_codes[i] == check_total_syms[i]);
      }
}
#endif

      if (force_update_cycle >= 0)
         m_symbols_until_update = m_update_cycle = force_update_cycle;
      else
      {
         m_update_cycle = (31U + m_update_cycle * LZHAM_MAX(32U, (m_adapt_rate ? m_adapt_rate : LZHAM_DEFAULT_ADAPT_RATE))) >> 5U;

         if (m_update_cycle > m_max_cycle)
            m_update_cycle = m_max_cycle;

         m_symbols_until_update = m_update_cycle;
      }
            
      if (m_encoding)
         status = prefix_coding::generate_codes(m_total_syms, &m_code_sizes[0], &m_codes[0]);
      else
      {
         uint actual_table_bits = m_decoder_table_bits;

         // Try to see if using the accel table is actually worth the trouble of constructing it.
         uint cost_to_use_table = (1 << actual_table_bits) + 64;
         uint cost_to_not_use_table = m_symbols_until_update * math::floor_log2i(m_total_syms);
         if (cost_to_not_use_table <= cost_to_use_table)
            actual_table_bits = 0;

         status = prefix_coding::generate_decoder_tables(m_total_syms, &m_code_sizes[0], m_pDecode_tables, actual_table_bits, code_size_hist, sym_freq_all_ones);
      }

      LZHAM_ASSERT(status);
      if (!status)
      {
         LZHAM_LOG_ERROR(4009);
         return false;
      }
               
      return true;
   }

   bool quasi_adaptive_huffman_data_model::update_sym(uint sym)
   {
      uint freq = m_sym_freq[sym];
      freq++;
      m_sym_freq[sym] = static_cast<uint16>(freq);

      LZHAM_ASSERT(freq <= cUINT16_MAX);

      if (--m_symbols_until_update == 0)
      {
         if (!update_tables())
         {
            LZHAM_LOG_ERROR(4010);
            return false;
         }
      }

      return true;
   }
	   
   adaptive_bit_model::adaptive_bit_model(float prob0)
   {
      set_probability_0(prob0);
   }

   adaptive_bit_model::adaptive_bit_model(const adaptive_bit_model& other) :
      m_bit_0_prob(other.m_bit_0_prob)
   {
   }
      
   void adaptive_bit_model::set_probability_0(float prob0)
   {
      m_bit_0_prob = static_cast<uint16>(math::clamp<uint>((uint)(prob0 * cSymbolCodecArithProbScale), 1, cSymbolCodecArithProbScale - 1));
   }
      
   symbol_codec::symbol_codec(lzham_malloc_context malloc_context) :
      m_malloc_context(malloc_context),
      m_output_buf(malloc_context),
      m_arith_output_buf(malloc_context),
      m_output_syms(malloc_context)
   {
      clear();
   }
   
   void symbol_codec::reset()
   {
      m_pDecode_buf = NULL;
      m_pDecode_buf_next = NULL;
      m_pDecode_buf_end = NULL;
      m_decode_buf_size = 0;

      m_bit_buf = 0;
      m_bit_count = 0;
      m_total_model_updates = 0;
      m_mode = cNull;
      m_total_bits_written = 0;

      m_arith_base = 0;
      m_arith_value = 0;
      m_arith_length = 0;
      m_arith_total_bits = 0;

      m_output_buf.try_resize(0);
      m_arith_output_buf.try_resize(0);
      m_output_syms.try_resize(0);

      m_pDecode_need_bytes_func = NULL;
      m_pDecode_private_data = NULL;
      m_pSaved_huff_model = NULL;
      m_pSaved_model = NULL;
      m_saved_node_index = 0;
   }

   void symbol_codec::clear()
   {
      reset();

      m_output_buf.clear();
      m_arith_output_buf.clear();
      m_output_syms.clear();
   }

   bool symbol_codec::start_encoding(uint expected_file_size)
   {
      m_mode = cEncoding;

      m_total_model_updates = 0;
      m_total_bits_written = 0;

      if (!put_bits_init(expected_file_size))
         return false;

      m_output_syms.try_resize(0);

      arith_start_encoding();

      return true;
   }

   bool symbol_codec::encode_bits(uint bits, uint num_bits)
   {
      LZHAM_ASSERT(m_mode == cEncoding);

      if (!num_bits)
         return true;

      LZHAM_ASSERT((num_bits == 32) || (bits <= ((1U << num_bits) - 1)));

      if (num_bits > 16)
      {
         if (!record_put_bits(bits >> 16, num_bits - 16))
         {
            LZHAM_LOG_ERROR(4011);
            return false;
         }
         if (!record_put_bits(bits & 0xFFFF, 16))
         {
            LZHAM_LOG_ERROR(4012);
            return false;
         }
      }
      else
      {
         if (!record_put_bits(bits, num_bits))
         {
            LZHAM_LOG_ERROR(4013);
            return false;
         }
      }
      return true;
   }

   bool symbol_codec::encode_arith_init()
   {
      LZHAM_ASSERT(m_mode == cEncoding);

      output_symbol sym;
      sym.m_bits = 0;
      sym.m_num_bits = output_symbol::cArithInit;
      sym.m_arith_prob0 = 0;
      if (!m_output_syms.try_push_back(sym))
      {
         LZHAM_LOG_ERROR(4014);
         return false;
      }

      return true;
   }

   bool symbol_codec::encode_align_to_byte()
   {
      LZHAM_ASSERT(m_mode == cEncoding);

      output_symbol sym;
      sym.m_bits = 0;
      sym.m_num_bits = output_symbol::cAlignToByteSym;
      sym.m_arith_prob0 = 0;
      if (!m_output_syms.try_push_back(sym))
      {
         LZHAM_LOG_ERROR(4015);
         return false;
      }

      return true;
   }

   bool symbol_codec::encode(uint sym, quasi_adaptive_huffman_data_model& model)
   {
      LZHAM_ASSERT(m_mode == cEncoding);
      LZHAM_ASSERT(model.m_encoding);

      if (!record_put_bits(model.m_codes[sym], model.m_code_sizes[sym]))
      {
         LZHAM_LOG_ERROR(4016);
         return false;
      }

      uint freq = model.m_sym_freq[sym];
      freq++;
      model.m_sym_freq[sym] = static_cast<uint16>(freq);
      
      LZHAM_ASSERT(freq <= cUINT16_MAX);

      if (--model.m_symbols_until_update == 0)
      {
         m_total_model_updates++;
         if (!model.update_tables())
         {
            LZHAM_LOG_ERROR(4018);
            return false;
         }
      }
      return true;
   }

   void symbol_codec::arith_propagate_carry()
   {
      int index = m_arith_output_buf.size() - 1;
      while (index >= 0)
      {
         uint c = m_arith_output_buf[index];

         if (c == 0xFF)
            m_arith_output_buf[index] = 0;
         else
         {
            m_arith_output_buf[index]++;
            break;
         }

         index--;
      }
   }

   bool symbol_codec::arith_renorm_enc_interval()
   {
      do
      {
         if (!m_arith_output_buf.try_push_back((m_arith_base >> 24) & 0xFF))
            return false;
         m_total_bits_written += 8;

         m_arith_base <<= 8;
      } while ((m_arith_length <<= 8) < cSymbolCodecArithMinLen);
      return true;
   }

   void symbol_codec::arith_start_encoding()
   {
      m_arith_output_buf.try_resize(0);

      m_arith_base = 0;
      m_arith_value = 0;
      m_arith_length = cSymbolCodecArithMaxLen;
      m_arith_total_bits = 0;
   }

   bool symbol_codec::encode(uint bit, adaptive_bit_model& model, bool update_model)
   {
      LZHAM_ASSERT(m_mode == cEncoding);

      m_arith_total_bits++;

      output_symbol sym;
      sym.m_bits = bit;
      sym.m_num_bits = -1;
      sym.m_arith_prob0 = model.m_bit_0_prob;
      if (!m_output_syms.try_push_back(sym))
      {
         LZHAM_LOG_ERROR(4019);
         return false;
      }

      uint x = model.m_bit_0_prob * (m_arith_length >> cSymbolCodecArithProbBits);

      if (!bit)
      {
         if (update_model)
            model.m_bit_0_prob += ((cSymbolCodecArithProbScale - model.m_bit_0_prob) >> cSymbolCodecArithProbMoveBits);

         m_arith_length = x;
      }
      else
      {
         if (update_model)
            model.m_bit_0_prob -= (model.m_bit_0_prob >> cSymbolCodecArithProbMoveBits);

         uint orig_base = m_arith_base;
         m_arith_base   += x;
         m_arith_length -= x;
         if (orig_base > m_arith_base)
            arith_propagate_carry();
      }

      if (m_arith_length < cSymbolCodecArithMinLen)
      {
         if (!arith_renorm_enc_interval())
         {
            LZHAM_LOG_ERROR(4020);
            return false;
         }
      }

      return true;
   }
      
   bool symbol_codec::arith_stop_encoding()
   {
      uint orig_base = m_arith_base;

      if (m_arith_length > 2 * cSymbolCodecArithMinLen)
      {
         m_arith_base  += cSymbolCodecArithMinLen;
         m_arith_length = (cSymbolCodecArithMinLen >> 1);
      }
      else
      {
         m_arith_base  += (cSymbolCodecArithMinLen >> 1);
         m_arith_length = (cSymbolCodecArithMinLen >> 9);
      }

      if (orig_base > m_arith_base)
         arith_propagate_carry();

      if (!arith_renorm_enc_interval())
      {
         LZHAM_LOG_ERROR(4021);
         return false;
      }

      while (m_arith_output_buf.size() < 4)
      {
         if (!m_arith_output_buf.try_push_back(0))
         {
            LZHAM_LOG_ERROR(4022);
            return false;
         }
         m_total_bits_written += 8;
      }
      return true;
   }

   bool symbol_codec::stop_encoding(bool support_arith)
   {
      LZHAM_ASSERT(m_mode == cEncoding);

      if (support_arith)
      {
         if (!arith_stop_encoding())
            return false;
      }

      if (!assemble_output_buf())
         return false;

      m_mode = cNull;
      return true;
   }

   bool symbol_codec::record_put_bits(uint bits, uint num_bits)
   {
      LZHAM_ASSERT(m_mode == cEncoding);

      LZHAM_ASSERT(num_bits <= 25);
      LZHAM_ASSERT(m_bit_count >= 25);

      if (!num_bits)
         return true;

      m_total_bits_written += num_bits;

      output_symbol sym;
      sym.m_bits = bits;
      sym.m_num_bits = (uint16)num_bits;
      sym.m_arith_prob0 = 0;
      if (!m_output_syms.try_push_back(sym))
      {
         LZHAM_LOG_ERROR(4023);
         return false;
      }

      return true;
   }

   bool symbol_codec::put_bits_init(uint expected_size)
   {
      m_bit_buf = 0;
      m_bit_count = cBitBufSize;

      m_output_buf.try_resize(0);
      if (!m_output_buf.try_reserve(expected_size))
      {
         LZHAM_LOG_ERROR(4024);
         return false;
      }

      return true;
   }

   bool symbol_codec::put_bits(uint bits, uint num_bits)
   {
      LZHAM_ASSERT(num_bits <= 25);
      LZHAM_ASSERT(m_bit_count >= 25);

      if (!num_bits)
         return true;

      m_bit_count -= num_bits;
      m_bit_buf |= (static_cast<bit_buf_t>(bits) << m_bit_count);

      m_total_bits_written += num_bits;

      while (m_bit_count <= (cBitBufSize - 8))
      {
         if (!m_output_buf.try_push_back(static_cast<uint8>(m_bit_buf >> (cBitBufSize - 8))))
            return false;

         m_bit_buf <<= 8;
         m_bit_count += 8;
      }

      return true;
   }

   bool symbol_codec::put_bits_align_to_byte()
   {
      uint num_bits_in = cBitBufSize - m_bit_count;
      if (num_bits_in & 7)
      {
         if (!put_bits(0, 8 - (num_bits_in & 7)))
         {
            LZHAM_LOG_ERROR(4025);
            return false;
         }
      }
      return true;
   }

   bool symbol_codec::flush_bits()
   {
      return put_bits(0, 7); // to ensure the last bits are flushed
   }

   bool symbol_codec::assemble_output_buf()
   {
      m_total_bits_written = 0;

      uint arith_buf_ofs = 0;

      // Intermix the final Arithmetic, Huffman, or plain bits to a single combined bitstream.
      // All bits from each source must be output in exactly the same order that the decompressor will read them.
      for (uint sym_index = 0; sym_index < m_output_syms.size(); sym_index++)
      {
         const output_symbol& sym = m_output_syms[sym_index];

         if (sym.m_num_bits == output_symbol::cAlignToByteSym)
         {
            if (!put_bits_align_to_byte())
            {
               LZHAM_LOG_ERROR(4026);
               return false;
            }
         }
         else if (sym.m_num_bits == output_symbol::cArithInit)
         {
            LZHAM_ASSERT(m_arith_output_buf.size());

            if (m_arith_output_buf.size())
            {
               m_arith_length = cSymbolCodecArithMaxLen;
               m_arith_value = 0;
               for (uint i = 0; i < 4; i++)
               {
                  const uint c = m_arith_output_buf[arith_buf_ofs++];
                  m_arith_value = (m_arith_value << 8) | c;
                  if (!put_bits(c, 8))
                  {
                     LZHAM_LOG_ERROR(4027);
                     return false;
                  }
               }
            }
         }
         else if (sym.m_num_bits == output_symbol::cArithSym)
         {
            // This renorm logic must match the logic used in the arithmetic decoder.
            if (m_arith_length < cSymbolCodecArithMinLen)
            {
               do
               {
                  const uint c = (arith_buf_ofs < m_arith_output_buf.size()) ? m_arith_output_buf[arith_buf_ofs++] : 0;
                  if (!put_bits(c, 8))
                  {
                     LZHAM_LOG_ERROR(4028);
                     return false;
                  }
                  m_arith_value = (m_arith_value << 8) | c;
               } while ((m_arith_length <<= 8) < cSymbolCodecArithMinLen);
            }

            uint x = sym.m_arith_prob0 * (m_arith_length >> cSymbolCodecArithProbBits);
            uint bit = (m_arith_value >= x);

            if (bit == 0)
            {
               m_arith_length = x;
            }
            else
            {
               m_arith_value  -= x;
               m_arith_length -= x;
            }

            LZHAM_VERIFY(bit == sym.m_bits);
         }
         else
         {
            // Huffman or plain bits
            if (!put_bits(sym.m_bits, sym.m_num_bits))
            {
               LZHAM_LOG_ERROR(4029);
               return false;
            }
         }
      }

      return flush_bits();
   }

   //------------------------------------------------------------------------------------------------------------------
   // Decoding
   //------------------------------------------------------------------------------------------------------------------

   bool symbol_codec::start_decoding(const uint8* pBuf, size_t buf_size, bool eof_flag, need_bytes_func_ptr pNeed_bytes_func, void *pPrivate_data)
   {
      if (!buf_size)
      {
         LZHAM_LOG_ERROR(4030);
         return false;
      }

      m_total_model_updates = 0;

      m_pDecode_buf = pBuf;
      m_pDecode_buf_next = pBuf;
      m_decode_buf_size = buf_size;
      m_pDecode_buf_end = pBuf + buf_size;

      m_pDecode_need_bytes_func = pNeed_bytes_func;
      m_pDecode_private_data = pPrivate_data;
      m_decode_buf_eof = eof_flag;

      m_bit_buf = 0;
      m_bit_count = 0;

      m_mode = cDecoding;

      return true;
   }

   uint symbol_codec::decode_bits(uint num_bits)
   {
      LZHAM_ASSERT(m_mode == cDecoding);

      if (!num_bits)
         return 0;

      if (num_bits > 16)
      {
         uint a = get_bits(num_bits - 16);
         uint b = get_bits(16);

         return (a << 16) | b;
      }
      else
         return get_bits(num_bits);
   }

   void symbol_codec::decode_remove_bits(uint num_bits)
   {
      LZHAM_ASSERT(m_mode == cDecoding);

      while (num_bits > 16)
      {
         remove_bits(16);
         num_bits -= 16;
      }

      remove_bits(num_bits);
   }

   uint symbol_codec::decode_peek_bits(uint num_bits)
   {
      LZHAM_ASSERT(m_mode == cDecoding);
      LZHAM_ASSERT(num_bits <= 25);

      if (!num_bits)
         return 0;

      while (m_bit_count < (int)num_bits)
      {
         uint c = 0;
         if (m_pDecode_buf_next == m_pDecode_buf_end)
         {
            if (!m_decode_buf_eof)
            {
               m_pDecode_need_bytes_func(m_pDecode_buf_next - m_pDecode_buf, m_pDecode_private_data, m_pDecode_buf, m_decode_buf_size, m_decode_buf_eof);
               m_pDecode_buf_end = m_pDecode_buf + m_decode_buf_size;
               m_pDecode_buf_next = m_pDecode_buf;
               if (m_pDecode_buf_next < m_pDecode_buf_end) c = *m_pDecode_buf_next++;
            }
         }
         else
            c = *m_pDecode_buf_next++;

         m_bit_count += 8;
         LZHAM_ASSERT(m_bit_count <= cBitBufSize);

         m_bit_buf |= (static_cast<bit_buf_t>(c) << (cBitBufSize - m_bit_count));
      }

      return static_cast<uint>(m_bit_buf >> (cBitBufSize - num_bits));
   }

   uint symbol_codec::decode(quasi_adaptive_huffman_data_model& model)
   {
      LZHAM_ASSERT(m_mode == cDecoding);
      LZHAM_ASSERT(!model.m_encoding);

      const prefix_coding::decoder_tables* pTables = model.m_pDecode_tables;

      while (m_bit_count < (cBitBufSize - 8))
      {
         uint c = 0;
         if (m_pDecode_buf_next == m_pDecode_buf_end)
         {
            if (!m_decode_buf_eof)
            {
               m_pDecode_need_bytes_func(m_pDecode_buf_next - m_pDecode_buf, m_pDecode_private_data, m_pDecode_buf, m_decode_buf_size, m_decode_buf_eof);
               m_pDecode_buf_end = m_pDecode_buf + m_decode_buf_size;
               m_pDecode_buf_next = m_pDecode_buf;
               if (m_pDecode_buf_next < m_pDecode_buf_end) c = *m_pDecode_buf_next++;
            }
         }
         else
            c = *m_pDecode_buf_next++;

         m_bit_count += 8;
         m_bit_buf |= (static_cast<bit_buf_t>(c) << (cBitBufSize - m_bit_count));
      }

      uint k = static_cast<uint>((m_bit_buf >> (cBitBufSize - 16)) + 1);
      uint sym, len;

      if (k <= pTables->m_table_max_code)
      {
         uint32 t = pTables->m_lookup[m_bit_buf >> (cBitBufSize - pTables->m_table_bits)];

         LZHAM_ASSERT(t != cUINT32_MAX);
         sym = t & cUINT16_MAX;
         len = t >> 16;

         LZHAM_ASSERT(model.m_code_sizes[sym] == len);
      }
      else
      {
         len = pTables->m_decode_start_code_size;

         for ( ; ; )
         {
            if (k <= pTables->m_max_codes[len - 1])
               break;
            len++;
         }

         int val_ptr = pTables->m_val_ptrs[len - 1] + static_cast<int>((m_bit_buf >> (cBitBufSize - len)));

         if (((uint)val_ptr >= model.m_total_syms))
         {
            // corrupted stream, or a bug
            LZHAM_ASSERT(0);
            LZHAM_LOG_ERROR(4031);
            return 0;
         }

         sym = pTables->m_sorted_symbol_order[val_ptr];
      }

      m_bit_buf <<= len;
      m_bit_count -= len;

      uint freq = model.m_sym_freq[sym];
      freq++;
      model.m_sym_freq[sym] = static_cast<uint16>(freq);
      
      LZHAM_ASSERT(freq <= cUINT16_MAX);
      
      if (--model.m_symbols_until_update == 0)
      {
         m_total_model_updates++;
         model.update_tables();
      }

      return sym;
   }

   uint64 symbol_codec::stop_decoding()
   {
      LZHAM_ASSERT(m_mode == cDecoding);

      uint64 n = m_pDecode_buf_next - m_pDecode_buf;

      m_mode = cNull;

      return n;
   }

   uint symbol_codec::get_bits(uint num_bits)
   {
      LZHAM_ASSERT(num_bits <= 25);

      if (!num_bits)
         return 0;

      while (m_bit_count < (int)num_bits)
      {
         uint c = 0;
         if (m_pDecode_buf_next == m_pDecode_buf_end)
         {
            if (!m_decode_buf_eof)
            {
               m_pDecode_need_bytes_func(m_pDecode_buf_next - m_pDecode_buf, m_pDecode_private_data, m_pDecode_buf, m_decode_buf_size, m_decode_buf_eof);
               m_pDecode_buf_end = m_pDecode_buf + m_decode_buf_size;
               m_pDecode_buf_next = m_pDecode_buf;
               if (m_pDecode_buf_next < m_pDecode_buf_end) c = *m_pDecode_buf_next++;
            }
         }
         else
            c = *m_pDecode_buf_next++;

         m_bit_count += 8;
         LZHAM_ASSERT(m_bit_count <= cBitBufSize);

         m_bit_buf |= (static_cast<bit_buf_t>(c) << (cBitBufSize - m_bit_count));
      }

      uint result = static_cast<uint>(m_bit_buf >> (cBitBufSize - num_bits));

      m_bit_buf <<= num_bits;
      m_bit_count -= num_bits;

      return result;
   }

   void symbol_codec::remove_bits(uint num_bits)
   {
      LZHAM_ASSERT(num_bits <= 25);

      if (!num_bits)
         return;

      while (m_bit_count < (int)num_bits)
      {
         uint c = 0;
         if (m_pDecode_buf_next == m_pDecode_buf_end)
         {
            if (!m_decode_buf_eof)
            {
               m_pDecode_need_bytes_func(m_pDecode_buf_next - m_pDecode_buf, m_pDecode_private_data, m_pDecode_buf, m_decode_buf_size, m_decode_buf_eof);
               m_pDecode_buf_end = m_pDecode_buf + m_decode_buf_size;
               m_pDecode_buf_next = m_pDecode_buf;
               if (m_pDecode_buf_next < m_pDecode_buf_end) c = *m_pDecode_buf_next++;
            }
         }
         else
            c = *m_pDecode_buf_next++;

         m_bit_count += 8;
         LZHAM_ASSERT(m_bit_count <= cBitBufSize);

         m_bit_buf |= (static_cast<bit_buf_t>(c) << (cBitBufSize - m_bit_count));
      }

      m_bit_buf <<= num_bits;
      m_bit_count -= num_bits;
   }

   void symbol_codec::decode_align_to_byte()
   {
      LZHAM_ASSERT(m_mode == cDecoding);

      if (m_bit_count & 7)
      {
         remove_bits(m_bit_count & 7);
      }
   }

   int symbol_codec::decode_remove_byte_from_bit_buf()
   {
      if (m_bit_count < 8)
         return -1;
      int result = static_cast<int>(m_bit_buf >> (cBitBufSize - 8));
      m_bit_buf <<= 8;
      m_bit_count -= 8;
      return result;
   }

   uint symbol_codec::decode(adaptive_bit_model& model, bool update_model)
   {
      while (m_arith_length < cSymbolCodecArithMinLen)
      {
         uint c = get_bits(8);
         m_arith_value = (m_arith_value << 8) | c;
         m_arith_length <<= 8;
      }

      uint x = model.m_bit_0_prob * (m_arith_length >> cSymbolCodecArithProbBits);
      uint bit = (m_arith_value >= x);

      if (!bit)
      {
         if (update_model)
            model.m_bit_0_prob += ((cSymbolCodecArithProbScale - model.m_bit_0_prob) >> cSymbolCodecArithProbMoveBits);

         m_arith_length = x;
      }
      else
      {
         if (update_model)
            model.m_bit_0_prob -= (model.m_bit_0_prob >> cSymbolCodecArithProbMoveBits);
         m_arith_value  -= x;
         m_arith_length -= x;
      }

      return bit;
   }
      
   void symbol_codec::start_arith_decoding()
   {
      LZHAM_ASSERT(m_mode == cDecoding);

      m_arith_length = cSymbolCodecArithMaxLen;
      m_arith_value = 0;

      m_arith_value = (get_bits(8) << 24);
      m_arith_value |= (get_bits(8) << 16);
      m_arith_value |= (get_bits(8) << 8);
      m_arith_value |= get_bits(8);
   }

   void symbol_codec::decode_need_bytes()
   {
      if (!m_decode_buf_eof)
      {
         m_pDecode_need_bytes_func(m_pDecode_buf_next - m_pDecode_buf, m_pDecode_private_data, m_pDecode_buf, m_decode_buf_size, m_decode_buf_eof);
         m_pDecode_buf_end = m_pDecode_buf + m_decode_buf_size;
         m_pDecode_buf_next = m_pDecode_buf;
      }
   }

} // namespace lzham
// File: lzham_symbol_codec.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once
#include "lzham_prefix_coding.h"

namespace lzham
{
   class symbol_codec;
   
   const uint cSymbolCodecArithMinLen = 0x01000000U;
   const uint cSymbolCodecArithMaxLen = 0xFFFFFFFFU;

   const uint cSymbolCodecArithProbBits = 11;
   const uint cSymbolCodecArithProbScale = 1 << cSymbolCodecArithProbBits;
   const uint cSymbolCodecArithProbHalfScale = 1 << (cSymbolCodecArithProbBits - 1);
   const uint cSymbolCodecArithProbMoveBits = 5;

   typedef uint64 bit_cost_t;
   const uint32 cBitCostScaleShift = 24;
   const uint32 cBitCostScale = (1U << cBitCostScaleShift);
   const bit_cost_t cBitCostMax = cUINT64_MAX;

   inline bit_cost_t convert_to_scaled_bitcost(uint bits) { LZHAM_ASSERT(bits <= 255); uint32 scaled_bits = bits << cBitCostScaleShift; return static_cast<bit_cost_t>(scaled_bits); }

   extern uint32 g_prob_cost[cSymbolCodecArithProbScale];

   class quasi_adaptive_huffman_data_model
   {
   public:
      quasi_adaptive_huffman_data_model(lzham_malloc_context malloc_context = NULL, bool encoding = false, uint total_syms = 0, uint max_update_interval = 0, uint adapt_rate = 0);
      quasi_adaptive_huffman_data_model(const quasi_adaptive_huffman_data_model& other);
      ~quasi_adaptive_huffman_data_model();

      bool assign(const quasi_adaptive_huffman_data_model& rhs);
      quasi_adaptive_huffman_data_model& operator= (const quasi_adaptive_huffman_data_model& rhs);
      
      void clear();

      void set_malloc_context(lzham_malloc_context malloc_context) 
      { 
         m_malloc_context = malloc_context; 
         m_initial_sym_freq.set_malloc_context(malloc_context);
         m_sym_freq.set_malloc_context(malloc_context);
         m_codes.set_malloc_context(malloc_context);
         m_code_sizes.set_malloc_context(malloc_context);
      }

      lzham_malloc_context get_malloc_context() const { return m_malloc_context; }

      bool init2(lzham_malloc_context context, bool encoding, uint total_syms, uint max_update_interval, uint adapt_rate, const uint16 *pInitial_sym_freq);
      bool reset();

      inline uint get_total_syms() const { return m_total_syms; }

      void rescale();
      void reset_update_rate();

      bool update_sym(uint sym);

      inline bit_cost_t get_cost(uint sym) const { return convert_to_scaled_bitcost(m_code_sizes[sym]); }

   public:
      lzham_malloc_context             m_malloc_context;
      lzham::vector<uint16>            m_initial_sym_freq;

      lzham::vector<uint16>            m_sym_freq;

      lzham::vector<uint16>            m_codes;
      lzham::vector<uint8>             m_code_sizes;

      prefix_coding::decoder_tables*   m_pDecode_tables;

      uint                             m_total_syms;

      uint                             m_max_cycle;
      uint                             m_update_cycle;
      uint                             m_symbols_until_update;

      uint                             m_total_count;

      uint8                            m_decoder_table_bits;
      uint16                           m_max_update_interval; // def=16, typical range 12-128, controls the max interval between table updates, higher=longer max interval (faster decode/lower ratio)
      uint16                           m_adapt_rate; // def=10, 8 or higher, scaled by 8, controls the slowing of the update update freq, higher=more rapid slowing (faster decode/lower ratio)
      bool                             m_encoding;

      bool update_tables(int force_update_cycle = -1, bool sym_freq_all_ones = false);

      friend class symbol_codec;
   };
      
   class adaptive_bit_model
   {
   public:
      inline adaptive_bit_model() { clear(); }
      adaptive_bit_model(float prob0);
      adaptive_bit_model(const adaptive_bit_model& other);

      inline adaptive_bit_model& operator= (const adaptive_bit_model& rhs) { m_bit_0_prob = rhs.m_bit_0_prob; return *this; }

      inline void clear() { m_bit_0_prob  = 1U << (cSymbolCodecArithProbBits - 1); }

      void set_probability_0(float prob0);

      inline void update(uint bit)
      {
         if (!bit)
            m_bit_0_prob += ((cSymbolCodecArithProbScale - m_bit_0_prob) >> cSymbolCodecArithProbMoveBits);
         else
            m_bit_0_prob -= (m_bit_0_prob >> cSymbolCodecArithProbMoveBits);
         LZHAM_ASSERT(m_bit_0_prob >= 1);
         LZHAM_ASSERT(m_bit_0_prob < cSymbolCodecArithProbScale);
      }

      inline bit_cost_t get_cost(uint bit) const { return g_prob_cost[bit ? (cSymbolCodecArithProbScale - m_bit_0_prob) : m_bit_0_prob]; }

   public:
      uint16 m_bit_0_prob;

      friend class symbol_codec;
   };
      
#if LZHAM_CPU_HAS_64BIT_REGISTERS
   #define LZHAM_SYMBOL_CODEC_USE_64_BIT_BUFFER 1
#else
   #define LZHAM_SYMBOL_CODEC_USE_64_BIT_BUFFER 0
#endif

   class symbol_codec
   {
      LZHAM_NO_COPY_OR_ASSIGNMENT_OP(symbol_codec);

   public:
      symbol_codec(lzham_malloc_context malloc_context);

      void reset();
      
      // clear() is like reset(), except it also frees all memory.
      void clear();
      
      // Encoding
      bool start_encoding(uint expected_file_size);
      bool encode_bits(uint bits, uint num_bits);
      bool encode_arith_init();
      bool encode_align_to_byte();
      bool encode(uint sym, quasi_adaptive_huffman_data_model& model);
      bool encode(uint bit, adaptive_bit_model& model, bool update_model = true);
      
      inline uint encode_get_total_bits_written() const { return m_total_bits_written; }

      bool stop_encoding(bool support_arith);

      const lzham::vector<uint8>& get_encoding_buf() const  { return m_output_buf; }
            lzham::vector<uint8>& get_encoding_buf()        { return m_output_buf; }

      // Decoding

      typedef void (*need_bytes_func_ptr)(size_t num_bytes_consumed, void *pPrivate_data, const uint8* &pBuf, size_t &buf_size, bool &eof_flag);

      bool start_decoding(const uint8* pBuf, size_t buf_size, bool eof_flag = true, need_bytes_func_ptr pNeed_bytes_func = NULL, void *pPrivate_data = NULL);

      inline void decode_set_input_buffer(const uint8* pBuf, size_t buf_size, const uint8* pBuf_next, bool eof_flag)
      {
         m_pDecode_buf = pBuf;
         m_pDecode_buf_next = pBuf_next;
         m_decode_buf_size = buf_size;
         m_pDecode_buf_end = pBuf + buf_size;
         m_decode_buf_eof = eof_flag;
      }
      inline uint64 decode_get_bytes_consumed() const { return m_pDecode_buf_next - m_pDecode_buf; }
      inline uint64 decode_get_bits_remaining() const { return ((m_pDecode_buf_end - m_pDecode_buf_next) << 3) + m_bit_count; }

      void start_arith_decoding();
      uint decode_bits(uint num_bits);
      uint decode_peek_bits(uint num_bits);
      void decode_remove_bits(uint num_bits);
      void decode_align_to_byte();
      int decode_remove_byte_from_bit_buf();
      uint decode(quasi_adaptive_huffman_data_model& model);
      uint decode(adaptive_bit_model& model, bool update_model = true);
      uint64 stop_decoding();

      uint get_total_model_updates() const { return m_total_model_updates; }

   public:
      lzham_malloc_context    m_malloc_context;

      const uint8*            m_pDecode_buf;
      const uint8*            m_pDecode_buf_next;
      const uint8*            m_pDecode_buf_end;
      size_t                  m_decode_buf_size;
      bool                    m_decode_buf_eof;

      need_bytes_func_ptr     m_pDecode_need_bytes_func;
      void*                   m_pDecode_private_data;

#if LZHAM_SYMBOL_CODEC_USE_64_BIT_BUFFER
      typedef uint64 bit_buf_t;
      enum { cBitBufSize = 64 };
#else
      typedef uint32 bit_buf_t;
      enum { cBitBufSize = 32 };
#endif

      bit_buf_t               m_bit_buf;
      int                     m_bit_count;

      uint                    m_total_model_updates;

      lzham::vector<uint8>    m_output_buf;
      lzham::vector<uint8>    m_arith_output_buf;

      struct output_symbol
      {
         uint m_bits;

         enum
         {
            cArithSym = -1,
            cAlignToByteSym = -2,
            cArithInit = -3
         };
         int16 m_num_bits;

         uint16 m_arith_prob0;
      };
      lzham::vector<output_symbol> m_output_syms;

      uint                    m_total_bits_written;

      uint                    m_arith_base;
      uint                    m_arith_value;
      uint                    m_arith_length;
      uint                    m_arith_total_bits;

      quasi_adaptive_huffman_data_model*     m_pSaved_huff_model;
      void*                   m_pSaved_model;
      uint                    m_saved_node_index;

      bool put_bits_init(uint expected_size);
      bool record_put_bits(uint bits, uint num_bits);

      void arith_propagate_carry();
      bool arith_renorm_enc_interval();
      void arith_start_encoding();
      bool arith_stop_encoding();

      bool put_bits(uint bits, uint num_bits);
      bool put_bits_align_to_byte();
      bool flush_bits();
      bool assemble_output_buf();

      uint get_bits(uint num_bits);
      void remove_bits(uint num_bits);

      void decode_need_bytes();

      enum
      {
         cNull,
         cEncoding,
         cDecoding
      } m_mode;
   };

// Optional macros for faster decompression. These macros implement the symbol_codec class's decode functionality.
// This is hard to debug (and just plain ugly), but using these macros eliminate function calls, and they place the most important 
// member variables on the stack so they're hopefully put in registers (avoiding horrible load hit stores on some CPU's).
// The user must define the LZHAM_DECODE_NEEDS_BYTES macro, which is invoked when the decode buffer is exhausted.

#define LZHAM_SYMBOL_CODEC_DECODE_DECLARE(codec) \
   uint arith_value = 0; \
   uint arith_length = 0; \
   symbol_codec::bit_buf_t bit_buf = 0; \
   int bit_count = 0; \
   const uint8* pDecode_buf_next = NULL;

#define LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec) \
   arith_value = codec.m_arith_value; \
   arith_length = codec.m_arith_length; \
   bit_buf = codec.m_bit_buf; \
   bit_count = codec.m_bit_count; \
   pDecode_buf_next = codec.m_pDecode_buf_next;

#define LZHAM_SYMBOL_CODEC_DECODE_END(codec) \
   codec.m_arith_value = arith_value; \
   codec.m_arith_length = arith_length; \
   codec.m_bit_buf = bit_buf; \
   codec.m_bit_count = bit_count; \
   codec.m_pDecode_buf_next = pDecode_buf_next;

// The user must declare the LZHAM_DECODE_NEEDS_BYTES macro.

#define LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, result, num_bits) \
{ \
   while (LZHAM_BUILTIN_EXPECT(bit_count < (int)(num_bits), 0)) \
   { \
      uint r; \
      if (LZHAM_BUILTIN_EXPECT(pDecode_buf_next == codec.m_pDecode_buf_end, 0)) \
      { \
         if (LZHAM_BUILTIN_EXPECT(!codec.m_decode_buf_eof, 1)) \
         { \
            LZHAM_SYMBOL_CODEC_DECODE_END(codec) \
            LZHAM_DECODE_NEEDS_BYTES \
            LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec) \
         } \
         r = 0; \
         if (LZHAM_BUILTIN_EXPECT(pDecode_buf_next < codec.m_pDecode_buf_end, 1)) r = *pDecode_buf_next++; \
      } \
      else \
         r = *pDecode_buf_next++; \
      bit_count += 8; \
      bit_buf |= (static_cast<symbol_codec::bit_buf_t>(r) << (symbol_codec::cBitBufSize - bit_count)); \
   } \
   result = (num_bits) ? static_cast<uint>(bit_buf >> (symbol_codec::cBitBufSize - (num_bits))) : 0; \
   bit_buf <<= (num_bits); \
   bit_count -= (num_bits); \
}

#define LZHAM_SYMBOL_CODEC_DECODE_ARITH_BIT(codec, result, model) \
{ \
   adaptive_bit_model *pModel; \
   pModel = &model; \
   while (LZHAM_BUILTIN_EXPECT(arith_length < cSymbolCodecArithMinLen, 0)) \
   { \
      uint c; codec.m_pSaved_model = pModel; \
      LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, c, 8); \
      pModel = static_cast<adaptive_bit_model*>(codec.m_pSaved_model); \
      arith_value = (arith_value << 8) | c; \
      arith_length <<= 8; \
   } \
   uint x = pModel->m_bit_0_prob * (arith_length >> cSymbolCodecArithProbBits); \
   result = (arith_value >= x); \
   if (!result) \
   { \
      pModel->m_bit_0_prob += ((cSymbolCodecArithProbScale - pModel->m_bit_0_prob) >> cSymbolCodecArithProbMoveBits); \
      arith_length = x; \
   } \
   else \
   { \
      pModel->m_bit_0_prob -= (pModel->m_bit_0_prob >> cSymbolCodecArithProbMoveBits); \
      arith_value  -= x; \
      arith_length -= x; \
   } \
}

#if LZHAM_SYMBOL_CODEC_USE_64_BIT_BUFFER
#define LZHAM_SYMBOL_CODEC_DECODE_ADAPTIVE_HUFFMAN(codec, result, model) \
{ \
   quasi_adaptive_huffman_data_model* pModel; const prefix_coding::decoder_tables* pTables; \
   pModel = &model; pTables = model.m_pDecode_tables; \
   if (LZHAM_BUILTIN_EXPECT(bit_count < 24, 0)) \
   { \
      uint c; \
      pDecode_buf_next += sizeof(uint32); \
      if (LZHAM_BUILTIN_EXPECT(pDecode_buf_next >= codec.m_pDecode_buf_end, 0)) \
      { \
         pDecode_buf_next -= sizeof(uint32); \
         while (bit_count < 24) \
         { \
            if (!codec.m_decode_buf_eof) \
            { \
               codec.m_pSaved_huff_model = pModel; \
               LZHAM_SYMBOL_CODEC_DECODE_END(codec) \
               LZHAM_DECODE_NEEDS_BYTES \
               LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec) \
               pModel = codec.m_pSaved_huff_model; pTables = pModel->m_pDecode_tables; \
            } \
            c = 0; if (pDecode_buf_next < codec.m_pDecode_buf_end) c = *pDecode_buf_next++; \
            bit_count += 8; \
            bit_buf |= (static_cast<symbol_codec::bit_buf_t>(c) << (symbol_codec::cBitBufSize - bit_count)); \
         } \
      } \
      else \
      { \
         c = LZHAM_READ_BIG_ENDIAN_UINT32(pDecode_buf_next - sizeof(uint32)); \
         bit_count += 32; \
         bit_buf |= (static_cast<symbol_codec::bit_buf_t>(c) << (symbol_codec::cBitBufSize - bit_count)); \
      } \
   } \
   uint k = static_cast<uint>((bit_buf >> (symbol_codec::cBitBufSize - 16)) + 1); \
   uint len; \
   if (LZHAM_BUILTIN_EXPECT(k <= pTables->m_table_max_code, 1)) \
   { \
      uint32 t = pTables->m_lookup[bit_buf >> (symbol_codec::cBitBufSize - pTables->m_table_bits)]; \
      result = t & cUINT16_MAX; \
      len = t >> 16; \
   } \
   else \
   { \
      len = pTables->m_decode_start_code_size; \
      for ( ; ; ) \
      { \
         if (LZHAM_BUILTIN_EXPECT(k <= pTables->m_max_codes[len - 1], 0)) \
            break; \
         len++; \
      } \
      int val_ptr = pTables->m_val_ptrs[len - 1] + static_cast<int>(bit_buf >> (symbol_codec::cBitBufSize - len)); \
      if (((uint)val_ptr >= pModel->m_total_syms)) val_ptr = 0; \
      result = pTables->m_sorted_symbol_order[val_ptr]; \
   }  \
   bit_buf <<= len; \
   bit_count -= len; \
   uint freq = pModel->m_sym_freq[result]; \
   freq++; \
   pModel->m_sym_freq[result] = static_cast<uint16>(freq); \
   LZHAM_ASSERT(freq <= cUINT16_MAX); \
   if (LZHAM_BUILTIN_EXPECT(--pModel->m_symbols_until_update == 0, 0)) \
   { \
      pModel->update_tables(); \
   } \
}
#else
#define LZHAM_SYMBOL_CODEC_DECODE_ADAPTIVE_HUFFMAN(codec, result, model) \
{ \
   quasi_adaptive_huffman_data_model* pModel; const prefix_coding::decoder_tables* pTables; \
   pModel = &model; pTables = model.m_pDecode_tables; \
   while (LZHAM_BUILTIN_EXPECT(bit_count < (symbol_codec::cBitBufSize - 8), 1)) \
   { \
      uint c; \
      if (LZHAM_BUILTIN_EXPECT(pDecode_buf_next == codec.m_pDecode_buf_end, 0)) \
      { \
         if (LZHAM_BUILTIN_EXPECT(!codec.m_decode_buf_eof, 1)) \
         { \
            codec.m_pSaved_huff_model = pModel; \
            LZHAM_SYMBOL_CODEC_DECODE_END(codec) \
            LZHAM_DECODE_NEEDS_BYTES \
            LZHAM_SYMBOL_CODEC_DECODE_BEGIN(codec) \
            pModel = codec.m_pSaved_huff_model; pTables = pModel->m_pDecode_tables; \
         } \
         c = 0; if (LZHAM_BUILTIN_EXPECT(pDecode_buf_next < codec.m_pDecode_buf_end, 1)) c = *pDecode_buf_next++; \
      } \
      else \
         c = *pDecode_buf_next++; \
      bit_count += 8; \
      bit_buf |= (static_cast<symbol_codec::bit_buf_t>(c) << (symbol_codec::cBitBufSize - bit_count)); \
   } \
   uint k = static_cast<uint>((bit_buf >> (symbol_codec::cBitBufSize - 16)) + 1); \
   uint len; \
   if (LZHAM_BUILTIN_EXPECT(k <= pTables->m_table_max_code, 1)) \
   { \
      uint32 t = pTables->m_lookup[bit_buf >> (symbol_codec::cBitBufSize - pTables->m_table_bits)]; \
      result = t & cUINT16_MAX; \
      len = t >> 16; \
   } \
   else \
   { \
      len = pTables->m_decode_start_code_size; \
      for ( ; ; ) \
      { \
         if (LZHAM_BUILTIN_EXPECT(k <= pTables->m_max_codes[len - 1], 0)) \
            break; \
         len++; \
      } \
      int val_ptr = pTables->m_val_ptrs[len - 1] + static_cast<int>(bit_buf >> (symbol_codec::cBitBufSize - len)); \
      if (LZHAM_BUILTIN_EXPECT(((uint)val_ptr >= pModel->m_total_syms), 0)) val_ptr = 0; \
      result = pTables->m_sorted_symbol_order[val_ptr]; \
   }  \
   bit_buf <<= len; \
   bit_count -= len; \
   uint freq = pModel->m_sym_freq[result]; \
   freq++; \
   pModel->m_sym_freq[result] = static_cast<uint16>(freq); \
   LZHAM_ASSERT(freq <= cUINT16_MAX); \
   if (LZHAM_BUILTIN_EXPECT(--pModel->m_symbols_until_update == 0, 0)) \
   { \
      pModel->update_tables(); \
   } \
}
#endif

#define LZHAM_SYMBOL_CODEC_DECODE_ALIGN_TO_BYTE(codec) if (bit_count & 7) { int dummy_result; LZHAM_NOTE_UNUSED(dummy_result); LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, dummy_result, bit_count & 7); }

#define LZHAM_SYMBOL_CODEC_DECODE_REMOVE_BYTE_FROM_BIT_BUF(codec, result) \
{ \
   result = -1; \
   if (bit_count >= 8) \
   { \
      result = static_cast<int>(bit_buf >> (symbol_codec::cBitBufSize - 8)); \
      bit_buf <<= 8; \
      bit_count -= 8; \
   } \
}

#define LZHAM_SYMBOL_CODEC_DECODE_ARITH_START(codec) \
{ \
   for ( arith_value = 0, arith_length = 0; arith_length < 4; ++arith_length ) \
   { \
      uint val; LZHAM_SYMBOL_CODEC_DECODE_GET_BITS(codec, val, 8); \
      arith_value = (arith_value << 8) | val; \
   } \
   arith_length = cSymbolCodecArithMaxLen; \
}

} // namespace lzham
// File: lzham_timer.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_timer.h"

#ifndef LZHAM_USE_WIN32_API
   #include <time.h>
#endif   

namespace lzham
{
   unsigned long long lzham_timer::g_init_ticks;
   unsigned long long lzham_timer::g_freq;
   double lzham_timer::g_inv_freq;
   
   #if LZHAM_USE_WIN32_API
      inline void query_counter(timer_ticks *pTicks)
      {
         QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(pTicks));
      }
      inline void query_counter_frequency(timer_ticks *pTicks)
      {
         QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>(pTicks));
      }
   #else
      inline void query_counter(timer_ticks *pTicks)
      {
         *pTicks = clock();
      }
      inline void query_counter_frequency(timer_ticks *pTicks)
      {
         *pTicks = CLOCKS_PER_SEC;
      }
   #endif
   
   lzham_timer::lzham_timer() :
      m_start_time(0),
      m_stop_time(0),
      m_started(false),
      m_stopped(false)
   {
      if (!g_inv_freq) 
         init();
   }

   lzham_timer::lzham_timer(timer_ticks start_ticks)
   {
      if (!g_inv_freq) 
         init();
      
      m_start_time = start_ticks;
      
      m_started = true;
      m_stopped = false;
   }

   void lzham_timer::start(timer_ticks start_ticks)
   {
      m_start_time = start_ticks;
      
      m_started = true;
      m_stopped = false;
   }

   void lzham_timer::start()
   {
      query_counter(&m_start_time);
      
      m_started = true;
      m_stopped = false;
   }

   void lzham_timer::stop()
   {
      LZHAM_ASSERT(m_started);
                  
      query_counter(&m_stop_time);
      
      m_stopped = true;
   }

   double lzham_timer::get_elapsed_secs() const
   {
      LZHAM_ASSERT(m_started);
      if (!m_started)
         return 0;
      
      timer_ticks stop_time = m_stop_time;
      if (!m_stopped)
         query_counter(&stop_time);
         
      timer_ticks delta = stop_time - m_start_time;
      return delta * g_inv_freq;
   }

   timer_ticks lzham_timer::get_elapsed_us() const
   {
      LZHAM_ASSERT(m_started);
      if (!m_started)
         return 0;
         
      timer_ticks stop_time = m_stop_time;
      if (!m_stopped)
         query_counter(&stop_time);
      
      timer_ticks delta = stop_time - m_start_time;
      return (delta * 1000000ULL + (g_freq >> 1U)) / g_freq;      
   }

   void lzham_timer::init()
   {
      if (!g_inv_freq)
      {
         query_counter_frequency(&g_freq);
         g_inv_freq = 1.0f / g_freq;
         
         query_counter(&g_init_ticks);
      }
   }

   timer_ticks lzham_timer::get_init_ticks()
   {
      if (!g_inv_freq) 
         init();
      
      return g_init_ticks;
   }

   timer_ticks lzham_timer::get_ticks()
   {
      if (!g_inv_freq) 
         init();
      
      timer_ticks ticks;
      query_counter(&ticks);
      return ticks - g_init_ticks;
   }

   double lzham_timer::ticks_to_secs(timer_ticks ticks)
   {
      if (!g_inv_freq) 
         init();
      
      return ticks * g_inv_freq;
   }
   
} // namespace lzham// File: lzham_timer.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

namespace lzham
{
   typedef unsigned long long timer_ticks;
      
   class lzham_timer
   {
   public:
      lzham_timer();
      lzham_timer(timer_ticks start_ticks);
      
      void start();
      void start(timer_ticks start_ticks);
      
      void stop();
         
      double get_elapsed_secs() const;
      inline double get_elapsed_ms() const { return get_elapsed_secs() * 1000.0f; }
      timer_ticks get_elapsed_us() const;
      
      static void init();
      static inline timer_ticks get_ticks_per_sec() { return g_freq; }
      static timer_ticks get_init_ticks();
      static timer_ticks get_ticks();
      static double ticks_to_secs(timer_ticks ticks);
      static inline double ticks_to_ms(timer_ticks ticks) { return ticks_to_secs(ticks) * 1000.0f; }
      static inline double get_secs() { return ticks_to_secs(get_ticks()); }
      static inline double get_ms() { return ticks_to_ms(get_ticks()); }
                   
   private:
      static timer_ticks g_init_ticks;
      static timer_ticks g_freq;
      static double g_inv_freq;
      
      timer_ticks m_start_time;
      timer_ticks m_stop_time;
      
      bool m_started : 1;
      bool m_stopped : 1;
   };

   enum var_args_t { cVarArgs };
   
#if LZHAM_PERF_SECTIONS
   class scoped_perf_section
   {
   public:
      inline scoped_perf_section() :
         m_start_ticks(lzham_timer::get_ticks())
      {
         m_name[0] = '?';
         m_name[1] = '\0';
      }
      
      inline scoped_perf_section(const char *pName) :
         m_start_ticks(lzham_timer::get_ticks())
      {
         strcpy_s(m_name, pName);
         
         lzham_buffered_printf("Thread: 0x%08X, BEGIN Time: %3.3fms, %s\n", GetCurrentThreadId(), lzham_timer::ticks_to_ms(m_start_ticks), m_name);
      }
      
      inline scoped_perf_section(var_args_t, const char *pName, ...) :
         m_start_ticks(lzham_timer::get_ticks())
      {
         va_list args;
         va_start(args, pName);
         vsprintf_s(m_name, sizeof(m_name), pName, args);
         va_end(args);
         
         lzham_buffered_printf("Thread: 0x%08X, BEGIN Time: %3.3fms, %s\n", GetCurrentThreadId(), lzham_timer::ticks_to_ms(m_start_ticks), m_name);
      }
   
      inline ~scoped_perf_section()
      {
         double end_ms = lzham_timer::get_ms();
         double start_ms = lzham_timer::ticks_to_ms(m_start_ticks);
         
         lzham_buffered_printf("Thread: 0x%08X, END   Time: %3.3fms, %s, Total: %3.3fms\n", GetCurrentThreadId(), end_ms, m_name, end_ms - start_ms);
      }

   private:
      char m_name[64];   
      timer_ticks m_start_ticks;
   };
#else
   class scoped_perf_section
   {
   public:
      inline scoped_perf_section() { }
      inline scoped_perf_section(const char *pName) { (void)pName; }
      inline scoped_perf_section(var_args_t, const char *pName, ...) { (void)pName; }
   };
#endif // LZHAM_PERF_SECTIONS   

} // namespace lzham
// File: lzham_traits.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

namespace lzham
{
   template<typename T>
   struct scalar_type
   {
      enum { cFlag = false };
      static inline void construct(T* p) { helpers::construct(p); }
      static inline void construct(T* p, const T& init) { helpers::construct(p, init); }
      static inline void construct_array(T* p, uint n) { helpers::construct_array(p, n); }
      static inline void destruct(T* p) { helpers::destruct(p); }
      static inline void destruct_array(T* p, uint n) { helpers::destruct_array(p, n); }
   };

   template<typename T> struct scalar_type<T*>
   {
      enum { cFlag = true };
      static inline void construct(T** p) { memset(p, 0, sizeof(T*)); }
      static inline void construct(T** p, T* init) { *p = init; }
      static inline void construct_array(T** p, uint n) { memset(p, 0, sizeof(T*) * n); }
      static inline void destruct(T** p) { LZHAM_NOTE_UNUSED(p); }
      static inline void destruct_array(T** p, uint n) { LZHAM_NOTE_UNUSED(p); LZHAM_NOTE_UNUSED(n); }
   };

#define LZHAM_DEFINE_BUILT_IN_TYPE(X) \
   template<> struct scalar_type<X> { \
   enum { cFlag = true }; \
   static inline void construct(X* p) { memset(p, 0, sizeof(X)); } \
   static inline void construct(X* p, const X& init) { memcpy(p, &init, sizeof(X)); } \
   static inline void construct_array(X* p, uint n) { memset(p, 0, sizeof(X) * n); } \
   static inline void destruct(X* p) { LZHAM_NOTE_UNUSED(p); } \
   static inline void destruct_array(X* p, uint n) { LZHAM_NOTE_UNUSED(p); LZHAM_NOTE_UNUSED(n); } };

   LZHAM_DEFINE_BUILT_IN_TYPE(bool)
   LZHAM_DEFINE_BUILT_IN_TYPE(char)
   LZHAM_DEFINE_BUILT_IN_TYPE(unsigned char)
   LZHAM_DEFINE_BUILT_IN_TYPE(short)
   LZHAM_DEFINE_BUILT_IN_TYPE(unsigned short)
   LZHAM_DEFINE_BUILT_IN_TYPE(int)
   LZHAM_DEFINE_BUILT_IN_TYPE(unsigned int)
   LZHAM_DEFINE_BUILT_IN_TYPE(long)
   LZHAM_DEFINE_BUILT_IN_TYPE(unsigned long)
   LZHAM_DEFINE_BUILT_IN_TYPE(float)
   LZHAM_DEFINE_BUILT_IN_TYPE(double)
   LZHAM_DEFINE_BUILT_IN_TYPE(long double)
   #if defined(WIN32)
      LZHAM_DEFINE_BUILT_IN_TYPE(__int64)
      LZHAM_DEFINE_BUILT_IN_TYPE(unsigned __int64)
   #endif

#undef LZHAM_DEFINE_BUILT_IN_TYPE

// See: http://erdani.org/publications/cuj-2004-06.pdf

   template<typename T>
   struct bitwise_movable { enum { cFlag = false }; };

// Defines type Q as bitwise movable.
#define LZHAM_DEFINE_BITWISE_MOVABLE(Q) template<> struct bitwise_movable<Q> { enum { cFlag = true }; };

   template<typename T>
   struct bitwise_copyable { enum { cFlag = false }; };

   // Defines type Q as bitwise copyable.
#define LZHAM_DEFINE_BITWISE_COPYABLE(Q) template<> struct bitwise_copyable<Q> { enum { cFlag = true }; };

#if (defined(__APPLE__) && (TARGET_OS_MAC != 1)) || defined(__NetBSD__)
   #define LZHAM_IS_POD(T) std::is_pod<T>::value
#else
   #define LZHAM_IS_POD(T) __is_pod(T)
#endif

#define LZHAM_IS_SCALAR_TYPE(T) (scalar_type<T>::cFlag)

#define LZHAM_IS_BITWISE_COPYABLE(T) ((scalar_type<T>::cFlag) || (bitwise_copyable<T>::cFlag) || LZHAM_IS_POD(T))

#define LZHAM_IS_BITWISE_MOVABLE(T) (LZHAM_IS_BITWISE_COPYABLE(T) || (bitwise_movable<T>::cFlag))

#define LZHAM_HAS_DESTRUCTOR(T) ((!scalar_type<T>::cFlag) && (!LZHAM_IS_POD(T)))

   // From yasli_traits.h:
   // Credit goes to Boost;
   // also found in the C++ Templates book by Vandevoorde and Josuttis

   typedef char (&yes_t)[1];
   typedef char (&no_t)[2];

   template <class U> yes_t class_test(int U::*);
   template <class U> no_t class_test(...);

   template <class T> struct is_class
   {
      enum { value = (sizeof(class_test<T>(0)) == sizeof(yes_t)) };
   };

   template <typename T> struct is_pointer
   {
      enum { value = false };
   };

   template <typename T> struct is_pointer<T*>
   {
      enum { value = true };
   };

   LZHAM_DEFINE_BITWISE_COPYABLE(empty_type);
   LZHAM_DEFINE_BITWISE_MOVABLE(empty_type);

   namespace helpers
   {
      template <typename T>
      inline void construct_array(T* p, uint n)
      {
         if (LZHAM_IS_SCALAR_TYPE(T))
         {
            memset(p, 0, sizeof(T) * n);
         }
         else
         {
            T* q = p + n;
            for ( ; p != q; ++p)
               new (static_cast<void*>(p)) T;
         }
      }

      template <typename T>
      inline void destruct_array(T* p, uint n)
      {
         if ( LZHAM_HAS_DESTRUCTOR(T) )
         {
            T* q = p + n;
            for ( ; p != q; ++p)
               p->~T();
         }
      }
   }

} // namespace lzham
// File: types.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

namespace lzham
{
   typedef unsigned char      uint8;
   typedef signed char        int8;
   typedef unsigned char      uint8;
   typedef unsigned short     uint16;
   typedef signed short       int16;
   typedef unsigned int       uint32;
   typedef uint32             uint;
   typedef signed int         int32;

   #ifdef _MSC_VER
      typedef unsigned __int64      uint64;
      typedef signed __int64        int64;
   #else
      typedef unsigned long long    uint64;
      typedef long long             int64;
   #endif

   const uint8  cUINT8_MIN  = 0;
   const uint8  cUINT8_MAX  = 0xFFU;
   const uint16 cUINT16_MIN = 0;
   const uint16 cUINT16_MAX = 0xFFFFU;
   const uint32 cUINT32_MIN = 0;
   const uint32 cUINT32_MAX = 0xFFFFFFFFU;
   const uint64 cUINT64_MIN = 0;
   const uint64 cUINT64_MAX = 0xFFFFFFFFFFFFFFFFULL;    //0xFFFFFFFFFFFFFFFFui64;

   const int8  cINT8_MIN  = -128;
   const int8  cINT8_MAX  = 127;
   const int16 cINT16_MIN = -32768;
   const int16 cINT16_MAX = 32767;
   const int32 cINT32_MIN = (-2147483647 - 1);
   const int32 cINT32_MAX = 2147483647;
   const int64 cINT64_MIN = (int64)0x8000000000000000ULL; //(-9223372036854775807i64 - 1);
   const int64 cINT64_MAX = (int64)0x7FFFFFFFFFFFFFFFULL; //9223372036854775807i64;

#if LZHAM_64BIT_POINTERS
   typedef uint64 uint_ptr;
   typedef uint64 uint32_ptr;
   typedef int64 signed_size_t;
   typedef uint64 ptr_bits_t;
#else
   typedef unsigned int uint_ptr;
   typedef unsigned int uint32_ptr;
   typedef signed int signed_size_t;
   typedef uint32 ptr_bits_t;
#endif
   
   enum
   {
      cInvalidIndex = -1
   };

   const uint cIntBits = sizeof(uint) * CHAR_BIT;

   template<typename T> struct int_traits { enum { cMin = INT_MIN, cMax = INT_MAX, cSigned = true }; };
   template<> struct int_traits<int8> { enum { cMin = cINT8_MIN, cMax = cINT8_MAX, cSigned = true }; };
   template<> struct int_traits<int16> { enum { cMin = cINT16_MIN, cMax = cINT16_MAX, cSigned = true }; };
   template<> struct int_traits<int32> { enum { cMin = cINT32_MIN, cMax = cINT32_MAX, cSigned = true }; };

   template<> struct int_traits<uint> { enum { cMin = 0, cMax = UINT_MAX, cSigned = false }; };
   template<> struct int_traits<uint8> { enum { cMin = 0, cMax = cUINT8_MAX, cSigned = false }; };
   template<> struct int_traits<uint16> { enum { cMin = 0, cMax = cUINT16_MAX, cSigned = false }; };

   struct empty_type { };

} // namespace lzham
// File: lzham_utils.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

#define LZHAM_GET_ALIGNMENT(v) ((!sizeof(v)) ? 1 : (__alignof(v) ? __alignof(v) : sizeof(uint32))) 

#define LZHAM_MIN(a, b) (((a) < (b)) ? (a) : (b))
#define LZHAM_MAX(a, b) (((a) < (b)) ? (b) : (a))

template<class T, size_t N> T decay_array_to_subtype(T (&a)[N]);
#define LZHAM_ARRAY_SIZE(X) (sizeof(X) / sizeof(decay_array_to_subtype(X)))

namespace lzham
{
   namespace utils
   {
      template<typename T> inline void swap(T& l, T& r)
      {
         T temp(l);
         l = r;
         r = temp;
      }
      
      template<typename T> inline void zero_object(T& obj)
      {
         memset(&obj, 0, sizeof(obj));
      }
                  
      static inline uint32 swap32(uint32 x) { return ((x << 24U) | ((x << 8U) & 0x00FF0000U) | ((x >> 8U) & 0x0000FF00U) | (x >> 24U)); }
      
      inline uint count_leading_zeros16(uint v)
      {
         LZHAM_ASSERT(v < 0x10000);
         
         uint temp;
         uint n = 16;
         
         temp = v >> 8;
         if (temp) { n -=  8; v = temp; }

         temp = v >> 4;
         if (temp) { n -=  4; v = temp; }

         temp = v >> 2;
         if (temp) { n -=  2; v = temp; }

         temp = v >> 1;
         if (temp) { n -=  1; v = temp; }

         if (v & 1) n--;

         return n;
      }
      
   }   // namespace utils
         
} // namespace lzham

// File: lzham_vector.cpp
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_vector.h"

namespace lzham
{
   bool elemental_vector::increase_capacity(uint min_new_capacity, bool grow_hint, uint element_size, object_mover pMover, bool nofail)
   {
      LZHAM_ASSERT(m_size <= m_capacity);
      
#if LZHAM_64BIT_POINTERS
      LZHAM_ASSUME(sizeof(void*) == sizeof(uint64));
      LZHAM_ASSERT(min_new_capacity < (0x400000000ULL / element_size));
#else      
      LZHAM_ASSUME(sizeof(void*) == sizeof(uint32));
      LZHAM_ASSERT(min_new_capacity < (0x7FFF0000U / element_size));
#endif      

      if (m_capacity >= min_new_capacity)
         return true;

      // new_capacity must be 64-bit when compiling on x64.
		size_t new_capacity = (size_t)min_new_capacity;
      if ((grow_hint) && (!math::is_power_of_2(static_cast<uint64>(new_capacity))))
         new_capacity = static_cast<uint>(math::next_pow2(static_cast<uint64>(new_capacity)));

      LZHAM_ASSERT(new_capacity && (new_capacity > m_capacity));

      const size_t desired_size = element_size * new_capacity;
      size_t actual_size;
      if (!pMover)
      {
         void* new_p = lzham_realloc(m_malloc_context, m_p, desired_size, &actual_size, true);
         if (!new_p)
         {
            if (nofail)
            {
               LZHAM_LOG_ERROR(5000);
               return false;
            }
               
            char buf[256];
            sprintf_s(buf, sizeof(buf), "vector: lzham_realloc() failed allocating %u bytes", desired_size);
            LZHAM_FAIL(buf);
         }
         m_p = new_p;
      }
      else
      {
         void* new_p = lzham_malloc(m_malloc_context, desired_size, &actual_size);
         if (!new_p)
         {
            if (nofail)
            {
               LZHAM_LOG_ERROR(5001);
               return false;
            }
               
            LZHAM_LOG_ERROR(5002);

            char buf[256];
            sprintf_s(buf, sizeof(buf), "vector: lzham_malloc() failed allocating %u bytes", desired_size);
            LZHAM_FAIL(buf);
         }
         
         (*pMover)(new_p, m_p, m_size);
         
         if (m_p)
            lzham_free(m_malloc_context, m_p);

         m_p = new_p;
      }            
      
      if (actual_size > desired_size)
         m_capacity = static_cast<uint>(actual_size / element_size);
      else
         m_capacity = static_cast<uint>(new_capacity);
    
      return true;
   }

} // namespace lzham
// File: lzham_vector.h
// See Copyright Notice and license at the end of include/lzham.h
#pragma once

namespace lzham
{
   struct elemental_vector
   {
      void* m_p;
      uint m_size;
      uint m_capacity;
      lzham_malloc_context m_malloc_context;

      typedef void (*object_mover)(void* pDst, void* pSrc, uint num);

      bool increase_capacity(uint min_new_capacity, bool grow_hint, uint element_size, object_mover pRelocate, bool nofail);
   };

   template<typename T>
   class vector : public helpers::rel_ops< vector<T> >
   {
   public:
      typedef T*              iterator;
      typedef const T*        const_iterator;
      typedef T               value_type;
      typedef T&              reference;
      typedef const T&        const_reference;
      typedef T*              pointer;
      typedef const T*        const_pointer;

      inline vector(lzham_malloc_context context = NULL) :
         m_p(NULL),
         m_size(0),
         m_capacity(0),
         m_malloc_context(context)
      {
      }

      inline vector(lzham_malloc_context context, uint n, const T& init) :
         m_p(NULL),
         m_size(0),
         m_capacity(0),
         m_malloc_context(context)
      {
         increase_capacity(n, false);
         helpers::construct_array(m_p, n, init);
         m_size = n;
      }

      inline vector(const vector& other) :
         m_p(NULL),
         m_size(0),
         m_capacity(0),
         m_malloc_context(other.m_malloc_context)
      {
         increase_capacity(other.m_size, false);

         m_size = other.m_size;

         if (LZHAM_IS_BITWISE_COPYABLE(T))
            memcpy(m_p, other.m_p, m_size * sizeof(T));
         else
         {
            T* pDst = m_p;
            const T* pSrc = other.m_p;
            for (uint i = m_size; i > 0; i--)
               helpers::construct(pDst++, *pSrc++);
         }
      }

#if 0
      inline explicit vector(lzham_malloc_context context, uint size) :
         m_p(NULL),
         m_size(0),
         m_capacity(0),
         m_malloc_context(context)
      {
         try_resize(size);
      }
#endif

      inline ~vector()
      {
         if (m_p)
         {
            scalar_type<T>::destruct_array(m_p, m_size);
            lzham_free(m_malloc_context, m_p);
         }
      }

      lzham_malloc_context get_malloc_context() const 
      { 
         return m_malloc_context; 
      }
      
      void set_malloc_context(lzham_malloc_context context)
      {
         clear();
         m_malloc_context = context;
      }

      inline vector& operator= (const vector& other)
      {
         if (this == &other)
            return *this;

         if (m_capacity >= other.m_size)
            try_resize(0);
         else
         {
            clear();
            if (!increase_capacity(other.m_size, false))
            {
               LZHAM_LOG_ERROR(5008);
               LZHAM_FAIL("lzham::vector operator=: Out of memory!");
               return *this;
            }
         }

         if (LZHAM_IS_BITWISE_COPYABLE(T))
            memcpy(m_p, other.m_p, other.m_size * sizeof(T));
         else
         {
            T* pDst = m_p;
            const T* pSrc = other.m_p;
            for (uint i = other.m_size; i > 0; i--)
               helpers::construct(pDst++, *pSrc++);
         }

         m_size = other.m_size;

         return *this;
      }

      inline const   T* begin() const  { return m_p; }
                     T* begin()        { return m_p; }

      inline const   T* end() const  { return m_p + m_size; }
                     T* end()        { return m_p + m_size; }

      inline bool empty() const { return !m_size; }
      inline uint size() const { return m_size; }
      inline uint size_in_bytes() const { return m_size * sizeof(T); }
      inline uint capacity() const { return m_capacity; }

      // operator[] will assert on out of range indices, but in final builds there is (and will never be) any range checking on this method.
      inline const T& operator[] (uint i) const  { LZHAM_ASSERT(i < m_size); return m_p[i]; }
      inline       T& operator[] (uint i)        { LZHAM_ASSERT(i < m_size); return m_p[i]; }

      // at() always includes range checking, even in final builds, unlike operator [].
      // The first element is returned if the index is out of range.
      inline const T& at(uint i) const  { LZHAM_ASSERT(i < m_size); return (i >= m_size) ? m_p[0] : m_p[i]; }
      inline       T& at(uint i)        { LZHAM_ASSERT(i < m_size); return (i >= m_size) ? m_p[0] : m_p[i]; }

      inline const T& front() const  { LZHAM_ASSERT(m_size); return m_p[0]; }
      inline       T& front()        { LZHAM_ASSERT(m_size); return m_p[0]; }

      inline const T& back() const  { LZHAM_ASSERT(m_size); return m_p[m_size - 1]; }
      inline       T& back()        { LZHAM_ASSERT(m_size); return m_p[m_size - 1]; }

      inline const   T* get_ptr() const   { return m_p; }
      inline         T* get_ptr()         { return m_p; }

      inline void clear()
      {
         if (m_p)
         {
            scalar_type<T>::destruct_array(m_p, m_size);
            lzham_free(m_malloc_context, m_p);
            m_p = NULL;
            m_size = 0;
            m_capacity = 0;
         }
      }

      inline void clear_no_destruction()
      {
         if (m_p)
         {
            lzham_free(m_malloc_context, m_p);
            m_p = NULL;
            m_size = 0;
            m_capacity = 0;
         }
      }

      inline bool try_reserve(uint new_capacity)
      {
         return increase_capacity(new_capacity, true, true);
      }

      inline bool try_resize(uint new_size, bool grow_hint = false)
      {
         if (m_size != new_size)
         {
            if (new_size < m_size)
               scalar_type<T>::destruct_array(m_p + new_size, m_size - new_size);
            else
            {
               if (new_size > m_capacity)
               {
                  if (!increase_capacity(new_size, (new_size == (m_size + 1)) || grow_hint, true))
                  {
                     LZHAM_LOG_ERROR(5004);
                     return false;
                  }
               }

               scalar_type<T>::construct_array(m_p + m_size, new_size - m_size);
            }

            m_size = new_size;
         }

         return true;
      }
      
      inline bool try_resize_no_construct(uint new_size, bool grow_hint = false)
      {
         if (new_size > m_capacity)
         {
            if (!increase_capacity(new_size, (new_size == (m_size + 1)) || grow_hint, true))
            {
               LZHAM_LOG_ERROR(5005);
               return false;
            }
         }
         
         m_size = new_size;

         return true;
      }

      inline T* try_enlarge(uint i)
      {
         uint cur_size = m_size;
         if (!try_resize(cur_size + i, true))
         {
            LZHAM_LOG_ERROR(5006);
            return NULL;
         }
         return get_ptr() + cur_size;
      }

      inline bool try_push_back(const T& obj)
      {
         LZHAM_ASSERT(!m_p || (&obj < m_p) || (&obj >= (m_p + m_size)));

         if (m_size >= m_capacity)
         {
            if (!increase_capacity(m_size + 1, true, true))
            {
               LZHAM_LOG_ERROR(5007);
               return false;
            }
         }

         scalar_type<T>::construct(m_p + m_size, obj);
         m_size++;

         return true;
      }

      inline void pop_back()
      {
         LZHAM_ASSERT(m_size);

         if (m_size)
         {
            m_size--;
            scalar_type<T>::destruct(&m_p[m_size]);
         }
      }

      inline bool insert(uint index, const T* p, uint n)
      {
         LZHAM_ASSERT(index <= m_size);
         if (!n)
            return true;
                  
         const uint orig_size = m_size;
         if (!try_resize(m_size + n, true))
            return false;

         const uint num_to_move = orig_size - index;
         if (num_to_move)
         {
            if (LZHAM_IS_BITWISE_COPYABLE(T))
               memmove(m_p + index + n, m_p + index, sizeof(T) * num_to_move);
            else
            {
               const T* pSrc = m_p + orig_size - 1;
               T* pDst = const_cast<T*>(pSrc) + n;

               for (uint i = 0; i < num_to_move; i++)
               {
                  LZHAM_ASSERT((pDst - m_p) < (int)m_size);
                  *pDst-- = *pSrc--;
               }
            }
         }

         T* pDst = m_p + index;

         if (LZHAM_IS_BITWISE_COPYABLE(T))
            memcpy(pDst, p, sizeof(T) * n);
         else
         {
            for (uint i = 0; i < n; i++)
            {
               LZHAM_ASSERT((pDst - m_p) < (int)m_size);
               *pDst++ = *p++;
            }
         }

         return true;
      }

      // push_front() isn't going to be very fast - it's only here for usability.
      inline bool try_push_front(const T& obj)
      {
         return insert(0, &obj, 1);
      }

      bool append(const vector& other)
      {
         if (other.m_size)
            return insert(m_size, &other[0], other.m_size);
         return true;
      }

      bool append(const T* p, uint n)
      {
         if (n)
            return insert(m_size, p, n);
         return true;
      }

      inline void erase(uint start, uint n)
      {
         LZHAM_ASSERT((start + n) <= m_size);
         if ((start + n) > m_size)
            return;

         if (!n)
            return;

         const uint num_to_move = m_size - (start + n);

         T* pDst = m_p + start;

         const T* pSrc = m_p + start + n;

         if (LZHAM_IS_BITWISE_COPYABLE(T))
            memmove(pDst, pSrc, num_to_move * sizeof(T));
         else
         {
            T* pDst_end = pDst + num_to_move;

            while (pDst != pDst_end)
               *pDst++ = *pSrc++;

            scalar_type<T>::destruct_array(pDst_end, n);
         }

         m_size -= n;
      }

      inline void erase(uint index)
      {
         erase(index, 1);
      }

      inline void erase(T* p)
      {
         LZHAM_ASSERT((p >= m_p) && (p < (m_p + m_size)));
         erase(static_cast<uint>(p - m_p));
      }

      void erase_unordered(uint index)
      {
         LZHAM_ASSERT(index < m_size);

         if ((index + 1) < m_size)
            (*this)[index] = back();

         pop_back();
      }

      inline bool operator== (const vector& rhs) const
      {
         if (m_size != rhs.m_size)
            return false;
         else if (m_size)
         {
            if (scalar_type<T>::cFlag)
               return memcmp(m_p, rhs.m_p, sizeof(T) * m_size) == 0;
            else
            {
               const T* pSrc = m_p;
               const T* pDst = rhs.m_p;
               for (uint i = m_size; i; i--)
                  if (!(*pSrc++ == *pDst++))
                     return false;
            }
         }

         return true;
      }

      inline bool operator< (const vector& rhs) const
      {
         const uint min_size = math::minimum(m_size, rhs.m_size);

         const T* pSrc = m_p;
         const T* pSrc_end = m_p + min_size;
         const T* pDst = rhs.m_p;

         while ((pSrc < pSrc_end) && (*pSrc == *pDst))
         {
            pSrc++;
            pDst++;
         }

         if (pSrc < pSrc_end)
            return *pSrc < *pDst;

         return m_size < rhs.m_size;
      }

      inline void swap(vector& other)
      {
         utils::swap(m_p, other.m_p);
         utils::swap(m_size, other.m_size);
         utils::swap(m_capacity, other.m_capacity);
      }

      inline void sort()
      {
         std::sort(begin(), end());
      }

      inline void unique()
      {
         if (!empty())
         {
            sort();

            resize(std::unique(begin(), end()) - begin());
         }
      }

      inline void reverse()
      {
         uint j = m_size >> 1;
         for (uint i = 0; i < j; i++)
            utils::swap(m_p[i], m_p[m_size - 1 - i]);
      }

      inline int find(const T& key) const
      {
         const T* p = m_p;
         const T* p_end = m_p + m_size;

         uint index = 0;

         while (p != p_end)
         {
            if (key == *p)
               return index;

            p++;
            index++;
         }

         return cInvalidIndex;
      }

      inline int find_sorted(const T& key) const
      {
         if (m_size)
         {
            // Uniform binary search - Knuth Algorithm 6.2.1 U, unrolled twice.
            int i = ((m_size + 1) >> 1) - 1;
            int m = m_size;

            for ( ; ; )
            {
               LZHAM_ASSERT_OPEN_RANGE(i, 0, (int)m_size);
               const T* pKey_i = m_p + i;
               int cmp = key < *pKey_i;
               if ((!cmp) && (key == *pKey_i)) return i;
               m >>= 1;
               if (!m) break;
               cmp = -cmp;
               i += (((m + 1) >> 1) ^ cmp) - cmp;
               if (i < 0)
                  break;

               LZHAM_ASSERT_OPEN_RANGE(i, 0, (int)m_size);
               pKey_i = m_p + i;
               cmp = key < *pKey_i;
               if ((!cmp) && (key == *pKey_i)) return i;
               m >>= 1;
               if (!m) break;
               cmp = -cmp;
               i += (((m + 1) >> 1) ^ cmp) - cmp;
               if (i < 0)
                  break;
            }
         }

         return cInvalidIndex;
      }

      template<typename Q>
      inline int find_sorted(const T& key, Q less_than) const
      {
         if (m_size)
         {
            // Uniform binary search - Knuth Algorithm 6.2.1 U, unrolled twice.
            int i = ((m_size + 1) >> 1) - 1;
            int m = m_size;

            for ( ; ; )
            {
               LZHAM_ASSERT_OPEN_RANGE(i, 0, (int)m_size);
               const T* pKey_i = m_p + i;
               int cmp = less_than(key, *pKey_i);
               if ((!cmp) && (!less_than(*pKey_i, key))) return i;
               m >>= 1;
               if (!m) break;
               cmp = -cmp;
               i += (((m + 1) >> 1) ^ cmp) - cmp;
               if (i < 0)
                  break;

               LZHAM_ASSERT_OPEN_RANGE(i, 0, (int)m_size);
               pKey_i = m_p + i;
               cmp = less_than(key, *pKey_i);
               if ((!cmp) && (!less_than(*pKey_i, key))) return i;
               m >>= 1;
               if (!m) break;
               cmp = -cmp;
               i += (((m + 1) >> 1) ^ cmp) - cmp;
               if (i < 0)
                  break;
            }
         }

         return cInvalidIndex;
      }

      inline uint count_occurences(const T& key) const
      {
         uint c = 0;

         const T* p = m_p;
         const T* p_end = m_p + m_size;

         while (p != p_end)
         {
            if (key == *p)
               c++;

            p++;
         }

         return c;
      }

      inline void set_all(const T& o)
      {
         if ((sizeof(T) == 1) && (scalar_type<T>::cFlag))
            memset(m_p, *reinterpret_cast<const uint8*>(&o), m_size);
         else
         {
            T* pDst = m_p;
            T* pDst_end = pDst + m_size;
            while (pDst != pDst_end)
               *pDst++ = o;
         }
      }

   private:
      T*       m_p;
      uint     m_size;
      uint     m_capacity;
      lzham_malloc_context m_malloc_context;

      template<typename Q> struct is_vector { enum { cFlag = false }; };
      template<typename Q> struct is_vector< vector<Q> > { enum { cFlag = true }; };

      static void object_mover(void* pDst_void, void* pSrc_void, uint num)
      {
         T* pSrc = static_cast<T*>(pSrc_void);
         T* const pSrc_end = pSrc + num;
         T* pDst = static_cast<T*>(pDst_void);

         while (pSrc != pSrc_end)
         {
            new (static_cast<void*>(pDst)) T(*pSrc);
            pSrc->~T();
            pSrc++;
            pDst++;
         }
      }

      inline bool increase_capacity(uint min_new_capacity, bool grow_hint, bool nofail = false)
      {
         return reinterpret_cast<elemental_vector*>(this)->increase_capacity(
            min_new_capacity, grow_hint, sizeof(T),
            (LZHAM_IS_BITWISE_MOVABLE(T) || (is_vector<T>::cFlag)) ? NULL : object_mover, nofail);
      }
   };

   template<typename T> struct bitwise_movable< vector<T> > { enum { cFlag = true }; };

   extern void vector_test();

   template<typename T>
   inline void swap(vector<T>& a, vector<T>& b)
   {
      a.swap(b);
   }

} // namespace lzham

﻿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{8DA0CD32-701D-48D7-AE92-728338501500}</ProjectGuid>
    <RootNamespace>lzhamdecomp</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)lib\x86D\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)lib\x64D\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)lib\x86\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)lib\x64\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_x64D</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_x86D</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x86D.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x64D.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>Full</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <AdditionalIncludeDirectories>..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x86.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Full</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <AdditionalIncludeDirectories>..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <FloatingPointModel>Fast</FloatingPointModel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x64.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="lzham_assert.cpp" />
    <ClCompile Include="lzham_checksum.cpp" />
    <ClCompile Include="lzham_huffman_codes.cpp" />
    <ClCompile Include="lzham_lzdecomp.cpp" />
    <ClCompile Include="lzham_lzdecompbase.cpp" />
    <ClCompile Include="lzham_mem.cpp" />
    <ClCompile Include="lzham_platform.cpp" />
    <ClCompile Include="lzham_prefix_coding.cpp" />
    <ClCompile Include="lzham_symbol_codec.cpp" />
    <ClCompile Include="lzham_timer.cpp" />
    <ClCompile Include="lzham_vector.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lzham_assert.h" />
    <ClInclude Include="lzham_checksum.h" />
    <ClInclude Include="lzham_config.h" />
    <ClInclude Include="lzham_core.h" />
    <ClInclude Include="lzham_decomp.h" />
    <ClInclude Include="lzham_helpers.h" />
    <ClInclude Include="lzham_huffman_codes.h" />
    <ClInclude Include="lzham_lzdecompbase.h" />
    <ClInclude Include="lzham_math.h" />
    <ClInclude Include="lzham_mem.h" />
    <ClInclude Include="lzham_platform.h" />
    <ClInclude Include="lzham_prefix_coding.h" />
    <ClInclude Include="lzham_symbol_codec.h" />
    <ClInclude Include="lzham_timer.h" />
    <ClInclude Include="lzham_traits.h" />
    <ClInclude Include="lzham_types.h" />
    <ClInclude Include="lzham_utils.h" />
    <ClInclude Include="lzham_vector.h" />
    <ClInclude Include="..\include\lzham.h" />
    <ClInclude Include="..\include\lzham_dynamic_lib.h" />
    <ClInclude Include="..\include\lzham_static_lib.h" />
    <ClInclude Include="..\include\zlib.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\include\lzham_exports.inc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>// File: lzham_lib.cpp - Static library entrypoints.
// See Copyright Notice and license at the end of include/lzham.h
#include "lzham_core.h"
#include "lzham_decomp.h"
#include "lzham_comp.h"

extern "C" lzham_uint32 LZHAM_CDECL lzham_get_version(void)
{
   return LZHAM_DLL_VERSION;
}

extern "C" void LZHAM_CDECL lzham_set_memory_callbacks(lzham_realloc_func pRealloc, lzham_msize_func pMSize, void* pUser_data)
{
   lzham::lzham_lib_set_memory_callbacks(pRealloc, pMSize, pUser_data);
}

extern "C" lzham_decompress_state_ptr LZHAM_CDECL lzham_decompress_init(const lzham_decompress_params *pParams)
{
   return lzham::lzham_lib_decompress_init(pParams);
}

extern "C" lzham_decompress_state_ptr LZHAM_CDECL lzham_decompress_reinit(lzham_decompress_state_ptr p, const lzham_decompress_params *pParams)
{
   return lzham::lzham_lib_decompress_reinit(p, pParams);
}

extern "C" lzham_uint32 LZHAM_CDECL lzham_decompress_deinit(lzham_decompress_state_ptr p)
{
   return lzham::lzham_lib_decompress_deinit(p);
}

extern "C" lzham_decompress_status_t LZHAM_CDECL lzham_decompress(
   lzham_decompress_state_ptr p,
   const lzham_uint8 *pIn_buf, size_t *pIn_buf_size, 
   lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
   lzham_bool no_more_input_bytes_flag)
{
   return lzham::lzham_lib_decompress(p, pIn_buf, pIn_buf_size, pOut_buf, pOut_buf_size, no_more_input_bytes_flag);
}   

extern "C" lzham_decompress_status_t LZHAM_CDECL lzham_decompress_memory(const lzham_decompress_params *pParams, lzham_uint8* pDst_buf, size_t *pDst_len, const lzham_uint8* pSrc_buf, size_t src_len, lzham_uint32 *pAdler32)
{
   return lzham::lzham_lib_decompress_memory(pParams, pDst_buf, pDst_len, pSrc_buf, src_len, pAdler32);
}

extern "C" lzham_compress_state_ptr LZHAM_CDECL lzham_compress_init(const lzham_compress_params *pParams)
{
   return lzham::lzham_lib_compress_init(pParams);
}

extern "C" lzham_compress_state_ptr LZHAM_CDECL lzham_compress_reinit(lzham_compress_state_ptr p)
{
   return lzham::lzham_lib_compress_reinit(p);
}

extern "C" lzham_uint32 LZHAM_CDECL lzham_compress_deinit(lzham_compress_state_ptr p)
{
   return lzham::lzham_lib_compress_deinit(p);
}

extern "C" lzham_compress_status_t LZHAM_CDECL lzham_compress(
   lzham_compress_state_ptr p,
   const lzham_uint8 *pIn_buf, size_t *pIn_buf_size, 
   lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
   lzham_bool no_more_input_bytes_flag)
{
   return lzham::lzham_lib_compress(p, pIn_buf, pIn_buf_size, pOut_buf, pOut_buf_size, no_more_input_bytes_flag);
}   

extern "C" lzham_compress_status_t LZHAM_CDECL lzham_compress2(
   lzham_compress_state_ptr p,
   const lzham_uint8 *pIn_buf, size_t *pIn_buf_size, 
   lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
   lzham_flush_t flush_type)
{
   return lzham::lzham_lib_compress2(p, pIn_buf, pIn_buf_size, pOut_buf, pOut_buf_size, flush_type);
}   

extern "C" lzham_compress_status_t LZHAM_CDECL lzham_compress_memory(const lzham_compress_params *pParams, lzham_uint8* pDst_buf, size_t *pDst_len, const lzham_uint8* pSrc_buf, size_t src_len, lzham_uint32 *pAdler32)
{
   return lzham::lzham_lib_compress_memory(pParams, pDst_buf, pDst_len, pSrc_buf, src_len, pAdler32);
}

// ----------------- zlib-style API's

extern "C" const char * LZHAM_CDECL lzham_z_version(void)
{
   return LZHAM_Z_VERSION;
}

extern "C" lzham_z_ulong LZHAM_CDECL lzham_z_adler32(lzham_z_ulong adler, const unsigned char *ptr, size_t buf_len)
{
   return lzham::lzham_lib_z_adler32(adler, ptr, buf_len);
}

extern "C" lzham_z_ulong LZHAM_CDECL lzham_z_crc32(lzham_z_ulong crc, const lzham_uint8 *ptr, size_t buf_len)
{
   return lzham::lzham_lib_z_crc32(crc, ptr, buf_len);
}

extern "C" int LZHAM_CDECL lzham_z_deflateInit(lzham_z_streamp pStream, int level)
{
   return lzham::lzham_lib_z_deflateInit(pStream, level);
}

extern "C" int LZHAM_CDECL lzham_z_deflateInit2(lzham_z_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
{
   return lzham::lzham_lib_z_deflateInit2(pStream, level, method, window_bits, mem_level, strategy);
}

extern "C" int LZHAM_CDECL lzham_z_deflateReset(lzham_z_streamp pStream)
{
   return lzham::lzham_lib_z_deflateReset(pStream);
}

extern "C" int LZHAM_CDECL lzham_z_deflate(lzham_z_streamp pStream, int flush)
{
   return lzham::lzham_lib_z_deflate(pStream, flush);
}

extern "C" int LZHAM_CDECL lzham_z_deflateEnd(lzham_z_streamp pStream)
{
   return lzham::lzham_lib_z_deflateEnd(pStream);
}

extern "C" lzham_z_ulong LZHAM_CDECL lzham_z_deflateBound(lzham_z_streamp pStream, lzham_z_ulong source_len)
{
   return lzham::lzham_lib_z_deflateBound(pStream, source_len);
}

extern "C" int LZHAM_CDECL lzham_z_compress(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len)
{
   return lzham::lzham_lib_z_compress(pDest, pDest_len, pSource, source_len);
}

extern "C" int LZHAM_CDECL lzham_z_compress2(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len, int level)
{
   return lzham::lzham_lib_z_compress2(pDest, pDest_len, pSource, source_len, level);
}

extern "C" lzham_z_ulong LZHAM_CDECL lzham_z_compressBound(lzham_z_ulong source_len)
{
   return lzham::lzham_lib_z_compressBound(source_len);
}

extern "C" int LZHAM_CDECL lzham_z_inflateInit(lzham_z_streamp pStream)
{
   return lzham::lzham_lib_z_inflateInit(pStream);
}

extern "C" int LZHAM_CDECL lzham_z_inflateInit2(lzham_z_streamp pStream, int window_bits)
{
   return lzham::lzham_lib_z_inflateInit2(pStream, window_bits);
}

extern "C" int LZHAM_CDECL lzham_z_inflateReset(lzham_z_streamp pStream)
{
   return lzham::lzham_lib_z_inflateReset(pStream);
}

extern "C" int LZHAM_CDECL lzham_z_inflate(lzham_z_streamp pStream, int flush)
{
   return lzham::lzham_lib_z_inflate(pStream, flush);
}

extern "C" int LZHAM_CDECL lzham_z_inflateEnd(lzham_z_streamp pStream)
{
   return lzham::lzham_lib_z_inflateEnd(pStream);
}

extern "C" int LZHAM_CDECL lzham_z_uncompress(unsigned char *pDest, lzham_z_ulong *pDest_len, const unsigned char *pSource, lzham_z_ulong source_len)
{
   return lzham::lzham_lib_z_uncompress(pDest, pDest_len, pSource, source_len);
}

extern "C" const char * LZHAM_CDECL lzham_z_error(int err)
{
   return lzham::lzham_lib_z_error(err);
}
﻿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{83A2F0B5-1D02-4A13-B579-714F60E31774}</ProjectGuid>
    <RootNamespace>lzhamlib</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v100</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)lib\x86D\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)lib\x86\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)lib\x64D\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)lib\x64\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_x64D</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_x86D</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\include;..\lzhamdecomp;..\lzhamcomp;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x86D.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>Full</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <AdditionalIncludeDirectories>..\include;..\lzhamdecomp;..\lzhamcomp;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x86.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\include;..\lzhamdecomp;..\lzhamcomp;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)$(ProjectName)_x64D.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Full</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <AdditionalIncludeDirectories>..\include;..\lzhamdecomp;..\lzhamcomp;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>
      </ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <FloatingPointModel>Fast</FloatingPointModel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Warnin